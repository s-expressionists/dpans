*start*35509 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 FEB 89 14:49:51 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 24 Feb 89  14:45:40 PSTReceived: from fafnir.think.com by Think.COM; Fri, 24 Feb 89 17:41:46 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 24 Feb 89 17:39:54 ESTReceived: by verdi.think.com; Fri, 24 Feb 89 17:40:25 ESTDate: Fri, 24 Feb 89 17:40:25 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8902242240.AA10382@verdi.think.com>To: cl-cleanup@sail.stanford.eduSubject: PRETTY-PRINT-INTERFACEIssue:		PRETTY-PRINT-INTERFACEReferences:	Description of XP by Dick Waters (attached)		*PRINT-PRETTY* (CLtL p. 371)		WRITE (CLtL p. 382)		PPRINT (CLtL p. 383)		FORMAT (CLtL pp. 385-407)		FORMAT ~T directive (CLtL pp. 398-399)		FORMAT ~< directive (CLtL pp. 404-406)Related issues: Category:	CLARIFICATION CHANGE ADDITIONEdit history:	Version 1, 24-Feb-89 by SteeleProblem description:At present Common Lisp provides no specification whatsoever of howpretty-printing is to be accomplished, and no way for the user to controlit.  In particular, there is no protocol by which a user can write aprint-function for a structure, or a method for PRINT-OBJECT, that willinteract smoothly with the built-in pretty-printer in a portable manner.Proposal (PRETTY-PRINT-INTERFACE:XP):Adopt the interfaces and protocols of the XP pretty-printer by Dick Waters,described in full in the attached 12-page document.  Here is a very briefsummary of the proposal.New variables:	*PRINT-DISPATCH*		*PRINT-RIGHT-MARGIN*		*DEFAULT-RIGHT-MARGIN*		*PRINT-MISER-WIDTH*		*PRINT-LINES*		*LAST-ABBREVIATED-PRINTING*New function:	COPY-PRINT-DISPATCHNew macro:	DEFINE-PRINT-DISPATCHNew FORMAT directives:	~W  ~_  ~I  ~:T  ~/name/  ~<...~:>New # reader macro:  #"..."The function WRITE is extended to accept additional keyword arguments:DISPATCH, :RIGHT-MARGIN, :LINES, and :MISER-WIDTH corresponding to thefirst four of the new variables.Examples:	See attached document.Rationale:There ought to be a good user interface to the pretty printer.This is the only proposal for which there is a portable implementationthat has seen extensive use and is being made freely available.Current practice:XP son of PP son of GPRINT son of PRINT* is the latest in a line of prettyprinters that goes back 13 years.  All of these printers use essentiallythe same basic algorithm and conceptual interface.  Further, except forPRINT*, which was implemented solely to satisfy the author's personalneeds, each of these printers has had extensive use.  XP has been inexperimental use as the pretty printer in CMU Common Lisp for 6 months.  PPhas been the pretty printer in DEC Common Lisp for the past 3 years.  Priorto three years ago, GPRINT was used for 2 years as the pretty printer inDEC Common Lisp.  In addition, GPRINT has been the pretty printer invarious generations of Symbolics Lisp for upwards of 5 years.(See Waters R.C., "User Format Control in a Lisp Prettyprinter", ACM TOPLAS,5(4):513--531, October 1983.)Cost to Implementors:A fair amount of effort (perhaps a few man-weeks at most).Source code for XP is available to all comers from Dick Waters, andthe system is documented in great detail:Waters, Richard C., "XP: A Common Lisp Pretty Printing System",Artificial Intelligence Laboratory Technical Memo 1102,Massachusetts Institute of Technology, Cambridge MA, March 1989.Cost to Users:  None (I think).  This is an upward-compatible extension.Cost of non-adoption:  Continued inability for user print-functionsto interact with the pretty-printer in a useful and portable manner.Performance impact:  XP is claimed to be quite fast.Benefits:  User control of pretty-printing in a portable manner.Esthetics:Using ~<...~:> may strike some as uncomfortably close in the syntacticspace of FORMAT directives to the existing ~<...~>.  However, it is veryunlikely that both of these directives (pretty-print logical block andcolumnar justification, respectively) will be used in the same call toFORMAT.  Previous versions of XP used ~!...~. instead of ~<...~:> but thismade FORMAT strings very difficult to read; it is preferable to havea directive that looks like matching brackets of some sort.Discussion:Zetalisp used ~:T to mean pixelwise tabulation, so the use of ~:Tsuggested here may be a problem.  If so, another suggestion for namingthis directive would be appropriate.The ~/.../ directive is already in Zetalisp, and is not an idea newto this proposal.Guy Steele and Dick Waters strongly support this proposal.  (As an example,Guy Steele has a portable simulator for Connection Machine Lisp, and wouldlike very much to have xappings and xectors pretty-print properly.)!			   Pretty Printing			  Richard C. WatersPretty printing has traditionally been a black box process, displayingprogram code using a set of fixed layout rules.  Its utility can be greatlyenhanced by opening it up to user control.By providing direct access to the mechanisms within the pretty printer thatmake dynamic decisions about layout, the FORMAT directives ~_, ~I, and~<...~:> make it possible to specify pretty printing layout rules as a partof any function that produces output.  They also make it very easy forcircularity detection and abbreviation based on length and nesting depth tobe supported by the function.  The construct DEFINE-PRINT-DISPATCH makes itpossible to associate a user-defined pretty printing function with any typeof object.  Together, these facilities enable users to redefine the waycode is displayed and allow the full power of pretty printing to be appliedto complex combinations of data structures.		  Pretty Printing Control Variables*PRINT-DISPATCH*                                                 [variable]When *PRINT-PRETTY* is not NIL, the print dispatch table in*PRINT-DISPATCH* controls the way objects are printed.  The initial valueof *PRINT-DISPATCH* causes traditional pretty printing of Lisp code.*PRINT-RIGHT-MARGIN*                                             [variable]*DEFAULT-RIGHT-MARGIN*                                           [variable]The goal of dynamic layout decisions (when pretty printing or when directlyspecified via ~_, ~I, and ~<...~:>) is to keep the output between a pair ofmargins.  The left margin is set at the column where the output begins.  Ifthis cannot be determined, the left margin is set to zero.When *PRINT-RIGHT-MARGIN* is not NIL, it specifies the right margin to usewhen making layout decisions.  When *PRINT-RIGHT-MARGIN* is NIL (theinitial value), the right margin is set at the maximum line length that canbe displayed by the output stream without wraparound or truncation.  Ifthis cannot be determined, the right margin is set to*DEFAULT-RIGHT-MARGIN*.  The initial value of *DEFAULT-RIGHT-MARGIN* isimplementation-dependent.*PRINT-MISER-WIDTH*                                              [variable]If *PRINT-MISER-WIDTH* is not NIL, the pretty printer switches to a compactstyle of output (called miser style) whenever the width available forprinting a substructure is less than or equal to *PRINT-MISER-WIDTH*.  Theinitial value of *PRINT-MISER-WIDTH* is implementation-dependent.!*PRINT-LINES*                                                    [variable]When given a value other than its initial value of NIL, *PRINT-LINES*limits the number of output lines produced when something is printed.  Ifan attempt is made to go beyond *PRINT-LINES* lines, " ---" is printed atthe end of the last line and printing stops.(let ((*print-right-margin* 20) (*print-lines* 3))  (pprint '(setq a 1 b 2 c 3 d 4)))(SETQ A 1      B 2      C 3 ---*LAST-ABBREVIATED-PRINTING*                                      [variable]This variable records the last printing event where abbreviation occurred.Funcalling its value (e.g., after turning off abbreviation) causes theprinting to happen a second time.The function WRITE accepts keyword arguments :DISPATCH, :RIGHT-MARGIN,:LINES, and :MISER-WIDTH corresponding to *PRINT-DISPATCH*,*PRINT-RIGHT-MARGIN*, *PRINT-LINES*, and *PRINT-MISER-WIDTH*.		   Compiling Format Control StringsThe control strings used by FORMAT are essentially programs that performprinting.  The readmacro character #"..." provides the efficiency of usinga compiled function for printing without losing the conciseness of FORMATcontrol strings.  In the notation #"...", the string following # isidentical to a FORMAT control string.  However, the readmacro translates itinto an equivalent sharp-quoted function.  The first expression below isequivalent to the second.#"~%~@{~S~^, ~}"#'(lambda (stream &rest args)    (terpri stream)    (loop (prin1 (pop args) stream)          (if (null args) (return nil))          (write-string ", " stream)))In support of the above, FORMAT accepts functions as its second argument aswell as strings.  When a function is provided, it is called with theappropriate output stream as its first argument and the data arguments toFORMAT as its remaining arguments.  The function should perform whateveroutput is necessary.  The values returned by the function are ignored.  Thedirective ~? also accepts functions as well as control strings.!	     Dynamic Control of the Arrangement of OutputThe following FORMAT directives support precise control of what should bedone when a piece of output is too large to fit in the space available.Three concepts underlie the way these directives work---`logical blocks',`conditional newlines', and `sections'.The first line of Figure 1 shows a schematic piece of output.  Thecharacters in the output are represented by "-".  The positions ofconditional newlines are indicated by digits.  The beginnings and ends oflogical blocks are indicated by "<" and ">" respectively.The output as a whole is a logical block and the outermost section.  Thissection is indicated by the 0's on the second line of Figure 1.  Logicalblocks nested within the output are specified by ~<...~:> directives.Conditional newline positions are specified by ~_ directives.  Eachconditional newline defines two sections (one before it and one after it)and is associated with a third (the section immediately containing it).The section after a conditional newline consists of: all the output up to,but not including, (a) the next conditional newline immediately containedin the same logical block; or if (a) is not applicable, (b) the nextnewline that is at a lesser level of nesting in logical blocks; or if (b)is not applicable, (c) the end of the output.The section before a conditional newline consists of: all the output backto, but not including, (a) the previous conditional newline that isimmediately contained in the same logical block; or if (a) is notapplicable, (b) the beginning of the immediately containing logical block.The last four lines in Figure 1 indicate the sections before and after thefour conditional newlines.The section immediately containing a conditional newline is the shortestsection that contains the conditional newline in question.  In Figure 1,the first conditional newline is immediately contained in the sectionmarked with 0's, the second and third conditional newlines are immediatelycontained in the section before the fourth conditional newline, and thefourth conditional newline is immediately contained in the section afterthe first conditional newline.                 <-1---<--<--2---3->--4-->->                 000000000000000000000000000                 11 111111111111111111111111                           22 222                              333 3333                        44444444444444 44444Figure 1: Example of logical blocks, conditional newlines, and sections.Whenever possible, the pretty printer displays the entire contents of asection on a single line.  However, if the section is too long to fit inthe space available, line breaks are inserted at conditional newlinepositions within the section.!~W                                                          [format directive]WRITE -- An arg, any Lisp object, is printed obeying every printer controlvariable (as by WRITE).  In addition, ~W interacts correctly with depthabbreviation, by not resetting the depth counter to zero.  ~W does notaccept parameters.  If given the colon modifier, ~W binds *PRINT-PRETTY* toT.  If given the atsign modifier, ~W binds *PRINT-LEVEL* and *PRINT-LENGTH*to NIL.~W provides automatic support for circularity detection.  If *PRINT-CIRCLE*is T and ~W is applied to an argument that has already been encounteredduring the printing process, an appropriate #n# marker is inserted in theoutput instead of printing the argument.Circularity detection is supported by effectively doing the printing twice.On the first pass, circularities are detected and the actual outputting ofcharacters is suppressed.  On the second pass, the appropriate #n= and #n#markers are inserted and characters are output.~_                                                          [format directive]CONDITIONAL NEWLINE -- Without any modifiers, ~_ specifies a`linear-style' conditional newline.  A line break is inserted if and onlyif the immediately containing section cannot be printed on one line.  Theeffect of this is that line breaks are either inserted at everylinear-style conditional newline in a logical block or at none of them.~@_ specifies a `miser-style' conditional newline.  A line break isinserted if and only if the immediately containing section cannot beprinted on one line and miser style is in effect in the immediatelycontaining logical block.  The effect of this is that miser-styleconditional newlines act like linear-style conditional newlines, but onlywhen miser style is in effect.  Miser style is in effect for a logicalblock if and only if the the starting column of the logical block is lessthan or equal to *PRINT-MISER-WIDTH* columns from the right margin.~:_ specifies a `fill-style' conditional newline.  A line break isinserted if and only if either (a) the following section cannot be printedon the end of the current line, (b) the preceding section was not printedon a single line, or (c) the immediately containing section cannot beprinted on one line and miser style is in effect in the immediatelycontaining logical block.  If a logical block is broken up into a numberof subsections by fill-style conditional newlines, the basic effect isthat the logical block is printed with as many subsections as possible oneach line.  However, if miser style is in effect, fill-style conditionalnewlines act like linear-style conditional newlines.~:@_ specifies a `mandatory-style' conditional newline.  A line break isalways inserted.  This implies that none of the containing sections can beprinted on a single line and will therefore trigger the insertion of linebreaks at linear-style conditional newlines in these sections.When a line break is inserted by any type of conditional newline, anyblanks that immediately precede the conditional newline are omitted fromthe output and indentation is introduced at the beginning of the next line.By default, the indentation causes the following line to begin in the samecolumn as the first character in the immediately containing logical block.The indentation can be changed via ~I.There are a variety of ways unconditional newlines can be introduced intothe output (e.g., via ~% or by printing a string containing a newlinecharacter).  As with mandatory conditional newlines, this prevents any ofthe containing sections from being printed on one line.  In general, whenan unconditional newline is encountered, it is printed out withoutsuppression of the preceding blanks and without any indentation followingit.  However, if a per-line prefix has been specified (see ~<...~:>), thisprefix will always be printed no matter how a newline originates.!~<...~:>                                                    [format directive]LOGICAL BLOCK -- If ~:> is used to terminate a ~<...~>, the directivedelimits a logical block.  In addition, ~<...~:> descends into thecorresponding FORMAT argument (a list) in the same way as the directive~1{...~:}.  ~^ can be used to exit from ~<...~:> just as it can be used toexit from ~{...~}.The portion of a FORMAT control string enclosed in ~<...~:> can be dividedinto segments ~<prefix~;body~;suffix~:> by ~; directives.  It is an errorfor the enclosed portion to be divided into more than three segments.  Ifthe enclosed portion is divided into only two segments, the suffix defaultsto the null string.  If the enclosed portion consists of only a singlesegment, both the prefix and the suffix default to the null string.  If thecolon modifier is used with ~<...~:>, the prefix and suffix default to "("and ")" (respectively) instead of to the null string.The prefix and suffix must both be constant strings.  They cannot containFORMAT directives.  The body can be any arbitrary FORMAT control string.The prefix is printed out just before the logical block is started and thesuffix is printed out just after the logical block ends.  This is done evenwhen the argument corresponding to ~<...~:> is an empty list.If ~<...~:> is applied to an argument that is not a list, the directive isignored (suppressing the output of the prefix and suffix) and the offendingargument is printed using ~W.  This makes it easier to write FORMAT stringsthat are robust in the face of malformed arguments.During the processing of the FORMAT string nested in ~<...~:>, argumentsare taken one by one from the list passed to ~<...~:>.  If an attempt ismade to access an argument at a time when the remaining portion of thisargument list is not a cons, then ". " is inserted in the output, ~W isused to print out the remaining argument list, and the processing of thelogical block is terminated, except for printing the suffix (if any).  Thismakes it easier to write FORMAT strings that are robust in the face ofmalformed argument lists.  (Note that ~^ exits only when the remainingargument list is NIL.)~<...~:> provides automatic support for depth abbreviation.  If*PRINT-LEVEL* is not NIL and ~<...~:> is encountered at a dynamic nestingdepth in logical blocks greater than *PRINT-LEVEL*, "#" is inserted in theoutput and the ~<...~:> and its associated argument are ignored.~<...~:> provides automatic support for length abbreviation.  If*PRINT-LENGTH* is not NIL, a count is kept of the number of arguments usedwithin the ~<...~:>.  If this count ever reaches *PRINT-LENGTH*, " ..." isinserted in the output and the processing of the logical block isterminated, except for printing the suffix (if any).~<...~:> also provides automatic support for circularity detection.  If*PRINT-CIRCLE* is T and ~<...~:> (without the atsign modifier) is appliedto a list argument that has already been encountered during the printingprocess, an appropriate #n# marker is inserted in the output and the~<...~:> and its associated argument are ignored.!In addition, if an attempt is made to access an argument from the listpassed to ~<...~:>, at a time when the remaining portion of this list hasalready been encountered during the printing process, ". #n#" is insertedin the output and the processing of the logical block is terminated, exceptfor printing the suffix (if any).  This catches instances of CDRcircularity in lists.For circularity detection to work correctly when printing an object, everypart of the object that is a cons must be printed using ~<...~:> and everynon-cons must be printed using ~W.  If some part is printed some other way(e.g., using ~S), circularities involving this part will be missed.If the atsign modifier is used with ~<...~:>, the entire remaining argumentlist is passed to the directive as its argument.  Unlike ~1@{...~} all ofthe remaining arguments are always consumed by ~@<...~:>, even if they arenot all used by the FORMAT string nested in the directive.As an example of the interaction of conditional newlines and logicalblocks, consider the following.  The FORMAT string specifies how to prettyprint a LET.  The outermost ~:<...~:> decomposes the input and specifiesthat parentheses should be printed in the output.  The~:<~@{~:<~@{~W~^~ _~}~:>~^ ~:_~}~:> decomposes the list of binding pairs.Each pair in the list is itself decomposed and printed using~:<~@{~W~^ ~_~}~:>.  (An iteration is used in this FORMAT string instead ofmerely decomposing the pair into two elements so that a malformed paircontaining more than two elements will print readably.)  A space and afill-style conditional newline are placed after each pair except the last.The ~@{~^~_ ~W~} prints out the forms in the body of the LET separated byspaces and linear-style conditional newlines.(format T #"~:<~W~^ ~:<~@{~:<~@{~W~^ ~_~}~:>~^ ~:_~}~:>~            ~@{~^~_ ~W~}~:>"        '#1=(let (x (*print-length* (f (g 3)))                   (z . 2) (k (car y)))              (setq x (sqrt z)) #1#))Suppose that *PRINT-PRETTY* is T, *PRINT-LEVEL* is 4, and *PRINT-CIRCLE* isT.  If the line length is greater than or equal to 77, the output producedby the FORMAT above appears on one line.  However, if the line length is76, line breaks are inserted at the linear-style conditional newlinesseparating the forms in the body and the output below is produced.  Notethat, the degenerate binding pair X is printed readably even though itfails to be a list; a depth abbreviation marker is printed in place of(G 3); the binding pair (Z . 2) is printed readably even though it failsto be a proper list; and appropriate circularity markers are printed.#1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y)))      (SETQ X (SQRT Z))     #1#)If the line length is reduced to 35, a line break is inserted at one of thefill-style conditional newlines separating the binding pairs.#1=(LET (X (*PRINT-PRETTY* (F #))         (Z . 2) (K (CAR Y)))     (SETQ X (SQRT Z))     #1#)!Suppose that the line length is further reduced to 22 and *PRINT-LENGTH* isset to 3. In this situation, line breaks are inserted after both the firstand second binding pairs.  In addition, the second binding pair is itselfbroken across two lines.  Clause (b) of the description of fill-styleconditional newlines prevents the binding pair (Z . 2) from being printedat the end of the third line.  Note that the length abbreviation hides thecircularity from view and therefore the printing of circularity markersdisappears as well.(LET (X      (*PRINT-LENGTH*       (F #))      (Z . 2) ...)  (SETQ X (SQRT Z))  ...)If ~@; is used to terminate the prefix in ~<...~:>, the prefix is a`per-line' prefix.  A per-line prefix is printed at the beginning of everyline in the logical block, rather than just before the start of the blockas a whole.  Each instance of the prefix is lined up below the occurrenceof the prefix on the first line.  With a line length of 25, the form belowproduces the output shown.(format T #"~<;;; ~@;Roads ~<= ~@;~W, ~:_~W~:>  ~:_ Town ~W~:>"           '((elm cottonwood) boston));;; Roads = ELM,;;;       = COTTONWOOD;;;  Town BOSTONIf ~<...~:> is terminated with ~:@>, then a fill-style conditional newlineis automatically inserted after each group of blanks immediately containedin the body (except for blanks after a ~<newline> directive).  This makesit easy to achieve the equivalent of paragraph filling.  With a line lengthof 12, the form below produces the output shown.(format T #"~<~:(~W~) street goes to ~:(~W~).~:@>"         '(main boston))Main streetgoes toBoston.To a considerable extent, the basic form of the directive ~<...~> isincompatible with the dynamic control of the arrangement of output by ~W,~_, ~<...~:>, ~I, and ~:T.  As a result, it is an error for any of thesedirectives to be nested within ~<...~>.  Beyond this, it is also an errorfor the ~<...~:;...~> form of ~<...~> to be used at all in conjunction withany of these directives.!~I                                                          [format directive]INDENT -- ~nI specifies that the indentation within the immediatelycontaining logical block should be set to the column position of the firstcharacter in the block plus n.  If omitted, n defaults to zero.  Theparameter can be negative; however, the total indentation cannot be movedleft of the beginning of the line or left of the end of the rightmostper-line prefix.  ~n:I is exactly the same as ~nI except that it operatesrelative to the position in the output of the directive itself, rather thanrelative to the first character in the block.  Changes in indentationcaused by a ~I directive do not take effect until after the next linebreak.  Consider the following example:(format T #"~:<~W ~@_~:I~W ~:_~W ~1I~_~W~:>"         '(defun prod (x y) (* x y)))If the line width available is 15, both the ~:_ and the ~_ are replaced byline breaks.  The ~:I directive before the ~W that prints the function namecauses the argument list to be lined up under the function name.  The ~1Idirective before the ~_ specifies that the statement in the body of theDEFUN should be printed at a relative indentation of 1 in the logicalblock.(DEFUN PROD       (X Y)  (* X Y))In miser style, all ~I directives are ignored, forcing the linescorresponding to the logical block to line up under the first character inthe block.  If *PRINT-MISER-WIDTH* were greater than or equal to 14 (theblock begins in the second column, after the prefix "(" IS printed), theexample output above would have been as follows.(DEFUN PROD (X Y) (* X Y))~:T                                                         [format directive]TABULATE -- If the colon modifier is used with the ~T directive, thetabbing computation is done relative to the column where the sectionimmediately containing the directive begins, rather than with respect tocolumn zero.  Consider the following example.  Each street name is followedby a ~8:T, which ensures that the total width taken up will be a multipleof 8.  With a line width of 25, the output shown is produced.(format T #"~<Roads ~:I~@_~@{~W~^~8:T~:_~}~:>"        '(elm main maple center))Roads ELM     MAIN      MAPLE   CENTER!~/name/                                                     [format directive]CALL FUNCTION -- User defined functions can be called from within a FORMATstring by using the directive ~/name/.  The colon modifier, the atsignmodifier, and arbitrarily many parameters can be specified with the ~/name/directive.  The name can contain a package prefix, but it cannot contain"/".  If the readmacro #"..." is used, the default package associated withname will be the value of *PACKAGE* at the moment the #"..." is read.  Ifan ordinary FORMAT control string is used, the default package will be thevalue of *PACKAGE* at the moment the string is processed by FORMAT.When a ~/name/ directive is encountered, the indicated function is calledwith four or more arguments.  The first four arguments are: the outputstream, the FORMAT argument corresponding to the directive, the value T ifthe colon modifier was used (NIL otherwise), and the value T if the atsignmodifier was used (NIL otherwise).  The remaining arguments consist of anyparameters specified with the directive.  The function should print theargument appropriately.  Any values returned by the function are ignored.~/LINEAR-STYLE/                                             [format directive]An argument, a list, is printed so that either all of the elements are onone line or each element is on a separate line.  Parentheses are printedaround the list if the colon modifier is specified.  As an example of afunction intended to be called from within a FORMAT string, the definitionof LINEAR-STYLE is shown below.(defun linear-style (stream list &optional (colon? T) atsign?)    (declare (ignore atsign?))  (if colon?      (format stream #"~:<~@{~W~^ ~_~}~:>" list)      (format stream #"~<~@{~W~^ ~_~}~:>" list)))~/FILL-STYLE/                                               [format directive]An argument, a list, is printed with as many elements as possible on eachline.  Parentheses are printed around the list if the colon modifier isspecified.~/TABULAR-STYLE/                                            [format directive]An argument, a list, is printed in a tabular form with as many elements aspossible on each line.  In addition to the colon modifier, which causesparentheses to be printed, ~/TABULAR-STYLE/ takes a parameter(default 16) that specifies the width of columns in the table.!			Print Dispatch TablesPretty printing is directed by print dispatch tables.COPY-PRINT-DISPATCH &optional (table *PRINT-DISPATCH*)           [function]A copy is made of table, which defaults to the current print dispatchtable.  If table is NIL, a copy is made of the initial print dispatchtable.DEFINE-PRINT-DISPATCH type-specifier options &body function      [macro]This puts an entry into a print dispatch table.  The type-specifier(which is implicitly quoted) is the key of the entry.  The functionspecifies how to pretty print the indicated type of object.  Whenappropriate, the function is called with two arguments: an outputstream and the object to print.  Any values returned by the function areignored.  The options are a list of pairs containing a keyword and avalue.  Three different keywords are supported:(:TABLE table) Specifies the table (default *PRINT-DISPATCH*) to put the dispatch entryinto.(:PRIORITY number)Specifies a priority (default 0) used to resolve conflicts when an objectmatches more than one entry.(:NAME name)Specifies a name to be given to function.  This makes it possible toreuse the function---e.g., in another call on DEFINE-PRINT-DISPATCH.Before doing anything else, DEFINE-PRINT-DISPATCH removes any existingentry with a type specifier EQUAL to the given type specifier.  A newentry containing the given priority and function is then created.The function in a DEFINE-PRINT-DISPATCH call can be specified in fivedifferent ways.  First, the function can be NIL.  In this case, no newentry is made after the old entry (if any) is removed.  Second, thefunction can be omitted altogether.  In this case, the standard prettyprinting function (if any) corresponding to the type specifier is enteredinto the table.  Third, the function can be an argument list followed by abody consisting of one or more statements.  (The use of &REST X in theargument list below makes it possible to use ~/RATIO-PRINT/ in a FORMATstring.)(define-print-dispatch ratio ((:name ratio-print))                        (s obj &rest x)    (declare (ignore x))  (format s #"#.(/ ~W ~W)" (numerator obj) (denominator obj)))(pprint '(2/3 -4/5)) prints: (#.(/ 2 3) #.(/ -4 5))!Fourth, the function can be an instance of #"...".(define-print-dispatch (and ratio (satisfies plusp))                        ((:priority 1))  #"(+ ~/ratio-print/)")(pprint '(2/3 -4/5)) prints: ((+ #.(/ 2 3)) #.(/ -4 5))Fifth, the function can be a sharp-quoted function name.  The definitionbelow shows the default method used for printing lists that represent data,rather than programs.  (As shown in the definition of LINEAR-STYLE above,LINEAR-STYLE, FILL-STYLE, and TABULAR-STYLE are all defined with theirCOLON? and ATSIGN? arguments optional so that they can be used asDEFINE-PRINT-DISPATCH functions.)(define-print-dispatch cons ((:priority -10)) #'fill-style)The entry to use for printing an object is selected by looking at theentries in *PRINT-DISPATCH* in the order of their priorities.  The firstentry whose type specifier matches the object is chosen.  If an objectmatches two entries with the same priority, an arbitrary choice is made.If no entry matches the object, the object is printed as if *PRINT-PRETTY*were NIL.(CONS car-type cdr-type)                                    [type specifier]When used simply as the symbol CONS, this type specifier matches anycons cell.  When used in the form above, it matches a cons cell only if thecar of the cell matches the type specifier car-type and the cdr ofthe cell matches the type specifier cdr-type.  The cdr-type canbe omitted in which case it defaults to T.The examples below show three of the predefined pretty printing functionsfor Lisp code.  By default, function calls are printed in the standardway---i.e, either all on one line or with the arguments one to a lineindented after the function name.(define-print-dispatch (cons (and symbol (satisfies fboundp)))                       ((:priority -5))  #"~:<~W~^ ~:I~@_~@{~W~^ ~_~}~:>")Lists beginning with COND are printed the same way as function calls,except that the clauses are always printed in linear style, rather than inthe format suggested by their cars.(define-print-dispatch (cons (member cond)) ()  #"~:<~W~^ ~:I~@_~@{~:/linear-style/~^ ~_~}~:>")Lists beginning with QUOTE are printed using the standard "'" syntax.  Notethe care taken to ensure that data lists that happen to begin with QUOTEwill be printed legibly.(define-print-dispatch (cons (member quote)) () (s list)  (if (and (consp (cdr list)) (null (cddr list)))      (format s #"'~W" (cadr list))      (fill-style s list)))!In addition to the last four entries shown above, the initial printdispatch table contains approximately fifty additional entries with typespecifiers of the form (CONS (MEMBER symbol)) and priority zero for variousLisp special forms and macros.  There are no other predefined prettyprinting functions for data structures other than lists.  However, as shownbelow, such entries can easily be defined.(defstruct family mom kids)(define-print-dispatch family () (s f)  (format s #"~@<#<~;~W and ~2I~_~/fill-style/~;>~:>"             (family-mom f) (family-kids f)))The pretty printing function for the structure FAMILY specifies how toadjust the layout of the output so that it can fit aesthetically into avariety of line widths.  In addition, it obeys the printer controlvariables *PRINT-LEVEL*, *PRINT-LENGTH*, *PRINT-LINES*, *PRINT-CIRCLE*, and*PRINT-ESCAPE*, and can tolerate several different kinds of malformity inthe data structure.  The output below shows what happens with line width25, *PRINT-PRETTY T, *PRINT-ESCAPE* NIL, and a malformed KIDS list.(write (list 'principle-family             (make-family :mom "Lucy"                          :kids '("Mark" "Bob" . "Dan"))))(PRINCIPLE-FAMILY #<Lucy and     Mark Bob . Dan>) Note that a pretty printing function for a structure is different from thestructure's print function.  While print functions are permanentlyassociated with a structure, pretty printing functions are stored in printdispatch tables and can be rapidly changed to reflect different printingneeds.  If there is no pretty printing function for a structure in thecurrent print dispatch table, the print function (if any) is used instead.[End of attached document]*start*02596 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 FEB 89 14:33:00 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 27 Feb 89  14:32:54 PSTReceived: from mist.encore.COM by multimax.encore.com with SMTP (5.61/25-eef)	id AA04127; Mon, 27 Feb 89 17:31:20 -0500Received: from localhost by mist. (4.0/SMI-4.0)	id AA09796; Mon, 27 Feb 89 17:29:26 ESTMessage-Id: <8902272229.AA09796@mist.>To: Guy Steele <gls@Think.COM>Cc: cl-cleanup@sail.stanford.eduSubject: Re: PRETTY-PRINT-INTERFACE In-Reply-To: Your message of Fri, 24 Feb 89 17:40:25 -0500.             <8902242240.AA10382@verdi.think.com> Date: Mon, 27 Feb 89 17:29:24 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>You can add me to the list of strong supporters of this proposal.While the proposal is long and complex, it is supported by a longhistory of usage in several different Lisp environments.  Unlike someearlier members of this family, this version fits cleanly enough intothe rest of Common Lisp to warrant standardization.A couple of specific comments:Under aesthetics you might mention that some people will undoubtedlyfind piling more hair on FORMAT ugly (of course these same people maywell find FORMAT in general ugly :-)).The utility of *PRINT-LINES* becomes more obvious if it is pointed outthat Dick's pretty printers are implemented to print each line as itis computed.  This means that a small value for *PRINT-LINES* savessignificant time as well as output medium space.  In fact, many peoplefind that a very pleasant REP loop is created by setting *PRINT-LINES*to a value from 1-4, *PRINT-PRETTY* to T, and defining a short-namefunction (say (PP*)) that funcalls *LAST-ABBREVIATED-PRINTING* withabbreviation bound off.  This is almost as fast and compact as, andMUCH more readable than, a non-pretty-printing REP loop.The advantages of compiled format strings (format functions) should bebrought out as benefits in their own right.  The current proposal justmentions them as a minor feature of XP.At first this struck me a very cute end run around the failure ofSTREAM-INFO, then I realized that one of the problems with STREAM-INFOmay have been that it was a standard at the wrong level.  STREAM-INFOpermitted people to use XP, but not to count on it.  This proposalmakes it possible to write portable code whose new data structures andlanguage elements print correctly in whatever Common Lisp environmentthey're run in. *start*00804 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 FEB 89 17:59:48 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 28 Feb 89  17:57:44 PSTDate: Tue, 28 Feb 89 17:54:54 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue PRETTY-PRINT-INTERFACETo: cl-cleanup@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUMessage-ID: <12474405302.30.IIM@ECLA.USC.EDU>The stuff about ~W providing circularity detection, and ~<...~:> providingdepth abbreviation and circularity detection is wrong.  This functionalityshould always be provided, and not require the use of special format directivesto get it.  See the recently passed issue PRINT-CIRCLE-STRUCTURE.kab-------*start*01555 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 09:30:51 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 09:29:43 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Mar 89  09:30:41 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 557494; Wed 15-Mar-89 12:28:19 ESTDate: Wed, 15 Mar 89 12:28 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRETTY-PRINT-INTERFACE (Version 1)To: masinter.pa, Guy Steele <gls@Think.COM>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <890314-170500-2365@Xerox>Message-ID: <19890315172817.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoIf you're thinking about making a new version, I intend to comment onthis, but it's so huge that it's taking a long time.  A very briefsummary of some of my likely comments is: I'm in favor of the generalidea of defining a standard pretty printer, but there are some problemsin the details of this proposal; part of this seems to resemble CLOS,but is gratuitously(?) different; there doesn't seem to be anyconcession to variable-width fonts, although I didn't find an explicitstatement of what units indentation and width are measured in; I wish toGod that Dick Waters hated FORMAT, because the grotesque FORMAT-basedsyntax is going to make this a lot harder to pass.*start*01408 00024 US GV-Info: Moon@STONY-BROOK.SCRC.Symbolics.COM at 16-Mar-89 13:39:09 from AGReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 16 MAR 89 13:38:46 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 557494; Wed 15-Mar-89 12:28:19 ESTDate: Wed, 15 Mar 89 12:28 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRETTY-PRINT-INTERFACE (Version 1)To: masinter.pa, Guy Steele <gls@Think.COM>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <890314-170500-2365@Xerox>Message-ID: <19890315172817.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoIf you're thinking about making a new version, I intend to comment onthis, but it's so huge that it's taking a long time.  A very briefsummary of some of my likely comments is: I'm in favor of the generalidea of defining a standard pretty printer, but there are some problemsin the details of this proposal; part of this seems to resemble CLOS,but is gratuitously(?) different; there doesn't seem to be anyconcession to variable-width fonts, although I didn't find an explicitstatement of what units indentation and width are measured in; I wish toGod that Dick Waters hated FORMAT, because the grotesque FORMAT-basedsyntax is going to make this a lot harder to pass.*start*01242 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 14-Mar-89 17:31:28 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 17:31:29 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Mar 89  17:32:09 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 MAR 89 17:05:00 PSTDate: 14 Mar 89 17:04 PSTFrom: masinter.paSubject: Issue: PRETTY-PRINT-INTERFACE (Version 1)In-reply-to: Guy Steele <gls@Think.COM>'s message of Fri, 24 Feb 89 17:40:25 ESTTo: Guy Steele <gls@Think.COM>cc: cl-cleanup@sail.stanford.eduMessage-ID: <890314-170500-2365@Xerox>Dan Pierson had a few specific comments.Kim Barrett says"... The stuff about ~W providing circularity detection, and ~<...~:>providingdepth abbreviation and circularity detection is wrong.  This functionalityshould always be provided, and not require the use of special formatdirectivesto get it.  See the recently passed issue PRINT-CIRCLE-STRUCTURE...."Can we get a new version that addresses those comments?I think if we email things out by Thursday we might have a chance ofavoiding the "two-weekers". Thanks,Larry*start*14930 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 12:59:30 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 12:58:18 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 15 Mar 89  12:54:51 PSTReceived: from fafnir.think.com by Think.COM; Wed, 15 Mar 89 15:50:57 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Wed, 15 Mar 89 15:52:16 ESTReceived: by verdi.think.com; Wed, 15 Mar 89 15:49:04 ESTDate: Wed, 15 Mar 89 15:49:04 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903152049.AA03416@verdi.think.com>To: cl-cleanup@sail.stanford.eduSubject: PRETTY-PRINT-INTERFACE, version 3 (supersedes 2 sent an hour ago!)Version 3 is changed from version 1 as follows:adds a functional interface to supplement the interface through FORMAT,and reflects comments by Barrett and Pierson.The document attached to version 1 has been omitted here, as themailer choked on it.  It should logically be inserted before thefunctional interface attached here.--GuyIssue:		PRETTY-PRINT-INTERFACEReferences:	Description of XP by Dick Waters (attached)		*PRINT-PRETTY* (CLtL p. 371)		WRITE (CLtL p. 382)		PPRINT (CLtL p. 383)		FORMAT (CLtL pp. 385-407)		FORMAT ~T directive (CLtL pp. 398-399)		FORMAT ~< directive (CLtL pp. 404-406)Related issues: Category:	CLARIFICATION CHANGE ADDITIONEdit history:	Version 1, 24-Feb-89 by Steele		Version 2, 15-Mar-89 by Steele and Waters		Version 3, 15-Mar-89 by SteeleProblem description:At present Common Lisp provides no specification whatsoever of howpretty-printing is to be accomplished, and no way for the user to controlit.  In particular, there is no protocol by which a user can write aprint-function for a structure, or a method for PRINT-OBJECT, that willinteract smoothly with the built-in pretty-printer in a portable manner.Proposal (PRETTY-PRINT-INTERFACE:XP):Adopt the interfaces and protocols of the XP pretty-printer by Dick Waters,described in full in the attached 12-page document.  Here is a very briefsummary of the proposal.New variables:	*PRINT-DISPATCH*		*PRINT-RIGHT-MARGIN*		*DEFAULT-RIGHT-MARGIN*		*PRINT-MISER-WIDTH*		*PRINT-LINES*		*LAST-ABBREVIATED-PRINTING*New function:	COPY-PRINT-DISPATCHNew macro:	DEFINE-PRINT-DISPATCHNew FORMAT directives:	~W  ~_  ~I  ~:T  ~/name/  ~<...~:>New # reader macro:  #"..."The function WRITE is extended to accept additional keyword arguments:DISPATCH, :RIGHT-MARGIN, :LINES, and :MISER-WIDTH corresponding to thefirst four of the new variables.Finally, wherever in the attached document it says that certain constructssupport depth abbreviation and circularity detection, it should be notedthat this is so a fortiori, because *all* printing operations support themproperly.  Therefore, while the statements are correct, the possiblymisleading implication that they are the only way to achieve suchdetection should be rectified if the text is taken over into the standard.Examples:	See attached document.Rationale:There ought to be a good user interface to the pretty printer.This is the only proposal for which there is a portable implementationthat has seen extensive use and is being made freely available.Current practice:XP son of PP son of GPRINT son of PRINT* is the latest in a line of prettyprinters that goes back 13 years.  All of these printers use essentiallythe same basic algorithm and conceptual interface.  Further, except forPRINT*, which was implemented solely to satisfy the author's personalneeds, each of these printers has had extensive use.  XP has been inexperimental use as the pretty printer in CMU Common Lisp for 6 months.  PPhas been the pretty printer in DEC Common Lisp for the past 3 years.  Priorto three years ago, GPRINT was used for 2 years as the pretty printer inDEC Common Lisp.  In addition, GPRINT has been the pretty printer invarious generations of Symbolics Lisp for upwards of 5 years.(See Waters R.C., "User Format Control in a Lisp Prettyprinter", ACM TOPLAS,5(4):513--531, October 1983.)Cost to Implementors:A fair amount of effort (perhaps a few man-weeks at most).Source code for XP is available to all comers from Dick Waters, andthe system is documented in great detail:Waters, Richard C., "XP: A Common Lisp Pretty Printing System",Artificial Intelligence Laboratory Technical Memo 1102,Massachusetts Institute of Technology, Cambridge MA, March 1989.Cost to Users:  None (I think).  This is an upward-compatible extension.Cost of non-adoption:  Continued inability for user print-functionsto interact with the pretty-printer in a useful and portable manner.Performance impact:  XP is claimed to be quite fast.Benefits:  User control of pretty-printing in a portable manner.Esthetics:Using ~<...~:> may strike some as uncomfortably close in the syntacticspace of FORMAT directives to the existing ~<...~>.  However, it is veryunlikely that both of these directives (pretty-print logical block andcolumnar justification, respectively) will be used in the same call toFORMAT.  Previous versions of XP used ~!...~. instead of ~<...~:> but thismade FORMAT strings very difficult to read; it is preferable to havea directive that looks like matching brackets of some sort.Dan Pierson comments:  You might mention that some people will undoubtedlyfind piling more hair on FORMAT ugly (of course these same people maywell find FORMAT in general ugly :-)).Discussion:Zetalisp used ~:T to mean pixelwise tabulation, so the use of ~:Tsuggested here may be a problem.  If so, another suggestion for namingthis directive would be appropriate.The ~/.../ directive is already in Zetalisp, and is not an idea newto this proposal.Guy Steele and Dick Waters strongly support this proposal.  (As an example,Guy Steele has a portable simulator for Connection Machine Lisp, and wouldlike very much to have xappings and xectors pretty-print properly.)Dan Pierson comments: You can add me to the list of strong supporters ofthis proposal.  While the proposal is long and complex, it is supported bya long history of usage in several different Lisp environments.  Unlikesome earlier members of this family, this version fits cleanly enough intothe rest of Common Lisp to warrant standardization.The utility of *PRINT-LINES* becomes more obvious if it is pointed outthat Dick's pretty printers are implemented to print each line as itis computed.  This means that a small value for *PRINT-LINES* savessignificant time as well as output medium space.  In fact, many peoplefind that a very pleasant REP loop is created by setting *PRINT-LINES*to a value from 1-4, *PRINT-PRETTY* to T, and defining a short-namefunction (say (PP*)) that funcalls *LAST-ABBREVIATED-PRINTING* withabbreviation bound off.  This is almost as fast and compact as, andMUCH more readable than, a non-pretty-printing REP loop.The advantages of compiled format strings (format functions) should bebrought out as benefits in their own right.  The current proposal justmentions them as a minor feature of XP.At first this struck me a very cute end run around the failure ofSTREAM-INFO, then I realized that one of the problems with STREAM-INFOmay have been that it was a standard at the wrong level.  STREAM-INFOpermitted people to use XP, but not to count on it.  This proposalmakes it possible to write portable code whose new data structures andlanguage elements print correctly in whatever Common Lisp environmentthey're run in.  [End of comments by Pierson]!                  Functional Interface  The primary interface to operations for dynamically determining thearrangement of output is provided through FORMAT.  This is done,because FORMAT strings are typically the most convenient way ofinteracting with pretty printing.  However, these operations havenothing inherently to do with FORMAT per se.  In particular, they canalso be accessed via the six functions and macros below.WITHIN-LOGICAL-BLOCK (&KEY :STREAM :VAR :ARG                     [Macro]                           :PREFIX :PER-LINE-PREFIX :SUFFIX)                      &BODY BODYIn the manner of ~<...~:>, this macro causes printing to begrouped into a logical block.  The value NIL is always returned.:STREAM specifies the stream the logical block is to be printed on.:STREAM defaults to *STANDARD-OUTPUT* and follows the standardconventions for stream arguments to output functions---NIL stands for*STANDARD-OUTPUT* and T stands for *TERMINAL-IO*.:VAR (which defaults to *STANDARD-OUTPUT*) must be a symbol other thanT or NIL.  :VAR is bound to a special kind of stream that supportsdynamic decisions about the arrangement of output.The BODY can contain any arbitrary Lisp forms.  All the standardprinting functions (e.g., WRITE, PRINC, TERPRI) can be used to printoutput into :VAR.  All and only the output sent to :VAR is treated asbeing in the logical block.  It is an error for the BODY to send anyoutput directly to :STREAM.:SUFFIX (which defaults to the null string) specifies a suffix that isprinted just after the logical block.  :PREFIX specifies a prefix to beprinted before the beginning of the logical block.  :PER-LINE-PREFIXspecifies a prefix that is printed before the block and at thebeginning of each new line in the block.  It is an error for :PREFIXand :PRE-LINE-PREFIX to both be used. If neither is used, a :PREFIX ofthe null string is assumed.:ARG (which defaults to NIL) is interpreted as being a list that BODYis responsible for printing.  If :ARG is not a list, it is printedusing WRITE.  If *PRINT-CIRCLE* is not NIL and :ARG is a circularreference to a cons, then an appropriate #n# marker is printed.  If*PRINT-LEVEL* is not NIL and the logical block is at a dynamic nestingdepth of greater than *PRINT-LEVEL* in logical blocks, # is printed.If either of the three conditions above occures, the special output isprinted on :STREAM and the BODY is skipped along with the printing ofthe prefix and suffix.CONDITIONAL-NEWLINE KIND &OPTIONAL (STREAM *STANDARD-OUTPUT*)    [Function]CONDITIONAL-NEWLINE is the functional equivalent of ~_.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions.  The KIND argument specifiesthe style of conditional newline.  It must be one of :LINEAR, :FILL,:MISER, or :MANDATORY.  If STREAM is a special stream bound byWITHIN-LOGICAL-BLOCK, a conditional newline is sent to it.  Otherwise,CONDITIONAL-NEWLINE has no effect.  The value NIL is always returned.LOGICAL-BLOCK-INDENT KIND N &OPTIONAL (STREAM *STANDARD-OUTPUT*) [Function]LOGICAL-BLOCK-INDENT is the functional equivalent of ~I, STREAMargument (which defaults to *STANDARD-OUTPUT*) follows the standardconventions for stream arguments to printing functions.  N specifiesthe amount of indentation.  If KIND is :FROM-START, this indentation isrelative to the start of the enclosing block (as for ~I).  If KIND is:FROM-POSITION, the indentation is relative to the current outputposition (as for ~:I).  It is an error for KIND to take on any othervalue.  If STREAM is a special stream bound by WITHIN-LOGICAL-BLOCK,LOGICAL-BLOCK-INDENT sets the indentation in the innermost enclosinglogical block.  Otherwise, LOGICAL-BLOCK-INDENT has no effect.  Thevalue NIL is always returned.LOGICAL-BLOCK-TAB KIND COLNUM COLINC &OPTIONAL (STREAM *STANDARD-OUTPUT*)LOGICAL-BLOCK-TAB is the functional equivalent of ~T.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions.  The arguments COLNUM andCOLINC correspond to the two numeric parameters to ~T.  The KINDargument specifies the style of tabbing.  It must be one of :LINE (tabusing ~T), :BLOCK (tab using ~:T), :LINE-RELATIVE (tab using ~@T), or:BLOCK-RELATIVE (tab using ~:@T).  If STREAM is a special stream boundby WITHIN-LOGICAL-BLOCK, tabbing is performed.  Otherwise,LOGICAL-BLOCK-TAB has no effect.  The value NIL is always returned.LOGICAL-BLOCK-POP ARGS &OPTIONAL (STREAM *STANDARD-OUTPUT*)      [Macro]LOGICAL-BLOCK-COUNT &OPTIONAL (STREAM *STANDARD-OUTPUT*)         [Macro]LOGICAL-BLOCK-POP is identical to POP except that it supports*PRINT-LENGTH* and *PRINT-CIRCLE*.  It is an error to useLOGICAL-BLOCK-POP anywhere other than syntactically nested within acall on WITHIN-LOGICAL-BLOCK.ARGS must be a symbol or expression acceptable to POP.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions.  If STREAM is a special streambound by WITHIN-LOGICAL-BLOCK, then LOGICAL-BLOCK-POP performs thespecial operations described below.  Otherwise, LOGICAL-BLOCK-POP isidentical to POP.Each time LOGICAL-BLOCK-POP is called, it performs three tests.  ifARGS is not a cons, ". " is printed followed by ARGS.  If*PRINT-LENGTH* is NIL and LOGICAL-BLOCK-POP has already been called*PRINT-LENGTH* times within the immediately containing logical block,"..." is printed. If *PRINT-CIRCLE* is not NIL, and ARGS is a circularreference, then ". " is printed followed by an appropriate #n# marker.If either of the three conditions above occurs, the special output isprinted on :STREAM and the execution of the immediately containingWITHIN-LOGICAL-BLOCK is terminated except for the printing of thesuffix.  Otherwise, LOGICAL-BLOCK-POP pops the top value off of ARGSand returns this value.LOGICAL-BLOCK-COUNT is identical to LOGICAL-BLOCK-POP except that itdoes not take an ARGS argument, always returns NIL, and only performsthe second test discussed above.  It is useful when the components of anon-list are being printed.Using the functions above, TABULAR-STYLE could be defined as follows.        (defun tabular-style (stream list &optional (colon? T) atsign? 						(tabsize nil))	(declare (ignore atsign?))      (if (null tabsize) (setq tabsize 16))      (within-logical-block (:var s :stream stream :arg list			     :prefix (if colon? "(" "")			     :suffix (if colon? ")" ""))       (when list	 (loop (write (logical-block-pop list s) :stream s)	       (if (null list) (return nil))	       (write-char #\space s)	       (logical-block-tab :block-relative 0 tabsize s)	       (conditional-newline :fill s)))))The function below prints a vector using #(...) notation.        (defun print-vector (v *standard-output*)      (within-logical-block (:prefix "#(" :suffix ")")	(let ((end (length v)) (i 0))	  (when (plusp end)	    (loop (logical-block-count)		  (write (aref v i))		  (if (= (incf i) end) (return nil))		  (write-char #\space)		  (conditional-newline :fill))))))[End of attached document]*start*04082 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 22:34:23 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 22:34:20 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 17 Mar 89  22:35:17 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 560283; Sat 18-Mar-89 01:32:31 ESTDate: Sat, 18 Mar 89 01:32 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRETTY-PRINT-INTERFACE (version 3)To: Guy Steele <gls@Think.COM>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8903152049.AA03416@verdi.think.com>Message-ID: <19890318063223.0.MOON@EUPHRATES.SCRC.Symbolics.COM>In general I like this.  Certainly I like the idea of having astandardized interface for extending the pretty-printer, and I believethat this particular pretty-printer is based on a good underlyingtheory, certainly the best theory that I have seen.  However, I don'tthink this is ready to go into the standard in its current form.  Someof these comments are on the programmer interface, others are just onthe way the proposal is presented.I could not find any specification of the units of measurement for*PRINT-RIGHT-MARGIN*, *DEFAULT-RIGHT-MARGIN*, *PRINT-MISER-WIDTH*,indentation, and tabulation.  It's not even clear that margins,indentation, and tabulation can't be measured in three differentunits.  Analysis of the examples suggests that the units areassumed to be characters and all characters are assumed to be thesame width.  This is not an implementation-independent assumption.In any case the proposal has to be specific about the units.  Iwould prefer something that seamlessly accomodates variable-widthcharacters, but don't have enough experience with pretty-printersto propose anything myself.I would like to be able to vote on the FORMAT-based interface andthe functional interface separately.I would like to see the DEFINE-PRINT-DISPATCH mechanism recast in termsof DEFMETHOD and a PRETTY-PRINT-OBJECT generic function.  If DEFMETHODis deficient and unable to provide all the necessary features, I thinkwe need to know that before it's too late to amend CLOS.  I don't seeany problems myself, other than the need to replace the funny extensionto the CONS type-specifier with passing of the CAR of the CONS as aseparate argument so an EQL parameter specializer can be used.I'd like to suggest some improvements to the syntax ofWITHIN-LOGICAL-BLOCK, based on Symbolics experience with similar macros:  Instead of separate :STREAM and :VAR keywords, it works better to have  only a :STREAM keyword, whose value must be a symbol.  This symbol  is evaluated to get the stream, and also is bound around the body to  a (possibly new) stream.  This simplifies the syntax and avoids the  risk of accidentally writing to the wrong stream.  Defaulting to *STANDARD-OUTPUT* and handling T and NIL is correct here  (:STREAM NIL means *STANDARD-OUTPUT* is the variable that gets bound.)    Since the :ARG argument appears to be mandatory, it should be a  required argument preceding the keyword arguments.  This would also  eliminate the meaningless keyword name for this argument.    It would be nice if the :PREFIX, :PER-LINE-PREFIX, and :SUFFIX  arguments could be functions as well as strings, to allow more control  over the printing of this information.  That's not essential, but it  would for example make it easier to print special characters.The :FROM-START and :FROM-POSITION values for KIND in LOGICAL-BLOCK-INDENTare too easily confused.  I suggest renaming them to :BLOCK and :CURRENTand renaming the argument to RELATIVE-TO.The functional interface is missing equivalents for the~/TABULAR-STYLE/, ~/FILL-STYLE/, and ~/LINEAR-STYLE/ features.I think it's better to provide these as predefined functionsthan to make the user define them himself.*start*02699 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 12:33:02 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 12:31:58 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 20 Mar 89  12:29:22 PSTReceived: from mist.encore.COM by multimax.encore.com with SMTP (5.61/25-eef)	id AA00470; Mon, 20 Mar 89 10:13:54 -0500Received: from localhost by mist. (4.0/SMI-4.0)	id AA01358; Mon, 20 Mar 89 10:15:47 ESTMessage-Id: <8903201515.AA01358@mist.>To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: PRETTY-PRINT-INTERFACE (version 3) In-Reply-To: Your message of Sat, 18 Mar 89 01:32:00 -0500.             <19890318063223.0.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Mon, 20 Mar 89 10:15:45 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    Date: Sat, 18 Mar 89 01:32 EST    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>        I could not find any specification of the units of measurement for    *PRINT-RIGHT-MARGIN*, *DEFAULT-RIGHT-MARGIN*, *PRINT-MISER-WIDTH*,    indentation, and tabulation.  It's not even clear that margins,    indentation, and tabulation can't be measured in three different    units.  Analysis of the examples suggests that the units are    assumed to be characters and all characters are assumed to be the    same width.  This is not an implementation-independent assumption.    In any case the proposal has to be specific about the units.  I    would prefer something that seamlessly accomodates variable-width    characters, but don't have enough experience with pretty-printers    to propose anything myself.    I think that all three clearly have to be in the same units; thewriteup should be changed to specify this.  After thinking about itfor a while, it's not clear that the exact unit matters much as longas it's not to small.  Pixels are too small; "n"'s or "m"'s aren't.Personally I'd suggest an "m" as the standard unit.Other than that, I don't think the propsal has terrible problems withvariable width (even kerned) fonts because most indentation is donerelative to the position of the start of another word.  This commoncase can be handled with arbitrary precision; a variable width fontimplementation would presumably indent to the exact pixel position ofthe relevant character (how would that be expressed in Postscript?).Of course parts of the proposal won't work for right-to-left ortop-to-bottom languages.  I think that rejecting the proposal becauseof that would be ridiculous.*start*02675 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 12:38:37 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 12:38:21 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Mar 89  12:36:46 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 561205; Mon 20-Mar-89 15:35:05 ESTDate: Mon, 20 Mar 89 15:34 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PRETTY-PRINT-INTERFACE (version 3) To: Dan L. Pierson <pierson@mist.encore.com>cc: cl-cleanup@SAIL.STANFORD.EDU, disk@wheaties.ai.mit.eduIn-Reply-To: <8903201515.AA01358@mist.>Message-ID: <19890320203457.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 20 Mar 89 10:15:45 EST    From: Dan L. Pierson <pierson@mist.encore.com>	Date: Sat, 18 Mar 89 01:32 EST	From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    	I could not find any specification of the units of measurement for	*PRINT-RIGHT-MARGIN*, *DEFAULT-RIGHT-MARGIN*, *PRINT-MISER-WIDTH*,	indentation, and tabulation.        I think that all three clearly have to be in the same units; the    writeup should be changed to specify this.  After thinking about it    for a while, it's not clear that the exact unit matters much as long    as it's not to small.  Pixels are too small; "n"'s or "m"'s aren't.    Personally I'd suggest an "m" as the standard unit.I don't see anything wrong with that, although I can't claim to be anexpert in this area.    Other than that, I don't think the propsal has terrible problems with    variable width (even kerned) fonts because most indentation is done    relative to the position of the start of another word.  This common    case can be handled with arbitrary precision; a variable width font    implementation would presumably indent to the exact pixel position of    the relevant character (how would that be expressed in Postscript?).I think what you're saying is that the argument to LOGICAL-BLOCK-INDENT(or ~I) is almost always zero?  In the examples given in version 1of the proposal, zero is in the majority, there are also two 1's anda 2.  I didn't find any cases where the number given to ~I seemed tobe intended to correspond to the number of characters in some word.There might need to be a style suggestion for writers of pretty printmethods telling them to use relative indentation instead of countingcharacters.  Given that, your suggestion sounds plausible to me.*start*02816 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 14:23:14 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 14:23:00 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Mar 89  14:15:08 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 561357; Mon 20-Mar-89 17:13:50 ESTDate: Mon, 20 Mar 89 17:13 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PRETTY-PRINT-INTERFACE (version 3) To: Dan L. Pierson <pierson@mist.encore.com>cc: cl-cleanup@SAIL.STANFORD.EDU, dick@wheaties.ai.mit.eduIn-Reply-To: <8903201515.AA01358@mist.>Supersedes: <19890320203457.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Comments: Resend after correcting misspelling in Dick Waters' mailbox name.Message-ID: <19890320221342.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 20 Mar 89 10:15:45 EST    From: Dan L. Pierson <pierson@mist.encore.com>	Date: Sat, 18 Mar 89 01:32 EST	From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    	I could not find any specification of the units of measurement for	*PRINT-RIGHT-MARGIN*, *DEFAULT-RIGHT-MARGIN*, *PRINT-MISER-WIDTH*,	indentation, and tabulation.        I think that all three clearly have to be in the same units; the    writeup should be changed to specify this.  After thinking about it    for a while, it's not clear that the exact unit matters much as long    as it's not to small.  Pixels are too small; "n"'s or "m"'s aren't.    Personally I'd suggest an "m" as the standard unit.I don't see anything wrong with that, although I can't claim to be anexpert in this area.    Other than that, I don't think the propsal has terrible problems with    variable width (even kerned) fonts because most indentation is done    relative to the position of the start of another word.  This common    case can be handled with arbitrary precision; a variable width font    implementation would presumably indent to the exact pixel position of    the relevant character (how would that be expressed in Postscript?).I think what you're saying is that the argument to LOGICAL-BLOCK-INDENT(or ~I) is almost always zero?  In the examples given in version 1of the proposal, zero is in the majority, there are also two 1's anda 2.  I didn't find any cases where the number given to ~I seemed tobe intended to correspond to the number of characters in some word.There might need to be a style suggestion for writers of pretty printmethods telling them to use relative indentation instead of countingcharacters.  Given that, your suggestion sounds plausible to me.*start*03967 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 16:02:10 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 16:02:10 PSTReceived: from life.ai.mit.edu by SAIL.Stanford.EDU with TCP; 20 Mar 89  15:55:52 PSTReceived: from wheat-chex.ai.mit.edu by life.ai.mit.edu; Mon, 20 Mar 89 18:54:57 ESTReceived: from localhost by wheat-chex.ai.mit.edu; Mon, 20 Mar 89 18:54:55 ESTDate: Mon, 20 Mar 89 18:54:55 ESTFrom: dick@wheaties.ai.mit.eduMessage-Id: <8903202354.AA04220@wheat-chex.ai.mit.edu>To: David A. Moon <Moon@stony-brook.scrc.symbolics.com>Cc: gls@think.com, cl-cleanup@sail.stanford.edu, dick@wheaties.ai.mit.eduSubject: Issue: PRETTY-PRINT-INTERFACE (version 3)RE: your recent comments.(1) Clearly, the right statements about length units need to be put inthe proposal.  A note advising programmers to use explicit lengths aslittle as possible also sounds like a good idea.(2) I agree that it was a severe error to omit the funcional interface.However, I also think it would be a severe error to omit the format interface.(3) I understand why you would like to have define-print-dispatch    merged with the CLOS stuff.  I will look into that.  (Can you    remind me of the issue of SIGPLAN notices that CLOS was described    in?  Is that accurate?)  However, I think there may be problems.      First, although not particularly shown in the examples, I have    found very elaborate type specifies for printing things (e.g.,    including satisfies clauses) to be quite useful.  In the proposal    note the use of the specifier (CONS (AND SYMBOL (SATISFIES FBOUNDP))).      Also note the use of priorities to disambiguate between overlapping    type specifiers.  This is very important to get propper    defaulting---i.e. specifying how to print lists in general as well    as particular special forms.  Maybe some inheretence things can    make that work in CLOS, but it is not clear to me.      Finally although it can certainly work, passing style of    printing arguments around does not appeal to me anywhere near as    much as multiple dispatch tables, because     when you write your first style, you have to set things up to    allow for more styles even if you never have more styles, or else    face a lot of work when you make a second style.  It is also not    clear how this would all fit in with having a standard predefined    style that users can modify as they wish.      It seems to me that the pretty printer and CLOS just do not have    the same idea of what an object is, and that while CLOS primarily    has a quasi-static association of methods to objects, the pretty    printer wants to support rapid wholesale change.  Given these    differences, unification may not work as well as one might hope.(4) Your suggestions for improving the functional interface basicallysound good to me, however I differ slightly with a couple of them.  Combining the :stream and :var sounds like a good idea.  However, The :arg argument is not mandatory.  It is not used in the    second example I sent around with the functional interface proposal.  I think that making :prefix, :per-line-prefix, and :suffix functions    is overkill.  One can always use #. after all.  Changing the name of :from-start and :from-position and the argument     sounds fine to me.  note that ~/tabular-style/ etc. uses the format interface for    calling a function.  Therefore it has already been implicitly    stated that tabular-style, fill-style, and linear-style, are    functions and what their arguments are.  The definition of the    function linear-style is given as an example, and fill-style is    used as a function in another example in the original proposal.    Nevertheless, the functional interface part should note that they    are functions.*start*05202 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 18:43:35 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 18:43:37 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Mar 89  18:41:21 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 561599; Mon 20-Mar-89 21:39:43 ESTDate: Mon, 20 Mar 89 21:39 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRETTY-PRINT-INTERFACE (version 3)To: dick@wheaties.ai.mit.educc: gls@think.com, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8903202354.AA04220@wheat-chex.ai.mit.edu>Message-ID: <19890321023936.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 20 Mar 89 18:54:55 EST    From: dick@wheaties.ai.mit.edu    ....    (Can you    remind me of the issue of SIGPLAN notices that CLOS was described    in?  Is that accurate?)  SIGPlan Notices (ISSN 0362-1340)Volume 23Special Issue -- September 1988ISBN 0-89791-289-6ACM Order Number 548883I don't know whether it's accurate, I haven't looked at it.  I imagineit is an exact copy of X3J13 document 88-002R, which is pretty close.    (3) I understand why you would like to have define-print-dispatch	merged with the CLOS stuff.  I will look into that.  However, I think there may be problems.	  First, although not particularly shown in the examples, I have	found very elaborate type specifies for printing things (e.g.,	including satisfies clauses) to be quite useful.  In the proposal	note the use of the specifier (CONS (AND SYMBOL (SATISFIES FBOUNDP))).	  Also note the use of priorities to disambiguate between overlapping	type specifiers.  This is very important to get propper	defaulting---i.e. specifying how to print lists in general as well	as particular special forms.  Maybe some inheretence things can	make that work in CLOS, but it is not clear to me.So what you're saying is that you want to use type specifiers that haveunclear subtype/supertype relationships, and compensate for that byusing numerical priorities.  I understand now.  CLOS cannot currentlyhandle that through the normal parameter specializer mechanism, becauseit requires clear subtype/supertype relationships from the typespecifiers alone.  On the other hand, one could make a form of methodcombination that did the same thing as define-print-dispatch, but thatwould be going through the back door.  On the third hand, some of theapplicability testing could be moved into the body of the method andcall-next-method employed.At this point I don't know what to say; expediency and elegance seemto be in direct conflict.  Maybe someone else has an idea.  I certainlywill not block the thing for this point of esthetics, but it does raisea red flag for me that something somewhere is inadequate.	  Finally although it can certainly work, passing style of	printing arguments around does not appeal to me anywhere near as	much as multiple dispatch tables, because 	when you write your first style, you have to set things up to	allow for more styles even if you never have more styles, or else	face a lot of work when you make a second style.  It is also not	clear how this would all fit in with having a standard predefined	style that users can modify as they wish.I think if you think about this harder you'll realize that dispatch tablesand style-of-printing arguments are isomorphic and differ only in someminor internal implementation details.	  It seems to me that the pretty printer and CLOS just do not have	the same idea of what an object is, and that while CLOS primarily	has a quasi-static association of methods to objects, the pretty	printer wants to support rapid wholesale change.  Given these	differences, unification may not work as well as one might hope.I think this is a non-issue, but the real problem is what you said abovecomplex type specifiers.    (4) Your suggestions for improving the functional interface basically    sound good to me, however I differ slightly with a couple of them.      Combining the :stream and :var sounds like a good idea.      However, The :arg argument is not mandatory.  It is not used in the	second example I sent around with the functional interface proposal.I don't recall seeing any examples of the functional interface.  Let meask, how frequently is the :arg argument omitted?  If it's omitted veryinfrequently, it would be better to supply an explicit nil in those casesthan to say :arg in all the rest of the cases.      I think that making :prefix, :per-line-prefix, and :suffix functions	is overkill.  One can always use #. after all.No, the issue is a function that decides at run time what to output, ratherthan having a canned string.  Whether the string appears in the source oris generated at compile time is of no moment.  But if you don't want toput in the extra flexibility, I won't complain, I don't have a specificuse for it in mind, I only proposed it on general principles.*start*23496 00024 USaGV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 22-Mar-89 11:42:13 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 MAR 89 10:59:55 PSTReceived: from life.ai.mit.edu by SAIL.Stanford.EDU with TCP; 22 Mar 89  10:54:13 PSTReceived: from wheat-chex.ai.mit.edu by life.ai.mit.edu; Wed, 22 Mar 89 13:54:36 ESTReceived: from localhost by wheat-chex.ai.mit.edu; Wed, 22 Mar 89 13:54:34 ESTDate: Wed, 22 Mar 89 13:54:34 ESTFrom: dick@wheaties.ai.mit.eduMessage-Id: <8903221854.AA10669@wheat-chex.ai.mit.edu>To: cl-cleanup@sail.stanford.eduSubject: PRETTY-PRINT-INTERFACE, version 4Version 3 (by Guy Steele Jr) supersedes version 2 and is changed fromversion 1 as follows: adds a functional interface to supplement theinterface through FORMAT, and reflects comments by Barrett andPierson.Version 4 (by Dick Waters) is changed from version 3 as follows: Theshort summary is updated to reflect the functional interface.  Thefunctional interface is changed following suggestions made by Dave Moon.The proposal is amended in a few minor ways to increase thecompatibility with variable width fonts.  Additional discussion has beenadded with regard to the advantages of XP with regard to handlingcircularity detection and abbreviation, the interaction with CLOS, andthe extended type specifier CONS used by XP.The document attached to version 1 has also been fully revised, but issent in a separate message due to mailer problems.--DickIssue:		PRETTY-PRINT-INTERFACEReferences:	Description of XP by Dick Waters (attached)		*PRINT-PRETTY* (CLtL p. 371)		WRITE (CLtL p. 382)		PPRINT (CLtL p. 383)		FORMAT (CLtL pp. 385-407)		FORMAT ~T directive (CLtL pp. 398-399)		FORMAT ~< directive (CLtL pp. 404-406)Related issues: Category:	CLARIFICATION CHANGE ADDITIONEdit history:	Version 1, 24-Feb-89 by Steele		Version 2, 15-Mar-89 by Steele and Waters		Version 3, 15-Mar-89 by Steele		Version 4, 22-Mar-89 by WatersProblem description:At present, Common Lisp provides no specification whatsoever of howpretty-printing is to be accomplished, and no way for the user to controlit.  In particular, there is no protocol by which a user can write aprint-function for a structure, or a method for PRINT-OBJECT, that willinteract smoothly with the built-in pretty-printer in a portable manner.Proposal (PRETTY-PRINT-INTERFACE:XP):Adopt the interfaces and protocols of the XP pretty-printer by Dick Waters,described in full in the attached 12-page document.  Here is a very briefsummary of the proposal.New variables:	*PRINT-DISPATCH*		*PRINT-RIGHT-MARGIN*		*DEFAULT-RIGHT-MARGIN*		*PRINT-MISER-WIDTH*		*PRINT-LINES*		*LAST-ABBREVIATED-PRINTING*New functions:	COPY-PRINT-DISPATCH		FILL-STYLE		LINEAR-STYLE		TABULAR-STYLE		CONDITIONAL-NEWLINE		LOGICAL-BLOCK-TAB		LOGICAL-BLOCK-INDENTNew macros:	DEFINE-PRINT-DISPATCH		WITHIN-LOGICAL-BLOCK		LOGICAL-BLOCK-COUNT		LOGICAL-BLOCK-POPNew FORMAT directives:	~W  ~_  ~I  ~:T  ~/name/  ~<...~:>New # reader macro:  #"..."The function WRITE is extended to accept additional keyword arguments:DISPATCH, :RIGHT-MARGIN, :LINES, and :MISER-WIDTH corresponding to thefirst four of the new variables.Examples:	See attached document.Rationale:There ought to be a good user interface to the pretty printer.This is the only proposal for which there is a portable implementationthat has seen extensive use and is being made freely available.Current practice:XP son of PP son of GPRINT son of PRINT* is the latest in a line of prettyprinters that goes back 13 years.  All of these printers use essentiallythe same basic algorithm and conceptual interface.  Further, except forPRINT*, which was implemented solely to satisfy the author's personalneeds, each of these printers has had extensive use.  XP has been inexperimental use as the pretty printer in CMU Common Lisp for 6 months.  PPhas been the pretty printer in DEC Common Lisp for the past 3 years.  Priorto three years ago, GPRINT was used for 2 years as the pretty printer inDEC Common Lisp.  In addition, GPRINT has been the pretty printer invarious generations of Symbolics Lisp for upwards of 5 years.(See Waters R.C., "User Format Control in a Lisp Prettyprinter", ACM TOPLAS,5(4):513--531, October 1983.)Cost to Implementors:A fair amount of effort (perhaps a few man-weeks at most).Source code for XP is available to all comers from Dick Waters, andthe system is documented in great detail:Waters, Richard C., "XP: A Common Lisp Pretty Printing System",Artificial Intelligence Laboratory Technical Memo 1102,Massachusetts Institute of Technology, Cambridge MA, March 1989.Cost to Users:  None (I think).  This is an upward-compatible extension.Cost of non-adoption:  Continued inability for user print-functionsto interact with the pretty-printer in a useful and portable manner.Performance impact:  XP is claimed to be quite fast.Benefits:  User control of pretty-printing in a portable manner.Aesthetics:Using ~<...~:> may strike some as uncomfortably close in the syntacticspace of FORMAT directives to the existing ~<...~>.  However, it is veryunlikely that both of these directives (pretty-print logical block andcolumnar justification, respectively) will be used in the same call toFORMAT.  Previous versions of XP used ~!...~. instead of ~<...~:> but thismade FORMAT strings very difficult to read; it is preferable to havea directive that looks like matching brackets of some sort.Dan Pierson comments:  You might mention that some people will undoubtedlyfind piling more hair on FORMAT ugly (of course these same people maywell find FORMAT in general ugly :-)).Discussion:Zetalisp used ~:T to mean pixelwise tabulation, so the use of ~:Tsuggested here may be a problem.  If so, another suggestion for namingthis directive would be appropriate.The ~/.../ directive is already in Zetalisp, and is not an idea newto this proposal.  However, it should be noted that the proposal for~/.../ here is simpler than, and incompatible with, the current Zatalisppractice.Guy Steele and Dick Waters strongly support this proposal.  (As an example,Guy Steele has a portable simulator for Connection Machine Lisp, and wouldlike very much to have xappings and xectors pretty-print properly.)Dan Pierson comments: You can add me to the list of strong supporters ofthis proposal.  While the proposal is long and complex, it is supported bya long history of usage in several different Lisp environments.  Unlikesome earlier members of this family, this version fits cleanly enough intothe rest of Common Lisp to warrant standardization.The utility of *PRINT-LINES* becomes more obvious if it is pointed outthat Dick's pretty printers are implemented to print each line as itis computed.  This means that a small value for *PRINT-LINES* savessignificant time as well as output medium space.  In fact, many peoplefind that a very pleasant REP loop is created by setting *PRINT-LINES*to a value from 1-4, *PRINT-PRETTY* to T, and defining a short-namefunction (say (PP*)) that funcalls *LAST-ABBREVIATED-PRINTING* withabbreviation bound off.  This is almost as fast and compact as, andMUCH more readable than, a non-pretty-printing REP loop.The advantages of compiled format strings (format functions) should bebrought out as benefits in their own right.  The current proposal justmentions them as a minor feature of XP.At first this struck me a very cute end run around the failure ofSTREAM-INFO, then I realized that one of the problems with STREAM-INFOmay have been that it was a standard at the wrong level.  STREAM-INFOpermitted people to use XP, but not to count on it.  This proposalmakes it possible to write portable code whose new data structures andlanguage elements print correctly in whatever Common Lisp environmentthey're run in.  [End of comments by Pierson]It has been noted by Guy Steele that some places in the initial documentwhere it says that circularity detection is handled correctly, this istrue a fortiori following the decision on PRINT-CIRCLE-STRUCTURE.However, Waters notes that the vote on PRINT-CIRCLE-STRUCTURE saidnothing about the handling of *PRINT-LEVEL*.  Therefore, the fact thatXP handles *PRINT-LEVEL* correctly is an improvement.In addition, PRINT-CIRCLE-STRUCTURE is also silent on what is supposedto happen if a user program decomposes a list itself (e.g., with DOLISTor ~{~}) rather than calling a print function.  Assumedly *PRINT-CIRCLE*etc. is not handled in this case.  In contrast, if one usesWITHIN-LOGICAL-BLOCK or ~<~:>, then *PRINT-CIRCLE*, *PRINT-LEVEL*, and*PRINT-LENGTH* are all automatically handled correctly.For example, (format nil "-~1{~A ~A ~A ~A ~A ~}-" '#1=(1 #1# 2 . #1#))?produces "-1 #1=(1 #1# 2 . #1#) 2 1 #1=(1 #1# 2 . #1#) -"even under PRINT-CIRCLE-STRUCTURE and(format nil "-~1{~A ~}-" '#1=(1 #1# 2 . #1#)) cause infinite looping.  However, in XP,(format nil "-~:<~W ~W ~W ~W ~W~:>-" '#1=(1 #1# 2 . #1#))produces "-#1=(1 #1# 2 . #1#)-".This proves to be very useful when writing pretty printing functions for things.Note also that ~<~:> supports *print-level* and *print-length* correctly.All the same things can be said about the functional interface and usingWITHIN-LOGICAL-BLOCK rather than traversing a list yourself in some fashion.All in all, Waters claims that PRINT-CIRCLE-STRUCTURE covers at most 1/4of what XP does in support of *print-circle* and does not cover anythingof what XP does to support *print-level*, *print-length*, androbustness in the face of malformed arguments.  These are vitalfeatures for writing printing functions that really work right all the time.It has been noted by Dave Moon that things would be much more elegant ifDEFINE-PRINT-DISPATCH could be expressed directly as a CLOS DEFMETHODfor an appropriate generic function.  Dick Waters agrees with this.However, DEFINE-PRINT-DISPATCH depends on type specifiers that are morecomplex than the ones CLOS deals with and ones that do not have clearsubtype/supertype relationships, compensating for the latter problem bysupporting numerical priorities to disambiguate things.  (The defaultingbehavior is a key feature of the pretty printer.)  At the very least,this means that DEFINE-PRINT-DISPATCH will not fit into CLOS in a simple way.Given the problems, Moon suggests that "it does seem that right now itmight be best to keep a separate DEFINE-PRINT-DISPATCH macro, with theidea that the expansion is implementation-dependent at the moment, butmight some day be changed to be defined to expand into DEFMETHOD.  Ihaven't looked to see whether any syntactic changes would be appropriateto make that transition smoother."(Waters also worries that the overhead needed to locate the right CLOSmethod would seriously degrade the pretty printer, because the printerhas to do this for every part of every object printed.  This dispatching iscurrently done by very fast code that is tuned to take advantage of theobserved distribution of kinds of objects that have special prettyprinters attached to them.  Even with this special purpose code,dispatching takes a significant part of the pretty printer's time.)Dave Moon also comments that it is not good to have something that lookslike a type specifier (i.e., the extended form of the CONS type specifierused by DEFINE-PRINT-DISPATCH) and yet is not a real type specifier.  Hesuggests that we should either amend Common Lisp to accept the extendedform of the CONS type specifier, or stop having DEFINE-PRINT-DISPATCHuse it.  Waters supports any course of action that retains the use of theextended CONS type specifier in conjunction with DEFINE-PRINT-DISPATCH.However, he notes that the trade-off is clear.  One could avoid thecomplex CONS type specifier without any significant loss offunctionality by introducing a new macro DEFINE-LIST-PRINT-DISPATCH thatis identical to DEFINE-PRINT-DISPATCH except that it is relevant only toconses and the type specifier applies to the CAR of the object to beprinted rather than to the object as a whole.  However, this appears tohim to be significantly less elegant than the current approach.-------------------- detailed documentation --------------------The full description is too large to fit in with everything else in thismessage.  A fully correct version follows in a separate message.  Thestuff below summarizes all of the changes from the full description inversion 1.                          AmendmentsTo a considerable extent, the design of the XP interface is completelyneutral about the issue of variable- versus fixed- width fonts.  Inparticular, most of the discussion of how the formating proceeds eithertalks about absolute positions of zero or talks about something beingin the same horizontal position as something else.  These statements areall font-independent.  (Further, although Waters' current implementationdoes not support variable-width fonts, the algorithms used could beextended to support them without radical changes.)Nevertheless, there are 9 places where users specify explicitnon-zero lengths: the variables *PRINT-RIGHT-MARGIN*,*DEFAULT-RIGHT-MARGIN*, and *PRINT-MISER-WIDTH*, the numericarguments to ~T, ~I, and ~/tabular-style/ and their associated functionsLOGICAL-BLOCK-TAB, LOGICAL-BLOCK-INDENT, and TABULAR-STYLE.It is proposed that all of these lengths be in the same units, and thatthis unit be ems (the length of an "m" in the font currently being usedto output characters to the relevant output stream at the moment thatthe command is encountered or a variable is consulted).It is further proposed that users and implementors be advised to setthings up so that explicit lengths do not have to be specified.  Forimplementors, this means making streams smart enough that they know howwide they are.  (This avoids the use of *PRINT-RIGHT-MARGIN* and*DEFAULT-RIGHT-MARGIN* in most situations.)  For users, this meansrelying on streams knowing their own widths (which is a good idea foradaptability in any case) and using ~:I to specify indentations whereverpossible.  Further, it should be noted that since *PRINT-MISER-WIDTH* isessentially heuristic in nature, it does not matter if its value is onlyan approximate length and users will only need to change thevalue of *PRINT-MISER-WIDTH* in unusual situations.  This leaves onlytabbing as an area where explicit lengths have to be specified on aregular basis.  Fortunately, approximate lengths are often acceptable inthis situation as well.                  Functional Interface  The primary interface to operations for dynamically determining thearrangement of output is provided through FORMAT.  This is done,because FORMAT strings are typically the most convenient way ofinteracting with pretty printing.  However, these operations havenothing inherently to do with FORMAT per se.  In particular, they canalso be accessed via the six functions and macros below.WITHIN-LOGICAL-BLOCK (STREAM-SYMBOL LIST                     [Macro]                      :PREFIX :PER-LINE-PREFIX :SUFFIX)                      &BODY BODYIn the manner of ~<...~:>, this macro causes printing to begrouped into a logical block.  The value NIL is always returned.STREAM-SYMBOL must be a symbol.  If it is NIL, it is treated the same asif it were *STANDARD-OUTPUT*.  If it is T, it is treated the same as ifit were *TERMINAL-IO*.  The run-time value of STREAM-SYMBOL must be astream.  The logical block is printed into this destination stream.The BODY can contain any arbitrary Lisp forms.  Within the BODY,STREAM-SYMBOL is bound to a special kind of stream that supports dynamicdecisions about the arrangement of output and then forwards the outputto the destination stream.  All the standard printing functions (e.g.,WRITE, PRINC, TERPRI) can be used to print output into STREAM-SYMBOL.All and only the output sent to STREAM-SYMBOL is treated as being in thelogical block.  (It is an error to send any output directly to theunderlying destination stream.)The :SUFFIX, :PREFIX, and :PER-LINE-PREFIX must all be expressions that(at run time) evaluate to strings.  :SUFFIX (which defaults to the nullstring) specifies a suffix that is printed just after the logical block.:PREFIX specifies a prefix to be printed before the beginning of thelogical block.  :PER-LINE-PREFIX specifies a prefix that is printedbefore the block and at the beginning of each new line in the block.  Itis an error for :PREFIX and :PRE-LINE-PREFIX to both be used. If neitheris used, a :PREFIX of the null string is assumed.LIST is interpreted as being a list that BODY is responsible forprinting.  If LIST does not (at run time) evaluate to a list, it isprinted using WRITE.  If *PRINT-CIRCLE* is not NIL and LIST is acircular reference to a cons, then an appropriate #n# marker is printed.If *PRINT-LEVEL* is not NIL and the logical block is at a dynamicnesting depth of greater than *PRINT-LEVEL* in logical blocks, # isprinted.  If either of the three conditions above occures, the indicatedspecial output is printed on STREAM-SYMBOL and the BODY is skipped alongwith the printing of the prefix and suffix.  (If the BODY isnot responsible for printing a list, then the first two tests above canbe turned off by supplying NIL for the LIST argument.)CONDITIONAL-NEWLINE KIND &OPTIONAL (STREAM *STANDARD-OUTPUT*)    [Function]CONDITIONAL-NEWLINE is the functional equivalent of ~_.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions (i.e., NIL stands for*STANDARD-OUTPUT* and T stands for *TERMINAL-IO*).  The KIND argumentspecifies the style of conditional newline.  It must be one of :LINEAR,:FILL, :MISER, or :MANDATORY.  If STREAM is a special stream bound byWITHIN-LOGICAL-BLOCK, a conditional newline is sent to it.  Otherwise,CONDITIONAL-NEWLINE has no effect.  The value NIL is always returned.LOGICAL-BLOCK-INDENT RELATIVE-TO N &OPTIONAL (STREAM *STANDARD-OUTPUT*) [Function]LOGICAL-BLOCK-INDENT is the functional equivalent of ~I.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions.  N specifies the indentation inems.  If RELATIVE-TO is :BLOCK, this indentation is relative to thestart of the enclosing block (as for ~I).  If RELATIVE-TO is :CURRENT,the indentation is relative to the current output position (as for ~:I).It is an error for RELATIVE-TO to take on any other value.  If STREAM isa special stream bound by WITHIN-LOGICAL-BLOCK, LOGICAL-BLOCK-INDENTsets the indentation in the innermost enclosing logical block.Otherwise, LOGICAL-BLOCK-INDENT has no effect.  The value NIL is alwaysreturned.LOGICAL-BLOCK-TAB KIND COLNUM COLINC &OPTIONAL (STREAM *STANDARD-OUTPUT*)LOGICAL-BLOCK-TAB is the functional equivalent of ~T.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions.  The arguments COLNUM and COLINCcorrespond to the two numeric parameters to ~T and are in terms of ems.The KIND argument specifies the style of tabbing.  It must be one of:LINE (tab using ~T), :BLOCK (tab using ~:T), :LINE-RELATIVE (tab using~@T), or :BLOCK-RELATIVE (tab using ~:@T).  If STREAM is a specialstream bound by WITHIN-LOGICAL-BLOCK, tabbing is performed.  Otherwise,LOGICAL-BLOCK-TAB has no effect.  The value NIL is always returned.LOGICAL-BLOCK-POP ARGS &OPTIONAL (STREAM *STANDARD-OUTPUT*)      [Macro]LOGICAL-BLOCK-COUNT &OPTIONAL (STREAM *STANDARD-OUTPUT*)         [Macro]LOGICAL-BLOCK-POP is identical to POP except that it supports*PRINT-LENGTH* and *PRINT-CIRCLE*.  It is an error to useLOGICAL-BLOCK-POP anywhere other than syntactically nested within acall on WITHIN-LOGICAL-BLOCK.ARGS must be a symbol or expression acceptable to POP.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions.  If STREAM is a special streambound by WITHIN-LOGICAL-BLOCK, then LOGICAL-BLOCK-POP performs thespecial operations described below.  Otherwise, LOGICAL-BLOCK-POP isidentical to POP.Each time LOGICAL-BLOCK-POP is called, it performs three tests.  ifARGS is not a cons, ". " is printed followed by ARGS.  If*PRINT-LENGTH* is NIL and LOGICAL-BLOCK-POP has already been called*PRINT-LENGTH* times within the immediately containing logical block,"..." is printed.  If *PRINT-CIRCLE* is not NIL, and ARGS is a circularreference, then ". " is printed followed by an appropriate #n# marker.If either of the three conditions above occurs, the special output isprinted on :STREAM and the execution of the immediately containingWITHIN-LOGICAL-BLOCK is terminated except for the printing of thesuffix.  Otherwise, LOGICAL-BLOCK-POP pops the top value off of ARGSand returns this value.LOGICAL-BLOCK-COUNT is identical to LOGICAL-BLOCK-POP except that itdoes not take an ARGS argument, always returns NIL, and only performsthe second test discussed above.  It is useful when the components of anon-list are being printed.Using the functions above, TABULAR-STYLE could be defined as follows.  (defun tabular-style (s list &optional (colon? T) atsign? (tabsize nil))      (declare (ignore atsign?))    (if (null tabsize) (setq tabsize 16))    (within-logical-block (s list :prefix (if colon? "(" "")				  :suffix (if colon? ")" ""))     (when list       (loop (write (logical-block-pop list s) :stream s)	     (if (null list) (return nil))	     (write-char #\space s)	     (logical-block-tab :block-relative 0 tabsize s)	     (conditional-newline :fill s)))))    The function below prints a vector using #(...) notation.      (defun print-vector (v *standard-output*)    (within-logical-block (nil nil :prefix "#(" :suffix ")")      (let ((end (length v)) (i 0))	(when (plusp end)	  (loop (logical-block-count)		(write (aref v i))		(if (= (incf i) end) (return nil))		(write-char #\space)		(conditional-newline :fill))))))FILL-STYLE STREAM LIST &OPTIONAL (COLON? T) ATSIGN?LINEAR-STYLE STREAM LIST &OPTIONAL (COLON? T) ATSIGN?TABULAR-STYLE STREAM LIST &OPTIONAL (COLON? T) ATSIGN? (TABSIZE 16)The directives ~/fill-style/, ~/linear-style/, and ~/tabular-style/ aresupported by the three functions above.  These functions can also becalled directly by the user.  Each function prints parentheses aroundthe output if an only if COLON? (default T) is not NIL.  Each functionignores its ATSIGN? argument and returns NIL.  (These arguments areoptional to facilitate the direct use of the three functions.)  Eachfunction handles abbreviation and circularity detection correctly, anduses WRITE to print LIST when given a non-list argument.The function LINEAR-STYLE prints a list either all on one line, or witheach element on a separate line.  The function FILL-STYLE prints a listwith as many elements as possible on each line.  The functionTABULAR-STYLE is the same as FILL-STYLE except that it prints theelements so that they line up in columns.  This function takes anadditional argument TABSIZE (default 16) that specifies the columnspacing in ems.[End of attached document]*start*40570 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 22-Mar-89 12:06:37 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 MAR 89 11:50:53 PSTReceived: from life.ai.mit.edu by SAIL.Stanford.EDU with TCP; 22 Mar 89  10:56:27 PSTReceived: from wheat-chex.ai.mit.edu by life.ai.mit.edu; Wed, 22 Mar 89 13:56:35 ESTReceived: from localhost by wheat-chex.ai.mit.edu; Wed, 22 Mar 89 13:56:33 ESTDate: Wed, 22 Mar 89 13:56:33 ESTFrom: dick@wheaties.ai.mit.eduMessage-Id: <8903221856.AA10674@wheat-chex.ai.mit.edu>To: cl-cleanup@sail.stanford.eduSubject: PRETTY-PRINT-INTERFACE, version 4Issue:		PRETTY-PRINT-INTERFACEFull description of XP accompanying version 4 of the proposal--------------------			   Pretty Printing			  Richard C. WatersPretty printing has traditionally been a black box process, displayingprogram code using a set of fixed layout rules.  Its utility can be greatlyenhanced by opening it up to user control.By providing direct access to the mechanisms within the pretty printer thatmake dynamic decisions about layout, the FORMAT directives ~_, ~I, and~<...~:> make it possible to specify pretty printing layout rules as a partof any function that produces output.  They also make it very easy forcircularity detection and abbreviation based on length and nesting depth tobe supported by the function.  The construct DEFINE-PRINT-DISPATCH makes itpossible to associate a user-defined pretty printing function with any typeof object.  Together, these facilities enable users to redefine the waycode is displayed and allow the full power of pretty printing to be appliedto complex combinations of data structures.		  Pretty Printing Control Variables*PRINT-DISPATCH*                                                 [variable]When *PRINT-PRETTY* is not NIL, the print dispatch table in*PRINT-DISPATCH* controls the way objects are printed.  The initial valueof *PRINT-DISPATCH* causes traditional pretty printing of Lisp code.*PRINT-RIGHT-MARGIN*                                             [variable]*DEFAULT-RIGHT-MARGIN*                                           [variable]The goal of dynamic layout decisions (when pretty printing or when directlyspecified via ~_, ~I, and ~<...~:>) is to keep the output between a pair ofmargins.  The left margin is set at the column where the output begins.  Ifthis cannot be determined, the left margin is set to zero.When *PRINT-RIGHT-MARGIN* is not NIL, it specifies the right margin to usewhen making layout decisions.  When *PRINT-RIGHT-MARGIN* is NIL (theinitial value), the right margin is set at the maximum line length that canbe displayed by the output stream without wraparound or truncation.  Ifthis cannot be determined, the right margin is set to*DEFAULT-RIGHT-MARGIN*.  The initial value of *DEFAULT-RIGHT-MARGIN* isimplementation-dependent.To allow for the possibility of variable-width fonts, both of thesevariables are interpreted in terms of ems---the length of an "m"in the font being used to display characters on the relevant outputstream at the moment when the variables are consulted.*PRINT-MISER-WIDTH*                                              [variable]If *PRINT-MISER-WIDTH* is not NIL, the pretty printer switches to a compactstyle of output (called miser style) whenever the width available forprinting a substructure is less than or equal to *PRINT-MISER-WIDTH* ems.  Theinitial value of *PRINT-MISER-WIDTH* is implementation-dependent.!*PRINT-LINES*                                                    [variable]When given a value other than its initial value of NIL, *PRINT-LINES*limits the number of output lines produced when something is printed.  Ifan attempt is made to go beyond *PRINT-LINES* lines, " ---" is printed atthe end of the last line and printing stops.(let ((*print-right-margin* 20) (*print-lines* 3))  (pprint '(setq a 1 b 2 c 3 d 4)))(SETQ A 1      B 2      C 3 ---*LAST-ABBREVIATED-PRINTING*                                      [variable]This variable records the last printing event where abbreviation occurred.Funcalling its value (e.g., after turning off abbreviation) causes theprinting to happen a second time.The function WRITE accepts keyword arguments :DISPATCH, :RIGHT-MARGIN,:LINES, and :MISER-WIDTH corresponding to *PRINT-DISPATCH*,*PRINT-RIGHT-MARGIN*, *PRINT-LINES*, and *PRINT-MISER-WIDTH*.		   Compiling Format Control StringsThe control strings used by FORMAT are essentially programs that performprinting.  The readmacro character #"..." provides the efficiency of usinga compiled function for printing without losing the conciseness of FORMATcontrol strings.  In the notation #"...", the string following # isidentical to a FORMAT control string.  However, the readmacro translates itinto an equivalent sharp-quoted function.  The first expression below isequivalent to the second.#"~%~@{~S~^, ~}"#'(lambda (stream &rest args)    (terpri stream)    (loop (prin1 (pop args) stream)          (if (null args) (return nil))          (write-string ", " stream)))In support of the above, FORMAT accepts functions as its second argument aswell as strings.  When a function is provided, it is called with theappropriate output stream as its first argument and the data arguments toFORMAT as its remaining arguments.  The function should perform whateveroutput is necessary.  The values returned by the function are ignored.  Thedirective ~? also accepts functions as well as control strings.!	     Dynamic Control of the Arrangement of OutputThe following FORMAT directives support precise control of what should bedone when a piece of output is too large to fit in the space available.Three concepts underlie the way these directives work---`logical blocks',`conditional newlines', and `sections'.The first line of Figure 1 shows a schematic piece of output.  Thecharacters in the output are represented by "-".  The positions ofconditional newlines are indicated by digits.  The beginnings and ends oflogical blocks are indicated by "<" and ">" respectively.The output as a whole is a logical block and the outermost section.  Thissection is indicated by the 0's on the second line of Figure 1.  Logicalblocks nested within the output are specified by ~<...~:> directives.Conditional newline positions are specified by ~_ directives.  Eachconditional newline defines two sections (one before it and one after it)and is associated with a third (the section immediately containing it).The section after a conditional newline consists of: all the output up to,but not including, (a) the next conditional newline immediately containedin the same logical block; or if (a) is not applicable, (b) the nextnewline that is at a lesser level of nesting in logical blocks; or if (b)is not applicable, (c) the end of the output.The section before a conditional newline consists of: all the output backto, but not including, (a) the previous conditional newline that isimmediately contained in the same logical block; or if (a) is notapplicable, (b) the beginning of the immediately containing logical block.The last four lines in Figure 1 indicate the sections before and after thefour conditional newlines.The section immediately containing a conditional newline is the shortestsection that contains the conditional newline in question.  In Figure 1,the first conditional newline is immediately contained in the sectionmarked with 0's, the second and third conditional newlines are immediatelycontained in the section before the fourth conditional newline, and thefourth conditional newline is immediately contained in the section afterthe first conditional newline.                 <-1---<--<--2---3->--4-->->                 000000000000000000000000000                 11 111111111111111111111111                           22 222                              333 3333                        44444444444444 44444Figure 1: Example of logical blocks, conditional newlines, and sections.Whenever possible, the pretty printer displays the entire contents of asection on a single line.  However, if the section is too long to fit inthe space available, line breaks are inserted at conditional newlinepositions within the section.!~W                                                          [format directive]WRITE -- An arg, any Lisp object, is printed obeying every printer controlvariable (as by WRITE).  In addition, ~W interacts correctly with depthabbreviation, by not resetting the depth counter to zero.  ~W does notaccept parameters.  If given the colon modifier, ~W binds *PRINT-PRETTY* toT.  If given the atsign modifier, ~W binds *PRINT-LEVEL* and *PRINT-LENGTH*to NIL.~W provides automatic support for circularity detection.  If *PRINT-CIRCLE*is T and ~W is applied to an argument that has already been encounteredduring the printing process, an appropriate #n# marker is inserted in theoutput instead of printing the argument.Circularity detection is supported by effectively doing the printing twice.On the first pass, circularities are detected and the actual outputting ofcharacters is suppressed.  On the second pass, the appropriate #n= and #n#markers are inserted and characters are output.~_                                                          [format directive]CONDITIONAL NEWLINE -- Without any modifiers, ~_ specifies a`linear-style' conditional newline.  A line break is inserted if and onlyif the immediately containing section cannot be printed on one line.  Theeffect of this is that line breaks are either inserted at everylinear-style conditional newline in a logical block or at none of them.~@_ specifies a `miser-style' conditional newline.  A line break isinserted if and only if the immediately containing section cannot beprinted on one line and miser style is in effect in the immediatelycontaining logical block.  The effect of this is that miser-styleconditional newlines act like linear-style conditional newlines, but onlywhen miser style is in effect.  Miser style is in effect for a logicalblock if and only if the the starting column of the logical block is lessthan or equal to *PRINT-MISER-WIDTH* columns from the right margin.~:_ specifies a `fill-style' conditional newline.  A line break isinserted if and only if either (a) the following section cannot be printedon the end of the current line, (b) the preceding section was not printedon a single line, or (c) the immediately containing section cannot beprinted on one line and miser style is in effect in the immediatelycontaining logical block.  If a logical block is broken up into a numberof subsections by fill-style conditional newlines, the basic effect isthat the logical block is printed with as many subsections as possible oneach line.  However, if miser style is in effect, fill-style conditionalnewlines act like linear-style conditional newlines.~:@_ specifies a `mandatory-style' conditional newline.  A line break isalways inserted.  This implies that none of the containing sections can beprinted on a single line and will therefore trigger the insertion of linebreaks at linear-style conditional newlines in these sections.When a line break is inserted by any type of conditional newline, anyblanks that immediately precede the conditional newline are omitted fromthe output and indentation is introduced at the beginning of the next line.By default, the indentation causes the following line to begin in the samecolumn as the first character in the immediately containing logical block.The indentation can be changed via ~I.There are a variety of ways unconditional newlines can be introduced intothe output (e.g., via ~% or by printing a string containing a newlinecharacter).  As with mandatory conditional newlines, this prevents any ofthe containing sections from being printed on one line.  In general, whenan unconditional newline is encountered, it is printed out withoutsuppression of the preceding blanks and without any indentation followingit.  However, if a per-line prefix has been specified (see ~<...~:>), thisprefix will always be printed no matter how a newline originates.!~<...~:>                                                    [format directive]LOGICAL BLOCK -- If ~:> is used to terminate a ~<...~>, the directivedelimits a logical block.  In addition, ~<...~:> descends into thecorresponding FORMAT argument (a list) in the same way as the directive~1{...~:}.  ~^ can be used to exit from ~<...~:> just as it can be used toexit from ~{...~}.The portion of a FORMAT control string enclosed in ~<...~:> can be dividedinto segments ~<prefix~;body~;suffix~:> by ~; directives.  It is an errorfor the enclosed portion to be divided into more than three segments.  Ifthe enclosed portion is divided into only two segments, the suffix defaultsto the null string.  If the enclosed portion consists of only a singlesegment, both the prefix and the suffix default to the null string.  If thecolon modifier is used with ~<...~:>, the prefix and suffix default to "("and ")" (respectively) instead of to the null string.The prefix and suffix must both be constant strings.  They cannot containFORMAT directives.  The body can be any arbitrary FORMAT control string.The prefix is printed out just before the logical block is started and thesuffix is printed out just after the logical block ends.  This is done evenwhen the argument corresponding to ~<...~:> is an empty list.If ~<...~:> is applied to an argument that is not a list, the directive isignored (suppressing the output of the prefix and suffix) and the offendingargument is printed using ~W.  This makes it easier to write FORMAT stringsthat are robust in the face of malformed arguments.During the processing of the FORMAT string nested in ~<...~:>, argumentsare taken one by one from the list passed to ~<...~:>.  If an attempt ismade to access an argument at a time when the remaining portion of thisargument list is not a cons, then ". " is inserted in the output, ~W isused to print out the remaining argument list, and the processing of thelogical block is terminated, except for printing the suffix (if any).  Thismakes it easier to write FORMAT strings that are robust in the face ofmalformed argument lists.  (Note that ~^ exits only when the remainingargument list is NIL.)~<...~:> provides automatic support for depth abbreviation.  If*PRINT-LEVEL* is not NIL and ~<...~:> is encountered at a dynamic nestingdepth in logical blocks greater than *PRINT-LEVEL*, "#" is inserted in theoutput and the ~<...~:> and its associated argument are ignored.~<...~:> provides automatic support for length abbreviation.  If*PRINT-LENGTH* is not NIL, a count is kept of the number of arguments usedwithin the ~<...~:>.  If this count ever reaches *PRINT-LENGTH*, " ..." isinserted in the output and the processing of the logical block isterminated, except for printing the suffix (if any).~<...~:> also provides automatic support for circularity detection.  If*PRINT-CIRCLE* is T and ~<...~:> (without the atsign modifier) is appliedto a list argument that has already been encountered during the printingprocess, an appropriate #n# marker is inserted in the output and the~<...~:> and its associated argument are ignored.!In addition, if an attempt is made to access an argument from the listpassed to ~<...~:>, at a time when the remaining portion of this list hasalready been encountered during the printing process, ". #n#" is insertedin the output and the processing of the logical block is terminated, exceptfor printing the suffix (if any).  This catches instances of CDRcircularity in lists.For circularity detection to work correctly when printing an object, everypart of the object that is a cons must be printed using ~<...~:> and everynon-cons must be printed using ~W.  If some part is printed some other way(e.g., using ~S), circularities involving this part will be missed.If the atsign modifier is used with ~<...~:>, the entire remaining argumentlist is passed to the directive as its argument.  Unlike ~1@{...~} all ofthe remaining arguments are always consumed by ~@<...~:>, even if they arenot all used by the FORMAT string nested in the directive.As an example of the interaction of conditional newlines and logicalblocks, consider the following.  The FORMAT string specifies how to prettyprint a LET.  The outermost ~:<...~:> decomposes the input and specifiesthat parentheses should be printed in the output.  The~:<~@{~:<~@{~W~^~ _~}~:>~^ ~:_~}~:> decomposes the list of binding pairs.Each pair in the list is itself decomposed and printed using~:<~@{~W~^ ~_~}~:>.  (An iteration is used in this FORMAT string instead ofmerely decomposing the pair into two elements so that a malformed paircontaining more than two elements will print readably.)  A space and afill-style conditional newline are placed after each pair except the last.The ~@{~^~_ ~W~} prints out the forms in the body of the LET separated byspaces and linear-style conditional newlines.(format T #"~:<~W~^ ~:<~@{~:<~@{~W~^ ~_~}~:>~^ ~:_~}~:>~            ~@{~^~_ ~W~}~:>"        '#1=(let (x (*print-length* (f (g 3)))                   (z . 2) (k (car y)))              (setq x (sqrt z)) #1#))Suppose that *PRINT-PRETTY* is T, *PRINT-LEVEL* is 4, and *PRINT-CIRCLE* isT.  If the line length is greater than or equal to 77, the output producedby the FORMAT above appears on one line.  However, if the line length is76, line breaks are inserted at the linear-style conditional newlinesseparating the forms in the body and the output below is produced.  Notethat, the degenerate binding pair X is printed readably even though itfails to be a list; a depth abbreviation marker is printed in place of(G 3); the binding pair (Z . 2) is printed readably even though it failsto be a proper list; and appropriate circularity markers are printed.#1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y)))      (SETQ X (SQRT Z))     #1#)If the line length is reduced to 35, a line break is inserted at one of thefill-style conditional newlines separating the binding pairs.#1=(LET (X (*PRINT-PRETTY* (F #))         (Z . 2) (K (CAR Y)))     (SETQ X (SQRT Z))     #1#)!Suppose that the line length is further reduced to 22 and *PRINT-LENGTH* isset to 3. In this situation, line breaks are inserted after both the firstand second binding pairs.  In addition, the second binding pair is itselfbroken across two lines.  Clause (b) of the description of fill-styleconditional newlines prevents the binding pair (Z . 2) from being printedat the end of the third line.  Note that the length abbreviation hides thecircularity from view and therefore the printing of circularity markersdisappears as well.(LET (X      (*PRINT-LENGTH*       (F #))      (Z . 2) ...)  (SETQ X (SQRT Z))  ...)If ~@; is used to terminate the prefix in ~<...~:>, the prefix is a`per-line' prefix.  A per-line prefix is printed at the beginning of everyline in the logical block, rather than just before the start of the blockas a whole.  Each instance of the prefix is lined up below the occurrenceof the prefix on the first line.  With a line length of 25, the form belowproduces the output shown.(format T #"~<;;; ~@;Roads ~<= ~@;~W, ~:_~W~:>  ~:_ Town ~W~:>"           '((elm cottonwood) boston));;; Roads = ELM,;;;       = COTTONWOOD;;;  Town BOSTONIf ~<...~:> is terminated with ~:@>, then a fill-style conditional newlineis automatically inserted after each group of blanks immediately containedin the body (except for blanks after a ~<newline> directive).  This makesit easy to achieve the equivalent of paragraph filling.  With a line lengthof 12, the form below produces the output shown.(format T #"~<~:(~W~) street goes to ~:(~W~).~:@>"         '(main boston))Main streetgoes toBoston.To a considerable extent, the basic form of the directive ~<...~> isincompatible with the dynamic control of the arrangement of output by ~W,~_, ~<...~:>, ~I, and ~:T.  As a result, it is an error for any of thesedirectives to be nested within ~<...~>.  Beyond this, it is also an errorfor the ~<...~:;...~> form of ~<...~> to be used at all in conjunction withany of these directives.!~I                                                          [format directive]INDENT -- ~nI specifies that the indentation within the immediatelycontaining logical block should be set to the column position of thefirst character in the block plus n ems.  If omitted, n defaults tozero.  The parameter can be negative; however, the total indentationcannot be moved left of the beginning of the line or left of the end ofthe rightmost per-line prefix.  ~n:I is exactly the same as ~nI exceptthat it operates relative to the position in the output of the directiveitself, rather than relative to the first character in the block.  (Forrobustness in the face of variable-width fonts, it is advisable to use~:I with a parameter of zero instead of ~I whenever possible.)  Changesin indentation caused by a ~I directive do not take effect until afterthe next line break.  Consider the following example:(format T #"~:<~W ~@_~:I~W ~:_~W ~1I~_~W~:>"         '(defun prod (x y) (* x y)))If the line width available is 15, both the ~:_ and the ~_ are replaced byline breaks.  The ~:I directive before the ~W that prints the function namecauses the argument list to be lined up under the function name.  The ~1Idirective before the ~_ specifies that the statement in the body of theDEFUN should be printed at a relative indentation of 1 in the logicalblock.(DEFUN PROD       (X Y)  (* X Y))In miser style, all ~I directives are ignored, forcing the linescorresponding to the logical block to line up under the first character inthe block.  If *PRINT-MISER-WIDTH* were greater than or equal to 14 (theblock begins in the second column, after the prefix "(" IS printed), theexample output above would have been as follows.(DEFUN PROD (X Y) (* X Y))~:T                                                         [format directive]TABULATE -- If the colon modifier is used with the ~T directive, thetabbing computation is done relative to the column where the sectionimmediately containing the directive begins, rather than with respect tocolumn zero.  The numerical parameters are both interpreted as being inunits of ems.  Consider the following example.  Each street name isfollowed by a ~8:T, which ensures that the total width taken up will bea multiple of 8.  With a line width of 25, the output shown is produced.(format T #"~<Roads ~:I~@_~@{~W~^~8:T~:_~}~:>"        '(elm main maple center))Roads ELM     MAIN      MAPLE   CENTER!~/name/                                                     [format directive]CALL FUNCTION -- User defined functions can be called from within a FORMATstring by using the directive ~/name/.  The colon modifier, the atsignmodifier, and arbitrarily many parameters can be specified with the ~/name/directive.  The name can contain a package prefix, but it cannot contain"/".  If the readmacro #"..." is used, the default package associated withname will be the value of *PACKAGE* at the moment the #"..." is read.  Ifan ordinary FORMAT control string is used, the default package will be thevalue of *PACKAGE* at the moment the string is processed by FORMAT.When a ~/name/ directive is encountered, the indicated function is calledwith four or more arguments.  The first four arguments are: the outputstream, the FORMAT argument corresponding to the directive, the value T ifthe colon modifier was used (NIL otherwise), and the value T if the atsignmodifier was used (NIL otherwise).  The remaining arguments consist of anyparameters specified with the directive.  The function should print theargument appropriately.  Any values returned by the function are ignored.~/LINEAR-STYLE/                                             [format directive]An argument, a list, is printed so that either all of the elements are onone line or each element is on a separate line.  Parentheses are printedaround the list if the colon modifier is specified.  As an example of afunction intended to be called from within a FORMAT string, the definitionof LINEAR-STYLE is shown below.(defun linear-style (stream list &optional (colon? T) atsign?)    (declare (ignore atsign?))  (if colon?      (format stream #"~:<~@{~W~^ ~_~}~:>" list)      (format stream #"~<~@{~W~^ ~_~}~:>" list)))~/FILL-STYLE/                                               [format directive]An argument, a list, is printed with as many elements as possible on eachline.  Parentheses are printed around the list if the colon modifier isspecified.~/TABULAR-STYLE/                                            [format directive]An argument, a list, is printed in a tabular form with as many elements aspossible on each line.  In addition to the colon modifier, which causesparentheses to be printed, ~/TABULAR-STYLE/ takes a parameter(default 16) that specifies the width in ems of columns in the table.!                  Functional Interface  The primary interface to operations for dynamically determining thearrangement of output is provided through FORMAT.  This is done,because FORMAT strings are typically the most convenient way ofinteracting with pretty printing.  However, these operations havenothing inherently to do with FORMAT per se.  In particular, they canalso be accessed via the six functions and macros below.WITHIN-LOGICAL-BLOCK (STREAM-SYMBOL LIST                     [Macro]                      :PREFIX :PER-LINE-PREFIX :SUFFIX)                      &BODY BODYIn the manner of ~<...~:>, this macro causes printing to begrouped into a logical block.  The value NIL is always returned.STREAM-SYMBOL must be a symbol.  If it is NIL, it is treated the same asif it were *STANDARD-OUTPUT*.  If it is T, it is treated the same as ifit were *TERMINAL-IO*.  The run-time value of STREAM-SYMBOL must be astream.  The logical block is printed into this destination stream.The BODY can contain any arbitrary Lisp forms.  Within the BODY,STREAM-SYMBOL is bound to a special kind of stream that supports dynamicdecisions about the arrangement of output and then forwards the outputto the destination stream.  All the standard printing functions (e.g.,WRITE, PRINC, TERPRI) can be used to print output into STREAM-SYMBOL.All and only the output sent to STREAM-SYMBOL is treated as being in thelogical block.  (It is an error to send any output directly to theunderlying destination stream.)The :SUFFIX, :PREFIX, and :PER-LINE-PREFIX must all be expressions that(at run time) evaluate to strings.  :SUFFIX (which defaults to the nullstring) specifies a suffix that is printed just after the logical block.:PREFIX specifies a prefix to be printed before the beginning of thelogical block.  :PER-LINE-PREFIX specifies a prefix that is printedbefore the block and at the beginning of each new line in the block.  Itis an error for :PREFIX and :PRE-LINE-PREFIX to both be used. If neitheris used, a :PREFIX of the null string is assumed.LIST is interpreted as being a list that BODY is responsible forprinting.  If LIST does not (at run time) evaluate to a list, it isprinted using WRITE.  If *PRINT-CIRCLE* is not NIL and LIST is acircular reference to a cons, then an appropriate #n# marker is printed.If *PRINT-LEVEL* is not NIL and the logical block is at a dynamicnesting depth of greater than *PRINT-LEVEL* in logical blocks, # isprinted.  If either of the three conditions above occures, the indicatedspecial output is printed on STREAM-SYMBOL and the BODY is skipped alongwith the printing of the prefix and suffix.  (If the BODY isnot responsible for printing a list, then the first two tests above canbe turned off by supplying NIL for the LIST argument.)!CONDITIONAL-NEWLINE KIND &OPTIONAL (STREAM *STANDARD-OUTPUT*)    [Function]CONDITIONAL-NEWLINE is the functional equivalent of ~_.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions (i.e., NIL stands for*STANDARD-OUTPUT* and T stands for *TERMINAL-IO*).  The KIND argumentspecifies the style of conditional newline.  It must be one of :LINEAR,:FILL, :MISER, or :MANDATORY.  If STREAM is a special stream bound byWITHIN-LOGICAL-BLOCK, a conditional newline is sent to it.  Otherwise,CONDITIONAL-NEWLINE has no effect.  The value NIL is always returned.LOGICAL-BLOCK-INDENT RELATIVE-TO N &OPTIONAL (STREAM *STANDARD-OUTPUT*) [Function]LOGICAL-BLOCK-INDENT is the functional equivalent of ~I.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions.  N specifies the indentation inems.  If RELATIVE-TO is :BLOCK, this indentation is relative to thestart of the enclosing block (as for ~I).  If RELATIVE-TO is :CURRENT,the indentation is relative to the current output position (as for ~:I).It is an error for RELATIVE-TO to take on any other value.  If STREAM isa special stream bound by WITHIN-LOGICAL-BLOCK, LOGICAL-BLOCK-INDENTsets the indentation in the innermost enclosing logical block.Otherwise, LOGICAL-BLOCK-INDENT has no effect.  The value NIL is alwaysreturned.LOGICAL-BLOCK-TAB KIND COLNUM COLINC &OPTIONAL (STREAM *STANDARD-OUTPUT*)LOGICAL-BLOCK-TAB is the functional equivalent of ~T.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions.  The arguments COLNUM and COLINCcorrespond to the two numeric parameters to ~T and are in terms of ems.The KIND argument specifies the style of tabbing.  It must be one of:LINE (tab using ~T), :BLOCK (tab using ~:T), :LINE-RELATIVE (tab using~@T), or :BLOCK-RELATIVE (tab using ~:@T).  If STREAM is a specialstream bound by WITHIN-LOGICAL-BLOCK, tabbing is performed.  Otherwise,LOGICAL-BLOCK-TAB has no effect.  The value NIL is always returned.LOGICAL-BLOCK-POP ARGS &OPTIONAL (STREAM *STANDARD-OUTPUT*)      [Macro]LOGICAL-BLOCK-COUNT &OPTIONAL (STREAM *STANDARD-OUTPUT*)         [Macro]LOGICAL-BLOCK-POP is identical to POP except that it supports*PRINT-LENGTH* and *PRINT-CIRCLE*.  It is an error to useLOGICAL-BLOCK-POP anywhere other than syntactically nested within acall on WITHIN-LOGICAL-BLOCK.ARGS must be a symbol or expression acceptable to POP.  STREAM (whichdefaults to *STANDARD-OUTPUT*) follows the standard conventions forstream arguments to printing functions.  If STREAM is a special streambound by WITHIN-LOGICAL-BLOCK, then LOGICAL-BLOCK-POP performs thespecial operations described below.  Otherwise, LOGICAL-BLOCK-POP isidentical to POP.!Each time LOGICAL-BLOCK-POP is called, it performs three tests.  ifARGS is not a cons, ". " is printed followed by ARGS.  If*PRINT-LENGTH* is NIL and LOGICAL-BLOCK-POP has already been called*PRINT-LENGTH* times within the immediately containing logical block,"..." is printed.  If *PRINT-CIRCLE* is not NIL, and ARGS is a circularreference, then ". " is printed followed by an appropriate #n# marker.If either of the three conditions above occurs, the special output isprinted on :STREAM and the execution of the immediately containingWITHIN-LOGICAL-BLOCK is terminated except for the printing of thesuffix.  Otherwise, LOGICAL-BLOCK-POP pops the top value off of ARGSand returns this value.LOGICAL-BLOCK-COUNT is identical to LOGICAL-BLOCK-POP except that itdoes not take an ARGS argument, always returns NIL, and only performsthe second test discussed above.  It is useful when the components of anon-list are being printed.Using the functions above, TABULAR-STYLE could be defined as follows.  (defun tabular-style (s list &optional (colon? T) atsign? (tabsize nil))      (declare (ignore atsign?))    (if (null tabsize) (setq tabsize 16))    (within-logical-block (s list :prefix (if colon? "(" "")				  :suffix (if colon? ")" ""))     (when list       (loop (write (logical-block-pop list s) :stream s)	     (if (null list) (return nil))	     (write-char #\space s)	     (logical-block-tab :block-relative 0 tabsize s)	     (conditional-newline :fill s)))))    The function below prints a vector using #(...) notation.      (defun print-vector (v *standard-output*)    (within-logical-block (nil nil :prefix "#(" :suffix ")")      (let ((end (length v)) (i 0))	(when (plusp end)	  (loop (logical-block-count)		(write (aref v i))		(if (= (incf i) end) (return nil))		(write-char #\space)		(conditional-newline :fill))))))FILL-STYLE STREAM LIST &OPTIONAL (COLON? T) ATSIGN?LINEAR-STYLE STREAM LIST &OPTIONAL (COLON? T) ATSIGN?TABULAR-STYLE STREAM LIST &OPTIONAL (COLON? T) ATSIGN? (TABSIZE 16)The directives ~/fill-style/, ~/linear-style/, and ~/tabular-style/ aresupported by the three functions above.  These functions can also becalled directly by the user.  Each function prints parentheses aroundthe output if an only if COLON? (default T) is not NIL.  Each functionignores its ATSIGN? argument and returns NIL.  (These arguments areoptional to facilitate the direct use of the three functions.)  Eachfunction handles abbreviation and circularity detection correctly, anduses WRITE to print LIST when given a non-list argument.The function LINEAR-STYLE prints a list either all on one line, or witheach element on a separate line.  The function FILL-STYLE prints a listwith as many elements as possible on each line.  The functionTABULAR-STYLE is the same as FILL-STYLE except that it prints theelements so that they line up in columns.  This function takes anadditional argument TABSIZE (default 16) that specifies the columnspacing in ems.!			Print Dispatch TablesPretty printing is directed by print dispatch tables.COPY-PRINT-DISPATCH &optional (table *PRINT-DISPATCH*)           [function]A copy is made of table, which defaults to the current print dispatchtable.  If table is NIL, a copy is made of the initial print dispatchtable.DEFINE-PRINT-DISPATCH type-specifier options &body function      [macro]This puts an entry into a print dispatch table.  The type-specifier(which is implicitly quoted) is the key of the entry.  The functionspecifies how to pretty print the indicated type of object.  Whenappropriate, the function is called with two arguments: an outputstream and the object to print.  Any values returned by the function areignored.  The options are a list of pairs containing a keyword and avalue.  Three different keywords are supported:(:TABLE table) Specifies the table (default *PRINT-DISPATCH*) to put the dispatch entryinto.(:PRIORITY number)Specifies a priority (default 0) used to resolve conflicts when an objectmatches more than one entry.(:NAME name)Specifies a name to be given to function.  This makes it possible toreuse the function---e.g., in another call on DEFINE-PRINT-DISPATCH.Before doing anything else, DEFINE-PRINT-DISPATCH removes any existingentry with a type specifier EQUAL to the given type specifier.  A newentry containing the given priority and function is then created.The function in a DEFINE-PRINT-DISPATCH call can be specified in fivedifferent ways.  First, the function can be NIL.  In this case, no newentry is made after the old entry (if any) is removed.  Second, thefunction can be omitted altogether.  In this case, the standard prettyprinting function (if any) corresponding to the type specifier is enteredinto the table.  Third, the function can be an argument list followed by abody consisting of one or more statements.  (The use of &REST X in theargument list below makes it possible to use ~/RATIO-PRINT/ in a FORMATstring.)(define-print-dispatch ratio ((:name ratio-print))                        (s obj &rest x)    (declare (ignore x))  (format s #"#.(/ ~W ~W)" (numerator obj) (denominator obj)))(pprint '(2/3 -4/5)) prints: (#.(/ 2 3) #.(/ -4 5))!Fourth, the function can be an instance of #"...".(define-print-dispatch (and ratio (satisfies plusp))                        ((:priority 1))  #"(+ ~/ratio-print/)")(pprint '(2/3 -4/5)) prints: ((+ #.(/ 2 3)) #.(/ -4 5))Fifth, the function can be a sharp-quoted function name.  The definitionbelow shows the default method used for printing lists that represent data,rather than programs.  (As shown in the definition of LINEAR-STYLE above,LINEAR-STYLE, FILL-STYLE, and TABULAR-STYLE are all defined with theirCOLON? and ATSIGN? arguments optional so that they can be used asDEFINE-PRINT-DISPATCH functions.)(define-print-dispatch cons ((:priority -10)) #'fill-style)The entry to use for printing an object is selected by looking at theentries in *PRINT-DISPATCH* in the order of their priorities.  The firstentry whose type specifier matches the object is chosen.  If an objectmatches two entries with the same priority, an arbitrary choice is made.If no entry matches the object, the object is printed as if *PRINT-PRETTY*were NIL.(CONS car-type cdr-type)                                    [type specifier]When used simply as the symbol CONS, this type specifier matches anycons cell.  When used in the form above, it matches a cons cell only if thecar of the cell matches the type specifier car-type and the cdr ofthe cell matches the type specifier cdr-type.  The cdr-type canbe omitted in which case it defaults to T.The examples below show three of the predefined pretty printing functionsfor Lisp code.  By default, function calls are printed in the standardway---i.e, either all on one line or with the arguments one to a lineindented after the function name.(define-print-dispatch (cons (and symbol (satisfies fboundp)))                       ((:priority -5))  #"~:<~W~^ ~:I~@_~@{~W~^ ~_~}~:>")Lists beginning with COND are printed the same way as function calls,except that the clauses are always printed in linear style, rather than inthe format suggested by their cars.(define-print-dispatch (cons (member cond)) ()  #"~:<~W~^ ~:I~@_~@{~:/linear-style/~^ ~_~}~:>")Lists beginning with QUOTE are printed using the standard "'" syntax.  Notethe care taken to ensure that data lists that happen to begin with QUOTEwill be printed legibly.(define-print-dispatch (cons (member quote)) () (s list)  (if (and (consp (cdr list)) (null (cddr list)))      (format s #"'~W" (cadr list))      (fill-style s list)))!In addition to the last four entries shown above, the initial printdispatch table contains approximately fifty additional entries with typespecifiers of the form (CONS (MEMBER symbol)) and priority zero for variousLisp special forms and macros.  There are no other predefined prettyprinting functions for data structures other than lists.  However, as shownbelow, such entries can easily be defined.(defstruct family mom kids)(define-print-dispatch family () (s f)  (format s #"~@<#<~;~W and ~2I~_~/fill-style/~;>~:>"             (family-mom f) (family-kids f)))The pretty printing function for the structure FAMILY specifies how toadjust the layout of the output so that it can fit aesthetically into avariety of line widths.  In addition, it obeys the printer controlvariables *PRINT-LEVEL*, *PRINT-LENGTH*, *PRINT-LINES*, *PRINT-CIRCLE*, and*PRINT-ESCAPE*, and can tolerate several different kinds of malformity inthe data structure.  The output below shows what happens with line width25, *PRINT-PRETTY T, *PRINT-ESCAPE* NIL, and a malformed KIDS list.(write (list 'principle-family             (make-family :mom "Lucy"                          :kids '("Mark" "Bob" . "Dan"))))(PRINCIPLE-FAMILY #<Lucy and     Mark Bob . Dan>) Note that a pretty printing function for a structure is different from thestructure's print function.  While print functions are permanentlyassociated with a structure, pretty printing functions are stored in printdispatch tables and can be rapidly changed to reflect different printingneeds.  If there is no pretty printing function for a structure in thecurrent print dispatch table, the print function (if any) is used instead.[End of attached document]*start*01112 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 22-Mar-89 16:15:37 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 MAR 89 16:15:36 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Mar 89  16:11:53 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 563289; Wed 22-Mar-89 19:11:28 ESTDate: Wed, 22 Mar 89 19:11 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRETTY-PRINT-INTERFACE, version 4To: dick@wheaties.ai.mit.educc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8903221854.AA10669@wheat-chex.ai.mit.edu>Message-ID: <19890323001116.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Version 4 of the proposal looks good to me.  I noticed one typo,in the arguments of WITHIN-LOGICAL-BLOCK the word &KEY is missing.I still think that the FORMAT-based interface and the functionalinterface should be separated for voting purposes.*start*01043 00024 US Date:  4 Apr 89 13:02 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: PRETTY-PRINT-INTERFACETo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRETTY-PRINT-INTERFACETo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:51:29 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:31:42 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571245; Tue 4-Apr-89 15:31:40 EDTOriginal-Date: Tue, 4 Apr 89 15:31 EDTMessage-ID: <890404153114.7.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say this was deferred to the next meeting by a vote of N-2.*start*00839 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at  9-Apr-89 23:16:23 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 APR 89 23:16:24 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Apr 89  23:15:32 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 09 APR 89 23:15:22 PDTDate: 9 Apr 89 23:14 PDTFrom: masinter.paSubject: Re: PRETTY-PRINT-INTERFACE, version 4In-reply-to: dick@wheaties.ai.mit.edu's message of Wed, 22 Mar 89 13:54:34 ESTTo: dick@wheaties.ai.mit.educc: cl-cleanup@sail.stanford.eduMessage-ID: <890409-231522-3487@Xerox>As I relayed to you, what I recall is that there was some squawking aboutadding new FORMAT directives. Maybe we should break it up for voting.*start*01477 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 12-Apr-89 10:18:12 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 APR 89 10:18:10 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 12 Apr 89  10:12:12 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA07535; Wed, 12 Apr 89 11:12:05 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA03186; Wed, 12 Apr 89 11:12:03 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8904121712.AA03186@defun.utah.edu>Date: Wed, 12 Apr 89 11:12:02 MDTSubject: issue PRETTY-PRINT-INTERFACETo: cl-cleanup@sail.stanford.eduI've finally found time to look over the hardcopy of this issue thatwas distributed at the March meeting, but I'm having an extremelydifficult time parsing it.  The description is spread out in too manyplaces (the proposal section, the list of amendments, and the attacheddocument), and there are some things mentioned in the discussionsection that appear to contradict what is actually in the proposal(like whether the list form of the CONS type specifier is a real typespecifier or not).  Can somebody please revise this writeup so that itis organized more coherently?  I realize this issue is long andcomplicated, but improving the presentation would make it a lot moreunderstandable. -Sandra-------