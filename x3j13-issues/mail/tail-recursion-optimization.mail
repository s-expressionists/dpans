*start*01742 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 01 SEP 88 11:05:32 PDTReceived: from JASPER.SCRC.Symbolics.COM ([128.81.41.58]) by SAIL.Stanford.EDU with TCP; 1 Sep 88  11:05:09 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by JASPER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 213936; Thu 1-Sep-88 14:04:14 EDTDate: Thu, 1 Sep 88 14:03 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAIL-RECURSION-OPTIMIZATION (Version 1)To: eb@LUCID.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8809010415.AA03523@kent-state>Message-ID: <880901140348.9.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Wed, 31 Aug 88 21:15:50 PDT    From: Eric Benson <eb@lucid.com>    This is not tail-recursion optimization...You're right. I'm familiar with the distinctions you're making and am guiltyof sloppy wording.In the meantime -- while I rewrite the proposal to refer to "early binding"rather than "tail recursion" where appropriate -- could you please comment onwhether you are likely to support such an ammended proposal, or if not, whynot? (I'll also try to broaden the set of test cases to include anon-tail-recursive example in which early binding just for clarity.)Are your objections more than ones of mere terminology and classification?Do you want to use something other than INLINE? Do you want to contest thechosen defaults? Do you think this is a non-issue? These are the kinds ofquestions I'd like to see answered. I'd like to not have discussion of thisproposal fall off just because of some (admittedly glaring) wording problems.*start*01299 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 01 SEP 88 12:11:17 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 1 Sep 88  12:10:51 PDTReceived: from kent-state ([192.9.200.24]) by heavens-gate id AA05438g; Thu, 1 Sep 88 11:10:06 PSTReceived: by kent-state id AA03819g; Thu, 1 Sep 88 12:08:50 PDTDate: Thu, 1 Sep 88 12:08:50 PDTFrom: Eric Benson <eb@lucid.com>Message-Id: <8809011908.AA03819@kent-state>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Thu, 1 Sep 88 14:03 EDT <880901140348.9.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: TAIL-RECURSION-OPTIMIZATION (Version 1)I support this proposal completely, assuming it is reworded as youindicate.  In fact, Lucid has already implemented and documented thisproposal, exactly as you describe it.  Early function binding is doneon all self calls, not just self tail calls, unless the function isdeclared or proclaimed NOTINLINE.  In our model, SPEED=0 meanseverything is NOTINLINE.  This is in knowing violation of the Law(civil disobedience?), but we have never to my knowledge received abug report from a customer about it.*start*02560 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 01 SEP 88 14:38:57 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 1 Sep 88  14:37:30 PDTReceived: by ti.com id AA00269; Thu, 1 Sep 88 16:35:15 CDTReceived: from Kelvin by tilde id AA12434; Thu, 1 Sep 88 16:27:48 CDTMessage-Id: <2798141382-9746178@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Thu, 1 Sep 88 16:29:42 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 1)In-Reply-To: Msg of Wed, 31 Aug 88 18:11 EDT from Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>> Issue:        TAIL-RECURSION-OPTIMIZATION> References:   5.1 Forms (pp54-59), SYMBOL-FUNCTION (p90)> Category:     CHANGE> Edit history: 31-Aug-88, Version 1 by Pitman> Status:	      For Internal Discussion> > Problem Description:> >   Useful tail-recursion optimizations are not permitted by CLtL because>   the compiler must assume that any opaque function call might change>   the definition of a function in between calls to that function, so a>   direct jump to the code is not appropriate."Tail-recursion optimizations" could mean one of two things:  eithera function that calls itself being optimized into a loop, or jumping toanother function while keeping the same stack frame.  Your examples onlymention the first case; I don't see that the second is any problem.  I'mnot even convinced that the first case is really a problem since I haven'tseen an example of meaningful code where it would not be safe to assumethat a function didn't redefine itself (other than the DEFUN-AUTOLOADINGexample, which is not a likely candidate for optimization anyway).  In anycase, all one would have to do to insure a run-time indirection is to do (FUNCALL (SYMBOL-FUNCTION 'FOO) ...) instead of (FOO ...).Anyway, I think it would be a mistake to tie this issue with theSPEED and NOTINLINE declarations since they are intended to affectefficiency, not the semantics of the code.> Current Practice:> >   Symbolics Genera and Symbolics Cloe not currently do tail recursion>   optimization. As such, they are compatible with the proposal.The TI Explorer does do tail recursion optimization (both kinds) at higheroptimization levels.  It does assume that a function won't redefineitself, but no one has reported that as being a problem.  -- David Gray*start*01642 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 31 AUG 88 21:17:42 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 31 Aug 88  21:17:56 PDTReceived: from kent-state ([192.9.200.24]) by heavens-gate id AA05222g; Wed, 31 Aug 88 20:17:06 PSTReceived: by kent-state id AA03523g; Wed, 31 Aug 88 21:15:50 PDTDate: Wed, 31 Aug 88 21:15:50 PDTFrom: Eric Benson <eb@lucid.com>Message-Id: <8809010415.AA03523@kent-state>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Wed, 31 Aug 88 18:11 EDT <880831181117.6.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: TAIL-RECURSION-OPTIMIZATION (Version 1)This is not tail-recursion optimization.  This is more properly calledEARLY-FUNCTION-BINDING.  As it happens, early function binding isoften combined with tail-recursion optimization in the case of selfcalls.  This has led to some confusion between the two, but in factthey are orthogonal.  To clarify, tail-recursion optimization meansnot consuming stack space for a function call when the result of thatcall will be the result of the function making the call.  Earlyfunction binding means committing to a particular function definitionfor a name before the call itself, in Common Lisp usually referring toa commitment to a particular definition when there is the possibilityof a redefinition which would invalidate that commitment.  Either orboth of these optimizations may be applied to both self calls andcalls to other functions.*start*05732 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 31 AUG 88 15:13:00 PDTReceived: from JASPER.SCRC.Symbolics.COM ([128.81.41.58]) by SAIL.Stanford.EDU with TCP; 31 Aug 88  15:12:51 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by JASPER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 213745; Wed 31-Aug-88 18:11:53 EDTDate: Wed, 31 Aug 88 18:11 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAIL-RECURSION-OPTIMIZATION (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880831181117.6.KMP@GRYPHON.SCRC.Symbolics.COM>Issue:        TAIL-RECURSION-OPTIMIZATIONReferences:   5.1 Forms (pp54-59), SYMBOL-FUNCTION (p90)Category:     CHANGEEdit history: 31-Aug-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  Useful tail-recursion optimizations are not permitted by CLtL because  the compiler must assume that any opaque function call might change  the definition of a function in between calls to that function, so a  direct jump to the code is not appropriate.  The best a compiler can do right now is approximately:    (IF (EQ #'FOO ...what compiler expects...)        ...fast jump...        ...standard function calling sequence...)Proposal (TAIL-RECURSION-OPTIMIZATION:PERMIT):  Permit tail-recursion optimizations in some situations, but do not  require them.  Specifically, with SPEED=0, the compiler should not produce  tail-recursion optimizations (for the sake of tracing, stack debugging,  and reloading in interactive debugging), but with in other with higher  speed settings, it is permitted to make such optimizations.  Specify that the NOTINLINE declaration can be used within a function  to inhibit tail recursive calls from within that function, regardless  of the OPTMIZE SPEED setting.  Specify that the NOTINLINE proclamation can be used to globally  inhibit tail recursive calls to a particular function, regardless  of the OPTMIZE SPEED setting.Test Cases:  #1: (DEFUN FACTORIAL-2 (X &OPTIONAL (N 1))        (COND ((= X 0) N)	      (T (FACTORIAL-2 (- X 1) (* N X)))))      The compiler is permitted to (but not required to) treat this      as if the following had been written instead:      (DEFUN FACTORIAL-2 (X &OPTIONAL (N 1))	(LABELS ((FACTORIAL-2 (X &OPTIONAL (N 1)))		   (COND ((= X 0) N)			 (T (FACTORIAL-2 (- X 1) (* N X)))))	  (FACTORIAL-2 X N)))  #2: (DEFMACRO DEFUN-AUTOLOADING (NAME FILE)	`(PROGN (PROCLAIM '(NOTINLINE ,NAME))		(DEFUN ,NAME (&REST ARGUMENTS)		  (LET ((OLD-ME #',NAME))		    (LOAD ,FILE)		    (LET ((NEW-ME #',NAME))		      (WHEN (EQ OLD-ME NEW-ME)			(ERROR "Function ~S was undefined after autoload." ',NAME))		      (APPLY NEW-ME ARGUMENTS))))))      (DEFUN-AUTOLOADING FOO "foo.lisp")      (DEFUN BAR (X) (FOO X))      The compiler must not make assumptions about the contents of FOO,      so the function BAR will always see the current definition of FOO even      in the face of runtime redefinition.Rationale:  Tail recursion optimization is an important source of speed improvement.  Program modularity is of key importance to many Common Lisp programmers,  and it would be rash to say that the compiler could simply violate function  boundaries at whim. Nevertheless, for Common Lisp to successfully compete  with other languages, it should be designed in a way that at least permits  implementations to make this optimization.  This proposal is designed to achieve a workable compromise between issues of  speed and debuggability.  Some implementations do tail recursion removal already even when it is  not permitted. Such implementations have an unfair benchmark advantage over  "correct but slow" implementations in the marketplace. This would even the  odds for those implementations who would do the optimization if only it were  correct.Current Practice:  Symbolics Genera and Symbolics Cloe not currently do tail recursion  optimization. As such, they are compatible with the proposal.Cost to Implementors:  None. This permits action for those interested in taking it, but does  not require any action.Cost to Users:  Small. Some users who do runtime redefinition of functions would have to  add some declarations if they were compiling code with SPEED>0.Cost of Non-Adoption:  Lisp would show up poorly against other languages in certain benchmarks.  Lisp vendors who do this optimization even though it's technically not  correct would continue have an unfair business advantage over vendors  over those who respect the rules of the language.Benefits:  Compilers which chose to implement the optimization in question would  be able to produce better code.Aesthetics:  No major aesthetic impact.Discussion:  Pitman explored a number of different variants of this proposal before  sending this one. He's not wedded to the details here, but just tried to  submit something that would sound plausible. If there are ways to change  things which would make this proposal more palatable, he's happy to  hear them.  Charles Hornig (Symbolics) observes that SPEED=0 is perhaps not quite  the right criterion. The issue of whether absolute values of the   OPTIMIZE qualities are what's of interest or only relative values of  the different qualities is an open topic. For now, this proposal uses  SPEED 0 just to be conservative. If everyone can agree on something  broader, we could change the proposal. Alternatively, we can just   adopt that part of the proposal `as is' and work on a separate proposal  on how to deal with OPTIMIZE qualities.*start*01446 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 18:36:49 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 20 Sep 88  18:35:53 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 20 SEP 88 18:21:45 PDTDate: 20 Sep 88 18:21 PDTFrom: masinter.paSubject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 1)In-reply-to: David N Gray <Gray@DSG.csc.ti.com>'s message of Thu, 1 Sep 88 16:29:42 CDTTo: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880920-182145-5298@Xerox>The X3J13 body seems willing (eager) to give implementors the leeway to makesmall concessions in semantics in the name of performance. This seems like a relatively small concession given the negative associationwith the assembly-language hacker's anathema of "self-modifying code".I think it is marginally OK to leave the issue name alone.... Isn't this strongly related to FUNCTION-COERCE-TIME? I'm in favor of lazyfunction coerce time for FUNCALL and agressive function coerce time forcar-of-form calling. That is, implementations should assume early binding whenit appears as the car of form, and late binding when it appears 'FOO.  If youreally want late binding, you can say (FUNCALL 'FOO x y), right?I don't know if it makes sense to link the issues, but the two together makemore sense than either one alone.*start*00737 00024 USaReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 02 OCT 88 17:24:18 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 469157; Sun 2-Oct-88 20:24:30 EDTDate: Sun, 2 Oct 88 20:24 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: TAIL-RECURSION-OPTIMIZATIONTo: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <881002202400.2.KMP@GRYPHON.SCRC.Symbolics.COM>Do you have a copy of the version 2 mail which I sent last night?Somehow I managed to either delete it or mis-file it.I'd appreciate it if you could forward it back to me.Thanks.*start*07156 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 OCT 88 18:47:25 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Oct 88  18:47:19 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 469170; Sun 2-Oct-88 21:45:52 EDTDate: Sun, 2 Oct 88 21:44 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUSupersedes: <881001212759.3.KMP@GRYPHON.SCRC.Symbolics.COM>Message-ID: <881002214456.5.KMP@GRYPHON.SCRC.Symbolics.COM>[Some people didn't get copies of this when I sent it last night, so I'm retrying. -kmp]I tried to merge the discussion, mostly trying to use the terms "earlybinding" and "tail recursion" more correctly. The changes pervade thetext.I admit to making the changes somewhat hastily in an effort to get outof here at a reasonable hour tonight.  I hope David Gray and Eric Bensonwill check carefully for any major problems since they were the onesmost vocal by the previous writeup.[Btw, I wanted to reply to some specific comments by Gray and Masinterwith which I disagree, but I don't have time right now. I'll try to getto them another time.] -kmp-----Issue:        TAIL-RECURSION-OPTIMIZATIONReferences:   5.1 Forms (pp54-59), SYMBOL-FUNCTION (p90)Category:     CHANGEEdit history: 31-Aug-88, Version 1 by Pitman	      01-Oct-88, Version 2 by Pitman (merge discussion)Status:	      For Internal DiscussionProblem Description:  Early binding of function names to function definitions is generally  inhibited in Common Lisp because CLtL says the compiler must assume  that any opaque function call might change the definition of a  function in between calls to that function.  The inability to do early binding is a barrier to doing traditional  optimizations such as tail recursion removal. For example, the best  a compiler can typically do right now when a function FOO calls  itself tail recursively is approximately:    (IF (EQ #'FOO ...what compiler expects...)        ...fast jump...        ...standard function calling sequence...)Proposal (TAIL-RECURSION-OPTIMIZATION:PERMIT-EARLY-BINDING):  Permit early binding in some situations, but do not require them.  Specifically, with SPEED=0, the compiler should not do early binding  (for the sake of tracing, stack debugging, and reloading in  interactive debugging), but with in other with higher speed settings,  it is permitted to make such optimizations (except as discussed below).  Specify that the NOTINLINE declaration can be used within a function  to inhibit early binding of a function name to its definition,  regardless of the OPTMIZE SPEED setting.  Specify that the NOTINLINE proclamation can be used to globally  inhibit early binding of a function name to its definition, regardless  of the OPTMIZE SPEED setting.Test Cases:  #1: (DEFUN FACTORIAL-2 (X &OPTIONAL (N 1))        (COND ((= X 0) N)	      (T (FACTORIAL-2 (- X 1) (* N X)))))      The compiler is permitted to (but not required to) treat this      as if the following had been written instead:      (DEFUN FACTORIAL-2 (X &OPTIONAL (N 1))	(LABELS ((FACTORIAL-2 (X &OPTIONAL (N 1)))		   (COND ((= X 0) N)			 (T (FACTORIAL-2 (- X 1) (* N X)))))	  (FACTORIAL-2 X N)))  #2: (DEFMACRO DEFUN-AUTOLOADING (NAME FILE)	`(PROGN (PROCLAIM '(NOTINLINE ,NAME))		(DEFUN ,NAME (&REST ARGUMENTS)		  (LET ((OLD-ME #',NAME))		    (LOAD ,FILE)		    (LET ((NEW-ME #',NAME))		      (WHEN (EQ OLD-ME NEW-ME)			(ERROR "Function ~S was undefined after autoload." ',NAME))		      (APPLY NEW-ME ARGUMENTS))))))      (DEFUN-AUTOLOADING FOO "foo.lisp")      (DEFUN BAR (X) (FOO X))      The compiler must not make assumptions about the contents of #'FOO.      Therefore, the function BAR will always see the current definition      of FOO even in the face of runtime redefinition.Rationale:  Early binding is an important source of speed improvement.  Program modularity is of key importance to many Common Lisp programmers,  and it would be rash to say that the compiler could simply violate  function boundaries at whim. Nevertheless, for Common Lisp to successfully  compete with other languages, it should be designed in a way that at least  permits implementations to make this optimization.  This proposal is designed to achieve a workable compromise between issues  of speed and debuggability.  Some implementations do early binding already even when it is not permitted.  Such implementations have an unfair benchmark advantage over "correct but  slow" implementations in the marketplace. This would even the odds for those  implementations who would do the optimization if only it were correct.Current Practice:  Symbolics Genera and Symbolics Cloe not currently do early binding.  As such, they are compatible with the proposal.  Lucid Common Lisp does early binding, and so does not conform to CLtL in  some cases.  The TI Explorer assumes a function will not redefine itself and does  tail recursion removal at `higher optimization levels.'Cost to Implementors:  None. This permits action for those interested in taking it, but does  not require any action.Cost to Users:  Small. Some users who do runtime redefinition of functions would have to  add some declarations if they were compiling code with SPEED>0.Cost of Non-Adoption:  Lisp would show up poorly against other languages in certain benchmarks.  Lisp vendors who do this optimization even though it's technically not  correct would continue have an unfair business advantage over vendors  over those who respect the rules of the language.Benefits:  Compilers which chose to implement the optimization in question would  be able to produce better code.Aesthetics:  No major aesthetic impact.Discussion:  Pitman explored a number of different variants of this proposal before  sending this one. He's not wedded to the details here, but just tried to  submit something that would sound plausible. If there are ways to change  things which would make this proposal more palatable, he's happy to  hear them.  Charles Hornig (Symbolics) observes that SPEED=0 is perhaps not quite  the right criterion. The issue of whether absolute values of the   OPTIMIZE qualities are what's of interest or only relative values of  the different qualities is an open topic. For now, this proposal uses  SPEED 0 just to be conservative. If everyone can agree on something  broader, we could change the proposal. Alternatively, we can just   adopt that part of the proposal `as is' and work on a separate proposal  on how to deal with OPTIMIZE qualities.  David Gray has expressed reservations about this to the OPTIMIZE SPEED  quality at all since he sees it as a semantic issue.  Masinter points out that there might be some relation of this to   the issue FUNCTION-COERCE-TIME.*start*01735 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 02 OCT 88 18:45:56 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 469171; Sun 2-Oct-88 21:45:57 EDTDate: Sun, 2 Oct 88 21:45 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: (not about) Re: TAIL-RECURSION-OPTIMIZATIONTo: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <881002-175623-2803@Xerox>Message-ID: <881002214518.6.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: 2 Oct 88 17:56 PDT    From: masinter.pa@Xerox.COM    I didn't get it. Try again, eh?Ok. I think I have access to it via another channel.    I don't know how I'm gonna get all this stuff out this week, what with all    that's going on.    Sigh.It's my plan to go through the whole list and come up with a position onevery issue by the end of the week. As I go, I plan to submit updatedversions of anything that I think can be put in order.I don't think it's necessary to present everything this meeting. Remember,there's a finite amount of time. I'd focus on the ones which are going tohave a complicated impact that people need time to evaluate. Other issuesmay just have to get deferred to the next meeting, or dealt with in the mail.Everyone knows you've put in a ton of time, so keep in mind that if youdon't get it all done it doesn't mean you're not doing your job. There hasbeen a real rush of things that have waited and the system just has torespond to that as best it can.If as you work on this there's anything you see specifically that you wantme to help with, drop me a line.*start*02728 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 OCT 88 17:21:02 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 3 Oct 88  17:20:45 PDTReceived: by ti.com id AA26248; Mon, 3 Oct 88 19:18:51 CDTReceived: from Kelvin by tilde id AA14043; Mon, 3 Oct 88 19:09:12 CDTMessage-Id: <2800915811-11749067@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 3 Oct 88 19:10:11 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)In-Reply-To: Msg of Sun, 2 Oct 88 21:44 EDT from Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>>   Early binding of function names to function definitions is generally>   inhibited in Common Lisp because CLtL says the compiler must assume>   that any opaque function call might change the definition of a>   function in between calls to that function.Is there a specific place in CLtL that clearly says that, or is itjust inferred from the ability to SETF SYMBOL-FUNCTION withoutrestrictions on where or when?> Proposal (TAIL-RECURSION-OPTIMIZATION:PERMIT-EARLY-BINDING):> >   Permit early binding in some situations, but do not require them.This doesn't define what "early binding" means.  The test cases suggestwhat the intent is, but I'm not comfortable with specification byexample.  In particular, it isn't clear whether you intend to affect thecase of one function calling another, or if you are only talking aboutfunctions that reference their own definition.>   Specifically, with SPEED=0, the compiler should not do early binding>   (for the sake of tracing, stack debugging, and reloading in>   interactive debugging), ...Given that intent, if proposal OPTIMIZE-DEBUG-INFO:NEW-QUALITY isadopted, then a more appropriate criteria might be DEBUG>SPEED.Actually, though, if debugability is the issue, this might be beyondwhat the standard ought to specify, since nowhere else does it specifywhat happens at particular optimization levels.>     ... but with in other with higher speed settings, ...The grammar didn't come out right on that.>   regardless of the OPTMIZE SPEED setting.OPTIMIZE>   of the OPTMIZE SPEED setting.ditto> Current Practice:> >   Symbolics Genera and Symbolics Cloe not currently do early binding."not" -> "do not">   David Gray has expressed reservations about this to the OPTIMIZE SPEED>   quality at all since he sees it as a semantic issue.... about tying this to the OPTIMIZE qualities ...Actually, I thought _you_ were presenting it as a semantic issue.*start*04306 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 11:21:26 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 5 Oct 88  11:21:21 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 471023; Wed 5-Oct-88 14:19:06 EDTDate: Wed, 5 Oct 88 14:18 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)To: Gray@DSG.csc.ti.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <2800915811-11749067@Kelvin>Message-ID: <881005141854.5.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Mon, 3 Oct 88  19:10:11 CDT    From: David N Gray <Gray@DSG.csc.ti.com>    >   Early binding of function names to function definitions is generally    >   inhibited in Common Lisp because CLtL says the compiler must assume    >   that any opaque function call might change the definition of a    >   function in between calls to that function.    Is there a specific place in CLtL that clearly says that, or is it    just inferred from the ability to SETF SYMBOL-FUNCTION without    restrictions on where or when?Just inferred. Why?    > Proposal (TAIL-RECURSION-OPTIMIZATION:PERMIT-EARLY-BINDING):    >     >   Permit early binding in some situations, but do not require them.    This doesn't define what "early binding" means.  The test cases suggest    what the intent is, but I'm not comfortable with specification by    example.Can you suggest a wording?    In particular, it isn't clear whether you intend to affect the    case of one function calling another, or if you are only talking about    functions that reference their own definition.I see no reason to distinguish. Do you agree? If not, can you please makea case for why a function referencing itself should be different than a function referencing another function. This is the kind of thing I worryabout: (SETQ FACT '(LAMBDA (X) (COND ((ZEROP X) 1) (T (* X (FACT (- X 1)))))))    (COMPILE 'FACT FACT) vs (SETF (SYMBOL-FUNCTION 'FACT) (COMPILE NIL FACT)).Any difference in behavior/efficiency of these two forms would seemhighly gratuitous to me.    >   Specifically, with SPEED=0, the compiler should not do early binding    >   (for the sake of tracing, stack debugging, and reloading in    >   interactive debugging), ...    Given that intent, if proposal OPTIMIZE-DEBUG-INFO:NEW-QUALITY is    adopted, then a more appropriate criteria might be DEBUG>SPEED.    Actually, though, if debugability is the issue, this might be beyond    what the standard ought to specify, since nowhere else does it specify    what happens at particular optimization levels.If the new quality passes, I think we should haggle about this. I writemy proposals based on what's true at the time they will be voted on.Right now, there's little guidance about the qualities, and DEBUG isnot one. The note in the Discussion about this is intended to handwavethis issue. I could expand the note or move it to the proposal sectionif you thought it really important.    >     ... but with in other with higher speed settings, ...    The grammar didn't come out right on that.Right.    >   regardless of the OPTMIZE SPEED setting.    OPTIMIZERight.    >   of the OPTMIZE SPEED setting.    dittoHmmm. I detect a pattern.    > Current Practice:    >     >   Symbolics Genera and Symbolics Cloe not currently do early binding.    "not" -> "do not"Right.    >   David Gray has expressed reservations about this to the OPTIMIZE SPEED    >   quality at all since he sees it as a semantic issue.    ... about tying this to the OPTIMIZE qualities ...    Actually, I thought _you_ were presenting it as a semantic issue.Only in the sense that the current description forces it to be. Bysaying that SYMBOL-FUNCTION holds the function that will be called, CLtLreally tied our hands. This proposal is trying to get away from that andmake it an efficiency/debugging issue rather than a semantic issue.Does that make sense?Thanks for your careful reading and criticism.*start*03096 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 08:35:59 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  08:36:10 PDTReceived: by ti.com id AA27268; Fri, 7 Oct 88 10:33:59 CDTReceived: from Kelvin by tilde id AA16391; Fri, 7 Oct 88 10:18:44 CDTMessage-Id: <2801229485-95529@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 7 Oct 88 10:18:05 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.Stanford.edu, Bartley@MIPS.csc.ti.comSubject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)In-Reply-To: Msg of Wed, 5 Oct 88 14:18 EDT from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>> Just inferred. Why?I just wanted to see something a little more specific than "CLtL says".>     > Proposal (TAIL-RECURSION-OPTIMIZATION:PERMIT-EARLY-BINDING):>     > >     >   Permit early binding in some situations, but do not require them.> >     This doesn't define what "early binding" means.  The test cases suggest>     what the intent is, but I'm not comfortable with specification by>     example.> > Can you suggest a wording?I'm still not clear on what you intended, but here's a minimalspecification that I could support:Within the body of a DEFUN, if the CAR of a function call form is thesame as the name of the DEFUN, and that name has not been locallyshadowed by an FLET or MACROLET within the DEFUN, then a compiler isfree to assume that the reference is to the current function objectwithout requiring a run-time lookup of the symbol's functiondefinition.You might want to extend this to a self-reference in a FUNCTION form,but that is less interesting for optimization and causes the auto-loadexample to be a problem.>     In particular, it isn't clear whether you intend to affect the>     case of one function calling another, or if you are only talking about>     functions that reference their own definition.> > I see no reason to distinguish. Do you agree? If not, can you please make> a case for why a function referencing itself should be different than a > function referencing another function.No, I don't agree.  In the case of a function that references itself,there can only be an inconsistency if the function is redefined duringexecution of the function, which is not very likely.  However, whencalling another function, one would have to presume the possibility thatthe other function will be changed before the current function ischanged.>   This is the kind of thing I worry> about:>  (SETQ FACT '(LAMBDA (X) (COND ((ZEROP X) 1) (T (* X (FACT (- X 1)))))))>     (COMPILE 'FACT FACT)>  vs (SETF (SYMBOL-FUNCTION 'FACT) (COMPILE NIL FACT)).> Any difference in behavior/efficiency of these two forms would seem> highly gratuitous to me.But how can any optimization be done in the second case, where the callto FACT is referencing a function that isn't defined at the time ofcompilation?*start*01402 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 08:47:54 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  08:48:06 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472524; Fri 7-Oct-88 11:46:48 EDTDate: Fri, 7 Oct 88 11:46 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)To: David N Gray <Gray@DSG.csc.ti.com>cc: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, CL-Cleanup@SAIL.Stanford.edu, Bartley@MIPS.csc.ti.comIn-Reply-To: <2801229485-95529@Kelvin>Message-ID: <19881007154627.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 7 Oct 88  10:18:05 CDT    From: David N Gray <Gray@DSG.csc.ti.com>    In the case of a function that references itself,    there can only be an inconsistency if the function is redefined during    execution of the function, which is not very likely.That's not true, because a function can't reference -itself-, it canonly reference -its name-.  For example,(defun foo (x)  (if (zerop x) 1 (* x (foo (1- x)))))(setf (symbol-function 'bar) (symbol-function 'foo))(defun foo (x)  (* x 2))(bar 3) => 12, not 6*start*01524 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 12:22:37 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  12:22:32 PDTReceived: by ti.com id AA28753; Fri, 7 Oct 88 14:20:05 CDTReceived: from Kelvin by tilde id AA21104; Fri, 7 Oct 88 14:02:13 CDTMessage-Id: <2801242938-903828@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 7 Oct 88 14:02:18 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, CL-Cleanup@SAIL.Stanford.edu, Bartley@MIPS.csc.ti.comSubject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)In-Reply-To: Msg of Fri, 7 Oct 88 11:46 EDT from David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>> That's not true, because a function can't reference -itself-, it can> only reference -its name-.  For example,> > (defun foo (x)>   (if (zerop x) 1 (* x (foo (1- x)))))> (setf (symbol-function 'bar) (symbol-function 'foo))> (defun foo (x)>   (* x 2))> (bar 3) => 12, not 6Good point; this example helps clarify the issue:  is this the behaviordesired?  I think not, since when the programmer wrote the DEFUN for FOOhe most likely intended that the call to FOO referred to the functionhe was defining, not to some other FOO that might be defined later.Thus, in this case, early binding would cause less surprise than latebinding.*start*02978 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 17:43:46 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  17:43:48 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00881g; Fri, 7 Oct 88 17:03:36 PDTSite: Received: by bhopal id AA02180g; Fri, 7 Oct 88 17:01:56 PDTDate: Fri, 7 Oct 88 17:01:56 PDTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8810080001.AA02180@bhopal>To: Gray@DSG.csc.ti.comCc: Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.edu, Bartley@MIPS.csc.ti.comIn-Reply-To: David N Gray's message of Fri, 7 Oct 88  14:02:18 CDT <2801242938-903828@Kelvin>Subject: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)> > That's not true, because a function can't reference -itself-, it can> > only reference -its name-.  For example,> > > > (defun foo (x)> >   (if (zerop x) 1 (* x (foo (1- x)))))> > (setf (symbol-function 'bar) (symbol-function 'foo))> > (defun foo (x)> >   (* x 2))> > (bar 3) => 12, not 6> > Good point; this example helps clarify the issue:  is this the behavior> desired?  I think not, since when the programmer wrote the DEFUN for FOO> he most likely intended that the call to FOO referred to the function> he was defining, not to some other FOO that might be defined later.> Thus, in this case, early binding would cause less surprise than late> binding.I agree this is a well-chosen example.The purist in me says that a user wanting self-recursion should havewritten: (defun foo (x) (labels ((inner-foo (x)	    (if (zerop x) 1 (* x (inner-foo (1- x))))))   (inner-foo x)))But the pragmatist says that this is cumbersome enough that people will prefer the simpler version to be self-recursive: (defun foo (x)   (if (zerop x) 1 (* x (foo (1- x)))))A solution to this quandry that keeps source code simple would beto use two different function-defining macros for the two kinds ofbehavior.  I.e., DEFUN1 would be a version of DEFUN that produced code usinglabels to ensure self-recursion, and DEFUN2 would produce codethat chases through symbols.  Then for backwards compatibility, people can argue whether DEFUN should be equated with DEFUN1 orDEFUN2, or left for the user or vendor to define.But if the essence of this argument is accepted, then why not let(DECLARE (NOTINLINE FOO)) or (DECLARE (INLINE FOO)) discriminate thetwo forms?  And accepting that premise, it seems that 99.9% of thetime, self-recursion is expected or at worst :-) simply makes thecode run faster.  I think this leads to the solution Lucid adopted(but probably not through this chain of reasoning.)   One advantage I see to declarations over DEFUN1/DEFUN2 is thatDEFUN1 doesn't extend easily to collections of inter-callablefunctions, but declarations do (via PROCLAIM).  jlm*start*00912 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:12:18 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  18:07:26 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476147; Thu 13-Oct-88 19:31:21 EDTDate: Thu, 13 Oct 88 19:31 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013193113.6.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Not ready. Needs more work. I (KMP) made a note to myself that this should probably be related to the new DEBUG quality. KMP will work out a rewrite.*start*01447 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 NOV 88 21:24:04 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Nov 88  21:23:09 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 30 NOV 88 21:22:26 PSTDate: 30 Nov 88 21:22 PSTFrom: masinter.paSubject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 13 Oct 88 19:31 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881130-212226-3778@Xerox>I think it might help to have the proposal say more explicitly what isbeing proposed; it currently says "Permit early binding ..." which is avery general statement. I think what we are saying is very narrow: if you (SETF (SYMBOL-FUNCTION'FOO) ...) after you start executing the body of the definition of FOO andbefore you execute a call of FOO to itself, it is unspecified whether youget the old definition or the new one.In general, most implementations are required to enforce late binding forall functions not declared inline.This might be analogous to having(defun foo (x) ...) expand into(setf (symbol-function 'foo) #'(lambda (x) (declare (inline foo)) (blockfoo ...)))i.e., is a function is implicitly declared inline within its own body?*start*00772 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 14:07:58 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  14:06:58 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 14:01:31 PSTDate: 9 Dec 88 14:01 PSTFrom: masinter.paSubject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)In-reply-to: masinter.pa's message of 30 Nov 88 21:22 PSTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881209-140131-1032@Xerox>This issue is "not ready" and I have little hope of getting it ready in time....Maybe it can be brought "ready" to the January meeting.*start*00387 00024 US GV-Info: masinter.pa at 10-Apr-89 09:45:45 from massunterDate: 10 Apr 89 09:45 PDTFrom: masinter.paSubject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)In-reply-to: masinter.pa's message of 9 Dec 88 14:01 PSTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: masinterThis one seems to have fallen between the cracks. What do your notes say?*start*01161 00024 US GV-Info: KMP@STONY-BROOK.SCRC.Symbolics.COM at 10-Apr-89 13:07:06 from AGReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 10 APR 89 13:06:44 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 574575; Mon 10-Apr-89 16:06:14 EDTDate: Mon, 10 Apr 89 16:05 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: TAIL-RECURSION-OPTIMIZATION (Version 2)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <890410-094557-4370@Xerox>Message-ID: <890410160533.9.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 10 Apr 89 09:45 PDT    From: masinter.pa@Xerox.COM    This one seems to have fallen between the cracks. What do your notes say?My notes say...TAIL-RECURSION-OPTIMIZATION (Version 2, 01-Oct-88) Author:   Pitman Forum:    Cleanup Status:   Active Comments: ----- Pitman 05-Oct-88 -----	   Gray had some wording changes and some questions he wanted	   clarified. People seem to buy into this in the abstract but	   the writeup needs more work.