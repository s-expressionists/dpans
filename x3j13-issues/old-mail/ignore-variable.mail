*start*06350 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 13:54:46 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Feb 89  13:53:55 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 534454; Mon 6-Feb-89 16:51:58 ESTDate: Mon, 6 Feb 89 16:51 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: IGNORE-VARIABLE (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890206165129.4.KMP@BOBOLINK.SCRC.Symbolics.COM>This was already being discussed under DESTRUCTURING-BIND. I'mspawning a new issue name to help partition/focus the discussion.-----Issue:        IGNORE-VARIABLEForum:        CleanupReferences:   IGNORE declaration (p160)Category:     CHANGEEdit history: 06-Feb-89, Version 1 by PitmanStatus:       For Internal DiscussionProblem Description:  Many users of Symbolics Common Lisp (under Symbolics Genera) have grown  used to the variable named `IGNORE' receiving special treatment and have  complained that Common Lisp does not offer the same `feature.'Proposal (IGNORE-VARIABLE:SPECIAL-TREATMENT):  1. Define that the variable IGNORE (in the LISP package only) is always     implicitly ignored. It is an error to use the variable IGNORE.     A declaration of (IGNORE IGNORE) is permitted, but redundant.   2. Permit the variable IGNORE (or any variable declared ignored with the     IGNORE declaration) to be a duplicated variable in a binding list.Rationale:  1. Greater syntactic conciseness.     This is effectively current practice in some implementations.  2. If only one variable is going to be dignified in this way, it must     be possible to repeat it. If it makes sense to repeat IGNORE, it makes     sense to repeat any name declared IGNORE.Test Case:                                                    CLtL        Proposed  #1: (DEFUN FOO (IGNORE) T)                        may warn    ok  #2: (DEFUN FOO (IGNORE) IGNORE)                   ok          is error  #3: (DEFUN FOO (IGNORE IGNORE) T)                 is error    ok  #4: (DEFUN FOO (IGNORE IGNORE) IGNORE)            is error    is error  #5: (DEFUN FOO (X X) (DECLARE (IGNORE X)) T)      is error    ok  #6: (DEFUN FOO (X X) (DECLARE (IGNORE X)) X)      is error    is errorCurrent Practice:  Symbolics Genera currently treats all variables with the name "IGNORE"  (regardless of package) as ignored variables and complains if you try  to use them. It provides no way to turn off the `feature.'  Symbolics Cloe does not special-case variables named "IGNORE".Cost to Implementors:  Small.Cost to Users:  Although the change is technically incompatible, very few programs would  be likely to require change, since a name like IGNORE is unlikely to have  been used for anything other than an ignored variable.Cost of Non-Adoption:  Some programs would be clumsier to write.Benefits:  Less verbose code in some cases.  Existing code in some dialects would not require translation.Aesthetics:  At first brush, some might argue that this makes a bad special case in  the treatment of symbols as variables. However, on closer inspection,  it's clear that the language already treats some symbols magically:   - Symbols on the keyword package are treated specially with respect     to their values.   - Symbols like *PRINT-LEVEL*, etc. have pre-defined special meanings     and cannot be bound without knowing their conventions.   - Symbols like NIL and MOST-POSITIVE-FIXNUM have pre-defined values     and cannot be bound at all.  The thing which makes these changes palatable is that none of them is  based on the symbol's name. As such, anyone unhappy with this treatment  can simply make a new package that shadows the symbol and the symbol will  be treated normally if that is what is desired.Discussion:  When translating Macsyma from Zetalisp to Common Lisp a few years ago,  the use of Maclisp/LispM-style IGNORE was so pervasive that Pitman  ultimately just did (PROCLAIM '(SPECIAL IGNORE)) to muffle all the  would-be warnings. Except for the situation of duplicate variable names,  this is a totally portable solution, but it is -not- efficient.  Some people have suggested that (PROCLAIM '(IGNORE IGNORE)) should  work, but others argue that PROCLAIM should not, in general, be assumed  to affect lexical references.  Moon and Pitman mildly support option SPECIAL-TREATMENT.  Symbolics Common Lisp users have often expressed a desire to see this  feature in portable Common Lisp.  Some Symbolics users have complained specifically about the   incompatibility between Symbolics Genera and Symbolics Cloe in their  treatment of the variable IGNORE. Although Cloe has CLtL to fall back  on for justification, Cloe is invariably seen as the "bad guy" in their  reports because it stubbornly keeps them from getting the functionality  they want on the basis of what to them seems an irrelevant religious  or philosophical concern.  Some people might want to see a symmetric treatment of an ignored  variable in SETQ and MULTIPLE-VALUE-SETQ.  Maclisp used to permit NIL to denote an ignored variable. In general  this worked out well. The disadvantages to using NIL over using  IGNORE are:   - The common kind of macroexpansion error where NIL is substituted     for a useful value is harder to detect.    - There would be a potential conflict between the any meaning for NIL     in its `proper role' at the end of a dotted list and any opposing     meaning that a destructuring operation (eg, DEFMACRO, LOOP,      DESTRUCTURING-BIND) might want to assign to a dotted variable in     that position.  Note well: Experience with Symbolics Genera shows that special case  treatment based only on the name -- or some substring thereof -- and  not also on the package is a bad idea because there is no way to get  away from the feature if you don't like it. It is therefore an important  aspect of this proposal that only LISP:IGNORE is affected, and that an  EQ-test (and not a substring comparison) is the criterion for   identifying this magic variable.*start*01449 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 FEB 89 09:10:03 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 8 Feb 89  09:07:10 PSTReceived: by ti.com id AA01426; Wed, 8 Feb 89 11:04:59 CSTReceived: from Kelvin by tilde id AA13487; Wed, 8 Feb 89 10:57:33 CSTMessage-Id: <2811949017-5051752@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 8 Feb 89 10:56:57 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: IGNORE-VARIABLE (Version 1)In-Reply-To: Msg of Mon, 6 Feb 89 16:51 EST from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>> Proposal (IGNORE-VARIABLE:SPECIAL-TREATMENT):> >   1. Define that the variable IGNORE (in the LISP package only) is always>      implicitly ignored. It is an error to use the variable IGNORE.>      A declaration of (IGNORE IGNORE) is permitted, but redundant. > >   2. Permit the variable IGNORE (or any variable declared ignored with the>      IGNORE declaration) to be a duplicated variable in a binding list.The Explorer already supports this except for the part about permittingmultiple use of any variable declared IGNORE.I agree that this is a convenience which is often used, but I am lesssure about whether it is good programming practice.*start*04182 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 FEB 89 11:07:35 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 8 Feb 89  11:07:42 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 535877; Wed 8-Feb-89 14:04:27 ESTDate: Wed, 8 Feb 89 14:04 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: IGNORE-VARIABLE (Version 1)To: KMP@STONY-BROOK.SCRC.Symbolics.COMcc: Gray@DSG.CSC.TI.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <2811949017-5051752@Kelvin>Message-ID: <890208140425.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Wed, 8 Feb 89  10:56:57 CST    From: David N Gray <Gray@DSG.csc.ti.com>    ... I agree that this is a convenience which is often used, but I am less    sure about whether it is good programming practice. ...One good metric of whether it is a good programming practice is whetherit ever leads to trouble. Do you ... - have any bug reports on file from people who were caught by   it unaware and asked to have the feature removed. - have any instances of real code that uses IGNORE where you felt   the writer's intent would have been clearer if he'd done something else?I think most of the examples of using IGNORE that I've seen are very tasteful.Things like (MAPCAR #'(LAMBDA (IGNORE) (GENSYM)) VARS) to construct a listof temporary variables in a macro is ultimately more readable, I think,than (MAPCAR #'(LAMBDA (VAR)                 (DECLARE (IGNORE VAR))                 VAR)             VARS)since the latter conveys no more information in some people's coding style.(If I call a list of vars <name>S, it means that the elements will be <name>.)All the long form ultimately does is to force me to use up three more screenlines because (as a matter of personal policy) I try never put multiple formsin an implicit progn on the same line. I assert that anything that gratuitouslyloses me screen lines makes the program less readable. The issue is onlywhether this is a case where the loss is gratuitous.Already you cannot choose variable names in Common Lisp with noregard to how those names were defined. If you do, you'll trip over nameslike MOST-POSITIVE-FIXNUM. (Any argument that says you'd never accidentallychoose that one must surely say you'd never choose IGNORE either.) So there'sno big deal about working around the name IGNORE simply by placing it in a listeveryone has to know about of names they shouldn't use without reading doc.Beyond that, I claim, it's just a matter of "are you going to provide the userwhat he clearly wants". The only rational counter-argument (I believe) is notan aesthetic one because the person making that argument has no leg to stand on.There is a somewhat rational argument that you're just tired of adding littlefeatures that let users "get what they want" and you just want to say "tough!i've given you a lot of things. what you're asking for is reasonable but thecost in terms of address space or my time to implement it or whatever is toohigh and i will not give it to you."  This argument was used, for example,in rejecting CONJOIN, DISJOIN, etc. Given that you acknowledge the conveniencefactor, however, that argument is weakened dramatically.As an aside, the aforementioned metric cited above -would- suffice to show whylooking at the variable's name (independent of package) is not acceptable, sinceI can cite actual bugs in real programs that have come from having gensyms withnames like "IGNORE" -- due to doing (MAKE-SYMBOL (SYMBOL-NAME USER-VARIABLE)).Flexibility to use the same name in uninterned symbols or shadowed symbols inorder to dig one's way out of the attached semantics of a particular symbol isfundamental to the whole concept of the package system. However, within a particular module or package, where use of the package presumably means thatit is a given that the user understands its workings, I think matters ofconvenience should be catered to.*start*02389 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 FEB 89 12:51:58 PSTReceived: from ucbarpa.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 8 Feb 89  12:51:46 PSTReceived: from franz.UUCP by ucbarpa.Berkeley.EDU (5.61/1.33)	id AA09770; Wed, 8 Feb 89 12:20:13 -0800Received: from frisky by franz (3.2/3.14)	id AA02935; Wed, 8 Feb 89 11:57:26 PSTReceived: by frisky (3.2/3.14)	id AA02229; Wed, 8 Feb 89 11:54:35 PSTFrom: franz!frisky!jkf@ucbarpa.Berkeley.EDU (John Foderaro)Return-Path: <frisky!jkf>Message-Id: <8902081954.AA02229@frisky>To: Kent M Pitman <franz!akbar!franz!ucbarpa!STONY-BROOK.SCRC.Symbolics.COM!KMP@ucbarpa.Berkeley.EDU>Cc: franz!SAIL.Stanford.EDU!CL-Cleanup@ucbarpa.Berkeley.EDUSubject: Re: Issue: IGNORE-VARIABLE (Version 1) In-Reply-To: Your message of Wed, 08 Feb 89 14:04:00 EST.             <890208140425.7.KMP@BOBOLINK.SCRC.Symbolics.COM> Date: Wed, 08 Feb 89 11:54:34 PST>> One good metric of whether it is a good programming practice is whether>> it ever leads to trouble. Do you ...>>>>  - have any instances of real code that uses IGNORE where you felt>>    the writer's intent would have been clearer if he'd done something else? I'm sure that if you gave me access to source code where 'ignore' wasused,  I could find plenty of examples where it shouldn't have been.Since I don't have that access, I looked in the pcl code (not to pickon pcl, but it was all that I had):from 3600-low.cl:(defun set-function-name-1 (fn new-name ignore)  (cond ((or (funcallable-instance-p fn)	     (si:lexical-closure-p fn))   So set-function-name-1 takes three arguments, what is the third  argument?   Suppose I want to rewrite set-function-name-1, maybe I'll   need this variable when I rewrite it.  Here is how it should be written (sure it takes more keystrokesbut it is worth it):  from coral-low.cl:(defun set-function-name-1 (function new-name uninterned-name)  (declare (ignore uninterned-name))  (cond ((ccl::lfunp function)  from macros.cl:(defmacro destructuring-bind (pattern form &body body)  (multiple-value-bind (ignore declares body)      (extract-declarations body) again, the question the reader of this code has is what the firstvalue returned by extract-declarations? *start*02875 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 FEB 89 14:28:39 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 8 Feb 89  14:28:36 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 536009; Wed 8-Feb-89 17:25:35 ESTDate: Wed, 8 Feb 89 17:25 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: IGNORE-VARIABLE (Version 1) To: franz!frisky!jkf@ucbarpa.Berkeley.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8902081954.AA02229@frisky>Message-ID: <890208172531.1.KMP@BOBOLINK.SCRC.Symbolics.COM>Just because you refuse permit to a particular shorthand doesn't meanpeople will write the same concept in longhand the way you want them to.Nothing stops people from writing (defun foo (x y ignore)   (declare (ignore ignore))   ...)People do this all the time. Sometimes they use the word IGNORE.Sometimes they use the word IGNORED, STUFF, JUNK, HUNOZ, or whatever.But they do it.Also, if they were only interested in the first argument, nothing wouldkeep them from writing (defun foo (x &rest more-arguments)   (declare (ignore more-arguments))   ...)I do this all the time, by the way, and I don't think (defun foo (x &rest ignore) ...)would be any less readable.If someone really knows he's not going to use something, why does heneed to name it? Just because he gets his grins from wasting symbolspace or watching his code run onto the next screenful or from feedingthe printer an extra sheet of paper? I don't use the value of the square of pi when I compute factorial and I would not consider everusing it even if you insisted on passing it to me. Why should I beforced to devise a name for a thing I'm sure I'm not going to use?This problem is particularly acute for anonymous procedures where I canoften see the argument that is being passed in, what is being used, etc.I'm saying this feature is useful and that I could use it judiciously.You're saying this feature is not useful and that people could abuse it.I ignore the argument that it could be abused because that's true ofmost everything. We're left with an "I think it's useful; you think it'snot argument".As a general rule of thumb, in the absence of a technical argument forsolving a dispute, when someone claims that something is useful andsomeone else claims it is not, I believe the person claiming it is notis most likely to be wrong (since for nearly everything that is usefulyou can find a situation where it is not without having proved anything).Anyway, I've made my point and plan to say no more on this unlessspecifically asked to.*start*01053 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 FEB 89 15:00:51 PSTReceived: from ECLC.USC.EDU by SAIL.Stanford.EDU with TCP; 21 Feb 89  15:01:10 PSTDate: Sun, 19 Feb 89 15:42:05 PSTFrom: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>Subject: Issue IGNORE-VARIABLE, v1To: cl-cleanup@SAIL.STANFORD.EDUcc: iim%ECLA@ECLC.USC.EDUMessage-ID: <12472021827.5.IIM@ECLA.USC.EDU>In the discussion leading up to this issue being proposed, and in the proposalitself, there have been a number of comments about it being an error to have aduplicated name in a binding list.  I'm not trying to claim that doing so is agood idea, but I've never been able to find anything in CLtL that says doing sois wrong.  Also, I believe that the results are actually well defined forsequential binding forms (though not for parallel binding forms).  If CLtL doessay something about this, would somebody please point it out to me?kab-------*start*05320 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 14-Mar-89 11:06:08 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 11:05:42 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Mar 89  11:02:36 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 MAR 89 09:41:14 PSTDate: 14 Mar 89 09:03 PSTFrom: masinter.paSubject: Re: Issue IGNORE-VARIABLE, v1In-reply-to: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>'s message of Sun, 19 Feb 89 15:42:05 PSTTo: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>cc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <890314-094114-1073@Xerox>I didn't check the references when this was first proposed, but presumablypp 55-56 and 59-65 of CLtL have some indication that duplicates are notallowed. This issue was "withdrawn", i.e., we didn't propose it.     ----- Begin Forwarded Messages -----Date: Mon, 7 Mar 88 15:06 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LAMBDA-LIST-DUPLICATES (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUIssue:          LAMBDA-LIST-DUPLICATESReferences:     5.1.2 Variables (pp55-56)	        5.2.2 Lambda-Expressions (pp59-65),	        LET* (p111-112), PROG* (pp131-132)Category:       ADDITIONEdit history:   07-Mar-88, Version 1 by PitmanRelated Issues: DECLARATION-SCOPEStatus:	        For Internal DiscussionProblem Description:  CLtL forbids binding the same variable more than once in the same  binding form. This rule is claimed by some to be overly restrictive  because there are some well-defined situations in which it would be  useful to duplicate a variable name in the same binding list.Proposal (LAMBDA-LIST-DUPLICATES:ALLOW-SEQUENTIAL-NON-ITERATIVE):  Allow variable names to be repeated in situations where bindings are  sequential and the binding construct is non-iterative (specifically,  in the &AUX part of a normal lambda list, in the bindings of LET*, and  in the bindings of PROG*).Test Case:  ((LAMBDA (B &AUX (B (+ B 1)) (B (+ B 1))) B) 0) => 2  (LET* ((B 0) (B (+ B 1))) B)                    => 1  (PROG* ((B 0) (B (+ B 1))) (RETURN B))          => 1Rationale:  Because these bindings are inherently sequential and non-iterative, there  would no ambiguity about the intended scope bindings, and it is sometimes  useful to repeat the name of a binding when doing various kinds of  encapsulations or successive refinements to the same value.  The intent of duplicated bindings in "parallel binding" constructs like  LET or iterative constructs like DO* is less easy to predict, so it is  not proposed that the current rule be relaxed for such constructs.Current Practice:  The Symbolics implementation currently checks for this case and  signals an error.  [Others?]Cost to Implementors:  Converting would be relatively easy, but not completely trivial.  There is some interaction with declaration processing which becomes  involved, too (see issue DECLARATION-SCOPE).Cost to Users:  None. This is an upward-compatible change.Cost of Non-Adoption:  Some useful expressional style would be lost.Benefits:  A useful expressional style would be made available.Aesthetics:  The rule for variable duplication would be more syntactically complex  but pragmatically simpler.Discussion:  A request for a discussion of this issue came from the Japanesecommunity.  Pitman drafted this formal proposal and supports  LAMBDA-LIST-DUPLICATES:ALLOW-SEQUENTIAL-NON-ITERATIVE.     ----- Next Message -----From: Jeff Dalton <jeff%aiva.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Tue, 8 Mar 88 20:28:54 gmtTo: CL-Cleanup@sail.stanford.eduSubject: Issue: LAMBDA-LIST-DUPLICATES (Version 1)Cc: KMP@scrc-stony-brook.arpaCurrent practice:  Both PopLog Common Lisp and KCL allow variables to appear more  than once in a lambda-list.  In the three suggested test cases,  they both have the later binding current in the body of the form  and so return the values 2, 1, and 1 respectively.  In addition, both allow variables in other cases, specifically:  KCL:    ((lambda (a a) a) 1 2) => 2   PopLog:    ((lambda (a a) a) 1 2) => 1     ----- Next Message -----Date: Fri, 11 Mar 88 13:43 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LAMBDA-LIST-DUPLICATES (Version 1)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880307150614.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>I oppose LAMBDA-LIST-DUPLICATES:ALLOW-SEQUENTIAL-NON-ITERATIVE; I thinkCommon Lisp should continue to forbid binding the same variable morethan once in the same binding form.  I have two reasons:1. This is an unnecessary complication of the language rules.  Allowingduplicated variable names doesn't make it possible to write programsthat you couldn't write before, it just allows the programs to bewritten in a more obscure way.2. This would result in an unnecessary complication of the scoping rulesfor DECLARE.  Common Lisp would have to define what happens when aDECLARE of a variable is attached to a form that binds more than onevariable with the declared name.     ----- End Forwarded Messages -----