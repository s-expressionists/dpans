*start*02640 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 16 AUG 88 15:42:41 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 16 Aug 88  15:41:38 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA06408; Tue, 16 Aug 88 18:41:35 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA06571; Tue, 16 Aug 88 18:43:14 EDTMessage-Id: <8808162243.AA06571@mist.UUCP>To: cl-cleanup%sail.stanford.edu@multimax.ARPASubject: Issue: NTH-VALUE (Version 1)Date: Tue, 16 Aug 88 18:43:11 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>Issue:         NTH-VALUEReferences:    Multiple values, pp. 133-139Category:      ADDITIONEdit history:  Version 1 by Pierson 8/16/88Status:        For Internal DiscussionProblem description:The set of actions on multiple values in Common Lisp is incomplete.Proposal (NTH-VALUE:ADD):Add a new macro:NTH-VALUE n form                                               [Macro]Evaluates the FORM and returns the Nth value returned by the form as asingle value.  N is 0-based, i.e. the first returned value is value 0,for compatability with NTH and NTHCDR.Test Cases/Examples:With this proposal MOD could be defined as:(DEFUN MOD (NUMBER DIVISOR)  (NTH-VALUE 1 (FLOOR NUMBER DIVISOR)))The same code would currently be:(DEFUN MOD (NUMBER DIVISOR)  (MULTIPLE-VALUE-BIND (DIVIDEND REMAINDER)      (FLOOR NUMBER DIVISOR)    (DECLARE (IGNORE DIVIDEND))    REMAINDER))Rationale:This fills a hole in the initial definition of Common Lisp and permitsclearer code in some circumstances.Current practice:I don't know of any implementation that provides this feature.Cost to Implementors:A simple new macro needs to be written.  In addition, mostimplementations will choose to implement compiler hooks so that codewritten with NTH-VALUE will be as efficient as possible.Cost to Users:None, this is an upward-compatible change.Cost of non-Adoption:This feature won't be available to portable programs.Benefits:This makes some code that uses multiple values easier to read andwrite.  In addition, it may be easier for implementations to optimizeexpressions which use NTH-VALUE instead of using MULTIPLE-VALUE-BINDand ignoring the unwanted values.Aesthetics:While it does add another function to the language it removes someneed for the hairier multiple-value forms.Discussion:Pitman proposed this in the very late pre-CLtL days.  It was rejectedthen because it was too late in the cycle.------- End of Forwarded Message*start*02055 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 16 AUG 88 16:27:46 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 16 Aug 88  16:27:10 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 447350; Tue 16-Aug-88 19:25:26 EDTDate: Tue, 16 Aug 88 19:25 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: NTH-VALUE (Version 1)To: pierson%mist@MULTIMAX.ARPAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8808162243.AA06571@mist.UUCP>Message-ID: <880816192510.3.KMP@GRYPHON.SCRC.Symbolics.COM>If I recall, I was originally talked down on the argument that Ishouldn't be thinking of values as an array-like vector to beindexed into -- the argument being that this is not how argumentsto functions are treated. They, by contrast, are named.However, in practice, I find that I often write things like: (SIXTH (MULTIPLE-VALUE-LIST ...))or (NTH 5 (MULTIPLE-VALUE-LIST ...))just for visual clarity and conciseness (in spite of the consing)-- especially when picking apart hairy return values such as thoseinvolved with the time functions, but also even in simpler cases.A sufficiently clever compiler -could- just optimize my idiom,I suppose, but still it would be nice to provide people with something that was both efficient and perspicuous.So, even though some people may have wished they could reform the way Ithink about multiple values in some circumstances, the fact remains thatthey didn't change my model. They only managed to make me feel inconvenienced every time this comes up... So even after all this time,I still think this is a good idea and generally support the idea ofthis proposal.However, I would like to see the wording tightened to make it clear thatthe order of evaluation is left-to-right. "Evaluates N, then evaluates theform...." or some such.*start*00871 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 16 AUG 88 16:41:39 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 16 Aug 88  16:41:03 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 16 Aug 88 19:39:17 EDTTo: cl-cleanup@sail.stanford.eduSubject: Re: Issue: NTH-VALUE (Version 1) In-reply-to: Your message of Tue, 16 Aug 88 18:43:11 -0400.             <8808162243.AA06571@mist.UUCP> Date: Tue, 16 Aug 88 19:39:05 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUI'm not strongly opposed to this, but I've certainly never felt the needfor such a form.  The cases where want only one value, but not the firstvalue, are so rare that I don't mind using the more verbosemultiple-value-bind idiom.-- Scott*start*00967 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 SEP 88 13:46:30 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 12 Sep 88  13:45:39 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA13298; Mon, 12 Sep 88 13:44:22 PDTMessage-Id: <8809122044.AA13298@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comDate: 12 Sep 88 16:06To: cl-cleanup@sail.stanford.eduSubject: Issue: NTH-VALUEAlthough technically this proposal looks OK with me, I think it doesn'toffer increased functionality or potential efficiency.  It does offeran easier to read (and write!) interface for getting a multiple valueout of many, but this should be easy to construct as a portable macro.Since we have so many other proposals which to me seem much moreimportant, I'd prefer that we not submit this to X3J13 as a whole.			---Walter*start*01091 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 15:08:23 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 19 Sep 88  15:05:09 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 19 SEP 88 14:43:31 PDTDate: 19 Sep 88 14:43 PDTFrom: masinter.paSubject: Re: Issue: NTH-VALUEIn-reply-to: vanroggen%aitg.DEC@decwrl.dec.com's message of 12 Sep 88 16:06To: vanroggen%aitg.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduMessage-ID: <880919-144331-2329@Xerox>My belief is that as long as there is some proponent for a proposal we arebetter off  submitting it with the recommendation that it not be adopted thanjust dropping it. I think the mail is clear that both Kent and Dan areinterested in seeing this carried forward. I'm neutral on it, but I've had onmore than one occasion had to write(multiple-value-bind (ignore value) (form) (declare (ignore ignore)) value) to get what I wanted, so that this is mildly interesting to me.*start*03663 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 17:51:50 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Oct 88  17:47:59 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 468941; Sat 1-Oct-88 20:46:43 EDTDate: Sat, 1 Oct 88 20:46 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: NTH-VALUE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8808162243.AA06571@mist.UUCP>Message-ID: <881001204614.1.KMP@GRYPHON.SCRC.Symbolics.COM>Very minor changes per discussion... - expanded the Problem Description slightly. - changed Proposal to be more explict about order of argument evaluation - minor reformatting and rewording in places to make things clearer   and/or remove first-person usages from Pierson's writeup.-----Issue:         NTH-VALUEReferences:    Multiple values, pp. 133-139Category:      ADDITIONEdit history:  16-Aug-88, Version 1 by Pierson               01-Oct-88, Version 2 by Pitman (minor edits)Status:        For Internal DiscussionProblem description:  The set of operations on multiple values in Common Lisp is incomplete:  The only ways to retrieve just one of several return values (other than  the first) are:   - Bind several variables and then ignore all but one.     eg, (MULTIPLE-VALUE-BIND (X Y Z) <exp> (DECLARE (IGNORE X Y)) Z)     This is somewhat cumbersome to write and not perspicuous.   - Get a list of all return values and select from that.     eg, (THIRD (MULTIPLE-VALUE-LIST <exp>))     This is somewhat cumbersome, not perspicuous, and creates     needless garbage.Proposal (NTH-VALUE:ADD):  Add a new macro NTH-VALUE, described as  NTH-VALUE n form                                               [Macro]  Evaluates the FORM and returns the Nth value returned by the form as  a single value.  N is 0-based, i.e. the first returned value is   value 0 (for consistency with NTH and NTHCDR). Both N and FORM are  evaluated, in left-to-right order.Test Cases/Examples:  With this proposal MOD could be defined as:  (DEFUN MOD (NUMBER DIVISOR)    (NTH-VALUE 1 (FLOOR NUMBER DIVISOR)))  The same code would currently be:  (DEFUN MOD (NUMBER DIVISOR)    (MULTIPLE-VALUE-BIND (DIVIDEND REMAINDER)        (FLOOR NUMBER DIVISOR)      (DECLARE (IGNORE DIVIDEND))      REMAINDER))Rationale:  This corrects the stated problem.Current practice:  No implementation is known to provide this feature.Cost to Implementors:  Writing the macro version is fairly straightforward.  Most will choose to implement compiler hooks so that code written with  NTH-VALUE will be as efficient as possible. This may involve some  additional work, but presumably nothing major.Cost to Users:  None, this is an upward-compatible change.Cost of non-Adoption:  The occassional code where this comes up may be one or more of   clumsier to write, more difficult to read, or less efficient.Benefits:  The cost of non-adoption is avoided.Aesthetics:  While it does add another function to the language it removes  some need for the hairier multiple-value forms.Discussion:  Pitman proposed this in the very late pre-CLtL days. It was  rejected then because it was too late in the cycle.  Pitman, Pierson, and Masinter have voiced support for this  proposal.  vanRoggen and Fahlman don't really think this feature is  necessary, but don't actively oppose its inclusion.*start*01388 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 OCT 88 15:38:37 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 3 Oct 88  15:38:22 PDTReceived: by ti.com id AA25611; Mon, 3 Oct 88 17:34:36 CDTReceived: from Kelvin by tilde id AA12180; Mon, 3 Oct 88 17:25:49 CDTMessage-Id: <2800909595-11375570@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 3 Oct 88 17:26:35 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: NTH-VALUE (Version 2)In-Reply-To: Msg of Sat, 1 Oct 88 20:46 EDT from Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>> Proposal (NTH-VALUE:ADD):> >   Add a new macro NTH-VALUE, described as> >   NTH-VALUE n form                                               [Macro]> >   Evaluates the FORM and returns the Nth value returned by the form as>   a single value.  N is 0-based, i.e. the first returned value is >   value 0 (for consistency with NTH and NTHCDR). Both N and FORM are>   evaluated, in left-to-right order....> Current practice:> >   No implementation is known to provide this feature.The TI Explorer and LMI Lambda have this.[This is not necessarily an endorsement, however, since it seems to beonly rarely used.]*start*03411 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 14:17:08 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Oct 88  14:16:45 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 05 OCT 88 13:45:13 PDTDate: 5 Oct 88 13:45 PDTFrom: masinter.paSubject: Issue: NTH-VALUE (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881005-134513-1235@Xerox>change Current Practice as per Gray. I'm no longer sure ifI'm in favor of the proposal; I'd guess I'm neutral. I just re-read McCarthy's note about Lisp standards and"intellectual logrolling", and it makes me pause. (I'll forwardthe note to X3J13.)!Issue:         NTH-VALUEReferences:    Multiple values, pp. 133-139Category:      ADDITIONEdit history:  16-Aug-88, Version 1 by Pierson               01-Oct-88, Version 2 by Pitman (minor edits)		 5-Oct-88, Version 3 by Masinter			(add Current Practice as per Gray)Problem description:  The set of operations on multiple values in Common Lisp is incomplete:  The only ways to retrieve just one of several return values (other than  the first) are:   - Bind several variables and then ignore all but one.     eg, (MULTIPLE-VALUE-BIND (X Y Z) <exp> (DECLARE (IGNORE X Y)) Z)     This is somewhat cumbersome to write and not perspicuous.   - Get a list of all return values and select from that.     eg, (THIRD (MULTIPLE-VALUE-LIST <exp>))     This is somewhat cumbersome, not perspicuous, and creates     needless garbage.Proposal (NTH-VALUE:ADD):  Add a new macro NTH-VALUE, described as  NTH-VALUE n form                                               [Macro]  Evaluates the FORM and returns the Nth value returned by the form as  a single value.  N is 0-based, i.e. the first returned value is   value 0 (for consistency with NTH and NTHCDR). Both N and FORM are  evaluated, in left-to-right order.Test Cases/Examples:  With this proposal MOD could be defined as:  (DEFUN MOD (NUMBER DIVISOR)    (NTH-VALUE 1 (FLOOR NUMBER DIVISOR)))  The same code would currently be:  (DEFUN MOD (NUMBER DIVISOR)    (MULTIPLE-VALUE-BIND (DIVIDEND REMAINDER)        (FLOOR NUMBER DIVISOR)      (DECLARE (IGNORE DIVIDEND))      REMAINDER))Rationale:  This corrects the stated problem.Current practice:  The TI Explorer and LMI Lambda have this feature. Cost to Implementors:  Writing the macro version is fairly straightforward.  Some will choose to implement compiler hooks so that code written with  NTH-VALUE will be as efficient as possible. This may involve some  additional work, but presumably nothing major.Cost to Users:  This is an upward-compatible change.Cost of non-Adoption:  The occassional code where this comes up may be one or more of   clumsier to write, more difficult to read, or less efficient.  (The feature is rarely used in implementations that have it.)Benefits:  The cost of non-adoption is avoided.Aesthetics:  While it does add another function to the language it removes  some need for the hairier multiple-value forms.Discussion:  Pitman proposed this in the very late pre-CLtL days. It was  rejected then because it was too late in the cycle.  There was not strong sentiment for including this feature  in Common Lisp, but no active opposition.*start*02855 00024 US Date:  7 Oct 88 16:38 PDTFrom: masinter.paSubject: Issue: NTH-VALUE (Version 3)To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:         NTH-VALUEReferences:    Multiple values, pp. 133-139Category:      ADDITIONEdit history:  16-Aug-88, Version 1 by Pierson               01-Oct-88, Version 2 by Pitman (minor edits)		 5-Oct-88, Version 3 by Masinter			(add Current Practice as per Gray)Problem description:  The set of operations on multiple values in Common Lisp is incomplete:  The only ways to retrieve just one of several return values (other than  the first) are:   - Bind several variables and then ignore all but one.     eg, (MULTIPLE-VALUE-BIND (X Y Z) <exp> (DECLARE (IGNORE X Y)) Z)     This is somewhat cumbersome to write and not perspicuous.   - Get a list of all return values and select from that.     eg, (THIRD (MULTIPLE-VALUE-LIST <exp>))     This is somewhat cumbersome, not perspicuous, and creates     needless garbage.Proposal (NTH-VALUE:ADD):  Add a new macro NTH-VALUE, described as  NTH-VALUE n form                                               [Macro]  Evaluates the FORM and returns the Nth value returned by the form as  a single value.  N is 0-based, i.e. the first returned value is   value 0 (for consistency with NTH and NTHCDR). Both N and FORM are  evaluated, in left-to-right order.Test Cases/Examples:  With this proposal MOD could be defined as:  (DEFUN MOD (NUMBER DIVISOR)    (NTH-VALUE 1 (FLOOR NUMBER DIVISOR)))  The same code would currently be:  (DEFUN MOD (NUMBER DIVISOR)    (MULTIPLE-VALUE-BIND (DIVIDEND REMAINDER)        (FLOOR NUMBER DIVISOR)      (DECLARE (IGNORE DIVIDEND))      REMAINDER))Rationale:  This corrects the stated problem.Current practice:  The TI Explorer and LMI Lambda have this feature. Cost to Implementors:  Writing the macro version is fairly straightforward.  Some will choose to implement compiler hooks so that code written with  NTH-VALUE will be as efficient as possible. This may involve some  additional work, but presumably nothing major.Cost to Users:  This is an upward-compatible change.Cost of non-Adoption:  The occassional code where this comes up may be one or more of   clumsier to write, more difficult to read, or less efficient.  (The feature is rarely used in implementations that have it.)Benefits:  The cost of non-adoption is avoided.Aesthetics:  While it does add another function to the language it removes  some need for the hairier multiple-value forms.Discussion:  Pitman proposed this in the very late pre-CLtL days. It was  rejected then because it was too late in the cycle.  There was not strong sentiment for including this feature  in Common Lisp, but no active opposition.*start*03179 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 16:55:08 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Oct 88  16:43:04 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 07 OCT 88 16:38:01 PDTDate: 7 Oct 88 16:38 PDTFrom: masinter.paSubject: Issue: NTH-VALUE (Version 3)To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881007-163801-1388@Xerox>Issue:         NTH-VALUEReferences:    Multiple values, pp. 133-139Category:      ADDITIONEdit history:  16-Aug-88, Version 1 by Pierson               01-Oct-88, Version 2 by Pitman (minor edits)		 5-Oct-88, Version 3 by Masinter			(add Current Practice as per Gray)Problem description:  The set of operations on multiple values in Common Lisp is incomplete:  The only ways to retrieve just one of several return values (other than  the first) are:   - Bind several variables and then ignore all but one.     eg, (MULTIPLE-VALUE-BIND (X Y Z) <exp> (DECLARE (IGNORE X Y)) Z)     This is somewhat cumbersome to write and not perspicuous.   - Get a list of all return values and select from that.     eg, (THIRD (MULTIPLE-VALUE-LIST <exp>))     This is somewhat cumbersome, not perspicuous, and creates     needless garbage.Proposal (NTH-VALUE:ADD):  Add a new macro NTH-VALUE, described as  NTH-VALUE n form                                               [Macro]  Evaluates the FORM and returns the Nth value returned by the form as  a single value.  N is 0-based, i.e. the first returned value is   value 0 (for consistency with NTH and NTHCDR). Both N and FORM are  evaluated, in left-to-right order.Test Cases/Examples:  With this proposal MOD could be defined as:  (DEFUN MOD (NUMBER DIVISOR)    (NTH-VALUE 1 (FLOOR NUMBER DIVISOR)))  The same code would currently be:  (DEFUN MOD (NUMBER DIVISOR)    (MULTIPLE-VALUE-BIND (DIVIDEND REMAINDER)        (FLOOR NUMBER DIVISOR)      (DECLARE (IGNORE DIVIDEND))      REMAINDER))Rationale:  This corrects the stated problem.Current practice:  The TI Explorer and LMI Lambda have this feature. Cost to Implementors:  Writing the macro version is fairly straightforward.  Some will choose to implement compiler hooks so that code written with  NTH-VALUE will be as efficient as possible. This may involve some  additional work, but presumably nothing major.Cost to Users:  This is an upward-compatible change.Cost of non-Adoption:  The occassional code where this comes up may be one or more of   clumsier to write, more difficult to read, or less efficient.  (The feature is rarely used in implementations that have it.)Benefits:  The cost of non-adoption is avoided.Aesthetics:  While it does add another function to the language it removes  some need for the hairier multiple-value forms.Discussion:  Pitman proposed this in the very late pre-CLtL days. It was  rejected then because it was too late in the cycle.  There was not strong sentiment for including this feature  in Common Lisp, but no active opposition.*start*01211 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 19:28:38 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:42:47 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476052; Thu 13-Oct-88 18:40:33 EDTDate: Thu, 13 Oct 88 18:40 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: NTH-VALUE (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013184023.4.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Thought to be ready to vote.X3J13 meeting: JonL: Trivial, gratuitous. RWK: Not trivial -- allows index computation. Hard to do this      in a portable, efficient way. Allard: Says he has an NTH-VALUE macro for a portable system that he	 uses (which exploits the computed index feature) and that it's	 a gross kludge on Lucid in order to make it efficient. KMP: Also, in principle, an implementation could make this more      efficient than the alternatives.*start*03664 00024 US Date:  8 Dec 88 17:15 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: NTH-VALUE (Version 4)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noIssue:         NTH-VALUEReferences:    Multiple values, pp. 133-139Category:      ADDITIONEdit history:  16-Aug-88, Version 1 by Pierson               01-Oct-88, Version 2 by Pitman (minor edits)               5-Oct-88, Version 3 by Masinter			(add Current Practice as per Gray)                8-Dec-88, Version 4 by Masinter			(add comments to discussion)Problem description:  The set of operations on multiple values in Common Lisp is incomplete:  The only ways to retrieve just one of several return values (other than  the first) are:   - Bind several variables and then ignore all but one.     eg, (MULTIPLE-VALUE-BIND (X Y Z) <exp> (DECLARE (IGNORE X Y)) Z)     This is somewhat cumbersome to write and not perspicuous.   - Get a list of all return values and select from that.     eg, (THIRD (MULTIPLE-VALUE-LIST <exp>))     This is somewhat cumbersome, not perspicuous, and creates     needless garbage.Proposal (NTH-VALUE:ADD):  Add a new macro NTH-VALUE, described as  NTH-VALUE n form                                               [Macro]  Evaluates the FORM and returns the Nth value returned by the form as  a single value.  N is 0-based, i.e. the first returned value is   value 0 (for consistency with NTH and NTHCDR). Both N and FORM are  evaluated, in left-to-right order.Examples:  With this proposal MOD could be defined as:  (DEFUN MOD (NUMBER DIVISOR)    (NTH-VALUE 1 (FLOOR NUMBER DIVISOR)))  The same code would currently be:  (DEFUN MOD (NUMBER DIVISOR)    (MULTIPLE-VALUE-BIND (DIVIDEND REMAINDER)        (FLOOR NUMBER DIVISOR)      (DECLARE (IGNORE DIVIDEND))      REMAINDER))Rationale:  This corrects the stated problem.Current practice:  The TI Explorer and LMI Lambda have this feature. Cost to Implementors:  Writing the macro version is fairly straightforward.  Some will choose to implement compiler hooks so that code written with  NTH-VALUE will be as efficient as possible. This may involve some  additional work, but presumably nothing major.Cost to Users:  This is an upward-compatible change.Cost of non-Adoption:  The occassional code where this comes up may be one or more of   clumsier to write, more difficult to read, or less efficient.  (The feature is rarely used in implementations that have it.)Benefits:  The cost of non-adoption is avoided.Aesthetics:  While it does add another function to the language it removes  some need for the hairier multiple-value forms.Discussion:  Pitman proposed this in the very late pre-CLtL days. It was  rejected then because it was too late in the cycle.  There was not strong sentiment for including this feature  in Common Lisp, but no active opposition.Comments at the October 1988 X3J13 meeting:"Trivial, gratuitous.""Not trivial -- allows index computation. Hard to do this in a portable, efficient way.""Says he has an NTH-VALUE macro for a portable system that he uses (which exploits the computed index feature) and that it's a gross kludge in one implementation to make it efficient."        TITAN 
         TITAN 
           Z       	       …       
                            	                          &             k       
      >              &              7              ø              )              Ä       
       )              t             :      â  zº*start*03646 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 17:52:33 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  17:39:03 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 DEC 88 17:20:41 PSTDate: 8 Dec 88 17:15 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: NTH-VALUE (Version 4)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881208-172041-4997@Xerox>!Issue:         NTH-VALUEReferences:    Multiple values, pp. 133-139Category:      ADDITIONEdit history:  16-Aug-88, Version 1 by Pierson               01-Oct-88, Version 2 by Pitman (minor edits)               5-Oct-88, Version 3 by Masinter			(add Current Practice as per Gray)                8-Dec-88, Version 4 by Masinter			(add comments to discussion)Problem description:  The set of operations on multiple values in Common Lisp is incomplete:  The only ways to retrieve just one of several return values (other than  the first) are:   - Bind several variables and then ignore all but one.     eg, (MULTIPLE-VALUE-BIND (X Y Z) <exp> (DECLARE (IGNORE X Y)) Z)     This is somewhat cumbersome to write and not perspicuous.   - Get a list of all return values and select from that.     eg, (THIRD (MULTIPLE-VALUE-LIST <exp>))     This is somewhat cumbersome, not perspicuous, and creates     needless garbage.Proposal (NTH-VALUE:ADD):  Add a new macro NTH-VALUE, described as  NTH-VALUE n form                                               [Macro]  Evaluates the FORM and returns the Nth value returned by the form as  a single value.  N is 0-based, i.e. the first returned value is   value 0 (for consistency with NTH and NTHCDR). Both N and FORM are  evaluated, in left-to-right order.Examples:  With this proposal MOD could be defined as:  (DEFUN MOD (NUMBER DIVISOR)    (NTH-VALUE 1 (FLOOR NUMBER DIVISOR)))  The same code would currently be:  (DEFUN MOD (NUMBER DIVISOR)    (MULTIPLE-VALUE-BIND (DIVIDEND REMAINDER)        (FLOOR NUMBER DIVISOR)      (DECLARE (IGNORE DIVIDEND))      REMAINDER))Rationale:  This corrects the stated problem.Current practice:  The TI Explorer and LMI Lambda have this feature. Cost to Implementors:  Writing the macro version is fairly straightforward.  Some will choose to implement compiler hooks so that code written with  NTH-VALUE will be as efficient as possible. This may involve some  additional work, but presumably nothing major.Cost to Users:  This is an upward-compatible change.Cost of non-Adoption:  The occassional code where this comes up may be one or more of   clumsier to write, more difficult to read, or less efficient.  (The feature is rarely used in implementations that have it.)Benefits:  The cost of non-adoption is avoided.Aesthetics:  While it does add another function to the language it removes  some need for the hairier multiple-value forms.Discussion:  Pitman proposed this in the very late pre-CLtL days. It was  rejected then because it was too late in the cycle.  There was not strong sentiment for including this feature  in Common Lisp, but no active opposition.Comments at the October 1988 X3J13 meeting:"Trivial, gratuitous.""Not trivial -- allows index computation. Hard to do this in a portable, efficient way.""Says he has an NTH-VALUE macro for a portable system that he uses (which exploits the computed index feature) and that it's a gross kludge in one implementation to make it efficient."*start*02944 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 11:25:34 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 12 Jan 89  11:24:46 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 520320; Thu 12-Jan-89 14:23:03 ESTDate: Thu, 12 Jan 89 14:22 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: NTH-VALUE (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <890112142253.9.KMP@BOBOLINK.SCRC.Symbolics.COM>Some additional data on this topic, based on practical experience withpeople using multiple values over the past year.Since there is no convention for use of IGNORE or NIL in multiple-valueargument lists in Common Lisp, it is a common complaint that Cloe getsfrom users of Genera that they must rewrite: (MULTIPLE-VALUE-BIND (IGNORE Y)     (SEND FROB :READ-CURSORPOS)   ...)to do (MULTIPLE-VALUE-BIND (IGNORE Y)     (SEND FROB :READ-CURSORPOS)   (DECLARE (IGNORE IGNORE))   ...)I usually tell them that Common Lisp is considering an NTH-VALUEprimitive so they could write (LET ((Y (NTH-VALUE (SEND FROB :READ-CURSORPOS) 1)))   ...)and they are mostly appeased.Recently, however, someone asked me how he could do what inSymbolics Lisp would be written as: (MULTIPLE-VALUE-SETQ (IGNORE Y) (SEND FROB :READ-CURSORPOS))The only rewrites I could think of for this were much yuckier, so Ithought I'd raise the issue. With NTH-VALUE it would be  (SETQ Y (NTH-VALUE (SEND FROB :READ-CURSORPOS) 1))but without it, all I could come up with were: (MULTIPLE-VALUE-BIND (XX YY)     (SEND FROB :READ-CURSORPOS)   (DECLARE (IGNORE XX))   (SETQ Y YY))or (SETQ Y (MULTIPLE-VALUE-BIND (XX YY)             (SEND FROB :READ-CURSORPOS)             (DECLARE (IGNORE XX))	     YY))or (SETQ Y (CADR (MULTIPLE-VALUE-LIST (SEND FROB :READ-CURSORPOS))))I consider this case to be much yuckier than previous examples I'veseen, and it strengthens my belief in the need for NTH-VALUE.In the absence of NTH-VALUE, we should consider the possibilityof permitting NIL in the argument list to MULTIPLE-VALUE-BIND andMULTIPLE-VALUE-SETQ to denote an argument which is not to be assigned.The good points of that would be - it is fairly concise syntactically. - it doesn't accomodate a variable index like NTH-VALUE does.   Some implementors might prefer not to have to write that code.The bad points of that would be - NIL can fall through from lots of places in macros, etc. so error   checking is reduced. - it's a special case, and so aesthetically ugly to some. - it doesn't accomodate a variable index like NTH-VALUE does.   Some users might prefer not to have to write that code.*start*02354 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 09:35:45 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 13 Jan 89  09:35:09 PSTReceived: from relay2.cs.net by RELAY.CS.NET id ac17984; 13 Jan 89 11:57 ESTReceived: from draper.com by RELAY.CS.NET id ab04747; 13 Jan 89 11:41 ESTDate: Fri, 13 Jan 89 09:02 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: NTH-VALUE (Version 4)To: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525re: Message from KMP of 12 Jan 89, 14:22 EST I don't recall from the proposal, but is it true that the syntax of NTH-VALUEis (NTH-VALUE value-returning-form index), rather than(NTH-VALUE index value-returning-form)?  Why isn't it the latter, a la NTHand NTHCDR?  Not only is it more consistent with NTH and NTHCDR that way, butit is much easier to eyeball-parse (NTH 2 (big hairy expression)) than(NTH (big hairy expression) 2). Btw. ZIL supports destructuring in the argument list of MULTIPLE-VALUE-BIND, and thus handles NIL in place of an argument as a degenerate case thereof.(It doesn't support NIL in MULTIPLE-VALUE-SETQ, though I probably could createa MULTIPLE-VALUE-DESETQ macro a la DESETQ if I wanted to bother.)  Apropos of multiple-value issues, shouldn't there be a portable way for afunction that is about to return multiple values to be able to determine whether or not all of those values were actually going to be used, so it could bypass computation of extra values if they weren't going to be needed?Refer to CLtL, p. 134:  "It may be that...for efficiency reasons it is desired not to compute thesecond value." - this from a discussion of why you might want to code(values (floor x y)), for example.  Well, if FLOOR doesn't know that onlyits first value is being used, how can it take advantage of this and notcompute the second value, unless it uses some underlying low-level mechanismto find this out? If NTH-VALUE passes, this could get interesting.  FLOOR would have to be ableto tell, for example, that only its second value was going to get used, andavoid computing the first value.  This may not make a lot of sense for FLOOR,but there may be other functions where it does.*start*01858 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 11:27:10 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 13 Jan 89  11:26:03 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA12473; Fri, 13 Jan 89 14:24:40 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA05936; Fri, 13 Jan 89 14:24:06 ESTMessage-Id: <8901131924.AA05936@mist.>To: "Steve Bacher (Batchman)" <SEB1525@draper.com>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: NTH-VALUE (Version 4) In-Reply-To: Your message of Fri, 13 Jan 89 09:02:00 -0500.             <8901131741.AA11635@multimax.encore.com> Date: Fri, 13 Jan 89 14:24:04 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    re: Message from KMP of 12 Jan 89, 14:22 EST         I don't recall from the proposal, but is it true that the syntax    of NTH-VALUE is (NTH-VALUE value-returning-form index), rather    than (NTH-VALUE index value-returning-form)?  Why isn't it the    latter, a la NTH and NTHCDR?  Not only is it more consistent with    NTH and NTHCDR that way, but it is much easier to eyeball-parse    (NTH 2 (big hairy expression)) than (NTH (big hairy expression)    2).     Kent was wrong, the syntax is (NTH-VALUE index value-returning-form).    Apropos of multiple-value issues, shouldn't there be a portable    way for a function that is about to return multiple values to be    able to determine whether or not all of those values were actually    going to be used, so it could bypass computation of extra values    if they weren't going to be needed?  Refer to CLtL, p. 134:      Sounds like it might be a useful feature, but it also sounds like anew feature proposal too late in the game.*start*01824 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 13:20:38 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 13 Jan 89  13:19:53 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA21689; Fri, 13 Jan 89 13:21:14 PSTReceived: from denali.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA08561; Fri, 13 Jan 89 13:17:53 PSTReceived: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA11212; Fri, 13 Jan 89 13:20:37 PSTMessage-Id: <8901132120.AA11212@denali.sun.com>To: "Steve Bacher (Batchman)" <SEB1525@draper.com>Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: NTH-VALUE (Version 4) In-Reply-To: Your message of Fri, 13 Jan 89 09:02:00 -0500;	<8901131737.AA17270@Sun.COM> .Date: Fri, 13 Jan 89 13:20:35 PSTFrom: peck@Sun.COM>If NTH-VALUE passes, this could get interesting.  FLOOR would have to be able							 ^^^^^^^^^^^^^>to tell, for example, that only its second value was going to get used, and>avoid computing the first value.  This may not make a lot of sense for FLOOR,>but there may be other functions where it does.Nah, it would never be *required*.  p134 is talking about a "standard idiom"for how a programmer could express the desire.  A really smart compilerthat is working on an inline function that it knows a LOT about*maybe* would make such an optimzation.  You make a good point reminding us that (VALUES (...)) is a special case of NTH-VALUE, ie (NTH-VALUE 0 (...))Are we going to see an extension for MULTIPLE NTH-VALUES?(multiple-value-bind (a c e)   (NTH-VALUE '(0 2 4) (...))  ...)Equivalent to the request for NIL binding:(multiple-value-bind (a nil c nil e) (...)  ...)Yes, of course i just kidding... :)*start*01891 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 JAN 89 06:20:27 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 15 Jan 89  06:17:30 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03822g; Sun, 15 Jan 89 06:11:48 PSTReceived: by bhopal id AA11926g; Sun, 15 Jan 89 06:14:08 PSTDate: Sun, 15 Jan 89 06:14:08 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901151414.AA11926@bhopal>To: peck@Sun.COMCc: SEB1525@draper.com, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: peck@Sun.COM's message of Fri, 13 Jan 89 13:20:35 PST <8901132120.AA11212@denali.sun.com>Subject: Issue: NTH-VALUE (Version 4) re:                  . . .               FLOOR would have to be able					       ^^^^^^^^^^^^^    >to tell, for example, that only its second value was going to get used,     >and avoid computing the first value.  This may not make a lot of sense     >for FLOOR, but there may be other functions where it does.    A really smart compiler that is working on an inline function that it     knows a LOT about *maybe* would make such an optimzation.Lucid's 3.0 compiler "knows" a lot about FLOOR, and indeed optimizescases when only the first value is returned.  This turnes out to beextrememly important for floating point FLOOR's.  This is moderatelyeasy to do in a compiler that has implemented type-propogation, since ithas to be aware of multiple-value contexts anyway.  But it would besignificantly harder to optimize the case where only the second argument is ultimately used, since there are so many more ways to obscure that fact.The truncatation (no pun intended) of multiple values down into one is avery common case -- specified at length in CLtL -- and is syntaticallyeasy to detect.-- JonL --