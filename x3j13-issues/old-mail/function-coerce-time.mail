*start*07201 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 20 JUN 88 13:12:18 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Jun 88  13:11:35 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 422133; Mon 20-Jun-88 16:10:25 EDTDate: Mon, 20 Jun 88 16:09 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COERCE-TIME (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880620160959.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        FUNCTION-COERCE-TIMEReferences:   SET-MACRO-CHARACTER (p362),	      SET-DISPATCH-MACRO-CHARACTER (p364),	      MAP (p249), MAPL (p129), ...	      Functions using :TEST, :KEY, etc. (REDUCE, MEMBER, DELETE, ...)	      Functions using a positional predicate (SORT, DELETE-IF, ...)Category:     CLARIFICATIONEdit history: 20-Jun-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  Many functions which accept arguments which are to be treated functionally  but which are not of type FUNCTION. This functionality can be very useful,  but the time at which the coercion is accomplished must be made clear.Proposal (FUNCTION-COERCE-TIME:LAZY):  Specify that when a non-function (eg, a symbol) is used in place of a  function as an argument to operators which take functional arguments,  the coercion of that non-function to a function is delayed as long as  possible. That is, it is as if the result of calling   #'(LAMBDA (NON-FUNCTION)       #'(LAMBDA (&REST ARGUMENTS)	   (APPLY NON-FUNCTION ARGUMENTS)))  on the non-functional argument were passed instead.  Rationale:      One of the main reasons that it may be useful to pass a non-function    instead of a function is to accomplish indirection which allows later    redefinitions to take proper effect. Early binding would tend to    thwart the usefulness of such indirection and force people into    notationally more clumsy devices.Proposal (FUNCTION-COERCE-TIME:AMBITIOUS):  Specify that when a non-function (eg, a symbol) is used in place of a  function as an argument to operators which take functional arguments,  the coercion of that non-function to a function is done immediately.  Rationale:    This is easier to implement since the coercion is done up front and    no further worry about uncoerced functions is needed internally.    Also, inlining of mapped functions (without using temporary storage    to hold a cached value of the function being mapped) can be done    without needing to know whether the function being inlined will    affect the place which holds the functional argument being passed.Proposal (FUNCTION-COERCE-TIME:HYBRID):  Specify that when a non-function (eg, a symbol) is used in place of a  function as an argument to operators which take functional arguments,  the coercion of that non-function to a function must be done immediately  if the functional argument is to be used only internally to the function  (eg, SORT or MAPCAR) but is delayed as long as possible otherwise. (eg,  SET-MACRO-CHARACTER). That is, it is as if the result of calling   #'(LAMBDA (NON-FUNCTION)       #'(LAMBDA (&REST ARGUMENTS)	   (APPLY NON-FUNCTION ARGUMENTS)))  on the non-functional argument were passed instead.  Rationale:    Debugging is enhanced for operations such as SET-MACRO-CHARACTER    without needlessly hampering useful optimizations to things like    SORT or MAPCAR, which very rarely require this facility.Test Cases:  (DEFVAR *SOME-FUNCTIONS*	  (LIST #'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 1)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 2)	        #'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 3)	        #'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 4)))  ; Control situation A  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'(LAMBDA (&REST X) (APPLY #'FOO X))		       *SOME-FUNCTIONS*)	       (FOO T)))  => ((1 1 2 3) 4)  ; Control situation B  (LET ((FOO (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))))    (LIST (MAPCAR FOO		  *SOME-FUNCTIONS*)		  (FOO T)))  => ((1 1 1 1) 4)  ; Interesting Situation 1  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-1     or ((1 1 1 1) 4)				;Ambitious-1  ; Interesting Situation 2  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR 'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-2     or ((1 1 1 1) 4)				;Ambitious-2  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (EXPT (READ STREAM) (OR N 1)))  (SET-DISPATCH-MACRO-CHARACTER #\# #\$ 'SHARP-DOLLAR)  (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3 81)  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (+ (READ STREAM) (* (OR N 0) 0.01)))   (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3.0 3.04)					;Lazy-3     (3 81)					;Ambitious-3  Proposal LAZY      requires LAZY-1,      LAZY-2,      LAZY-3.  Proposal AMBITIOUS requires AMBITIOUS-1, AMBITIOUS-2, AMBITIOUS-3.  Proposal HYBRID    requires AMBITIOUS-1, AMBITIOUS-2, LAZY-3.Current Practice:  Implementations are permitted to differ in when they do the coercion since  the coercion time is not clearly spelled out.  (In the test case, LAZY-1 can occur only if MAPCAR is inlined, and then  only if the original value of the function definition is not cached.)  [Some info below is based on empirical testing -- I didn't look at the   source or try to see how speed/safety affect things. -kmp]  Symbolics Genera implements AMBITIOUS-1 interpreted and LAZY-1 compiled.  Symbolics Cloe (a compiled-only lisp) implements LAZY-1 both `interpreted'   and compiled.  Both Symbolics Genera and Symbolics Cloe implement LAZY-2.  Symbolics Genera implements LAZY-3.  Symbolics Cloe implements AMBITIOUS-3.Cost to Implementors:  [Costs may vary widely depending on current practice.   I'll leave this one open for now pending feedback from others. -kmp]Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  A very important aspect of the language would be left unspecified.  Portability would suffer.Benefits:  HYBRID has the benefit of making things like readmacros easier to debug.  LAZY offers the additional benefit of being able to repair certain  functional arguments to SORT or MAPCAR (eg, as a symbol) in the debugger,  and then to proceed the error (in implementations offering that restart  option) in a way that makes the ongoing call to SORT or MAPCAR notice  the repairwork right away.Aesthetics:  Since this is a visible aspect of the language, anything which clarified  the behavior that a programmer might expect would seem to improve the  aesthetics somewhat.Discussion:  This issue was raised by Nick Gall and written up by Pitman.  Pitman supports FUNCTION-COERCE-TIME:HYBRID.*start*00951 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 JUN 88 22:59:41 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 22 Jun 88  22:58:22 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 22 JUN 88 22:58:11 PDTDate: 22 Jun 88 22:46 PDTFrom: masinter.paSubject: Re: Issue: FUNCTION-COERCE-TIME (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 20 Jun 88 16:09 EDTTo: KMP@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880622-225811-3055@Xerox>This is the right idea, but "at late as possible" is probably too vague tosatisfy folks.I think the idea is that supplying x as a functional argument to  remove-if,mapc, etc.  should work identically to supplying #'(lambda (&rest arguments)(apply (if (functionp x) x (symbol-function x)) arguments))*start*01579 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 23 JUN 88 07:38:15 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 423624; Thu 23-Jun-88 10:37:51 EDTDate: Thu, 23 Jun 88 10:37 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-COERCE-TIME (Version 1)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880622-225811-3055@Xerox>Message-ID: <880623103735.0.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 22 Jun 88 22:46 PDT    From: masinter.pa@Xerox.COM    This is the right idea, but "at late as possible" is probably too vague to    satisfy folks.Sigh. You're probably right.    I think the idea is that supplying x as a functional argument to  remove-if,    mapc, etc.  should work identically to supplying #'(lambda (&rest arguments)    (apply (if (functionp x) x (symbol-function x)) arguments))Since I plan to submit a cleanup item to re-allow LAMBDA expressions as coerceableto functions, i would appreciate it if we could avoid any wording that got uscaught up in irrelevant presuppositions about what was a function or what wasn't.For example, #'(lambda (&rest arguments) (apply (coerce x 'function) arguments))would both make your local intent clearer and make this proposal more modular.I'll take care of ammending it in a few days after I make sure there are no othercomments.*start*00951 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 JUN 88 22:59:41 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 22 Jun 88  22:58:22 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 22 JUN 88 22:58:11 PDTDate: 22 Jun 88 22:46 PDTFrom: masinter.paSubject: Re: Issue: FUNCTION-COERCE-TIME (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 20 Jun 88 16:09 EDTTo: KMP@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880622-225811-3055@Xerox>This is the right idea, but "at late as possible" is probably too vague tosatisfy folks.I think the idea is that supplying x as a functional argument to  remove-if,mapc, etc.  should work identically to supplying #'(lambda (&rest arguments)(apply (if (functionp x) x (symbol-function x)) arguments))*start*08135 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 16 SEP 88 08:36:03 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 460400; Fri 16-Sep-88 11:36:01 EDTDate: Fri, 16 Sep 88 11:35 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COERCE-TIME (Version 2)To: Masinter.PAcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880915-183212-3570@Xerox>References: <880620160959.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>,            <880623103735.0.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>,            <880622-225811-3055@Xerox>Message-ID: <880916113555.4.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: 15 Sep 88 18:32 PDT    From: masinter.pa@Xerox.COM    Subject: Issue: FUNCTION-COERCE-TIME (Version 1)        I don't have any further correspondence on file after this.    Did you send a revision?Nope, but here's one now. I changed the wording significantly enoughthat each warrants a careful re-reading. Anyway, hope this satisfiesyour criticisms about vagueness. -----Issue:        FUNCTION-COERCE-TIMEReferences:   SET-MACRO-CHARACTER (p362),	      SET-DISPATCH-MACRO-CHARACTER (p364),	      MAP (p249), MAPL (p129), ...	      Functions using :TEST, :KEY, etc. (REDUCE, MEMBER, DELETE, ...)	      Functions using a positional predicate (SORT, DELETE-IF, ...)Category:     CLARIFICATIONEdit history: 20-Jun-88, Version 1 by Pitman	      16-Sep-88, Version 2 by Pitman	       (changes to presentation of all proposals per Masinter's comments)Status:	      For Internal DiscussionProblem Description:  Many functions which accept arguments which are to be treated functionally  but which are not of type FUNCTION. This functionality can be very useful,  but the time at which the coercion is accomplished must be made clear.Proposal (FUNCTION-COERCE-TIME:LAZY):  Specify that when a non-function (eg, a symbol) is used as a functional  argument to an operator, the coercion of that non-function to a function  is delayed until the function is about to be called and is done anew  every time the function is to be called. That is, passing a non-function  functional argument, F, is equivalent to passing   #'(LAMBDA (&REST ARGUMENTS)       (APPLY F ARGUMENTS))  Rationale:    One of the main reasons that it may be useful to pass a non-function    instead of a function is to accomplish indirection which allows later    redefinitions to take proper effect. Early binding would tend to    thwart the usefulness of such indirection and force people into    notationally more clumsy devices.Proposal (FUNCTION-COERCE-TIME:AMBITIOUS):  Specify that when a non-function (eg, a symbol) is used as a functional  argument to an operator, the coercion of that non-function to a function  is done immediately. That is, all such functions treat a non-function  functional argument, F, as if   (COERCE F 'FUNCTION)  had been passed instead.  Rationale:    This is easier to implement since the coercion is done up front and    no further worry about uncoerced functions is needed internally.    Also, inlining of mapped functions (without using temporary storage    to hold a cached value of the function being mapped) can be done    without needing to know whether the function being inlined will    affect the place which holds the functional argument being passed.Proposal (FUNCTION-COERCE-TIME:HYBRID):  Specify that when a non-function (eg, a symbol) is used as a   functional argument to an operator, the coercion of that non-function  to a function must be done immediately if the functional argument is  to be used only internally to the function (eg, SORT or MAPCAR).  Otherwise, if the functional argument's use persists beyond the end  of the call to the operator (eg, SET-MACRO-CHARACTER), any coercion is  delayed until the function is about to be called and is done anew every  time the function is to be called.  That is, functions like SORT and MAPCAR are permitted to treat a   non-function functional argument, F, as if   (COERCE F 'FUNCTION)  had been passed instead. However, functions like SET-MACRO-CHARACTER  would treat a non-function functional argument, F, as if   #'(LAMBDA (&REST ARGUMENTS)       (APPLY F ARGUMENTS))  were passed instead.  Rationale:    Debugging is enhanced for operations such as SET-MACRO-CHARACTER    without needlessly hampering useful optimizations to things like    SORT or MAPCAR, which very rarely require this facility.Test Cases:  (DEFVAR *SOME-FUNCTIONS*	  (LIST #'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 1)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 2)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 3)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 4)))  ; Control situation A  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'(LAMBDA (&REST X) (APPLY #'FOO X))		       *SOME-FUNCTIONS*)	       (FOO T)))  => ((1 1 2 3) 4)  ; Control situation B  (LET ((FOO (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))))    (LIST (MAPCAR FOO		  *SOME-FUNCTIONS*)		  (FOO T)))  => ((1 1 1 1) 4)  ; Interesting Situation 1  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-1     or ((1 1 1 1) 4)				;Ambitious-1  ; Interesting Situation 2  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR 'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-2     or ((1 1 1 1) 4)				;Ambitious-2  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (EXPT (READ STREAM) (OR N 1)))  (SET-DISPATCH-MACRO-CHARACTER #\# #\$ 'SHARP-DOLLAR)  (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3 81)  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (+ (READ STREAM) (* (OR N 0) 0.01)))   (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3.0 3.04)					;Lazy-3     (3 81)					;Ambitious-3  Proposal LAZY      requires LAZY-1,      LAZY-2,      LAZY-3.  Proposal AMBITIOUS requires AMBITIOUS-1, AMBITIOUS-2, AMBITIOUS-3.  Proposal HYBRID    requires AMBITIOUS-1, AMBITIOUS-2, LAZY-3.Current Practice:  Implementations are permitted to differ in when they do the coercion since  the coercion time is not clearly spelled out.  (In the test case, LAZY-1 can occur only if MAPCAR is inlined, and then  only if the original value of the function definition is not cached.)  [Some info below is based on empirical testing -- I didn't look at the   source or try to see how speed/safety affect things. -kmp]  Symbolics Genera implements AMBITIOUS-1 interpreted and LAZY-1 compiled.  Symbolics Cloe (a compiled-only lisp) implements LAZY-1 both `interpreted'   and compiled.  Both Symbolics Genera and Symbolics Cloe implement LAZY-2.  Symbolics Genera implements LAZY-3.  Symbolics Cloe implements AMBITIOUS-3.Cost to Implementors:  [Costs may vary widely depending on current practice.   I'll leave this one open for now pending feedback from others. -kmp]Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  A very important aspect of the language would be left unspecified.  Portability would suffer.Benefits:  HYBRID has the benefit of making things like readmacros easier to debug.  LAZY offers the additional benefit of being able to repair certain  functional arguments to SORT or MAPCAR (eg, as a symbol) in the debugger,  and then to proceed the error (in implementations offering that restart  option) in a way that makes the ongoing call to SORT or MAPCAR notice  the repairwork right away.Aesthetics:  Since this is a visible aspect of the language, anything which clarified  the behavior that a programmer might expect would seem to improve the  aesthetics somewhat.Discussion:  This issue was raised by Nick Gall and written up by Pitman.  Pitman supports FUNCTION-COERCE-TIME:HYBRID.*start*01309 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 OCT 88 14:26:28 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Oct 88  14:26:43 PDTReceived: from Burger.ms by ArpaGateway.ms ; 02 OCT 88 14:24:50 PDTDate: 2 Oct 88 14:24 PDTFrom: masinter.paSubject: Re: Issue: FUNCTION-COERCE-TIME (Version 2)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 16 Sep 88 11:35 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PA, CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <881002-142450-2702@Xerox>Well, this is a puzzle. It seems intertwined in an odd way withFUNCTION-CALL-EVALUATION-ORDER. There we want to leave unspecified whereefunctuation takes place, but here we're trying to nail it down. There itwas important for performance. Here it isn't except where it is. Is it?I.e., is there a performance hit for LAZY? Certainly it would force someinlining of macros not to. I'll go for HYBRID. Its the most implementable, and reasonable to explain,and seems to cause the least performance hit.Probably we need to list explicitly which functions with functionalarguments are lazy and which are ambitious.*start*07368 00024 USfDate:  8 Oct 88 17:10 PDTSender: masinter.paSubject: DRAFT Issue: FUNCTION-COERCE-TIME (Version 2)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterThis proposal has not yet been resolved in the cleanup committee.There are a variety of options being considered, as you can tell.Status:	DRAFTIssue:        FUNCTION-COERCE-TIMEReferences:   SET-MACRO-CHARACTER (p362),	      SET-DISPATCH-MACRO-CHARACTER (p364),	      MAP (p249), MAPL (p129), ...	      Functions using :TEST, :KEY, etc. (REDUCE, MEMBER, DELETE, ...)	      Functions using a positional predicate (SORT, DELETE-IF, ...)Category:     CLARIFICATIONEdit history: 20-Jun-88, Version 1 by Pitman	      16-Sep-88, Version 2 by Pitman	       (changes to presentation of all proposals per Masinter's comments)Status:	      For Internal DiscussionProblem Description:  Many functions which accept arguments which are to be treated functionally  but which are not of type FUNCTION. This functionality can be very useful,  but the time at which the coercion is accomplished must be made clear.Proposal (FUNCTION-COERCE-TIME:LAZY):  Specify that when a non-function (eg, a symbol) is used as a functional  argument to an operator, the coercion of that non-function to a function  is delayed until the function is about to be called and is done anew  every time the function is to be called. That is, passing a non-function  functional argument, F, is equivalent to passing   #'(LAMBDA (&REST ARGUMENTS)       (APPLY F ARGUMENTS))  Rationale:    One of the main reasons that it may be useful to pass a non-function    instead of a function is to accomplish indirection which allows later    redefinitions to take proper effect. Early binding would tend to    thwart the usefulness of such indirection and force people into    notationally more clumsy devices.Proposal (FUNCTION-COERCE-TIME:AMBITIOUS):  Specify that when a non-function (eg, a symbol) is used as a functional  argument to an operator, the coercion of that non-function to a function  is done immediately. That is, all such functions treat a non-function  functional argument, F, as if   (COERCE F 'FUNCTION)  had been passed instead.  Rationale:    This is easier to implement since the coercion is done up front and    no further worry about uncoerced functions is needed internally.    Also, inlining of mapped functions (without using temporary storage    to hold a cached value of the function being mapped) can be done    without needing to know whether the function being inlined will    affect the place which holds the functional argument being passed.Proposal (FUNCTION-COERCE-TIME:HYBRID):  Specify that when a non-function (eg, a symbol) is used as a   functional argument to an operator, the coercion of that non-function  to a function must be done immediately if the functional argument is  to be used only internally to the function (eg, SORT or MAPCAR).  Otherwise, if the functional argument's use persists beyond the end  of the call to the operator (eg, SET-MACRO-CHARACTER), any coercion is  delayed until the function is about to be called and is done anew every  time the function is to be called.  That is, functions like SORT and MAPCAR are permitted to treat a   non-function functional argument, F, as if   (COERCE F 'FUNCTION)  had been passed instead. However, functions like SET-MACRO-CHARACTER  would treat a non-function functional argument, F, as if   #'(LAMBDA (&REST ARGUMENTS)       (APPLY F ARGUMENTS))  were passed instead.  Rationale:    Debugging is enhanced for operations such as SET-MACRO-CHARACTER    without needlessly hampering useful optimizations to things like    SORT or MAPCAR, which very rarely require this facility.Test Cases:  (DEFVAR *SOME-FUNCTIONS*	  (LIST #'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 1)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 2)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 3)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 4)))  ; Control situation A  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'(LAMBDA (&REST X) (APPLY #'FOO X))		       *SOME-FUNCTIONS*)	       (FOO T)))  => ((1 1 2 3) 4)  ; Control situation B  (LET ((FOO (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))))    (LIST (MAPCAR FOO		  *SOME-FUNCTIONS*)		  (FOO T)))  => ((1 1 1 1) 4)  ; Interesting Situation 1  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-1     or ((1 1 1 1) 4)				;Ambitious-1  ; Interesting Situation 2  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR 'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-2     or ((1 1 1 1) 4)				;Ambitious-2  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (EXPT (READ STREAM) (OR N 1)))  (SET-DISPATCH-MACRO-CHARACTER #\# #\$ 'SHARP-DOLLAR)  (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3 81)  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (+ (READ STREAM) (* (OR N 0) 0.01)))   (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3.0 3.04)					;Lazy-3     (3 81)					;Ambitious-3  Proposal LAZY      requires LAZY-1,      LAZY-2,      LAZY-3.  Proposal AMBITIOUS requires AMBITIOUS-1, AMBITIOUS-2, AMBITIOUS-3.  Proposal HYBRID    requires AMBITIOUS-1, AMBITIOUS-2, LAZY-3.Current Practice:  Implementations are permitted to differ in when they do the coercion since  the coercion time is not clearly spelled out.  (In the test case, LAZY-1 can occur only if MAPCAR is inlined, and then  only if the original value of the function definition is not cached.)  [Some info below is based on empirical testing -- I didn't look at the   source or try to see how speed/safety affect things. -kmp]  Symbolics Genera implements AMBITIOUS-1 interpreted and LAZY-1 compiled.  Symbolics Cloe (a compiled-only lisp) implements LAZY-1 both `interpreted'   and compiled.  Both Symbolics Genera and Symbolics Cloe implement LAZY-2.  Symbolics Genera implements LAZY-3.  Symbolics Cloe implements AMBITIOUS-3.Cost to Implementors:  [Costs may vary widely depending on current practice.   I'll leave this one open for now pending feedback from others. -kmp]Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  A very important aspect of the language would be left unspecified.  Portability would suffer.Benefits:  HYBRID has the benefit of making things like readmacros easier to debug.  LAZY offers the additional benefit of being able to repair certain  functional arguments to SORT or MAPCAR (eg, as a symbol) in the debugger,  and then to proceed the error (in implementations offering that restart  option) in a way that makes the ongoing call to SORT or MAPCAR notice  the repairwork right away.Aesthetics:  Since this is a visible aspect of the language, anything which clarified  the behavior that a programmer might expect would seem to improve the  aesthetics somewhat.Discussion:  This issue was raised by Nick Gall and written up by Pitman.  Pitman supports FUNCTION-COERCE-TIME:HYBRID.*start*07691 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 17:44:07 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  17:26:25 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 08 OCT 88 17:10:18 PDTDate: 8 Oct 88 17:10 PDTSender: masinter.paSubject: DRAFT Issue: FUNCTION-COERCE-TIME (Version 2)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-171018-2362@Xerox>This proposal has not yet been resolved in the cleanup committee.There are a variety of options being considered, as you can tell.!Status:	DRAFTIssue:        FUNCTION-COERCE-TIMEReferences:   SET-MACRO-CHARACTER (p362),	      SET-DISPATCH-MACRO-CHARACTER (p364),	      MAP (p249), MAPL (p129), ...	      Functions using :TEST, :KEY, etc. (REDUCE, MEMBER, DELETE, ...)	      Functions using a positional predicate (SORT, DELETE-IF, ...)Category:     CLARIFICATIONEdit history: 20-Jun-88, Version 1 by Pitman	      16-Sep-88, Version 2 by Pitman	       (changes to presentation of all proposals per Masinter's comments)Status:	      For Internal DiscussionProblem Description:  Many functions which accept arguments which are to be treated functionally  but which are not of type FUNCTION. This functionality can be very useful,  but the time at which the coercion is accomplished must be made clear.Proposal (FUNCTION-COERCE-TIME:LAZY):  Specify that when a non-function (eg, a symbol) is used as a functional  argument to an operator, the coercion of that non-function to a function  is delayed until the function is about to be called and is done anew  every time the function is to be called. That is, passing a non-function  functional argument, F, is equivalent to passing   #'(LAMBDA (&REST ARGUMENTS)       (APPLY F ARGUMENTS))  Rationale:    One of the main reasons that it may be useful to pass a non-function    instead of a function is to accomplish indirection which allows later    redefinitions to take proper effect. Early binding would tend to    thwart the usefulness of such indirection and force people into    notationally more clumsy devices.Proposal (FUNCTION-COERCE-TIME:AMBITIOUS):  Specify that when a non-function (eg, a symbol) is used as a functional  argument to an operator, the coercion of that non-function to a function  is done immediately. That is, all such functions treat a non-function  functional argument, F, as if   (COERCE F 'FUNCTION)  had been passed instead.  Rationale:    This is easier to implement since the coercion is done up front and    no further worry about uncoerced functions is needed internally.    Also, inlining of mapped functions (without using temporary storage    to hold a cached value of the function being mapped) can be done    without needing to know whether the function being inlined will    affect the place which holds the functional argument being passed.Proposal (FUNCTION-COERCE-TIME:HYBRID):  Specify that when a non-function (eg, a symbol) is used as a   functional argument to an operator, the coercion of that non-function  to a function must be done immediately if the functional argument is  to be used only internally to the function (eg, SORT or MAPCAR).  Otherwise, if the functional argument's use persists beyond the end  of the call to the operator (eg, SET-MACRO-CHARACTER), any coercion is  delayed until the function is about to be called and is done anew every  time the function is to be called.  That is, functions like SORT and MAPCAR are permitted to treat a   non-function functional argument, F, as if   (COERCE F 'FUNCTION)  had been passed instead. However, functions like SET-MACRO-CHARACTER  would treat a non-function functional argument, F, as if   #'(LAMBDA (&REST ARGUMENTS)       (APPLY F ARGUMENTS))  were passed instead.  Rationale:    Debugging is enhanced for operations such as SET-MACRO-CHARACTER    without needlessly hampering useful optimizations to things like    SORT or MAPCAR, which very rarely require this facility.Test Cases:  (DEFVAR *SOME-FUNCTIONS*	  (LIST #'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 1)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 2)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 3)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 4)))  ; Control situation A  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'(LAMBDA (&REST X) (APPLY #'FOO X))		       *SOME-FUNCTIONS*)	       (FOO T)))  => ((1 1 2 3) 4)  ; Control situation B  (LET ((FOO (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))))    (LIST (MAPCAR FOO		  *SOME-FUNCTIONS*)		  (FOO T)))  => ((1 1 1 1) 4)  ; Interesting Situation 1  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-1     or ((1 1 1 1) 4)				;Ambitious-1  ; Interesting Situation 2  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR 'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-2     or ((1 1 1 1) 4)				;Ambitious-2  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (EXPT (READ STREAM) (OR N 1)))  (SET-DISPATCH-MACRO-CHARACTER #\# #\$ 'SHARP-DOLLAR)  (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3 81)  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (+ (READ STREAM) (* (OR N 0) 0.01)))   (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3.0 3.04)					;Lazy-3     (3 81)					;Ambitious-3  Proposal LAZY      requires LAZY-1,      LAZY-2,      LAZY-3.  Proposal AMBITIOUS requires AMBITIOUS-1, AMBITIOUS-2, AMBITIOUS-3.  Proposal HYBRID    requires AMBITIOUS-1, AMBITIOUS-2, LAZY-3.Current Practice:  Implementations are permitted to differ in when they do the coercion since  the coercion time is not clearly spelled out.  (In the test case, LAZY-1 can occur only if MAPCAR is inlined, and then  only if the original value of the function definition is not cached.)  [Some info below is based on empirical testing -- I didn't look at the   source or try to see how speed/safety affect things. -kmp]  Symbolics Genera implements AMBITIOUS-1 interpreted and LAZY-1 compiled.  Symbolics Cloe (a compiled-only lisp) implements LAZY-1 both `interpreted'   and compiled.  Both Symbolics Genera and Symbolics Cloe implement LAZY-2.  Symbolics Genera implements LAZY-3.  Symbolics Cloe implements AMBITIOUS-3.Cost to Implementors:  [Costs may vary widely depending on current practice.   I'll leave this one open for now pending feedback from others. -kmp]Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  A very important aspect of the language would be left unspecified.  Portability would suffer.Benefits:  HYBRID has the benefit of making things like readmacros easier to debug.  LAZY offers the additional benefit of being able to repair certain  functional arguments to SORT or MAPCAR (eg, as a symbol) in the debugger,  and then to proceed the error (in implementations offering that restart  option) in a way that makes the ongoing call to SORT or MAPCAR notice  the repairwork right away.Aesthetics:  Since this is a visible aspect of the language, anything which clarified  the behavior that a programmer might expect would seem to improve the  aesthetics somewhat.Discussion:  This issue was raised by Nick Gall and written up by Pitman.  Pitman supports FUNCTION-COERCE-TIME:HYBRID.*start*01016 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:01:04 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:01:22 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA19846; Thu, 13 Oct 88 14:59:44 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19871; Thu, 13 Oct 88 14:59:42 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132059.AA19871@defun.utah.edu>Date: Thu, 13 Oct 88 14:59:41 MDTSubject: issue FUNCTION-COERCE-TIMETo: cl-cleanup@sail.stanford.eduThe writeup for the LAZY option should mention that this might cause asubstantial performance hit in some implementations.Of the options presented, I prefer AMBITIOUS.  However, I would reallymuch rather see this whole issue left explicitly vague in thestandard.  If you'd like me to submit a proposal along those lines,let me know.-Sandra-------*start*01382 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:05:21 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:05:23 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 475890; 13 Oct 88 17:04:02 EDTDate: Thu, 13 Oct 88 17:03 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COERCE-TIME (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013170353.5.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Masinter: Eliminate the AMBITIOUS proposal. Continue to evolve the	   HYBRID and LAZY variants. KMP: Relation to DEBUG quality. There was some discussion about the idea of permitting vagueness (ie, making LAZY/AMBITIOUS optional in some places). KMP will write next draft.X3J13 meeting: JonL had some critical comments, but KMP couldn't understand them and believes it was because JonL didn't read the proposals carefully and was commenting on a superficial reading that led him to incorrect  conclusions. Some people weren't completely convinced that the HYBRID proposal would feel predictable enough. Others disagreed.*start*01584 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 OCT 88 12:54:02 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Oct 88  20:19:43 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00752g; Fri, 21 Oct 88 20:17:59 PDTReceived: by bhopal id AA12917g; Fri, 21 Oct 88 20:16:26 PDTDate: Fri, 21 Oct 88 20:16:26 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810220316.AA12917@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Thu, 13 Oct 88 17:03 EDT <881013170353.5.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COERCE-TIME (Version 2)re:  My notes from Fairfax meeting...     . . .      JonL had some critical comments, but KMP couldn't understand them     and believes it was because JonL didn't read the proposals carefully     and was commenting on a superficial reading that led him to incorrect      conclusions.This note doesn't say anyting at all to me (presumably it meant somethingto you at the time?).I favor FUNCTION-COERCE-TIME:HYBRID.The proposal is ovely opaque because it is trying to be overly general.Given the "cleanup" that we've already accepted for the FUNCTION type,then the only non-"functions" that can be passed to the functions ofreference (MAP, SORT, SET-MACRO-CHARACTER, etc) are SYMBOLS.  Also,it should be noted that the "coercion" involved is merely SYMBOL-FUNCTION.-- JonL --*start*01735 00024 US Return-Path: <sandra%defun@cs.utah.edu>Received: from cs.utah.edu ([128.110.4.21]) by Xerox.COM ; 07 NOV 88 15:42:30 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.0-cs)	id AA00342; Mon, 7 Nov 88 16:40:22 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA03984; Mon, 7 Nov 88 16:40:12 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8811072340.AA03984@defun.utah.edu>Date: Mon, 7 Nov 88 16:40:10 MSTSubject: Re: Issue: FUNCTION-COERCE-TIME (Version 2)To: masinter.paCc: Jon L White <jonl@lucid.com>, sandra%defun@cs.ARPA (Sandra J, Loosemore), KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: masinter.pa@Xerox.COM, 7 Nov 88 15:07 PSTWell, the main reason why I prefer "AMBITIOUS" to "HYBRID" is that itseems kind of peculiar to make an exception for the two functions,SET-MACRO-CHARACTER and SET-DISPATCH-MACRO-CHARACTER.  Besides beingdifferent from all the other functions that take functional arguments,it makes them different from the pathname functions (which alwayscoerce non-pathname "pathname" arguments to pathnames) and the packagefunctions (which always coerce non-package "package" arguments topackages). Also, I disagree that there is no performance penalty, although it'scertainly small in comparison to the rest of the reader's processing.For example, A-Lisp has a fast, opencoded funcall primitive that ituses when its argument is guaranteed to be a function, which is *much*faster than a normal funcall (by a factor of at least 20).I don't feel really strongly about this -- HYBRID is not really allthat objectionable to me, and I would vote for it if AMBITIOUS isthrown out. -Sandra-------*start*01729 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 NOV 88 16:28:12 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Nov 88  16:26:40 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 07 NOV 88 15:07:10 PSTDate: 7 Nov 88 15:07 PSTFrom: masinter.paSubject: Re: Issue: FUNCTION-COERCE-TIME (Version 2)In-reply-to: Jon L White <jonl@lucid.com>'s message of Fri, 21 Oct 88 20:16:26 PDTIn-reply-to: sandra%defun@cs.utah.edu (Sandra J Loosemore)'s message of Thu, 13 Oct 88 14:59:41 MDTTo: Jon L White <jonl@lucid.com>, sandra%defun@cs.utah.edu (Sandra J Loosemore)cc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881107-150710-1136@Xerox>JonL: Kent still has the hope that he'll be able to reverse the decision inFUNCTION-TYPE and let lambda lists be standardly coerced to functions bydefault. Rather than tie up this proposal with that issue, he resorted toterminology that would otherwise unnecessarily link the two issues.I think it is a good idea to make sure the two issues aren't linked. Maybeall we need to do is to explain in the discussion section the reason why itwas written in this way.Sandra: Can you explain the reasons why you like "ambitious"? I can't thinkof any good reasons for making it the standard; it doesn't improve thepotential performance of applications and it does interfere with theflexibility of the language; delayed "binding" is a feature we should becautious about removing from Lisp.  Similarly, there doesn't seem to be anygood reason for leaving it explicitly vague, does there? Could you explain?*start*02098 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 07 NOV 88 17:12:10 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 488700; Mon 7-Nov-88 20:12:33 ESTDate: Mon, 7 Nov 88 20:12 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-COERCE-TIME (Version 2)To: masinter.pacc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881107-150710-1136@Xerox>Message-ID: <881107201238.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Not only do I wish FUNCTION-TYPE would get changed back, but I think it isappropriate for us to word things in such a way that they infringe on someimplementation-specific extensions.To take an example from another domain, the Scheme community was discussingdefining EQ on symbols as simply comparing the print names (because Schemedoesn't have gensyms). I tried to talk them into mentioning that this wasonly incidental and that if gensyms were introduced that the (formal semantics)location of the symbol should be used, not its print name. I met with opposition from people who said that we (Scheme) shouldn't be saying howpeople extend things. But I continue to believe it would be a disaster ifsomeone extended Scheme to make EQ do anything other than pointer comparisonfor non-interned symbols.Getting back to this point, then, I think it's a good idea not only to separatethe issue of FUNCTION-TYPE from this issue, but also it's good to adopt wordingthat says what we mean it to say in the case where we can reasonably anticipateextensions.By the way, I'm thinking of circulating a revision of this proposal whichmight lean more toward explicitly vague on some of these issues. At the sametime, I'd like to encourage the use of the DEBUG and/or SPEED quality to helpcompilers lean toward LAZY in the slow/easy-to-debug case and AMBITIOUS in thefast/hard-to-debug case. There are some details to be worked out, though...Does anyone have any thoughts on that. *start*00821 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 21:51:32 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Dec 88  21:43:22 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 07 DEC 88 21:41:22 PSTDate: 7 Dec 88 21:41 PSTFrom: masinter.paSubject: Re: Issue: FUNCTION-COERCE-TIME (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881207-214122-2728@Xerox>This issue does not look like it will be ready in time. At one time, Sandraoffered to write up an "explicitly-vague" varient, and so was Kent, with"some details to be worked out."Given their schedules, this seems like it is unworkable. I'd like to have aversion for discussion in January, however.*start*00893 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JAN 89 23:59:56 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Jan 89  23:59:51 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 JAN 89 23:58:44 PSTDate: 8 Jan 89 23:58 PSTFrom: masinter.paSubject: Re: Issue: FUNCTION-COERCE-TIME (Version 2)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 13 Oct 88 17:03 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890108-235844-3572@Xerox>Kent:This one looks good for you to work on, if you're looking for priorities.We released a draft at the last meeting, but couldn't get said what wewanted. I'll try not to send too many "priorities" your way...*start*01204 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 08:38:02 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 08:38:05 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  08:38:32 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Fri, 17 Mar 89 11:34:48 ESTDate: Fri, 17 Mar 89 11:35 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: FUNCTION-COERCE-TIME (Version 2)To: cl-cleanup@sail.stanford.eduCc: Masinter.paIn-Reply-To: <890316-221804-6820@Xerox>Message-Id: <19890317163539.1.BARMAR@OCCAM.THINK.COM>I favor LAZY, and then HYBRID.  I don't think performance is asignificant issue, as programmers can always get ambitious semantics byspecifying #'symbol or (symbol-function 'symbol) explicitly instead of'symbol.  I believe that anyone who specifies the symbol instead of thefunction is doing it precisely for its lazy semantics.I like LAZY best because it makes all functions that take functionalarguments consistent.                                                barmar*start*09875 00024 US GV-Info: masinter.pa at 16-Mar-89 22:17:46 from massunterDate: 16 Mar 89 22:17 PSTSender: masinter.paSubject: Issue: FUNCTION-COERCE-TIME (Version 2)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.educc: MasinterUnfortunately, there have been no new versions of thisproduced since it was last distributed, labelled DRAFT, to X3J13prior to the October, 1988 meeting in Fairfax.Excerpts from the mail on this are appended.Issue:        FUNCTION-COERCE-TIMEReferences:   SET-MACRO-CHARACTER (p362),	      SET-DISPATCH-MACRO-CHARACTER (p364),	      MAP (p249), MAPL (p129), ...	      Functions using :TEST, :KEY, etc. (REDUCE, MEMBER, DELETE, ...)	      Functions using a positional predicate (SORT, DELETE-IF, ...)Category:     CLARIFICATIONEdit history: 20-Jun-88, Version 1 by Pitman	      16-Sep-88, Version 2 by Pitman	       (changes to presentation of all proposals per Masinter's comments)Status:	      For Internal DiscussionProblem Description:  Many functions which accept arguments which are to be treated functionally  but which are not of type FUNCTION. This functionality can be very useful,  but the time at which the coercion is accomplished must be made clear.Proposal (FUNCTION-COERCE-TIME:LAZY):  Specify that when a non-function (eg, a symbol) is used as a functional  argument to an operator, the coercion of that non-function to a function  is delayed until the function is about to be called and is done anew  every time the function is to be called. That is, passing a non-function  functional argument, F, is equivalent to passing   #'(LAMBDA (&REST ARGUMENTS)       (APPLY F ARGUMENTS))  Rationale:    One of the main reasons that it may be useful to pass a non-function    instead of a function is to accomplish indirection which allows later    redefinitions to take proper effect. Early binding would tend to    thwart the usefulness of such indirection and force people into    notationally more clumsy devices.Proposal (FUNCTION-COERCE-TIME:AMBITIOUS):  Specify that when a non-function (eg, a symbol) is used as a functional  argument to an operator, the coercion of that non-function to a function  is done immediately. That is, all such functions treat a non-function  functional argument, F, as if   (COERCE F 'FUNCTION)  had been passed instead.  Rationale:    This is easier to implement since the coercion is done up front and    no further worry about uncoerced functions is needed internally.    Also, inlining of mapped functions (without using temporary storage    to hold a cached value of the function being mapped) can be done    without needing to know whether the function being inlined will    affect the place which holds the functional argument being passed.Proposal (FUNCTION-COERCE-TIME:HYBRID):  Specify that when a non-function (eg, a symbol) is used as a   functional argument to an operator, the coercion of that non-function  to a function must be done immediately if the functional argument is  to be used only internally to the function (eg, SORT or MAPCAR).  Otherwise, if the functional argument's use persists beyond the end  of the call to the operator (eg, SET-MACRO-CHARACTER), any coercion is  delayed until the function is about to be called and is done anew every  time the function is to be called.  That is, functions like SORT and MAPCAR are permitted to treat a   non-function functional argument, F, as if   (COERCE F 'FUNCTION)  had been passed instead. However, functions like SET-MACRO-CHARACTER  would treat a non-function functional argument, F, as if   #'(LAMBDA (&REST ARGUMENTS)       (APPLY F ARGUMENTS))  were passed instead.  Rationale:    Debugging is enhanced for operations such as SET-MACRO-CHARACTER    without needlessly hampering useful optimizations to things like    SORT or MAPCAR, which very rarely require this facility.Test Cases:  (DEFVAR *SOME-FUNCTIONS*	  (LIST #'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 1)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 2)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 3)		#'(LAMBDA (X) (SETF (SYMBOL-FUNCTION 'FOO) X) 4)))  ; Control situation A  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'(LAMBDA (&REST X) (APPLY #'FOO X))		       *SOME-FUNCTIONS*)	       (FOO T)))  => ((1 1 2 3) 4)  ; Control situation B  (LET ((FOO (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))))    (LIST (MAPCAR FOO		  *SOME-FUNCTIONS*)		  (FOO T)))  => ((1 1 1 1) 4)  ; Interesting Situation 1  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR #'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-1     or ((1 1 1 1) 4)				;Ambitious-1  ; Interesting Situation 2  (PROGN (SETF (SYMBOL-FUNCTION 'FOO) (CAR *SOME-FUNCTIONS*))	 (LIST (MAPCAR 'FOO		       *SOME-FUNCTIONS*)	       (FOO T)))  =>    ((1 1 2 3) 4)				;Lazy-2     or ((1 1 1 1) 4)				;Ambitious-2  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (EXPT (READ STREAM) (OR N 1)))  (SET-DISPATCH-MACRO-CHARACTER #\# #\$ 'SHARP-DOLLAR)  (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3 81)  (DEFUN SHARP-DOLLAR (STREAM CHAR N)    (DECLARE (IGNORE CHAR))    (+ (READ STREAM) (* (OR N 0) 0.01)))   (VALUES (READ-FROM-STRING "(#$3 #4$3)"))  => (3.0 3.04)					;Lazy-3     (3 81)					;Ambitious-3  Proposal LAZY      requires LAZY-1,      LAZY-2,      LAZY-3.  Proposal AMBITIOUS requires AMBITIOUS-1, AMBITIOUS-2, AMBITIOUS-3.  Proposal HYBRID    requires AMBITIOUS-1, AMBITIOUS-2, LAZY-3.Current Practice:  Implementations are permitted to differ in when they do the coercion since  the coercion time is not clearly spelled out.  (In the test case, LAZY-1 can occur only if MAPCAR is inlined, and then  only if the original value of the function definition is not cached.)  [Some info below is based on empirical testing -- I didn't look at the   source or try to see how speed/safety affect things. -kmp]  Symbolics Genera implements AMBITIOUS-1 interpreted and LAZY-1 compiled.  Symbolics Cloe (a compiled-only lisp) implements LAZY-1 both `interpreted'   and compiled.  Both Symbolics Genera and Symbolics Cloe implement LAZY-2.  Symbolics Genera implements LAZY-3.  Symbolics Cloe implements AMBITIOUS-3.Cost to Implementors:  [Costs may vary widely depending on current practice.   I'll leave this one open for now pending feedback from others. -kmp]Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  A very important aspect of the language would be left unspecified.  Portability would suffer.Benefits:  HYBRID has the benefit of making things like readmacros easier to debug.  LAZY offers the additional benefit of being able to repair certain  functional arguments to SORT or MAPCAR (eg, as a symbol) in the debugger,  and then to proceed the error (in implementations offering that restart  option) in a way that makes the ongoing call to SORT or MAPCAR notice  the repairwork right away.Aesthetics:  Since this is a visible aspect of the language, anything which clarified  the behavior that a programmer might expect would seem to improve the  aesthetics somewhat.Discussion:  This issue was raised by Nick Gall and written up by Pitman.  Pitman supports FUNCTION-COERCE-TIME:HYBRID.Additional comments:There was some concern about the proposal wording, becauseit was trying to allow for the possibility that implementationsmight extend other objects (e.g., lists that begin withLAMBDA) to "coerce" to functions, and the proposal shouldapply for them, too.This made the wording of the proposal pretty awkward, though.- - - - - -The writeup for the LAZY option should mention that this might cause asubstantial performance hit in some implementations.Of the options presented, I prefer AMBITIOUS.  However, I would reallymuch rather see this whole issue left explicitly vague in thestandard.  - - - - notes from Cleanup meeting (Fairfax, 1988): Eliminate the AMBITIOUS proposal. Continue to evolve the	   HYBRID and LAZY variants. Relation to DEBUG quality. There was some discussion about the idea of permitting vagueness (ie, making LAZY/AMBITIOUS optional in some places).X3J13 meeting: Some people weren't completely convinced that the HYBRID proposal would feel predictable enough. Others disagreed.- - - - - - - -Well, the main reason why I prefer "AMBITIOUS" to "HYBRID" is that itseems kind of peculiar to make an exception for the two functions,SET-MACRO-CHARACTER and SET-DISPATCH-MACRO-CHARACTER.  Besides beingdifferent from all the other functions that take functional arguments,it makes them different from the pathname functions (which alwayscoerce non-pathname "pathname" arguments to pathnames) and the packagefunctions (which always coerce non-package "package" arguments topackages). Also, I disagree that there is no performance penalty, although it'scertainly small in comparison to the rest of the reader's processing.For example, A-Lisp has a fast, opencoded funcall primitive that ituses when its argument is guaranteed to be a function, which is *much*faster than a normal funcall (by a factor of at least 20).I don't feel really strongly about this -- HYBRID is not really allthat objectionable to me, and I would vote for it if AMBITIOUS isthrown out. -------... I'm thinking of a revision  which might lean more towardexplicitly vague on some of these issues. At the same time,I'd like to encourage the use of the DEBUG and/or SPEED qualityto help compilers lean toward LAZY in the slow/easy-to-debugcase and AMBITIOUS in the fast/hard-to-debug case. There aresome details to be worked out, though...*start*01038 00024 US GV-Info: barmar@Think.COM at 17-Mar-89 09:04:11 from AGReturn-Path: <barmar@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 17 MAR 89 08:51:18 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Fri, 17 Mar 89 11:34:48 ESTDate: Fri, 17 Mar 89 11:35 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: FUNCTION-COERCE-TIME (Version 2)To: cl-cleanup@sail.stanford.eduCc: Masinter.paIn-Reply-To: <890316-221804-6820@Xerox>Message-Id: <19890317163539.1.BARMAR@OCCAM.THINK.COM>I favor LAZY, and then HYBRID.  I don't think performance is asignificant issue, as programmers can always get ambitious semantics byspecifying #'symbol or (symbol-function 'symbol) explicitly instead of'symbol.  I believe that anyone who specifies the symbol instead of thefunction is doing it precisely for its lazy semantics.I like LAZY best because it makes all functions that take functionalarguments consistent.                                                barmar*start*01060 00024 US Date:  4 Apr 89 11:28 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: FUNCTION-COERCE-TIMETo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COERCE-TIMETo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 11:21:11 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:16:47 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571092; Tue 4-Apr-89 14:16:48 EDTOriginal-Date: Tue, 4 Apr 89 14:16 EDTMessage-ID: <890404141624.9.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes show this as withdrawn.The editors were instructed to be explicitly vague 16-1.