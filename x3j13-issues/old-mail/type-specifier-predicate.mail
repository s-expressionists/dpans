*start*01922 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  6 Dec 88 22:38From: jonl%lucid:COM:XeroxIn-Reply-to: Don Cohen's message of Wed, 30 Nov 88 18:55:38 PST <8812010255.AA17146@vaxa.isi.edu>Subject: commonlisp typesTo: donc%vaxa.isi:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: donc@vaxa.isi.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: Don Cohen's message of Wed, 30 Nov 88 18:55:38 PST <8812010255.AA17146@vaxa.isi.edu>Subject: commonlisp typesReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 DEC 88 22:38:01 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 6 Dec 88  21:46:59 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00869g; Tue, 6 Dec 88 21:44:34 PSTReceived: by bhopal id AA11501g; Tue, 6 Dec 88 21:46:27 PSTOriginal-Date: Tue, 6 Dec 88 21:46:27 PSTMessage-Id: <8812070546.AA11501@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: There seems to be nothing in CLtL that answers the question:        "is x a legal type specifier?"At the meeting that founded the X3J13 committee (on 6-Dec-85), Guy Steele circulated a list of "non-controversial issues" and "Clarifications"which included the following addition [typos faithfully reproduced]:  "(*) 51 Add a newefunction TYPE-SPECIFIER-P that is true of valid type   specifiers and fals of all other Lisp objects.  Note that the use of   DEFSTRUCT and DEFTYPE can change the behavior of TYPE-SPECIFIER-P over   time."Sad to say, this and many other "non-controversial" items included inGuy's list of "Clarifications", has never been brought up in the X3J13"Cleanup" subcommittee.  However, Lucid's 3.0 release includes such a function.-- JonL --*start*01797 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 30 Nov 88 19:18Subject: commonlisp typesFrom: donc%vaxa.isi:EDU:XeroxTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: common-lisp@sail.stanford.eduSubject: commonlisp typesFrom: Don Cohen <donc@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 NOV 88 19:18:22 PSTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 30 Nov 88  18:56:05 PSTPosted-Date: Wed, 30 Nov 88 18:55:38 PSTMessage-Id: <8812010255.AA17146@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.59/5.51)	id AA17146; Wed, 30 Nov 88 18:55:41 PSTOriginal-Date: Wed, 30 Nov 88 18:55:38 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThere seems to be nothing in CLtL that answers the question:    "is x a legal type specifier?"The description of TypeP says that the type argument may beany of the legal type specifiers except (function ...) or(values ...).I would hope that would mean that for any such "legalarguments" typep would not cause an error.  I would also hope that any illegal type would cause an error.On the other hand the description of how typep handles(satisfies ...) indicates that errors might well result.Intuitively, it seems to me that if an error results fromthat test the typep test ought to return nil, e.g.,    (typep nil '(satisfies zerop))I'd like the spec to say that typep first decides whetherthe type is legal, and signals an error if not.  Then,for things like satisfies, it applies the predicate butcatches errors, and returns nil if an error occurs.What do you experts (and lawyers) out there think?*start*03439 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  1 Dec 88 08:38From: barmar%Think:COM:XeroxSubject: commonlisp typesIn-Reply-to: <8812010255.AA17146@vaxa.isi.edu>To: donc%vaxa.isi:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: commonlisp typesTo: Don Cohen <donc@vaxa.isi.edu>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <8812010255.AA17146@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 DEC 88 08:38:04 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 1 Dec 88  08:06:41 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 1 Dec 88 10:48:06 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 1 Dec 88 11:04:43 ESTOriginal-Date: Thu, 1 Dec 88 11:04 ESTMessage-Id: <19881201160446.1.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Wed, 30 Nov 88 18:55:38 PST    From: Don Cohen <donc@vaxa.isi.edu>    There seems to be nothing in CLtL that answers the question:	"is x a legal type specifier?"    The description of TypeP says that the type argument may be    any of the legal type specifiers except (function ...) or    (values ...).    I would hope that would mean that for any such "legal    arguments" typep would not cause an error.  I would also     hope that any illegal type would cause an error.    On the other hand the description of how typep handles    (satisfies ...) indicates that errors might well result.    Intuitively, it seems to me that if an error results from    that test the typep test ought to return nil, e.g.,	(typep nil '(satisfies zerop))    I'd like the spec to say that typep first decides whether    the type is legal, and signals an error if not.  Then,    for things like satisfies, it applies the predicate but    catches errors, and returns nil if an error occurs.    What do you experts (and lawyers) out there think?Since CLtL doesn't say that TYPEP must signal an error if the typespecifier is invalid, it currently "is an error" if the type specifieris not a valid type specifer other than (FUNCTION ...) or (VALUES ...).I don't think there has been any suggestion within X3J13 to change this.In general, Common Lisp tends not to require implementations to do lotsof this kind of checking; at high safety optimization levels it isinformally encouraged, but not required.Actually, in this particular case, I don't think that requiring an errorto be signalled would be too bad.  TYPEP must already do a significantamount of work to decode the type specifier, so it probably knows whenthe type specifier is invalid, and signalling an error would be prettyeasy.  However, putting this requirement into the CL standard would bean incompatible change to the language definition, with only minor gain,and I think it is kind of late for it now (we're not very far fromtrying to get a draft finished).As for your suggestion about (SATISFIES ...), I personally think that isa bad idea.  TYPEP shouldn't silently hide bugs in the programmer'spredicate.  The above example should have been written as	(typep nil '(and number (satisfies zerop)))                                                barmar*start*01647 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  1 Dec 88 22:28From: jwz%spice.cs.cmu:EDU:XeroxSubject: Re: commonlisp typesTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jamie.Zawinski <jwz@spice.cs.cmu.edu>To: common-lisp@sail.stanford.eduSubject: Re: commonlisp typesReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 DEC 88 22:28:16 PSTReceived: from SPICE.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 1 Dec 88  22:04:56 PSTOriginal-Date: Fri, 2 Dec 88 00:40 ESTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV...but I believe it is the case that there is no CL way to determineif a given type is defined.I wish there was some CL way to define a complex type and insert it in the existing hierarchy.  For example, I once tried to define the typeLIST-OF, which would be used like (TYPEP '(1 2 3) '(LIST-OF FIXNUM))  ==> T (TYPEP '(A B 3) '(LIST-OF FIXNUM))  ==> NIL (SUBTYPEP '(LIST-OF SYMBOL) 'LIST)  ==> T (SUBTYPEP '(LIST-OF FIXNUM) '(LIST-OF NUMBER))  ==> T (SUBTYPEP '(LIST-OF *) '(LIST-OF LIST))  ==> NIL NILOn the TI Explorer this was really easy.In Lucid CL, it was not possible except by bashing the definitions ofTYPEP and SUBTYPEP.Can someone explain the rationale behind forcing SATISFIES to accept only function-names and not lambda expressions?I can see that the compiler could have special knowledge aboutsuch forms as (SATISFIES PLUSP), but CLtL says lambdas are excluded"to avoid scoping problems."Jamie*start*01805 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  2 Dec 88 08:28From: barmar%Think:COM:XeroxSubject: Re: commonlisp typesIn-Reply-to: <8812020545.AA12869@Think.COM>To: jwz%spice.cs.cmu:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: commonlisp typesTo: Jamie.Zawinski <jwz@spice.cs.cmu.edu>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <8812020545.AA12869@Think.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 DEC 88 08:27:51 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 2 Dec 88  08:04:04 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Fri, 2 Dec 88 10:41:22 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Fri, 2 Dec 88 11:02:22 ESTOriginal-Date: Fri, 2 Dec 88 11:02 ESTMessage-Id: <19881202160232.8.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 2 Dec 1988 00:40-EST     From: Jamie.Zawinski <jwz@spice.cs.cmu.edu>    Can someone explain the rationale behind forcing SATISFIES to     accept only function-names and not lambda expressions?    I can see that the compiler could have special knowledge about    such forms as (SATISFIES PLUSP), but CLtL says lambdas are excluded    "to avoid scoping problems."I think this means that they didn't want to create confusion aboutwhether the lambda expressions produced lexical closures or not.Someone might think that the following would work:(defun strange-eq (x y)  (typep x '(satisfies (lambda (object) (eq object y)))))                                                barmar*start*02621 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  2 Dec 88 08:58From: gls%Think:COM:XeroxIn-Reply-to: Jamie.Zawinski's message of Fri, 2 Dec 1988 00:40-EST  <8812020545.AA12869@Think.COM>Subject: commonlisp typesTo: jwz%spice.cs.cmu:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Guy Steele <gls@Think.COM>To: jwz@spice.cs.cmu.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: Jamie.Zawinski's message of Fri, 2 Dec 1988 00:40-EST  <8812020545.AA12869@Think.COM>Subject: commonlisp typesReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 DEC 88 08:58:49 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 2 Dec 88  08:36:41 PSTReceived: from fafnir.think.com by Think.COM; Fri, 2 Dec 88 11:13:42 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 2 Dec 88 11:34:51 ESTReceived: by verdi.think.com; Fri, 2 Dec 88 11:33:22 ESTOriginal-Date: Fri, 2 Dec 88 11:33:22 ESTMessage-Id: <8812021633.AA05964@verdi.think.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV   Date: Fri, 2 Dec 1988 00:40-EST    From: Jamie.Zawinski <jwz@spice.cs.cmu.edu>   ...   Can someone explain the rationale behind forcing SATISFIES to    accept only function-names and not lambda expressions?   I can see that the compiler could have special knowledge about   such forms as (SATISFIES PLUSP), but CLtL says lambdas are excluded   "to avoid scoping problems."Consider(defun bazola (linguini pop-tarts)  (declare (type (satisfies (lambda (x) (< x linguini))) pop-tarts))  ...)I'm trying to say that pop-tarts is always smaller in value than linguini.The lambda expression appears lexically within the binding of linguini,so one might expect that the free reference to linguini is legitimate.But it can't work.Similarly this cannot work:(defun bazola (linguini pop-tarts)  (assert (typep pop-tarts '(satisfies (lambda (x) (< x linguini)))))  ...)[Of course, this can be rendered instead as(defun bazola (linguini pop-tarts)  (assert (< pop-tarts linguini))  ...)but that is beside the point.]One might conceivably argue that SATISFIES should allow an actualfunction and not just a name; then one might try(defun bazola (linguini pop-tarts)  (assert (typep pop-tarts `(satisfies ,(lambda (x) (< x linguini)))))  ...)but this approach doesn't help the declaration case.  It's a basic problemof compile-time versus run-time execution.--Guy*start*02489 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  3 Jan 89 04:06From: RWK%F.ILA.Dialnet.Symbolics:COM:XeroxSubject: commonlisp typesIn-Reply-to: <8812070546.AA11501@bhopal>To: jonl%lucid.com%RIVERSIDE.SCRC.SYMBOLICS:COM:Xerox, common-lisp%sail.stanford.edu%RIVERSIDE.SCRC.SYMBOLICS:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@F.ILA.Dialnet.Symbolics.COM>Subject: commonlisp typesTo: jonl%lucid.com@RIVERSIDE.SCRC.SYMBOLICS.COM, common-lisp%sail.stanford.edu@RIVERSIDE.SCRC.SYMBOLICS.COMIn-Reply-To: <8812070546.AA11501@bhopal>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 04:05:57 PSTReceived: from Riverside.SCRC.Symbolics.COM (SCRC-RIVERSIDE.ARPA) by SAIL.Stanford.EDU with TCP; 3 Jan 89  03:39:54 PSTReceived: from F.ILA.Dialnet.Symbolics.COM (FUJI.ILA.Dialnet.Symbolics.COM) by Riverside.SCRC.Symbolics.COM via DIAL with SMTP id 305296; 3 Jan 89 06:37:40 ESTOriginal-Date: Tue, 3 Jan 89 05:35 ESTSupersedes: <19890103090720.6.RWK@F.ILA.Dialnet.Symbolics.COM>Comments: Retransmission of failed mail.Message-ID: <19890103103558.4.RWK@F.ILA.Dialnet.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVU    Date: Tue, 6 Dec 88 21:46:27 PST    From: Jon L White <jonl@lucid.com>    re: There seems to be nothing in CLtL that answers the question:	    "is x a legal type specifier?"    At the meeting that founded the X3J13 committee (on 6-Dec-85), Guy Steele     circulated a list of "non-controversial issues" and "Clarifications"    which included the following addition [typos faithfully reproduced]:      "(*) 51 Add a newefunction TYPE-SPECIFIER-P that is true of valid type       specifiers and fals of all other Lisp objects.  Note that the use of       DEFSTRUCT and DEFTYPE can change the behavior of TYPE-SPECIFIER-P over       time."    Sad to say, this and many other "non-controversial" items included in    Guy's list of "Clarifications", has never been brought up in the X3J13    "Cleanup" subcommittee.  However, Lucid's 3.0 release includes such     a function.How do you define "valid type specifier"?(deftype foo (x)   (car x))(typep 'yow '(foo a))==> Error taking CAR of the symbol A.(type-specifier-p '(foo a))==> ?I would guess probably T, but then, how do you word the definition?If not, how do you define it?*start*04885 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 22 Dec 88 13:01From: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: commonlisp typesIn-Reply-to: <8812021633.AA05964@verdi.think.com>To: gls%Think:COM:Xeroxcc: jwz%spice.cs.cmu:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: commonlisp typesTo: gls@Think.COMcc: jwz@spice.cs.cmu.edu, common-lisp@sail.stanford.eduIn-Reply-To: <8812021633.AA05964@verdi.think.com>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 DEC 88 13:00:42 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Dec 88  12:18:57 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 511560; Thu 22-Dec-88 15:17:50 ESTOriginal-Date: Thu, 22 Dec 88 15:17 ESTMessage-ID: <881222151736.1.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 2 Dec 88 11:33:22 EST    From: Guy Steele <gls@Think.COM>       Date: Fri, 2 Dec 1988 00:40-EST        From: Jamie.Zawinski <jwz@spice.cs.cmu.edu>       ...       Can someone explain the rationale behind forcing SATISFIES to        accept only function-names and not lambda expressions?       I can see that the compiler could have special knowledge about       such forms as (SATISFIES PLUSP), but CLtL says lambdas are excluded       "to avoid scoping problems."    Consider    (defun bazola (linguini pop-tarts)      (declare (type (satisfies (lambda (x) (< x linguini))) pop-tarts))      ...)    I'm trying to say that pop-tarts is always smaller in value than linguini.    The lambda expression appears lexically within the binding of linguini,    so one might expect that the free reference to linguini is legitimate.    But it can't work.    Similarly this cannot work:    (defun bazola (linguini pop-tarts)      (assert (typep pop-tarts '(satisfies (lambda (x) (< x linguini)))))      ...)    [Of course, this can be rendered instead as    (defun bazola (linguini pop-tarts)      (assert (< pop-tarts linguini))      ...)    but that is beside the point.]    One might conceivably argue that SATISFIES should allow an actual    function and not just a name; then one might try    (defun bazola (linguini pop-tarts)      (assert (typep pop-tarts `(satisfies ,(lambda (x) (< x linguini)))))      ...)    but this approach doesn't help the declaration case.  It's a basic problem    of compile-time versus run-time execution.    --GuyFyi, it turns out this rationale doesn't hold as much water as you'd think.Consider: (defun bar (x) (symbolp x)) (defun foo (x)   (flet ((bar (y) (integerp y)))     (typep x '(satisfies bar)))) (foo 'x)The correct answer is T, but I bet a lot of implementations return NILin compiled code.Anyway, my main point is that the reason for prohibiting lambda expressionsisn't that they're not meaningful, only that they're hard to reason about.But since an analogous argument can be made for symbols, the rationale breaksdown.Since (SATISFIES BAR) means that (FUNCALL (SYMBOL-FUNCTION 'BAR) ...) istrue, not that (FUNCALL #'BAR ...) is true, then it follows that(SATISFIES (LAMBDA (X) (AND (BAR X) (BAZ X)))) means(FUNCALL (EVAL '#'(LAMBDA (X) (AND (BAR X) (BAZ X)))) ...) is true, notthat(FUNCALL #'(LAMBDA (X) (AND (BAR X) (BAZ X))) ...) is true.The real truth is that we thought the scoping problems were limited toLAMBDA expressions because we weren't used to reasoning about FLET, whichwas a new construct at the time we designed CL. If we had it to do over,I'd certainly be lobbying strongly for permitting lambda expressions.The Common-Lisp mailing list doesn't have the authority to change the language, so I'll save any proposals to change things for other forums.But I did want to publicly debunk the myth behind this design decision.Btw, if LAMBDA expressions -were- permitted, the BAZOLA example you suggestcould, in addition to the more obvious way you cite, be written as:    (defun bazola (linguini pop-tarts)      (declare (special linguini))      (assert (typep pop-tarts '(satisfies (lambda (x)					     (declare (special linguini))					     (< x linguini)))))      ...)This works even if you open code it in the obvious way, though it hasthe disadvantage that figuring out that the SPECIAL declaration was neededonly for the sake of the transition into the SATISFIES and not for somefunction called within the opened LAMBDA may be tricky. So the open-codedform may do a needless special bind in complex cases involving calls touser-defined predicates.*start*02614 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  2 Jan 89 13:01From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: commonlisp typesIn-Reply-to: <881222151736.1.KMP@BOBOLINK.SCRC.Symbolics.COM>To: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: gls%Think:COM:Xerox, jwz%spice.cs.cmu:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: commonlisp typesTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: gls@Think.COM, jwz@spice.cs.cmu.edu, common-lisp@sail.stanford.eduIn-Reply-To: <881222151736.1.KMP@BOBOLINK.SCRC.Symbolics.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 13:01:22 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Jan 89  12:37:56 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 514019; Mon 2-Jan-89 15:35:56 ESTOriginal-Date: Mon, 2 Jan 89 15:35 ESTMessage-ID: <19890102203526.6.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 22 Dec 88 15:17 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>	Date: Fri, 2 Dec 88 11:33:22 EST	From: Guy Steele <gls@Think.COM>	   Date: Fri, 2 Dec 1988 00:40-EST 	   From: Jamie.Zawinski <jwz@spice.cs.cmu.edu>	   ...	   Can someone explain the rationale behind forcing SATISFIES to 	   accept only function-names and not lambda expressions?        ....    Fyi, it turns out this rationale doesn't hold as much water as you'd think.    Consider:     (defun bar (x) (symbolp x))     (defun foo (x)       (flet ((bar (y) (integerp y)))	 (typep x '(satisfies bar))))     (foo 'x)    The correct answer is T, but I bet a lot of implementations return NIL    in compiled code.    ....    The real truth is that we thought the scoping problems were limited to    LAMBDA expressions because we weren't used to reasoning about FLET, which    was a new construct at the time we designed CL. If we had it to do over,    I'd certainly be lobbying strongly for permitting lambda expressions.You're right.  I think what really happened is not that we weren't usedto FLET, but that FLET and LABELS were added to the language aftertype-specifiers had been designed, and the full ramifications of FLET onthe rest of the language were not explored at the time it was added.*start*02111 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  4 Jan 89 01:21 PSTFrom: jonl%lucid:COM:XeroxIn-Reply-to: Robert W. Kerns's message of Tue, 3 Jan 89 05:35 EST <19890103103558.4.RWK@F.ILA.Dialnet.Symbolics.CSubject: commonlisp typesTo: RWK%F.ILA.Dialnet.Symbolics:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: RWK@F.ILA.Dialnet.Symbolics.COMCc: common-lisp@sail.stanford.eduIn-Reply-To: Robert W. Kerns's message of Tue, 3 Jan 89 05:35 EST <19890103103558.4.RWK@F.ILA.Dialnet.Symbolics.COM>Subject: commonlisp typesReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 JAN 89 01:20:50 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 4 Jan 89  01:01:59 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04028g; Wed, 4 Jan 89 00:56:44 PSTReceived: by bhopal id AA01403g; Wed, 4 Jan 89 00:58:57 PSTOriginal-Date: Wed, 4 Jan 89 00:58:57 PSTMessage-Id: <8901040858.AA01403@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: How do you define "valid type specifier"?Very syntactically.  I think its perfectly acceptable to have a setof combination rules for making "words" in the type-specifier syntax,even though some such "words" would be gibberish.The important thing is that base-level types -- those defined in CLtL -- along with DEFSTRUCT extensions be recognizable.  They don'thave the problems that SATISFIES generates, or that a broken userdefinition generates (such as your DEFTYPE FOO example).By the bye, on another note, I haven't seen any implementation thathas the bug Kent wondered about earlier:     (defun bar (x) (symbolp x))     (defun foo (x)       (flet ((bar (y) (integerp y)))	 (typep x '(satisfies bar))))     (foo 'x)    The correct answer is T, but I bet a lot of implementations return NIL    in compiled code.Anyone know of an implementation for which this fails?-- JonL --*start*01088 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  4 Jan 89 06:00 PSTFrom: FORSTER%cs.umass:EDU:XeroxSubject: re: commonlisp typesTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David Forster <FORSTER@cs.umass.EDU>Subject: re: commonlisp typesTo: common-lisp@sail.stanford.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 JAN 89 06:00:02 PSTReceived: from crash.cs.umass.edu ([128.119.40.235]) by SAIL.Stanford.EDU with TCP; 4 Jan 89  05:37:09 PSTReceived: from vax5.cs.umass.edu by crash.cs.umass.edu (5.59/Ultrix2.0-B)	id AA05758; Wed, 4 Jan 89 08:38:09 estMessage-Id: <8901041338.AA05758@crash.cs.umass.edu>Original-Date: Wed, 4 Jan 89 08:37 ESTX-Vms-To: IN%"common-lisp@sail.stanford.edu"GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThe TI Explorer (4.2) is one of your problem cases -- it applies the flet'dfunction in the `satisfies' clause, instead of the defun'd one.*start*02990 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  6 Jan 89 14:17 PSTFrom: RWK%FUJI.ILA.Dialnet.Symbolics:COM:XeroxSubject: commonlisp typesIn-Reply-to: <8901040858.AA01403@bhopal>To: jonl%lucid.com%Riverside.SCRC.Symbolics:COM:Xeroxcc: common-lisp%sail.stanford.edu%Riverside.SCRC.Symbolics:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@FUJI.ILA.Dialnet.Symbolics.COM>Subject: commonlisp typesTo: Jon L White <jonl%lucid.com@Riverside.SCRC.Symbolics.Com>cc: common-lisp%sail.stanford.edu@Riverside.SCRC.Symbolics.ComIn-Reply-To: <8901040858.AA01403@bhopal>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 14:17:26 PSTReceived: from Riverside.SCRC.Symbolics.COM (SCRC-RIVERSIDE.ARPA) by SAIL.Stanford.EDU with TCP; 6 Jan 89  13:46:18 PSTReceived: from F.ILA.Dialnet.Symbolics.COM (FUJI.ILA.Dialnet.Symbolics.COM) by Riverside.SCRC.Symbolics.COM via DIAL with SMTP id 306344; 6 Jan 89 15:56:48 ESTReceived: from CALVARY.ILA.Dialnet.Symbolics.COM by F.ILA.Dialnet.Symbolics.COM via CHAOS with CHAOS-MAIL id 7601; Fri 6-Jan-89 15:15:53 ESTOriginal-Date: Fri, 6 Jan 89 15:16 ESTMessage-ID: <19890106201603.1.RWK@CALVARY.ILA.Dialnet.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Wed, 4 Jan 89 00:58:57 PST    From: Jon L White <jonl@lucid.com>    re: How do you define "valid type specifier"?    Very syntactically.  I think its perfectly acceptable to have a set    of combination rules for making "words" in the type-specifier syntax,    even though some such "words" would be gibberish.    The important thing is that base-level types -- those defined in     CLtL -- along with DEFSTRUCT extensions be recognizable.  They don't    have the problems that SATISFIES generates, or that a broken user    definition generates (such as your DEFTYPE FOO example).I'm not saying there's a fundamental problem here, just that there's a choiceto be made, and that writing precise and understandable definitions isnon-trivial.  I'd like to encourage you to make YOUR definition explicit forus, as a starting point.    By the bye, on another note, I haven't seen any implementation that    has the bug Kent wondered about earlier:	 (defun bar (x) (symbolp x))	 (defun foo (x)	   (flet ((bar (y) (integerp y)))	     (typep x '(satisfies bar))))	 (foo 'x)	The correct answer is T, but I bet a lot of implementations return NIL	in compiled code.    Anyone know of an implementation for which this fails?Yes, Symbolics.  You must have missed my query about any implementationsfor which it succeeds!  Any implementation which does source-rewritingto optimize TYPEP has to concern itself with this issue.  (The issue is thesame as for doing INLINEing, but Symbolics fails to use the same mechanism foroptimizations as it does for inlining.)*start*02824 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  6 Jan 89 14:20 PSTFrom: RWK%FUJI.ILA.Dialnet.Symbolics:COM:XeroxSubject: commonlisp typesIn-Reply-to: <881222151736.1.KMP@BOBOLINK.SCRC.Symbolics.COM>To: gls%Think.COM%Riverside.Symbolics:COM:Xerox, jwz%spice.cs.cmu.edu%Riverside.SCRC.Symbolics:COM:Xerox, common-lisp%sail.stanford.edu%Riverside.SCRC.Symbolics:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@FUJI.ILA.Dialnet.Symbolics.COM>Subject: commonlisp typesTo: gls%Think.COM@Riverside.Symbolics.COM, jwz%spice.cs.cmu.edu@Riverside.SCRC.Symbolics.COM, common-lisp%sail.stanford.edu@Riverside.SCRC.Symbolics.COMIn-Reply-To: <881222151736.1.KMP@BOBOLINK.SCRC.Symbolics.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 14:20:08 PSTReceived: from Riverside.SCRC.Symbolics.COM (SCRC-RIVERSIDE.ARPA) by SAIL.Stanford.EDU with TCP; 6 Jan 89  13:46:18 PSTReceived: from F.ILA.Dialnet.Symbolics.COM (FUJI.ILA.Dialnet.Symbolics.COM) by Riverside.SCRC.Symbolics.COM via DIAL with SMTP id 306345; 6 Jan 89 15:57:47 ESTReceived: from CALVARY.ILA.Dialnet.Symbolics.COM by F.ILA.Dialnet.Symbolics.COM via CHAOS with CHAOS-MAIL id 7603; Fri 6-Jan-89 15:33:07 ESTOriginal-Date: Fri, 6 Jan 89 15:33 ESTSupersedes: <19890103102924.8.RWK@F.ILA.Dialnet.Symbolics.COM>Comments: Retransmission of failed mail.Message-ID: <19890106203322.2.RWK@CALVARY.ILA.Dialnet.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 22 Dec 88 15:17 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    Fyi, it turns out this rationale doesn't hold as much water as you'd think.    Consider:     (defun bar (x) (symbolp x))     (defun foo (x)       (flet ((bar (y) (integerp y)))	 (typep x '(satisfies bar))))     (foo 'x)    The correct answer is T, but I bet a lot of implementations return NIL    in compiled code.Like the Symbolics system, Boo, Hiss!In terms of source transformations, this would have to compile the TYPEPas follows:(defun foo (x)  (flet ((bar (y) (integerp y)))    (let ((#:G0002 x))      (macrolet ((bar (a) `(funcall (symbol-function 'bar) ,a)))        (bar #:G0002)))))Which is obviously going to require either a codewalker or a typewalkerto identify either locally defined functions or functions used in thetype expansion to shadow with MACROLET.So I'm curious.  Does any compiler actually get this right?  Really,this is a general problem with any form of source-code rewrites.  TheSymbolics compiler does get this right with inlined functions, but I'llbet it doesn't with some other internal in-lined things that work assource transformations.*start*01863 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  6 Jan 89 21:30 PSTSubject: Re: commonlisp typesIn-Reply-to: Your message of Fri, 06 Jan 89 15:33:00 -0500.             <19890106203322.2.RWK@CALVARY.ILA.DialnetFrom: quiroz%cs.rochester:EDU:XeroxTo: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 21:30:50 PSTReceived: from cayuga.cs.rochester.edu (CS.ROCHESTER.EDU) by SAIL.Stanford.EDU with TCP; 6 Jan 89  21:11:52 PSTReceived: from lesath.cs.rochester.edu by cayuga.cs.rochester.edu (5.59/k) id AA09897; Fri, 6 Jan 89 20:12:20 ESTReceived: from loopback by lesath.cs.rochester.edu (3.2/k) id AA09737; Fri, 6 Jan 89 20:12:14 ESTMessage-Id: <8901070112.AA09737@lesath.cs.rochester.edu>Original-Date: Fri, 06 Jan 89 20:12:09 -0500: So I'm curious.  Does any compiler actually get this right?KCL.  See script at the end of this message.BTW, our mailer didn't like the address    Robert W. Kerns <RWK@FUJI.ILA.Dialnet.Symbolics.COM>on the excuse that FUJI.ILA.Dialnet.Symbolics.COM is an unknown host.CesarKCl (Kyoto Common Lisp)  June 3, 1987--- UofR version of September 9, 1988Loading /u/quiroz/.kclrcLoading /u/quiroz/work/kcl/defsys/defsys.oFinished loading /u/quiroz/work/kcl/defsys/defsys.oFinished loading /u/quiroz/.kclrc>     (defun bar (x) (symbolp x))bar>     (defun foo (x)       (flet ((bar (y) (integerp y)))	 (typep x '(satisfies bar))))foo>     (foo 'x)t>(compile 'bar)End of Pass 1.  End of Pass 2.  OPTIMIZE levels: Safety=0 (No runtime error checking), Space=0, Speed=3bar>(compile 'foo)End of Pass 1.  End of Pass 2.  OPTIMIZE levels: Safety=0 (No runtime error checking), Space=0, Speed=3foo>(foo 'x)t>*start*02778 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  7 Jan 89 01:16 PSTFrom: jonl%lucid:COM:XeroxIn-Reply-to: Robert W. Kerns's message of Fri, 6 Jan 89 15:16 EST <19890106201603.1.RWK@CALVARY.ILA.Dialnet.SymboSubject: commonlisp typesTo: RWK%FUJI.ILA.Dialnet.Symbolics:COM:Xeroxcc: jonl%lucid.com%Riverside.SCRC.Symbolics:COM:Xerox, common-lisp%sail.stanford.edu%Riverside.SCRC.Symbolics:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: RWK@FUJI.ILA.Dialnet.Symbolics.COMCc: jonl%lucid.com@Riverside.SCRC.Symbolics.Com, common-lisp%sail.stanford.edu@Riverside.SCRC.Symbolics.ComIn-Reply-To: Robert W. Kerns's message of Fri, 6 Jan 89 15:16 EST <19890106201603.1.RWK@CALVARY.ILA.Dialnet.Symbolics.COM>Subject: commonlisp typesReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 JAN 89 01:15:50 PSTReceived: from Riverside.SCRC.Symbolics.COM (SCRC-RIVERSIDE.ARPA) by SAIL.Stanford.EDU with TCP; 7 Jan 89  00:54:42 PSTReceived: from LUCID.COM by Riverside.SCRC.Symbolics.COM via INTERNET with SMTP id 306559; 7 Jan 89 03:53:00 ESTReceived: from bhopal ([192.9.200.13]) by heavens-gate id AA08351g; Sat, 7 Jan 89 00:50:24 PSTReceived: by bhopal id AA02943g; Sat, 7 Jan 89 00:52:38 PSTOriginal-Date: Sat, 7 Jan 89 00:52:38 PSTMessage-Id: <8901070852.AA02943@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: [TYPE-SPECIFIER-P] I'd like to encourage you to make YOUR definition     explicit for us, as a starting point.Well, what I can tell you in reasonable terms won't be that helpful. Wesimpy hook in to the part of SUBTYPEP that has to resolve these questions,and "catch" any signals about unrecognized types.  For symbols, thequestion of a recognized type is fairly easy -- there's a list in CLtLof some basic types, and then there's more basic types coming fromDEFSTRUCT, and finally there's "recursion" via DEFTYPE.  Can you thinkof an easier answer for this?re:     Anyone know of an implementation for which this fails?    Yes, Symbolics.  You must have missed my query about any implementations    for which it succeeds!  Any implementation which does source-rewriting    to optimize TYPEP has to concern itself with this issue.  (The issue is the    same as for doing INLINEing, but Symbolics fails to use the same mechanism    for optimizations as it does for inlining.)Lucid succeeds (and one or two others that I tried).  Oddly enough, Lucidalso "fails" to use the same mechanism for compiler optimizers as it doesfor INLINEing -- and it gets the optimizations right, but certain casesof lexical inlining screws wrong.-- JonL --