*start*05853 00024 USaOriginator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  7 Jan 88 00:38From: edsel!jonl%labrea.stanford:EDU:XeroxSubject: TYPEP warp implicationsTo: labrea!common-lisp%sail%labrea.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: labrea!common-lisp%sail@labrea.stanford.eduSubject: TYPEP warp implicationsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 JAN 88 00:39:24 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 6 Jan 88  23:59:22 PSTReceived: by labrea.stanford.edu; Wed, 6 Jan 88 23:59:09 PSTReceived: from bhopal.lucid.com by edsel id AA00715g; Wed, 6 Jan 88 23:18:53 PSTReceived: by bhopal id AA15243g; Wed, 6 Jan 88 23:21:16 PSTOriginal-Date: Wed, 6 Jan 88 23:21:16 PSTMessage-Id: <8801070721.AA15243@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVRecent mail under the subject line of "Types in CL" brought to light aninconsistency in CLtL that may have gone unnoticed by most people.-- The second paragraph of page 11 makes it clear that "data types" are   just sets of objects; subsequent discussion makes it clear that the   second argument to TYPEP (a type specifier) is a name for some such   set, and that there may be several distinct names specifying the same   set (or type).  The first paragraph of section 6.2.1 on page 72 says   that TYPEP is a set membership test, and SUBTYPEP is a subset test.-- The first two paragraphs of section 4.5, on page 45, describe a   permission for what I call "element-type upgrading" on arrays; the    documentation fo ARRAY-ELEMENT-TYPE on page 291 also makes it clear    that a conforming implementation is permitted to "collapse" array   element types into some more limited set of types, providing that   the array returned by make-array is at most an "upgrade".  For example, depending on how primitive arrays are actually implemented,        (make-array <dims> :element-type '(signed-byte 5))and       (make-array <dims> :element-type '(signed-byte 16))might legitimately create exactly the same set of objects.  The onlyconstraint seems to be that that (array (signed-byte 16)) be the mostspecific type *** in that implementation *** which can hold all the objects made by (make-array <dims> :element-type '(signed-byte 5)).In this case, we say that the array element type has been upgraded from(signed-byte 5) to (signed-byte 16), and we imply that there is noparticular special provisions for arrays of element type, say, (signed-byte 8).  [Every vendor's implementation I have looked at does someamount of non-trivial "upgrading" on the element type (signed-byte 5).]By the bulletted paragraphs above, (array (signed-byte 5)) and(array (signed-byte 16)) are in fact names for exactly the sameset of objects.However pages 45 and 46 go at length to specify that these two differentnames for the same set of objects must be treated differently by TYPEPand SUBTYPEP.  This seems to "warp" the utility of TYPEP since it putsit at variance with the fundamental principle: "SUBTYPEP means subsetp".No one I've asked has tried to defend this "warp".  I conjecture that itwas added to CLtL in a mistaken belief that it would promote portability.I say "mistaken" because the source of non-portability is the permissionto upgrade; if two different implementations do any upgrading differently,then the effect will be the same kind of non-portability that resultswhen two different implementations set the boundary between fixnums and bignums differently.  Yet I'm in favor of the permission to upgrade; I would not like to see CL become a language like C where there are a prescribed set of kinds of arraysthat must be implemented (e.g, "int", "long int", "single", "double" etc), and no others can exist.  In short, I would not want to gain portabilityat the expense of limiting the language to the architectural features ofthe hardware on which it was first implemented.I would like to suggest that the flaw be fixed as follows:-- Delete all the documentation that suggests the :element-type argument   to make-array mignt not be a satisfactory element-type in the type   specifier for the kind of array produced;-- Introduce a function UPGRADE-ARRAY-ELEMENT-TYPE, which will tell you   how a particular :element-type argument to make-array will be treated   (so that you don't have to cons up an array to find out).Does anyone have any strong feeling on this dichotomy one way or the other?Have you been affected by variations in the vendors treatement of arrays?-- JonL --P.S. A clarifying note on the definition of "type specifier".  I called it     a "name" in the above message.  This means that it is either a symbol     like FIXNUM, or ARRAY, or one of the permissible list conbinations     of type specifiers like (OR FIXNUM BIGNUM) etc.  [But note that he      Object System proposal may have to permit class-objects themselves to      be considered as type-specifiers because it is possible to create classes     that don't have (proper) symbolic names; however, we can still view     "the object itself" as its own name in the sense that the address of     an object is a hidden name.]  Thus the set of type-specifiers forms     a mathematical language, and the SUBTYPEP relation is generated by some      basic, generating set of relations between these names.  I want to see     this language actually describing the implementation in which it is     running -- that the objects of the implementation are a model for that     language -- rather than seeing it be limited to some theoretical     model which no vendor bothers to implement.*start*03309 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 24 Dec 87 15:13From: barmar%think:COM:XeroxSubject: Re:  Types in CLIn-Reply-to: <8712172057.AA00603@Think.COM>To: "cam-common-lisp%computer-lab.cambridge.ac.uk%NSS.Cs.Ucl.AC.UK":GV:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: cam-common-lisp%computer-lab.cambridge.ac.uk@NSS.Cs.Ucl.AC.UKFrom: Barry Margolin <barmar@think.com>Subject: Re:  Types in CLCc: common-lisp@sail.stanford.eduIn-Reply-To: <8712172057.AA00603@Think.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 DEC 87 15:15:25 PSTReceived: from NSS.CS.UCL.AC.UK by SAIL.STANFORD.EDU with TCP; 24 Dec 87  14:42:30 PSTReceived: from computer-lab.cambridge.ac.uk by NSS.Cs.Ucl.AC.UK            via Janet with NIFTP  id aa05382; 24 Dec 87 16:10 GMTOriginal-Date: Thu, 17 Dec 87 19:04 ESTOriginal-To: Jeff Barnett <jbarnett@com.northrop.nrtc>Message-Id: <871217190451.6.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date:     Thu, 17 Dec 87 12:56:57 PST    From: Jeff Barnett <jbarnett@nrtc.northrop.com>    Your claim that the compiler should inhibit (SETF (AREF A 0) A) is only valid     if A is declared of type T1.  I never said anything about the compiler inhibiting the SETF.  I saidthat it is incorrect to do the SETF.  However, you are correct that Iwas wrong; you didn't show the MAKE-ARRAY form, and I assumed A wascreated with	(setq a (make-array 1 :element-type 't2))				  It may not be.  What you are pointing out is    that there is a problem if one tries to determine the type of an object (or    its type membership status) *after* the object is created.Actually, there is a bug in your original message, in the TYPEP call.The predicate	(TYPEP A 'T1)expands to	(TYPEP A '(ARRAY T2 1))which is equivalent to	(AND (ARRAYP A)	     (EQ (ARRAY-ELEMENT-TYPE A) 'T2)	     (= (ARRAY-RANK A) 1)	     (= (ARRAY-DIMENSION A 0) 1))Note that it never does an AREF, so the question of whether (AREF A 0)is of type T2 never comes up.  When array types are used in TYPEP, theelement type does not refer to the current contents, but to the array'simplementation type.In order to create the type anomaly you describe, you must use theSATISFIES type specifier, e.g.(DEFUN T1P (A)  (AND (ARRAYP A)       (= (ARRAY-RANK A) 1)       (= (ARRAY-DIMENSION A 0) 1)       (TYPEP (AREF A 0) 'T2)))(DEFTYPE T1 () '(SATISFIES T1P))When you do this, (TYPEP A 'T1) is guaranteed to infinitely recurse.Because Lisp's type system permits arbitrary code to be incorporated,the type system is Turing-equivalent, which means that the haltingproblem exists.  Without SATISFIES, though, the problem you describedoesn't exist, because none of the other type specifiers require doing aTYPEP of constituents of the object being tested (actually, I think(TYPEP A '(COMPLEX <type>)) is an abbreviation for	(AND (COMPLEXP A)	     (TYPEP (REALPART A) '<type>)	     (TYPEP (IMAGPART A) '<type>))but no recursion can occur because the parts of a complex number cannotbe complex).                                                barmar*start*02665 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 28 Dec 87 11:09From: barmar%Think:COM:XeroxSubject: Types in CLIn-Reply-to: <8712272115.AA02168@bhopal.lucid.com>To: edsel!jonl%labrea.stanford:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Types in CLTo: Jon L White <edsel!jonl@labrea.stanford.edu>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <8712272115.AA02168@bhopal.lucid.com>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 28 DEC 87 11:04:43 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 28 Dec 87  08:37:59 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Mon, 28 Dec 87 11:37:32 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Mon, 28 Dec 87 11:37:29 ESTOriginal-Date: Mon, 28 Dec 87 11:38 ESTMessage-Id: <871228113827.1.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Sun, 27 Dec 87 13:15:46 PST    From: Jon L White <edsel!jonl@labrea.stanford.edu>    re: 	Actually, there is a bug in your original message, in the TYPEP call.	The predicate		(TYPEP A 'T1)	expands to		(TYPEP A '(ARRAY T2 1))	which is equivalent to		(AND (ARRAYP A)		     (EQ (ARRAY-ELEMENT-TYPE A) 'T2)		     (= (ARRAY-RANK A) 1)		     (= (ARRAY-DIMENSION A 0) 1))    This isn't right, and is probably a good example of the single most common     error when trying to figure out what the array types mean.  Since a CL    implementation of arrays is permitted to "upgrade" the :element-type    argument into something actually supported, and since there is no     requirement to preserve the original :element-type argument, then the    line above		     (EQ (ARRAY-ELEMENT-TYPE A) 'T2)    should be 		     (SUBTYPEP 'T2  (ARRAY-ELEMENT-TYPE A))    Of course, optimizations are possible for specific T2's; but in general    the element-type might have been upgraded to, for example, T.This contradicts an explicit statement to the contrary in CLtL.  On page46, it says:     (ARRAY CHARACTER) is not the set of all arrays that can hold     characters, but rather the set of arrays that are specialized to     hold characters and no other objects.  To test whether an array FOO     can hold a character, one should not use     (TYPEP FOO '(ARRAY CHARACTER))     but rather     (SUBTYPEP 'CHARACTER (ARRAY-ELEMENT-TYPE FOO))I therefore stand by my translation.                                                barmar*start*03204 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 28 Dec 87 11:09From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Types in CLIn-Reply-to: <8712272115.AA02168@bhopal.lucid.com>To: edsel!jonl%labrea.stanford:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Types in CLTo: Jon L White <edsel!jonl@labrea.stanford.edu>cc: common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <8712272115.AA02168@bhopal.lucid.com>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 28 DEC 87 11:04:47 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 28 Dec 87  08:48:19 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 310888; Mon 28-Dec-87 11:24:56 ESTOriginal-Date: Mon, 28 Dec 87 11:24 ESTMessage-ID: <19871228162446.2.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Sun, 27 Dec 87 13:15:46 PST    From: Jon L White <edsel!jonl@labrea.stanford.edu>    re: 	Actually, there is a bug in your original message, in the TYPEP call.	The predicate		(TYPEP A 'T1)	expands to		(TYPEP A '(ARRAY T2 1))	which is equivalent to		(AND (ARRAYP A)		     (EQ (ARRAY-ELEMENT-TYPE A) 'T2)		     (= (ARRAY-RANK A) 1)		     (= (ARRAY-DIMENSION A 0) 1))    This isn't right, and is probably a good example of the single most common     error when trying to figure out what the array types mean.  Since a CL    implementation of arrays is permitted to "upgrade" the :element-type    argument into something actually supported, and since there is no     requirement to preserve the original :element-type argument, then the    line above		     (EQ (ARRAY-ELEMENT-TYPE A) 'T2)    should be 		     (SUBTYPEP 'T2  (ARRAY-ELEMENT-TYPE A))    Of course, optimizations are possible for specific T2's; but in general    the element-type might have been upgraded to, for example, T.Just to keep the record 100% straight, SUBTYPEP isn't right.It's true that MAKE-ARRAY and DECLARE upgrade the element type,but TYPEP does not.CLtL p.46 says the ARRAY type specifier -for- -discrimination- (i.e. when used with the TYPEP function) means arrays specializedto hold precisely the mentioned element type and no other objects,unless the mentioned element type is *, which means all arrays.See also the second to last paragraph on p.45.  This is all a bitstrange, but it's what the book says.  I suspect there are reasonsfor it.  We've been through this a million times on the Common Lispmailing list, and no one, including you and me, can remember it withoutlooking it up in the book each time, so it must be unintuitive.EQ isn't right either.  The function you really want is EQUAL-TYPEP,which doesn't exist in Common Lisp, since two type specifiers cancertainly be equivalent without being EQ, and in fact without being EQUAL.An adequate definition is probably  (defun equal-typep (t1 t2)    (and (subtypep t1 t2) (subtypep t2 t1)))*start*02211 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 28 Dec 87 11:09From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: Barry Margolin's message of Thu, 17 Dec 87 19:04 EST <871217190451.6.BARMAR@OCCAM.THINK.COM>Subject: Types in CLTo: labrea!barmar%think.com%labrea.stanford:EDU:Xeroxcc: labrea!common-lisp%sail%labrea.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: labrea!barmar%think.com@labrea.stanford.eduCc: labrea!common-lisp%sail@labrea.stanford.eduIn-Reply-To: Barry Margolin's message of Thu, 17 Dec 87 19:04 EST <871217190451.6.BARMAR@OCCAM.THINK.COM>Subject: Types in CLReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 28 DEC 87 11:04:58 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 27 Dec 87  14:21:33 PSTReceived: by labrea.stanford.edu; Sun, 27 Dec 87 14:21:39 PSTReceived: from bhopal.lucid.com by edsel id AA20288g; Sun, 27 Dec 87 13:14:07 PSTReceived: by bhopal id AA02168g; Sun, 27 Dec 87 13:15:46 PSTOriginal-Date: Sun, 27 Dec 87 13:15:46 PSTMessage-Id: <8712272115.AA02168@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre:     Actually, there is a bug in your original message, in the TYPEP call.    The predicate	    (TYPEP A 'T1)    expands to	    (TYPEP A '(ARRAY T2 1))    which is equivalent to	    (AND (ARRAYP A)		 (EQ (ARRAY-ELEMENT-TYPE A) 'T2)		 (= (ARRAY-RANK A) 1)		 (= (ARRAY-DIMENSION A 0) 1))This isn't right, and is probably a good example of the single most common error when trying to figure out what the array types mean.  Since a CLimplementation of arrays is permitted to "upgrade" the :element-typeargument into something actually supported, and since there is no requirement to preserve the original :element-type argument, then theline above		 (EQ (ARRAY-ELEMENT-TYPE A) 'T2)should be 		 (SUBTYPEP 'T2  (ARRAY-ELEMENT-TYPE A))Of course, optimizations are possible for specific T2's; but in generalthe element-type might have been upgraded to, for example, T.-- JonL --*start*02006 00024 USaOriginator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  7 Jan 88 08:28From: sandra%orion%cs.utah:EDU:XeroxSubject: the array type mess....To: edsel!jonl%labrea.stanford:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Subject: the array type mess....To: edsel!jonl@labrea.stanford.eduCc: common-lisp@sail.stanford.eduReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 JAN 88 08:29:08 PSTReceived: from CS.UTAH.EDU by SAIL.STANFORD.EDU with TCP; 7 Jan 88  07:58:55 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA19342; Thu, 7 Jan 88 08:58:56 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA29760; Thu, 7 Jan 88 08:58:52 MSTOriginal-Date: Thu, 7 Jan 88 08:58:52 MSTMessage-Id: <8801071558.AA29760@orion.utah.edu>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI believe that an implementation is not allowed to upgrade all array typesarbitrarily; at least, on p. 34, it says that the types simple-vector,simple-string, and simple-bit-vector are disjoint.I'm also unhappy with the current situation, but my solution would beto do away with the array upgrading entirely.  In other words, I'd liketo see (typep (make-array n :element-type foo) foo) be true in allimplementations, for all types foo.  If an implementation does not havea specialized representation for (array (signed-byte 5)), it couldstill internally upgrade it to some other convenient representation,but it should keep the original element-type around (stored in the array header) so type discrimination will still work.Also, the last type I asked the question, there seemed to be generalagreement that SUBTYPEP should reflect the actual type hierarchy in theimplementation.  In some implementations, for example, FLOAT might bea subtype of SHORT-FLOAT.-Sandra-------*start*02019 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Jan 88 20:53From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: Sandra J Loosemore's message of Thu, 7 Jan 88 08:58:52 MST <8801071558.AA29760@orion.utah.edu>Subject: the array type mess....To: sandra%orion%cs.utah:EDU:Xeroxcc: labrea!common-lisp%sail%labrea.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: sandra%orion@cs.utah.eduCc: labrea!common-lisp%sail@labrea.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Thu, 7 Jan 88 08:58:52 MST <8801071558.AA29760@orion.utah.edu>Subject: the array type mess....Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 JAN 88 20:53:53 PSTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 8 Jan 88  20:29:22 PSTReceived: by labrea.stanford.edu; Fri, 8 Jan 88 20:29:17 PSTReceived: from bhopal.lucid.com by edsel id AA10474g; Fri, 8 Jan 88 19:27:32 PSTReceived: by bhopal id AA23963g; Fri, 8 Jan 88 19:30:02 PSTOriginal-Date: Fri, 8 Jan 88 19:30:02 PSTMessage-Id: <8801090330.AA23963@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: I believe that an implementation is not allowed to upgrade all array types    arbitrarily;  . . .Quite right -- since strings and bit-arrays are treated specially in so manycontexts, I frequently forget that are also subtypes of arrays.re:                                             In other words, I'd like    to see (typep (make-array n :element-type foo) foo) be true in all    implementations, for all types foo.  I'm sure you meant to say:	(typep (make-array n :element-type '<foo>) 	       '(array <foo>))right?Yes, upgrading isn't the only way to optimize the important cases; althoughI'd think a vendor would be under some compulsion to reveal just whichelement types were "preferable".-- JonL --*start*01739 00024 USaOriginator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Jan 88 20:54From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: "Larry_Masinter.PARC"@Xerox.COM's message of 8 Jan 88 14:56:16 PST (Friday) <880108-145707-2273@XeroSubject: TYPEP warp implicationsTo: labrea!Masinter.PA%Xerox.COM%labrea.stanford:EDU:Xeroxcc: labrea!common-lisp%sail%labrea.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: labrea!Masinter.PA%Xerox.COM@labrea.stanford.eduCc: labrea!common-lisp%sail@labrea.stanford.eduIn-Reply-To: "Larry_Masinter.PARC"@Xerox.COM's message of 8 Jan 88 14:56:16 PST (Friday) <880108-145707-2273@Xerox>Subject: TYPEP warp implicationsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 JAN 88 20:54:12 PSTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 8 Jan 88  20:29:00 PSTReceived: by labrea.stanford.edu; Fri, 8 Jan 88 20:28:54 PSTReceived: from bhopal.lucid.com by edsel id AA10453g; Fri, 8 Jan 88 19:17:35 PSTReceived: by bhopal id AA23932g; Fri, 8 Jan 88 19:20:07 PSTOriginal-Date: Fri, 8 Jan 88 19:20:07 PSTMessage-Id: <8801090320.AA23932@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: Wouldn't it be simpler, promote portability, and not cost very much  to     require that arrays remember the element type they were created with?Well, not necessarily the :element-type arguemnt per se, but a canonicalrepresentation thereof.   What you are suggesting is that we toss outelement-type "upgrading"; I could contemplate that.  I wonder how others feel?-- JonL --*start*01117 00024 US Return-Path: <edsel!jonl@labrea.stanford.edu>Received: from labrea.stanford.edu by Xerox.COM ; 11 JAN 88 14:02:23 PSTReceived: by labrea.stanford.edu; Fri, 8 Jan 88 20:29:11 PSTReceived: from bhopal.lucid.com by edsel id AA10453g; Fri, 8 Jan 88 19:17:35 PSTReceived: by bhopal id AA23932g; Fri, 8 Jan 88 19:20:07 PSTDate: Fri, 8 Jan 88 19:20:07 PSTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8801090320.AA23932@bhopal.lucid.com>To: labrea!Masinter.PA%Xerox.COM@labrea.stanford.eduCc: labrea!common-lisp%sail@labrea.stanford.eduIn-Reply-To: "Larry_Masinter.PARC"@Xerox.COM's message of 8 Jan 88 14:56:16 PST (Friday) <880108-145707-2273@Xerox>Subject: TYPEP warp implicationsre: Wouldn't it be simpler, promote portability, and not cost very much  to     require that arrays remember the element type they were created with?Well, not necessarily the :element-type arguemnt per se, but a canonicalrepresentation thereof.   What you are suggesting is that we toss outelement-type "upgrading"; I could contemplate that.  I wonder how others feel?-- JonL --*start*01461 00024 US Date: 11 Jan 88 14:02From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: "Larry_Masinter.PARC"@Xerox.COM's message of 8 Jan 88 14:56:16 PST (Friday) <880108-145707-2273@XeroSubject: TYPEP warp implicationsTo: Larry Masinter:PARC:Xeroxcc: common-lisp.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: "Larry Masinter".PARCCc: common-lisp.stanford.EDUIn-Reply-To: "Larry_Masinter.PARC"@Xerox.COM's message of 8 Jan 88 14:56:16 PST (Friday) <880108-145707-2273@Xerox>Subject: TYPEP warp implicationsReturn-Path: <edsel!jonl@labrea.stanford.edu>Received: from labrea.stanford.edu by Xerox.COM ; 11 JAN 88 14:02:15 PSTReceived: by labrea.stanford.edu; Fri, 8 Jan 88 20:28:37 PSTReceived: from bhopal.lucid.com by edsel id AA10442g; Fri, 8 Jan 88 19:16:33 PSTReceived: by bhopal id AA23927g; Fri, 8 Jan 88 19:19:04 PSTOriginal-Date: Fri, 8 Jan 88 19:19:04 PSTMessage-Id: <8801090319.AA23927@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: Wouldn't it be simpler, promote portability, and not cost very much  to     require that arrays remember the element type they were created with?Well, not necessarily the :element-type arguemnt per se, but a canonicalrepresentation thereof.   What you are suggesting is that we toss outelement-type "upgrading"; I could contemplate that.  I wonder how others feel?-- JonL --*start*05842 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  9 Jan 88 13:30From: Ram%C.CS.CMU:EDU:XeroxSubject: the array type mess....To: edsel!jonl%LABREA.STANFORD:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:Xerox, sandra%orion%CS.UTAH:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Ram@C.CS.CMU.EDUTo: Jon L White <edsel!jonl@LABREA.STANFORD.EDU>Cc: common-lisp@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUSubject: the array type mess....Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 JAN 88 13:30:32 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 9 Jan 88  12:54:58 PSTReceived: ID <RAM@C.CS.CMU.EDU.#Internet>; Sat 9 Jan 88 15:54:18-ESTOriginal-Date: Sat, 9 Jan 88 15:54 ESTMessage-ID: <RAM.12365298662.BABYL@>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVWell, I certainly agree that there is a mess here, but it seems to methat an obvious solution is being overlooked.  It is possible to haveboth implementation-dependent array specialization and the identity:  (typep (make-array ... :element-type <type>) '(array ... <type>)) => TArray type specialization is just one instance of the implementationprocess of mapping user specifications into the implementation.  Inorder to understand the Common Lisp type system, you have to startthinking about two different conceptions of type:Definitional type    This is the type system as seen by the user of the implementation.    It is a collection of promises made by the language definition to    the user.Implementation type    This is an abstraction of the implementation chosen for an object.    The implementation type of an object is basically a name for the    representation chosen for that object, and often had more to do    with the details of the implementation of the object than with the    user visible meaning of the object.  Consider the FIXNUM type or    the type that has been hypothesized in previous discussions    POWER-OF-TWO-BIGNUM.  Implementation types are usually of little    direct concern to the user: his concern is to somehow use the    defined language facilities in a way that permits efficient    representations.Traditionally, these two conceptions of type have been used largelyinterchangeably in Lisp.  I think that there are two main reasons forthis: -- Before Common Lisp, Lisp systems didn't have type systems elaborate    enough to say anything very interesting about the types of objects.    In these simple systems, it was easier to maintain an approximate    equivalence between the definitional and implementation type. -- Before Common Lisp, the distinction between the implementation and    the definition was generally only casually made.  This was    acceptable, since these Lisp dialects had only one implementation.The problem that we are seeing with arrays is that the relationshipbetween definitional and implementation types is under-defined,causing problems in functions that straddle thedefinition=>implementation boundary.  There are two obvious solutions,one of which has already been proposed: -- Make the mapping more direct.  Eliminating "array element type    upgrading" would be an instance of this. -- Make the mapping explicitly ill-defined in a more useful way.I think we need to do the latter because the former won't work.  I don'tsee how to eliminate "array element type upgrading" without creatingmore problems we solve.  Even if this can be done, the ill-definednature of the to-implementation mapping will crop up again and again.We already had a long discussion about TYPE-OF, ARRAY-ELEMENT-TYPE andSUBTYPEP.  This discussion was prompted by what superficially appearedto be compile questions about TYPE-OF.The main reason that the problem is so blatant with arrays is that anarray is currently the only way that Common Lisp lets the user get hishands on a specializable cell as something approaching a first-classobject.  I think that array element types should treated in much thesame way as the primary other kind of specializable cell: variables.It is widely accepted that a Common Lisp compiler is free to implement avariable however it damn well pleases as long as it preserves thelanguage semantics during normal execution.  When compilers start usingnon-standard representations such as "unboxed numbers" and playing gameslike introducing spurious copies during register allocation, thenextra-linguistic environment features such as debuggers can detect thefunny business, but this is of little concern to the normal programmer.With arrays, it is somewhat more awkward to play free and loose withrepresentations, since the user has been given operations (such asARRAY-ELEMENT-TYPE) that manipulate the implementation type of theobject in terms of definitional types.  The user has been given enoughrope to hang himself, mainly because array types were being thought ofmore in terms of implementation types than definitional types.My conclusion is that it isn't array types that are wrong, it is theunderstanding of the meaning of TYPEP that is wrong.  TYPEP should bethought of as a query:     Could this value be the implementation of an object defined by the    language to have this type?and not:    Is this the implementation type of this object?The first definition is the only one that works in Common Lisp, sincethe Common Lisp definition is implementation-independent.  Under thisinterpretation, it is obvious that the TYPEP/MAKE-ARRAY identity holds.In terms of the TYPEP implementation, this means that TYPEP willautomatically do the to-implementation mapping on the type specifierbefore comparing it to the implementation type.  Rob*start*01102 00024 US Return-Path: <edsel!jonl@labrea.Stanford.EDU>Received: from labrea.Stanford.EDU by Xerox.COM ; 12 JAN 88 21:18:16 PSTReceived: by labrea.Stanford.EDU; Tue, 12 Jan 88 21:17:57 PSTReceived: from bhopal.lucid.com by edsel id AA27371g; Tue, 12 Jan 88 21:12:40 PSTReceived: by bhopal id AA15482g; Tue, 12 Jan 88 21:15:23 PSTDate: Tue, 12 Jan 88 21:15:23 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8801130515.AA15482@bhopal.lucid.com>To: labrea!masinter.pa%xerox.com@labrea.Stanford.EDUIn-Reply-To: "Larry_Masinter.PARC"@Xerox.COM's message of 10 Jan 88 17:21:32 PST (Sunday) <880110-172237-348@Xerox>Subject: TYPEP warp implicationsre: It wouldn't be so much tossing out upgrading as it is making it less visible.There's no middle ground.  Either there is some array such that array-element-type called on it is not equal-type-p (in Moon's sense) to the :element-type argument, or there is no such array.Maybe you're confusing the equal-type-p question with "remembering exactlythe type specifier the user passed to make-array"?-- JonL --*start*03778 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 MAR 88 13:19:47 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 1 Mar 88  13:16:30 PSTReceived: by labrea.Stanford.EDU; Tue, 1 Mar 88 12:38:16 PSTReceived: from bhopal.lucid.com by edsel id AA06523g; Tue, 1 Mar 88 13:03:03 PSTReceived: by bhopal id AA05817g; Tue, 1 Mar 88 13:09:10 PSTDate: Tue, 1 Mar 88 13:09:10 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8803012109.AA05817@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.edu, vanroggen%aitg.decnet@hudson.dec.com, Ram@c.cs.cmu.eduIn-Reply-To: David A. Moon's message of Tue, 1 Mar 88 13:07 EST <19880301180711.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: UPGRADE-ARRAY-ELEMENT-TYPE: a sloution for the array TYPEP problem?re: I don't know why the declaration vs discrimination thing was done.      . . .     Offhand getting rid of this distinction into two kinds of types seems    like a good idea.  However, I'm a bit leery of changing things in the    language when I don't understand why they are there.  . . . I share your queasiness here.  My first impluse is to ask for a function(which would be "implementation revealing") named UPGRADE-ARRAY-ELEMENT-TYPEwhose purpose would be to tell you what the canonical representation for atype name is (when used as an :element-type specifier).   E.g., suppose:    (setq a (make-array size :element-type 'foo)    (setq real-element-type (upgrade-array-element-type 'foo)) then the following two specifiers would be type-equivalent:    `(array foo)     `(array ,real-element-type)even if "'foo" and "real-element-type" be not type-equivalent.  Furthermore,    (typep (aref a n) real-element-type)is always true, even though in the face of non-trivial upgrading,   (typep (aref a n) 'foo)could be false.I would consider UPGRADE-ARRAY-ELEMENT-TYPE in the same genre of featuresas MOST-POSITIVE-FIXNUM.   Programmers would inevitably choose to use"real-element-type" rather than "'foo", and ocasionally find that theircode wasn't so trivially portable to a system that had a fundamentallydifferent kind of upgrading.But if "upgrading" is to remain in CL, I don't see how we can avoidopening it up a bit for inspection.My second impluse is to toss out upgrading altogether, and require every array to remember the type (or, a canonical name therefor) by which it was created.  The reason this is second, rather than first, on my list is that to make types absolutely portable this way is a very pyrrhic success.Sure, your program will port to the Y machine -- it will just run two ordersof magnitude slower [because you started out on, say, a Multics machine with (MOD 512) arrays optimized, and ported to an implementation for an engineering workstation that prefers (UNSIGNED-BYTE 8) arrays ...].Finally, as I've said before, I don't think it's an acceptable solution for Lisp to take the same route as C (and others) to achieve portability.The kinds of array types in such languages are limited to a small (albeitvery useful) set that seems inspired by one particular hardware architecture.-- JonL --P.S. Of course UPGRADE-ARRAY-ELEMENT-TYPE can currently be implemented     in a "consy" way doing something like:         (array-element-type (make-array 0 :element-type 'foo))     But the presence of a "first class" function UPGRADE-ARRAY-ELEMENT-TYPE      would be more for the purpose of encouraging cognizance of these     problems than for avoiding the consing.  Implicitly, such a function     lies underneath any implementation of MAKE-ARRAY already.*start*04286 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 13:54From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: the array type mess....In-Reply-to: <RAM.12365298662.BABYL@>To: Ram%C.CS.CMU:EDU:Xeroxcc: edsel!jonl%LABREA.STANFORD:EDU:Xerox, common-lisp%SAIL.STANFORD:EDU:Xerox, sandra%orion%CS.UTAH:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: the array type mess....To: Ram@C.CS.CMU.EDUcc: Jon L White <edsel!jonl@LABREA.STANFORD.EDU>, common-lisp@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUIn-Reply-To: <RAM.12365298662.BABYL@>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 13:53:53 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Mar 88  13:04:43 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 361275; Fri 11-Mar-88 16:02:53 ESTOriginal-Date: Fri, 11 Mar 88 16:02 ESTMessage-ID: <19880311210247.6.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI agree with your points about definitional versus implementation types.Is it a correct summary of your comments that you want the distinction(CLtL p.45) between declaration and discrimination to be eliminated,with TYPEP being changed to treat array type specifiers in precisely theway that CLtL calls "for declaration"?To say the same thing in Lisp:(TYPEP array '(ARRAY type *))is currently defined to be equivalent to:(AND (TYPEP array '(ARRAY * *))     (SUBTYPEP (ARRAY-ELEMENT-TYPE array) 'type)     (SUBTYPEP 'type (ARRAY-ELEMENT-TYPE array)))I don't think you're proposing to make it equivalent to:(AND (TYPEP array '(ARRAY * *))     (SUBTYPEP 'type (ARRAY-ELEMENT-TYPE array)))but rather to make it equivalent to:(LET ((TYPE1 (IMPLEMENTATION-DEPENDENT-ARRAY-ELEMENT-TYPE 'type)))  (AND (TYPEP array '(ARRAY * *))       (SUBTYPEP (ARRAY-ELEMENT-TYPE array) TYPE1)       (SUBTYPEP TYPE1 (ARRAY-ELEMENT-TYPE array))))where an inefficient but portable definition is:(DEFUN IMPLEMENTATION-DEPENDENT-ARRAY-ELEMENT-TYPE (TYPE)  (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE))Is this accurate?Let's look at the various things (TYPEP array '(ARRAY TYPE *)) => Tmight mean, and what they mean with that proposal:(TYPEP x TYPE) means x can safely be stored into the array:		yes(TYPEP x TYPE) is true for all current elements of the array:		no(TYPEP x TYPE) is true for all future elements of the array:		no(NOT (TYPEP x TYPE)) means x cannot be safely stored into the array:	nowith CLtL's current definition of TYPEP:(TYPEP x TYPE) means x can safely be stored into the array:		yes(TYPEP x TYPE) is true for all current elements of the array:		yes(TYPEP x TYPE) is true for all future elements of the array:		yes(NOT (TYPEP x TYPE)) means x cannot be safely stored into the array:	yesSo what we're saying is that for the latter two tests you must useARRAY-ELEMENT-TYPE, and for the second test you must look at theactual contents of the array.  That's probably okay, especiallywhen one considers that in CLtL (TYPEP array '(ARRAY TYPE *)) veryrarely returns T, and for most values of TYPE it is implementationdependent.(ARRAY T) remains a proper subset of (ARRAY *), and (STRING size) remainsan abbreviation for (ARRAY STRING-CHAR (size)), for the simple reasonthat CLtL requires (IMPLEMENTATION-DEPENDENT-ARRAY-ELEMENT-TYPE 'STRING-CHAR)=> STRING-CHAR (or a type specifier equivalent to STRING-CHAR).Should the IMPLEMENTATION-DEPENDENT-ARRAY-ELEMENT-TYPE function I havepostulated as hidden inside TYPEP be made available as a standard function?An interesting comment on all this is that we are implicitly assumingthat an implementation's spectrum of specialized array types is independentof the size, number of dimensions, indirectness, or adjustability of thearray.  This seems unlikely to be true of all implementations.  I don'tknow how to fix this deficiency.Someone should write this up in Cleanup form and thus give us alla chance to think about it more deeply.*start*04450 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 21:00From: edsel!jonl%labrea.Stanford:EDU:XeroxIn-Reply-to: David A. Moon's message of Fri, 11 Mar 88 16:02 EST <19880311210247.6.MOON@EUPHRATES.SCRC.Symbolics.Subject: the array type mess....To: Moon%stony-brook.scrc.symbolics:COM:Xeroxcc: Ram%c.cs.cmu:EDU:Xerox, common-lisp%sail.stanford:EDU:Xerox, sandra%orion%cs.utah:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>To: Moon@stony-brook.scrc.symbolics.comCc: Ram@c.cs.cmu.edu, common-lisp@sail.stanford.edu, sandra%orion@cs.utah.eduIn-Reply-To: David A. Moon's message of Fri, 11 Mar 88 16:02 EST <19880311210247.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: the array type mess....Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 21:00:47 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 11 Mar 88  20:22:24 PSTReceived: by labrea.Stanford.EDU; Fri, 11 Mar 88 20:23:06 PSTReceived: from bhopal.lucid.com by edsel id AA02102g; Fri, 11 Mar 88 20:03:14 PSTReceived: by bhopal id AA13617g; Fri, 11 Mar 88 20:10:04 PSTOriginal-Date: Fri, 11 Mar 88 20:10:04 PSTMessage-Id: <8803120410.AA13617@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: To say the same thing in Lisp:    . . .     (DEFUN IMPLEMENTATION-DEPENDENT-ARRAY-ELEMENT-TYPE (TYPE)      (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE))    . . .     Should the IMPLEMENTATION-DEPENDENT-ARRAY-ELEMENT-TYPE function I have    postulated as hidden inside TYPEP be made available as a standard function?Your summary here is essentially the same as the proposal I sent to CL-CLEANUP on March 1, except I named it UPGRADE-ARRAY-ELEMENT-TYPEto suggest that a possibly-non-trival super-type would be returned. Also, I think the functionality underlying UPGRADE-ARRAY-ELEMENT-TYPE is already in everyone's arrays implementation, regardless of how they handle the TYPEP mess.  For those not on the cl-cleanup list, I'veexcerpted the relevant message below.    Date: Tue, 1 Mar 88 13:09:10 PST    From: Jon L White <edsel!jonl@labrea.Stanford.EDU>    To: Moon@stony-brook.scrc.symbolics.com    Cc: cl-cleanup@sail.stanford.edu, vanroggen%aitg.decnet@hudson.dec.com,	    Ram@c.cs.cmu.edu    Subject: UPGRADE-ARRAY-ELEMENT-TYPE: a sloution for the array TYPEP problem    . . .   a function (which    would be "implementation revealing") named UPGRADE-ARRAY-ELEMENT-TYPE    whose purpose would be to tell you what the canonical representation for a    type name is (when used as an :element-type specifier).      . . .     [why not toss out "upgrading" altogether? because ...]     to make types absolutely portable this way is a very pyrrhic success.    Sure, your program will port to the Y machine -- it will just run two     orders of magnitude slower [because you started out on, say, a Multics     machine with (MOD 512) arrays optimized, and ported to an implementation     for an engineering workstation that prefers (UNSIGNED-BYTE 8) arrays ...].    Finally, as I've said before, I don't think it's an acceptable solution     for Lisp to take the same route as C (and others) to achieve portability.    The kinds of array types in such languages are limited to a small (albeit    very useful) set that seems inspired by one particular hardware     architecture.    -- JonL --    P.S. Of course UPGRADE-ARRAY-ELEMENT-TYPE can currently be implemented	in a "consy" way doing something like:	    (array-element-type (make-array 0 :element-type 'foo))	But the presence of a "first class" function UPGRADE-ARRAY-ELEMENT-TYPE	would be more for the purpose of encouraging cognizance of these	problems than for avoiding the consing.  Implicitly, such a function	lies underneath any implementation of MAKE-ARRAY already.    Date: Tue, 1 Mar 88 14:05:25 PST    From: Jon L White <edsel!jonl@labrea.Stanford.EDU>    To: Ram@c.cs.cmu.edu    Cc: cl-cleanup@sail.stanford.edu, Moon@scrc-stony-brook.arpa,	    vanroggen%aitg.decnet@hudson.dec.com    Subject: function-type-rest-list-element (really array types)    ...    This may be another way of trying to say that	    `(ARRAY FOO)    is type equivalent to	    `(ARRAY ,(upgrade array-element-type 'foo))-- JonL --*start*00816 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 MAR 88 00:09:33 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Mar 88  00:07:20 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 14 MAR 88 00:08:03 PSTDate: 14 Mar 88 00:07 PSTFrom: Masinter.paSubject: Re: the array type mess....In-reply-to: variousTo: cl-cleanup@Sail.stanford.eduMessage-ID: <880314-000803-1132@Xerox>This issue is now called "ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS", i.e., thesemantics of element types in ARRAY type descriptors.It is listed as "needs volunteer". I think we understand the problem sufficiently to attempt a writeup, and we'veheard several different proposals, discarded some but not all.*start*01833 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAY 88 15:26:34 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 23 May 88  15:24:58 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA08740; Mon, 23 May 88 18:23:43 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA13364; Mon, 23 May 88 18:26:48 EDTMessage-Id: <8805232226.AA13364@mist.UUCP>To: Jon L White <edsel!jonl%labrea.stanford.edu@multimax.ARPA>Cc: cl-cleanup%sail.stanford.edu@multimax.ARPASubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS In-Reply-To: Your message of Fri, 13 May 88 02:18:34 -0700.             <8805130918.AA25649@bhopal.lucid.com> Date: Mon, 23 May 88 18:26:41 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>Either I oppose both options or an additional proposal is needed.  Theproblem is that I want the following code to "work".(DEFVAR MY-ARRAY (MAKE-ARRAY 20 :ELEMENT-TYPE '(SIGNED-BYTE 5)));;; Upgrade the storage of the above any way you want...(LET ((MY-ARRAY MY-ARRAY))  (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5)) MY-ARRAY))  (SETF (AREF MY-ARRAY 10) 127))    ; This is an error.  In fact it                                    ; signals an error with the right				    ; optimization flags.The SETF obviously conflicts with the local declaration and there isno reason that even a fairly dumb compiler can't give an error withoutreference to the type information that is associated with the globaldefinition of MY-ARRAY.I don't think that this is covered by either "for declaration" or "fordiscrimination" of the array.  It is a local declaration coveringreferences to elements of the array; unfortunately our currentdeclaration terminology doesn't handle this distinction.*start*17780 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 MAY 88 02:38:52 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 13 May 88  02:36:31 PDTReceived: by labrea.stanford.edu; Fri, 13 May 88 02:23:56 PDTReceived: from bhopal.lucid.com by edsel id AA11362g; Fri, 13 May 88 02:15:28 PDTReceived: by bhopal id AA25649g; Fri, 13 May 88 02:18:34 PDTDate: Fri, 13 May 88 02:18:34 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805130918.AA25649@bhopal.lucid.com>To: cl-cleanup@sail.stanford.eduSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSIssue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45               TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72               ARRAY-ELEMENT-TYPE, CLtL p. 291Category:      CHANGEEdit history:  Version 1, 13-May-88, JonLProblem description:The distinction between type-specifiers "for declaration" and "fordiscrimination" is made only for array type specifiers -- those that aresubtypes of ARRAY.  Discussion on the Common Lisp electronic mailing list in late 1987 and January 1988 shows that many people are confused by this one-of-a-kind situation.  This may be one of the more insidious flawsin the current CL design.A consequence of this "flaw" is that a variable declared to be of type 		<certain-type>and all of whose assigned objects are created in accord with that type,still may have *none* of its values ever satisfied by the TYPEP predicate with that type-specifier.  One type-specifier with this property in most implementations of CL is  <certain-type>  =  (ARRAY (SIGNED-BYTE 5)).An array created with this type specifier will, depending on the vendor,either be of typep (ARRAY (SIGNED-BYTE 8)) or (ARRAY T); but (almost) never of typep (ARRAY (SIGNED-BYTE 5)).It would be much simpler if the real source of the problem that led to this split up could be resolved.  Two proposals will be offered, each rejecting this odd distinction, but in different ways.  Because thereare two proposals, some of the common discussion has been moved upinto the problem description part.No one seems to remember just exactly why this "warp" was put into CommonLisp in the first place; possibly it was added in a mistaken belief that it would promote portability. ["Mistaken", because the source of non-portability is the permission to upgrade; if two different implementationsdo any upgrading differently, then the effect will be the same kind of non-portability that results when two different implementations set the boundary between fixnums and bignums differently.]A common feeling among Common Lisp users is that the set of type-specifiersforms a mathematical language, and the SUBTYPEP relation is generated by some basic, generating set of relations between these names.  People want to seethis language actually describing the implementation in which it is running -- that the objects of the implementation are a model for that language -- rather than seeing it be limited to some theoretical model which no vendor bothers to implement.   Hence, typep and subtypep should be changed toreflect what kinds of arrays get built; alternatively, make-array shouldbe changed to exhibit the distinctions that typep makes.One possibility for unification arises from focusing on type specifiers as names for collections of objects, and on SUBTYPEP as a kind of "subsetp" for collections of objects.  -- The second paragraph of page 11 makes it clear that "data types" are     just sets of objects; subsequent discussion makes it clear that the     second argument to TYPEP (a type specifier) is a name for some such     set, and that there may be several distinct names specifying the same     set (or type).  The first paragraph of section 6.2.1 on page 72 says     that TYPEP is a set membership test, and SUBTYPEP is a subset test.  -- The first two paragraphs of section 4.5, on page 45, describe a     permission for what may be called "element-type upgrading" on arrays;      the  documentation for ARRAY-ELEMENT-TYPE on page 291 also makes it      clear that a conforming implementation is permitted to "collapse"      array element types into some more limited set of types, providing      that the array returned by make-array is at most an "upgrade".  The     array types STRING and BIT-ARRAY are excluded from upgrading.For example, depending on how primitive arrays are actually implemented,        (make-array <dims> :element-type '(signed-byte 5))and       (make-array <dims> :element-type '(signed-byte 8))might legitimately create arrays specialized to hold exactly the same set ofobjects.  The only constraint seems to be that that (array (signed-byte 8))be the most specific type  *** in that implementation *** which can holdall the arrays made by (make-array <dims> :element-type '(signed-byte 5) ...).In this case, we say that the array element type has been upgraded from(signed-byte 5) to (signed-byte 8), and we imply that there is no particular special provisions for arrays of element type, say, (signed-byte 6).By the bulletted paragraphs above, (array (signed-byte 5)) and(array (signed-byte 8)) are in fact names for exactly the sameset of objects.However pages 45 and 46 go at length to specify that these two differentnames for the same set of objects must be treated differently by TYPEPand SUBTYPEP.  This seems to "warp" the utility of TYPEP since it putsit at variance with the fundamental principle: "SUBTYPEP means subsetp".To get a sense of how the community is "confused", see the arpanetmailing list for Common Lisp, in a series of exchanges started onThu, 17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com>under the subject line of "Types in CL".  Also see the exchange started Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu>under the subject line of "TYPEP warp implications"[Notation: because of the inability to show meta- or linguistic variablesin a different typeface, some code examples will use a backquote format;a form like ",x" will simply mean "substitute the value of x here".and a form like `(...) will simply mean "evaluate this first, doingthe indicated comma substitutions."  Also, the term "type-equivalent"will be used to denote two types which are each subtypes of the other;this relation establishes a partition on the set of type-specifiersinto disjoint sets, and members of the same equivalence class are simply different names for the same type.]One interesting krinkle in this issue is the question as to whether two non-EQ but type-equivalent type-specifiers ,aet-x and ,aet-y could give rise to different array types.  Remember that `(array ,aet-x) and `(array ,aet-y) are type-equivalent only if ,aet-x is type-equivalent to ,aet-y.  But this doesn't say anything about the reverse implication: does ,aet-x being type-equivalent to ,aet-y necessarily imply that `(array ,aet-x) is type-equivalent to `(array ,aet-y)?  For example, consider SHORT-FLOAT and SINGLE-FLOAT in an implementation where these are type-equivalent (because only one internal float type is provided forLisp objects -- see CLtL section 2.1.3).  One may desire to implement (ARRAY SHORT-FLOAT) and (ARRAY SINGLE-FLOAT) differently; say, for example that the former is packed into 16-bit half-words, whereas the latter is packed into 32-bit words.  But for either kind of packing, the result of AREF is an ordinary "single-float"; the whole point is merely to specify a packing technique for "packed float" arrays.Test case: Let aet-x and aet-y be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-arraywill return an object of the same primitive type; let this primitivetype be described by `(array ,aet-y).  This will be an implementation dependent search, but in every implementation that the present writer (JonL) has tested, there will be some such types; often, (signed-byte 5)and (signed-byte 8) will work.  Thus in each case, it should be true that:  (array-element-type (make-array 0 :element-type ',aet-x))  ==> ,aet-y  (array-element-type (make-array 0 :element-type ',aet-y))  ==> ,aet-yand if such a function exists, then:  (upgrade-array-element-type ',aet-x)  ==> ,aet-y  (upgrade-array-element-type ',aet-y)  ==> ,aet-yNow for a first set of tests; to eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   `(typep (make-array 0 :element-type ',aet-x)           '(array ,aet-x))   `(typep (make-array 0 :element-type 'aet-y)           '(array ,aet-y))Since `(array ,aet-x) and `(array ,aet-y) are different names for exactlythe same set of objects -- those arrays specialized to hold elements oftype aet-y -- then if the correlation between type-names and sets of objectsis being observed, these names should be type-equivalent.  That means thatboth of the following tests should be true:  [B]   `(subtypep '(array ,aet-x) '(array ,aet-y))   `(subtypep '(array ,aet-y) '(array ,aet-x))Additionally, to show that un-equivalent type-specifiers that are upgradedto the same "element type" should be equivalent as element-type specifiers,then both the following type tests should be true:  [C]   `(typep (make-array 0 :element-type ',aet-y)           '(array ,aet-x))   `(typep (make-array 0 :element-type ',aet-x)           '(array ,aet-y))Proposal (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING)-- Delete all the documentation that suggests the :element-type argument   to make-array might not be a satisfactory element-type in the type   specifier for the kind of array produced.  Particularly, delete the   documentation that permits a difference between type-specifiers "for   declaration" and "for discrimination;  primarily this means parts   of the discussion in CLtL, section 4.5, p. 45 and 46.  Include a   statement that `(array ,aet) is a suitable type-specifier for the   array made by `(make-array <dims> :element-type ',aet ...).-- Change the documentation of ARRAY-ELEMENT-TYPE, CLtL p. 291 by deleting   the sentence begining "This set may be larger than the set requested   when the array was created; for example . . ."-- Introduce a function UPGRADE-ARRAY-ELEMENT-TYPE, which will reveal how   a particular :element-type argument to make-array will be treated.   Semantically, this would be equivalent to:     (defun upgrade-array-element-type (element-type)       (array-element-type (make-array 0 :element-type element-type)))   but it wouldn't have to cons up the 0-element array first.  Also,   the presence of this name, as a documented function in the language,    would serve notice that "upgrading" is an important aspect of any real   implementation of CL arrays.-- Change TYPEP (and SUBTYPEP) so that `(typep x '(array ,aet)) is true   if and only if `(typep x '(array ,(upgrade-array-element-type aet)))   is true.Rationale:This proposal legitimizes current practice, and removes the obscure and un-useful distinction  between type-specifiers "for declaration" and "fordiscrimination".  Current Practice:Every vendor's implementation that the present writer has queried does some amount of non-trivial "upgrading" [generally, using (signed-byte 5)as an :element-type argument to make-array will show it]; this includes LUCID, VAXLISP, SYMBOLICS, FRANZ, and XEROX. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it [it may be that these two vendors have implemented a partial solution for subtypep, with a view to future extensions.]Adoption Cost:Typically, a small amount of work will be required in every vendor'simplementation of TYPEP and SUBTYPEP; some vendors may have alreadydone the work, but not fully integrated it.Benefits:It will greatly reduce confusion in the user community; the fact that (make-array <n> :element-type '<aet>) frequently is not of type (array <aet>)has been very confusing to almost everyone.   That is, in practice,the distinction between "for declaration" and "for discrimination" hasbeen a disaster.Conversion Cost:Because of the prevalence of confusion in this area, it seems that nouser code will have to be changed.  In fact, it is more likely thatsome of the vendors will cease to get bug reports about some arraythat didn't seem to be of "the obvious type".Esthetics:Discussion:Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set of kinds of arrays that must be implemented (e.g, "int", "long int", "single","double" etc), and no others can exist.  In short, no one would not want to gain portability at the expense of limiting the language to the architecturalfeatures of the hardware on which it was first implemented.Many senior implementors at Lucid favor this proposal.  In network mail "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this proposal -- namely that upgrading should be continued, and that TYPEP should be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already been proposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  I don't    see how to eliminate "array element type upgrading" without creating    more problems [than] we solve.  . . .     My conclusion is that it isn't array types that are wrong, it is the    understanding of the meaning of TYPEP that is wrong. One possible criticism of this proposal is that it hinders portability by exposing an implementation dependent facet, namely the "upgrading" function.But the kind of portabililty achieved by a programmer ignorant of therealities of array implementations -- that only a finite number of type classes are really implemented efficiently in any particularCL implementation -- would be a very pyrrhic victory to say the least.The kinds of attention a programmer would have to pay to these array typeboundaries is the same kind of attention he now has to pay to the fixnum/bignum boundary (i.e., arithmetic that is doable in unit time, and that which requires tens to hundreds of units of time).Proposal (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:FLUSH-UPGRADING)-- Delete all the documentation that suggests the :element-type argument   to make-array might not be a satisfactory element-type in the type   specifier for the kind of array produced.  Particularly, delete the   documentation that permits a difference between type-specifiers "for   declaration" and "for discrimination;  primarily this means parts   of the discussion in CLtL, section 4.5, p. 45 and 46.  Include a   statement that `(array ,aet) is a suitable type-specifier for the   array made by `(make-array <dims> :element-type ',aet ...).  Include   also a statement that if `(array ,aet-x) and `(array ,aet-y)	 are   type-equivalent, then it must be the case that ,aet-x and ,aet-y are   also type-equivalent.-- Change the documentation of ARRAY-ELEMENT-TYPE, CLtL p. 291 by deleting   the sentence begining "This set may be larger than the set requested   when the array was created; for example . . ."-- Change the implementation of arrays so that a canonical member of   the equivalence class around the :element-type argument is always   remembered; ARRAY-ELEMENT-TYPE should return this canonical member.   Rationale:This makes for maximum portability; type specifiers are "remembered"exactly as the user typed them in (up to type-equivalence transformations).Current Practice:No vendor implements this.Adoption Cost:Array implementations would have to be changed in every vendor; for some,this could be an enormous amount of work.  In some implementations, the "cheapest" primitive arrays might become considerably more costly.  Since arrays seem to be at the base of every Common Lisp system, the effects of this change could be widespread, and costly to fix.Benefits:Being in love with portability means never having to say you're sorryabout TYPEP.Conversion Cost:Because of the prevalence of confusion in this area, it seems that nouser code will have to be changed.  However, knowing what :element-typespecifiers are implemented efficiently will likely still be of concern tomost vendor's clients.Esthetics:Discussion:The test case is, unfortunately, not relevant to this proposal, since itpresumes that some non-trivial upgrading is going on.  In particular,there will be no "two, distinct type specifiers ,aet-x and ,aet-x that are definitely not type-equivalent, but for which   (array-element-type (make-array 0 :element-type ',aet-x))  ==> ,aet-y"Many people are in favor of this proposal, at least initially.  See thearpanet interchanges mentioned above.One (or more) senior implementor(s) at Lucid favor(s) this proposal.It may be desirable to introduce a new function CANONICAL-TYPE of oneargument, which takes a type-specifier into a canonical type-specifierfor that type-equivalence class.*start*02937 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 20 MAY 88 21:03:39 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 May 88  21:02:00 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 408141; 20 May 88 23:59:59 EDTDate: Fri, 20 May 88 23:59 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSTo: Jon L White <edsel!jonl@labrea.stanford.edu>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8805130918.AA25649@bhopal.lucid.com>Message-ID: <19880521035951.6.MOON@EUPHRATES.SCRC.Symbolics.COM>ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING seems like thebeginning of a reasonable proposal.  There are a few problems with it:You don't list what type specifiers it applies to.  I assume you meanto include SIMPLE-ARRAY and VECTOR in addition to ARRAY.  What aboutCOMPLEX?Your proposal assumes without stating it explicitly that  (array-element-type (make-array dimensions :element-type element-type					     options...))is independent of the values of dimensions and options.  I believe thisto be true of most implementations, but see nothing in CLtL that requiresit.  I can easily imagine an implementation that offers more specializedarrays of rank 1 than of other ranks, more specialized adjustable thannon-adjustable arrays, or size-dependent specializations (why bother withpacked formats for very small arrays?).  This could seriously impact theadoption cost.  I think I have mentioned this before; do I have to dragout all the other comments I made last time this issue came up?You should specify more clearly that you are incompatibly changing themeaning of (typep array '(array <element-type>)) from "(aref array i)is guaranteed to result in an object of type <element-type>" to "(setf(aref array i) x) is type-valid if and only if x is of type<element-type>."I don't understand the justification for introducing the functionUPGRADE-ARRAY-ELEMENT-TYPE.  There are plenty of other type operatorsmissing from Common Lisp, why put in just this one?In the discussion section, "In short, no one would not want to gain portability at the expense of limiting the language to the architecturalfeatures of the hardware on which it was first implemented." doesnot say what I think you meant it to say, unless you've suddenlychanged your views radically.  Take out a "not."The proposal is much too long and contains too many digressions.  Itshould be extensively pared down before it is presented to X3J13.  Youcan judge from my 1-week delay in response how difficult I found it toread all the way through this proposal.  I haven't noticed any otherresponses, so others may have found it very difficult also.*start*05075 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 21 MAY 88 06:14:19 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 21 May 88  06:13:23 PDTReceived: by labrea.stanford.edu; Sat, 21 May 88 06:13:50 PDTReceived: from bhopal.lucid.com by edsel id AA19922g; Sat, 21 May 88 06:02:08 PDTReceived: by bhopal id AA08320g; Sat, 21 May 88 06:05:42 PDTDate: Sat, 21 May 88 06:05:42 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805211305.AA08320@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 20 May 88 23:59 EDT <19880521035951.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSYou raise a number of good points here.  I'm going to reply to severalof them out-of-order, to do the "easier" ones first.re: In the discussion section, "In short, no one would not want to     gain portability at the expense of limiting the language . . .    Take out a "not."Yes, several persons here at Lucid noted the typo too.  Take out a "not".re: I don't understand the justification for introducing the function    UPGRADE-ARRAY-ELEMENT-TYPE.  There are plenty of other type operators    missing from Common Lisp, why put in just this one?Because of the prevalence of user confusion about "upgrading" in arrays;this gives him a reasonable query mechanism for a very common problem.  Italso, quite likely, reflects a functionality that each implementation willhave to provide for itself anyway.re: You don't list what type specifiers it applies to.  I assume you mean    to include SIMPLE-ARRAY and VECTOR in addition to ARRAY.  What about    COMPLEX?I didn't think that explicit mention of SIMPLE-ARRAY and VECTOR was necessary, as they are subtypes of ARRAY.   However, it can't hurt toput in the one sentence clarification.  I did not mean COMPLEX; I only meant to cover arrays.  Perhaps COMPLEX could be "swept under the same rug"; do you think it is a good idea to do so?re: Your proposal assumes without stating it explicitly that      (array-element-type (make-array dimensions :element-type element-type					         options...))    is independent of the values of dimensions and options.  I believe this    to be true of most implementations, but see nothing in CLtL that requires    it.  . . . This could seriously impact the adoption cost.  I think I     have mentioned this before; do I have to drag out all the other comments     I made last time this issue came up?Yes, I think this assumption about independence is right. I don't rememberyour bringing out any such discussion on cl-cleanup before; the only noteI can find is just a statement of this same assumption sent out to thecommon-lisp mailing list:    Date: Fri, 11 Mar 88 16:02 EST    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    Subject: the array type mess....    To: Ram@C.CS.CMU.EDU    Cc: Jon L White <edsel!jonl@LABREA.STANFORD.EDU>,	    common-lisp@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDU    In-Reply-To: <RAM.12365298662.BABYL@>    . . .     An interesting comment on all this is that we are implicitly assuming    that an implementation's spectrum of specialized array types is independent    of the size, number of dimensions, indirectness, or adjustability of the    array.  This seems unlikely to be true of all implementations.  I don't    know how to fix this deficiency.    Someone should write this up in Cleanup form and thus give us all    a chance to think about it more deeply.But the grim file reaper seems to have put on temporarily inaccessibleback-up tape my cl-cleanp archives prior to Mar 4, 1988.  So I may havejust missed all the commentary about it before.On the other hand, if this assumption is violated, the I'd be curiousto know how an implementation can do, say, displacement of a vector toa multi-dimensional array with conformal element type, and vice-versa.  I've heard that Symbolics users frequently do this in order to runsequence-like functions over 2-dimensional arrays.re: The proposal is much too long and contains too many digressions.  There are two proposals here, you know; the verbal discussion in Palo Alto on March 13 suggested we would need two (and maybe this was a first?).  I have had commentary on it from folks at Lucid, but I note that CL-CLEANUP has been effectively moribund for the six weeks prior to the submission of this proposal.  So I don't think the lack of other public replies means it is any more difficult to comprehend than the other long proposals (such as, "setf-function-vs-macro").   On the other hand, I agree that is is unfortunately long; I don't easily see what can be deleted without opening up loopholes for someone to argue against.Do you have some specific suggestions as to what could be elided without inviting more criticism?  -- JonL --*start*18250 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 06:03:49 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 24 May 88  06:02:20 PDTReceived: by labrea.stanford.edu; Tue, 24 May 88 06:02:41 PDTReceived: from bhopal.lucid.com by edsel id AA05174g; Tue, 24 May 88 05:38:48 PDTReceived: by bhopal id AA05224g; Tue, 24 May 88 05:42:41 PDTDate: Tue, 24 May 88 05:42:41 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805241242.AA05224@bhopal.lucid.com>To: cl-cleanup@sail.stanford.eduSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 2)Issue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45               TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72               ARRAY-ELEMENT-TYPE, CLtL p. 291Category:      CHANGEEdit history:  Version 1, 13-May-88, JonL	       Version 2, 23-May-88, JonL  		(typo fixes, comments from moon, rearrange some discussion)Problem description:CLtL draws a distinction between type-specifiers "for declaration" and "for discrimination" in the case of array type specifiers -- i.e., those that are subtypes  of ARRAY [this implicitly includes SIMPLE-ARRAY and VECTOR].  Many people are confused by this situation, which may be one of the more insidious flaws in the current CL design.To get a sense of how the community is confused, see the arpanet mailing list for Common Lisp, in a series of exchanges started on Thu, 17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com>under the subject line of "Types in CL".  Also see the exchange started Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu>under the subject line of "TYPEP warp implications"A consequence of this "flaw" is that a variable declared to be of type 		<certain-type>and all of whose assigned objects are created in accord with that type,still may have *none* of its values ever satisfied by the TYPEP predicate with that type-specifier.  One type-specifier with this property in most implementations of CL is  <certain-type>  =  (ARRAY (SIGNED-BYTE 5)).An array created with this type specifier will, depending on the vendor,either be of typep (ARRAY (SIGNED-BYTE 8)) or (ARRAY T); but (almost) never of typep (ARRAY (SIGNED-BYTE 5)).A common feeling among Common Lisp users is that the set of type-specifiersforms a mathematical language, and the SUBTYPEP relation is generated by some basic, generating set of relations between these names.  People want to seethis language actually describing the implementation in which it is running -- that the objects of the implementation are a model for that language -- rather than seeing it be limited to some theoretical model which no vendor bothers to implement.   Hence, typep and subtypep should be changed toreflect what kinds of arrays get built; alternatively, make-array shouldbe changed to exhibit the distinctions that typep makes.No one seems to remember just exactly why this "warp" was put into CommonLisp in the first place; possibly it was added in a mistaken belief that it would promote portability. ["Mistaken", because the source of non-portability is the permission to upgrade; if two different implementationsdo any upgrading differently, then the effect will be the same kind of non-portability that results when two different implementations set the boundary between fixnums and bignums differently.]  However, many now feelit would be much simpler if the real source of the problem that led to this split up could be resolved.  Two proposals will be offered, each rejecting this odd distinction, but in different ways.  [Notation: because of the inability to show meta- or linguistic variablesin a different typeface, some code examples will use a backquote format;a form like ",x" will simply mean "substitute the value of x here".and a form like `(...) will simply mean "evaluate this first, doingthe indicated comma substitutions."  Also, the term "type-equivalent"will be used to denote two types which are each subtypes of the other;this relation establishes a partition on the set of type-specifiersinto disjoint sets, and members of the same equivalence class are simply different names for the same type.]One interesting krinkle in this issue is the question as to whether two non-EQ but type-equivalent type-specifiers ,aet-x and ,aet-y could give rise to different array types.  Remember that `(array ,aet-x) and `(array ,aet-y) are type-equivalent only if ,aet-x is type-equivalent to ,aet-y.  But this doesn't say anything about the reverse implication: does ,aet-x being type-equivalent to ,aet-y necessarily imply that `(array ,aet-x) is type-equivalent to `(array ,aet-y)?  For example, consider SHORT-FLOAT and SINGLE-FLOAT in an implementation where these are type-equivalent (because only one internal float type is provided forLisp objects -- see CLtL section 2.1.3).  One may desire to implement (ARRAY SHORT-FLOAT) and (ARRAY SINGLE-FLOAT) differently; say, for example that the former is packed into 16-bit half-words, whereas the latter is packed into 32-bit words.  But for either kind of packing, the result of AREF is an ordinary "single-float"; the whole point is merely to specify a packing technique for "packed float" arrays.  This "krinkle", however,will not be addressed by the proposals herein; it should simply beremembered that the implication goes only one way:  `(array ,aet-x)  is-type-equivalent-to  `(array ,aet-y)  ==>    ,aet-x  is-type-equivalent-to  ,aet-yTest case: Let aet-x and aet-y be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-arraywill return an object of the same primitive type; let this primitivetype be described by `(array ,aet-y).  This will be an implementation dependent search, but in every implementation that the present writer (JonL) has tested, there will be some such types; often, (signed-byte 5)and (signed-byte 8) will work.  Thus in each case, it should be true that:  (array-element-type (make-array 0 :element-type ',aet-x))  ==> ,aet-y  (array-element-type (make-array 0 :element-type ',aet-y))  ==> ,aet-yand if such a function exists, then:  (upgrade-array-element-type ',aet-x)  ==> ,aet-y  (upgrade-array-element-type ',aet-y)  ==> ,aet-yNow for a first set of tests; to eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   `(typep (make-array 0 :element-type ',aet-x)           '(array ,aet-x))   `(typep (make-array 0 :element-type ',aet-y)           '(array ,aet-y))Since `(array ,aet-x) and `(array ,aet-y) are different names for exactlythe same set of objects -- those arrays specialized to hold elements oftype aet-y -- then if the correlation between type-names and sets of objectsis being observed, these names should be type-equivalent.  That means thatboth of the following tests should be true:  [B]   `(subtypep '(array ,aet-x) '(array ,aet-y))   `(subtypep '(array ,aet-y) '(array ,aet-x))Additionally, to show that un-equivalent type-specifiers that are upgradedto the same "element type" should be equivalent as element-type specifiers,then both the following type tests should be true:  [C]   `(typep (make-array 0 :element-type ',aet-y)           '(array ,aet-x))   `(typep (make-array 0 :element-type ',aet-x)           '(array ,aet-y))Proposal (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING)-- Delete all the documentation that suggests the :element-type argument   to make-array might not be a satisfactory element-type in the type   specifier for the kind of array produced.  Particularly, delete the   documentation that permits a difference between type-specifiers "for   declaration" and "for discrimination;  primarily this means parts   of the discussion in CLtL, section 4.5, p. 45 and 46.  Include a   statement that `(array ,aet) is a suitable type-specifier for the   array made by `(make-array <dims> :element-type ',aet ...).-- Change the documentation of ARRAY-ELEMENT-TYPE, CLtL p. 291 by deleting   the sentence begining "This set may be larger than the set requested   when the array was created; for example . . ."-- Add documentation assuring that the resultant array-element-type   from a call to make-array is independent of any argument to make-array   except for the :element-type argument.-- Introduce a function UPGRADE-ARRAY-ELEMENT-TYPE, which will reveal how   a particular :element-type argument to make-array will be treated.   Semantically, this would be equivalent to:     (defun upgrade-array-element-type (element-type)       (array-element-type (make-array 0 :element-type element-type)))   but it wouldn't have to cons up the 0-element array first.  Also,   the presence of this name, as a documented function in the language,    would serve notice that "upgrading" is an important aspect of any real   implementation of CL arrays.-- Change TYPEP (and SUBTYPEP) so that `(typep x '(array ,aet)) is true   if and only if `(typep x '(array ,(upgrade-array-element-type aet)))   is true.Rationale:This proposal legitimizes current practice, and removes the obscure and un-useful distinction  between type-specifiers "for declaration" and "fordiscrimination".  Current Practice:Every vendor's implementation that the present writer has queried does some amount of non-trivial "upgrading" [generally, using (signed-byte 5)as an :element-type argument to make-array will show it]; this includes LUCID, VAXLISP, SYMBOLICS, FRANZ, and XEROX. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it [it may be that these two vendors have implemented a partial solution for subtypep, with a view to future extensions.]Cost to Implementors:Typically, a small amount of work will be required in every vendor'simplementation of TYPEP and SUBTYPEP; some vendors may have alreadydone the work, but not fully integrated it.Cost to Users:Because of the prevalence of confusion in this area, it seems unlikely thatany user code will have to be changed.  In fact, it is more likely that someof the vendors will cease to get bug reports about make-array returning aresult that isn't of "the obvious type".Cost of non-adoption:See Benefits.Benefits:It will greatly reduce confusion in the user community; the fact that (make-array <n> :element-type '<aet>) frequently is not of type (array <aet>)has been very confusing to almost everyone.   That is, in practice,the distinction between "for declaration" and "for discrimination" hasbeen a disaster.Esthetics:Discussion:Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set of kinds of arrays that must be implemented (e.g, "int", "long int", "single","double" etc), and no others can exist.  In short, no one would want to gain portability at the expense of limiting the language to the architecturalfeatures of the hardware on which it was first implemented.Many senior implementors at Lucid favor this proposal.  In network mail "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this proposal -- namely that upgrading should be continued, and that TYPEP should be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already been proposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  I don't    see how to eliminate "array element type upgrading" without creating    more problems [than] we solve.  . . .     My conclusion is that it isn't array types that are wrong, it is the    understanding of the meaning of TYPEP that is wrong. One possible criticism of this proposal is that it hinders portability by exposing an implementation dependent facet, namely the "upgrading" function.But the kind of portabililty achieved by a programmer ignorant of the realities of array implementations -- that only a finite number of array type classes are really implemented efficiently in any particular CL implementation  -- would be a very pyrrhic victory to say the least.  The kinds of attention a programmer would have to pay to these array type boundaries is the same kind of attention he now has to pay to the fixnum/bignum boundary (i.e., arithmetic that is doable in unit time, and that which requires tens to hundreds of units of time).This proposal arises from focusing on type specifiers as names for collections of objects, and on SUBTYPEP as being "subsetp" on collections of objects.  -- The second paragraph of CLtL p11 makes it clear that "data types" are     just sets of objects; subsequent discussion makes it clear that the     second argument to TYPEP (a type specifier) is a name for some such     set, and that there may be several distinct names specifying the same     set (or type).  The first paragraph of section 6.2.1 on page 72 says     that TYPEP is a set membership test, and SUBTYPEP is a subset test.  -- The first two paragraphs of section 4.5, on page 45, describe a     permission for what may be called "element-type upgrading" on arrays;      the  documentation for ARRAY-ELEMENT-TYPE on page 291 also makes it      clear that a conforming implementation is permitted to "collapse"      array element types into some more limited set of types, providing      that the array returned by make-array is at most an "upgrade".  The     array types STRING and BIT-ARRAY are excluded from upgrading.For example, depending on how primitive arrays are actually implemented,        (make-array <dims> :element-type '(signed-byte 5))and       (make-array <dims> :element-type '(signed-byte 8))might legitimately create arrays specialized to hold exactly the same set ofobjects.  The only constraint seems to be that that (array (signed-byte 8))be the most specific type  *** in that implementation *** which can holdall the arrays made by (make-array <dims> :element-type '(signed-byte 5) ...).In this case, we say that the array element type has been upgraded from(signed-byte 5) to (signed-byte 8), and we imply that there is no particular special provisions for arrays of element type, say, (signed-byte 6).By the bulletted paragraphs above, (array (signed-byte 5)) and(array (signed-byte 8)) are in fact names for exactly the sameset of objects.However pages 45 and 46 go at length to specify that these two differentnames for the same set of objects must be treated differently by TYPEPand SUBTYPEP.  This seems to "warp" the utility of TYPEP since it putsit at variance with the fundamental principle: "SUBTYPEP means subsetp".Proposal (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:FLUSH-UPGRADING)-- Delete all the documentation that suggests the :element-type argument   to make-array might not be a satisfactory element-type in the type   specifier for the kind of array produced.  Particularly, delete the   documentation that permits a difference between type-specifiers "for   declaration" and "for discrimination;  primarily this means parts   of the discussion in CLtL, section 4.5, p. 45 and 46.  Include a   statement that `(array ,aet) is a suitable type-specifier for the   array made by `(make-array <dims> :element-type ',aet ...).  Include   also a statement that if `(array ,aet-x) and `(array ,aet-y)	 are   type-equivalent, then it must be the case that ,aet-x and ,aet-y are   also type-equivalent.-- Change the documentation of ARRAY-ELEMENT-TYPE, CLtL p. 291 by deleting   the sentence begining "This set may be larger than the set requested   when the array was created; for example . . ."-- Change the implementation of arrays so that a canonical member of   the equivalence class around the :element-type argument is always   remembered; ARRAY-ELEMENT-TYPE should return this canonical member.   Rationale:This makes for maximum portability; type specifiers are "remembered"exactly as the user typed them in (up to type-equivalence transformations).Current Practice:No vendor implements this.Cost to Implementors:Array implementations would have to be changed in every vendor; for some,this could be an enormous amount of work.  In some implementations, the "cheapest" primitive arrays might become considerably more costly.  Since arrays seem to be at the base of every Common Lisp system, the effects of this change could be widespread, and costly to fix.Cost to Users:Because of the prevalence of confusion in this area, it seems unlikely thatany user code will have to be changed.  However, knowing what :element-typespecifiers are implemented efficiently will likely still be of concern tomost vendor's clients.Benefits:Being in love with portability means never having to say you're sorryabout TYPEP.Esthetics:Discussion:The test case is, unfortunately, not relevant to this proposal, since itpresumes that some non-trivial upgrading is going on.  In particular,there will be no "two, distinct type specifiers ,aet-x and ,aet-x that are definitely not type-equivalent, but for which   (array-element-type (make-array 0 :element-type ',aet-x))  ==> ,aet-y"Many people are in favor of this proposal, at least initially.  See thearpanet interchanges mentioned above.One senior implementor at Lucid has favored this proposal.It may be desirable to introduce a new function CANONICAL-TYPE of oneargument, which takes a type-specifier into a canonical type-specifierfor that type-equivalence class.*start*01371 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAY 88 18:20:20 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 23 May 88  18:18:57 PDTReceived: by labrea.stanford.edu; Mon, 23 May 88 18:19:21 PDTReceived: from bhopal.lucid.com by edsel id AA02526g; Mon, 23 May 88 17:10:53 PDTReceived: by bhopal id AA02281g; Mon, 23 May 88 17:14:44 PDTDate: Mon, 23 May 88 17:14:44 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805240014.AA02281@bhopal.lucid.com>To: pierson%mist@multimax.arpaCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Dan L. Pierson's message of Mon, 23 May 88 18:26:41 EDT <8805232226.AA13364@mist.UUCP>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS re: The SETF obviously conflicts with the local declaration and there is    no reason that even a fairly dumb compiler can't give an error without    reference to the type information that is associated with the global    definition of MY-ARRAY.I sympathize with your viewpoint entirely, but it is out of the domain ofthis proposal.   My comments on ISSUE: DEFSTRUCT-DEFAULT-VALUE-EVALUATIONsuggested something similar; but compielr treatment of "declarations" isn'tpart of the topic of ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS.-- JonL --*start*00780 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 08:12:20 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 24 May 88  08:08:52 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 24 May 88 11:09:42 EDTTo: cl-cleanup@sail.stanford.eduSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 2) In-reply-to: Your message of Tue, 24 May 88 05:42:41 -0700.             <8805241242.AA05224@bhopal.lucid.com> Date: Tue, 24 May 88 11:09:29 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUOne minor typographical correction: it's "Rob MacLachlan", not "RobMcLaughlin".I also favor the "Unify Upgrading" option.-- Scott*start*04505 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 13:41:58 PDTReceived: from JASPER.SCRC.Symbolics.COM ([128.81.41.58]) by SAIL.Stanford.EDU with TCP; 24 May 88  13:39:48 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by JASPER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 191912; Tue 24-May-88 16:39:26 EDTDate: Tue, 24 May 88 16:39 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSTo: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8805211305.AA08320@bhopal.lucid.com>Message-ID: <19880524203927.4.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sat, 21 May 88 06:05:42 PDT    From: Jon L White <edsel!jonl@labrea.stanford.edu>    re: I don't understand the justification for introducing the function	UPGRADE-ARRAY-ELEMENT-TYPE.  There are plenty of other type operators	missing from Common Lisp, why put in just this one?    Because of the prevalence of user confusion about "upgrading" in arrays;    this gives him a reasonable query mechanism for a very common problem.  It    also, quite likely, reflects a functionality that each implementation will    have to provide for itself anyway.I don't buy either of those arguments.  That's just my personal opinion.    re: You don't list what type specifiers it applies to.  I assume you mean	to include SIMPLE-ARRAY and VECTOR in addition to ARRAY.  What about	COMPLEX?    I didn't think that explicit mention of SIMPLE-ARRAY and VECTOR was     necessary, as they are subtypes of ARRAY.   However, it can't hurt to    put in the one sentence clarification.  I did not mean COMPLEX; I only     meant to cover arrays.  Perhaps COMPLEX could be "swept under the same     rug"; do you think it is a good idea to do so?I'd like to see COMPLEX included, too.  I think it would be a mistake tofix only half the problem, especially if later someone fixes the rest ofthe problem in an incompatible way.  Are you going to introduceUPGRADE-COMPLEX-ELEMENT-TYPE?    re: Your proposal assumes without stating it explicitly that	  (array-element-type (make-array dimensions :element-type element-type						     options...))	is independent of the values of dimensions and options.  I believe this	to be true of most implementations, but see nothing in CLtL that requires	it.    Yes, I think this assumption about independence is right.    ....I'd be curious    to know how an implementation can do, say, displacement of a vector to    a multi-dimensional array with conformal element type, and vice-versa.  There could be more element types for displaced arrays than for simplearrays.  I am not going to argue that it's important that Common Lispcontinue to allow that, especially if no implementations depending on itare discovered.  I'm reasonably sure that all Symbolics implementationshave the same menu of element types for all kinds of arrays, but I don'tknow that much about any other implementations.In any case, assumptions like this must be stated explicitly, especiallyfor their effect on the cost of adopting the proposal.    re: The proposal is much too long and contains too many digressions.      There are two proposals here, you know; the verbal discussion in Palo Alto     on March 13 suggested we would need two (and maybe this was a first?).  I     have had commentary on it from folks at Lucid, but I note that CL-CLEANUP     has been effectively moribund for the six weeks prior to the submission of     this proposal.  So I don't think the lack of other public replies means it     is any more difficult to comprehend than the other long proposals (such as,     "setf-function-vs-macro").       On the other hand, I agree that is is unfortunately long; I don't easily see     what can be deleted without opening up loopholes for someone to argue against.    Do you have some specific suggestions as to what could be elided without     inviting more criticism?  I think the second proposal should be deleted before it leaves the Cleanupcommittee.  It probably makes sense to leave it in for now.  I think some ofthe digressions about interesting krinkles and so forth aren't needed even now,but certainly should be deleted before it leaves the Cleanup committee.  Ithink all but the first paragraph of the problem description could be deletedor moved into the discussion section at the end.*start*00885 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 28 MAY 88 20:40:01 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 28 May 88  20:39:08 PDTReceived: by labrea.stanford.edu; Sat, 28 May 88 20:39:35 PDTReceived: from bhopal.lucid.com by edsel id AA29682g; Sat, 28 May 88 20:27:12 PDTReceived: by bhopal id AA12869g; Sat, 28 May 88 20:31:24 PDTDate: Sat, 28 May 88 20:31:24 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805290331.AA12869@bhopal.lucid.com>To: cl-cleanup@sail.stanford.eduSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSIs there anyone on this mailing list who would like to see the proposal (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:FLUSH-UPGRADING) continued?  If not,then perhaps we can delete it?-- JonL --*start*15898 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 JUN 88 22:19:32 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 2 Jun 88  22:16:02 PDTReceived: by labrea.stanford.edu; Thu, 2 Jun 88 22:16:20 PDTReceived: from bhopal.lucid.com by edsel id AA04593g; Thu, 2 Jun 88 22:08:32 PDTReceived: by bhopal id AA29144g; Thu, 2 Jun 88 22:06:32 PDTDate: Thu, 2 Jun 88 22:06:32 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8806030506.AA29144@bhopal.lucid.com>To: cl-cleanup@sail.stanford.eduSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)Following version omits the "FLUSH-UPGRADING" proposal, which no one on thiscommittee offered to support.  Additionally, it has a re-organization of thediscussion (as per moon's suggestion) now that only one proposal is present.It doesn't attack the COMPLEX problem.  I think biting off array element-typesemantics is enough for now; if it passes, then one of us will submit a COMPLEX-ELEMENT-TYPE-SEMANTICS issue; if it fails, then COMPLEX will be moot.-------------------------------------------------------------------------------Issue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45               TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72               ARRAY-ELEMENT-TYPE, CLtL p. 291Category:      CHANGEEdit history:  Version 1, 13-May-88, JonL	       Version 2, 23-May-88, JonL  		(typo fixes, comments from moon, rearrange some discussion)	       Version 3, 02-Jun-88, JonL  		(flush alternate proposal ["flush-upgrading"]; consequently,		 move more of discussion back to discussion section)Problem description:CLtL draws a distinction between type-specifiers "for declaration" and "for discrimination" in the case of array type specifiers -- i.e., those that are subtypes  of ARRAY [this implicitly includes SIMPLE-ARRAY and VECTOR].  Many people are confused by this situation, which may be one of the more insidious flaws in the current CL design.A consequence of this "flaw" is that a variable declared to be of type 		<certain-type>and all of whose assigned objects are created in accord with that type,still may have *none* of its values ever satisfied by the TYPEP predicate with that type-specifier.  One type-specifier with this property in most implementations of CL is  <certain-type>  =  (ARRAY (SIGNED-BYTE 5)).An array created with this type specifier will, depending on the vendor,either be of typep (ARRAY (SIGNED-BYTE 8)) or (ARRAY T); but (almost) never of typep (ARRAY (SIGNED-BYTE 5)).[Notation: because of the inability to show meta- or linguistic variablesin a different typeface, some code examples will use a backquote format;a form like ",x" will simply mean "substitute the value of x here".and a form like `(...) will simply mean "evaluate this first, doingthe indicated comma substitutions."  Also, the term "type-equivalent"will be used to denote two types which are each subtypes of the other;this relation establishes a partition on the set of type-specifiersinto disjoint sets, and members of the same equivalence class are simply different names for the same type.]Test case: Let aet-x and aet-y be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-arraywill return an object of the same primitive type; let this primitivetype be described by `(array ,aet-y).  This will be an implementation dependent search, but in every implementation that the present writer (JonL) has tested, there will be some such types; often, (signed-byte 5)and (signed-byte 8) will work.  Thus in each case, it should be true that:  (array-element-type (make-array 0 :element-type ',aet-x))  ==> ,aet-y  (array-element-type (make-array 0 :element-type ',aet-y))  ==> ,aet-yand if such a function exists, then:  (upgrade-array-element-type ',aet-x)  ==> ,aet-y  (upgrade-array-element-type ',aet-y)  ==> ,aet-yNow for a first set of tests; to eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   `(typep (make-array 0 :element-type ',aet-x)           '(array ,aet-x))   `(typep (make-array 0 :element-type ',aet-y)           '(array ,aet-y))Since `(array ,aet-x) and `(array ,aet-y) are different names for exactlythe same set of objects -- those arrays specialized to hold elements oftype aet-y -- then if the correlation between type-names and sets of objectsis being observed, these names should be type-equivalent.  That means thatboth of the following tests should be true:  [B]   `(subtypep '(array ,aet-x) '(array ,aet-y))   `(subtypep '(array ,aet-y) '(array ,aet-x))Additionally, to show that un-equivalent type-specifiers that are upgradedto the same "element type" should be equivalent as element-type specifiers,then both the following type tests should be true:  [C]   `(typep (make-array 0 :element-type ',aet-y)           '(array ,aet-x))   `(typep (make-array 0 :element-type ',aet-x)           '(array ,aet-y))Proposal (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING)-- Delete all the documentation that suggests the :element-type argument   to make-array might not be a satisfactory element-type in the type   specifier for the kind of array produced.  Particularly, delete the   documentation that permits a difference between type-specifiers "for   declaration" and "for discrimination;  primarily this means parts   of the discussion in CLtL, section 4.5, p. 45 and 46.  Include a   statement that `(array ,aet) is a suitable type-specifier for the   array made by `(make-array <dims> :element-type ',aet ...).-- Change the documentation of ARRAY-ELEMENT-TYPE, CLtL p. 291 by deleting   the sentence begining "This set may be larger than the set requested   when the array was created; for example . . ."-- Add documentation assuring that the resultant array-element-type   from a call to make-array is independent of any argument to make-array   except for the :element-type argument.  Thus upgrading, if done at all,   must be done the same way for complex and multi-dimensional arrays as for   simple vectors. -- Introduce a function UPGRADE-ARRAY-ELEMENT-TYPE, which will reveal how   a particular :element-type argument to make-array will be treated.   Semantically, this would be equivalent to:     (defun upgrade-array-element-type (element-type)       (array-element-type (make-array 0 :element-type element-type)))   but it wouldn't have to cons up the 0-element array first.  Also,   the presence of this name, as a documented function in the language,    would serve notice that "upgrading" is an important aspect of any real   implementation of CL arrays.-- Change TYPEP (and SUBTYPEP) so that `(typep x '(array ,aet)) is true   if and only if `(typep x '(array ,(upgrade-array-element-type aet)))   is true.Rationale:This proposal legitimizes current practice, and removes the obscure and un-useful distinction  between type-specifiers "for declaration" and "fordiscrimination".  Current Practice:Every vendor's implementation that the present writer has queried does some amount of non-trivial "upgrading" [generally, using (signed-byte 5)as an :element-type argument to make-array will show it]; this includes LUCID, VAXLISP, SYMBOLICS, FRANZ, and XEROX. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it [it may be that these two vendors have implemented a partial solution for subtypep, with a view to future extensions.]Cost to Implementors:Typically, a small amount of work will be required in every vendor'simplementation of TYPEP and SUBTYPEP; some vendors may have alreadydone the work, but not fully integrated it.Cost to Users:Because of the prevalence of confusion in this area, it seems unlikely thatany user code will have to be changed.  In fact, it is more likely that someof the vendors will cease to get bug reports about make-array returning aresult that isn't of "the obvious type".Cost of non-adoption:See Benefits.Benefits:It will greatly reduce confusion in the user community; the fact that (make-array <n> :element-type '<aet>) frequently is not of type (array <aet>)has been very confusing to almost everyone.   That is, in practice,the distinction between "for declaration" and "for discrimination" hasbeen a disaster.Esthetics:Discussion:To get a sense of how the community is confused, see the arpanet mailing list for Common Lisp, in a series of exchanges started on Thu, 17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com>under the subject line of "Types in CL".  Also see the exchange started Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu>under the subject line of "TYPEP warp implications"A common feeling among Common Lisp users is that the set of type-specifiersforms a mathematical language, and the SUBTYPEP relation is generated by some basic, generating set of relations between these names.  People want to seethis language actually describing the implementation in which it is running -- that the objects of the implementation are a model for that language -- rather than seeing it be limited to some theoretical model which no vendor bothers to implement.   Hence, typep and subtypep should be changed toreflect what kinds of arrays get built. [Alternatively, make-array shouldbe changed to exhibit the distinctions that typep makes.]Many senior implementors at Lucid favor this proposal.  In network mail "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this proposal -- namely that upgrading should be continued, and that TYPEP should be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already been proposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  I don't    see how to eliminate "array element type upgrading" without creating    more problems [than] we solve.  . . .     My conclusion is that it isn't array types that are wrong, it is the    understanding of the meaning of TYPEP that is wrong. Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set of kinds of arrays that must be implemented (e.g, "int", "long int", "single","double" etc), and no others can exist.  In short, no one would want to gain portability at the expense of limiting the language to the architecturalfeatures of the hardware on which it was first implemented.One possible criticism of this proposal is that it hinders portability by exposing an implementation dependent facet, namely the "upgrading" function.But the kind of portabililty achieved by a programmer ignorant of the realities of array implementations -- that only a finite number of array type classes are really implemented efficiently in any particular CL implementation  -- would be a very pyrrhic victory to say the least.  The kinds of attention a programmer would have to pay to these array type boundaries is the same kind of attention he now has to pay to the fixnum/bignum boundary (i.e., arithmetic that is doable in unit time, and that which requires tens to hundreds of units of time).  No one seems to remember just exactly why this "warp" was put into Common Lisp in the first place -- drawing a distinction between array type-specifiers "for declaration"and "for discrimination".  Possibly it was added in a mistaken belief that itwould promote portability. ["Mistaken", because the source of non-portabilityis the permission to upgrade; if two different implementations do any upgrading differently, then the effect will be the same kind of non-portability that results when two different implementations set the boundary between fixnums and bignums differently.] Since this proposal contains the implication:  `(array ,aet-x)  is-type-equivalent-to  `(array ,aet-y)  ==>    ,aet-x  is-type-equivalent-to  ,aet-ythen the question naturally arises "Does the reverse implication hold?"  That is, should two non-EQ but type-equivalent type-specifiers ,aet-x and ,aet-y always give rise to the same array types?   For example, consider SHORT-FLOAT and SINGLE-FLOAT in an implementation where these are type-equivalent (because only one internal float type is provided for Lisp objects -- see CLtL section 2.1.3).  One may desire to implement (ARRAY SHORT-FLOAT) and (ARRAY SINGLE-FLOAT) differently.  Say, for example that the former is packed into 16-bit half-words, whereas the latter is packed into 32-bit words; but for either kind of packing, the result of AREF is an ordinary "single-float".  The whole point is merely to specify a packing technique for "packed float" arrays.  This "krinkle", however,will not be addressed by the proposals herein; it should simply beremembered that the implication above goes only one way, and is notan "if-and-only-if" link.This proposal arises from focusing on type specifiers as names for collections of objects, and on SUBTYPEP as being "subsetp" on collections of objects.  -- The second paragraph of CLtL p11 makes it clear that "data types" are     just sets of objects; subsequent discussion makes it clear that the     second argument to TYPEP (a type specifier) is a name for some such     set, and that there may be several distinct names specifying the same     set (or type).  The first paragraph of section 6.2.1 on page 72 says     that TYPEP is a set membership test, and SUBTYPEP is a subset test.  -- The first two paragraphs of section 4.5, on page 45, describe a     permission for what may be called "element-type upgrading" on arrays;      the  documentation for ARRAY-ELEMENT-TYPE on page 291 also makes it      clear that a conforming implementation is permitted to "collapse"      array element types into some more limited set of types, providing      that the array returned by make-array is at most an "upgrade".  The     array types STRING and BIT-ARRAY are excluded from upgrading.For example, depending on how primitive arrays are actually implemented,        (make-array <dims> :element-type '(signed-byte 5))and       (make-array <dims> :element-type '(signed-byte 8))might legitimately create arrays specialized to hold exactly the same set ofobjects.  The only constraint seems to be that that (array (signed-byte 8))be the most specific type  *** in that implementation *** which can holdall the arrays made by (make-array <dims> :element-type '(signed-byte 5) ...).In this case, we say that the array element type has been upgraded from(signed-byte 5) to (signed-byte 8), and we imply that there is no particular special provisions for arrays of element type, say, (signed-byte 6).By the bulletted paragraphs above, (array (signed-byte 5)) and(array (signed-byte 8)) are in fact names for exactly the sameset of objects.However pages 45 and 46 go at length to specify that these two differentnames for the same set of objects must be treated differently by TYPEPand SUBTYPEP.  This seems to "warp" the utility of TYPEP since it putsit at variance with the fundamental principle: "SUBTYPEP means subsetp".*start*03976 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 JUN 88 14:02:04 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Jun 88  13:59:10 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 416025; Tue 7-Jun-88 16:58:52 EDTDate: Tue, 7 Jun 88 16:58 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)To: Jon L White <edsel!jonl@labrea.stanford.edu>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8806030506.AA29144@bhopal.lucid.com>Message-ID: <19880607205831.0.MOON@EUPHRATES.SCRC.Symbolics.COM>In general, I agree with ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING,however I have a few comments.To my mind the proposal never quite says explicitly what it's proposing.It speaks in terms of modifications to the document rather than features ofthe language.  I would summarize it as "The type specifier (ARRAY type)"denotes the set of all arrays that can result from calling MAKE-ARRAY witha :ELEMENT-TYPE argument of type.  The equivalence relations among typespecifiers (ARRAY type1) and (ARRAY type2) are implementation-dependent,since they depend on whether the implementation has distinctrepresentations for arrays with the two element types.  The subtyperelations among type specifiers (ARRAY type1) and (ARRAY type2) are asfollows:  For all values of type1 and type2, (ARRAY type1) and(ARRAY type2) are either equivalent or disjoint."[I added that last sentence, since I didn't find your proposal clear onSUBTYPEP.  Is my sentence what you intended to propose?]I really don't think it's acceptable to leave COMPLEX out.  The declarationversus discrimination distinction applies just as much to COMPLEX as toARRAY; at a minimum, COMPLEX should be mentioned in the body of theproposal as a subject for a necessary companion proposal.  I think it wouldbe better to include the proposal for COMPLEX in this one; it's astraightforward extension of the ARRAY proposal and will not complicate it.The one sentence version is "The type specifier (COMPLEX type) denotes theset of objects that can result from giving numbers of the specified type tothe function COMPLEX."  To that one should add the same comment about typeequivalence and subtypes as I made for arrays in the preceding paragraph.You need to list explicitly the type specifiers that are affected bythis proposal, so no one overlooks one.I really don't think the UPGRADE-ARRAY-ELEMENT-TYPE function is necessary.Everything you explain in terms of it can be explained in terms ofARRAY-ELEMENT-TYPE.I'm not sure I believe your claim that the cost to implementors and cost tousers are small.  This is an incompatible change, admittedly in an obscurearea.  Symbolics makes much heavier use of types than most other users ofCommon Lisp that I am aware of, particularly in presentation types, acompatible extension of Common Lisp types, and Statice types, anothercompatible extension of Common Lisp types.  I would not care to assert thatthis proposal will have no impact in those areas, I'd have to do some studyfirst.  The cost to implementors to change TYPEP and SUBTYPEP themselves isclearly small, but the cost to keep other things in the implementationconsistent with the change might not be small.  Also the claim that nousers could depend on the current workings of Common Lisp in this areabecause some users are confused is poor reasoning, and appears naive aboutusers.  I would not care to assert that there are no users out there whodepend on the present behavior.I think it would be better to admit that it is an incompatible changeand argue that the decrease in confusion justifies the cost.The discussion section was real long, so I didn't read it.*start*01401 00024 USfReturn-Path: <edsel!jonl@labrea.stanford.edu>Received: from labrea.stanford.edu by Xerox.COM ; 09 JUN 88 15:16:39 PDTReceived: by labrea.stanford.edu; Thu, 9 Jun 88 15:16:20 PDTReceived: from bhopal.lucid.com by edsel id AA16528g; Thu, 9 Jun 88 15:13:17 PDTReceived: by bhopal id AA25438g; Thu, 9 Jun 88 15:11:55 PDTDate: Thu, 9 Jun 88 15:11:55 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8806092211.AA25438@bhopal.lucid.com>To: Masinter.paIn-Reply-To: Masinter.pa@Xerox.COM's message of 8 Jun 88 12:28 PDT <880608-122824-2933@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)re: Can you produce a version 4 that you think will make Moon happy? (I don't     think it has to make Moon happy, you just have to think that it does.)I intended to reply to him tonight.  I probably won't make him happy at all.Amongst other things, I'm going to suggest that we try to get someone toread this proposal (Version 4, which will have a few trivial changes init) who isn't already steeped in the problem.  This is essential, sinceonly moon and I are reading it now, and we both have been staring at itmuch to long to decide questions like "the proposal doesn't say what itis proposing."  I expect to get some knowledgeable, but "uncomtaminated",hacker at lucid to read it; could you find some like person at Xerox?-- JonL --*start*04529 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 JUN 88 02:44:40 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 10 Jun 88  02:43:54 PDTReceived: by labrea.stanford.edu; Fri, 10 Jun 88 02:42:48 PDTReceived: from bhopal.lucid.com by edsel id AA19194g; Fri, 10 Jun 88 02:23:15 PDTReceived: by bhopal id AA27396g; Fri, 10 Jun 88 02:21:54 PDTDate: Fri, 10 Jun 88 02:21:54 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8806100921.AA27396@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 7 Jun 88 16:58 EDT <19880607205831.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)I intend to put some more work in on this proposal later today (Friday)which will, among other things, incorporate some of your suggestion; but others of your comments I'm not sure what to do with.re: To my mind the proposal never quite says explicitly what it's proposing.    It speaks in terms of modifications to the document rather than features     of the language.  Of the several parts of the proposal, two go like this:  -- Introduce a function UPGRADE-ARRAY-ELEMENT-TYPE, which will reveal how     a particular :element-type argument to make-array will be treated.     Semantically, this would be equivalent to:       (defun upgrade-array-element-type (element-type)         (array-element-type (make-array 0 :element-type element-type)))     . . .   -- Change TYPEP (and SUBTYPEP) so that `(typep x '(array ,aet)) is true     if and only if `(typep x '(array ,(upgrade-array-element-type aet)))     is true.   I think those are specific enough, as proposals.  The discussion section,which you say you didn't read, contained further ramifications;  much ofthat would cover what you want to add.  The remaining three parts ofthe proposal are indeed concerned with documentation, since I think thatis one of the fundamental problems here -- CLtL has the particular mis-features of the "warp" built-in at numerous places, and they will have to be removed.re:  The subtype relations among type specifiers (ARRAY type1) and      (ARRAY type2) are as follows:  For all values of type1 and type2,      (ARRAY type1) and (ARRAY type2) are either equivalent or disjoint.Yea, I *think* this is true under the unify-upgrading proposal; but isn'tit true under the status quo also?   see the "warp" statement at the bottom of CLtL p45, and the disjointness statement on p46: "Now(array character) is not a subset of (array t); the two sets are in factdisjoint because ..."   What I thought the interesting question would be is that found in the discussion section of the proposal, near:    Since this proposal contains the implication:      `(array ,aet-x)  is-type-equivalent-to  `(array ,aet-y)      ==>        ,aet-x  is-type-equivalent-to  ,aet-y    then the question naturally arises "Does the reverse implication hold?"  The answer I came up with is no. Perhaps you should go read that after all.re: ... COMPLEX should be mentioned in the body of the    proposal as a subject for a necessary companion proposal. Ok, why not.  It seems clear to me that most implementations will have atotally different kind of upgrading for COMPLEX's than for ARRAY's, andthat's part of the reason I don't want to mix the two together right now.re: You need to list explicitly the type specifiers that are affected by    this proposal, so no one overlooks one.I did, but in the problem statement part:     . . . i.e., those [type-specifiers] that are subtypes  of ARRAY.      This implicitly includes SIMPLE-ARRAY and VECTOR.What more were you thinking of?  simply noting that forms like(ARRAY <type>) and (VECTOR <type> 3) and (SIMPLE-ARRAY <type> (* * *)) are all subtypes of ARRAY?One more question I have for you [apparently no one else is readingthese more complicated proposals?].  Do you find the notation `(array ,aet-y) distracting?  I notice that in your comments you use(ARRAY type-y) instead.  Is the form `(array ,aet-y) bad enoughto warrant complete substitution?  At least one of my early readershere at lucid didn't like it.I think it would be real good if we could get some knowledgeable, but"uncontaminated", reader to go over this proposal now.  Or maybe Version 4.-- JonL --*start*01836 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 07 SEP 88 04:28:51 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01177g; Wed, 7 Sep 88 03:28:49 PSTReceived: by bhopal id AA10665g; Wed, 7 Sep 88 04:28:09 PDTDate: Wed, 7 Sep 88 04:28:09 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809071128.AA10665@bhopal>To: Masinter.paIn-Reply-To: Masinter.pa@Xerox.COM's message of 4 Sep 88 15:37 PDT <880904-153740-8873@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)re: The last message I have filed on this issue was dated June 10, in which     you say "I intend to put some more work in on this proposal later today     (Friday) which will, among other things, incorporate some of your     suggestion; but others of your comments I'm not sure what to do with...."Uh, there wasn't time to get that in before the Boston X3J13 meeting, soI didn't do it then.  I'll get back to it "very soon".Like you, I have been swamped with other duties since earlier this year,and will just this week get back to the several items of cleanup thatI've been putting off.  The ones that _frequently_ come back to my mind(without having to peruse old mail files) are:  (1) minor fixes to ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)  (2) moderate revamp to hash-table and package iterator primitives  (3) vast simplification of DECLARE-SCOPEGuy did say that he would submit the remainder of his "clarifications"list form 9-Dec-85 -- hear anything from him yet either?Also, I'll make a pass at my own "clarifications" list -- hardcopy ofwhich was passed out to selected members at the Palo Alot meeting inMarch of this year.-- JonL --P.S.: Hmmm, my logo crock -- well, now if only I had the software to use it ...*start*10815 00024 US Date:  6 Sep 88 12:17 PDTFrom: Pedersen.paSubject: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSTo: masinter.pacc: Pedersen.pa	I think JonL's quite correct in identifying the (obscure) distinction between types used for discrimination and types used for declaration as a constant source of confusion and errors. His solution for the case of the array types also seems satisfactory; however, I agree with Moon that this problem extends to other types as well, most notably the type complex. It is not clear to me whether this proposal need address the type complex aside from noting that a similar solution may be appropriate.	JonL's argument follows directly from the following two observations:"  -- The second paragraph of CLtL p11 makes it clear that "data types" are     just sets of objects; subsequent discussion makes it clear that the     second argument to TYPEP (a type specifier) is a name for some such     set, and that there may be several distinct names specifying the same     set (or type).  The first paragraph of section 6.2.1 on page 72 says     that TYPEP is a set membership test, and SUBTYPEP is a subset test.  -- The first two paragraphs of section 4.5, on page 45, describe a     permission for what may be called "element-type upgrading" on arrays;      the  documentation for ARRAY-ELEMENT-TYPE on page 291     also makes it clear that a conforming implementation is permitted     to "collapse" array element types into some more limited set of types,      providing that the array returned by make-array is at most an "upgrade".     The array types STRING and BIT-ARRAY are excluded from upgrading."	Hence if (make-array DIMS :element-type TYPE-1) and (make-array DIMS :element-type TYPE-2) produce arrays of the same type, then (array TYPE-1) and (array TYPE-2) are names for the same set of objects and TYPEP and SUBTYPEP must behave appropriately.	I also agree with Moon that this is an incompatible change, and should be announced as such. The proposed function, UPGRADE-ARRAY-ELEMENT-TYPE, is a convenience, but is not strictly necessary for the rest of the argument to hold water; it simply makes explicit what is implicit in the behavior of make-array.	Here's a cut at a rephrasing of the proposal:Issue:           ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:   Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291Category:      CHANGEEdit history:  Version 1, 13-May-88, JonL	           Version 2, 23-May-88, JonL  		  (typo fixes, comments from moon, rearrange some discussion)	           Version 3, 02-Jun-88, JonL  		  (flush alternate proposal ["flush-upgrading"]; consequently,		   move more of discussion back to discussion section.	           Version 4, 06-Sept-88, Jan PedersenProblem description:CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination". Many people are confused by this situation, which may be one of the more insidious flaws in the current CL design. A consequence of this "flaw" is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have *none* of its values ever satisfy the typep predicate with that type-specifier.One type-specifier with this property is  <certain-type>  =  (array ELEMENT-TYPE), for certain values of ELEMENT-TYPE. For example, for most implementations of CL, an array, x, created with element-type (signed-byte 5) will, depending on the vendor, either satisfy (typep x '(array (signed-byte 8))) or (typep x '(array t)); but (almost) never (typep x '(array (signed-byte 5))).This proposal suggests elimination of this distinction for the array types  array,  simple-array, and vector by guaranteeing that arrays constructed with a specific element-type satisfy the typep predicate with the derived array type-specifier and by guaranteeing that subtypep reflect the type equivalences defined by the behavior of make-array.Test case:Let AET-X and AET-Y be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-arraywill return an object of the same array type. Let this primitivetype be  (array AET-Y).  This will be an implementation dependent search, but in every implementation that the present writer has tested, there will be some such types; often, (signed-byte 5)and (signed-byte 8) will work. Thus, in each case, it should be true that:  (array-element-type (make-array 0 :element-type AET-X))  ==> AET-Y  (array-element-type (make-array 0 :element-type AET-Y))  ==> AET-YTo eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type 'AET-X)           '(array AET-X))   (typep (make-array 0 :element-type 'AET-Y)           '(array AET-Y))Since (array AET-X) and (array AET-Y) are different names for exactlythe same set of objects, these names should be type-equivalent. In other words, both describe those arrays specialized to hold elements oftype AET-Y. That implies that the following set of tests should also be true:  [B]   (subtypep '(array AET-X) '(array AET-Y))   (subtypep '(array AET-Y) '(array AET-X))Additionally, to show that un-equivalent type-specifiers that are upgradedto the same "element type" should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type 'AET-Y)           '(array AET-X))   (typep (make-array 0 :element-type 'AET-X)           '(array AET-Y))Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING)-- Change typep and subtypep  so that (typep x '(array AET)) is true if and only if (typep x `(array ,(array-element-type (make-array 0 :element-type 'AET)))) is true.-- Require that the resultant array-element-type from a call to make-array is independent of any argument to make-array except for the :element-type argument.  Thus upgrading, if done at all, must be done the same way for non-simple and multi-dimensional arrays as for simple arrays.-- Eliminate references to the distinction between types "for declaration" and "for discrimination" in the discussion of array element-types. This would include:	a.) The discussion in section  4.5, p. 45 and 46	b.) p. 291, the sentence begining "This set may be larger than the set	requested when the array was created; for example . . ."-- Introduce a function, UPGRADE-ARRAY-ELEMENT-TYPE, which will reveal how a particular :element-type argument to make-array will be treated. Semantically, this would be equivalent to:     (defun upgrade-array-element-type (element-type)       (array-element-type (make-array 0 :element-type element-type)))but it might not cons up the 0-element array first.  Also, the presence of this name, as a documented function in the language, would serve notice that "upgrading" is an important aspect of any real implementation of CL arrays.Rationale:This proposal legitimizes current practice, and removes the obscure and un-useful distinction  between type-specifiers "for declaration" and "fordiscrimination" for array type-specifiers. The suggested changes to the interpretation of array type-specifiers follow from defining type specifiers as names for collections of objects, on typep being a set membership test, and subtypep a subset test on collections of objects.Current Practice:Every vendor's implementation that the present writer has queried does some amount of non-trivial "upgrading"; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it.Cost to Implementors:This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of typep and subtypep.Cost to Users:Because of the prevalence of confusion in this area, it seems unlikely thatany user code will have to be changed.  In fact, it is more likely that someof the vendors will cease to get bug reports about make-array returning aresult that isn't of "the obvious type".Cost of non-adoption:Benefits:It will greatly reduce confusion in the user community.  The fact that (make-array <n> :element-type 'AET) frequently is not of type (array AET)has been very confusing to almost everyone.   That is, in practice,the distinction between "for declaration" and "for discrimination" hasbeen a disaster.It may also be the case that portability will be improved since the identity(typep (make-array N :element-type 'AET) '(array AET)) will be observed.Esthetics:Discussion:To get a sense of how the community is confused, see the arpanet mailing list for Common Lisp, in a series of exchanges started on Thu, 17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com>under the subject line of "Types in CL".  Also see the exchange started Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu>under the subject line of "TYPEP warp implications".Many senior implementors at Lucid favor this proposal.  In network mail "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this proposal -- namely that upgrading should be continued, and that TYPEP should be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already been proposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  I don't    see how to eliminate "array element type upgrading" without creating    more problems [than] we solve.  . . .     My conclusion [JonL's] is that it isn't array types that are wrong, it is the    understanding of the meaning of TYPEP that is wrong.Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set of kinds of arrays that must be implemented (e.g, "int", "long int", "single","double" etc), and no others can exist.  In short, no one would want to gain portability at the expense of limiting the language to the architecturalfeatures of the hardware on which it was first implemented.							J.P.			*start*11182 00024 USPDate: 13 Sep 88 02:08 PDTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)In-reply-to: your message of Wed, 7 Sep 88 04:28:09 PDTTo: Jon L White <jonl@lucid.com>cc: MasinterI'll see if I can get you a demo copy of Medley for the Sun. What flavor Sun would you like it for? Here's Pedersen's comments. If you like his rewrite, lets go for it.Date:  6 Sep 88 12:17 PDTFrom: Pedersen.paSubject: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSTo: masinter.pacc: Pedersen.pa	I think JonL's quite correct in identifying the (obscure) distinction between types used for discrimination and types used for declaration as a constant source of confusion and errors. His solution for the case of the array types also seems satisfactory; however, I agree with Moon that this problem extends to other types as well, most notably the type complex. It is not clear to me whether this proposal need address the type complex aside from noting that a similar solution may be appropriate.	JonL's argument follows directly from the following two observations:"  -- The second paragraph of CLtL p11 makes it clear that "data types" are     just sets of objects; subsequent discussion makes it clear that the     second argument to TYPEP (a type specifier) is a name for some such     set, and that there may be several distinct names specifying the same     set (or type).  The first paragraph of section 6.2.1 on page 72 says     that TYPEP is a set membership test, and SUBTYPEP is a subset test.  -- The first two paragraphs of section 4.5, on page 45, describe a     permission for what may be called "element-type upgrading" on arrays;      the  documentation for ARRAY-ELEMENT-TYPE on page 291     also makes it clear that a conforming implementation is permitted     to "collapse" array element types into some more limited set of types,      providing that the array returned by make-array is at most an "upgrade".     The array types STRING and BIT-ARRAY are excluded from upgrading."	Hence if (make-array DIMS :element-type TYPE-1) and (make-array DIMS :element-type TYPE-2) produce arrays of the same type, then (array TYPE-1) and (array TYPE-2) are names for the same set of objects and TYPEP and SUBTYPEP must behave appropriately.	I also agree with Moon that this is an incompatible change, and should be announced as such. The proposed function, UPGRADE-ARRAY-ELEMENT-TYPE, is a convenience, but is not strictly necessary for the rest of the argument to hold water; it simply makes explicit what is implicit in the behavior of make-array.	Here's a cut at a rephrasing of the proposal:Issue:           ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:   Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291Category:      CHANGEEdit history:  Version 1, 13-May-88, JonL	           Version 2, 23-May-88, JonL  		  (typo fixes, comments from moon, rearrange some discussion)	           Version 3, 02-Jun-88, JonL  		  (flush alternate proposal ["flush-upgrading"]; consequently,		   move more of discussion back to discussion section.	           Version 4, 06-Sept-88, Jan PedersenProblem description:CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination". Many people are confused by this situation, which may be one of the more insidious flaws in the current CL design. A consequence of this "flaw" is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have *none* of its values ever satisfy the typep predicate with that type-specifier.One type-specifier with this property is  <certain-type>  =  (array ELEMENT-TYPE), for certain values of ELEMENT-TYPE. For example, for most implementations of CL, an array, x, created with element-type (signed-byte 5) will, depending on the vendor, either satisfy (typep x '(array (signed-byte 8))) or (typep x '(array t)); but (almost) never (typep x '(array (signed-byte 5))).This proposal suggests elimination of this distinction for the array types  array,  simple-array, and vector by guaranteeing that arrays constructed with a specific element-type satisfy the typep predicate with the derived array type-specifier and by guaranteeing that subtypep reflect the type equivalences defined by the behavior of make-array.Test case:Let AET-X and AET-Y be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type. Let this primitive type be  (array AET-Y).  This will be an implementation dependent search, but in every implementation that the present writer has tested, there will be some such types; often, (signed-byte 5) and (signed-byte 8) will work. Thus, in each case, it should be true that:  (array-element-type (make-array 0 :element-type AET-X))  ==> AET-Y  (array-element-type (make-array 0 :element-type AET-Y))  ==> AET-YTo eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type 'AET-X)           '(array AET-X))   (typep (make-array 0 :element-type 'AET-Y)           '(array AET-Y))Since (array AET-X) and (array AET-Y) are different names for exactly the same set of objects, these names should be type-equivalent. In other words, both describe those arrays specialized to hold elements of type AET-Y. That implies that the following set of tests should also be true:  [B]   (subtypep '(array AET-X) '(array AET-Y))   (subtypep '(array AET-Y) '(array AET-X))Additionally, to show that un-equivalent type-specifiers that are upgraded to the same "element type" should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type 'AET-Y)           '(array AET-X))   (typep (make-array 0 :element-type 'AET-X)           '(array AET-Y))Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING)-- Change typep and subtypep  so that (typep x '(array AET)) is true if and only if (typep x `(array ,(array-element-type (make-array 0 :element-type 'AET)))) is true.-- Require that the resultant array-element-type from a call to make-array is independent of any argument to make-array except for the :element-type argument.  Thus upgrading, if done at all, must be done the same way for non-simple and multi-dimensional arrays as for simple arrays.-- Eliminate references to the distinction between types "for declaration" and "for discrimination" in the discussion of array element-types. This would include:	a.) The discussion in section  4.5, p. 45 and 46	b.) p. 291, the sentence begining "This set may be larger than the set	requested when the array was created; for example . . ."-- Introduce a function, UPGRADE-ARRAY-ELEMENT-TYPE, which will reveal how a particular :element-type argument to make-array will be treated. Semantically, this would be equivalent to:     (defun upgrade-array-element-type (element-type)       (array-element-type (make-array 0 :element-type element-type)))but it might not cons up the 0-element array first.  Also, the presence of this name, as a documented function in the language, would serve notice that "upgrading" is an important aspect of any real implementation of CL arrays.Rationale:This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination" for array type-specifiers. The suggested changes to the interpretation of array type-specifiers follow from defining type specifiers as names for collections of objects, on typep being a set membership test, and subtypep a subset test on collections of objects.Current Practice:Every vendor's implementation that the present writer has queried does some amount of non-trivial "upgrading"; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it.Cost to Implementors:This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of typep and subtypep.Cost to Users:Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about make-array returning a result that isn't of "the obvious type".Cost of non-adoption:Benefits:It will greatly reduce confusion in the user community.  The fact that (make-array <n> :element-type 'AET) frequently is not of type (array AET) has been very confusing to almost everyone.   That is, in practice, the distinction between "for declaration" and "for discrimination" has been a disaster.It may also be the case that portability will be improved since the identity (typep (make-array N :element-type 'AET) '(array AET)) will be observed.Esthetics:Discussion:To get a sense of how the community is confused, see the arpanet mailing list for Common Lisp, in a series of exchanges started on Thu, 17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com>under the subject line of "Types in CL".  Also see the exchange started Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu>under the subject line of "TYPEP warp implications".Many senior implementors at Lucid favor this proposal.  In network mail "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this proposal -- namely that upgrading should be continued, and that TYPEP should be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already been proposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  I don't    see how to eliminate "array element type upgrading" without creating    more problems [than] we solve.  . . .     My conclusion [JonL's] is that it isn't array types that are wrong, it is the    understanding of the meaning of TYPEP that is wrong.Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set of kinds of arrays that must be implemented (e.g, "int", "long int", "single","double" etc), and no others can exist.  In short, no one would want to gain portability at the expense of limiting the language to the architecturalfeatures of the hardware on which it was first implemented.							J.P.*start*01506 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 19 SEP 88 18:30:13 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03869g; Mon, 19 Sep 88 17:29:50 PSTReceived: by bhopal id AA15809g; Mon, 19 Sep 88 18:29:14 PDTDate: Mon, 19 Sep 88 18:29:14 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809200129.AA15809@bhopal>To: masinter.paCc: jonl@lucid.comIn-Reply-To: masinter.pa@Xerox.COM's message of 13 Sep 88 02:08 PDT <880913-020813-2582@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)re: I'll see if I can get you a demo copy of Medley for the Sun. What flavor     Sun would you like it for?It would be much easier for me, personally, to try it on a Sun3/160.  The Sun4's we have are much more limited, and their usage is more constrained; however, I could run it there on either a Sun version 3 or version 4 UnixOS.Say, isn't PARC a beta site anyway for Lucid software?  possibly you should be slated for a beta release of the Sun4/3.0 (Sun3/3.0 is what is just beingshipped now -- Apollo, Sun4, VAX etc are on a varying length schedules for the 3.0 release).re:  ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS ... Here's Pedersen's comments.     If you like his rewrite, lets go for it.I'll need some time to compare this with the last mailed out version,and with the one I wanted to mail out which incorporated moon's lastcommentary.  Say, possibly later this week?-- JonL --*start*01656 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 22 SEP 88 20:39:17 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA07170g; Thu, 22 Sep 88 19:38:49 PSTReceived: by bhopal id AA07862g; Thu, 22 Sep 88 20:38:19 PDTDate: Thu, 22 Sep 88 20:38:19 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809230338.AA07862@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: Masinter.PA, jonl@lucid.comIn-Reply-To: David A. Moon's message of Sun, 18 Sep 88 17:35 EDT <19880918213543.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSre:     I think you're right that only a small amount of additional work is needed.    How about if you make a revision of the proposal and send it just to me,    and then I will read that together with your message of 10 June and send    back a constructive response.  If it arrives before some time on Tuesday    I should be able to answer this week, otherwise I'll be away and won't    be able to answer until late next week.Well, now I feel bad that the blizzard of mail surrounding our Sun3/3.0release has prevented me from seeing this msg until now.  I assume thatyour travel is connected with OOPSLA (I had to cancel because of mountingresponsibilities).   Since I didn't make your Tuesday deadline, then I'm going to wait until either this weekend, or early next week to send youthe current revision.  Send me mail pronto if my attention to this matter TOMORROW, 23-Sep-88,would be more convenient.  I'll scan mail headers backwards tomorrowmorning to see if you so request.-- JonL --*start*01080 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 29 SEP 88 17:48:52 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00408g; Thu, 29 Sep 88 16:47:49 PSTReceived: by bhopal id AA14262g; Thu, 29 Sep 88 17:47:21 PDTDate: Thu, 29 Sep 88 17:47:21 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809300047.AA14262@bhopal>To: masinter.paCc: Moon@STONY-BROOK.SCRC.Symbolics.COM, jonl@lucid.comIn-Reply-To: masinter.pa@Xerox.COM's message of 28 Sep 88 23:05 PDT <880928-230528-2306@Xerox>Subject: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSre: Just checking ... did I miss the update on this issue?    I want to be able to send stuff out this weekend....No update mailed out yet.  We've been embroiled in other issues, but we agreed that this one is essentially done modulo minor nits.  I suspectthat Moon is out of town today; and I have another deadline for tomorrow. So I'd like to put off even the minor amount of time that it would take topdl around with this until Saturday.-- JonL --*start*11125 00024 USfReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 01 OCT 88 23:00:37 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01527g; Sat, 1 Oct 88 21:59:21 PSTReceived: by bhopal id AA09202g; Sat, 1 Oct 88 22:58:55 PDTDate: Sat, 1 Oct 88 22:58:55 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810020558.AA09202@bhopal>To: masinter.pa, pedersen.paCc: jonl@lucid.com, Moon@STONY-BROOK.SCRC.Symbolics.COMSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)I liked what Jan did very much!  I've a few nits to bend into it;  -- changed some meta-language notation -- given the lack of fonts,     I much prefer "<type>" to "AET" (the latter looks like an s-exp)  -- moved the "Test case" later, following other proposal formats;  -- refined the description of upgrade-array-element-type so that is      more usable;  -- re-pretty-printed to a 79-column page!  -- a couple more sentences here and there of explanation.So here is the diddled version; If Jan and moon approve, then send it out?-- JonL --P.S. By the bye, while I've always agreed that type upgrading for COMPLEX      must be handled some day, I still don't think it is beneficial to     get mired down in it now.  There has been a long hue and cry about     arrays, but no "user" that I'm aware of has ever complained about     COMPLEX.  So I don't see it as a pressing issue.!Issue:           ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:   Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291Category:      CHANGEEdit history:  Version 1, 13-May-88, JonL	       Version 2, 23-May-88, JonL  	        (typo fixes, comments from moon, rearrange some discussion)	       Version 3, 02-Jun-88, JonL  	        (flush alternate proposal ["flush-upgrading"]; consequently,	         move more of discussion back to discussion section.	       Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings) Problem description:CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination". Many people are confused by this situation, which may be one of the more insidious flaws in the current CL design. A consequence of this "flaw" is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have *none* of its values ever satisfy the typep predicate with that type-specifier.One type-specifier with this property is         <certain-type>  =  (ARRAY <element-type>) for various implementation dependent values of <element-type>.  For example,in  most implementations of CL, an array X created with  and element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy 	(TYPEP X '(ARRAY (SIGNED-BYTE 8))), or	(TYPEP X '(ARRAY T)) but (almost) never will it satisfy 	(TYPEP X '(ARRAY (SIGNED-BYTE 5))).This proposal suggests elimination of this distinction for the array typesARRAY,  SIMPLE-ARRAY, and VECTOR and their subtypes, by guaranteeing that arrays constructed with a specific element-type satisfy the typep predicatewith the derived array type-specifier, and by guaranteeing that subtypep reflect the type equivalences defined by the behavior of make-array.Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING)-- Introduce a function, UPGRADE-ARRAY-ELEMENT-TYPE of one argument, which    reveals how the given implementation treats a particular :element-type    argument to make-array.  Given a type-specifier <type1> as argument, it   returns a maximal type-specifier <type2> such that <type2> is the   actual specialized array element type used whenever <type1> is given as   an :element-type argument to MAKE-ARRAY.   Note that 	(upgrade-array-element-type '<type>) = 	    (array-element-type (make-array 0 :element-type '<type>))   for all type specifiers <type>.   -- Change typep and subtypep  so that:	    (TYPEP X '(ARRAY <type>))    is true if and only if 	    (TYPEP X `(ARRAY ,(UPGRADE-ARRAY-ELEMENT-TYPE '<type>)))   is true.-- Require that the resultant array-element-type from a call to make-array    is independent of any argument to make-array except for the :element-type   argument.  Thus upgrading, if done at all, must be done the same way for    non-simple and multi-dimensional arrays as it is for simple arrays.-- Eliminate references to the distinction between types "for declaration" and   "for discrimination" in the discussion of array element-types. This would   include documentation patterened after CLtL:	a.) The discussion in section  4.5, p. 45 and 46	b.) p. 291, the sentence begining "This set may be larger than the set	requested when the array was created; for example . . ."Test cases:Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely nottype-equivalent in a given implementation, but for which make-array will returnan object of the same array type. Let this primitive type be  (ARRAY <aet-y>).This will be an implementation dependent search, but in every implementationthat the proposer has tested, there will be some such types; often,(SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, it should be true that:  (array-element-type (make-array 0 :element-type '<aet-x>))  ==> <aet-y>  (array-element-type (make-array 0 :element-type '<aet-y>))  ==> <aet-y>To eliminate the distinction between "for declaration" and "for discrimination"both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>))Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. In other words, both describe those arrays specialized to hold elements of type <aet-y>. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>))Additionally, to show that un-equivalent type-specifiers that are upgraded tothe same "element type" should be equivalent as element-type specifiers, thefollowing type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)           '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)           '(array <aet-y>))Rationale:This proposal legitimizes current practice, and removes the obscure andun-useful distinction between type-specifiers "for declaration" and "fordiscrimination" for array type-specifiers. The suggested changes to theinterpretation of array type-specifiers follow from defining type specifiers as names for collections of objects, on typep being a set membership test, and subtypep a subset test on collections of objects.Current Practice:Every vendor's implementation that the proposer has queried does some amountof non-trivial "upgrading"; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinctionbetween "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it.Cost to Implementors:This proposal is an incompatible change to the current language specification,but only a small amount of work should be required in each vendor'simplementation of typep and subtypep.Cost to Users:Because of the prevalence of confusion in this area, it seems unlikely that anyuser code will have to be changed.  In fact, it is more likely that some of thevendors will cease to get bug reports about make-array returning a result thatisn't of "the obvious type".Cost of non-adoption:Continuing confusion in the user community.Benefits:It will greatly reduce confusion in the user community.  The fact that(make-array <n> :element-type '<type>) frequently is not of type (array <type>) has been very confusing to almost everyone.   That is, in practice, the distinction between "for declaration" and "for discrimination" has been a disaster.Esthetics:Reducing the confusing distinction between type-specifiers "for declaration"and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of datathey purport to name.  Thus this is a step towards increased elegance.Discussion:To get a sense of how the community is confused, see the arpanet mailing list for Common Lisp, in a series of exchanges started on Thu, 17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com>under the subject line of "Types in CL".  Also see the exchange started Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu>under the subject line of "TYPEP warp implications".Many senior implementors at Lucid favor this proposal.  In network mail "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this proposal -- namely that upgrading should be continued, and that TYPEP should be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already been proposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  I don't    see how to eliminate "array element type upgrading" without creating    more problems [than] we solve.  . . .     My conclusion [JonL's] is that it isn't array types that are wrong, it isthe    understanding of the meaning of TYPEP that is wrong.Semantically, upgrade-array-element-type is equivalent to:     (defun upgrade-array-element-type (element-type)       (array-element-type (make-array 0 :element-type element-type)))but it might not cons up the 0-element array first.  Also, the presence of this name, as a documented function in the language, would serve notice that"upgrading" is an important aspect of any real implementation of CL arrays.Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set of kinds of arrays that must be implemented (e.g, "int", "long int", "single","double" etc), and no others can exist.  In short, no one would want to gain portability at the expense of limiting the language to the architecturalfeatures of the hardware on which it was first implemented.It may also be the case that portability will be improved since the identity(typep (make-array N :element-type '<type>) '(array <type>)) will be observed.-------------------------------------------------------------------------------*start*01771 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 03 OCT 88 20:31:42 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 469995; Mon 3-Oct-88 23:31:26 EDTDate: Mon, 3 Oct 88 23:30 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)To: Jon L White <jonl@lucid.com>cc: masinter.pa, pedersen.pa, Moon@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <8810020558.AA09202@bhopal>Message-ID: <19881004033056.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoIn general I favor this, however I still insist that it is unacceptableto change the language so that ARRAY and COMPLEX become inconsistent intheir treatment of their element type specifier.  There is no reason notto add COMPLEX to the proposal and keep it consistent.Also I'm bothered by the use of the word "upgrade" inUPGRADE-ARRAY-ELEMENT-TYPE; I don't see how the dictionarydefinition of "upgrade" as increasing the rank, position, importance, quality,or value of something applies.  I think the word you mean is "canonicalize",however the concept we are really trying to convey is what element typethe particular implementation provides, so why not call itIMPLEMENTATION-ARRAY-ELEMENT-TYPE?  Alternatively, if by "upgrade"you meant to connote the idea of the least common supertype of allelement types that are implemented the same way, you could callit MAXIMAL-ARRAY-ELEMENT-TYPE.  I like IMPLEMENTATION- better.When I get back to a real terminal (probably tomorrow) I will checkover my other comments on this issue and make sure this versionsatisfies them.*start*10733 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 00:59:42 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Oct 88  00:59:05 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 05 OCT 88 00:57:24 PDTDate: 5 Oct 88 00:57 PDTFrom: masinter.paSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)To: cl-cleanup@sail.stanford.eduMessage-ID: <881005-005724-4531@Xerox>I realized that this only went to a couple of individuals rather than thewhole list.  As I would like it Ready for Release by last week, and Bensonasked for the latest version, I'm mailing this one out.In general, if you're having private discussions on an issue, please keepme informed so I know what's happening. I'd just as soon you cc'dcl-cleanup on issues. Please don't cc common-lisp and/or cl-editorial onthe same message unless it is absolutely necessary.!Issue:           ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:   Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291Category:      CHANGEEdit history:  Version 1, 13-May-88, JonL	       Version 2, 23-May-88, JonL  	        (typo fixes, comments from moon, rearrange some discussion)	       Version 3, 02-Jun-88, JonL  	        (flush alternate proposal ["flush-upgrading"]; consequently,	         move more of discussion back to discussion section.	       Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings) Problem description:CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination". Many people are confused by this situation, which may be one of the more insidious flaws in the current CL design. A consequence of this "flaw" is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have *none* of its values ever satisfy the typep predicate with that type-specifier.One type-specifier with this property is         <certain-type>  =  (ARRAY <element-type>) for various implementation dependent values of <element-type>.  Forexample,in  most implementations of CL, an array X created with  and element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy 	(TYPEP X '(ARRAY (SIGNED-BYTE 8))), or	(TYPEP X '(ARRAY T)) but (almost) never will it satisfy 	(TYPEP X '(ARRAY (SIGNED-BYTE 5))).This proposal suggests elimination of this distinction for the array typesARRAY,  SIMPLE-ARRAY, and VECTOR and their subtypes, by guaranteeing that arrays constructed with a specific element-type satisfy the typep predicatewith the derived array type-specifier, and by guaranteeing that subtypep reflect the type equivalences defined by the behavior of make-array.Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING)-- Introduce a function, UPGRADE-ARRAY-ELEMENT-TYPE of one argument, which    reveals how the given implementation treats a particular :element-type    argument to make-array.  Given a type-specifier <type1> as argument, it   returns a maximal type-specifier <type2> such that <type2> is the   actual specialized array element type used whenever <type1> is given as   an :element-type argument to MAKE-ARRAY.   Note that 	(upgrade-array-element-type '<type>) = 	    (array-element-type (make-array 0 :element-type '<type>))   for all type specifiers <type>.   -- Change typep and subtypep  so that:	    (TYPEP X '(ARRAY <type>))    is true if and only if 	    (TYPEP X `(ARRAY ,(UPGRADE-ARRAY-ELEMENT-TYPE '<type>)))   is true.-- Require that the resultant array-element-type from a call to make-array    is independent of any argument to make-array except for the:element-type   argument.  Thus upgrading, if done at all, must be done the same way for   non-simple and multi-dimensional arrays as it is for simple arrays.-- Eliminate references to the distinction between types "for declaration"and   "for discrimination" in the discussion of array element-types. Thiswould   include documentation patterened after CLtL:	a.) The discussion in section  4.5, p. 45 and 46	b.) p. 291, the sentence begining "This set may be larger than the set	requested when the array was created; for example . . ."Test cases:Let <aet-x> and <aet-y> be two distinct type specifiers that are definitelynottype-equivalent in a given implementation, but for which make-array willreturnan object of the same array type. Let this primitive type be  (ARRAY<aet-y>).This will be an implementation dependent search, but in everyimplementationthat the proposer has tested, there will be some such types; often,(SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, it should be true that:  (array-element-type (make-array 0 :element-type '<aet-x>))  ==> <aet-y>  (array-element-type (make-array 0 :element-type '<aet-y>))  ==> <aet-y>To eliminate the distinction between "for declaration" and "fordiscrimination"both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>))Since (array <aet-x>) and (array <aet-y>) are different names for exactlythe same set of objects, these names should be type-equivalent. In other words,both describe those arrays specialized to hold elements of type <aet-y>. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>))Additionally, to show that un-equivalent type-specifiers that are upgradedtothe same "element type" should be equivalent as element-type specifiers,thefollowing type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)           '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)           '(array <aet-y>))Rationale:This proposal legitimizes current practice, and removes the obscure andun-useful distinction between type-specifiers "for declaration" and "fordiscrimination" for array type-specifiers. The suggested changes to theinterpretation of array type-specifiers follow from defining typespecifiers as names for collections of objects, on typep being a set membership test, and subtypep a subset test on collections of objects.Current Practice:Every vendor's implementation that the proposer has queried does someamountof non-trivial "upgrading"; this includes Lucid, Vaxlisp, Symbolics, Franz,and Xerox. Most implementations fail tests [A] and [C] part 1, but passtests [A] and [C] part 2; this is a consequence of implementing the distinctionbetween "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it.Cost to Implementors:This proposal is an incompatible change to the current languagespecification,but only a small amount of work should be required in each vendor'simplementation of typep and subtypep.Cost to Users:Because of the prevalence of confusion in this area, it seems unlikely thatanyuser code will have to be changed.  In fact, it is more likely that some ofthevendors will cease to get bug reports about make-array returning a resultthatisn't of "the obvious type".Cost of non-adoption:Continuing confusion in the user community.Benefits:It will greatly reduce confusion in the user community.  The fact that(make-array <n> :element-type '<type>) frequently is not of type (array <type>) has been very confusing to almost everyone.   That is, in practice, the distinction between "for declaration" and "for discrimination" has been a disaster.Esthetics:Reducing the confusing distinction between type-specifiers "fordeclaration"and "for discrimination" is a simplifying step -- it is a much simpler ruleto state that the type-specifiers actually describe the collections of datathey purport to name.  Thus this is a step towards increased elegance.Discussion:To get a sense of how the community is confused, see the arpanet mailing list for Common Lisp, in a series of exchanges started on Thu, 17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com>under the subject line of "Types in CL".  Also see the exchange started Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu>under the subject line of "TYPEP warp implications".Many senior implementors at Lucid favor this proposal.  In network mail "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this proposal -- namely that upgrading should be continued, and that TYPEPshould be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already beenproposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  Idon't    see how to eliminate "array element type upgrading" without creating    more problems [than] we solve.  . . .     My conclusion [JonL's] is that it isn't array types that are wrong, itisthe    understanding of the meaning of TYPEP that is wrong.Semantically, upgrade-array-element-type is equivalent to:     (defun upgrade-array-element-type (element-type)       (array-element-type (make-array 0 :element-type element-type)))but it might not cons up the 0-element array first.  Also, the presence of this name, as a documented function in the language, would serve noticethat"upgrading" is an important aspect of any real implementation of CL arrays.Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set ofkinds of arrays that must be implemented (e.g, "int", "long int", "single","double" etc), and no others can exist.  In short, no one would want togain portability at the expense of limiting the language to the architecturalfeatures of the hardware on which it was first implemented.It may also be the case that portability will be improved since theidentity(typep (make-array N :element-type '<type>) '(array <type>)) will beobserved.There is a strong feeling that the COMPLEX type should have a similar handling as ARRAY type. This will be the subject of a separate cleanupissue.*start*03243 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 05 OCT 88 15:45:18 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03089g; Wed, 5 Oct 88 14:44:15 PSTReceived: by bhopal id AA02030g; Wed, 5 Oct 88 15:43:44 PDTDate: Wed, 5 Oct 88 15:43:44 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810052243.AA02030@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: masinter.pa, pedersen.pa, jonl@lucid.comIn-Reply-To: David A. Moon's message of Mon, 3 Oct 88 23:30 EDT <19881004033056.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)re: ... I still insist that it is unacceptable    to change the language so that ARRAY and COMPLEX become inconsistent in    their treatment of their element type specifier.  There is no reason not    to add COMPLEX to the proposal and keep it consistent.Here's the thing that keeps me from being as upset at this situationas you are -- there are *several* places where "objects" can be storedthat one may desire specialization a la array-element-type.  In particular Lucid's customers keep asking for this sort of thing in defstructs and flavor instances, and I notice with some chagrin the cleanup proposalon type-specialized lists (e.g. list-of-unsigned-byte-8 or whatever).COMPLEX is merely one of several object-containing data that might havethe declaration/discrimination schizophrenia -- and is probably onlyof interest at all because of the passing reference on CLtL p20 to the (remote?) possiblity of specialized numeric representations for thetwo complex components.Instead, the "Page 45" problem is in practice entirely an array problem-- I don't know of any implementations that do "upgrading" for anycomponents other than array elements; and CLtL P45-46 goes on and onat length about arrays without ever mentioning any other data typefor which this schizophrenia might be appropriate.  I have no objection to putting a "sleeping dog" in this proposal that simply says something like "we don't want any of the declaration/discrimination schizophrenia from CLtL p45 to be in the new standard".  I just don't want to have to cover all the ramifications of how some implementations *might* have gotten into trouble had they extended the schizophrenia to other types(but arrays need exhaustive discussion since virtually every implementationdoes indeed do the "upgrading".)re: Also I'm bothered by the use of the word "upgrade" in    UPGRADE-ARRAY-ELEMENT-TYPE; ... [maybe ] you meant to connote     the idea of the least common supertype of all element types that     are implemented the same way, you could call it ...Yes, of course that is what is intended.  Everyone on the CommonLisp mailing list who saw this term during the discussions of thepast year seem to have understood it this way also.  Since itseems to have the right connotations -- if not necessarily theright etymology -- I think it is as good as any other.  A secondterm just came to mind, if you really are opposed to "UPGRADE-" --how about 	IMPLEMENTED-ARRAY-ELEMENT-TYPEI'd really prefer that to	IMPLEMENTATION-ARRAY-ELEMENT-TYPE-- JonL --*start*01044 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 05 OCT 88 14:40:10 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 471288; Wed 5-Oct-88 17:40:22 EDTDate: Wed, 5 Oct 88 17:40 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)To: Masinter.PAcc: JonL@Lucid.COM, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <881005-141044-1342@Xerox>Message-ID: <881005174014.9.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 5 Oct 88 14:10 PDT    From: masinter.pa@Xerox.COM    Subject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)    [removed cl-cleanup]    Didn't you get version 5 from me?Yup, sorry about that. Either I had some stuff in a wrong mailbox fora short while or things weren't sorted by date, but indeed it is therenow so I'll have to go read up and find out how I stand. Thanks.*start*03724 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 01:25:12 PDTReceived: from YUKON.SCRC.Symbolics.COM (SCRC-YUKON.ARPA) by SAIL.Stanford.EDU with TCP; 6 Oct 88  01:25:26 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 396198; Thu 6-Oct-88 03:47:16 EDTDate: Thu, 6 Oct 88 03:44 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881005-005724-4531@Xerox>Message-ID: <881006034426.1.KMP@BOBOLINK.SCRC.Symbolics.COM>Ok, so I finally got caught up in my reading on this.  This is startingto look pretty good, but I've bot a bunch of picky little comments abouthow this should be projected ...    Date: 5 Oct 88 00:57 PDT    From: masinter.pa@Xerox.COM    ...    Issue:           ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS    ...    in  most implementations of CL, an array X created with  and element-type "an element-type" ?    ...    This proposal suggests elimination of this distinction for the array types    ARRAY,  SIMPLE-ARRAY, and VECTOR and their subtypes, by guaranteeing that     arrays constructed with a specific element-type satisfy the typep predicate    with the derived array type-specifier, and by guaranteeing that subtypep     reflect the type equivalences defined by the behavior of make-array.This paragraph doesn't belong in the problem description!    Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING)    -- Introduce a function, UPGRADE-ARRAY-ELEMENT-TYPE of one argument, which        reveals how the given implementation treats a particular :element-type        argument to make-array.  Given a type-specifier <type1> as argument, it       returns a maximal type-specifier <type2> such that <type2> is the       actual specialized array element type used whenever <type1> is given as       an :element-type argument to MAKE-ARRAY.   Note that 	    (upgrade-array-element-type '<type>) = 		(array-element-type (make-array 0 :element-type '<type>))       for all type specifiers <type>.   I haven't decided how I feel about this part. You could do the same byjust saying ``Introduce the concept of an `upgraded' array-element-type...''without actually providing the function that does the upgrading. But I guessI think providing the function is harmless. Presumably it will be there anyway.    ...    Test cases:    ...    Thus, in each case, it should be true that:I'd say "will happen to be true that", and emphasize that it's importantto know that this might happen -- but it's not something that should be particularly depended upon since obviously it will vary across implementations.    ...    That implies that the following set of tests should also be true:      [B]       (subtypep '(array <aet-x>) '(array <aet-y>))This is a feature and should be encouraged.       (subtypep '(array <aet-y>) '(array <aet-x>))This happens by accident and might not always happen. Again, document it, butmake sure it's clear that this is only something to `guard against' and notsomething to generally depend upon.    Additionally, to show that un-equivalent type-specifiers that are upgraded    to    the same "element type" should be equivalent as element-type specifiers,    the    following type tests should be true:      [C]       (typep (make-array 0 :element-type '<aet-y>)	       '(array <aet-x>))Accidental,etc.       (typep (make-array 0 :element-type '<aet-x>)	       '(array <aet-y>))Intentional,etc.*start*01322 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 13:33:23 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 5 Oct 88  11:45:32 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 471051; 5 Oct 88 14:43:24 EDTDate: Wed, 5 Oct 88 14:43 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 3)To: Jonl@Lucid.COMcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8806100921.AA27396@bhopal.lucid.com>Message-ID: <881005144312.6.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri, 10 Jun 88 02:21:54 PDT    From: Jon L White <edsel!jonl@labrea.stanford.edu>    To:   Moon@Stony-Brook.SCRC.Symbolics.COM    I intend to put some more work in on this proposal later today (Friday)    which will, among other things, incorporate some of your suggestion; but     others of your comments I'm not sure what to do with.    ...I have no record of any such proposal going out. I was going to try tobring myself up to date on this discussion but I'm going to put it offuntil I have an up-to-date copy of the proposal.*start*02413 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 13:33:39 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 5 Oct 88  12:20:59 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02779g; Wed, 5 Oct 88 11:18:36 PSTReceived: by bhopal id AA01503g; Wed, 5 Oct 88 12:18:13 PDTDate: Wed, 5 Oct 88 12:18:13 PDTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8810051918.AA01503@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 5 Oct 88 00:57 PDT <881005-005724-4531@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)I'm disturbed by the consensus that seems to have formed around theissue of upgrading array types.  In particular, I'd like someone topoint out why you can't simply require  (equal (array-element-type (make-array n :element-type x))        x)for all legal types x.As far as I can tell, all you have to do is store x in the headerinformation of the array, for later retrieval whenever type issuesmust be resolved.  Since the internal implementation type y may differ from x,UPGRADE-ARRAY-ELEMENT-TYPE becomes a merely informative routine thatusers can employ to understand the efficiency with with their code isimplemented.  I can think of no other valid reason for a user to careabout the internal representation, with the possible exception ofinterfacing to foreign code. In particular, any code that attempts to put objects of type y into anarray declared with type x is guaranteed to lose for someimplementation unless x and y are equivalent types.  This should bereflected in signalled errors when safety is high.  If someone wantsto put 213 into an array, then they had better have created it with anelement-type that is a super-type of (integer 213 213).(unsigned-byte 8) will work, (unsigned-byte 5) will not.I.e., with safety 3, setf should type check against the declared, notthe internal, type.  With safety 1 or 2, it might check against theinternal type (presumably a cheaper test).This is extremely simple to understand and to implement.  I think anyalternative to what I am presenting here adds enough complexity andnon-portability to the language to require a very solid and explicit justification.  jlm*start*00570 00024 US Date:  5 Oct 88 14:13 PDTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)In-reply-to: Jim McDonald <jlm@lucid.com>'s message of Wed, 5 Oct 88 12:18:13 PDTTo: Jim McDonald <jlm@lucid.com>cc: masinter.pa, cl-cleanup@sail.stanford.edu"I'd like someone topoint out why you can't simply require  (equal (array-element-type (make-array n :element-type x))        x)for all legal types x."a) nobody does itb) its not very usefulI thought this was in the discussion section, but it seems to be hidden.*start*02067 00024 US Date:  6 Oct 88 13:38 PDTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)In-reply-to: Jim McDonald <jlm@lucid.com>'s message of Thu, 6 Oct 88 13:12:35 PDTTo: Jim McDonald <jlm@lucid.com>cc: masinter.pa, cl-cleanup@sail.stanford.eduSorry that I was so terse. Call the proposal to make arrays remember their element types REMEMBER-TYPE.I had also proposed REMEMBER-TYPE at one time. This is certainly legal in current Common Lisp -- any implementation could currently do this and conform to CLtL. However, none do. The weight of current practice is a useful indication of the well-considered thoughts of the designers of current implementations; in several areas, implementations have chosen to diverge from CLtL, exactly because CLtL is "buggy". So, the justifcation that "nobody does it" is that there is evidence that no Common Lisp implementor so far has thought that it would be useful, consistent, cleaner.Secondly, there is no simple canonicalization for type specifiers. Currently, I can reasonably expect that(equal (array-element-type (make-array n :element-type '(integer -129 128)))    (array-element-type (make-array n :element-type '(signed-byte 8))))yet your proposal to require that   (equal (array-element-type (make-array n :element-type x))            x)    for all legal types x."would violate that.It was argued that array element types are an important part of the underlying implementation, their visibility in a portable way is useful.It was argued that REMEMBER-TYPE would add an additional storage burden that would be a cumbersome implementation burden.REMEMBER-TYPE would make the language  easier to document and understand only if there were some reasonable way to handle the canonicalization of types mentioned above.I'm having trouble with the issues of "obscure bugs" and "increases portability". Perhaps I'm too close to the subject, but could you supply some examples of obscure bugs or non-portable programs which REMEMBER-TYPE would address?*start*01538 00024 USaReturn-Path: <jlm@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 06 OCT 88 13:13:58 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00485g; Thu, 6 Oct 88 13:14:16 PDTReceived: by bhopal id AA05594g; Thu, 6 Oct 88 13:12:35 PDTDate: Thu, 6 Oct 88 13:12:35 PDTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8810062012.AA05594@bhopal>To: masinter.paCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 5 Oct 88 14:13 PDT <881005-141417-1355@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)    "I'd like someone to    point out why you can't simply require          (equal (array-element-type (make-array n :element-type x))            x)    for all legal types x."    a) nobody does itI believe there is precedent for correcting buggy behavior, even whenit is shared by all implementations.Why is it so important to force to the user to be concerned with theunderlying implementation of arrays?  Why are we so unwilling tolet an array remember that, e.g., its elements all satisfy PRIMEP?I can't see any logical reason.  Is there some historical reason, orhave we arrived at the current state entirely by accident?    b) its not very usefulI disagree.  It makes the language easier to document and understand,removes a source of obscure bugs, and increases portability.  Whatmore do you want?      I thought this was in the discussion section, but it seems to be hidden.  jlm*start*02429 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 13:42:55 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Oct 88  13:42:54 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 06 OCT 88 13:38:20 PDTDate: 6 Oct 88 13:38 PDTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)In-reply-to: Jim McDonald <jlm@lucid.com>'s message of Thu, 6 Oct 88 13:12:35 PDTTo: Jim McDonald <jlm@lucid.com>cc: masinter.pa, cl-cleanup@sail.stanford.eduMessage-ID: <881006-133820-1336@Xerox>Sorry that I was so terse. Call the proposal to make arrays remember theirelement types REMEMBER-TYPE.I had also proposed REMEMBER-TYPE at one time. This is certainly legal in current Common Lisp -- any implementation couldcurrently do this and conform to CLtL. However, none do. The weight ofcurrent practice is a useful indication of the well-considered thoughts ofthe designers of current implementations; in several areas, implementationshave chosen to diverge from CLtL, exactly because CLtL is "buggy". So, thejustifcation that "nobody does it" is that there is evidence that no CommonLisp implementor so far has thought that it would be useful, consistent,cleaner.Secondly, there is no simple canonicalization for type specifiers.Currently, I can reasonably expect that(equal (array-element-type (make-array n :element-type '(integer -129128)))    (array-element-type (make-array n :element-type '(signed-byte 8))))yet your proposal to require that   (equal (array-element-type (make-arrayn :element-type x))            x)    for all legal types x."would violate that.It was argued that array element types are an important part of theunderlying implementation, their visibility in a portable way is useful.It was argued that REMEMBER-TYPE would add an additional storage burdenthat would be a cumbersome implementation burden.REMEMBER-TYPE would make the language  easier to document and understandonly if there were some reasonable way to handle the canonicalization oftypes mentioned above.I'm having trouble with the issues of "obscure bugs" and "increasesportability". Perhaps I'm too close to the subject, but could you supplysome examples of obscure bugs or non-portable programs which REMEMBER-TYPEwould address?*start*13504 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 19:59:27 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Oct 88  19:58:04 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472326; Thu 6-Oct-88 22:49:32 EDTDate: Thu, 6 Oct 88 22:49 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 6)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881005-005724-4531@Xerox>Message-ID: <19881007024901.2.MOON@EUPHRATES.SCRC.Symbolics.COM>I mostly agree with version 5, but found that it didn't address all ofmy concerns presented in June and in private discussions with JonL.  Tobe constructive, I've made a new version of the proposal, instead ofjust commenting.  The changes are: - fix typographical errors - use the same terminology as CLtL as much as possible - cover SUBTYPEP in the proposal, not just in the test case - cover all cases of declaration vs. discrimination (i.e. add COMPLEX) - add a complete list of affected type-specifiers - change the name of UPGRADE-ARRAY-ELEMENT-TYPE - change the presentation of the proposal to make it easier to understand - numbered the proposal points, and added a summary of them, to   make the proposal easier to discussIssue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291               The type-specifiers ARRAY, COMPLEX, SIMPLE-ARRAY, and VECTORCategory:      CHANGEEdit history:  Version 1, 13-May-88, JonL               Version 2, 23-May-88, JonL                  (typo fixes, comments from moon, rearrange some discussion)               Version 3, 02-Jun-88, JonL                  (flush alternate proposal ["flush-upgrading"]; consequently,                 move more of discussion back to discussion section.               Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings)               (Version 5 edit history missing)               Version 6, 6-Oct-88, Moon                (fix typos, cover subtypep explicitly, add complex,                 change name of UPGRADE-ARRAY-ELEMENT-TYPE)Problem description: CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination".  Many people are confused by this situation, which may be one of the more insidious flaws in the current CL design.  A consequence of this "flaw" is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have *none* of its values ever satisfy the typep predicate with that type-specifier. One type-specifier with this property is           (ARRAY <element-type>)  for various implementation dependent values of <element-type>.  For example, in most implementations of CL, an array X created with an element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy        (TYPEP X '(ARRAY (SIGNED-BYTE 8))), or        (TYPEP X '(ARRAY T))  but (almost) never will it satisfy         (TYPEP X '(ARRAY (SIGNED-BYTE 5))).Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING) Eliminate the distinction between type-specifiers "for declaration" and "for discrimination".  Change the meaning of the <element-type> in the ARRAY type-specifier and its subtypes, and in the COMPLEX type-specifier, to be the same for TYPEP and SUBTYPEP as for TYPE declarations. Specify how SUBTYPEP behaves on these type-specifiers.  Add a function to provide access to the implementation-dependent set of array types and another function to provide access to the implementation-dependent set of complex number types. 1. Eliminate references to the distinction between types "for declaration" and "for discrimination" in the discussion of array and complex type-specifiers. This would include documentation patterned after CLtL:        a.) The discussion in section 4.5, pp. 45-7        b.) p. 291, the sentence begining "This set may be larger than the set        requested when the array was created; for example . . ." Instead, (ARRAY <type>) always means all arrays that can result by specifying <type> as the :ELEMENT-TYPE argument to the function MAKE-ARRAY, and (COMPLEX <type>) always means all complex numbers that can result by giving numbers of type <type> to the function COMPLEX, plus all other complex numbers of the same specialized representation. 2. Change the meaning of (TYPEP <x> '(ARRAY <type>)) to be true if and only if <x> is an array of the most specialized representation capable of holding elements of type <type>.  In other words, it is true if and only if <x> is an array and (ARRAY-ELEMENT-TYPE <x>) is the same type-specifier as (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE <type>)). Do the same for SIMPLE-ARRAY and VECTOR. 3. Change the meaning of (TYPEP <x> '(COMPLEX <type>)) to be true if and only if <x> is a complex number of the most specialized representation capable of holding components of type <type>, or <x> is of any subtype of that representation. 4. Define that for all type-specifiers <type1> and <type2>, other than *, (ARRAY <type1>) and (ARRAY <type2>) are either equivalent or disjoint, depending on whether they use the same specialized representation or distinct representations.  This defines the behavior of SUBTYPEP. 5. Define that for all type-specifiers <type1> and <type2>, other than *, (SUBTYPEP '(COMPLEX <type1>) '(COMPLEX <type2>)) is T T if they use the same specialized representation, T T if they use distinct specialized representations but (SUBTYPEP '<type1> '<type2>) is true, and NIL T otherwise. 6. Require that the resultant ARRAY-ELEMENT-TYPE from a call to MAKE-ARRAY is independent of any argument to MAKE-ARRAY except for the :ELEMENT-TYPE argument.  Thus the set of specialized array representations must be consistent between single-dimensional and multi-dimensional, simple and non-simple, short and long arrays. 7. Add the function IMPLEMENTATION-ARRAY-ELEMENT-TYPE which returns the same result as    (DEFUN IMPLEMENTATION-ARRAY-ELEMENT-TYPE (TYPE)      (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE))) The type specifiers (ARRAY <type1>) and (ARRAY <type2>), where neither <type1> nor <type2> is *, are equivalent if <type1> and <type2> produce the same value from IMPLEMENTATION-ARRAY-ELEMENT-TYPE, and disjoint otherwise. 8. Add the function IMPLEMENTATION-COMPLEX-COMPONENT-TYPE which returns the component type of the most specialized complex number representation that can hold components of the given type.Test cases: Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type.  This will be an implementation dependent search, but in every implementation that the proposer has tested, there will be some such types; often, (SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, both of the following forms return T T:  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))            (array-element-type (make-array 0 :element-type '<aet-y>)))  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))            (array-element-type (make-array 0 :element-type '<aet-x>))) To eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>)) Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>)) Additionally, to show that un-equivalent type-specifiers that use the same specialized array type should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-y>))Rationale: This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination".  The suggested changes to the interpretation of array and complex type-specifiers follow from defining type-specifiers as names for collections of objects, on TYPEP being a set membership test, and SUBTYPEP a subset test on collections of objects. The small differences between the specification for ARRAY and the specification for COMPLEX are necessary because there is no MAKE-COMPLEX function, thus in the case of COMPLEX we must refer to the type of the components, and a number can be a member of more than one type.  Thus     (SUBTYPEP '(COMPLEX SINGLE-FLOAT) '(COMPLEX FLOAT)) is true in all implementations, but      (SUBTYPEP '(ARRAY SINGLE-FLOAT) '(ARRAY FLOAT)) is only true in implementations that do not have a specialized array representation that can hold single-floats but not other floats.Current Practice: Every vendor's implementation that the proposer has queried has a finite set of specialized array representations, such that two non-equivalent element types can be found that use the same specialized array representation; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it.Cost to Implementors: This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of typep and subtypep.Cost to Users: Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about make-array returning a result that isn't of "the obvious type".  Since the change is incompatible, some user code might have to be changed.Cost of non-adoption: Continuing confusion in the user community.Benefits: It will greatly reduce confusion in the user community.  The fact that (make-array <n> :element-type '<type>) frequently is not of type  (array <type>) has been very confusing to almost everyone.  That is, in practice, the distinction between "for declaration" and "for discrimination" has been a disaster.Esthetics: Reducing the confusing distinction between type-specifiers "for declaration" and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of data they purport to name.  Thus this is a step towards increased elegance.Discussion: To get a sense of how the community is confused, see the arpanet mailing  list for Common Lisp, in a series of exchanges started on Thu,  17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com> under the subject line of "Types in CL".  Also see the exchange started  Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu> under the subject line of "TYPEP warp implications".  Many senior implementors at Lucid favor this proposal.  In network mail  "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this  proposal -- namely that upgrading should be continued, and that TYPEP should be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already been    proposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  I    don't see how to eliminate "array element type upgrading" without    creating more problems [than] we solve.  . . .    My conclusion [JonL's] is that it isn't array types that are wrong,    it is the understanding of the meaning of TYPEP that is wrong. Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set of kinds of arrays that must be implemented (e.g, "int", "long int", "single", "double" etc), and no others can exist.  In short, no one would want to gain portability at the expense of limiting the language to the architectural features of the hardware on which it was first implemented.  It may also be the case that portability will be improved since the identity (typep (make-array N :element-type '<type>) '(array <type>)) will be observed.*start*03156 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 07 OCT 88 13:03:17 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472725; Fri 7-Oct-88 16:02:52 EDTDate: Fri, 7 Oct 88 16:02 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)To: Jon L White <jonl@lucid.com>cc: masinter.pa, pedersen.paIn-Reply-To: <8810052243.AA02030@bhopal>Message-ID: <19881007200231.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI didn't see this message before sending my proposed revisionof ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, because the messagewas not sent to the mailing list, only to individuals.    Date: Wed, 5 Oct 88 15:43:44 PDT    From: Jon L White <jonl@lucid.com>    re: ... I still insist that it is unacceptable	to change the language so that ARRAY and COMPLEX become inconsistent in	their treatment of their element type specifier.  There is no reason not	to add COMPLEX to the proposal and keep it consistent.    Here's the thing that keeps me from being as upset at this situation    as you are -- there are *several* places where "objects" can be stored    that one may desire specialization a la array-element-type.  In particular     Lucid's customers keep asking for this sort of thing in defstructs and     flavor instances, and I notice with some chagrin the cleanup proposal    on type-specialized lists (e.g. list-of-unsigned-byte-8 or whatever).I don't see how this is relevant.  People making future changes to CommonLisp are of course obligated to make their changes in a way that's consistentwith what's there now, and when we make our changes we can only take intoaccount what's there now, not what someone might change in the future.  Rightnow Common Lisp only uses "declaration versus discrimination" in connectionwith ARRAY and COMPLEX.    COMPLEX is merely one of several object-containing data that might have    the declaration/discrimination schizophrenia ....Never mind "might".  Only COMPLEX, ARRAY, SIMPLE-ARRAY, and VECTOR do.    re: Also I'm bothered by the use of the word "upgrade" in	UPGRADE-ARRAY-ELEMENT-TYPE; ... [maybe ] you meant to connote 	the idea of the least common supertype of all element types that 	are implemented the same way, you could call it ...    Yes, of course that is what is intended.  Everyone on the Common    Lisp mailing list who saw this term during the discussions of the    past year seem to have understood it this way also.  Since it    seems to have the right connotations -- if not necessarily the    right etymology -- I think it is as good as any other.  A second    term just came to mind, if you really are opposed to "UPGRADE-" --    how about 	    IMPLEMENTED-ARRAY-ELEMENT-TYPE    I'd really prefer that to	    IMPLEMENTATION-ARRAY-ELEMENT-TYPEEither of these names would be okay with me.  I would have includedthe one you proposed in my revision of the proposal if I had seenthis message in time.*start*00836 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 18:02:19 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  18:02:12 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472939; Fri 7-Oct-88 21:00:49 EDTDate: Fri, 7 Oct 88 21:00 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 6)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <19881007024901.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <881007210033.6.KMP@BOBOLINK.SCRC.Symbolics.COM>This looks good to me.*start*02543 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 07 OCT 88 18:29:27 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01042g; Fri, 7 Oct 88 18:28:13 PDTReceived: by bhopal id AA02590g; Fri, 7 Oct 88 18:26:34 PDTDate: Fri, 7 Oct 88 18:26:34 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080126.AA02590@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.edu, masinter.pa, pedersen.paIn-Reply-To: David A. Moon's message of Fri, 7 Oct 88 16:02 EDT <19881007200231.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)re: [JonL] Here's the thing that keeps me from being as upset at this situation	as you are -- there are *several* places where "objects" can be stored	that one may desire specialization a la array-element-type.  In particular 	Lucid's customers keep asking for this sort of thing in defstructs and 	flavor instances, and I notice with some chagrin the cleanup proposal	on type-specialized lists (e.g. list-of-unsigned-byte-8 or whatever).    Right now Common Lisp only uses "declaration versus discrimination" in     connection  with ARRAY and COMPLEX.Had we thought of it before, this issue should have been called TYPE-SPECIFIER-SPECIALIZATION:UNIFY-DECLARATION.   Your additionof the COMPLEX stuff is ok by me, since it doesn't detract from thefixup of arrays, nor from similar directions in the future.But, in the future, we may have to worry about any lurking remnants of the "schizophrenia"; I think it is more pervasive, in implicit ways, than  the explicit losage in the section 4.5.re: I didn't see this message before sending my proposed revision    of ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, because the message    was not sent to the mailing list, only to individuals.    . . .     	Date: Wed, 5 Oct 88 15:43:44 PDT	From: Jon L White <jonl@lucid.com>        . . . 	         IMPLEMENTED-ARRAY-ELEMENT-TYPE	I'd really prefer that to		IMPLEMENTATION-ARRAY-ELEMENT-TYPE    [Moon] Either of these names would be okay with me.  I would have     included the one you proposed in my revision of the proposal if I had     seen this message in time.If you don't mind, then, I'll change it to IMPLEMENTED-ARRAY-ELEMENT-TYPE, and  analogously will change IMPLEMENTATION-COMPLEX-COMPONENT-TYPE toIMPLEMENTED-COMPLEX-PART-TYPE  [See CLtL, p220 and p47 where the "elements"of a complex number are called "parts"]-- JonL --*start*02688 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 20:41:17 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  20:41:26 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01042g; Fri, 7 Oct 88 18:28:13 PDTReceived: by bhopal id AA02590g; Fri, 7 Oct 88 18:26:34 PDTDate: Fri, 7 Oct 88 18:26:34 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080126.AA02590@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.edu, masinter.pa, pedersen.paIn-Reply-To: David A. Moon's message of Fri, 7 Oct 88 16:02 EDT <19881007200231.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 5)re: [JonL] Here's the thing that keeps me from being as upset at this situation	as you are -- there are *several* places where "objects" can be stored	that one may desire specialization a la array-element-type.  In particular 	Lucid's customers keep asking for this sort of thing in defstructs and 	flavor instances, and I notice with some chagrin the cleanup proposal	on type-specialized lists (e.g. list-of-unsigned-byte-8 or whatever).    Right now Common Lisp only uses "declaration versus discrimination" in     connection  with ARRAY and COMPLEX.Had we thought of it before, this issue should have been called TYPE-SPECIFIER-SPECIALIZATION:UNIFY-DECLARATION.   Your additionof the COMPLEX stuff is ok by me, since it doesn't detract from thefixup of arrays, nor from similar directions in the future.But, in the future, we may have to worry about any lurking remnants of the "schizophrenia"; I think it is more pervasive, in implicit ways, than  the explicit losage in the section 4.5.re: I didn't see this message before sending my proposed revision    of ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, because the message    was not sent to the mailing list, only to individuals.    . . .     	Date: Wed, 5 Oct 88 15:43:44 PDT	From: Jon L White <jonl@lucid.com>        . . . 	         IMPLEMENTED-ARRAY-ELEMENT-TYPE	I'd really prefer that to		IMPLEMENTATION-ARRAY-ELEMENT-TYPE    [Moon] Either of these names would be okay with me.  I would have     included the one you proposed in my revision of the proposal if I had     seen this message in time.If you don't mind, then, I'll change it to IMPLEMENTED-ARRAY-ELEMENT-TYPE, and  analogously will change IMPLEMENTATION-COMPLEX-COMPONENT-TYPE toIMPLEMENTED-COMPLEX-PART-TYPE  [See CLtL, p220 and p47 where the "elements"of a complex number are called "parts"]-- JonL --*start*14197 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 23:43:24 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  23:43:05 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01290g; Fri, 7 Oct 88 23:41:51 PDTReceived: by bhopal id AA03475g; Fri, 7 Oct 88 23:40:12 PDTDate: Fri, 7 Oct 88 23:40:12 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080640.AA03475@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 7)Changed names in accord with previous msg.Use "type-equivalent" rather than "same type specifier" in item 2, since   this isn't dependent on whether (unsigned-byte 8) or (mod 256) is used.Fixed up a couple of awkward wordings.Remaining questions for Moon: -- Item 3 in the proposal has something odd with the description of <x>,    and I'm not sure I know what you really mean.  It says something like    "... iff <x> is a complex number of a {certain} representation, or     if <x> is of any subtype of that representation."  What would this     mean for an implementation that has, say, two distinct specialized     representations for complex part types -- (signed-byte 8) and    (signed-byte 32) -- what should the values of the following be:       (typep #c(15 99) '(complex (signed-byte 8))  ==> ??       (typep #c(15 99) '(complex (signed-byte 32)) ==> ??    Or, did you intend item 3 to depend on the understanding in the    succeeding item 5? -- The second paragraph of the Rationale didn't parse (as English); I    made a stab a breaking the run-on sentence into two, but you ought    to take another look at it.-- JonL --!Issue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291               The type-specifiers ARRAY, COMPLEX, SIMPLE-ARRAY, and VECTORCategory:      CHANGEEdit history:  Version 1, 13-May-88, JonL               Version 2, 23-May-88, JonL                  (typo fixes, comments from moon, rearrange some discussion)               Version 3, 02-Jun-88, JonL                  (flush alternate proposal ["flush-upgrading"]; consequently,                 move more of discussion back to discussion section.               Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings)               (Version 5 edit history missing)               Version 6, 6-Oct-88, Moon                (fix typos, cover subtypep explicitly, add complex,                 change name of UPGRADE-ARRAY-ELEMENT-TYPE)               Version 7, 7-Oct-88, JonL (more name and wording changes).Problem description: CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination".  Many people are confused by this situation, which may be one of the more insidious flaws in the current CL design.  A consequence of this "flaw" is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have *none* of its values ever satisfy the typep predicate with that type-specifier. One type-specifier with this property is           (ARRAY <element-type>)  for various implementation dependent values of <element-type>.  For example, in most implementations of CL, an array X created with an element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy        (TYPEP X '(ARRAY (SIGNED-BYTE 8))), or        (TYPEP X '(ARRAY T))  but (almost) never will it satisfy         (TYPEP X '(ARRAY (SIGNED-BYTE 5))).Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING) Eliminate the distinction between type-specifiers "for declaration" and "for discrimination".  Change the meaning of the <element-type> in the ARRAY type-specifier and its subtypes, and in the COMPLEX type-specifier, to be the same for TYPEP and SUBTYPEP as for TYPE declarations. Specify how SUBTYPEP behaves on these type-specifiers.  Add a function to provide access to the implementation-dependent set of array types and another function to provide access to the implementation-dependent set of complex number types. 1. Eliminate references to the distinction between types "for declaration" and "for discrimination" in the discussion of array and complex type-specifiers. This would include documentation patterned after CLtL:        a.) The discussion in section 4.5, pp. 45-7        b.) p. 291, the sentence begining "This set may be larger than the set        requested when the array was created; for example . . ." Instead, (ARRAY <type>) always means all arrays that can result by specifying <type> as the :ELEMENT-TYPE argument to the function MAKE-ARRAY, and (COMPLEX <type>) always means all complex numbers that can result by giving numbers of type <type> to the function COMPLEX, plus all other complex numbers of the same specialized representation. 2. Change the meaning of (TYPEP <x> '(ARRAY <type>)) to be true if and only if <x> is an array of the most specialized representation capable of holding elements of type <type>.  In other words, it is true if and only if <x> is an array and (ARRAY-ELEMENT-TYPE <x>) is type-equivalent to (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE <type>)). Do the same for SIMPLE-ARRAY and VECTOR. 3. Change the meaning of (TYPEP <x> '(COMPLEX <type>)) to be true if and only if <x> is a complex number of the most specialized representation capable of holding parts of type <type>,  or if <x> is of  any subtype of that representation.  Both the real and imaginary parts must satisy (TYPEP <real-or-imag-part> '<type>).  4. Define that for all type-specifiers <type1> and <type2>, other than *, (ARRAY <type1>) and (ARRAY <type2>) are either equivalent or disjoint, depending on whether they use the same specialized representation or distinct representations.  This defines the behavior of SUBTYPEP. 5. Define that for all type-specifiers <type1> and <type2>, other than *, (SUBTYPEP '(COMPLEX <type1>) '(COMPLEX <type2>)) is T T if they use the same specialized representation, T T if they use distinct specialized representations but (SUBTYPEP '<type1> '<type2>) is true, and NIL T otherwise. 6. Require that the resultant ARRAY-ELEMENT-TYPE from a call to MAKE-ARRAY is independent of any argument to MAKE-ARRAY except for the :ELEMENT-TYPE argument.  Thus the set of specialized array representations must be consistent between single-dimensional and multi-dimensional, simple and non-simple, short and long arrays. 7. Add the function IMPLEMENTED-ARRAY-ELEMENT-TYPE of one argument  which returns the same result as:    (DEFUN IMPLEMENTED-ARRAY-ELEMENT-TYPE (TYPE)      (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE))) The type specifiers (ARRAY <type1>) and (ARRAY <type2>), where neither <type1> nor <type2> is *, are equivalent if <type1> and <type2> produce the same value from IMPLEMENTED-ARRAY-ELEMENT-TYPE, and disjoint otherwise. 8. Add the function IMPLEMENTED-COMPLEX-PART-TYPE of one argument  which  returns the part type of the most specialized complex number representation that can hold parts of the given argument type.Test cases: Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type.  This will be an implementation dependent search, but in every implementation that the proposer has tested, there will be some such types; often, (SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, both of the following forms return T T:  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))            (array-element-type (make-array 0 :element-type '<aet-y>)))  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))            (array-element-type (make-array 0 :element-type '<aet-x>))) To eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>)) Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>)) Additionally, to show that un-equivalent type-specifiers that use the same specialized array type should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-y>))Rationale: This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination".  The suggested changes to the interpretation of array and complex type-specifiers follow from defining type-specifiers as names for collections of objects, on TYPEP being a set membership test, and SUBTYPEP a subset test on collections of objects. The small differences between the specification for ARRAY and the specification for COMPLEX are necessary because there is no creation function for complexes which allows one to specify the resultant type independently of the types of the parts.  Thus in the case of COMPLEX we must refer to the type of the two parts, and to the fact that a  number can be a member of more than one type.  Note that:     (SUBTYPEP '(COMPLEX SINGLE-FLOAT) '(COMPLEX FLOAT)) is true in all implementations, but      (SUBTYPEP '(ARRAY SINGLE-FLOAT) '(ARRAY FLOAT)) is only true in implementations that do not have a specialized array representation that can hold single-floats but not other floats.Current Practice: Every vendor's implementation that the proposer has queried has a finite set of specialized array representations, such that two non-equivalent element types can be found that use the same specialized array representation; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it. No vendor that the proposer has queried has any specialized representation for complexes.Cost to Implementors: This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of typep and subtypep.Cost to Users: Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about make-array returning a result that isn't of "the obvious type".  Since the change is incompatible, some user code might have to be changed.Cost of non-adoption: Continuing confusion in the user community.Benefits: It will greatly reduce confusion in the user community.  The fact that (make-array <n> :element-type '<type>) frequently is not of type  (array <type>) has been very confusing to almost everyone.  That is, in practice, the distinction between "for declaration" and "for discrimination" has been a disaster.Esthetics: Reducing the confusing distinction between type-specifiers "for declaration" and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of data they purport to name.  Thus this is a step towards increased elegance.Discussion: To get a sense of how the community is confused, see the arpanet mailing  list for Common Lisp, in a series of exchanges started on Thu,  17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com> under the subject line of "Types in CL".  Also see the exchange started  Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu> under the subject line of "TYPEP warp implications".  Many senior implementors at Lucid favor this proposal.  In network mail  "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this  proposal -- namely that upgrading should be continued, and that TYPEP should be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already been    proposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  I    don't see how to eliminate "array element type upgrading" without    creating more problems [than] we solve.  . . .    My conclusion [JonL's] is that it isn't array types that are wrong,    it is the understanding of the meaning of TYPEP that is wrong. Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set of kinds of arrays that must be implemented (e.g, "int", "long int", "single", "double" etc), and no others can exist.  In short, no one would want to gain portability at the expense of limiting the language to the architectural features of the hardware on which it was first implemented.  It may also be the case that portability will be improved since the identity (typep (make-array N :element-type '<type>) '(array <type>)) will be observed.*start*14197 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 23:43:24 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  23:43:05 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01290g; Fri, 7 Oct 88 23:41:51 PDTReceived: by bhopal id AA03475g; Fri, 7 Oct 88 23:40:12 PDTDate: Fri, 7 Oct 88 23:40:12 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080640.AA03475@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (version 7)Changed names in accord with previous msg.Use "type-equivalent" rather than "same type specifier" in item 2, since   this isn't dependent on whether (unsigned-byte 8) or (mod 256) is used.Fixed up a couple of awkward wordings.Remaining questions for Moon: -- Item 3 in the proposal has something odd with the description of <x>,    and I'm not sure I know what you really mean.  It says something like    "... iff <x> is a complex number of a {certain} representation, or     if <x> is of any subtype of that representation."  What would this     mean for an implementation that has, say, two distinct specialized     representations for complex part types -- (signed-byte 8) and    (signed-byte 32) -- what should the values of the following be:       (typep #c(15 99) '(complex (signed-byte 8))  ==> ??       (typep #c(15 99) '(complex (signed-byte 32)) ==> ??    Or, did you intend item 3 to depend on the understanding in the    succeeding item 5? -- The second paragraph of the Rationale didn't parse (as English); I    made a stab a breaking the run-on sentence into two, but you ought    to take another look at it.-- JonL --!Issue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291               The type-specifiers ARRAY, COMPLEX, SIMPLE-ARRAY, and VECTORCategory:      CHANGEEdit history:  Version 1, 13-May-88, JonL               Version 2, 23-May-88, JonL                  (typo fixes, comments from moon, rearrange some discussion)               Version 3, 02-Jun-88, JonL                  (flush alternate proposal ["flush-upgrading"]; consequently,                 move more of discussion back to discussion section.               Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings)               (Version 5 edit history missing)               Version 6, 6-Oct-88, Moon                (fix typos, cover subtypep explicitly, add complex,                 change name of UPGRADE-ARRAY-ELEMENT-TYPE)               Version 7, 7-Oct-88, JonL (more name and wording changes).Problem description: CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination".  Many people are confused by this situation, which may be one of the more insidious flaws in the current CL design.  A consequence of this "flaw" is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have *none* of its values ever satisfy the typep predicate with that type-specifier. One type-specifier with this property is           (ARRAY <element-type>)  for various implementation dependent values of <element-type>.  For example, in most implementations of CL, an array X created with an element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy        (TYPEP X '(ARRAY (SIGNED-BYTE 8))), or        (TYPEP X '(ARRAY T))  but (almost) never will it satisfy         (TYPEP X '(ARRAY (SIGNED-BYTE 5))).Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING) Eliminate the distinction between type-specifiers "for declaration" and "for discrimination".  Change the meaning of the <element-type> in the ARRAY type-specifier and its subtypes, and in the COMPLEX type-specifier, to be the same for TYPEP and SUBTYPEP as for TYPE declarations. Specify how SUBTYPEP behaves on these type-specifiers.  Add a function to provide access to the implementation-dependent set of array types and another function to provide access to the implementation-dependent set of complex number types. 1. Eliminate references to the distinction between types "for declaration" and "for discrimination" in the discussion of array and complex type-specifiers. This would include documentation patterned after CLtL:        a.) The discussion in section 4.5, pp. 45-7        b.) p. 291, the sentence begining "This set may be larger than the set        requested when the array was created; for example . . ." Instead, (ARRAY <type>) always means all arrays that can result by specifying <type> as the :ELEMENT-TYPE argument to the function MAKE-ARRAY, and (COMPLEX <type>) always means all complex numbers that can result by giving numbers of type <type> to the function COMPLEX, plus all other complex numbers of the same specialized representation. 2. Change the meaning of (TYPEP <x> '(ARRAY <type>)) to be true if and only if <x> is an array of the most specialized representation capable of holding elements of type <type>.  In other words, it is true if and only if <x> is an array and (ARRAY-ELEMENT-TYPE <x>) is type-equivalent to (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE <type>)). Do the same for SIMPLE-ARRAY and VECTOR. 3. Change the meaning of (TYPEP <x> '(COMPLEX <type>)) to be true if and only if <x> is a complex number of the most specialized representation capable of holding parts of type <type>,  or if <x> is of  any subtype of that representation.  Both the real and imaginary parts must satisy (TYPEP <real-or-imag-part> '<type>).  4. Define that for all type-specifiers <type1> and <type2>, other than *, (ARRAY <type1>) and (ARRAY <type2>) are either equivalent or disjoint, depending on whether they use the same specialized representation or distinct representations.  This defines the behavior of SUBTYPEP. 5. Define that for all type-specifiers <type1> and <type2>, other than *, (SUBTYPEP '(COMPLEX <type1>) '(COMPLEX <type2>)) is T T if they use the same specialized representation, T T if they use distinct specialized representations but (SUBTYPEP '<type1> '<type2>) is true, and NIL T otherwise. 6. Require that the resultant ARRAY-ELEMENT-TYPE from a call to MAKE-ARRAY is independent of any argument to MAKE-ARRAY except for the :ELEMENT-TYPE argument.  Thus the set of specialized array representations must be consistent between single-dimensional and multi-dimensional, simple and non-simple, short and long arrays. 7. Add the function IMPLEMENTED-ARRAY-ELEMENT-TYPE of one argument  which returns the same result as:    (DEFUN IMPLEMENTED-ARRAY-ELEMENT-TYPE (TYPE)      (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE))) The type specifiers (ARRAY <type1>) and (ARRAY <type2>), where neither <type1> nor <type2> is *, are equivalent if <type1> and <type2> produce the same value from IMPLEMENTED-ARRAY-ELEMENT-TYPE, and disjoint otherwise. 8. Add the function IMPLEMENTED-COMPLEX-PART-TYPE of one argument  which  returns the part type of the most specialized complex number representation that can hold parts of the given argument type.Test cases: Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type.  This will be an implementation dependent search, but in every implementation that the proposer has tested, there will be some such types; often, (SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, both of the following forms return T T:  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))            (array-element-type (make-array 0 :element-type '<aet-y>)))  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))            (array-element-type (make-array 0 :element-type '<aet-x>))) To eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>)) Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>)) Additionally, to show that un-equivalent type-specifiers that use the same specialized array type should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-y>))Rationale: This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination".  The suggested changes to the interpretation of array and complex type-specifiers follow from defining type-specifiers as names for collections of objects, on TYPEP being a set membership test, and SUBTYPEP a subset test on collections of objects. The small differences between the specification for ARRAY and the specification for COMPLEX are necessary because there is no creation function for complexes which allows one to specify the resultant type independently of the types of the parts.  Thus in the case of COMPLEX we must refer to the type of the two parts, and to the fact that a  number can be a member of more than one type.  Note that:     (SUBTYPEP '(COMPLEX SINGLE-FLOAT) '(COMPLEX FLOAT)) is true in all implementations, but      (SUBTYPEP '(ARRAY SINGLE-FLOAT) '(ARRAY FLOAT)) is only true in implementations that do not have a specialized array representation that can hold single-floats but not other floats.Current Practice: Every vendor's implementation that the proposer has queried has a finite set of specialized array representations, such that two non-equivalent element types can be found that use the same specialized array representation; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other vendors fail it. No vendor that the proposer has queried has any specialized representation for complexes.Cost to Implementors: This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of typep and subtypep.Cost to Users: Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about make-array returning a result that isn't of "the obvious type".  Since the change is incompatible, some user code might have to be changed.Cost of non-adoption: Continuing confusion in the user community.Benefits: It will greatly reduce confusion in the user community.  The fact that (make-array <n> :element-type '<type>) frequently is not of type  (array <type>) has been very confusing to almost everyone.  That is, in practice, the distinction between "for declaration" and "for discrimination" has been a disaster.Esthetics: Reducing the confusing distinction between type-specifiers "for declaration" and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of data they purport to name.  Thus this is a step towards increased elegance.Discussion: To get a sense of how the community is confused, see the arpanet mailing  list for Common Lisp, in a series of exchanges started on Thu,  17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com> under the subject line of "Types in CL".  Also see the exchange started  Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu> under the subject line of "TYPEP warp implications".  Many senior implementors at Lucid favor this proposal.  In network mail  "Date: Sat, 9 Jan 1988  15:54 EST" Rob McLaughlin favored the gist of this  proposal -- namely that upgrading should be continued, and that TYPEP should be fixed.  Here is an excerpt of his words:    There are two obvious solutions, one of which has already been    proposed:     -- Make the mapping more direct.  Eliminating "array element type        upgrading" would be an instance of this.     -- Make the mapping explicitly ill-defined in a more useful way.    I think we need to do the latter because the former won't work.  I    don't see how to eliminate "array element type upgrading" without    creating more problems [than] we solve.  . . .    My conclusion [JonL's] is that it isn't array types that are wrong,    it is the understanding of the meaning of TYPEP that is wrong. Many persons are in favor of the permission to upgrade; but they would not like to see CL become a language like C where there are a prescribed set of kinds of arrays that must be implemented (e.g, "int", "long int", "single", "double" etc), and no others can exist.  In short, no one would want to gain portability at the expense of limiting the language to the architectural features of the hardware on which it was first implemented.  It may also be the case that portability will be improved since the identity (typep (make-array N :element-type '<type>) '(array <type>)) will be observed.*start*13132 00024 US Date:  8 Oct 88 12:32 PDTFrom: masinter.paSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 8)To: cl-cleanup@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterI modified this issue to tone down its criticizm of the currentCommon Lisp situation (e.g., removed the assertion that it has beena "disaster"). I think it still reads well. I also tried to squeezeinto the discussion section some of the alternatives that were triedand not adopted, and the reasons for not adopting them.I don't think there are two many others that I'll have lastminute revisions to; if you're there and listening today, letme know. (Or call at (415) 494-4365).Issue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291               The type-specifiers ARRAY, COMPLEX, SIMPLE-ARRAY, and VECTORRelated Issues: SUBTYPEP-TOO-VAGUE, LIST-TYPE-SPECIFIERCategory:      CHANGEEdit history:  Version 1, 13-May-88, JonL               Version 2, 23-May-88, JonL                  (typo fixes, comments from moon, rearrange some discussion)               Version 3, 02-Jun-88, JonL                  (flush alternate proposal ["flush-upgrading"]; consequently,                 move more of discussion back to discussion section.               Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings)               (Version 5 edit history missing)               Version 6, 6-Oct-88, Moon                (fix typos, cover subtypep explicitly, add complex,                 change name of UPGRADE-ARRAY-ELEMENT-TYPE)               Version 7, 7-Oct-88, JonL (more name and wording changes)               Version 8,  8-Oct-88, Masinter (wording, discussion)Problem description: CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination".  Many people are confused by this situation.  A consequence of this distinction is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have none of its values ever satisfy the TYPEP predicate with that type-specifier. One type-specifier with this property is           (ARRAY <element-type>)  for various implementation dependent values of <element-type>.  For example, in most implementations of CL, an array X created with an element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy        (TYPEP X '(ARRAY (SIGNED-BYTE 8))), or        (TYPEP X '(ARRAY T))  but (almost) never will it satisfy         (TYPEP X '(ARRAY (SIGNED-BYTE 5))).Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING) Summary of changes: Eliminate the distinction between type-specifiers "for declaration" and "for discrimination".  Change the meaning of the <element-type> in the ARRAY type-specifier and its subtypes, and in the COMPLEX type-specifier, to be the same for TYPEP and SUBTYPEP as for TYPE declarations. Specify how SUBTYPEP behaves on these type-specifiers.  Add a function to provide access to the implementation-dependent set of array types and another function to provide access to the implementation-dependent set of complex number types. Specifics: 1. Eliminate references to the distinction between types "for declaration" and "for discrimination" in the discussion of array and complex type-specifiers. This would include documentation patterned after CLtL:        a.) The discussion in section 4.5, pp. 45-7        b.) p. 291, the sentence begining "This set may be larger than the set        requested when the array was created; for example . . ." Instead, (ARRAY <type>) always means all arrays that can result by specifying <type> as the :ELEMENT-TYPE argument to the function MAKE-ARRAY, and (COMPLEX <type>) always means all complex numbers that can result by giving numbers of type <type> to the function COMPLEX, plus all other complex numbers of the same specialized representation. 2. Change the meaning of (TYPEP <x> '(ARRAY <type>)) to be true if and only if <x> is an array of the most specialized representation capable of holding elements of type <type>.  In other words, it is true if and only if <x> is an array and (ARRAY-ELEMENT-TYPE <x>) is type-equivalent to (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE <type>)). Do the same for SIMPLE-ARRAY and VECTOR. 3. Change the meaning of (TYPEP <x> '(COMPLEX <type>)) to be true if and only if <x> is a complex number of the most specialized representation capable of holding parts of type <type>,  or if <x> is of  any subtype of that representation.  Both the real and imaginary parts must satisy (TYPEP <real-or-imag-part> '<type>).  4. Define that for all type-specifiers <type1> and <type2>, other than *, (ARRAY <type1>) and (ARRAY <type2>) are either equivalent or disjoint, depending on whether they use the same specialized representation or distinct representations.  This defines the behavior of SUBTYPEP. 5. Define that for all type-specifiers <type1> and <type2>, other than *, (SUBTYPEP '(COMPLEX <type1>) '(COMPLEX <type2>)) is T T if they use the same specialized representation, T T if they use distinct specialized representations but (SUBTYPEP '<type1> '<type2>) is true, and NIL T otherwise. 6. Require that the resultant ARRAY-ELEMENT-TYPE from a call to MAKE-ARRAY is independent of any argument to MAKE-ARRAY except for the :ELEMENT-TYPE argument.  Thus the set of specialized array representations must be consistent between single-dimensional and multi-dimensional, simple and non-simple, short and long arrays. 7. Add the function IMPLEMENTED-ARRAY-ELEMENT-TYPE of one argument  which returns the same result as:    (DEFUN IMPLEMENTED-ARRAY-ELEMENT-TYPE (TYPE)      (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE))) The type specifiers (ARRAY <type1>) and (ARRAY <type2>), where neither <type1> nor <type2> is *, are equivalent if <type1> and <type2> produce the same value from IMPLEMENTED-ARRAY-ELEMENT-TYPE, and disjoint otherwise. 8. Add the function IMPLEMENTED-COMPLEX-PART-TYPE of one argument  which  returns the part type of the most specialized complex number representation that can hold parts of the given argument type.Test cases: Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type.  This will be an implementation dependent search, but in every implementation that the proposer has tested, there will be some such types; often, (SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, both of the following forms return T T:  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))            (array-element-type (make-array 0 :element-type '<aet-y>)))  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))            (array-element-type (make-array 0 :element-type '<aet-x>))) To eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>)) Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>)) Additionally, to show that un-equivalent type-specifiers that use the same specialized array type should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-y>))Rationale: This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination".  The suggested changes to the interpretation of array and complex type-specifiers follow from defining type-specifiers as names for collections of objects, on TYPEP being a set membership test, and SUBTYPEP a subset test on collections of objects. The small differences between the specification for ARRAY and the specification for COMPLEX are necessary because there is no creation function for complexes which allows one to specify the resultant type independently of the types of the parts.  Thus in the case of COMPLEX we must refer to the type of the two parts, and to the fact that a  number can be a member of more than one type.  Note that:     (SUBTYPEP '(COMPLEX SINGLE-FLOAT) '(COMPLEX FLOAT)) is true in all implementations, but      (SUBTYPEP '(ARRAY SINGLE-FLOAT) '(ARRAY FLOAT)) is only true in implementations that do not have a specialized array representation that can hold single-floats but not other floats.Current Practice: Every vendor's implementation that the proposer has queried has a finite set of specialized array representations, such that two non-equivalent element types can be found that use the same specialized array representation; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other implementations fail it. No vendor that the proposer has queried has any specialized representation for complexes.Cost to Implementors: This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of TYPEP and SUBTYPEP.Cost to Users: Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about MAKE-ARRAY returning a result that isn't of "the obvious type".  Since the change is incompatible, some user code might have to be changed.Cost of non-adoption: Continuing confusion in the user community.Benefits: It will greatly reduce confusion in the user community.  The fact that (MAKE-ARRAY <n> :ELEMENT-TYPE '<type>) frequently is not of type  (ARRAY <type>) has been very confusing to almost everyone.   Portability of applications will be increased slightly, since the behavior of  (TYPEP (MAKE-ARRAY <n> :ELEMENT-TYPE <type>) '(ARRAY <type>))  will no longer be implementation-dependent. Esthetics: Reducing the confusing distinction between type-specifiers "for declaration" and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of data they purport to name.  Thus this is a step towards increased elegance.Discussion: This issue was prompted by a lengthy discussion on the Common Lisp mailing list. It was the subject of a lengthy discussion in the cleanup committee, as well as a number of individual efforts. We considered the possibility of requiring that arrays remember the element-type given in the make-array call, e.g., require that (equal <x> (array-element-type (make-array <n> :element-type <x>))) for all valid type specifiers <x>. This has several problems: it increases the storage requirement for arrays, and 'hides' a  relevant part of the underlying implementation for no apparently  good reason. In addition, there might be some problems with equivalent but separate types (although this might be handled by changing "equal" to "equal-type", given a more rigorous definition of SUBTYPEP; see issue SUBTYPEP-TOO-VAGUE.) However, it would increase portability, since it would be much more difficult to write a program that, for example, created  an array with one element-type and then assumed an upgraded element-type. It would be valid for an implementation to do so  -- to remember the original array element-type or its canonical or expanded  form -- and satisfy all of the constraints of this proposal. We considered a suggestion to restrict the set of "known" array element types; this would gain portability at the expense of limiting the language.        TITAN 
         TITAN 
           <       !      i       #                            )                           .             j       >                                W                                        `              0       
                   4             d      1 "z*start*13137 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 12:42:31 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  12:42:51 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 08 OCT 88 12:32:44 PDTDate: 8 Oct 88 12:32 PDTFrom: masinter.paSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 8)To: cl-cleanup@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-123244-2125@Xerox>I modified this issue to tone down its criticizm of the currentCommon Lisp situation (e.g., removed the assertion that it has beena "disaster"). I think it still reads well. I also tried to squeezeinto the discussion section some of the alternatives that were triedand not adopted, and the reasons for not adopting them.I don't think there are two many others that I'll have lastminute revisions to; if you're there and listening today, letme know. (Or call at (415) 494-4365).!Issue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291               The type-specifiers ARRAY, COMPLEX, SIMPLE-ARRAY, and VECTORRelated Issues: SUBTYPEP-TOO-VAGUE, LIST-TYPE-SPECIFIERCategory:      CHANGEEdit history:  Version 1, 13-May-88, JonL               Version 2, 23-May-88, JonL                  (typo fixes, comments from moon, rearrange some discussion)               Version 3, 02-Jun-88, JonL                  (flush alternate proposal ["flush-upgrading"]; consequently,                 move more of discussion back to discussion section.               Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings)               (Version 5 edit history missing)               Version 6, 6-Oct-88, Moon                (fix typos, cover subtypep explicitly, add complex,                 change name of UPGRADE-ARRAY-ELEMENT-TYPE)               Version 7, 7-Oct-88, JonL (more name and wording changes)               Version 8,  8-Oct-88, Masinter (wording, discussion)Problem description: CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination".  Many people are confused by this situation.  A consequence of this distinction is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have none of its values ever satisfy the TYPEP predicate with that type-specifier. One type-specifier with this property is           (ARRAY <element-type>)  for various implementation dependent values of <element-type>.  For example, in most implementations of CL, an array X created with an element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy        (TYPEP X '(ARRAY (SIGNED-BYTE 8))), or        (TYPEP X '(ARRAY T))  but (almost) never will it satisfy         (TYPEP X '(ARRAY (SIGNED-BYTE 5))).Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING) Summary of changes: Eliminate the distinction between type-specifiers "for declaration" and "for discrimination".  Change the meaning of the <element-type> in the ARRAY type-specifier and its subtypes, and in the COMPLEX type-specifier, to be the same for TYPEP and SUBTYPEP as for TYPE declarations. Specify how SUBTYPEP behaves on these type-specifiers.  Add a function to provide access to the implementation-dependent set of array types and another function to provide access to the implementation-dependent set of complex number types. Specifics: 1. Eliminate references to the distinction between types "for declaration" and "for discrimination" in the discussion of array and complex type-specifiers. This would include documentation patterned after CLtL:        a.) The discussion in section 4.5, pp. 45-7        b.) p. 291, the sentence begining "This set may be larger than the set        requested when the array was created; for example . . ." Instead, (ARRAY <type>) always means all arrays that can result by specifying <type> as the :ELEMENT-TYPE argument to the function MAKE-ARRAY, and (COMPLEX <type>) always means all complex numbers that can result by giving numbers of type <type> to the function COMPLEX, plus all other complex numbers of the same specialized representation. 2. Change the meaning of (TYPEP <x> '(ARRAY <type>)) to be true if and only if <x> is an array of the most specialized representation capable of holding elements of type <type>.  In other words, it is true if and only if <x> is an array and (ARRAY-ELEMENT-TYPE <x>) is type-equivalent to (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE <type>)). Do the same for SIMPLE-ARRAY and VECTOR. 3. Change the meaning of (TYPEP <x> '(COMPLEX <type>)) to be true if and only if <x> is a complex number of the most specialized representation capable of holding parts of type <type>,  or if <x> is of  any subtype of that representation.  Both the real and imaginary parts must satisy (TYPEP <real-or-imag-part> '<type>).  4. Define that for all type-specifiers <type1> and <type2>, other than *, (ARRAY <type1>) and (ARRAY <type2>) are either equivalent or disjoint, depending on whether they use the same specialized representation or distinct representations.  This defines the behavior of SUBTYPEP. 5. Define that for all type-specifiers <type1> and <type2>, other than *, (SUBTYPEP '(COMPLEX <type1>) '(COMPLEX <type2>)) is T T if they use the same specialized representation, T T if they use distinct specialized representations but (SUBTYPEP '<type1> '<type2>) is true, and NIL T otherwise. 6. Require that the resultant ARRAY-ELEMENT-TYPE from a call to MAKE-ARRAY is independent of any argument to MAKE-ARRAY except for the :ELEMENT-TYPE argument.  Thus the set of specialized array representations must be consistent between single-dimensional and multi-dimensional, simple and non-simple, short and long arrays. 7. Add the function IMPLEMENTED-ARRAY-ELEMENT-TYPE of one argument  which returns the same result as:    (DEFUN IMPLEMENTED-ARRAY-ELEMENT-TYPE (TYPE)      (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE))) The type specifiers (ARRAY <type1>) and (ARRAY <type2>), where neither <type1> nor <type2> is *, are equivalent if <type1> and <type2> produce the same value from IMPLEMENTED-ARRAY-ELEMENT-TYPE, and disjoint otherwise. 8. Add the function IMPLEMENTED-COMPLEX-PART-TYPE of one argument  which  returns the part type of the most specialized complex number representation that can hold parts of the given argument type.Test cases: Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type.  This will be an implementation dependent search, but in every implementation that the proposer has tested, there will be some such types; often, (SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, both of the following forms return T T:  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))            (array-element-type (make-array 0 :element-type '<aet-y>)))  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))            (array-element-type (make-array 0 :element-type '<aet-x>))) To eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>)) Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>)) Additionally, to show that un-equivalent type-specifiers that use the same specialized array type should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-y>))Rationale: This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination".  The suggested changes to the interpretation of array and complex type-specifiers follow from defining type-specifiers as names for collections of objects, on TYPEP being a set membership test, and SUBTYPEP a subset test on collections of objects. The small differences between the specification for ARRAY and the specification for COMPLEX are necessary because there is no creation function for complexes which allows one to specify the resultant type independently of the types of the parts.  Thus in the case of COMPLEX we must refer to the type of the two parts, and to the fact that a  number can be a member of more than one type.  Note that:     (SUBTYPEP '(COMPLEX SINGLE-FLOAT) '(COMPLEX FLOAT)) is true in all implementations, but      (SUBTYPEP '(ARRAY SINGLE-FLOAT) '(ARRAY FLOAT)) is only true in implementations that do not have a specialized array representation that can hold single-floats but not other floats.Current Practice: Every vendor's implementation that the proposer has queried has a finite set of specialized array representations, such that two non-equivalent element types can be found that use the same specialized array representation; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other implementations fail it. No vendor that the proposer has queried has any specialized representation for complexes.Cost to Implementors: This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of TYPEP and SUBTYPEP.Cost to Users: Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about MAKE-ARRAY returning a result that isn't of "the obvious type".  Since the change is incompatible, some user code might have to be changed.Cost of non-adoption: Continuing confusion in the user community.Benefits: It will greatly reduce confusion in the user community.  The fact that (MAKE-ARRAY <n> :ELEMENT-TYPE '<type>) frequently is not of type  (ARRAY <type>) has been very confusing to almost everyone.   Portability of applications will be increased slightly, since the behavior of  (TYPEP (MAKE-ARRAY <n> :ELEMENT-TYPE <type>) '(ARRAY <type>))  will no longer be implementation-dependent. Esthetics: Reducing the confusing distinction between type-specifiers "for declaration" and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of data they purport to name.  Thus this is a step towards increased elegance.Discussion: This issue was prompted by a lengthy discussion on the Common Lisp mailing list. It was the subject of a lengthy discussion in the cleanup committee, as well as a number of individual efforts. We considered the possibility of requiring that arrays remember the element-type given in the make-array call, e.g., require that (equal <x> (array-element-type (make-array <n> :element-type <x>))) for all valid type specifiers <x>. This has several problems: it increases the storage requirement for arrays, and 'hides' a  relevant part of the underlying implementation for no apparently  good reason. In addition, there might be some problems with equivalent but separate types (although this might be handled by changing "equal" to "equal-type", given a more rigorous definition of SUBTYPEP; see issue SUBTYPEP-TOO-VAGUE.) However, it would increase portability, since it would be much more difficult to write a program that, for example, created  an array with one element-type and then assumed an upgraded element-type. It would be valid for an implementation to do so  -- to remember the original array element-type or its canonical or expanded  form -- and satisfy all of the constraints of this proposal. We considered a suggestion to restrict the set of "known" array element types; this would gain portability at the expense of limiting the language.*start*12852 00024 US Date:  8 Oct 88 13:25 PDTFrom: masinter.paSubject: DRAFT Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 8)To: x3J13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterThere have been last-minute edits to the wording (but not the intent) of this issue/proposal that cause me to write DRAFT in the issue status.Issue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291               The type-specifiers ARRAY, COMPLEX, SIMPLE-ARRAY, and VECTORRelated Issues: SUBTYPEP-TOO-VAGUE, LIST-TYPE-SPECIFIERCategory:      CHANGEEdit history:  Version 1, 13-May-88, JonL               Version 2, 23-May-88, JonL                  (typo fixes, comments from moon, rearrange some discussion)               Version 3, 02-Jun-88, JonL                  (flush alternate proposal ["flush-upgrading"]; consequently,                 move more of discussion back to discussion section.               Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings)               (Version 5 edit history missing)               Version 6, 6-Oct-88, Moon                (fix typos, cover subtypep explicitly, add complex,                 change name of UPGRADE-ARRAY-ELEMENT-TYPE)               Version 7, 7-Oct-88, JonL (more name and wording changes)               Version 8,  8-Oct-88, Masinter (wording, discussion)Problem description: CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination".  Many people are confused by this situation.  A consequence of this distinction is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have none of its values ever satisfy the TYPEP predicate with that type-specifier. One type-specifier with this property is           (ARRAY <element-type>)  for various implementation dependent values of <element-type>.  For example, in most implementations of CL, an array X created with an element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy        (TYPEP X '(ARRAY (SIGNED-BYTE 8))), or        (TYPEP X '(ARRAY T))  but (almost) never will it satisfy         (TYPEP X '(ARRAY (SIGNED-BYTE 5))).Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING) Summary of changes: Eliminate the distinction between type-specifiers "for declaration" and "for discrimination".  Change the meaning of the <element-type> in the ARRAY type-specifier and its subtypes, and in the COMPLEX type-specifier, to be the same for TYPEP and SUBTYPEP as for TYPE declarations. Specify how SUBTYPEP behaves on these type-specifiers.  Add a function to provide access to the implementation-dependent set of array types and another function to provide access to the implementation-dependent set of complex number types. Specifics: 1. Eliminate references to the distinction between types "for declaration" and "for discrimination" in the discussion of array and complex type-specifiers. This would include documentation patterned after CLtL:        a.) The discussion in section 4.5, pp. 45-7        b.) p. 291, the sentence begining "This set may be larger than the set        requested when the array was created; for example . . ." Instead, (ARRAY <type>) always means all arrays that can result by specifying <type> as the :ELEMENT-TYPE argument to the function MAKE-ARRAY, and (COMPLEX <type>) always means all complex numbers that can result by giving numbers of type <type> to the function COMPLEX, plus all other complex numbers of the same specialized representation. 2. Change the meaning of (TYPEP <x> '(ARRAY <type>)) to be true if and only if <x> is an array of the most specialized representation capable of holding elements of type <type>.  In other words, it is true if and only if <x> is an array and (ARRAY-ELEMENT-TYPE <x>) is type-equivalent to (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE <type>)). Do the same for SIMPLE-ARRAY and VECTOR. 3. Change the meaning of (TYPEP <x> '(COMPLEX <type>)) to be true if and only if <x> is a complex number of the most specialized representation capable of holding parts of type <type>,  or if <x> is of  any subtype of that representation.  Both the real and imaginary parts must satisy (TYPEP <real-or-imag-part> '<type>).  4. Define that for all type-specifiers <type1> and <type2>, other than *, (ARRAY <type1>) and (ARRAY <type2>) are either equivalent or disjoint, depending on whether they use the same specialized representation or distinct representations.  This defines the behavior of SUBTYPEP. 5. Define that for all type-specifiers <type1> and <type2>, other than *, (SUBTYPEP '(COMPLEX <type1>) '(COMPLEX <type2>)) is T T if they use the same specialized representation, T T if they use distinct specialized representations but (SUBTYPEP '<type1> '<type2>) is true, and NIL T otherwise. 6. Require that the resultant ARRAY-ELEMENT-TYPE from a call to MAKE-ARRAY is independent of any argument to MAKE-ARRAY except for the :ELEMENT-TYPE argument.  Thus the set of specialized array representations must be consistent between single-dimensional and multi-dimensional, simple and non-simple, short and long arrays. 7. Add the function IMPLEMENTED-ARRAY-ELEMENT-TYPE of one argument  which returns the same result as:    (DEFUN IMPLEMENTED-ARRAY-ELEMENT-TYPE (TYPE)      (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE))) The type specifiers (ARRAY <type1>) and (ARRAY <type2>), where neither <type1> nor <type2> is *, are equivalent if <type1> and <type2> produce the same value from IMPLEMENTED-ARRAY-ELEMENT-TYPE, and disjoint otherwise. 8. Add the function IMPLEMENTED-COMPLEX-PART-TYPE of one argument  which  returns the part type of the most specialized complex number representation that can hold parts of the given argument type.Test cases: Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type.  This will be an implementation dependent search, but in every implementation that the proposer has tested, there will be some such types; often, (SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, both of the following forms return T T:  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))            (array-element-type (make-array 0 :element-type '<aet-y>)))  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))            (array-element-type (make-array 0 :element-type '<aet-x>))) To eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>)) Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>)) Additionally, to show that un-equivalent type-specifiers that use the same specialized array type should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-y>))Rationale: This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination".  The suggested changes to the interpretation of array and complex type-specifiers follow from defining type-specifiers as names for collections of objects, on TYPEP being a set membership test, and SUBTYPEP a subset test on collections of objects. The small differences between the specification for ARRAY and the specification for COMPLEX are necessary because there is no creation function for complexes which allows one to specify the resultant type independently of the types of the parts.  Thus in the case of COMPLEX we must refer to the type of the two parts, and to the fact that a  number can be a member of more than one type.  Note that:     (SUBTYPEP '(COMPLEX SINGLE-FLOAT) '(COMPLEX FLOAT)) is true in all implementations, but      (SUBTYPEP '(ARRAY SINGLE-FLOAT) '(ARRAY FLOAT)) is only true in implementations that do not have a specialized array representation that can hold single-floats but not other floats.Current Practice: Every vendor's implementation that the proposer has queried has a finite set of specialized array representations, such that two non-equivalent element types can be found that use the same specialized array representation; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other implementations fail it. No vendor that the proposer has queried has any specialized representation for complexes.Cost to Implementors: This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of TYPEP and SUBTYPEP.Cost to Users: Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about MAKE-ARRAY returning a result that isn't of "the obvious type".  Since the change is incompatible, some user code might have to be changed.Cost of non-adoption: Continuing confusion in the user community.Benefits: It will greatly reduce confusion in the user community.  The fact that (MAKE-ARRAY <n> :ELEMENT-TYPE '<type>) frequently is not of type  (ARRAY <type>) has been very confusing to almost everyone.   Portability of applications will be increased slightly, since the behavior of  (TYPEP (MAKE-ARRAY <n> :ELEMENT-TYPE <type>) '(ARRAY <type>))  will no longer be implementation-dependent. Esthetics: Reducing the confusing distinction between type-specifiers "for declaration" and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of data they purport to name.  Thus this is a step towards increased elegance.Discussion: This issue was prompted by a lengthy discussion on the Common Lisp mailing list. It was the subject of a lengthy discussion in the cleanup committee, as well as a number of individual efforts. We considered the possibility of requiring that arrays remember the element-type given in the make-array call, e.g., require that (equal <x> (array-element-type (make-array <n> :element-type <x>))) for all valid type specifiers <x>. This has several problems: it increases the storage requirement for arrays, and 'hides' a  relevant part of the underlying implementation for no apparently  good reason. In addition, there might be some problems with equivalent but separate types (although this might be handled by changing "equal" to "equal-type", given a more rigorous definition of SUBTYPEP; see issue SUBTYPEP-TOO-VAGUE.) However, it would increase portability, since it would be much more difficult to write a program that, for example, created  an array with one element-type and then assumed an upgraded element-type. It would be valid for an implementation to do so  -- to remember the original array element-type or its canonical or expanded  form -- and satisfy all of the constraints of this proposal. We considered a suggestion to restrict the set of "known" array element types; this would gain portability at the expense of limiting the language.     ----- End Forwarded Messages -----        TITAN 
          TITAN 
         TITAN 
           B       !             #                            )                           .             j       >                                W                                        `              0       
                   4                   0 "z*start*12797 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 13:53:39 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  13:29:14 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 08 OCT 88 13:25:27 PDTDate: 8 Oct 88 13:25 PDTFrom: masinter.paSubject: DRAFT Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 8)To: x3J13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-132527-2172@Xerox>There have been last-minute edits to the wording (but not the intent) of this issue/proposal that cause me to write DRAFT in the issue status.!Issue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45                    TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                    ARRAY-ELEMENT-TYPE, CLtL p. 291               The type-specifiers ARRAY, COMPLEX, SIMPLE-ARRAY, and VECTORRelated Issues: SUBTYPEP-TOO-VAGUE, LIST-TYPE-SPECIFIERCategory:      CHANGEEdit history:  Version 1, 13-May-88, JonL               Version 2, 23-May-88, JonL                  (typo fixes, comments from moon, rearrange some discussion)               Version 3, 02-Jun-88, JonL                  (flush alternate proposal ["flush-upgrading"]; consequently,                 move more of discussion back to discussion section.               Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings)               (Version 5 edit history missing)               Version 6, 6-Oct-88, Moon                (fix typos, cover subtypep explicitly, add complex,                 change name of UPGRADE-ARRAY-ELEMENT-TYPE)               Version 7, 7-Oct-88, JonL (more name and wording changes)               Version 8,  8-Oct-88, Masinter (wording, discussion)Problem description: CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination".  Many people are confused by this situation.  A consequence of this distinction is that a variable declared to be of type <certain-type> and all of whose assigned objects are created in accordance with that type, may still have none of its values ever satisfy the TYPEP predicate with that type-specifier. One type-specifier with this property is           (ARRAY <element-type>)  for various implementation dependent values of <element-type>.  For example, in most implementations of CL, an array X created with an element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy        (TYPEP X '(ARRAY (SIGNED-BYTE 8))), or        (TYPEP X '(ARRAY T))  but (almost) never will it satisfy         (TYPEP X '(ARRAY (SIGNED-BYTE 5))).Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING) Summary of changes: Eliminate the distinction between type-specifiers "for declaration" and "for discrimination".  Change the meaning of the <element-type> in the ARRAY type-specifier and its subtypes, and in the COMPLEX type-specifier, to be the same for TYPEP and SUBTYPEP as for TYPE declarations. Specify how SUBTYPEP behaves on these type-specifiers.  Add a function to provide access to the implementation-dependent set of array types and another function to provide access to the implementation-dependent set of complex number types. Specifics: 1. Eliminate references to the distinction between types "for declaration" and "for discrimination" in the discussion of array and complex type-specifiers. This would include documentation patterned after CLtL:        a.) The discussion in section 4.5, pp. 45-7        b.) p. 291, the sentence begining "This set may be larger than the set        requested when the array was created; for example . . ." Instead, (ARRAY <type>) always means all arrays that can result by specifying <type> as the :ELEMENT-TYPE argument to the function MAKE-ARRAY, and (COMPLEX <type>) always means all complex numbers that can result by giving numbers of type <type> to the function COMPLEX, plus all other complex numbers of the same specialized representation. 2. Change the meaning of (TYPEP <x> '(ARRAY <type>)) to be true if and only if <x> is an array of the most specialized representation capable of holding elements of type <type>.  In other words, it is true if and only if <x> is an array and (ARRAY-ELEMENT-TYPE <x>) is type-equivalent to (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE <type>)). Do the same for SIMPLE-ARRAY and VECTOR. 3. Change the meaning of (TYPEP <x> '(COMPLEX <type>)) to be true if and only if <x> is a complex number of the most specialized representation capable of holding parts of type <type>,  or if <x> is of  any subtype of that representation.  Both the real and imaginary parts must satisy (TYPEP <real-or-imag-part> '<type>).  4. Define that for all type-specifiers <type1> and <type2>, other than *, (ARRAY <type1>) and (ARRAY <type2>) are either equivalent or disjoint, depending on whether they use the same specialized representation or distinct representations.  This defines the behavior of SUBTYPEP. 5. Define that for all type-specifiers <type1> and <type2>, other than *, (SUBTYPEP '(COMPLEX <type1>) '(COMPLEX <type2>)) is T T if they use the same specialized representation, T T if they use distinct specialized representations but (SUBTYPEP '<type1> '<type2>) is true, and NIL T otherwise. 6. Require that the resultant ARRAY-ELEMENT-TYPE from a call to MAKE-ARRAY is independent of any argument to MAKE-ARRAY except for the :ELEMENT-TYPE argument.  Thus the set of specialized array representations must be consistent between single-dimensional and multi-dimensional, simple and non-simple, short and long arrays. 7. Add the function IMPLEMENTED-ARRAY-ELEMENT-TYPE of one argument  which returns the same result as:    (DEFUN IMPLEMENTED-ARRAY-ELEMENT-TYPE (TYPE)      (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE))) The type specifiers (ARRAY <type1>) and (ARRAY <type2>), where neither <type1> nor <type2> is *, are equivalent if <type1> and <type2> produce the same value from IMPLEMENTED-ARRAY-ELEMENT-TYPE, and disjoint otherwise. 8. Add the function IMPLEMENTED-COMPLEX-PART-TYPE of one argument  which  returns the part type of the most specialized complex number representation that can hold parts of the given argument type.Test cases: Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type.  This will be an implementation dependent search, but in every implementation that the proposer has tested, there will be some such types; often, (SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, both of the following forms return T T:  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))            (array-element-type (make-array 0 :element-type '<aet-y>)))  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))            (array-element-type (make-array 0 :element-type '<aet-x>))) To eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>)) Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>)) Additionally, to show that un-equivalent type-specifiers that use the same specialized array type should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-y>))Rationale: This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination".  The suggested changes to the interpretation of array and complex type-specifiers follow from defining type-specifiers as names for collections of objects, on TYPEP being a set membership test, and SUBTYPEP a subset test on collections of objects. The small differences between the specification for ARRAY and the specification for COMPLEX are necessary because there is no creation function for complexes which allows one to specify the resultant type independently of the types of the parts.  Thus in the case of COMPLEX we must refer to the type of the two parts, and to the fact that a  number can be a member of more than one type.  Note that:     (SUBTYPEP '(COMPLEX SINGLE-FLOAT) '(COMPLEX FLOAT)) is true in all implementations, but      (SUBTYPEP '(ARRAY SINGLE-FLOAT) '(ARRAY FLOAT)) is only true in implementations that do not have a specialized array representation that can hold single-floats but not other floats.Current Practice: Every vendor's implementation that the proposer has queried has a finite set of specialized array representations, such that two non-equivalent element types can be found that use the same specialized array representation; this includes Lucid, Vaxlisp, Symbolics, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other implementations fail it. No vendor that the proposer has queried has any specialized representation for complexes.Cost to Implementors: This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of TYPEP and SUBTYPEP.Cost to Users: Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about MAKE-ARRAY returning a result that isn't of "the obvious type".  Since the change is incompatible, some user code might have to be changed.Cost of non-adoption: Continuing confusion in the user community.Benefits: It will greatly reduce confusion in the user community.  The fact that (MAKE-ARRAY <n> :ELEMENT-TYPE '<type>) frequently is not of type  (ARRAY <type>) has been very confusing to almost everyone.   Portability of applications will be increased slightly, since the behavior of  (TYPEP (MAKE-ARRAY <n> :ELEMENT-TYPE <type>) '(ARRAY <type>))  will no longer be implementation-dependent. Esthetics: Reducing the confusing distinction between type-specifiers "for declaration" and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of data they purport to name.  Thus this is a step towards increased elegance.Discussion: This issue was prompted by a lengthy discussion on the Common Lisp mailing list. It was the subject of a lengthy discussion in the cleanup committee, as well as a number of individual efforts. We considered the possibility of requiring that arrays remember the element-type given in the make-array call, e.g., require that (equal <x> (array-element-type (make-array <n> :element-type <x>))) for all valid type specifiers <x>. This has several problems: it increases the storage requirement for arrays, and 'hides' a  relevant part of the underlying implementation for no apparently  good reason. In addition, there might be some problems with equivalent but separate types (although this might be handled by changing "equal" to "equal-type", given a more rigorous definition of SUBTYPEP; see issue SUBTYPEP-TOO-VAGUE.) However, it would increase portability, since it would be much more difficult to write a program that, for example, created  an array with one element-type and then assumed an upgraded element-type. It would be valid for an implementation to do so  -- to remember the original array element-type or its canonical or expanded  form -- and satisfy all of the constraints of this proposal. We considered a suggestion to restrict the set of "known" array element types; this would gain portability at the expense of limiting the language.     ----- End Forwarded Messages -----*start*04363 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 14:18:37 PDTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 7 Oct 88  14:18:18 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA04912; Fri, 7 Oct 88 17:17:38 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA03303; Fri, 7 Oct 88 17:19:24 EDTMessage-Id: <8810072119.AA03303@mist.UUCP>To: cl-cleanup%sail.stanford.edu@MULTIMAX.ENCORE.COMSubject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESDate: Fri, 07 Oct 88 17:19:22 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>Issue:         DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESReferences:    Array type specifiers, pp. 45-46Related issues: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, DECLARE-TYPE-FREECategory:      CLARIFICATIONEdit history:  Version 1,  7-Oct-88, PiersonProblem description:Array type specifiers appear to be useful both for declaring thestorage format of the array and for declaring the types of legaloperations on array elements.  Unfortunately, the current definitionof the meaning of array type specifiers does not require animplementation to support the second use.Proposal (DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES:RESTRICTIVE):Within the scope of an array type declaration, all references to arrayelements are assumed to satisfy the exact declared element type.  Animplementation should signal an error if this is ever violated.  Acompiler may treat the code within the scope of the array typedeclaration as if each access of an array element was surrounded by anappropriate THE form.Examples:(DEFVAR *ONE-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 5)))(DEFVAR *ANOTHER-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 8)))(DEFUN FROB (AN-ARRAY)  (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))  (SETF (AREF AN-ARRAY 1) 31)		; OK  (SETF (AREF AN-ARRAY 2) 127)		; Should signal an error  (SETF (AREF AN-ARRAY 3) (* 2 (AREF AN-ARRAY 3))) ; Run-time decision needed  (LET ((FOO 0))    (DECLARE (TYPE (SIGNED-BYTE 5) FOO))    (SETF FOO (AREF AN-ARRAY 0))))	; Declared to be safe(FROB *ONE-ARRAY*)			; Legal call, should signal an error(FROM *ANOTHER-ARRAY*)			; Is probably an undetectable errorNote that the above definition of FROB is equivalent to:(DEFUN FROB (AN-ARRAY)  (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 1) 31))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 2) 127))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))	(* 2 (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))))  (LET ((FOO 0))    (DECLARE (TYPE (SIGNED-BYTE 5) FOO))    (SETF FOO (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 0)))))Test Cases:TBSRationale:This mandates a useful and commonly expected behavior.  It complementsproposal ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, which deals with arraytype specifiers as they refer to arrays as a whole.  The "shouldsignal an error" requirement permits compiler optimization whilerequiring interpreters and low compiler optimization levels to performuseful error checking.Current practice:???Cost to Implementors:Most implementations will have to extend the type checking in theinterpreter and low optimization levels of the compiler.Cost to Users:Some users might find that errors in existing code become visible forthe first time.Cost of non-adoption:Users will continue to expect declaration syntax to be more usefulthan it really is.It will be harder to debug code that uses arrays containingspecialized types.Performance impact:Highly optimized code should be unaffected.  Interpreted andunoptimized code will run slower because of the additional errorchecking. Benefits:It will be easier to use the Common Lisp type system to catchprogramming errors.Aesthetics:Improved because the meaning of type declarations will coincide moreclearly with their appearance.Discussion:Pierson supports this proposal.JonL expressed support for the idea behind this proposal during thediscussion of ARRAY-TYPE-ELEMENT-TYPE-SEMANITICS but said that it wasa compiler committee problem.  This was submitted as a cleanup issueanyway because it imposes requirements on the interpreter as well asthe compiler.*start*02108 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 15:56:37 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  15:56:18 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472850; Fri 7-Oct-88 18:54:24 EDTDate: Fri, 7 Oct 88 18:54 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESTo: pierson%mist@MULTIMAX.ENCORE.COMcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8810072119.AA03303@mist.UUCP>Message-ID: <881007185412.1.KMP@BOBOLINK.SCRC.Symbolics.COM>This is inconsistent with current practice in that implementations arecurrently permitted to ignore type declarations altogether -- not justfor array but for anything.The only consistent proposal would be to say that in all cases wheredeclarations are done and violated, an implementation should signal anerror -- not just for arrays.Either way, you're talking major work. Although not technically anincompatible change, some implementations (like the Lisp machine family)currently don't track these declarations at all since it would mostlyonly slow things down. Some other (stock hardware) implementationsonly track the types they know how how to optimize. Eg, they mightignore SYMBOL declarations because they don't have an optimization thatpertains to symbols but they might track FIXNUM declarations becausethey know lots of cool things to do with that.As such, your cost to implementors seems a little understated. Ido not personally maintain that aspect of any implementation, so I'mjust guessing but it looks to my naive eye like it's not justa matter of "extended some checking" -- it might also mean somepretty sweeping changes to the kinds of information that have tobe tracked by interpreters and compilers, and perhaps in some caseseven to the modularity of the interpreter and/or compiler. *start*01624 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 16:08:36 PDTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 7 Oct 88  16:08:39 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA05562; Fri, 7 Oct 88 19:08:23 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA03705; Fri, 7 Oct 88 19:10:10 EDTMessage-Id: <8810072310.AA03705@mist.UUCP>To: cl-cleanup%sail.stanford.edu@MULTIMAX.ENCORE.COMSubject: Re: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES Date: Fri, 07 Oct 88 19:10:08 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>    This is inconsistent with current practice in that implementations are    currently permitted to ignore type declarations altogether -- not just    for array but for anything.    Sorry 'bout that.  Would you be happy if it was changed to specifythat implementations which pay attention to type declarations musttreat references to array elements as strictly as any other declaredtype?More globally, with the new error terminology we're going to have todecide whether implementations will still be permitted to ignore typedeclarations for interpreted and unoptimized code.  Since these casescan no longer be "is an error", they've got to become either "shouldbe signalled", "undefined", or "unspecified".  I favor "should be anerror" because type checking can be a powerful debugging tool and somecurrent users appear to expect it to work as such, look at the CLXsources for example.*start*03367 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 16:16:09 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  16:15:54 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472873; Fri 7-Oct-88 19:13:56 EDTDate: Fri, 7 Oct 88 19:13 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES To: pierson%mist@MULTIMAX.ENCORE.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8810072306.AA03674@mist.UUCP>Message-ID: <881007191339.2.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri, 07 Oct 88 19:06:32 EDT    From: Dan L. Pierson <pierson%mist@multimax.ARPA>	This is inconsistent with current practice in that implementations are	currently permitted to ignore type declarations altogether -- not just	for array but for anything.        Sorry 'bout that.  Would you be happy if it was changed to specify    that implementations which pay attention to type declarations must    treat references to array elements as strictly as any other declared    type?Not really. Any non-conforming implementation could claim to be in theset of those who don't completely pay attention to declarations.It's not that I oppose the sentiment. I just don't want to spin our wheelsto no good end. I don't think it takes a formal vote of X3J13 for us toask Kathy to add an implementation note to the declartions section thatreminds people that implementations can do such checking and suggests thatthey do so where feasible.To an extent, I think this is the sort of thing that it's appropriate (orat least -- given all the other things we already have cooking -- necessary)to let ``market pressure'' take care of.    More globally, with the new error terminology we're going to have to    decide whether implementations will still be permitted to ignore type    declarations for interpreted and unoptimized code.  Since these cases    can no longer be "is an error", they've got to become either "should    be signalled", "undefined", or "unspecified".  I favor "should be an    error" because type checking can be a powerful debugging tool and some    current users appear to expect it to work as such, look at the CLX    sources for example.Strictly, there's no decision called for."undefined" is the same as "is an error".I think what you mean to say is now that we have more terms, we mightwant to incompatibly change the language so that more things takeadvantage of that new terminology.Put another way, CLtL is unambiguous about the "undefinedness" abouta lot of things, but that lack of ambiguity may not have been intended.Insofar as numerous such cases are arguably mistakes, and more preciselanguage may have sometimes been intended (or since been seen to havebeen a good idea), it's now time to think about fixing those situations.If that's what you mean, I agree. But such things are going to bevery expensive at times to do, and we should be honest about the costsso that implementors can know what they're buying into (or what tovote against if the cost is prohibitive).*start*00883 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 22:36:58 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  22:37:23 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 OCT 88 22:33:21 PDTDate: 8 Oct 88 22:33 PDTFrom: masinter.paSubject: Re: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES In-reply-to: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>'s message of Fri, 07 Oct 88 19:10:08 EDTTo: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>cc: cl-cleanup@sail.stanford.eduMessage-ID: <881008-223321-2629@Xerox>I think this issue is also addressed by ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS;certainly the ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS "Problem Description" has alot of overlap with the problem description here.*start*01106 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 12:42:51 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  12:42:59 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475715; Thu 13-Oct-88 15:41:36 EDTDate: Thu, 13 Oct 88 15:41 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 8)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013154128.4.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...X3J13 meeting: Masinter: Impact on character proposal. JonL: This issue seems mostly about TYPEP yet in one place       addresses MAKE-ARRAY. [KMP couldn't figure out if JonL       meant he didn't think it appropriate for the proposal       to affect both or if he just didn't think the writeup       did a good job of stating it had an impact on both.]*start*01271 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 12:44:52 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  12:45:09 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA17097; Thu, 13 Oct 88 13:43:34 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19810; Thu, 13 Oct 88 13:43:32 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810131943.AA19810@defun.utah.edu>Date: Thu, 13 Oct 88 13:43:30 MDTSubject: issue ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSTo: cl-cleanup@sail.stanford.eduI don't see anything obviously wrong with the general approach takenby this proposal.  However, I think the new functions added bysections 7 and 8 are unnecessary and I would either like those partsremoved, or something added to the "Rationale" section to explain whysome people think they *are* necessary.  Also, since this proposalchanges the behavior of TYPEP on array type specifiers, I'd like tosee some clarification of how functions such as BIT-VECTOR-P that aredefined in terms of TYPEP in CLtL are affected by the change, or anexplicit statement that they're not.-Sandra-------*start*02802 00024 US Return-Path: <jlm@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 10 OCT 88 12:50:46 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02272g; Mon, 10 Oct 88 12:50:55 PDTReceived: by bhopal id AA11361g; Mon, 10 Oct 88 12:49:15 PDTDate: Mon, 10 Oct 88 12:49:15 PDTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8810101949.AA11361@bhopal>To: cl-cleanup@sail.stanford.eduCc: cl-cleanup@sail.stanford.edu, Masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 8 Oct 88 12:32 PDT <881008-123244-2125@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 8)     ... It would be valid for an implementation to ... remember the     original array element-type or its canonical or expanded form ...     and satisfy all of the constraints of this proposal.This observation makes the proposal much more palatable, so I won'tpress the issue beyond the following two observations:(1)  The extra storage per array for remembering the original type can     be quite minimal, depending on the implementation.  If arrays     already allocate a full pointer for the type, that can just as     well point at the pair (<upgraded-type> . <given-type>) shared     among all such arrays.  If arrays use a special encoding of a few     bits to identify the updgraded type, then a small number of extra     bits suffices to index into a table of given types, overflowing     to the use of a full pointer.  This does not necessarily     complicate the runtime array access code, but could require enough     trickiness in laying out arrays to be considered non-trivial. (2)  I find it esthetically disturbing that the existing proposal     seems to force the following to be legal in many implementations:       (setf (aref (the (array (unsigned-byte 5)) foo) 0)	     127)     Any proposal to make such code illegal would seem to be     incompatible with ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING      since then, e.g., for any implementation for which      (array (unsigned-byte 5)) upgrades to (array (unsigned-byte 8))     the following code would be illlegal or legal depending whether      baz is declared inline or not:       (defun baz (x) (setf (aref x 0) 127))        (defun peculiar ()         (let ((x (make-array 0 :element-type '(unsigned-byte 4))))	   (declare (type (array (unsigned-byte 4)) x))	   (baz x)           (aref x 0)))     In fact, I can't even portably assume that PECULIAR returns a     number, since in implementions which upgrade to (array t),     BAZ could be consistently redefined to install a string.     I keep wondering what the potential convert from FORTRAN or     PASCAL would think of all this. Thanks for bearing with me. jlm       *start*01138 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 OCT 88 13:15:06 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 17 Oct 88  13:13:51 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA05099g; Mon, 17 Oct 88 13:13:38 PDTReceived: by bhopal id AA03278g; Mon, 17 Oct 88 13:12:04 PDTDate: Mon, 17 Oct 88 13:12:04 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810172012.AA03278@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Thu, 13 Oct 88 15:41 EDT <881013154128.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 8)re: My notes from Fairfax meeting...I also remember Sandra remarking that the proposal part was "unreadable".This relates somewhat to my comment about the lack of focus on TYPEPand unnecessary, possibly confusing, detail about how make-array shouldwork.  I expect to do another version "soon", but possibly as late asnext week.-- JonL --*start*00807 00024 US Date: 25 Oct 88 16:15 PDTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 8)In-reply-to: Jon L White <jonl@lucid.com>'s message of Mon, 17 Oct 88 13:12:04 PDTTo: Jon L White <jonl@lucid.com>cc: masinterJust to remind you that you promised a new version of this proposal this week. I'm counting on you to make sure that all of the comments we got on Version 8 have been addressed to the satisfaction of the commenters.Should DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES as submitted by Dan Pierson still be a separate issue? Mail since the DRAFT Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 8):10 Oct Jim McDonald <jlm@lucid.com>13 Oct Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM> 13 Oct sandra%defun@cs.utah.edu (Sandra J Loosemore)*start*23671 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 NOV 88 13:17:07 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 3 Nov 88  21:42:26 PSTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA01968g; Thu, 3 Nov 88 21:41:29 PSTReceived: by bhopal id AA24037g; Thu, 3 Nov 88 21:40:04 PSTDate: Thu, 3 Nov 88 21:40:04 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811040540.AA24037@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)This version is a substantial re-write, to address issues raised sincethe X3J13 meeting in Fairfax, especially in the mail msgs:  10 Oct Jim McDonald <jlm@lucid.com>  13 Oct Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>   13 Oct sandra%defun@cs.utah.edu (Sandra J Loosemore)One major change is the re-introduction of "upgrading".  Not only has this word crept into most people's vocabulary, but Pedersen has provided a sufficient rationale for using it -- it is a movement upward in thetype-hierarchy lattice.  We have found one implementation that does noupgrading; and we have had to clarify some things about upgrading, tocover existing practice.  This is reflected in two sub-items in the proposal part.  Although the proposal is a CHANGE, is now consists of seven sub-items:  One ADDITION  Two incompatible CHANGES  Three CLARIFICATIONS  And "a partridge in a pear tree"The seventh item is the definition for subtypep on complexes; I'm notsure whether this is new (because CLtL forgot about it), or a change,or simply a clarification.  Let's hope it's at least right!-- JonL --P.S.  I say "we" above, since many people helped in the production of      this version.!Issue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45               Functions: TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                          ARRAY-ELEMENT-TYPE, CLtL p. 291               The type-specifiers:                          ARRAY,  SIMPLE-ARRAY,  VECTOR,  SIMPLE-VECTOR                          COMPLEXRelated Issues: SUBTYPEP-TOO-VAGUE, LIST-TYPE-SPECIFIERCategory:      CHANGEEdit history:  Version 1, 13-May-88, JonL               Version 2, 23-May-88, JonL                  (typo fixes, comments from moon, rearrange some discussion)               Version 3, 02-Jun-88, JonL                  (flush alternate proposal ["flush-upgrading"]; consequently,                 move more of discussion back to discussion section.               Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings)               (Version 5 edit history missing)               Version 6, 6-Oct-88, Moon                (fix typos, cover subtypep explicitly, add complex,                 change name of UPGRADE-ARRAY-ELEMENT-TYPE)               Version 7, 7-Oct-88, JonL (more name and wording changes)               Version 8,  8-Oct-88, Masinter (wording, discussion)               Version 9, 31-Oct-88, JonL (major re-wording to accommodate		 recent discussion; esp. re-introduce and clarify "upgrading")Problem description: CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination";  see CLtL, section 4.5 "Type  Specifiers That Specialize" (p.45 and following)  The phrase  "for declaration"  encompasses type-specifiers passed in as the  :element-type argument to  MAKE-ARRAY, passed in as the <result-type>  argument to COERCE, and used in THE and DECLARE type declarations.  The  phrase "for discrimination" refers to the type-specifiers passed in as  the <type> argument(s) to TYPEP and SUBTYPEP. One consequence of this distinction is that a variable declared to be of  type <certain-type>, and all of whose assigned objects are created in  accordance with that type, may still have none of its values ever satisfy  the TYPEP predicate with that type-specifier.   One type-specifier with  this property is           (ARRAY <element-type>)  for various implementation dependent values of <element-type>.  For example, in most implementations of CL, an array X created with an element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy        (TYPEP X '(ARRAY (SIGNED-BYTE 8))), or        (TYPEP X '(ARRAY T))  but (almost) never will it satisfy         (TYPEP X '(ARRAY (SIGNED-BYTE 5))). This is entirely permissible within the scope of standardization on MAKE-ARRAY, where an implementation is required only to construct up the result out of "the most specialized [element] type that can nevertheless accommodate elements of the given type [the :element-type argument]" (see CLtL, p287).  That is, an implementation may in fact only provide a  very small number of equivalence classes of element-types for storing  arrays, corresponding to its repertoire of specialized storage techniques; and it is explicitly permitted to "upgrade" any element-type request into  one of its built-in repertoire (see also  CLtL, p45, second and third paragraphs under Section 4.5.) As a practical matter, almost every existing implementation does some  serious upgrading of the :element-type argument given to MAKE-ARRAY.   Yet the difference between "for declaration" and "for discrimination"  has been very confusing to many people.  Similarly, portability is hindered when users do not know just how a given implementation does  upgrading.  The type specifier (COMPLEX <part-type>) also falls in the  domain of CLtL Section 4.5.  Currently, only one implementation actually provides any kind  of specialized storage for complex parts; and in this case, the practical matter is less urgent, since the kind of upgrading happening is so obvious  as to cause little or no confusion.Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING) Short Summary:  ** Eliminate the distinction between type-specifiers "for declaration" and     "for discrimination".  In short, change the meaning of array and     complex type specifiers in favor of the "for declaration" meaning.  ** Change the meaning of TYPEP to be in accord with "for declaration"     meaning of type-specifiers.  ** Add an implementation-dependent function that reveals how a given      type-specifier for array element-types is upgraded.  Add another such      function that reveals how a given type-specifier for complex parts is     upgraded.  ** Clarify that "upgrading" implies a movement upwards in the type-     hierarchy lattice; i.e., if <type> upgrades to <Type>, then     <Type> must be a super-type of <type>.  ** Clarify that upgrading an array element-type is independent of any      other property of arrays, such as rank, adjustability, fill-pointers,      etc.    ** Clarify how SUBTYPEP thus behaves on array type-specifiers.    ** Define how SUBTYPEP behaves on complex type-specifiers.   Note that despite this issue's name, the detailed specifications herein  apply to the type system -- not to the behavior of MAKE-ARRAY, nor to how arrays are actually implemented. Details:  First, some definitions: Two type-specifiers <type1> and <type2> are said   to be "type-equivalent" if and only if each one specifies a subtype of the  other one.  For example, (UNSIGNED-BYTE 5) and (MOD 32) are two different   type- specifiers that always refer to the same sets of things; hence they   are type-equivalent.  But (UNSIGNED-BYTE 5) and (SIGNED-BYTE 8) are not   type- equivalent since the former refers to a proper subset of the latter.  Two type-specifiers <type1> and <type2> are said to be "type-disjoint"  if their specified intersection is null.  For example, INTEGER and FLOAT   are type disjoint by definition (see CLtL p.33), and (INTEGER 3 5) and   (INTEGER 7 10) are type-disjoint because the specified ranges have no  elements in common. *. Eliminate the distinction between types "for declaration" and "for     discrimination".  In particular, elminate any such reference in the     discussion of array and complex type-specifiers; this would include     documentation patterned after the discussion in section 4.5, pp. 45-7,     especially the example on p.46 that says "See ARRAY-ELEMENT-TYPE".    Change the meaning of (ARRAY <element-type>), as well as any of the    subtypes of ARRAY (such as SIMPLE-ARRAY, VECTOR, etc.) in favor of the     "for declaration" meaning.  Make the similar simplification for the     <part-type> specifiers in the COMPLEX type-specifier. *. Change the meaning of (TYPEP <x> '(ARRAY <type>)), where <type> is not     *, to be true if and only if <x> is an array that could be the result     of giving <type> as the :element-type argument to MAKE-ARRAY.  While    (ARRAY *) refers to all arrays regardless of element type, (ARRAY <type>)    refers only to those arrays that can result from giving <type> as the    :element-type argument to the function MAKE-ARRAY.  Change the meanings    for (SIMPLE-ARRAY <type>) and (VECTOR <type>) in the same way.    Change the meaning of (TYPEP <x> '(COMPLEX <type>)) similarly.  Thus,    (COMPLEX <type>) refers to all complex numbers that can result from     giving numbers of type <type> to the function COMPLEX, plus all other     complex numbers of the same specialized representation.  Remember that    both the real and the imaginary parts of any such complex number must     satisfy:                (TYPEP <real-or-imag-part> '<type>).  *. Add the function UPGRADED-ARRAY-ELEMENT-TYPE of one argument, which    returns the element type of the most specialized array representation    capable of holding items of the given argument type.   Note that except    for storage allocation consequences, it could be defined as:      (DEFUN UPGRADED-ARRAY-ELEMENT-TYPE (TYPE)        (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE)))    Since element-type upgrading is a fundamental operation implicit in     almost every existing implementation of MAKE-ARRAY, the purpose of this     added function is primarily to reveal how an implementation does its    upgrading.    Add the function UPGRADED-COMPLEX-PART-TYPE of one argument that    returns the part type of the most specialized complex number    representation that can hold parts of the given argument type. *. Clarify that "upgrading" implies a movement upwards in the type-    hierarchy lattice.  Specifically, the type-specifier <type> must be    a subtype of (UPGRADED-ARRAY-ELEMENT-TYPE '<type>).  Furthermore, if     <type1> is a subtype of <type2>, then:            (UPGRADED-ARRAY-ELEMENT-TYPE '<type1>)    must also be a subtype of:            (UPGRADED-ARRAY-ELEMENT-TYPE '<type2>).      Note however, that two type-disjoint types can in fact be upgraded into     the same thing.    Clarify that ARRAY-ELEMENT-TYPE returns the upgraded element type    for the array; in particular, any documentation patterned after     the sentence on p. 291 begining "This set may be larger than the     set requested when the array was created; for example . . ." should    be embellished with this clarification.    Similarly, the type-specifier <type> must be a subtype of     (UPGRADED-COMPLEX-PART-TYPE <type>). *. Clarify that upgrading an array element-type is independent of any     other property of arrays, such as rank, adjustability, fill-pointers,     displacement etc.  For all such properties other than rank this should     be obvious (since they are not expressible in the language of     type-specifiers); but note that unless it is also independent of rank,     it would not be consistently possible to displace arrays to those of     differing rank. *. Clarify that SUBTYPEP on ARRAY type-specifiers is as follows:      For all type-specifiers <type1> and <type2> other than *, require     (ARRAY <type1>) and (ARRAY <type2>) to be type-equivalent if and only     if they refer to arrays of exactly the same specialized representation;     and require them to be type-disjoint if and only if they refer to arrays     of different, distinct specialized representations.  This definition    follows that implicitly prescribed in CLtL.    As a consequence of the preceding change to TYPEP and of the definition     of UPGRADED-ARRAY-ELEMENT-TYPE, the two type specifiers                 (ARRAY <type1>)  and                 (ARRAY <type2>)    are type-equivalent if and only if                (UPGRADED-ARRAY-ELEMENT-TYPE '<type1>)  and                (UPGRADED-ARRAY-ELEMENT-TYPE '<type2>)     are type-equivalent.  This is another way of saying that `(ARRAY <type>)    and `(ARRAY ,(UPGRADED-ARRAY-ELEMENT-TYPE '<type>)) refer to the same    set of specialized array representations.    This defines the behavior of SUBTYPEP on array type-specifiers; namely:                (SUBTYPEP '(ARRAY <type1>) '(ARRAY <type2>))    is true if and only if                (UPGRADED-ARRAY-ELEMENT-TYPE '<type1>)  and                (UPGRADED-ARRAY-ELEMENT-TYPE '<type2>)    are type-equivalent. *. Define SUBTYPEP on COMPLEX type-specifiers as follows:     For all type-specifiers <type1> and <type2> other than *,             (SUBTYPEP '(COMPLEX <type1>) '(COMPLEX <type2>))    is  T T  if:      1. <type1> is a subtype of <type2>, or      2. (UPGRADED-COMPLEX-PART-TYPE '<type1>) is type-equivalent         to (UPGRADED-COMPLEX-PART-TYPE '<type2>);  in this case,         (COMPLEX <type1>) and (COMPLEX <type2>) both refer to the          same specialized representation.   The result is  NIL T  otherwise. The small differences between the SUBTYPEP specification for ARRAY and  for COMPLEX are necessary because there is no creation function for  complexes which allows one to specify the resultant part type independently of the actual types of the parts.  Thus in the case of COMPLEX, we must  refer to the actual type of the parts, although a number can be a member  of more than one type; e.g., 17 is of type (MOD 18) as well as of type (MOD 256); and 2.3f5 is of type SINGLE-FLOAT was well as FLOAT. The form:     (SUBTYPEP '(COMPLEX SINGLE-FLOAT) '(COMPLEX FLOAT)) must be true in all implementations; but:     (SUBTYPEP '(ARRAY SINGLE-FLOAT) '(ARRAY FLOAT)) is true only in implementations that do not have a specialized array representation for single-floats distinct from that for other floats.Test cases: Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type.  This will be an implementation dependent search, but in every implementation that the proposer has tested, there will be some such types; often, (SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, both of the following forms return T T:  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))            (array-element-type (make-array 0 :element-type '<aet-y>)))  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))            (array-element-type (make-array 0 :element-type '<aet-x>))) To eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>)) Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>)) Additionally, to show that un-equivalent type-specifiers that use the same specialized array type should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-y>))Rationale: This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination".  The suggested changes to the interpretation of array and complex type-specifiers follow from defining type-specifiers as names for collections of objects, on TYPEP being a set membership test, and SUBTYPEP a subset test on collections of objects.Current Practice: Every vendor's implementation that the proposer has queried has a finite  set of specialized array representations, such that two non-equivalent  element types can be found that use the same specialized array  representation; this includes Lucid, Vaxlisp, Symbolics, TI, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other implementations fail it. The Explorer returns NIL for all six tests in [A], [B], and [C]. Allegedly, the PCLS implementation does no "upgrading"; each array "remembers" exactly the type-specifier handed to the MAKE-ARRAY call that created it.  Thus the test cases are not applicable to PCLS, since the precondition cannot be met (i.e., find two non-type-equivalent type-specifiers that are non-trivially upgraded by make-array). Only the TI Explorer offers any specialized representation for complexes; part types of SINGLE-FLOAT and DOUBLE-FLOAT are specialized.Cost to Implementors: This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of TYPEP and SUBTYPEP.Cost to Users: Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about MAKE-ARRAY returning a result that isn't of "the obvious type".  Since the change is incompatible, some user code might have to be changed.Cost of non-adoption: Continuing confusion in the user community.Benefits: It will greatly reduce confusion in the user community.  The fact that (MAKE-ARRAY <n> :ELEMENT-TYPE '<type>) frequently is not of type  (ARRAY <type>) has been very confusing to almost everyone.   Portability of applications will be increased slightly, since the behavior of      (TYPEP (MAKE-ARRAY <n> :ELEMENT-TYPE <type>) '(ARRAY <type>))  will no longer be implementation-dependent. Esthetics: Reducing the confusing distinction between type-specifiers "for declaration" and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of data they purport to name.  Thus this is a step towards increased elegance.Discussion: This issue was prompted by a lengthy discussion on the Common Lisp mailing list.  See for example a series of exchanges started on Thu,  17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com> under the subject line of "Types in CL".  See also the exchange started  Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu> under the subject line of "TYPEP warp implications" Although the types STRING,  BIT-VECTOR,  SIMPLE-STRING, and  SIMPLE-BIT-VECTOR are subtypes of the ARRAY type, they are not specifically discussed in this proposal.  The reason is that  they are not type-specifiers "that specialize", but are merely  abbreviations as follows:   STRING             ==  (VECTOR STRING-CHAR)   SIMPLE-STRING      ==  (SIMPLE-ARRAY STRING-CHAR (*))   BIT-VECTOR         ==  (VECTOR BIT)   SIMPLE-BIT-VECTOR  ==  (SIMPLE-ARRAY BIT (*)) Thus their semantics could be affected only in an implementation that doesn't support a specific "specialized storage" type for arrays of bits and vectors of string-chars.  But in fact, every CL implementation  must appear to support "specialized storage" for bit-arrays and strings, even if it means nothing more than remembering the fact that such an array was created with that element-type.  This is required in order for strings, bit-vectors,  and bit-arrays to be disjoint datatypes  (see CLtL p.34; see also the definitions of BIT-ARRAY and STRING found  in CLtL p.293, Section 17.4, and in CLtL p.299.) We considered the possibility of flushing the permission to "upgrade"; for example, it could be made a requirement that:     (ARRAY-ELEMENT-TYPE (MAKE-ARRAY <n> :ELEMENT-TYPE <type>)) always be equal to <type> (or, at least type-equivalent to <type>) for all valid type specifiers <type>.  This has several problems: it increases the storage requirement for many kinds of arrays, and hides a relevant part of the underlying implementation for no apparently  good reason.  However, it would increase portability, since it would be  much more difficult, for example, to write a program that created an array with one element-type, say, (UNSIGNED-BYTE 5), but operated on it  assuming a non-trivial upgraded element-type, say, (UNSIGNED-BYTE 8). Under this proposal, it is valid for an implementation of MAKE-ARRAY  to have arrays "remember" the type-equivalence class of the original  :element-type argument; such an implementation would satisfy all of  the  constraints listed above. We considered a suggestion to restrict the set of "known" array element  types; this would gain portability at the expense of limiting the  language. We considered leaving out of the proposal the addition of the two functions UPGRADED-ARRAY-ELEMENT-TYPE and UPGRADED-COMPLEX-PART-TYPE. But it was noted that every implementation of CL supports exactly that functionality somewhere in its implementation of MAKE-ARRAY; and exposing this to the user would be a good thing.  Furthermore, the existence of at least UPGRADED-ARRAY-ELEMENT-TYPE makes the clarifications on "upgrading" and SUBTYPEP implications easier.  Finally, there would be no other way at all to pinpoint just how complex parts are upgraded, since there is no type information available except for the actual types of the parts. Since this proposal contains the implication:     (ARRAY <type1>)  is-type-equivalent-to  (ARRAY <type2>)     ==>       <type1>  is-type-equivalent-to  <type2> then the question naturally arises "Does the reverse implication hold?"   That is, should two non-EQ but type-equivalent type-specifiers <type1> and <type2> always give rise to the same array types?   For example,  consider SHORT-FLOAT and SINGLE-FLOAT in an implementation where these  are type-equivalent (see CLtL section 2.1.3).  One may desire to implement  (ARRAY SHORT-FLOAT) and (ARRAY SINGLE-FLOAT) differently.  Say, for example  that the former is packed into 16-bit half-words, whereas the latter is  packed into 32-bit words; but for either kind of packing, the result of  AREF is an ordinary "single-float".  The whole point of the type-specifier to make-array is merely to specify a packing technique for "packed float"  arrays.  This "krinkle", however, will not be addressed by the proposal  herein; it should simply be remembered that the implication above goes  only one way, and is not an "if-and-only-if" link.*start*23227 00024 USaDate:  5 Dec 88 11:45 PSTSender: masinter.pato: X3J13@Sail.stanford.eduSubject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)from: CL-Cleanup@Sail.Stanford.eduREPLY-TO: cl-cleanup@Sail.Stanford.Educc: MasinterLine-fold: NOThis is the first of a number of issues for which we have preparednew versions since the October meeting. There will be a hardcopymailing of issues and a ballot; details in a separate message later.Ballot issues will also be available for anonymous FTP from hostarisia.xerox.com in the directory clcleanup/pending. As usual, if you have any comments, questions, please respondto CL-CLEANUP@Sail.stanford.edu rather than to the entire X3J13 list.Forum:         CleanupIssue:         ARRAY-TYPE-ELEMENT-TYPE-SEMANTICSReferences:    Data types and Type specifiers: CLtL p. 11; Sect. 4.5, p.45               Functions: TYPEP and SUBTYPEP; CLtL Sect. 6.2.1, p.72                          ARRAY-ELEMENT-TYPE, CLtL p. 291               The type-specifiers:                          ARRAY,  SIMPLE-ARRAY,  VECTOR,  SIMPLE-VECTOR                          COMPLEXRelated Issues: SUBTYPEP-TOO-VAGUE, LIST-TYPE-SPECIFIERCategory:      CHANGEEdit history:  Version 1, 13-May-88, JonL               Version 2, 23-May-88, JonL                  (typo fixes, comments from moon, rearrange some discussion)               Version 3, 02-Jun-88, JonL                  (flush alternate proposal ["flush-upgrading"]; consequently,                 move more of discussion back to discussion section.               Version 4, 01-Oct-88, Jan Pedersen & JonL                (reduce discussion, and "cleanup" wordings)               (Version 5 edit history missing)               Version 6, 6-Oct-88, Moon                (fix typos, cover subtypep explicitly, add complex,                 change name of UPGRADE-ARRAY-ELEMENT-TYPE)               Version 7, 7-Oct-88, JonL (more name and wording changes)               Version 8,  8-Oct-88, Masinter (wording, discussion)               Version 9, 31-Oct-88, JonL (major re-wording to accommodate		 recent discussion; esp. re-introduce and clarify "upgrading")Problem description: CLtL occasionally draws a distinction between type-specifiers "for declaration" and "for discrimination";  see CLtL, section 4.5 "Type  Specifiers That Specialize" (p.45 and following)  The phrase  "for declaration"  encompasses type-specifiers passed in as the  :element-type argument to  MAKE-ARRAY, passed in as the <result-type>  argument to COERCE, and used in THE and DECLARE type declarations.  The  phrase "for discrimination" refers to the type-specifiers passed in as  the <type> argument(s) to TYPEP and SUBTYPEP. One consequence of this distinction is that a variable declared to be of  type <certain-type>, and all of whose assigned objects are created in  accordance with that type, may still have none of its values ever satisfy  the TYPEP predicate with that type-specifier.   One type-specifier with  this property is           (ARRAY <element-type>)  for various implementation dependent values of <element-type>.  For example, in most implementations of CL, an array X created with an element-type of (SIGNED-BYTE 5) will, depending on the vendor, either satisfy        (TYPEP X '(ARRAY (SIGNED-BYTE 8))), or        (TYPEP X '(ARRAY T))  but (almost) never will it satisfy         (TYPEP X '(ARRAY (SIGNED-BYTE 5))). This is entirely permissible within the scope of standardization on MAKE-ARRAY, where an implementation is required only to construct up the result out of "the most specialized [element] type that can nevertheless accommodate elements of the given type [the :element-type argument]" (see CLtL, p287).  That is, an implementation may in fact only provide a  very small number of equivalence classes of element-types for storing  arrays, corresponding to its repertoire of specialized storage techniques; and it is explicitly permitted to "upgrade" any element-type request into  one of its built-in repertoire (see also  CLtL, p45, second and third paragraphs under Section 4.5.) As a practical matter, almost every existing implementation does some  serious upgrading of the :element-type argument given to MAKE-ARRAY.   Yet the difference between "for declaration" and "for discrimination"  has been very confusing to many people.  Similarly, portability is hindered when users do not know just how a given implementation does  upgrading.  The type specifier (COMPLEX <part-type>) also falls in the  domain of CLtL Section 4.5.  Currently, only one implementation actually provides any kind  of specialized storage for complex parts; and in this case, the practical matter is less urgent, since the kind of upgrading happening is so obvious  as to cause little or no confusion.Proposal: (ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS:UNIFY-UPGRADING) Short Summary:  ** Eliminate the distinction between type-specifiers "for declaration" and     "for discrimination".  In short, change the meaning of array and     complex type specifiers in favor of the "for declaration" meaning.  ** Change the meaning of TYPEP to be in accord with "for declaration"     meaning of type-specifiers.  ** Add an implementation-dependent function that reveals how a given      type-specifier for array element-types is upgraded.  Add another such      function that reveals how a given type-specifier for complex parts is     upgraded.  ** Clarify that "upgrading" implies a movement upwards in the type-     hierarchy lattice; i.e., if <type> upgrades to <Type>, then     <Type> must be a super-type of <type>.  ** Clarify that upgrading an array element-type is independent of any      other property of arrays, such as rank, adjustability, fill-pointers,      etc.    ** Clarify how SUBTYPEP thus behaves on array type-specifiers.    ** Define how SUBTYPEP behaves on complex type-specifiers.   Note that despite this issue's name, the detailed specifications herein  apply to the type system -- not to the behavior of MAKE-ARRAY, nor to how arrays are actually implemented. Details:  First, some definitions: Two type-specifiers <type1> and <type2> are said   to be "type-equivalent" if and only if each one specifies a subtype of the  other one.  For example, (UNSIGNED-BYTE 5) and (MOD 32) are two different   type- specifiers that always refer to the same sets of things; hence they   are type-equivalent.  But (UNSIGNED-BYTE 5) and (SIGNED-BYTE 8) are not   type- equivalent since the former refers to a proper subset of the latter.  Two type-specifiers <type1> and <type2> are said to be "type-disjoint"  if their specified intersection is null.  For example, INTEGER and FLOAT   are type disjoint by definition (see CLtL p.33), and (INTEGER 3 5) and   (INTEGER 7 10) are type-disjoint because the specified ranges have no  elements in common. *. Eliminate the distinction between types "for declaration" and "for     discrimination".  In particular, elminate any such reference in the     discussion of array and complex type-specifiers; this would include     documentation patterned after the discussion in section 4.5, pp. 45-7,     especially the example on p.46 that says "See ARRAY-ELEMENT-TYPE".    Change the meaning of (ARRAY <element-type>), as well as any of the    subtypes of ARRAY (such as SIMPLE-ARRAY, VECTOR, etc.) in favor of the     "for declaration" meaning.  Make the similar simplification for the     <part-type> specifiers in the COMPLEX type-specifier. *. Change the meaning of (TYPEP <x> '(ARRAY <type>)), where <type> is not     *, to be true if and only if <x> is an array that could be the result     of giving <type> as the :element-type argument to MAKE-ARRAY.  While    (ARRAY *) refers to all arrays regardless of element type, (ARRAY <type>)    refers only to those arrays that can result from giving <type> as the    :element-type argument to the function MAKE-ARRAY.  Change the meanings    for (SIMPLE-ARRAY <type>) and (VECTOR <type>) in the same way.    Change the meaning of (TYPEP <x> '(COMPLEX <type>)) similarly.  Thus,    (COMPLEX <type>) refers to all complex numbers that can result from     giving numbers of type <type> to the function COMPLEX, plus all other     complex numbers of the same specialized representation.  Remember that    both the real and the imaginary parts of any such complex number must     satisfy:                (TYPEP <real-or-imag-part> '<type>).  *. Add the function UPGRADED-ARRAY-ELEMENT-TYPE of one argument, which    returns the element type of the most specialized array representation    capable of holding items of the given argument type.   Note that except    for storage allocation consequences, it could be defined as:      (DEFUN UPGRADED-ARRAY-ELEMENT-TYPE (TYPE)        (ARRAY-ELEMENT-TYPE (MAKE-ARRAY 0 :ELEMENT-TYPE TYPE)))    Since element-type upgrading is a fundamental operation implicit in     almost every existing implementation of MAKE-ARRAY, the purpose of this     added function is primarily to reveal how an implementation does its    upgrading.    Add the function UPGRADED-COMPLEX-PART-TYPE of one argument that    returns the part type of the most specialized complex number    representation that can hold parts of the given argument type. *. Clarify that "upgrading" implies a movement upwards in the type-    hierarchy lattice.  Specifically, the type-specifier <type> must be    a subtype of (UPGRADED-ARRAY-ELEMENT-TYPE '<type>).  Furthermore, if     <type1> is a subtype of <type2>, then:            (UPGRADED-ARRAY-ELEMENT-TYPE '<type1>)    must also be a subtype of:            (UPGRADED-ARRAY-ELEMENT-TYPE '<type2>).      Note however, that two type-disjoint types can in fact be upgraded into     the same thing.    Clarify that ARRAY-ELEMENT-TYPE returns the upgraded element type    for the array; in particular, any documentation patterned after     the sentence on p. 291 begining "This set may be larger than the     set requested when the array was created; for example . . ." should    be embellished with this clarification.    Similarly, the type-specifier <type> must be a subtype of     (UPGRADED-COMPLEX-PART-TYPE <type>). *. Clarify that upgrading an array element-type is independent of any     other property of arrays, such as rank, adjustability, fill-pointers,     displacement etc.  For all such properties other than rank this should     be obvious (since they are not expressible in the language of     type-specifiers); but note that unless it is also independent of rank,     it would not be consistently possible to displace arrays to those of     differing rank. *. Clarify that SUBTYPEP on ARRAY type-specifiers is as follows:      For all type-specifiers <type1> and <type2> other than *, require     (ARRAY <type1>) and (ARRAY <type2>) to be type-equivalent if and only     if they refer to arrays of exactly the same specialized representation;     and require them to be type-disjoint if and only if they refer to arrays     of different, distinct specialized representations.  This definition    follows that implicitly prescribed in CLtL.    As a consequence of the preceding change to TYPEP and of the definition     of UPGRADED-ARRAY-ELEMENT-TYPE, the two type specifiers                 (ARRAY <type1>)  and                 (ARRAY <type2>)    are type-equivalent if and only if                (UPGRADED-ARRAY-ELEMENT-TYPE '<type1>)  and                (UPGRADED-ARRAY-ELEMENT-TYPE '<type2>)     are type-equivalent.  This is another way of saying that `(ARRAY <type>)    and `(ARRAY ,(UPGRADED-ARRAY-ELEMENT-TYPE '<type>)) refer to the same    set of specialized array representations.    This defines the behavior of SUBTYPEP on array type-specifiers; namely:                (SUBTYPEP '(ARRAY <type1>) '(ARRAY <type2>))    is true if and only if                (UPGRADED-ARRAY-ELEMENT-TYPE '<type1>)  and                (UPGRADED-ARRAY-ELEMENT-TYPE '<type2>)    are type-equivalent. *. Define SUBTYPEP on COMPLEX type-specifiers as follows:     For all type-specifiers <type1> and <type2> other than *,             (SUBTYPEP '(COMPLEX <type1>) '(COMPLEX <type2>))    is  T T  if:      1. <type1> is a subtype of <type2>, or      2. (UPGRADED-COMPLEX-PART-TYPE '<type1>) is type-equivalent         to (UPGRADED-COMPLEX-PART-TYPE '<type2>);  in this case,         (COMPLEX <type1>) and (COMPLEX <type2>) both refer to the          same specialized representation.   The result is  NIL T  otherwise. The small differences between the SUBTYPEP specification for ARRAY and  for COMPLEX are necessary because there is no creation function for  complexes which allows one to specify the resultant part type independently of the actual types of the parts.  Thus in the case of COMPLEX, we must  refer to the actual type of the parts, although a number can be a member  of more than one type; e.g., 17 is of type (MOD 18) as well as of type (MOD 256); and 2.3f5 is of type SINGLE-FLOAT was well as FLOAT. The form:     (SUBTYPEP '(COMPLEX SINGLE-FLOAT) '(COMPLEX FLOAT)) must be true in all implementations; but:     (SUBTYPEP '(ARRAY SINGLE-FLOAT) '(ARRAY FLOAT)) is true only in implementations that do not have a specialized array representation for single-floats distinct from that for other floats.Examples: Let <aet-x> and <aet-y> be two distinct type specifiers that are definitely not type-equivalent in a given implementation, but for which make-array will return an object of the same array type.  This will be an implementation dependent search, but in every implementation that the proposer has tested, there will be some such types; often, (SIGNED-BYTE 5) and (SIGNED-BYTE 8) will work. Thus, in each case, both of the following forms return T T:  (subtypep (array-element-type (make-array 0 :element-type '<aet-x>))            (array-element-type (make-array 0 :element-type '<aet-y>)))  (subtypep (array-element-type (make-array 0 :element-type '<aet-y>))            (array-element-type (make-array 0 :element-type '<aet-x>))) To eliminate the distinction between "for declaration" and "for discrimination" both of the following should be true:  [A]   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-y>)) Since (array <aet-x>) and (array <aet-y>) are different names for exactly the same set of objects, these names should be type-equivalent. That implies that the following set of tests should also be true:  [B]   (subtypep '(array <aet-x>) '(array <aet-y>))   (subtypep '(array <aet-y>) '(array <aet-x>)) Additionally, to show that un-equivalent type-specifiers that use the same specialized array type should be equivalent as element-type specifiers, the following type tests should be true:  [C]   (typep (make-array 0 :element-type '<aet-y>)          '(array <aet-x>))   (typep (make-array 0 :element-type '<aet-x>)          '(array <aet-y>))Rationale: This proposal legitimizes current practice, and removes the obscure and un-useful distinction between type-specifiers "for declaration" and "for discrimination".  The suggested changes to the interpretation of array and complex type-specifiers follow from defining type-specifiers as names for collections of objects, on TYPEP being a set membership test, and SUBTYPEP a subset test on collections of objects.Current Practice: Every vendor's implementation that the proposer has queried has a finite  set of specialized array representations, such that two non-equivalent  element types can be found that use the same specialized array  representation; this includes Lucid, Vaxlisp, Symbolics, TI, Franz, and Xerox. Most implementations fail tests [A] and [C] part 1, but pass tests [A] and [C] part 2; this is a consequence of implementing the distinction between "for declaration" and "for discrimination".  Lucid and Xerox both pass test [B], and the other implementations fail it. The Explorer returns NIL for all six tests in [A], [B], and [C]. Allegedly, the PCLS implementation does no "upgrading"; each array "remembers" exactly the type-specifier handed to the MAKE-ARRAY call that created it.  Thus the test cases are not applicable to PCLS, since the precondition cannot be met (i.e., find two non-type-equivalent type-specifiers that are non-trivially upgraded by make-array). The TI Explorer offers specialized representation for complexes; part types of SINGLE-FLOAT and DOUBLE-FLOAT are specialized.Cost to Implementors: This proposal is an incompatible change to the current language specification, but only a small amount of work should be required in each vendor's implementation of TYPEP and SUBTYPEP.Cost to Users: Because of the prevalence of confusion in this area, it seems unlikely that any user code will have to be changed.  In fact, it is more likely that some of the vendors will cease to get bug reports about MAKE-ARRAY returning a result that isn't of "the obvious type".  Since the change is incompatible, some user code might have to be changed.Cost of non-adoption: Continuing confusion in the user community.Benefits: It will greatly reduce confusion in the user community.  The fact that (MAKE-ARRAY <n> :ELEMENT-TYPE '<type>) frequently is not of type  (ARRAY <type>) has been very confusing to almost everyone.   Portability of applications will be increased slightly, since the behavior of      (TYPEP (MAKE-ARRAY <n> :ELEMENT-TYPE <type>) '(ARRAY <type>))  will no longer be implementation-dependent. Esthetics: Reducing the confusing distinction between type-specifiers "for declaration" and "for discrimination" is a simplifying step -- it is a much simpler rule to state that the type-specifiers actually describe the collections of data they purport to name.  Thus this is a step towards increased elegance.Discussion: This issue was prompted by a lengthy discussion on the Common Lisp mailing list.  See for example a series of exchanges started on Thu,  17 Dec 87 10:48:05 PST by Jeff Barnett <jbarnett@nrtc.northrop.com> under the subject line of "Types in CL".  See also the exchange started  Wed, 6 Jan 88 23:21:16 PST by Jon L White <edsel!jonl@labrea.stanford.edu> under the subject line of "TYPEP warp implications" Although the types STRING,  BIT-VECTOR,  SIMPLE-STRING, and  SIMPLE-BIT-VECTOR are subtypes of the ARRAY type, they are not specifically discussed in this proposal.  The reason is that  they are not type-specifiers "that specialize", but are merely  abbreviations as follows:   STRING             ==  (VECTOR STRING-CHAR)   SIMPLE-STRING      ==  (SIMPLE-ARRAY STRING-CHAR (*))   BIT-VECTOR         ==  (VECTOR BIT)   SIMPLE-BIT-VECTOR  ==  (SIMPLE-ARRAY BIT (*)) Thus their semantics could be affected only in an implementation that doesn't support a specific "specialized storage" type for arrays of bits and vectors of string-chars.  But in fact, every CL implementation  must appear to support "specialized storage" for bit-arrays and strings, even if it means nothing more than remembering the fact that such an array was created with that element-type.  This is required in order for strings, bit-vectors,  and bit-arrays to be disjoint datatypes  (see CLtL p.34; see also the definitions of BIT-ARRAY and STRING found  in CLtL p.293, Section 17.4, and in CLtL p.299.) We considered the possibility of flushing the permission to "upgrade"; for example, it could be made a requirement that:     (ARRAY-ELEMENT-TYPE (MAKE-ARRAY <n> :ELEMENT-TYPE <type>)) always be equal to <type> (or, at least type-equivalent to <type>) for all valid type specifiers <type>.  This has several problems: it increases the storage requirement for many kinds of arrays, and hides a relevant part of the underlying implementation for no apparently  good reason.  However, it would increase portability, since it would be  much more difficult, for example, to write a program that created an array with one element-type, say, (UNSIGNED-BYTE 5), but operated on it  assuming a non-trivial upgraded element-type, say, (UNSIGNED-BYTE 8). Under this proposal, it is valid for an implementation of MAKE-ARRAY  to have arrays "remember" the type-equivalence class of the original  :element-type argument; such an implementation would satisfy all of  the  constraints listed above. We considered a suggestion to restrict the set of "known" array element  types; this would gain portability at the expense of limiting the  language. We considered leaving out of the proposal the addition of the two functions UPGRADED-ARRAY-ELEMENT-TYPE and UPGRADED-COMPLEX-PART-TYPE. But it was noted that every implementation of CL supports exactly that functionality somewhere in its implementation of MAKE-ARRAY; and exposing this to the user would be a good thing.  Furthermore, the existence of at least UPGRADED-ARRAY-ELEMENT-TYPE makes the clarifications on "upgrading" and SUBTYPEP implications easier.  Finally, there would be no other way at all to pinpoint just how complex parts are upgraded, since there is no type information available except for the actual types of the parts. Since this proposal contains the implication:     (ARRAY <type1>)  is-type-equivalent-to  (ARRAY <type2>)     ==>       <type1>  is-type-equivalent-to  <type2> then the question naturally arises "Does the reverse implication hold?"   That is, should two non-EQ but type-equivalent type-specifiers <type1> and <type2> always give rise to the same array types?   For example,  consider SHORT-FLOAT and SINGLE-FLOAT in an implementation where these  are type-equivalent (see CLtL section 2.1.3).  One may desire to implement  (ARRAY SHORT-FLOAT) and (ARRAY SINGLE-FLOAT) differently.  Say, for example  that the former is packed into 16-bit half-words, whereas the latter is  packed into 32-bit words; but for either kind of packing, the result of  AREF is an ordinary "single-float".  The whole point of the type-specifier to make-array is merely to specify a packing technique for "packed float"  arrays.  This "krinkle", however, will not be addressed by the proposal  herein; it should simply be remembered that the implication above goes  only one way, and is not an "if-and-only-if" link.     (LIST ((PAGE NIL (PAPERSIZE NIL) (0 0 612 792) ((TEXT NIL NIL (72 72 468 648) NIL))) (PAGE NIL (PAPERSIZE Letter FOLIOINFO (ARABIC "" "")) (0 0 612 792) ((TEXT NIL NIL (72 72 468 648) NIL))) (PAGE NIL (PAPERSIZE Letter FOLIOINFO (ARABIC "" "")) (0 0 612 792) ((TEXT NIL NIL (72 72 468 648) NIL)))))        TITAN 
         TITAN 
                 	              #             J              )                                        
i       >      !n       
                                T                           `              0       
                   4             H      X #z*start*01246 00024 US Date:  6 Jan 89 11:57 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: CL-Cleanup@Sail.Stanford.edu's message of 5 Dec 88 11:45 PSTTo: cl-cleanup@Sail.Stanford.Educc: masinter.paThe proposal contains the sentence 'Eliminate the distinction between types "for declaration" and "for     discrimination".'However, the distinction remains for the list form of the FUNCTION type specifier, which is only valid "for declaration".I don't think the proposal removes the list form of the FUNCTION type specifier, or (alternatively, magically) allows the list form of the FUNCTION type specifier to be used for discrimination. I think the sentence needs to be qualified that it applies to COMPLEX and ARRAY and VECTOR type specifiers.I concur with the sentiment that would like to see the proposal amended to remove UPGRADED-COMPLEX-PART-TYPE and UPGRADED-ARRAY-ELEMENT-TYPE, as they are of so extremely limited utility and can be written trivially if really necessary.Stylisticly, this can be accomplished quickly if a bit awkwardly, by saying "The proposal is written using the following two functions, although these functions are not added to the standard."*start*01606 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 22:48:22 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Jan 89  22:45:39 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 06 JAN 89 11:58:01 PSTDate: 6 Jan 89 11:57 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: CL-Cleanup@Sail.Stanford.edu's message of 5 Dec 88 11:45 PSTTo: cl-cleanup@Sail.Stanford.Educc: masinter.paMessage-ID: <890106-115801-255@Xerox>The proposal contains the sentence 'Eliminate the distinction between types "for declaration" and "for     discrimination".'However, the distinction remains for the list form of the FUNCTION typespecifier, which is only valid "for declaration".I don't think the proposal removes the list form of the FUNCTION typespecifier, or (alternatively, magically) allows the list form of theFUNCTION type specifier to be used for discrimination. I think the sentenceneeds to be qualified that it applies to COMPLEX and ARRAY and VECTOR typespecifiers.I concur with the sentiment that would like to see the proposal amended toremove UPGRADED-COMPLEX-PART-TYPE and UPGRADED-ARRAY-ELEMENT-TYPE, as theyare of so extremely limited utility and can be written trivially if reallynecessary.Stylisticly, this can be accomplished quickly if a bit awkwardly, by saying"The proposal is written using the following two functions, although thesefunctions are not added to the standard."*start*00998 00024 US Date: 10 Jan 89 14:41 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Jon L White <jonl@lucid.com>'s message of Tue, 10 Jan 89 04:11:19 PSTTo: Jon L White <jonl@lucid.com>cc: masinter.pa, cl-cleanup@Sail.Stanford.EduEven though all implementations "must have some code" that does the upgrading, the code need not be a Lisp function. For example, KCL might do the upgrading in C, or an implementation might simply upgrade all array element types to T. There's a cost associated with adding functions to the LISP package, including them in the documentation and specification beyond the cost of requiring all implementations to write them -- the cost is in the overhead of testing, documentation, user understanding, burden on implementation model. The benefit of UPGRADE-ARRAY-ELEMENT-TYPE--namely, that it doesn't CONS as much as the portable definition--seems very small and I don't think it outweighs the cost.*start*01093 00024 US Return-Path: <@STONY-BROOK.SCRC.Symbolics.COM,@BOBOLINK.SCRC.Symbolics.COM:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 10 JAN 89 14:56:32 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 518809; 10 Jan 89 17:55:48 ESTDate: Tue, 10 Jan 89 17:55 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)To: Masinter.PAcc: JonL@Lucid.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890110-144153-6753@Xerox>Message-ID: <890110175533.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Also, for any given application, you usually know what types you careabout, so you can write a special-purpose, non-consing version forthat purpose by pre-caching the results at load time. For trivialextra cost, you can have a table incrementally updated only on thefirst call to the portable function with a particular argument, so theend effect is negligible consing even in the general case.*start*01521 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 10 JAN 89 04:12:34 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01880g; Tue, 10 Jan 89 04:09:02 PSTReceived: by bhopal id AA12797g; Tue, 10 Jan 89 04:11:19 PSTDate: Tue, 10 Jan 89 04:11:19 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901101211.AA12797@bhopal>To: masinter.paCc: cl-cleanup@Sail.Stanford.Edu, masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 6 Jan 89 11:57 PST <890106-115801-255@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)re:  'Eliminate the distinction between types "for declaration" and "for         discrimination".'In the initial proposal, I thought it was clear from the context that this applied only to ARRAY type specifiers (and the later added COMPLEX specifiers); but if someone was confused about it, it wouldn't hurt to make it explicit.   re: Stylisticly, this can be accomplished quickly if a bit awkwardly, by saying    "The proposal is written using the following two functions, although these    functions are not added to the standard." [UPGRADE-ARRAY-ELEMENT-TYPE ...]The whole point of proposing these two functions is the acknowledgement thatevery implementation must have them under one name or the other.  So whynot use the same name, so that  user code can access them?   The alternativeof a portable definition is not functinoally equivalent, since it conses.-- JonL --*start*02117 00024 US Date: 11 Jan 89 14:47 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Jon L White <jonl@lucid.com>'s message of Wed, 11 Jan 89 01:24:32 PSTTo: Jon L White <jonl@lucid.com>cc: masinter.pa, cl-cleanup@Sail.Stanford.EduI'll rephrase my statement:The benefit of UPGRADE-ARRAY-ELEMENT-TYPE--namely, that it doesn'tCONS while the simple portable definition does--seems very small; I don't think it outweighs the costs of adding it to the existing language. If UPGRADE-ARRAY-ELEMENT-TYPE were already part of Common Lisp, I don't I probably would not vote to take it out, even though it seems of limited utility. Since it isn't in the language, I vote against adding it.I also think that UPGRADE-ARRAY-ELEMENT-TYPE is strictly less useful than ARRAY-DIMENSION and ARRAY-TOTAL-SIZE and that a first-principle argument would be made against it. UPGRADE-ARRAY-ELEMENT-TYPE answers only a hypothetical issue, viz: what *would* the type of this array be if I *were* to upgrade it.As I think about it, I'm not sure why we rule out the possibility that the upgrading of arrays might happen differently for different arrays: for example, I might have an algorithm that "upgraded" all simple non-adjustable arrays with ARRAY-TOTAL-SIZE less than 2 to ELEMENT-TYPE T, but be more strict about larger arrays.  The major part of the proposal ("Change the meaning of (TYPEP <x> '(ARRAY <type>)), where <type> is not  *, to be true if and only if <x> is an array that could be the result of giving <type> as the :element-type argument to MAKE-ARRAY.") could be kept, and the part that talks about upgrading (Clarify that "upgrading" implies a movement upwards in the type- hierarchy lattice.) would just have to be recast in terms of a specific array. This is counter to the part that says "Clarify that upgrading an array element-type is independent of any     other property of arrays, such as rank, adjustability, fill-pointers,     displacement etc."but I wonder now if that is a clarification -- is it a Change? -- and if it is necessary.*start*02481 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 15:14:39 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  14:54:11 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 11 JAN 89 14:47:55 PSTDate: 11 Jan 89 14:47 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Jon L White <jonl@lucid.com>'s message of Wed, 11 Jan 89 01:24:32 PSTTo: Jon L White <jonl@lucid.com>cc: masinter.pa, cl-cleanup@Sail.Stanford.EduMessage-ID: <890111-144755-10740@Xerox>I'll rephrase my statement:The benefit of UPGRADE-ARRAY-ELEMENT-TYPE--namely, that it doesn'tCONSwhile the simple portable definition does--seems very small; I don't thinkit outweighs the costs of adding it to the existing language. IfUPGRADE-ARRAY-ELEMENT-TYPE were already part of Common Lisp, I don't Iprobably would not vote to take it out, even though it seems of limitedutility. Since it isn't in the language, I vote against adding it.I also think that UPGRADE-ARRAY-ELEMENT-TYPE is strictly less useful thanARRAY-DIMENSION and ARRAY-TOTAL-SIZE and that a first-principle argumentwould be made against it. UPGRADE-ARRAY-ELEMENT-TYPE answers only ahypothetical issue, viz: what *would* the type of this array be if I *were*to upgrade it.As I think about it, I'm not sure why we rule out the possibility that theupgrading of arrays might happen differently for different arrays: forexample, I might have an algorithm that "upgraded" all simplenon-adjustable arrays with ARRAY-TOTAL-SIZE less than 2 to ELEMENT-TYPE T,but be more strict about larger arrays.  The major part of the proposal("Change the meaning of (TYPEP <x> '(ARRAY <type>)), where <type> is not*, to be true if and only if <x> is an array that could be the result ofgiving <type> as the :element-type argument to MAKE-ARRAY.") could be kept,and the part that talks about upgrading (Clarify that "upgrading" implies amovement upwards in the type- hierarchy lattice.) would just have to berecast in terms of a specific array. This is counter to the part that says "Clarify that upgrading an arrayelement-type is independent of any     other property of arrays, such as rank, adjustability, fill-pointers,     displacement etc."but I wonder now if that is a clarification -- is it a Change? -- and if itis necessary.*start*01974 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 21:38:44 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  21:37:54 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 11 JAN 89 21:36:44 PSTDate: 11 Jan 89 21:34 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Jon L White <jonl@lucid.com>'s message of Wed, 11 Jan 89 17:48:32 PSTTo: Jon L White <jonl@lucid.com>cc: Masinter.pa, cl-cleanup@Sail.Stanford.EduMessage-ID: <890111-213644-11560@Xerox>JonL, I was not suggesting a requirement that implementors would have toupgrade different arrays differently. Why would Lucid oppose allowing otherimplementors to take a different implementation strategy? Certainly yourcompiler optimizations could continue to work based on your assertionsabout your own array implementation types.>    but be more strict about larger arrays.  The major part of theproposal>    ("Change the meaning of (TYPEP <x> '(ARRAY <type>)), where <type> isnot>    *, to be true if and only if <x> is an array that could be the resultof>    giving <type> as the :element-type argument to MAKE-ARRAY.") could bekept,>>No, because you would have to say what the other arguments to MAKE-ARRAYwere.>>You know what the other arguments to MAKE-ARRAY are by looking at <x>.Imagine:Implementation A upgrades integer ranges to (SIGNED-BYTE n) for n a powerof 2 up to 32, and then T.Implementation B upgrades integer ranges to (SIGNED-BYTE 32) and then to T.Implementation C upgrades simple small (say, less than total-size 2) arrayslike B, and other arrays like A.  You can implement (C:TYPEP object type) by (if (simple-small-p object)(b:typep object type) (a:typep object type)). I.e., TYPEP need not merelybe implemented by ARRAYP + a test on ARRAY-ELEMENT-TYPE. *start*01710 00024 US Return-Path: <gsb@ALDERAAN.SCRC.Symbolics.COM>Received: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by Xerox.COM ; 11 JAN 89 20:15:13 PSTReceived: from GANG-GANG.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 258908; Wed 11-Jan-89 23:12:43 ESTDate: Wed, 11 Jan 89 23:12 ESTFrom: Glenn S. Burke <gsb@ALDERAAN.SCRC.Symbolics.COM>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)To: jonl@lucid.com, masinter.pacc: cl-cleanup@Sail.Stanford.EduIn-Reply-To: <8901120148.AA07016@bhopal>Message-ID: <19890112041220.9.GSB@GANG-GANG.SCRC.Symbolics.COM>    Date: Wed, 11 Jan 89 17:48:32 PST    From: Jon L White <jonl@lucid.com>    re: As I think about it, I'm not sure why we rule out the possibility that the	upgrading of arrays might happen differently for different arrays: for	example, I might have an algorithm that "upgraded" all simple	non-adjustable arrays with ARRAY-TOTAL-SIZE less than 2 to ELEMENT-TYPE T,	but be more strict about larger arrays.     Lucid would certainly oppose that change.  Our compiler optimizations    work on simple-arrays of known element type; and good reasons exist    as to why the simple/non-simple distinction and the element-type    distinctions are important (other "stock hardware" implmentations     have similar open-coding techniques).  I see no benefit to further     discrimination based on rank or array total size.    -- JonL --Right.  If you can't determine the upgraded type from a declaration, thedeclaration is next to useless.  (It just is not reasonable to have to,for instance, know the size of an array in order to be able to determinehow to access it.)*start*01606 00024 US Date: 11 Jan 89 21:34 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Jon L White <jonl@lucid.com>'s message of Wed, 11 Jan 89 17:48:32 PSTTo: Jon L White <jonl@lucid.com>cc: Masinter, cl-cleanup@Sail.Stanford.EduJonL, I was not suggesting a requirement that implementors would have to upgrade different arrays differently. Why would Lucid oppose allowing other implementors to take a different implementation strategy? Certainly your compiler optimizations could continue to work based on your assertions about your own array implementation types.>    but be more strict about larger arrays.  The major part of the proposal>    ("Change the meaning of (TYPEP <x> '(ARRAY <type>)), where <type> is not>    *, to be true if and only if <x> is an array that could be the result of>    giving <type> as the :element-type argument to MAKE-ARRAY.") could be kept,>>No, because you would have to say what the other arguments to MAKE-ARRAY were.>>You know what the other arguments to MAKE-ARRAY are by looking at <x>.  Imagine:Implementation A upgrades integer ranges to (SIGNED-BYTE n) for n a power of 2 up to 32, and then T.Implementation B upgrades integer ranges to (SIGNED-BYTE 32) and then to T.Implementation C upgrades simple small (say, less than total-size 2) arrays like B, and other arrays like A.  You can implement (C:TYPEP object type) by (if (simple-small-p object) (b:typep object type) (a:typep object type)). I.e., TYPEP need not merely be implemented by ARRAYP + a test on ARRAY-ELEMENT-TYPE. *start*02485 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 11 JAN 89 18:10:04 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 519869; Wed 11-Jan-89 21:09:25 ESTDate: Wed, 11 Jan 89 21:09 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)To: masinter.pacc: Jon L White <jonl@lucid.com>, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <890111-144755-10740@Xerox>Message-ID: <19890112020914.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 11 Jan 89 14:47 PST    From: masinter.pa@Xerox.COM    ....    As I think about it, I'm not sure why we rule out the possibility that the    upgrading of arrays might happen differently for different arrays: for    example, I might have an algorithm that "upgraded" all simple    non-adjustable arrays with ARRAY-TOTAL-SIZE less than 2 to ELEMENT-TYPE T,Actually you couldn't do that, because Common Lisp mandates the separateexistence of strings and bit-vectors.  But we get the idea.    but be more strict about larger arrays.  The major part of the proposal    ("Change the meaning of (TYPEP <x> '(ARRAY <type>)), where <type> is not    *, to be true if and only if <x> is an array that could be the result of    giving <type> as the :element-type argument to MAKE-ARRAY.") could be kept,No, because you would have to say what the other arguments to MAKE-ARRAY were.If you can prove that the statement I just said is false, then I will changemy mind and agree with you, since it would considerably simplify the proposal.I spent some time just now unsuccessfully trying to prove that the statementis true.  The place to think about is SUBTYPEP.    and the part that talks about upgrading (Clarify that "upgrading" implies a    movement upwards in the type- hierarchy lattice.) would just have to be    recast in terms of a specific array.     This is counter to the part that says "Clarify that upgrading an array    element-type is independent of any 	other property of arrays, such as rank, adjustability, fill-pointers, 	displacement etc."    but I wonder now if that is a clarification -- is it a Change? -- and if it    is necessary.You're probably right that it is a change, although I think JonL wasunable to find any current practice that it contradicts.*start*01363 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 11 JAN 89 17:49:32 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04314g; Wed, 11 Jan 89 17:46:15 PSTReceived: by bhopal id AA07016g; Wed, 11 Jan 89 17:48:32 PSTDate: Wed, 11 Jan 89 17:48:32 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901120148.AA07016@bhopal>To: masinter.paCc: cl-cleanup@Sail.Stanford.EduIn-Reply-To: masinter.pa@Xerox.COM's message of 11 Jan 89 14:47 PST <890111-144755-10740@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)re: As I think about it, I'm not sure why we rule out the possibility that the    upgrading of arrays might happen differently for different arrays: for    example, I might have an algorithm that "upgraded" all simple    non-adjustable arrays with ARRAY-TOTAL-SIZE less than 2 to ELEMENT-TYPE T,    but be more strict about larger arrays. Lucid would certainly oppose that change.  Our compiler optimizationswork on simple-arrays of known element type; and good reasons existas to why the simple/non-simple distinction and the element-typedistinctions are important (other "stock hardware" implmentations have similar open-coding techniques).  I see no benefit to further discrimination based on rank or array total size.-- JonL --*start*01509 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 17:50:53 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 11 Jan 89  17:50:21 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04314g; Wed, 11 Jan 89 17:46:15 PSTReceived: by bhopal id AA07016g; Wed, 11 Jan 89 17:48:32 PSTDate: Wed, 11 Jan 89 17:48:32 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901120148.AA07016@bhopal>To: masinter.paCc: cl-cleanup@Sail.Stanford.EduIn-Reply-To: masinter.pa@Xerox.COM's message of 11 Jan 89 14:47 PST <890111-144755-10740@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)re: As I think about it, I'm not sure why we rule out the possibility that the    upgrading of arrays might happen differently for different arrays: for    example, I might have an algorithm that "upgraded" all simple    non-adjustable arrays with ARRAY-TOTAL-SIZE less than 2 to ELEMENT-TYPE T,    but be more strict about larger arrays. Lucid would certainly oppose that change.  Our compiler optimizationswork on simple-arrays of known element type; and good reasons existas to why the simple/non-simple distinction and the element-typedistinctions are important (other "stock hardware" implmentations have similar open-coding techniques).  I see no benefit to further discrimination based on rank or array total size.-- JonL --*start*01433 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 11 JAN 89 01:25:22 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03246g; Wed, 11 Jan 89 01:22:16 PSTReceived: by bhopal id AA03698g; Wed, 11 Jan 89 01:24:32 PSTDate: Wed, 11 Jan 89 01:24:32 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901110924.AA03698@bhopal>To: masinter.paCc: cl-cleanup@Sail.Stanford.EduIn-Reply-To: masinter.pa@Xerox.COM's message of 10 Jan 89 14:41 PST <890110-144153-6753@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)re: The benefit of UPGRADE-ARRAY-ELEMENT-TYPE--namely, that it doesn't    CONS as much as the portable definition--seems very small and I don't think    it outweighs the cost.No, Larry, the issue isn't that it "doesn't CONS as much", but that it"doesn't CONS *at all*".  This kind of issue is critical to some vendors,such as Inference (which is why Joe Ginder was worrying about theimplicit consing in &rest args and in the sequence functions.)See CLtL, p292, definition of ARRAY-DIMENSION.  Applying the reasoningthat I am now trying to rebut, you would wind up with:   (defun array-dimension (array axis-number)     (elt (array-dimensions array) axis-number))Why do you suppose that CLtL included ARRAY-DIMENSION in the standard?How about ARRAY-TOTAL-SIZE? and ARRAY-ROW-MAJOR-INDEX?-- JonL --*start*01415 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 12 JAN 89 23:32:01 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01779g; Thu, 12 Jan 89 23:28:55 PSTReceived: by bhopal id AA04490g; Thu, 12 Jan 89 23:31:12 PSTDate: Thu, 12 Jan 89 23:31:12 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901130731.AA04490@bhopal>To: masinter.paCc: cl-cleanup@Sail.Stanford.EduIn-Reply-To: masinter.pa@Xerox.COM's message of 11 Jan 89 21:34 PST <890111-213644-11560@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)re: Why would Lucid oppose allowing other    implementors to take a different implementation strategy? Certainly your    compiler optimizations could continue to work based on your assertions    about your own array implementation types.Your suggestion was to permit a (gratuitous) variation on upgradingwhich would make reasonable compiler optimization impossible on portableprograms.  The compiler optimization can only work by assuming thatthere are no variations beyond the ones it "knows" about.  It isreasonable to ask for declarations about "simpleness" and about elementtype; but is is not reasonable to require declarations on size.Anyway, I though moon already put the scotch on this whole line of inquirydue to the type separateness of strings and bit-vectors.-- JonL --*start*00542 00024 US Date: 13 Jan 89 10:16 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 13 Jan 89 00:54 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, jonl@lucid.com, cl-cleanup@Sail.Stanford.EduYes, I've come to that conclusion. If you want to hack element types more than that, you just have to hide it, e.g., remember the requested element type even if you give it more "bits".*start*00455 00024 US Date: 13 Jan 89 10:17 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 13 Jan 89 00:54 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, jonl@lucid.com, cl-cleanup@Sail.Stanford.Edu... however, perhaps we should just not require that SUBTYPEP work for (ARRAY <type>) instead ....*start*00906 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 10:23:05 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Jan 89  10:22:30 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 13 JAN 89 10:16:49 PSTDate: 13 Jan 89 10:16 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 13 Jan 89 00:54 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, jonl@lucid.com, cl-cleanup@Sail.Stanford.EduMessage-ID: <890113-101649-2952@Xerox>Yes, I've come to that conclusion. If you want to hack element types morethan that, you just have to hide it, e.g., remember the requested elementtype even if you give it more "bits".*start*00819 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 10:23:18 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Jan 89  10:22:37 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 13 JAN 89 10:18:01 PSTDate: 13 Jan 89 10:17 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 13 Jan 89 00:54 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, jonl@lucid.com, cl-cleanup@Sail.Stanford.EduMessage-ID: <890113-101801-2954@Xerox>... however, perhaps we should just not require that SUBTYPEP work for(ARRAY <type>) instead ....*start*01777 00024 US Date: 13 Jan 89 10:44 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Jon L White <jonl@lucid.com>'s message of Thu, 12 Jan 89 23:31:12 PSTTo: Jon L White <jonl@lucid.com>cc: masinter.pa, cl-cleanup@Sail.Stanford.EduI don't think we're connecting.  Consider:Implementation A has a funny upgrade strategy.Implementation B has a regular upgrade strategy.(My suggestion:) The standard allows implementations to have both funny and regular upgrade strategies, i.e., it does not constrain implementations.A portable program calls MAKE-ARRAY with some ELEMENT-TYPE arguments, and uses those *same* element-types in declarations and programs.Implementation B, which only allows regular upgrade strategy, can use reasonable compiler optimizations; it can assume "there are no variations beyond the ones it 'knows' about." Implementation A, which employs a funny upgrade strategy, cannot use those same compiler optimizations. Maybe it has compiler optimizations of its own. Maybe it has special AREEF hardware. In any case, the fact that the standard ALLOWS implementation A to have a funny upgrade strategy does not make it impossible for implementation B to use reasonable compiler optimizations.Does it?The line of inquiry is not moot due to the type separateness of strings and bit-vectors; all it says is that upgrade strategies have to do it in such a way as to not cross those lines.Also, the character committee's proposal includes making some modifications to STRING such that STRING means any vector whose element type is SUBTYPEP to CHARACTER, and allowing more specialized strings. I think that the interaction of that proposal and this issue should be examined carefully.*start*01570 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 21:57:56 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 12 Jan 89  21:57:35 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 520814; Fri 13-Jan-89 00:54:45 ESTDate: Fri, 13 Jan 89 00:54 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)To: masinter.pacc: jonl@lucid.com, cl-cleanup@Sail.Stanford.EduIn-Reply-To: <890111-213644-11560@Xerox>Message-ID: <890113005433.8.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 11 Jan 89 21:34 PST    From: masinter.pa@Xerox.COM    ... You can implement (C:TYPEP object type) by (if (simple-small-p object)    (b:typep object type) (a:typep object type)). I.e., TYPEP need not merely    be implemented by ARRAYP + a test on ARRAY-ELEMENT-TYPE. Larry, I started off sympathetic to your point of view. The same ideahad occurred to me. But how would you implement SUBTYPEP? The problem isthat you'd have to always specify the range just in case it mattered.Although it precludes some interesting special-purpose representation, Itake it as a pragmatic truth, independently of what I might wish, thatwe can't really make this proposal work unless implementations agree tomake the upgrading depend only on the requested type and nothing else.*start*02141 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 10:56:31 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Jan 89  10:53:26 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 13 JAN 89 10:45:13 PSTDate: 13 Jan 89 10:44 PSTFrom: masinter.paSubject: Re: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)In-reply-to: Jon L White <jonl@lucid.com>'s message of Thu, 12 Jan 89 23:31:12 PSTTo: Jon L White <jonl@lucid.com>cc: masinter.pa, cl-cleanup@Sail.Stanford.EduMessage-ID: <890113-104513-3046@Xerox>I don't think we're connecting.  Consider:Implementation A has a funny upgrade strategy.Implementation B has a regular upgrade strategy.(My suggestion:) The standard allows implementations to have both funny andregular upgrade strategies, i.e., it does not constrain implementations.A portable program calls MAKE-ARRAY with some ELEMENT-TYPE arguments, anduses those *same* element-types in declarations and programs.Implementation B, which only allows regular upgrade strategy, can usereasonable compiler optimizations; it can assume "there are no variationsbeyond the ones it 'knows' about." Implementation A, which employs a funny upgrade strategy, cannot use thosesame compiler optimizations. Maybe it has compiler optimizations of itsown. Maybe it has special AREEF hardware. In any case, the fact that the standard ALLOWS implementation A to have afunny upgrade strategy does not make it impossible for implementation B touse reasonable compiler optimizations.Does it?The line of inquiry is not moot due to the type separateness of strings andbit-vectors; all it says is that upgrade strategies have to do it in such away as to not cross those lines.Also, the character committee's proposal includes making some modificationsto STRING such that STRING means any vector whose element type is SUBTYPEPto CHARACTER, and allowing more specialized strings. I think that theinteraction of that proposal and this issue should be examined carefully.*start*01517 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 JAN 89 05:48:52 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 15 Jan 89  05:47:45 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03805g; Sun, 15 Jan 89 05:43:29 PSTReceived: by bhopal id AA11850g; Sun, 15 Jan 89 05:45:49 PSTDate: Sun, 15 Jan 89 05:45:49 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901151345.AA11850@bhopal>To: masinter.paCc: masinter.pa, cl-cleanup@Sail.Stanford.EduIn-Reply-To: masinter.pa@Xerox.COM's message of 13 Jan 89 10:44 PST <890113-104513-3046@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)re: In any case, the fact that the standard ALLOWS implementation A to have a    funny upgrade strategy does not make it impossible for implementation B to    use reasonable compiler optimizations.As long as implementation A doesn't pay any attention to the declarationsthat implementation B is concerned about, then it is moot even toconsider "funny" upgrades.  If A does pay attention to the declarations,then those that work in B will break in A.For the life of me, I can't understand why you are pressing this issue,since it's pointless to write something into the standard that A won'tuse and B can't use.  So why not leave it simply at the state where wespecify what B _can_ use, and what A doesn't care about.-- JonL --*start*01371 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 15 JAN 89 05:46:41 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03805g; Sun, 15 Jan 89 05:43:29 PSTReceived: by bhopal id AA11850g; Sun, 15 Jan 89 05:45:49 PSTDate: Sun, 15 Jan 89 05:45:49 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901151345.AA11850@bhopal>To: masinter.paCc: masinter.pa, cl-cleanup@Sail.Stanford.EduIn-Reply-To: masinter.pa@Xerox.COM's message of 13 Jan 89 10:44 PST <890113-104513-3046@Xerox>Subject: Issue: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS (Version 9)re: In any case, the fact that the standard ALLOWS implementation A to have a    funny upgrade strategy does not make it impossible for implementation B to    use reasonable compiler optimizations.As long as implementation A doesn't pay any attention to the declarationsthat implementation B is concerned about, then it is moot even toconsider "funny" upgrades.  If A does pay attention to the declarations,then those that work in B will break in A.For the life of me, I can't understand why you are pressing this issue,since it's pointless to write something into the standard that A won'tuse and B can't use.  So why not leave it simply at the state where wespecify what B _can_ use, and what A doesn't care about.-- JonL --