*start*05620 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 DEC 87 20:44:58 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Dec 87  20:42:44 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 DEC 87 20:41:08 PSTDate: 2 Dec 87 20:40 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Wed, 2 Dec 87 22:40 ESTTo: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-204108-1072@Xerox>I'm tempted to try to address several issues with FUNCTION declarations at once.1) I realize now that I do not understand the import of *any* of the argumenttype specifiers, and specificly the language about "at least of the typesspecified" that appears in CLtL p 47. However, I don't know what (declare (function my-cons (float string) list) )means. It says that my-cons is a function that can "accept a floating-pointnumber and a string (among other things), and its result is an object of typelist...."The problem is that the argument type declaration here is of absolutely no use.That the declared function can accept a float and a string among other thingshas no content. It doesn't say that it is illegal to pass a non-float as thefirst argument. It says that if you pass a float, its ok, and if you pass anon-float, it might be OK too. Isn't that the same as saying (function my-cons(t t) list)? It would be more valuable as far as I can see to say that a (function (floatstring) list) is one to which *only* a float and a string can be passed. Perhapssomeone familiar with an implementation that pays attention to thesedeclarations can explain what they are used to denote? 2) On the specific issue at hand: I'm inclined to be more sympathetic toallowing &REST <element-type>; function type specifiers are, after all, alreadya specialized little language -- the &KEY arguments have a separate syntax whichonly vaguely resembles the original lambda list syntax, for example. 3) Should the function type specifier also allow &ALLOW-OTHER-KEYS? Here is some (old) mail from the Common Lisp mailing list which touches on somerelated issues:!Date: 18 Apr 1986 16:07-ESTSubject: Type Specifier: (OR (FUNCTION ...) ...)From: NGALL@G.BBN.COMQuestion: What is the 'most informative' type specifier for the CL functionCOPY-SEQ?How 'bout? (function (sequence) sequence)Unfortunately, this does not tell the reader nor the compiler that if theargument is a list, then the result is also a list, and vice versa.  So howabout this:(or (function (list) list)    (function (vector) vector))This is syntactically valid CL, and the definition of the OR and FUNCTION typespecifiers makes it meaningful.  Unfortunately, it is not clear from pg. 158whether or not the following is legal:(proclaim '(ftype (or (function (list) list)                      (function (vector) vector))                  copy-seq))It is not legal in VaxLisp, and my guess is that there aren't anyimplementations that would do the right thing with it. So I would like topropose that such a use of OR/FUNCTION be considered legal CL.Without such a declaration, one is forced to either wrap (the <result-type> ...)around all calls to such functions or to DECLARE a restricted version ofFUNCTION in the appropriate places, e.g., (defun foo (alist avector)  (declare (list alist)           (vector avector)           (function copy-seq (list) list))  (zap (copy-seq alist)  (let ()    (declare (function copy-seq (vector) vector))    (zoop (copy-seq avector))))Either method is a real pain.This use of OR would give CL something akin to Ada overloading.  It allows theoverloading of multiple 'function type signatures' on a single function name.Such overloading is already implicit throughout CL (esp. the seq. functions).My proposal would merely allow a way of describing it.	-- Nick!Date: Mon, 4 Nov 85 22:29 ESTFrom: Daniel L. Weinreb <DLW@SCRC-QUABBIN.ARPA>Subject: Declaring FunctionsTo: shebs%utah-orion@UTAH-CS.ARPA, common-lisp@SU-AI.ARPAMessage-ID: <851104222904.2.DLW@CHICOPEE.SCRC.Symbolics.COM>In-Reply-To: <8511012045.AA07112@utah-orion.ARPA>    Date: Fri, 1 Nov 85 13:45:55 MST    From: shebs%utah-orion@utah-cs.arpa (Stanley Shebs)    The notion of a function type is mentioned in two places: p. 47 of the    CLM, where the (function ...) type specifier is defined, and p. 158-159,    where (ftype ...) and (function ...) are defined as options to declare.    Are they intended to be the same?  Read page 159 more carefully.  It explains that they have the same meaning, butare syntactically different.  "function" has the disadvantage that you can onlydeclare one thing per clause, unlike most other declarations, but the advantagethat it looks mildly like "defun".				       				       If so, then the second definition    should say that keywords and a (values ...) type specifier are allowed.If by keywords you mean &optional and friends, it isn't strictly necessary torepeat that, although it would sure clear things up if there were a crossreference in the book.However, there appears to be a typo on page 159.  The form following the phrase"entirely equivalent to", which currently reads (ftype (function arglist result-type1 result-type2 ...) name)ought to read  (ftype (function arglist (values result-type1 result-type2 ...)) name)in order to be consistent with page 47.*start*02076 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 DEC 87 21:47:39 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Dec 87  21:46:13 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 DEC 87 21:42:53 PSTDate: Wed, 2 Dec 87 21:42:47 PSTFrom: Pavel.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: <871202-204108-1072@Xerox>To: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-214253-1099@Xerox>Larry says:``I don't know what  (declare (function my-cons (float string) list) ) means.''It is usual in type theory for this to be read as an implication:	IF	   you pass a float and a string to MY-CONS	THEN	   MY-CONS is guaranteed to return a list.More rigorously, a type theorist would see (function my-cons (float string)list) as representing the set of all functions that, when applied to a float anda string, return a list.Under this view of types, we understand the constructor OR to be set-union (thatis, the type (OR t1 t2) represents the set of values in the union of the setsrepresented by t1 and t2) and the AND constructor is thus set intersection.Under this view, Nick Gall gives the wrong answer to his question about aspecific type for COPY-SEQ when he claims that a good one would be(or (function (list) list)    (function (vector) vector))Since this does not guarantee that COPY-SEQ will return a list when applied to alist; in fact, a function in this type might very well bomb when presented witha list.  In general, ORing function types isn't very helpful.  What he reallywants here is AND, not OR:(and (function (list) list)     (function (vector) vector))This represents the set of functions that both map lists to lists and vectors tovectors.Let me point out that I'm not claiming that this is how CLtL intends functiontypes to be interpreted, just that this meaning has proven very convenient formost uses.	Pavel*start*00894 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 DEC 87 22:26:58 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Dec 87  22:25:24 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 DEC 87 22:20:29 PSTDate: 2 Dec 87 22:20 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Pavel.pa's message of Wed, 2 Dec 87 21:42:47 PSTTo: Pavel.pacc: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-222029-1111@Xerox>Under the interpretation outlined in your message, it would not be valid to assume, given   (declare (function my-cons (float string) list) ) that     (typep (my-cons x y) 'list)  can be assumed, unless it was also asserted (declare (float x) (string y))? *start*00736 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 DEC 87 22:37:55 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Dec 87  22:36:45 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 DEC 87 22:36:23 PSTDate: Wed, 2 Dec 87 22:36:17 PSTFrom: Pavel.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: <871202-222029-1111@Xerox>To: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-223623-1122@Xerox>That's right.  Unless you know something about the types of the arguments, youcan assume nothing about the type of the result.	Pavel*start*03365 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 DEC 87 13:32:45 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 3 Dec 87  13:31:12 PSTReceived: ID <RAM@C.CS.CMU.EDU>; Thu 3 Dec 87 16:30:32-ESTDate: Thu, 3 Dec 87 16:30 ESTMessage-ID: <RAM.12355605918.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>, cl-cleanup@SAIL.STANFORD.EDU, Masinter.pa, sandra%orion@CS.UTAH.EDUSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Msg of 3 Dec 1987  12:52-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>My compiler cleanup proposal addresses a number of the issues beingdiscussed here.  We already went around once on cl-cleanup about themeaning function type.In my initial proposal, I had assumed a strict interpretation offunction type.  It was pointed out to me, that not only is CLTL veryclear about its non-restrictive interpretation, it is also verydifficult to use a strict interpretation within the framework of thecurrent type system.Basically, the problem is that if you think about "function typedeclarations" as being declarations about the type of the object whichis the function, then it isn't possible to use a strictinterpretation.  If you attempt to do so, then there will be caseswhere a type declaration is necessary for a program to be correct, andremoving declarations can cause a program to be incorrect.  Inaddition to problems with defining where declarations are necessary,requiring declarations is also clearly in conflict with the statedgoals for declarations in Common Lisp.Basically, the reason for this non-intuitive result is that adeclaration of a function's type actually makes a statement about whatdefinitions are legal, rather than what calls are legal.  What acompiler really wants to know is what calls are legal.The solution I suggest in my proposal is to introduce a mechanism thatallows arbitrary information about a function definition to be boundat compile time.  You don't declare the function type, you just definethe function, with any appropriate argument type declarations.Since you have asserted that calls to the function can be bound atcompile time, the compiler can apply any assertions on the formalparameters to the actual parameters and use type information derivedfrom the definition as the type of the call result.Early-binding of function names also allows many other optimizationssuch as "inline expansion" and "block compilation".Before people flame uncotrollably about the horror of static functionbinding in Lisp, I will point out that I don't propose that staticfunction binding be required, or even that it necessarily be thedefault.  It is also worth noting that the extent to which staticbinding is actually done once it has been allowed is an implementationdecision.  Declaring static binding doesn't necessarily preventincremental redefintion or reduce safety, it might only cause bettercompiler warnings to be generated.If this capability exists, then function type declarations (andfunction types) are more useless than they currently are (if that iseven possible).  RobP.S.  My proposal is <ram>cprop.txt on c.cs.cmu.edu*start*00799 00024 US Date:  7 Dec 87 14:40 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Ram@C.CS.CMU.EDU's message of Thu, 3 Dec 87 16:30 ESTTo: Ram@C.CS.CMU.EDUcc: KMP@SCRC-STONY-BROOK.ARPA, cl-cleanup@SAIL.STANFORD.EDU, Masinter.pa, sandra%orion@CS.UTAH.EDURam: I've scanned your latest proposal, but it still doesn't seem to address the minor issue at hand here:What does (declare (function (integer integer) t) foo)  imply? We've discussed what it could mean, what it should mean, what CLtL says it means, but I'd to hear about current practice. What, if anything,  do current implementations do with such declarations? Do any implementations pay attention to the types of arguments in function declarations? *start*01144 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 DEC 87 16:44:38 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 7 Dec 87  16:43:00 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 07 DEC 87 15:23:50 PSTDate: 7 Dec 87 14:40 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Ram@C.CS.CMU.EDU's message of Thu, 3 Dec 87 16:30 ESTTo: Ram@C.CS.CMU.EDUcc: KMP@SCRC-STONY-BROOK.ARPA, cl-cleanup@SAIL.STANFORD.EDU, Masinter.pa, sandra%orion@CS.UTAH.EDUMessage-ID: <871207-152350-3643@Xerox>Ram: I've scanned your latest proposal, but it still doesn't seem to address theminor issue at hand here:What does (declare (function (integer integer) t) foo)  imply? We've discussed what it could mean, what it should mean, what CLtL says itmeans, but I'd to hear about current practice. What, if anything,  do currentimplementations do with such declarations? Do any implementations pay attentionto the types of arguments in function declarations? *start*05491 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 DEC 87 09:55:59 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 3 Dec 87  09:53:41 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 294082; Thu 3-Dec-87 12:53:18 ESTDate: Thu, 3 Dec 87 12:52 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Masinter.pacc: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUIn-Reply-To: <871202-204108-1072@Xerox>Message-ID: <871203125256.0.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 2 Dec 87 20:40 PST    From: Masinter.pa@Xerox.COM    ...    (declare (function my-cons (float string) list) )    ...    The problem is that the argument type declaration here is of absolutely    no use.    ...    It would be more valuable as far as I can see to say that a    (function (float string) list)    is one to which *only* a float and a string can be passed. Perhaps    someone familiar with an implementation that pays attention to these    declarations can explain what they are used to denote? In Maclisp, if you declared a function to take arguments (fixnum flonum),for example, special tricks were allowed to be done with passing the argumentswithout having to heap-cons them. You were required to only use this declarationif you had made it available to the compiler at the time of compiling the function(so that it would have done the special tricks necessary to make the externalcalling sequence work). The net effect was that the function had a naive entrypoint (for people who didn't know about the declaration) and a magic entry pointfor people who wanted to exploit the declaration information and bypass somesetup instructions.In order to get this effect in CL, we have only to restrict the declaration ofa function to be exactly the declaration that the function was compiled under.That is, there are a number of possible universes we could elect to be in: * We could allow local function declarations to just say things we know to   be true, regardless of whether they were interesting. eg,      (PROCLAIM '(FUNCTION FOO (INTEGER) INTEGER))      (DEFUN FOO (X) (+ X 1))   could be matched in another file by      (LOCALLY (DECLARE (FUNCTION FOO (INTEGER) INTEGER)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM) FIXNUM)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (T) T)) ... (FOO ...) ...)   This would tend to thwart interesting compilations because nothing in the   declaration would tell you anything useful about how the function was compiled. * We could allow local function declarations only if they restrict the   declaration under which the function was compiled. eg,      (PROCLAIM '(FUNCTION FOO (INTEGER) INTEGER))      (DEFUN FOO (X) (+ X 1))   could be matched in another file by      (LOCALLY (DECLARE (FUNCTION FOO (INTEGER) INTEGER)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM) FIXNUM)) ... (FOO ...) ...)   but not by      (LOCALLY (DECLARE (FUNCTION FOO (T) T)) ... (FOO ...) ...)   This might thwart some interesting compilations because you wouldn't know    everything about the way the function was compiled, but you'd know some   information. * We could allow local function declarations only if they exactly match   the declaration under which the function was compiled. eg,      (PROCLAIM '(FUNCTION FOO (INTEGER) INTEGER))      (DEFUN FOO (X) (+ X 1))   could be matched in another file by      (LOCALLY (DECLARE (FUNCTION FOO (INTEGER) INTEGER)) ... (FOO ...) ...)   but not by      (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM) FIXNUM)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (T) T)) ... (FOO ...) ...)   This would have the best chance of getting interesting compilations, I think. * We could, as I guess Pavel is suggesting (though I lost or missed the   original mail), allow multiple declarations of the same function, in which   case the information provided would be of an entirely different nature (in   what amounts to a DEFMETHOD style) than what it's used for in the previous   three bullet items.   Presumably there are some gains to be had from this style. I have no feel for   how useful they are. An example, though, would be:      (PROCLAIM '(FUNCTION FOO (LIST) LIST))      (PROCLAIM '(FUNCTION FOO (VECTOR) VECTOR))   which would let you compile      (LENGTH (FOO (THE LIST L)))   into      (SYSTEM:LENGTH-ROUTINE-FOR-THINGS-KNOWN-TO-BE-OF-TYPE-LIST (FOO L))   [Sigh. I'd have called it SYSTEM:LIST-LENGTH, but that's taken by CLtL for    something that doesn't mean what I think of as LIST-LENGTH. A poor naming    decision if you ask me...] * This is a placeholder to remind readers that the likelihood that this list is   exhaustive is fairly low.This really gets at the heart of the problem, which is: * Are declarations just for compilation or do they serve some more abstract   higher level goal (eg, "documentation"). * How important is exact-typep information vs typep information. * How much of a modularity violation (or documentation constraint) is it to   have to know the exact conditions under which a function was compiled. * How important are optimal compilations?*start*01778 00024 US Return-Path: <sandra%orion@cs.utah.edu>Received: from cs.utah.edu by Xerox.COM ; 03 DEC 87 10:58:45 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA20506; Thu, 3 Dec 87 11:57:15 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA21459; Thu, 3 Dec 87 11:57:05 MSTDate: Thu, 3 Dec 87 11:57:05 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8712031857.AA21459@orion.utah.edu>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>Cc: Masinter.pa, cl-cleanup@sail.stanford.edu, sandra%orion@cs.utah.eduIn-Reply-To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Thu, 3 Dec 87 12:52 ESTOne reason for wanting to use a FUNCTION type specifier is that you mayonly be concerned with how many arguments a function can take, and youdon't care at all about their types.  Back when we were trying toimplement a CL compatibility package in PSL, we wanted to do thematching of actual arguments to lambda variables at compile-time so wecould use the EXPR call protocol instead of the much slower NEXPRprotocol.  (Basically, we had an EXPR entry point for every functionwith a 1-1 correspondence between actual arguments and lambdavariables.)  The problem is, you couldn't do the transformation on acall unless you already knew something about the lambda list for thefunction.I agree that the argument type business is confusing and not very usefulin its current state.  I'd like to say that    (LOCALLY (DECLARE (FTYPE (FUNCTION (INTEGER INTEGER) INTEGER) +))        (+ X Y))is equivalent to    (THE INTEGER (+ (THE INTEGER X) (THE INTEGER Y)))but I'm not sure that's exactly what CLtL is getting at.-Sandra-------*start*01121 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 DEC 87 11:27:15 PSTDate: 03 Dec 87 11:23 PSTFrom: Dick Gabriel <RPG@SAIL.Stanford.EDU>Subject: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issues To: cl-cleanup@SAIL.Stanford.EDU I'd like to reiterate what Pavel said: the declaration(declare (function my-cons (float string) list) )means that the function MY-CONS accepts two arguments, the first at leastof the type FLOAT (it can be a more general type), and the second at leastof the type STRING; it returns one value which is of the type LIST (itcould be more specific).Unfortunately, it does not mean that if the two arguments are of typesFLOAT and STRING then the result is of type LIST, which would beuseful.Lucid has a variant of this called RESTRICTIVE-FTYPE (or something),which would mean MY-CONS assumes it receives two arguments of typesFLOAT and STRING and produces something of type LIST.See page 47 (CLtL), the last complete paragraph, to see this.			-rpg-*start*02510 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 DEC 87 12:17:36 PSTReceived: from SCRC-YUKON.ARPA by SAIL.STANFORD.EDU with TCP; 3 Dec 87  12:15:27 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 301485; Thu 3-Dec-87 14:17:50 ESTDate: Thu, 3 Dec 87 14:17 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: sandra%orion@cs.utah.educc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: <8712031857.AA21459@orion.utah.edu>Message-ID: <871203141725.5.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Thu, 3 Dec 87 11:57:05 MST    From: sandra%orion@cs.utah.edu (Sandra J Loosemore)    One reason for wanting to use a FUNCTION type specifier is that you may    only be concerned with how many arguments a function can take, and you    don't care at all about their types. ...Thanks for remembering to mention this issue. It pops into my head from time to timeand then I always forget it before I get to the console.Yes, the same style of issues as I raised in my last message applies to argumentnumber. eg, if I did (PROCLAIM '(FUNCTION FOO (NUMBER NUMBER) NUMBER)) (DEFUN FOO (X Y) (+ X Y)) and later did: (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM &REST (LIST T)) FIXNUM)) ... (FOO ...) ...)would I be within reason? ie, is there semantic impact to the &REST which goes beyondtype declaring the rest of the arguments to be of type T? Am I also declaring that thefunction was in fact compiled believing that a &REST style argument pickup was used(and at the same point as I've specified it here). What about: (PROCLAIM '(FUNCTION FOO (NUMBER &REST (LIST NUMBER)) NUMBER)) (DEFUN FOO (X &REST Y) (APPLY #'+ X Y)) and then later (LOCALLY (DECLARE (FUNCTION FOO (NUMBER NUMBER &REST (LIST NUMBER)) NUMBER))   ... (FOO ...at least two arguments...) ...)In my CL conversion of Macsyma, I threw out all the *LEXPR declarations becauseCL couldn't make any use of them and they were just clutter. (And they'd be trivialto re-conjure if they were ever needed.) But I felt funny as I did it because I didknow I was throwing away information that would be interesting to some compilersand that seemed sad, so I definitely agree that one way or another, this is a realissue.*start*02648 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 DEC 87 03:10:28 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 9 Dec 87  03:03:38 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 09 DEC 87 03:00:06 PSTDate: 9 Dec 87 02:59 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Ram@C.CS.CMU.EDU's message of Tue, 8 Dec 87 14:21 ESTTo: Ram@C.CS.CMU.EDUcc: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871209-030006-1558@Xerox>I think I understand and agree with most of what you say, in particular "I thinkthat we should either entirely flush the concept of "function types" or changethe theory behind them.  The CLtL interpretation is well-defined, but not veryuseful. " There are two components to your proposal: (1) what is allowed (and what itmeans), and (2) how it is described in the standard.I like the part of your proposal which is to change the interpretation offunction declarations to mean an implicit assertion of argument and value types(the "restrictive interpretation"). I like defining  (declare (type (function (frob grid) bunker) x)) to mean (funcall x y z) has implicitly means  (the bunker (funcall (the function x)(the frob y) (the grid z)))I don't see, however, that there is much leverage to removing FUNCTION from thesection on type specifiers. It would do some violence to the otherwise usefulconcept of (deftype binary-arithmetic () '(function (number number) number))to be used in(declare (ftype binary-arithmetic x y z)) .I don't see at all that (funcall #'foo x y) doesn't mean (the t (funcall #'foo(the integer x) (the integer y)))) given (declare (function foo (integerinteger) t)). In the type propagation rules, you can transform funcall and apply expressionsusing the asserted value of the function argument, and the asserted value typeof #'name is derived from the asserted ftype of name. In this interpretation, AND would distribute nicely, Given (proclaim '(function foo (s1 t1) v1)) and (declare (function foo (s2 t2)v2)) you could assert that(foo x y) => (the (and v1 v2) (foo (the (and s1 s2) x) (the (and t1 t2) y))).(OR doesn't distribute as nicely, e.g., given (declare (ftype (or (function (s1t1) v1) (function (s2 t2) v2)) foo)),  there isn't a simple way to describe thetype assertions made for (foo x y).  We might even want to explicitly allow FUNCTION declarations in THEexpressions, as in(funcall (the binary-arithmetic x)  y z).*start*03460 00024 USaReturn-Path: <RAM@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 08 DEC 87 11:23:43 PSTReceived: ID <RAM@C.CS.CMU.EDU.#Internet>; Tue 8 Dec 87 14:22:06-ESTDate: Tue, 8 Dec 87 14:21 ESTMessage-ID: <RAM.12356893261.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDU, KMP@SCRC-STONY-BROOK.ARPA, sandra%orion@CS.UTAH.EDUSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Msg of 7 Dec 1987  17:40-EST from Masinter.pa at Xerox.COM    Date: Monday, 7 December 1987  17:40-EST    From: Masinter.pa at Xerox.COM    To:   Ram at C.CS.CMU.EDU    cc:   KMP at SCRC-STONY-BROOK.ARPA, cl-cleanup at SAIL.STANFORD.EDU,	  Masinter.pa at Xerox.COM, sandra%orion at CS.UTAH.EDU    Re:   Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issues    [...] What does (declare (function (integer integer) t) foo) imply?    We've discussed what it could mean, what it should mean, what CLtL    says it means, but I'd to hear about current practice. What, if    anything, do current implementations do with such declarations? Do    any implementations pay attention to the types of arguments in    function declarations?Our current compiler totally ignores function type declarations.I am working on a new compiler that currently gives function typedeclarations a strict interpretation, i.e. the function must be calledonly with two integer arguments.  (I suspect that this is like theRESTRICTIVE-FTYPE declarations that someone from Lucid mentioned.)  Atleast as an interpretation for FTYPE, this is clearly wrong.  I intendto at least rename this declaration, and perhaps entirely flush it asa user-visible facility.I think that we should either entirely flush the concept of "functiontypes" or change the theory behind them.  The CLtL interpretation iswell-defined, but not very useful.  The intuitive strictinterpretation is useful, but is not a type declaration, at least inthe sense used in CLtL.The restrictive interpretation can be modeled as a sort of magicsyntactic shorthand for a bunch of THE declarations at the call site:    (the t (foo (the integer x) (the integer y)))But under this interpretation, a "function type" isn't a type at all,since it isn't in any sense the type of the function object beingcalled.  It wouldn't be meaningful to declare a variable or value tohave a function type.  A "function type declaration" would be a pieceof magic recognized by the implementation that constrains calls to aparticular function variable.If we did this, then the concept of a "function type specifier" shouldbe flushed, since "function types" can't be used in any of the waysreal types can.  The "function type" syntax would become part of thesyntax peculiar to a "function type declaration".  (A minor beneficialside-effect is that it would make obvious the restriction on functiontypes in TYPEP.)One problem that I have with this interpretation is that it makes theevaluation of the functional position even more peculiar than italready is.  Since a "function type declaration" would be purelysyntactic, it would only take effect when there was a syntactic match,i.e. an obvious normal call to a declared function variable.  It wouldprobably be incorrect to do this transformation:    (funcall #'foo x y)  ==>    (the t (funcall #'foo (the integer x) (the integer y))))  Rob*start*01095 00024 US Return-Path: <sandra%orion@cs.utah.edu>Received: from cs.utah.edu by Xerox.COM ; 09 DEC 87 07:02:36 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA09306; Wed, 9 Dec 87 08:00:52 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA16131; Wed, 9 Dec 87 08:00:48 MSTDate: Wed, 9 Dec 87 08:00:48 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8712091500.AA16131@orion.utah.edu>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Masinter.paCc: Ram@c.cs.cmu.edu, cl-cleanup@sail.stanford.edu, sandra%orion@cs.utah.eduIn-Reply-To: Masinter.pa@Xerox.COM, 9 Dec 87 02:59 PST  Date: 9 Dec 87 02:59 PST  From: Masinter.pa@Xerox.COM  Given (proclaim '(function foo (s1 t1) v1)) and (declare (function foo (s2 t2)  v2)) you could assert that  (foo x y) => (the (and v1 v2) (foo (the (and s1 s2) x) (the (and t1 t2) y))).I disagree.  The DECLARE should shadow the PROCLAIM; see p. 156 ofCLtL.  Or is there another proposal in the works to change declarationshadowing as well?  :-)-Sandra-------*start*02921 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 DEC 87 07:30:56 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 9 Dec 87  07:29:24 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Wed 9 Dec 87 10:28:51-ESTDate: Wed, 9 Dec 87 10:28 ESTMessage-ID: <FAHLMAN.12357112955.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-DECLARATION issuesIn-reply-to: Msg of 9 Dec 1987  05:59-EST from Masinter.pa at Xerox.COMSeems to me that we're trying to overload the type definition forFUNCTION in ways that are not altogether consistent.  I'd suggest thefollowing:1. Leave the FUNCTION type specifier alone.  It's not terribly useful inits non-restrictive form, but it is harmless and it does fit in with therest of the type system.  (Of course, we would make it a full-fledgedtype-specifier as discussed in the FUNCTION-TYPE proposal.)2. Add an extended form for the LIST type specifier so that one canindicate element type and, perhaps, length.  This can be used to saysomething useful about rest-args, without having to put in ugly specialsyntax for this.3. Add a new declaration/proclamation, distinct from TYPE, by whichusers can tell the compiler restrictive things about what a givenfunction will accept and what it will return.  This notation can be setup so that you can say things like "if all args are integer, the resultwill be" and "if the second arg is spaceship, the result will beMartian".  Obviously this bit will require some careful design so thatwe can make it maximally expressive and minimally confusing.  I don'thave a proposal ready; maybe Rob does.4. Let me toss in here a related idea by Dave Touretzky that I've beenwaiting to introduce whenever the time is right for a new batch ofissues: the RESTRICT declaration/proclamation.  Basically, (DECLARE(RESTRICT type1 type2)) says that, within the extent covered by thisdeclaration, anything that is of type1 is guaranteed to be of type2 aswell, where type2 is generally more restrictive.  One could say(RESTRICT NUMBER (INTEGER -1024 1024)), which tells the compiler thatany time it can prove something is a number, it can assume it is afixnum.  In some contexts, this can replace about six dozen THEforms.  Users find it very awkward to say things like(the (integer -1024 1024) (+ (the (integer -1024 1024) x)                             (the (integer -1024 1024) y))..yet often that is the only portable way to assure the compiler that itcan generate fixnum-only code on most machines.The reson I bring up RESTRICT at this time is that I think the functionrestriction mentioned in point 3 is related to this.  Maybe it should becalled RESTRICT-CALL or something.-- Scott*start*02666 00024 US Date: 10 Dec 87 23:40 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-DECLARATION issuesIn-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Wed, 9 Dec 87 10:28 ESTTo: Fahlman@C.CS.CMU.EDUcc: MasinterI found myself disagreeing with most of your points. I thought maybe we should try working out some of them one-on-one. I do think we have some responsibility to remove useless features, even those that are harmless, while resisting adding new ones of dubious semantics and value."1. Leave the FUNCTION type specifier alone.  It's not terribly useful inits non-restrictive form, but it is harmless and it does fit in with therest of the type system.  (Of course, we would make it a full-fledgedtype-specifier as discussed in the FUNCTION-TYPE proposal.)"I'm turning 'not terribly useful' into 'useless'. I guess except as documentation, but the intent of the documentation is the restrictive form anyway, isn't it? "2. Add an extended form for the LIST type specifier so that one canindicate element type and, perhaps, length.  This can be used to saysomething useful about rest-args, without having to put in ugly specialsyntax for this."There's a problem in the interpretation of the type (LIST TYPE), in that it is different from (VECTOR TYPE), can't be tested in unit time (must go down the list, if you want to do TYPEP), can be dynamicly affected (by a (SETF (CAR ..) ..) etc. No other non-SATISFIES built-in type has this problem."3. Add a new declaration/proclamation, distinct from TYPE, by whichusers can tell the compiler restrictive things about what a givenfunction will accept and what it will return.  This notation can be setup so that you can say things like "if all args are integer, the resultwill be" and "if the second arg is spaceship, the result will beMartian".  Obviously this bit will require some careful design so thatwe can make it maximally expressive and minimally confusing.  I don'thave a proposal ready; maybe Rob does."If it isn't a TYPE you can't use DEFTYPE and you can't define things like BINARY-ARITHMETIC like you can now with DEFTYPE, etc. A whole new mechanism? "4. Let me toss in here a related idea by Dave Touretzky that I've beenwaiting to introduce whenever the time . . . . "This seems like something that ought to be tried out first. I think these kinds of global proclaimations affecting system types have the same sorts of problems that FLETing special forms do, e.g., (RESTRICT NUMBER (INTEGER -1024 1024))and yet under some WITH-OPEN-FILE there's an INCF that's incrementing the open-file-count which happens to exceed 1024.*start*02298 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Dec 87 12:41From: miller%ACORN.CS.ROCHESTER:EDU:XeroxSubject: Re: Question about declarationIn-Reply-to: <8712111027.AA00767@jabbah.cs.rochester.edu>Reply-to: miller%cs.rochester:EDU:XeroxTo: quiroz%ACORN.CS.ROCHESTER:EDU:Xeroxcc: CL%ACORN.CS.ROCHESTER:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Brad Miller <miller@ACORN.CS.ROCHESTER.EDU>Subject: Re: Question about declarationTo: quiroz@ACORN.CS.ROCHESTER.EDUcc: CL@ACORN.CS.ROCHESTER.EDUIn-Reply-To: <8712111027.AA00767@jabbah.cs.rochester.edu>Reply-To: miller@cs.rochester.eduReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 DEC 87 12:41:17 PSTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.STANFORD.EDU with TCP; 11 Dec 87  12:11:35 PSTReceived: from DOUGHNUT.CS.ROCHESTER.EDU (DOUGHNUT.CS.ROCHESTER.EDU) by ACORN.CS.ROCHESTER.EDU via INTERNET with SMTP id 25734; 11 Dec 87 15:13:28 ESTOriginal-Date: Fri, 11 Dec 87 15:13 ESTMessage-ID: <871211151322.1.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Default-Character-Style: (:FIX :CONDENSED :NORMAL)Fonts: CPTFONTCOrganization: University of Rochester, Department of Computer SciencePostal-address: 401A CS Building, Computer Science Department, University of Rochester, Rochester NY 14627Phone: 716-275-1118GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 11 Dec 87 05:27:16 -0500    From: quiroz    If (as it seems) `bar' isn't restricted to be anything sharper than    `list', then the only thing we know is that `foo' returns multiple    values.  (Indeed, `foo' is just another name for `values-list', but    I assume you are just abstracting here the useful aspects of a real    `foo' of yours.)T    I suspect I would write something as uninformative as	(proclaim '(function foo (list) (values &rest list)))    which is marginally better than no declaration at all.Are &markers accepted in these definitions? They aren't lamda lists. Ididn's see anything in CLtL to indicate that they are acceptible...Thnx,Brad------miller@cs.rochester.edu {...allegra!rochester!miller}Brad MillerUniversity of Rochester Computer Science Department*start*04599 00024 USaReturn-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 11 DEC 87 10:52:09 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Fri 11 Dec 87 13:50:40-ESTDate: Fri, 11 Dec 87 13:50 ESTMessage-ID: <FAHLMAN.12357673879.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@CMU-CS-C>To: Masinter.paCc: fahlman@C.CS.CMU.EDUSubject: Issue: FUNCTION-DECLARATION issuesIn-reply-to: Msg of 11 Dec 1987  02:40-EST from Masinter.pa at Xerox.COM    I found myself disagreeing with most of your points. I thought maybe we should    try working out some of them one-on-one.     I do think we have some responsibility to remove useless features, even those    that are harmless, while resisting adding new ones of dubious semantics and    value.Well, others might call this gratuitous incompatible change.  I don'tcare whether we keep the current long-form function type spec or not,but I'd hate to break someone's code for no good reason.  People mayhave sprinkled these function declarations through their programs in thehope that some clever compiler would eventually do something with them.    "1. Leave the FUNCTION type specifier alone.  It's not terribly useful in    its non-restrictive form, but it is harmless and it does fit in with the    rest of the type system.  (Of course, we would make it a full-fledged    type-specifier as discussed in the FUNCTION-TYPE proposal.)"    I'm turning 'not terribly useful' into 'useless'. I guess except as    documentation, but the intent of the documentation is the restrictive form    anyway, isn't it?Well, I agree that the non-restrictive form is of little value asdocumentation.    "2. Add an extended form for the LIST type specifier so that one can    indicate element type and, perhaps, length.  This can be used to say    something useful about rest-args, without having to put in ugly special    syntax for this."    There's a problem in the interpretation of the type (LIST TYPE), in that it is    different from (VECTOR TYPE), can't be tested in unit time (must go down the    list, if you want to do TYPEP), can be dynamicly affected (by a (SETF (CAR ..)    ..) etc. No other non-SATISFIES built-in type has this problem.Gee, it seems strange to me that we should make it impossible to saysomething useful about a type, just because it can't be checked quicklyat runtime.  We could say, as we have in other situations, that the longform of LIST is valid only for declaration and not for type-checking.Or we could just warn that because this declaration can be expensive tocheck, most systems will decline to do this at runtime.    "3. Add a new declaration/proclamation, distinct from TYPE, by which    users can tell the compiler restrictive things about what a given    function will accept and what it will return.  This notation can be set    up so that you can say things like "if all args are integer, the result    will be" and "if the second arg is spaceship, the result will be    Martian".  Obviously this bit will require some careful design so that    we can make it maximally expressive and minimally confusing.  I don't    have a proposal ready; maybe Rob does."    If it isn't a TYPE you can't use DEFTYPE and you can't define things like    BINARY-ARITHMETIC like you can now with DEFTYPE, etc. A whole new mechanism? Well, DEFTYPE has never loomed very large in my thinking, I'm afraid.Again, we need to be able to say this restrictive thing in order tobuild good compilers.  We can either let people do this in an ad hoc wayin each implementation, or we can give them a standard on this.  I don'tthink that this is really a type declaration, since it behaves ratherdifferently, but we still need some way to express it.    "4. Let me toss in here a related idea by Dave Touretzky that I've been    waiting to introduce whenever the time . . . . "    This seems like something that ought to be tried out first. I think these kinds    of global proclaimations affecting system types have the same sorts of problems    that FLETing special forms do, e.g.,     (RESTRICT NUMBER (INTEGER -1024 1024))    and yet under some WITH-OPEN-FILE there's an INCF that's incrementing the    open-file-count which happens to exceed 102 .As always, if you put in a declaration, you have to make sure it'sreally true.  I don't see that this is any more treacherous than theother type declarations.  It's just a shorthand for putting zillions ofTHE statements all over your code.-- Scott*start*01052 00024 US From: masinter.PADate: 16-Dec-87  1:32:02 PSTSubject: Current practice:argument types in function declarationsTo: common-lisp@sail.stanford.educc: masinterThe cleanup committee is considering various issues surrounding function declarations, and, in particular, declarations of the types of arguments.We've had considerable input about what such declarations could mean, should mean, what CLtL says they mean. Rather than going over all of that, this is a question about current practice: What do current implementations actually do? What do current users actually use have in their programs?Is anyone aware of any (released? supported?) Common Lisp implementation that pays any attention at all to the types of arguments, e.g., for which(proclaim '(function my-function (list vector) t))has any effect different from(proclaim '(function my-function (t t) t))?Does anyone *have* any Common Lisp code which contains such declarations? What is the intent of the declarations, other than as documentation?*start*00612 00024 USaReturn-Path: <vanroggen%aitg.DEC@decwrl.dec.com>Received: from decwrl.dec.com by Xerox.COM ; 16 DEC 87 06:50:03 PSTReceived: by decwrl.dec.com (5.54.4/4.7.34)	id AA12099; Wed, 16 Dec 87 06:50:49 PSTDate: Wed, 16 Dec 87 06:50:49 PSTMessage-Id: <8712161450.AA12099@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: masinter.PA, VANROGGEN@decwrl.dec.comSubject: RE: Current practice:argument types in function declarationsVAX LISP certainly does heed such proclamations when compiling callsto the declared functions.  And we do have such code in our system.			---Walter*start*02633 00024 US Return-Path: <mike%acorn%LIVE-OAK.LCS.MIT.EDU.#Chaos@XX.LCS.MIT.EDU>Received: from XX.LCS.MIT.EDU by Xerox.COM ; 16 DEC 87 10:45:32 PSTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 16 Dec 87 13:34-ESTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 72595; 16 Dec 87 13:28:50-ESTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 89445; Wed 16-Dec-87 13:03:38-ESTDate: Wed, 16 Dec 87 13:11 estFrom: mike%acorn@LIVE-OAK.LCS.MIT.EDUTo: masinter.PASubject: Current practice:argument types in function declarationsCc: common-lisp@sail.stanford.edu    From: masinter.PA@Xerox.COM    Date: 16 Dec 87 1:32:02 PST    >Is anyone aware of any (released? supported?) Common Lisp implementation that>pays any attention at all to the types of arguments, e.g., for which>    (proclaim '(function my-function (list vector) t))>has any effect different from>    (proclaim '(function my-function (t t) t))>    ?>Does anyone *have* any Common Lisp code which contains such declarations?>What is the intent of the declarations, other than as documentation?First off, either signature tells you more than nothing at all, sinceit fixes the number of arguments. Presumably, you have to checkthe number of arguments as well as the types for really safe calls.As for use, we are not using them currently, but plan to use them.The goal is to generate "safe" calls for functions when compiling ifthe type signature is unknown. If the type signature is known;however, the checking burden is placed on the caller (and can beminimized via type inference, etc.) and an unsafe call is generated.The type signature can be known either via block compilation, orby using function type proclamations. In any case if you ftype a functionand a call can be shown to contradict the proclamation, then youshould get a warning and a safe (slow) call.The one difficulty with these things is that common lisp's typelanguage doesn't allow you to specify accurate types for things like <. E.G.,(proclaim '(ftype < (function (&rest ??) (or T nil))))For ?? you'd like to say "zero or more non-complex numbers". You do NOT want to say LIST here.I am considering defining a (list-of ...) type specifier.where the argument is a type. This cannot really be written in common lisp, since it doesn't allow parameterized types in general.But we as implementors can put it in place as an extension.Mike BeckerleGold Hill Computers.        *start*00868 00024 US Return-Path: <johnw%cvaxa.sussex.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK by Xerox.COM ; 16 DEC 87 10:56:07 PSTReceived: from cvaxa.sussex.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa09399; 16 Dec 87 18:17 GMTFrom: John Williams <johnw%cvaxa.sussex.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Wed, 16 Dec 87 18:13:25 GMTMessage-Id: <561.8712161813@csuna.cvaxa.sussex.ac.uk>To: "masinter.PA" <@NSS.Cs.Ucl.AC.UK,@cvaxa.sussex.ac.uk:masinter.PA@xerox.com>Subject: Re:  Current practice:argument types in function declarationsPOPLOG Common Lisp (POPLOG is a UK AI development environment) willrecognise function declarations in the next release, but only becauseit is interested in knowing how many arguments and results a functiontakes (especially the number of results). John Williams (johnw@uk.ac.sussex.cvaxa)*start*00685 00024 US Return-Path: <norvig%cogsci.Berkeley.EDU@ucbvax.Berkeley.EDU>Received: from cogsci.berkeley.edu by Xerox.COM ; 16 DEC 87 11:26:25 PSTReceived: by cogsci.berkeley.edu (5.58/1.26)	id AA06978; Wed, 16 Dec 87 11:26:04 PSTDate: Wed, 16 Dec 87 11:26:04 PSTFrom: norvig%cogsci.Berkeley.EDU@ucbvax.Berkeley.EDU (Peter Norvig)Message-Id: <8712161926.AA06978@cogsci.berkeley.edu>To: mike%acorn@live-oak.lcs.mit.eduSubject: Re: Current practice:argument types in function declarationsCc: masinter.paSure, you can define LIST-OF:(deftype list-of (element-type)  `(and list (satisfies (lambda (l) 			   (every #'(lambda (x) (typep x ',element-type)) l)))))*start*00530 00024 US Date: 16 Dec 87 12:42 PSTFrom: Masinter.paSubject: RE: Current practice:argument types in function declarationsIn-reply-to: vanroggen%aitg.DEC@decwrl.dec.com's message of Wed, 16 Dec 87 06:50:49 PSTTo: vanroggen%aitg.DEC@decwrl.dec.comcc: masinter.PASigh, I don't have a VAX LISP manual. In what way does it "heed such proclaimations"? For example, does VAX LISP assume that, given(proclaim '(function my-function (integer symbol) t))that it is an error to call(my-function 'a-symbol 3)?*start*01509 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 16 Dec 87 02:00From: masinter:PA:XeroxSubject: Current practice:argument types in function declarationsTo: common-lisp%sail.stanford:EDU:Xeroxcc: masinter:PA:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 DEC 87 02:01:01 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 16 Dec 87  01:32:09 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 DEC 87 01:32:19 PSTOriginal-Date: 16 Dec 87 1:32:02 PSTMessage-ID: <871216-013219-2778@Xerox>The cleanup committee is considering various issues surrounding functiondeclarations, and, in particular, declarations of the types of arguments.We've had considerable input about what such declarations could mean, shouldmean, what CLtL says they mean. Rather than going over all of that, this is aquestion about current practice: What do current implementations actually do? What do current users actually usehave in their programs?Is anyone aware of any (released? supported?) Common Lisp implementation thatpays any attention at all to the types of arguments, e.g., for which(proclaim '(function my-function (list vector) t))has any effect different from(proclaim '(function my-function (t t) t))?Does anyone *have* any Common Lisp code which contains such declarations? Whatis the intent of the declarations, other than as documentation?*start*01041 00024 US Return-Path: <vanroggen%aitg.DEC@decwrl.dec.com>Received: from decwrl.dec.com by Xerox.COM ; 16 DEC 87 13:02:12 PSTReceived: by decwrl.dec.com (5.54.4/4.7.34)	id AA07759; Wed, 16 Dec 87 13:02:06 PSTDate: Wed, 16 Dec 87 13:02:06 PSTMessage-Id: <8712162102.AA07759@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: Masinter.pa, VANROGGEN@decwrl.dec.comSubject: RE: Current practice:argument types in function declarationsThat's right--your example would be in error.Perhaps we can trade manuals.  If you can send me your language andutilities manuals, I'd appreciate it just like you would.  I have anold (big blue) Interlisp manual.  What's your mail address?  I'lllook for an up-to-date manual set (I actually don't have one).My mail address is   Walter van Roggen  DEC AITG  290 Donald Lynch Blvd  Marlborough MA 01752  DLB5-2/B10However, it's unlikely that our documentation would mention the caseyou bring up, since it's being an error would seem apparent from CLtL.			---Walter*start*32454 00024 USfDate: 16 Dec 87 13:27 PSTFrom: Masinter.paSubject: Issue: FUNCTION-ARGUMENT-TYPE-SEMANTICSTo: vanroggen%aitg.DEC@decwrl.dec.comcc: masinterIn fact, a careful reading of CLtL p. 47 suggests, at least to some folks, that (proclaim '(function my-function (integer))) does *not* imply that it is an error to pass a non-integer to my-function. I've enclosed most of the relevant mail on the subject. My inclination is to specify in the standard that such declarations mean what (apparently) almost everyone has taken them to mean, rather than what CLtL says.If you'd like to join in the discussion, I'll forward to you or cc you on subsequent mail on this topic.     ----- Begin Forwarded Messages -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 DEC 87 20:44:58 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Dec 87  20:42:44 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 DEC 87 20:41:08 PSTDate: 2 Dec 87 20:40 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Wed, 2 Dec 87 22:40 ESTTo: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-204108-1072@Xerox>I'm tempted to try to address several issues with FUNCTION declarations at once.1) I realize now that I do not understand the import of *any* of the argumenttype specifiers, and specificly the language about "at least of the typesspecified" that appears in CLtL p 47. However, I don't know what (declare (function my-cons (float string) list) )means. It says that my-cons is a function that can "accept a floating-pointnumber and a string (among other things), and its result is an object of typelist...."The problem is that the argument type declaration here is of absolutely no use.That the declared function can accept a float and a string among other thingshas no content. It doesn't say that it is illegal to pass a non-float as thefirst argument. It says that if you pass a float, its ok, and if you pass anon-float, it might be OK too. Isn't that the same as saying (function my-cons(t t) list)? It would be more valuable as far as I can see to say that a (function (floatstring) list) is one to which *only* a float and a string can be passed. Perhapssomeone familiar with an implementation that pays attention to thesedeclarations can explain what they are used to denote? 2) On the specific issue at hand: I'm inclined to be more sympathetic toallowing &REST <element-type>; function type specifiers are, after all, alreadya specialized little language -- the &KEY arguments have a separate syntax whichonly vaguely resembles the original lambda list syntax, for example. 3) Should the function type specifier also allow &ALLOW-OTHER-KEYS? Here is some (old) mail from the Common Lisp mailing list which touches on somerelated issues:!Date: 18 Apr 1986 16:07-ESTSubject: Type Specifier: (OR (FUNCTION ...) ...)From: NGALL@G.BBN.COMQuestion: What is the 'most informative' type specifier for the CL functionCOPY-SEQ?How 'bout? (function (sequence) sequence)Unfortunately, this does not tell the reader nor the compiler that if theargument is a list, then the result is also a list, and vice versa.  So howabout this:(or (function (list) list)    (function (vector) vector))This is syntactically valid CL, and the definition of the OR and FUNCTION typespecifiers makes it meaningful.  Unfortunately, it is not clear from pg. 158whether or not the following is legal:(proclaim '(ftype (or (function (list) list)                      (function (vector) vector))                  copy-seq))It is not legal in VaxLisp, and my guess is that there aren't anyimplementations that would do the right thing with it. So I would like topropose that such a use of OR/FUNCTION be considered legal CL.Without such a declaration, one is forced to either wrap (the <result-type> ...)around all calls to such functions or to DECLARE a restricted version ofFUNCTION in the appropriate places, e.g., (defun foo (alist avector)  (declare (list alist)           (vector avector)           (function copy-seq (list) list))  (zap (copy-seq alist)  (let ()    (declare (function copy-seq (vector) vector))    (zoop (copy-seq avector))))Either method is a real pain.This use of OR would give CL something akin to Ada overloading.  It allows theoverloading of multiple 'function type signatures' on a single function name.Such overloading is already implicit throughout CL (esp. the seq. functions).My proposal would merely allow a way of describing it.	-- Nick!Date: Mon, 4 Nov 85 22:29 ESTFrom: Daniel L. Weinreb <DLW@SCRC-QUABBIN.ARPA>Subject: Declaring FunctionsTo: shebs%utah-orion@UTAH-CS.ARPA, common-lisp@SU-AI.ARPAMessage-ID: <851104222904.2.DLW@CHICOPEE.SCRC.Symbolics.COM>In-Reply-To: <8511012045.AA07112@utah-orion.ARPA>    Date: Fri, 1 Nov 85 13:45:55 MST    From: shebs%utah-orion@utah-cs.arpa (Stanley Shebs)    The notion of a function type is mentioned in two places: p. 47 of the    CLM, where the (function ...) type specifier is defined, and p. 158-159,    where (ftype ...) and (function ...) are defined as options to declare.    Are they intended to be the same?  Read page 159 more carefully.  It explains that they have the same meaning, butare syntactically different.  "function" has the disadvantage that you can onlydeclare one thing per clause, unlike most other declarations, but the advantagethat it looks mildly like "defun".				       				       If so, then the second definition    should say that keywords and a (values ...) type specifier are allowed.If by keywords you mean &optional and friends, it isn't strictly necessary torepeat that, although it would sure clear things up if there were a crossreference in the book.However, there appears to be a typo on page 159.  The form following the phrase"entirely equivalent to", which currently reads (ftype (function arglist result-type1 result-type2 ...) name)ought to read  (ftype (function arglist (values result-type1 result-type2 ...)) name)in order to be consistent with page 47.     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 DEC 87 21:47:39 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Dec 87  21:46:13 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 DEC 87 21:42:53 PSTDate: Wed, 2 Dec 87 21:42:47 PSTFrom: Pavel.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: <871202-204108-1072@Xerox>To: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-214253-1099@Xerox>Larry says:``I don't know what  (declare (function my-cons (float string) list) ) means.''It is usual in type theory for this to be read as an implication:	IF	   you pass a float and a string to MY-CONS	THEN	   MY-CONS is guaranteed to return a list.More rigorously, a type theorist would see (function my-cons (float string)list) as representing the set of all functions that, when applied to a float anda string, return a list.Under this view of types, we understand the constructor OR to be set-union (thatis, the type (OR t1 t2) represents the set of values in the union of the setsrepresented by t1 and t2) and the AND constructor is thus set intersection.Under this view, Nick Gall gives the wrong answer to his question about aspecific type for COPY-SEQ when he claims that a good one would be(or (function (list) list)    (function (vector) vector))Since this does not guarantee that COPY-SEQ will return a list when applied to alist; in fact, a function in this type might very well bomb when presented witha list.  In general, ORing function types isn't very helpful.  What he reallywants here is AND, not OR:(and (function (list) list)     (function (vector) vector))This represents the set of functions that both map lists to lists and vectors tovectors.Let me point out that I'm not claiming that this is how CLtL intends functiontypes to be interpreted, just that this meaning has proven very convenient formost uses.	Pavel     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 DEC 87 22:26:58 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Dec 87  22:25:24 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 DEC 87 22:20:29 PSTDate: 2 Dec 87 22:20 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Pavel.pa's message of Wed, 2 Dec 87 21:42:47 PSTTo: Pavel.pacc: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-222029-1111@Xerox>Under the interpretation outlined in your message, it would not be valid to assume, given   (declare (function my-cons (float string) list) ) that     (typep (my-cons x y) 'list)  can be assumed, unless it was also asserted (declare (float x) (string y))?      ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 DEC 87 22:37:55 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Dec 87  22:36:45 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 DEC 87 22:36:23 PSTDate: Wed, 2 Dec 87 22:36:17 PSTFrom: Pavel.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: <871202-222029-1111@Xerox>To: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-223623-1122@Xerox>That's right.  Unless you know something about the types of the arguments, youcan assume nothing about the type of the result.	Pavel     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 DEC 87 13:32:45 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 3 Dec 87  13:31:12 PSTReceived: ID <RAM@C.CS.CMU.EDU>; Thu 3 Dec 87 16:30:32-ESTDate: Thu, 3 Dec 87 16:30 ESTMessage-ID: <RAM.12355605918.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>, cl-cleanup@SAIL.STANFORD.EDU, Masinter.pa, sandra%orion@CS.UTAH.EDUSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Msg of 3 Dec 1987  12:52-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>My compiler cleanup proposal addresses a number of the issues beingdiscussed here.  We already went around once on cl-cleanup about themeaning function type.In my initial proposal, I had assumed a strict interpretation offunction type.  It was pointed out to me, that not only is CLTL veryclear about its non-restrictive interpretation, it is also verydifficult to use a strict interpretation within the framework of thecurrent type system.Basically, the problem is that if you think about "function typedeclarations" as being declarations about the type of the object whichis the function, then it isn't possible to use a strictinterpretation.  If you attempt to do so, then there will be caseswhere a type declaration is necessary for a program to be correct, andremoving declarations can cause a program to be incorrect.  Inaddition to problems with defining where declarations are necessary,requiring declarations is also clearly in conflict with the statedgoals for declarations in Common Lisp.Basically, the reason for this non-intuitive result is that adeclaration of a function's type actually makes a statement about whatdefinitions are legal, rather than what calls are legal.  What acompiler really wants to know is what calls are legal.The solution I suggest in my proposal is to introduce a mechanism thatallows arbitrary information about a function definition to be boundat compile time.  You don't declare the function type, you just definethe function, with any appropriate argument type declarations.Since you have asserted that calls to the function can be bound atcompile time, the compiler can apply any assertions on the formalparameters to the actual parameters and use type information derivedfrom the definition as the type of the call result.Early-binding of function names also allows many other optimizationssuch as "inline expansion" and "block compilation".Before people flame uncotrollably about the horror of static functionbinding in Lisp, I will point out that I don't propose that staticfunction binding be required, or even that it necessarily be thedefault.  It is also worth noting that the extent to which staticbinding is actually done once it has been allowed is an implementationdecision.  Declaring static binding doesn't necessarily preventincremental redefintion or reduce safety, it might only cause bettercompiler warnings to be generated.If this capability exists, then function type declarations (andfunction types) are more useless than they currently are (if that iseven possible).  RobP.S.  My proposal is <ram>cprop.txt on c.cs.cmu.edu     ----- Next Message -----Date:  7 Dec 87 14:40 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Ram@C.CS.CMU.EDU's message of Thu, 3 Dec 87 16:30 ESTTo: Ram@C.CS.CMU.EDUcc: KMP@SCRC-STONY-BROOK.ARPA, cl-cleanup@SAIL.STANFORD.EDU, Masinter.pa, sandra%orion@CS.UTAH.EDURam: I've scanned your latest proposal, but it still doesn't seem to address the minor issue at hand here:What does (declare (function (integer integer) t) foo)  imply? We've discussed what it could mean, what it should mean, what CLtL says it means, but I'd to hear about current practice. What, if anything,  do current implementations do with such declarations? Do any implementations pay attention to the types of arguments in function declarations?      ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 DEC 87 09:55:59 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 3 Dec 87  09:53:41 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 294082; Thu 3-Dec-87 12:53:18 ESTDate: Thu, 3 Dec 87 12:52 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Masinter.pacc: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUIn-Reply-To: <871202-204108-1072@Xerox>Message-ID: <871203125256.0.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 2 Dec 87 20:40 PST    From: Masinter.pa@Xerox.COM    ...    (declare (function my-cons (float string) list) )    ...    The problem is that the argument type declaration here is of absolutely    no use.    ...    It would be more valuable as far as I can see to say that a    (function (float string) list)    is one to which *only* a float and a string can be passed. Perhaps    someone familiar with an implementation that pays attention to these    declarations can explain what they are used to denote? In Maclisp, if you declared a function to take arguments (fixnum flonum),for example, special tricks were allowed to be done with passing the argumentswithout having to heap-cons them. You were required to only use this declarationif you had made it available to the compiler at the time of compiling the function(so that it would have done the special tricks necessary to make the externalcalling sequence work). The net effect was that the function had a naive entrypoint (for people who didn't know about the declaration) and a magic entry pointfor people who wanted to exploit the declaration information and bypass somesetup instructions.In order to get this effect in CL, we have only to restrict the declaration ofa function to be exactly the declaration that the function was compiled under.That is, there are a number of possible universes we could elect to be in: * We could allow local function declarations to just say things we know to   be true, regardless of whether they were interesting. eg,      (PROCLAIM '(FUNCTION FOO (INTEGER) INTEGER))      (DEFUN FOO (X) (+ X 1))   could be matched in another file by      (LOCALLY (DECLARE (FUNCTION FOO (INTEGER) INTEGER)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM) FIXNUM)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (T) T)) ... (FOO ...) ...)   This would tend to thwart interesting compilations because nothing in the   declaration would tell you anything useful about how the function was compiled. * We could allow local function declarations only if they restrict the   declaration under which the function was compiled. eg,      (PROCLAIM '(FUNCTION FOO (INTEGER) INTEGER))      (DEFUN FOO (X) (+ X 1))   could be matched in another file by      (LOCALLY (DECLARE (FUNCTION FOO (INTEGER) INTEGER)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM) FIXNUM)) ... (FOO ...) ...)   but not by      (LOCALLY (DECLARE (FUNCTION FOO (T) T)) ... (FOO ...) ...)   This might thwart some interesting compilations because you wouldn't know    everything about the way the function was compiled, but you'd know some   information. * We could allow local function declarations only if they exactly match   the declaration under which the function was compiled. eg,      (PROCLAIM '(FUNCTION FOO (INTEGER) INTEGER))      (DEFUN FOO (X) (+ X 1))   could be matched in another file by      (LOCALLY (DECLARE (FUNCTION FOO (INTEGER) INTEGER)) ... (FOO ...) ...)   but not by      (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM) FIXNUM)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (T) T)) ... (FOO ...) ...)   This would have the best chance of getting interesting compilations, I think. * We could, as I guess Pavel is suggesting (though I lost or missed the   original mail), allow multiple declarations of the same function, in which   case the information provided would be of an entirely different nature (in   what amounts to a DEFMETHOD style) than what it's used for in the previous   three bullet items.   Presumably there are some gains to be had from this style. I have no feel for   how useful they are. An example, though, would be:      (PROCLAIM '(FUNCTION FOO (LIST) LIST))      (PROCLAIM '(FUNCTION FOO (VECTOR) VECTOR))   which would let you compile      (LENGTH (FOO (THE LIST L)))   into      (SYSTEM:LENGTH-ROUTINE-FOR-THINGS-KNOWN-TO-BE-OF-TYPE-LIST (FOO L))   [Sigh. I'd have called it SYSTEM:LIST-LENGTH, but that's taken by CLtL for    something that doesn't mean what I think of as LIST-LENGTH. A poor naming    decision if you ask me...] * This is a placeholder to remind readers that the likelihood that this list is   exhaustive is fairly low.This really gets at the heart of the problem, which is: * Are declarations just for compilation or do they serve some more abstract   higher level goal (eg, "documentation"). * How important is exact-typep information vs typep information. * How much of a modularity violation (or documentation constraint) is it to   have to know the exact conditions under which a function was compiled. * How important are optimal compilations?     ----- Next Message -----Return-Path: <sandra%orion@cs.utah.edu>Received: from cs.utah.edu by Xerox.COM ; 03 DEC 87 10:58:45 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA20506; Thu, 3 Dec 87 11:57:15 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA21459; Thu, 3 Dec 87 11:57:05 MSTDate: Thu, 3 Dec 87 11:57:05 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8712031857.AA21459@orion.utah.edu>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>Cc: Masinter.pa, cl-cleanup@sail.stanford.edu, sandra%orion@cs.utah.eduIn-Reply-To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Thu, 3 Dec 87 12:52 ESTOne reason for wanting to use a FUNCTION type specifier is that you mayonly be concerned with how many arguments a function can take, and youdon't care at all about their types.  Back when we were trying toimplement a CL compatibility package in PSL, we wanted to do thematching of actual arguments to lambda variables at compile-time so wecould use the EXPR call protocol instead of the much slower NEXPRprotocol.  (Basically, we had an EXPR entry point for every functionwith a 1-1 correspondence between actual arguments and lambdavariables.)  The problem is, you couldn't do the transformation on acall unless you already knew something about the lambda list for thefunction.I agree that the argument type business is confusing and not very usefulin its current state.  I'd like to say that    (LOCALLY (DECLARE (FTYPE (FUNCTION (INTEGER INTEGER) INTEGER) +))        (+ X Y))is equivalent to    (THE INTEGER (+ (THE INTEGER X) (THE INTEGER Y)))but I'm not sure that's exactly what CLtL is getting at.-Sandra-------     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 DEC 87 11:27:15 PSTDate: 03 Dec 87 11:23 PSTFrom: Dick Gabriel <RPG@SAIL.Stanford.EDU>Subject: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issues To: cl-cleanup@SAIL.Stanford.EDU I'd like to reiterate what Pavel said: the declaration(declare (function my-cons (float string) list) )means that the function MY-CONS accepts two arguments, the first at leastof the type FLOAT (it can be a more general type), and the second at leastof the type STRING; it returns one value which is of the type LIST (itcould be more specific).Unfortunately, it does not mean that if the two arguments are of typesFLOAT and STRING then the result is of type LIST, which would beuseful.Lucid has a variant of this called RESTRICTIVE-FTYPE (or something),which would mean MY-CONS assumes it receives two arguments of typesFLOAT and STRING and produces something of type LIST.See page 47 (CLtL), the last complete paragraph, to see this.			-rpg-     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 DEC 87 12:17:36 PSTReceived: from SCRC-YUKON.ARPA by SAIL.STANFORD.EDU with TCP; 3 Dec 87  12:15:27 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 301485; Thu 3-Dec-87 14:17:50 ESTDate: Thu, 3 Dec 87 14:17 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: sandra%orion@cs.utah.educc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: <8712031857.AA21459@orion.utah.edu>Message-ID: <871203141725.5.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Thu, 3 Dec 87 11:57:05 MST    From: sandra%orion@cs.utah.edu (Sandra J Loosemore)    One reason for wanting to use a FUNCTION type specifier is that you may    only be concerned with how many arguments a function can take, and you    don't care at all about their types. ...Thanks for remembering to mention this issue. It pops into my head from time to timeand then I always forget it before I get to the console.Yes, the same style of issues as I raised in my last message applies to argumentnumber. eg, if I did (PROCLAIM '(FUNCTION FOO (NUMBER NUMBER) NUMBER)) (DEFUN FOO (X Y) (+ X Y)) and later did: (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM &REST (LIST T)) FIXNUM)) ... (FOO ...) ...)would I be within reason? ie, is there semantic impact to the &REST which goes beyondtype declaring the rest of the arguments to be of type T? Am I also declaring that thefunction was in fact compiled believing that a &REST style argument pickup was used(and at the same point as I've specified it here). What about: (PROCLAIM '(FUNCTION FOO (NUMBER &REST (LIST NUMBER)) NUMBER)) (DEFUN FOO (X &REST Y) (APPLY #'+ X Y)) and then later (LOCALLY (DECLARE (FUNCTION FOO (NUMBER NUMBER &REST (LIST NUMBER)) NUMBER))   ... (FOO ...at least two arguments...) ...)In my CL conversion of Macsyma, I threw out all the *LEXPR declarations becauseCL couldn't make any use of them and they were just clutter. (And they'd be trivialto re-conjure if they were ever needed.) But I felt funny as I did it because I didknow I was throwing away information that would be interesting to some compilersand that seemed sad, so I definitely agree that one way or another, this is a realissue.     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 DEC 87 03:10:28 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 9 Dec 87  03:03:38 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 09 DEC 87 03:00:06 PSTDate: 9 Dec 87 02:59 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Ram@C.CS.CMU.EDU's message of Tue, 8 Dec 87 14:21 ESTTo: Ram@C.CS.CMU.EDUcc: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871209-030006-1558@Xerox>I think I understand and agree with most of what you say, in particular "I thinkthat we should either entirely flush the concept of "function types" or changethe theory behind them.  The CLtL interpretation is well-defined, but not veryuseful. " There are two components to your proposal: (1) what is allowed (and what itmeans), and (2) how it is described in the standard.I like the part of your proposal which is to change the interpretation offunction declarations to mean an implicit assertion of argument and value types(the "restrictive interpretation"). I like defining  (declare (type (function (frob grid) bunker) x)) to mean (funcall x y z) has implicitly means  (the bunker (funcall (the function x)(the frob y) (the grid z)))I don't see, however, that there is much leverage to removing FUNCTION from thesection on type specifiers. It would do some violence to the otherwise usefulconcept of (deftype binary-arithmetic () '(function (number number) number))to be used in(declare (ftype binary-arithmetic x y z)) .I don't see at all that (funcall #'foo x y) doesn't mean (the t (funcall #'foo(the integer x) (the integer y)))) given (declare (function foo (integerinteger) t)). In the type propagation rules, you can transform funcall and apply expressionsusing the asserted value of the function argument, and the asserted value typeof #'name is derived from the asserted ftype of name. In this interpretation, AND would distribute nicely, Given (proclaim '(function foo (s1 t1) v1)) and (declare (function foo (s2 t2)v2)) you could assert that(foo x y) => (the (and v1 v2) (foo (the (and s1 s2) x) (the (and t1 t2) y))).(OR doesn't distribute as nicely, e.g., given (declare (ftype (or (function (s1t1) v1) (function (s2 t2) v2)) foo)),  there isn't a simple way to describe thetype assertions made for (foo x y).  We might even want to explicitly allow FUNCTION declarations in THEexpressions, as in(funcall (the binary-arithmetic x)  y z).     ----- Next Message -----Return-Path: <RAM@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 08 DEC 87 11:23:43 PSTReceived: ID <RAM@C.CS.CMU.EDU.#Internet>; Tue 8 Dec 87 14:22:06-ESTDate: Tue, 8 Dec 87 14:21 ESTMessage-ID: <RAM.12356893261.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDU, KMP@SCRC-STONY-BROOK.ARPA, sandra%orion@CS.UTAH.EDUSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Msg of 7 Dec 1987  17:40-EST from Masinter.pa at Xerox.COM    Date: Monday, 7 December 1987  17:40-EST    From: Masinter.pa at Xerox.COM    To:   Ram at C.CS.CMU.EDU    cc:   KMP at SCRC-STONY-BROOK.ARPA, cl-cleanup at SAIL.STANFORD.EDU,	  Masinter.pa at Xerox.COM, sandra%orion at CS.UTAH.EDU    Re:   Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issues    [...] What does (declare (function (integer integer) t) foo) imply?    We've discussed what it could mean, what it should mean, what CLtL    says it means, but I'd to hear about current practice. What, if    anything, do current implementations do with such declarations? Do    any implementations pay attention to the types of arguments in    function declarations?Our current compiler totally ignores function type declarations.I am working on a new compiler that currently gives function typedeclarations a strict interpretation, i.e. the function must be calledonly with two integer arguments.  (I suspect that this is like theRESTRICTIVE-FTYPE declarations that someone from Lucid mentioned.)  Atleast as an interpretation for FTYPE, this is clearly wrong.  I intendto at least rename this declaration, and perhaps entirely flush it asa user-visible facility.I think that we should either entirely flush the concept of "functiontypes" or change the theory behind them.  The CLtL interpretation iswell-defined, but not very useful.  The intuitive strictinterpretation is useful, but is not a type declaration, at least inthe sense used in CLtL.The restrictive interpretation can be modeled as a sort of magicsyntactic shorthand for a bunch of THE declarations at the call site:    (the t (foo (the integer x) (the integer y)))But under this interpretation, a "function type" isn't a type at all,since it isn't in any sense the type of the function object beingcalled.  It wouldn't be meaningful to declare a variable or value tohave a function type.  A "function type declaration" would be a pieceof magic recognized by the implementation that constrains calls to aparticular function variable.If we did this, then the concept of a "function type specifier" shouldbe flushed, since "function types" can't be used in any of the waysreal types can.  The "function type" syntax would become part of thesyntax peculiar to a "function type declaration".  (A minor beneficialside-effect is that it would make obvious the restriction on functiontypes in TYPEP.)One problem that I have with this interpretation is that it makes theevaluation of the functional position even more peculiar than italready is.  Since a "function type declaration" would be purelysyntactic, it would only take effect when there was a syntactic match,i.e. an obvious normal call to a declared function variable.  It wouldprobably be incorrect to do this transformation:    (funcall #'foo x y)  ==>    (the t (funcall #'foo (the integer x) (the integer y))))  Rob     ----- Next Message -----Return-Path: <sandra%orion@cs.utah.edu>Received: from cs.utah.edu by Xerox.COM ; 09 DEC 87 07:02:36 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA09306; Wed, 9 Dec 87 08:00:52 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA16131; Wed, 9 Dec 87 08:00:48 MSTDate: Wed, 9 Dec 87 08:00:48 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8712091500.AA16131@orion.utah.edu>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Masinter.paCc: Ram@c.cs.cmu.edu, cl-cleanup@sail.stanford.edu, sandra%orion@cs.utah.eduIn-Reply-To: Masinter.pa@Xerox.COM, 9 Dec 87 02:59 PST  Date: 9 Dec 87 02:59 PST  From: Masinter.pa@Xerox.COM  Given (proclaim '(function foo (s1 t1) v1)) and (declare (function foo (s2 t2)  v2)) you could assert that  (foo x y) => (the (and v1 v2) (foo (the (and s1 s2) x) (the (and t1 t2) y))).I disagree.  The DECLARE should shadow the PROCLAIM; see p. 156 ofCLtL.  Or is there another proposal in the works to change declarationshadowing as well?  :-)-Sandra-------     ----- End Forwarded Messages -----*start*02864 00024 US Return-Path: <vanroggen%aitg.DEC@decwrl.dec.com>Received: from decwrl.dec.com by Xerox.COM ; 16 DEC 87 16:31:24 PSTReceived: by decwrl.dec.com (5.54.4/4.7.34)	id AA10671; Wed, 16 Dec 87 14:22:09 PSTDate: Wed, 16 Dec 87 14:22:09 PSTMessage-Id: <8712162222.AA10671@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: Masinter.pa, VANROGGEN@decwrl.dec.comSubject: RE: Issue: FUNCTION-ARGUMENT-TYPE-SEMANTICSInteresting.I haven't really studied all the comments, but here are my off-the-cuffreactions:(PROCLAIM '(FTYPE (FUNCTION (A B) C) F))may cause the compilation of a call to F to be compiled as(THE C (F (THE A x) (THE B y)))It currently does not affect the compilation of the definition of F,though it should, ideally.  [BTW, I'm talking about what VAX LISPhas done for several years now.]If it did affect the compilation of the definition of F, I would thinkany local declarations of F's parameters would have to be "compatible"with any proclamation of F.  Compatible doesn't mean "the same or morerestrictive", it means the intersection of the types is non-null.First, we assume (THE A (THE B x)) is the same as (THE (AND A B) x).Is this already "known" from reading CLtL, or was this just a rashassumption on my part?If that's true, then I have been assuming that the above proclamationof F combined with a more local declaration of F would produce functiontype specifiers that AND each parameter:(LOCALLY (DECLARE (FTYPE (FUNCTION (A2 B2) C2) F))  ... (F x y) ...)and then the call to F would be equivalent to (THE (AND C C2) (F(THE (AND A A2) x) (THE (AND B B2) y))).This last inference has -not- yet been implemented in VAX LISP, but hasbeen requested many times.So far all this works for positional parameters but not for keywordparameters.  I don't have a firm opinion about what should happen whenthe number of required or optional parameters is incompatible, or whendifferent keyword parameters are specified.  I'd guess that a reasonableapproach is to allow specifying subsets of the permissible keywords,and that for each, the types are ANDed.BTW, I'm really against allowing the &REST type specifier refer to theelement rather than the whole list.  Why not allow LIST to be a shortform of (LIST *), and let people say (FUNCTION (... &REST (LIST INTEGER)) ...)?One can easily argue about how much expressivity should go into thesedeclarative type specifiers, but this seems like a simple extension.Further afield, I'd say that type specifiers really shouldn't be symbolsand lists of symbols and numbers, but functions, which happen to haveconvenient names represented by those symbols and lists.  These types/functions would be required to implement certain methods to handleTYPEP, SUBTYPEP, NAME, and who knows what else found to be useful.			---Walter*start*04869 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Dec 87 11:24From: jbarnett%nrtc.northrop:COM:XeroxSubject: Types in CLTo: common-lisp%sail.stanford:EDU:Xeroxcc: jbarnett%nrtc.northrop:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Barnett <jbarnett@nrtc.northrop.com>To: common-lisp@sail.stanford.educc: jbarnett@nrtc.northrop.comSubject: Types in CLReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 11:23:47 PSTReceived: from NRTC.NORTHROP.COM by SAIL.STANFORD.EDU with TCP; 17 Dec 87  10:48:26 PSTOriginal-Date: Thu, 17 Dec 87 10:48:05 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVRecently, there has been some message traffic concerning functional typespecification and related topics.  The purpose of this note is to pointout two problems with the CL type mechanism that I have not seendiscussed: the first concerns a case were the value of TYPEP *must* beundefined and the second concerns the definition of a subtype of afunctional type.PROBLEM I.  Assume that the following have been evaluated	(DEFTYPE T1 '(ARRAY T2 1))	(DEFTYPE T2 '(NOT T1))Let A be a one-dimensional array of size 1 such that (EQ A (AREF A 0)).What should the value of (TYPEP A 'T1) be?  It is easy to see that A isin type T1 if and only if it is not in type T1.  A type specificationmechanism that allows (1) recursive definitions and (2) a negationoperation is sure to have this problem.  Obviously, we want recursivespecification so that chains or rings of same-typed structures can bespecified and we want negation so that the programmer does not need toexplicitly list every possible alternative type in his definition.PROBLEM II.  Assume that the following return non-NIL	(SUBTYPEP 'T1 'T2)	(SUBTYPEP 'T2 'T3)The question is what are the subtypes of the type specifier	(FUNCTION (T2) T2)I think that the answer is	(FUNCTION (T3) T1)because the type-specific contract of an F in type (FUNCTION (T2) T2) isto (1) accept as arguments objects in T2 and (2) return objects in T2.Therefore, an F that accepts objects in T3 (which includes all of T2)and returns objects in T1 (all of which are in T2) satisfies thatcontract.  An F in (FUNCTION (T1) T3) does not because (1) it does notpromise to handle an object in T2-T1 and (2) may return an object inT3-T2.  Therefore,	(SUBTYPEP '(FUNCTION (T3) T1) '(FUNCTION (T2) T2))should be non-NIL while	(SUBTYPEP '(FUNCTION (T1) T3) '(FUNCTION (T2) T2))should be NIL.  Note, as SUBTYPEP decomposes functional typespecifications and recurs, it must *reverse* the order of its argumentswhen checking argument types---original order is used when value typesare checked.  It is somewhat amusing to trace a case where the typespecification of either the arguments and/or the values are themselvesfunctional types or where functional types are recursively specified.One reason to make sure that determining subtype-ness of functionaltypes is as accurate as it can be as often as possible arises becausemost LISPS do incremental compilations and are interactive.  If afunction is recompiled and either its argument or value types change, itwould be good to inform the user where there are calls that are nolonger type-compatible.  IF THE NEW TYPE OF THE FUNCTION IS A SUBTYPE OFTHE OLD, THEN, AS FAR AS TYPE CHECKING IS CONCERNED, EVERYTHING MUST BEOKAY.  It is only when this is not true, that it is necessary to checkthe types of objects actually passed to the function from other code orsee what assumptions have been made in consuming the returned objects.There is a slight generalization of the comments as to what is areasonable definition of subtype of functional types.  Assume that avariable or register has been given a type specification.  Let that typespecification be changed.  There are three possibilities:1. THE NEW TYPE SPECIFICATION IS A SUBTYPE OF THE OLD	Code that only reads the cell is not affected.	Code that writes the cell may or may not be valid.2. THE NEW TYPE SPECIFICATION IS A SUPERTYPE OF THE OLD	Code that only writes the cell is not affected.	Code that reads the cell may or may not be valid.3. THE NEW AND OLD TYPE SPECIFICATIONS ARE NOT COMPARABLE	Any code that reads the cell may or may not be valid.The reason that the above implies the rules for functional subtypedetermination is that, from the point of view of a function caller,arguments represent write-only registers while values representread-only registers.  A while ago, there was some discussion of having aclass of read-only goodies in LISP.  If that is ever sanctioned, thesecomments may provide some guidance in error checking interactions ofthat mechanism with type declarations and revisions.	Jeff*start*02846 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 16 Dec 87 11:16From: mike%acorn%LIVE-OAK.LCS.MIT:EDU:XeroxSubject: Current practice:argument types in function declarationsTo: masinter:PA:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 DEC 87 11:16:14 PSTReceived: from XX.LCS.MIT.EDU by SAIL.STANFORD.EDU with TCP; 16 Dec 87  10:45:26 PSTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 16 Dec 87 13:34-ESTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 72595; 16 Dec 87 13:28:50-ESTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 89445; Wed 16-Dec-87 13:03:38-ESTOriginal-Date: Wed, 16 Dec 87 13:11 est    From: masinter.PA@Xerox.COM    Date: 16 Dec 87 1:32:02 PST    >Is anyone aware of any (released? supported?) Common Lisp implementation that>pays any attention at all to the types of arguments, e.g., for which>    (proclaim '(function my-function (list vector) t))>has any effect different from>    (proclaim '(function my-function (t t) t))>    ?>Does anyone *have* any Common Lisp code which contains such declarations?>What is the intent of the declarations, other than as documentation?First off, either signature tells you more than nothing at all, sinceit fixes the number of arguments. Presumably, you have to checkthe number of arguments as well as the types for really safe calls.As for use, we are not using them currently, but plan to use them.The goal is to generate "safe" calls for functions when compiling ifthe type signature is unknown. If the type signature is known;however, the checking burden is placed on the caller (and can beminimized via type inference, etc.) and an unsafe call is generated.The type signature can be known either via block compilation, orby using function type proclamations. In any case if you ftype a functionand a call can be shown to contradict the proclamation, then youshould get a warning and a safe (slow) call.The one difficulty with these things is that common lisp's typelanguage doesn't allow you to specify accurate types for things like <. E.G.,(proclaim '(ftype < (function (&rest ??) (or T nil))))For ?? you'd like to say "zero or more non-complex numbers". You do NOT want to say LIST here.I am considering defining a (list-of ...) type specifier.where the argument is a type. This cannot really be written in common lisp, since it doesn't allow parameterized types in general.But we as implementors can put it in place as an extension.Mike BeckerleGold Hill Computers.        *start*02509 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Dec 87 00:35From: miller%ACORN.CS.ROCHESTER:EDU:XeroxSubject: Re: Current practice:argument types in function declarationsIn-Reply-to: <871216-013219-2778@Xerox>Reply-to: miller%cs.rochester:EDU:XeroxTo: masinter:PA:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Brad Miller <miller@ACORN.CS.ROCHESTER.EDU>Subject: Re: Current practice:argument types in function declarationsTo: masinter.PAcc: common-lisp@sail.stanford.eduIn-Reply-To: <871216-013219-2778@Xerox>Reply-To: miller@cs.rochester.eduReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 00:35:13 PSTReceived: from [192.5.53.205] by SAIL.STANFORD.EDU with TCP; 17 Dec 87  00:04:27 PSTOriginal-Date: Thu, 17 Dec 87 03:05 ESTMessage-ID: <871217030542.2.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Organization: University of Rochester, Department of Computer SciencePostal-address: 401A CS Building, Computer Science Department, University of Rochester, Rochester NY 14627Phone: 716-275-1118GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: 16 Dec 87 1:32:02 PST    From: masinter.PA@Xerox.COM    Does anyone *have* any Common Lisp code which contains such declarations? What    is the intent of the declarations, other than as documentation?All the code I write has such delcarations, including for the types of allreturned values. The immediate purpose is documentation since it's ignored onthe machine I happen to work on (a symbolics) but it's my hope that in futurethe compiler/interpreter would complain about calls to the function that passthe wrong type of argument at compile time, if it can tell. (runtime woulddepend on OPTIMIZE SAFETY or some such, and probably local declarations insidethe defun or whatever). Also, it could be used as a note to the debugger, since it could flag that anargument was of an unexpected type if some other problem arises and it getsinvoked. (this would help track down the error).But I'm a user, not an implementor: this is just what I hope to eventually getout of it. As I said, right now it's just documentation so the next guy knowswhat I expected the function to handle when I wrote it.Brad Miller------miller@cs.rochester.edu {...allegra!rochester!miller}Brad MillerUniversity of Rochester Computer Science Department*start*02055 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Dec 87 08:10From: mike%acorn%LIVE-OAK.LCS.MIT:EDU:XeroxSubject: 1Question about declaration0To: RWK%YUKON.SCRC.Symbolics:COM:Xeroxcc: miller%cs.rochester:EDU:Xerox, CL%ACORN.CS.ROCHESTER:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 08:09:36 PSTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.STANFORD.EDU with TCP; 17 Dec 87  07:35:17 PSTReceived: from XX.LCS.MIT.EDU (XX.LCS.MIT.EDU) by ACORN.CS.ROCHESTER.EDU via INTERNET with SMTP id 26111; 17 Dec 87 10:36:14 ESTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 17 Dec 87 10:08-ESTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 72757; 17 Dec 87 09:46:25-ESTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 89447; Wed 16-Dec-87 13:11:58-ESTOriginal-Date: Wed, 16 Dec 87 13:19 est    Date: Fri, 11 Dec 87 10:54 EST    From: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>            Date: Fri, 11 Dec 87 01:16 EST        From: Brad Miller <miller@ACORN.CS.ROCHESTER.EDU>        1    How would you write a function declaration for the following?            (defun foo (bar)    	    (declare (type list bar))    	    (values-list bar)            (proclaim '(function foo (list) ????))        0I wouldn't.  CL doesn't have any syntax for declaring    a variable number of values, period.    I think you can do this in CL:(function foo (list) (values &rest list))see CLtL pg 48 under the values type specifier. The explaination forthis "feature" is motivated by multiple-value-call.So presumably with this declaration, you can do(multiple-value-call '+ (foo 1 2 3))and get some kind of optimized call since it knows it's getting backa variable number of values when FOO returns....mike beckerle    *start*02003 00024 US Return-Path: <@DOUGHNUT.CS.ROCHESTER.EDU:miller@ACORN.CS.ROCHESTER.EDU>Received: from DOUGHNUT.CS.ROCHESTER.EDU by Xerox.COM ; 18 DEC 87 08:15:10 PSTDate: Thu, 17 Dec 87 03:05 ESTFrom: Brad Miller <miller@ACORN.CS.ROCHESTER.EDU>Subject: Re: Current practice:argument types in function declarationsTo: masinter.PAcc: common-lisp@sail.stanford.eduIn-Reply-To: <871216-013219-2778@Xerox>Message-ID: <871217030542.2.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Sender: miller@cs.rochester.eduReply-To: miller@cs.rochester.eduOrganization: University of Rochester, Department of Computer SciencePostal-address: 401A CS Building, Computer Science Department, University of Rochester, Rochester NY 14627Phone: 716-275-1118    Date: 16 Dec 87 1:32:02 PST    From: masinter.PA@Xerox.COM    Does anyone *have* any Common Lisp code which contains such declarations? What    is the intent of the declarations, other than as documentation?All the code I write has such delcarations, including for the types of allreturned values. The immediate purpose is documentation since it's ignored onthe machine I happen to work on (a symbolics) but it's my hope that in futurethe compiler/interpreter would complain about calls to the function that passthe wrong type of argument at compile time, if it can tell. (runtime woulddepend on OPTIMIZE SAFETY or some such, and probably local declarations insidethe defun or whatever). Also, it could be used as a note to the debugger, since it could flag that anargument was of an unexpected type if some other problem arises and it getsinvoked. (this would help track down the error).But I'm a user, not an implementor: this is just what I hope to eventually getout of it. As I said, right now it's just documentation so the next guy knowswhat I expected the function to handle when I wrote it.Brad Miller------miller@cs.rochester.edu {...allegra!rochester!miller}Brad MillerUniversity of Rochester Computer Science Department*start*01743 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 18 Dec 87 07:07From: samalone%ATHENA.MIT:EDU:XeroxSubject: Re: Current practice:argument types in function declarationsTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: <samalone@ATHENA.MIT.EDU>To: common-lisp@sail.stanford.eduSubject: Re: Current practice:argument types in function declarationsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 18 DEC 87 07:07:59 PSTReceived: from ATHENA.MIT.EDU by SAIL.STANFORD.EDU with TCP; 18 Dec 87  06:29:40 PSTReceived: by ATHENA.MIT.EDU (5.45/4.7) id AA08775; Fri, 18 Dec 87 09:29:25 ESTReceived: by M16-034-12.MIT.EDU (5.45/4.7) id AA10133; Fri, 18 Dec 87 09:29:16 ESTMessage-Id: <8712181429.AA10133@M16-034-12.MIT.EDU>Original-Date: Fri, 18 Dec 87 09:29:12 ESTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVYes, I often proclaim functions to take arguments of specific types. Usually this happens when I want to proclaim the return value of afunction and my sense of taste insists that I proclaim the types of thearguments as well.  However, none of the implementations I've used seemto do much with the information.There is one time when proclaiming the types of arguments to a function is obviously useful: when compiling the function itself.  True, one coulduse declarations inside of the function to achive the same result, butusing a proclamation keeps all of the function's type specification in one place.Without repeating them, I'd also like to voice my support of thecomments made by Mike Bekerle and Brad Miller.				--Stuart A. Malone*start*02460 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Dec 87 12:55From: barmar%Think:COM:XeroxSubject: Types in CLIn-Reply-to: <8712171849.AA02757@Think.COM>To: jbarnett%nrtc.northrop:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Types in CLTo: Jeff Barnett <jbarnett@nrtc.northrop.com>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <8712171849.AA02757@Think.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 12:55:22 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 17 Dec 87  12:20:30 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 17 Dec 87 15:19:56 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 17 Dec 87 15:19:52 ESTOriginal-Date: Thu, 17 Dec 87 15:21 ESTMessage-Id: <871217152141.3.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date:     Thu, 17 Dec 87 10:48:05 PST    From: Jeff Barnett <jbarnett@nrtc.northrop.com>    PROBLEM I.  Assume that the following have been evaluated	    (DEFTYPE T1 '(ARRAY T2 1))	    (DEFTYPE T2 '(NOT T1))    Let A be a one-dimensional array of size 1 such that (EQ A (AREF A 0)).By doing (SETF (AREF A 0) A) you have violated the type declaration youspecified, because you said that the elements of the array would neverbe of the same type as the array itself, so a compiler would bejustified in assuming that (EQ A (AREF A 0)) is never true.    What should the value of (TYPEP A 'T1) be?  It is easy to see that A is    in type T1 if and only if it is not in type T1.  A type specification    mechanism that allows (1) recursive definitions and (2) a negation    operation is sure to have this problem.Look up Russell's paradox (the one about the barber who shaves all andonly people who don't shave themselves, or the catalog of all books notin any other catalog) in a logic book.  Any sufficiently expressiveclass system allows such classes to be specified, even though such setscannot actually exist because they are self-contradictory.  Your exampleisn't really like this, because the Lisp type system lacks the abilityto specify that an array of type T1 contains ALL objects of type T2.                                                barmar*start*01616 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Dec 87 13:31From: jbarnett%nrtc.northrop:COM:XeroxSubject: Re:  Types in CLTo: barmar%think:COM:Xeroxcc: jbarnett%nrtc.northrop:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Barnett <jbarnett@nrtc.northrop.com>To: Barry Margolin <barmar@think.com>cc: Jeff Barnett <jbarnett@nrtc.northrop.com>, common-lisp@sail.stanford.eduSubject: Re:  Types in CLReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 13:31:16 PSTReceived: from NRTC.NORTHROP.COM by SAIL.STANFORD.EDU with TCP; 17 Dec 87  12:57:21 PSTOriginal-Date: Thu, 17 Dec 87 12:56:57 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVYour claim that the compiler should inhibit (SETF (AREF A 0) A) is only valid if A is declared of type T1.  It may not be.  What you are pointing out isthat there is a problem if one tries to determine the type of an object (orits type membership status) *after* the object is created.  In fact, theruntime package and compiler can offer you more protection if an object ismarked with a type when it is created; only then can modifications and so onbe checked locally.  However this loses something that may not be obvious: anobject can not be referenced by a register unless its marked type entails ALLtype restrictions imposed by the reference.  It is not sufficient that itscurrent configuration passes muster.	JeffP.S.  The barber is an old friend.*start*02318 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Dec 87 15:23From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Types in CLIn-Reply-to: The message of 17 Dec 87 13:48 EST from Jeff Barnett <jbarnett@nrtc.northrop.com>To: jbarnett%nrtc.northrop:COM:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Types in CLTo: Jeff Barnett <jbarnett@nrtc.northrop.com>cc: common-lisp@SAIL.STANFORD.EDUIn-Reply-To: The message of 17 Dec 87 13:48 EST from Jeff Barnett <jbarnett@nrtc.northrop.com>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 15:23:27 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 17 Dec 87  14:47:01 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 306293; Thu 17-Dec-87 17:47:00 ESTOriginal-Date: Thu, 17 Dec 87 17:46 ESTMessage-ID: <19871217224647.3.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVC    Date:     Thu, 17 Dec 87 10:48:05 PST    From:     Jeff Barnett <jbarnett@nrtc.northrop.com>    PROBLEM I.  Assume that the following have been evaluated	    (DEFTYPE T1 '(ARRAY T2 1))	    (DEFTYPE T2 '(NOT T1))    Let A be a one-dimensional array of size 1 such that (EQ A (AREF A 0)).    What should the value of (TYPEP A 'T1) be?You need to re-read the definition of the ARRAY type specifieron CLtL page 46, being careful also to read page 45, which doesn'tlook it's part of this, but is necessary in order to understand it.The -element-type- portion of the ARRAY type specifier doesn't meanwhat you think it means.This is interesting, because your "Problem I" is a good argument againstproposals that have been raised from time to time to change the definitionof the ARRAY type specifier to be what you thought it was.This is probably all a digression from your real point.  Since DEFTYPEcan do anything, especially in connection with SATISFIES, it is certainlypossible to create logically inconsistent type specifications, even thoughthe particular example you gave is not actually one.*start*02476 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Dec 87 15:28Subject: Re:  Types in CLFrom: NGALL%G.BBN:COM:XeroxIn-Reply-to: The message of     Thu, 17 Dec 87 10:48:05 PST from     Jeff Barnett <jbarnett@nrtc.northrop.com>To: jbarnett%NRTC.NORTHROP:COM:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 15:27:58 PSTReceived: from [8.2.0.18] by SAIL.STANFORD.EDU with TCP; 17 Dec 87  14:52:28 PSTOriginal-Date: 17 Dec 87 17:50 ESTMessage-ID: <[G.BBN.COM]17-Dec-87 17:50:23.NGALL>	    Date:     Thu, 17 Dec 87 10:48:05 PST    From:     Jeff Barnett <jbarnett@nrtc.northrop.com>        ...    PROBLEM I.  Assume that the following have been evaluated	    (DEFTYPE T1 '(ARRAY T2 1))	    (DEFTYPE T2 '(NOT T1))    Let A be a one-dimensional array of size 1 such that (EQ A (AREF A 0)).    What should the value of (TYPEP A 'T1) be?    ...Yes, a problem. CLtL should specify that the result of a call to TYPEPthat causes an identical subcall (i.e., it loops) is undefined.  Hereis a related (but perhaps better motivated example):(DEFTYPE TREE (LEAF-TYPE) `(OR ,LEAF-TYPE (VECTOR TREE 2)))(SETF CIRC-TREE '#(NIL NIL))(FILL CIRC-TREE CIRC-TREE)(TYPEP CIRC-TREE '(TREE INTEGER)) => {undefined}This same problem affects CLtL's definitions of LIST, TRUE-LIST, andDOTTED-LIST on pg. 28: A circular list is a LIST that is not a TRUE-LIST ora DOTTED-LIST...    PROBLEM II.  Assume that the following return non-NIL	    (SUBTYPEP 'T1 'T2)	    (SUBTYPEP 'T2 'T3)    The question is what are the subtypes of the type specifier	    (FUNCTION (T2) T2)    I think that the answer is	    (FUNCTION (T3) T1)    because the type-specific contract of an F in type (FUNCTION (T2) T2) is    to (1) accept as arguments objects in T2 and (2) return objects in T2.    Therefore, an F that accepts objects in T3 (which includes all of T2)    and returns objects in T1 (all of which are in T2) satisfies that    contract.  An F in (FUNCTION (T1) T3) does not because (1) it does not    promise to handle an object in T2-T1 and (2) may return an object in    T3-T2.  Therefore,	    (SUBTYPEP '(FUNCTION (T3) T1) '(FUNCTION (T2) T2))    ...The type specifier (FUNCTION ...) is not acceptable to TYPEP (pg. 47),therefore it is not acceptable to SUBTYPEP (pg. 72).-- Nick*start*03244 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Dec 87 16:41From: barmar%Think:COM:XeroxSubject: Re:  Types in CLIn-Reply-to: <8712172057.AA00603@Think.COM>To: jbarnett%nrtc.northrop:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re:  Types in CLTo: Jeff Barnett <jbarnett@nrtc.northrop.com>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <8712172057.AA00603@Think.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 16:41:59 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 17 Dec 87  16:03:40 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 17 Dec 87 19:03:09 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 17 Dec 87 19:03:05 ESTOriginal-Date: Thu, 17 Dec 87 19:04 ESTMessage-Id: <871217190451.6.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date:     Thu, 17 Dec 87 12:56:57 PST    From: Jeff Barnett <jbarnett@nrtc.northrop.com>    Your claim that the compiler should inhibit (SETF (AREF A 0) A) is only valid     if A is declared of type T1.  I never said anything about the compiler inhibiting the SETF.  I saidthat it is incorrect to do the SETF.  However, you are correct that Iwas wrong; you didn't show the MAKE-ARRAY form, and I assumed A wascreated with	(setq a (make-array 1 :element-type 't2))				  It may not be.  What you are pointing out is    that there is a problem if one tries to determine the type of an object (or    its type membership status) *after* the object is created.Actually, there is a bug in your original message, in the TYPEP call.The predicate	(TYPEP A 'T1)expands to	(TYPEP A '(ARRAY T2 1))which is equivalent to	(AND (ARRAYP A)	     (EQ (ARRAY-ELEMENT-TYPE A) 'T2)	     (= (ARRAY-RANK A) 1)	     (= (ARRAY-DIMENSION A 0) 1))Note that it never does an AREF, so the question of whether (AREF A 0)is of type T2 never comes up.  When array types are used in TYPEP, theelement type does not refer to the current contents, but to the array'simplementation type.In order to create the type anomaly you describe, you must use theSATISFIES type specifier, e.g.(DEFUN T1P (A)  (AND (ARRAYP A)       (= (ARRAY-RANK A) 1)       (= (ARRAY-DIMENSION A 0) 1)       (TYPEP (AREF A 0) 'T2)))(DEFTYPE T1 () '(SATISFIES T1P))When you do this, (TYPEP A 'T1) is guaranteed to infinitely recurse.Because Lisp's type system permits arbitrary code to be incorporated,the type system is Turing-equivalent, which means that the haltingproblem exists.  Without SATISFIES, though, the problem you describedoesn't exist, because none of the other type specifiers require doing aTYPEP of constituents of the object being tested (actually, I think(TYPEP A '(COMPLEX <type>)) is an abbreviation for	(AND (COMPLEXP A)	     (TYPEP (REALPART A) '<type>)	     (TYPEP (IMAGPART A) '<type>))but no recursion can occur because the parts of a complex number cannotbe complex).                                                barmar*start*02331 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Dec 87 17:06From: barmar%Think:COM:XeroxSubject: Types in CLIn-Reply-to: <19871217224647.3.MOON@EUPHRATES.SCRC.Symbolics.COM>To: Moon%stony-brook.scrc.symbolics:COM:Xeroxcc: jbarnett%nrtc.northrop:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Types in CLTo: David A. Moon <Moon@stony-brook.scrc.symbolics.com>Cc: Jeff Barnett <jbarnett@nrtc.northrop.com>, common-lisp@sail.stanford.eduIn-Reply-To: <19871217224647.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 17:06:54 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 17 Dec 87  16:34:46 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 17 Dec 87 19:34:15 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 17 Dec 87 19:34:11 ESTOriginal-Date: Thu, 17 Dec 87 19:35 ESTMessage-Id: <871217193557.7.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 17 Dec 87 17:46 EST    From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>    This is probably all a digression from your real point.  Since DEFTYPE    can do anything, especially in connection with SATISFIES, it is certainly    possible to create logically inconsistent type specifications, even though    the particular example you gave is not actually one.Ah, yes, I just did(deftype random-type () `(member ,(random 10)))In this case, even		   (and (typep x 'random-type)			(typep x 'random-type))can be false, and you can go crazy trying to call a function defined(defun random-function (x)  (check-type x random-type)  ...)By the way, this shows that I was wrong in my last message, when I saidthat recursion isn't possible unless SATISFIES is used.  All you need todo is(deftype int-greater-than (n)  (labels ((rest (n) (cons n (rest (1+ n)))))    `(member .,(rest (1+ n)))))Conceptually, the type specifier (int-greater-than N) is equivalent to(integer (N) *), but it'll never work with TYPEP.                                                barmar*start*35427 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 JUN 88 02:27:10 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 10 Jun 88  02:22:51 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 10 JUN 88 02:20:50 PDTDate: 10 Jun 88 02:20 PDTFrom: Masinter.paSubject: Issue: FUNCTION-ARGUMENT-TYPE-SEMANTICS]To: cl-cleanup@sail.stanford.eduMessage-ID: <880610-022050-6259@Xerox>Here is a (fairly random) subset of the mail text on this issue. This is partlyto jog your memory.A careful reading of CLtL p. 47 suggests, at least to some folks, that (proclaim'(function my-function (integer))) does *not* imply that it is an error to passa non-integer to my-function. I've enclosed most of the relevant mail on thesubject. My inclination is to specify in the standard that such declarationsmean what (apparently) almost everyone has taken them to mean, rather than whatCLtL says.What does(declare (function my-cons (float string) list) )mean? It says that my-cons is a function that can "accept a floating-pointnumber and a string (among other things), and its result is an object of typelist...."The problem is that the argument type declaration here is of absolutely no use.That the declared function can accept a float and a string among other thingshas no content. It doesn't say that it is illegal to pass a non-float as thefirst argument. It says that if you pass a float, its ok, and if you pass anon-float, it might be OK too. Isn't that the same as saying (function my-cons(t t) list)? It would be more valuable as far as I can see to say that a (function (floatstring) list) is one to which *only* a float and a string can be passed. Perhapssomeone familiar with an implementation that pays attention to thesedeclarations can explain what they are used to denote? 2) On the specific issue at hand: I'm inclined to be more sympathetic toallowing &REST <element-type>; function type specifiers are, after all, alreadya specialized little language -- the &KEY arguments have a separate syntax whichonly vaguely resembles the original lambda list syntax, for example. 3) Should the function type specifier also allow &ALLOW-OTHER-KEYS? Here is some (old) mail from the Common Lisp mailing list which touches on somerelated issues:!Date: 18 Apr 1986 16:07-ESTSubject: Type Specifier: (OR (FUNCTION ...) ...)From: NGALL@G.BBN.COMQuestion: What is the 'most informative' type specifier for the CL functionCOPY-SEQ?How 'bout? (function (sequence) sequence)Unfortunately, this does not tell the reader nor the compiler that if theargument is a list, then the result is also a list, and vice versa.  So howabout this:(or (function (list) list)    (function (vector) vector))This is syntactically valid CL, and the definition of the OR and FUNCTION typespecifiers makes it meaningful.  Unfortunately, it is not clear from pg. 158whether or not the following is legal:(proclaim '(ftype (or (function (list) list)                      (function (vector) vector))                  copy-seq))It is not legal in VaxLisp, and my guess is that there aren't anyimplementations that would do the right thing with it. So I would like topropose that such a use of OR/FUNCTION be considered legal CL.Without such a declaration, one is forced to either wrap (the <result-type> ...)around all calls to such functions or to DECLARE a restricted version ofFUNCTION in the appropriate places, e.g., (defun foo (alist avector)  (declare (list alist)           (vector avector)           (function copy-seq (list) list))  (zap (copy-seq alist)  (let ()    (declare (function copy-seq (vector) vector))    (zoop (copy-seq avector))))Either method is a real pain.This use of OR would give CL something akin to Ada overloading.  It allows theoverloading of multiple 'function type signatures' on a single function name.Such overloading is already implicit throughout CL (esp. the seq. functions).My proposal would merely allow a way of describing it.	-- Nick!Date: Mon, 4 Nov 85 22:29 ESTFrom: Daniel L. Weinreb <DLW@SCRC-QUABBIN.ARPA>Subject: Declaring FunctionsTo: shebs%utah-orion@UTAH-CS.ARPA, common-lisp@SU-AI.ARPAMessage-ID: <851104222904.2.DLW@CHICOPEE.SCRC.Symbolics.COM>In-Reply-To: <8511012045.AA07112@utah-orion.ARPA>    Date: Fri, 1 Nov 85 13:45:55 MST    From: shebs%utah-orion@utah-cs.arpa (Stanley Shebs)    The notion of a function type is mentioned in two places: p. 47 of the    CLM, where the (function ...) type specifier is defined, and p. 158-159,    where (ftype ...) and (function ...) are defined as options to declare.    Are they intended to be the same?  Read page 159 more carefully.  It explains that they have the same meaning, butare syntactically different.  "function" has the disadvantage that you can onlydeclare one thing per clause, unlike most other declarations, but the advantagethat it looks mildly like "defun".				       				       If so, then the second definition    should say that keywords and a (values ...) type specifier are allowed.If by keywords you mean &optional and friends, it isn't strictly necessary torepeat that, although it would sure clear things up if there were a crossreference in the book.However, there appears to be a typo on page 159.  The form following the phrase"entirely equivalent to", which currently reads (ftype (function arglist result-type1 result-type2 ...) name)ought to read  (ftype (function arglist (values result-type1 result-type2 ...)) name)in order to be consistent with page 47.     ----- Next Message -----Date: Wed, 2 Dec 87 21:42:47 PSTFrom: Pavel.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: <871202-204108-1072@Xerox>To: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-214253-1099@Xerox>Larry says:``I don't know what  (declare (function my-cons (float string) list) ) means.''It is usual in type theory for this to be read as an implication:	IF	   you pass a float and a string to MY-CONS	THEN	   MY-CONS is guaranteed to return a list.More rigorously, a type theorist would see (function my-cons (float string)list) as representing the set of all functions that, when applied to a float anda string, return a list.Under this view of types, we understand the constructor OR to be set-union (thatis, the type (OR t1 t2) represents the set of values in the union of the setsrepresented by t1 and t2) and the AND constructor is thus set intersection.Under this view, Nick Gall gives the wrong answer to his question about aspecific type for COPY-SEQ when he claims that a good one would be(or (function (list) list)    (function (vector) vector))Since this does not guarantee that COPY-SEQ will return a list when applied to alist; in fact, a function in this type might very well bomb when presented witha list.  In general, ORing function types isn't very helpful.  What he reallywants here is AND, not OR:(and (function (list) list)     (function (vector) vector))This represents the set of functions that both map lists to lists and vectors tovectors.Let me point out that I'm not claiming that this is how CLtL intends functiontypes to be interpreted, just that this meaning has proven very convenient formost uses.	Pavel     ----- Next Message -----Date: Wed, 2 Dec 87 22:36:17 PSTFrom: Pavel.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: <871202-222029-1111@Xerox>To: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871202-223623-1122@Xerox>That's right.  Unless you know something about the types of the arguments, youcan assume nothing about the type of the result.	Pavel     ----- Next Message -----Date: Thu, 3 Dec 87 16:30 ESTMessage-ID: <RAM.12355605918.BABYL@>From: Ram@C.CS.CMU.EDUTo: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>, cl-cleanup@SAIL.STANFORD.EDU,Masinter.pa, sandra%orion@CS.UTAH.EDUSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Msg of 3 Dec 1987  12:52-EST from Kent M Pitman <KMP atSTONY-BROOK.SCRC.Symbolics.COM>My compiler cleanup proposal addresses a number of the issues beingdiscussed here.  We already went around once on cl-cleanup about themeaning function type.In my initial proposal, I had assumed a strict interpretation offunction type.  It was pointed out to me, that not only is CLTL veryclear about its non-restrictive interpretation, it is also verydifficult to use a strict interpretation within the framework of thecurrent type system.Basically, the problem is that if you think about "function typedeclarations" as being declarations about the type of the object whichis the function, then it isn't possible to use a strictinterpretation.  If you attempt to do so, then there will be caseswhere a type declaration is necessary for a program to be correct, andremoving declarations can cause a program to be incorrect.  Inaddition to problems with defining where declarations are necessary,requiring declarations is also clearly in conflict with the statedgoals for declarations in Common Lisp.Basically, the reason for this non-intuitive result is that adeclaration of a function's type actually makes a statement about whatdefinitions are legal, rather than what calls are legal.  What acompiler really wants to know is what calls are legal.The solution I suggest in my proposal is to introduce a mechanism thatallows arbitrary information about a function definition to be boundat compile time.  You don't declare the function type, you just definethe function, with any appropriate argument type declarations.Since you have asserted that calls to the function can be bound atcompile time, the compiler can apply any assertions on the formalparameters to the actual parameters and use type information derivedfrom the definition as the type of the call result.Early-binding of function names also allows many other optimizationssuch as "inline expansion" and "block compilation".Before people flame uncotrollably about the horror of static functionbinding in Lisp, I will point out that I don't propose that staticfunction binding be required, or even that it necessarily be thedefault.  It is also worth noting that the extent to which staticbinding is actually done once it has been allowed is an implementationdecision.  Declaring static binding doesn't necessarily preventincremental redefintion or reduce safety, it might only cause bettercompiler warnings to be generated.If this capability exists, then function type declarations (andfunction types) are more useless than they currently are (if that iseven possible).  RobP.S.  My proposal is <ram>cprop.txt on c.cs.cmu.edu     ----- Next Message -----Date:  7 Dec 87 14:40 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Ram@C.CS.CMU.EDU's message of Thu, 3 Dec 87 16:30 ESTTo: Ram@C.CS.CMU.EDUcc: KMP@SCRC-STONY-BROOK.ARPA, cl-cleanup@SAIL.STANFORD.EDU, Masinter.pa,sandra%orion@CS.UTAH.EDURam: I've scanned your latest proposal, but it still doesn't seem to address theminor issue at hand here:What does (declare (function (integer integer) t) foo)  imply? We've discussed what it could mean, what it should mean, what CLtL says itmeans, but I'd to hear about current practice. What, if anything,  do currentimplementations do with such declarations? Do any implementations pay attentionto the types of arguments in function declarations?      ----- Next Message -----Date: Thu, 3 Dec 87 12:52 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Masinter.pacc: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUIn-Reply-To: <871202-204108-1072@Xerox>Message-ID: <871203125256.0.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 2 Dec 87 20:40 PST    From: Masinter.pa@Xerox.COM    ...    (declare (function my-cons (float string) list) )    ...    The problem is that the argument type declaration here is of absolutely    no use.    ...    It would be more valuable as far as I can see to say that a    (function (float string) list)    is one to which *only* a float and a string can be passed. Perhaps    someone familiar with an implementation that pays attention to these    declarations can explain what they are used to denote? In Maclisp, if you declared a function to take arguments (fixnum flonum),for example, special tricks were allowed to be done with passing the argumentswithout having to heap-cons them. You were required to only use this declarationif you had made it available to the compiler at the time of compiling thefunction(so that it would have done the special tricks necessary to make the externalcalling sequence work). The net effect was that the function had a naive entrypoint (for people who didn't know about the declaration) and a magic entry pointfor people who wanted to exploit the declaration information and bypass somesetup instructions.In order to get this effect in CL, we have only to restrict the declaration ofa function to be exactly the declaration that the function was compiled under.That is, there are a number of possible universes we could elect to be in: * We could allow local function declarations to just say things we know to   be true, regardless of whether they were interesting. eg,      (PROCLAIM '(FUNCTION FOO (INTEGER) INTEGER))      (DEFUN FOO (X) (+ X 1))   could be matched in another file by      (LOCALLY (DECLARE (FUNCTION FOO (INTEGER) INTEGER)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM) FIXNUM)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (T) T)) ... (FOO ...) ...)   This would tend to thwart interesting compilations because nothing in the   declaration would tell you anything useful about how the function wascompiled. * We could allow local function declarations only if they restrict the   declaration under which the function was compiled. eg,      (PROCLAIM '(FUNCTION FOO (INTEGER) INTEGER))      (DEFUN FOO (X) (+ X 1))   could be matched in another file by      (LOCALLY (DECLARE (FUNCTION FOO (INTEGER) INTEGER)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM) FIXNUM)) ... (FOO ...) ...)   but not by      (LOCALLY (DECLARE (FUNCTION FOO (T) T)) ... (FOO ...) ...)   This might thwart some interesting compilations because you wouldn't know    everything about the way the function was compiled, but you'd know some   information. * We could allow local function declarations only if they exactly match   the declaration under which the function was compiled. eg,      (PROCLAIM '(FUNCTION FOO (INTEGER) INTEGER))      (DEFUN FOO (X) (+ X 1))   could be matched in another file by      (LOCALLY (DECLARE (FUNCTION FOO (INTEGER) INTEGER)) ... (FOO ...) ...)   but not by      (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM) FIXNUM)) ... (FOO ...) ...)   or (LOCALLY (DECLARE (FUNCTION FOO (T) T)) ... (FOO ...) ...)   This would have the best chance of getting interesting compilations, I think. * We could, as I guess Pavel is suggesting (though I lost or missed the   original mail), allow multiple declarations of the same function, in which   case the information provided would be of an entirely different nature (in   what amounts to a DEFMETHOD style) than what it's used for in the previous   three bullet items.   Presumably there are some gains to be had from this style. I have no feel for   how useful they are. An example, though, would be:      (PROCLAIM '(FUNCTION FOO (LIST) LIST))      (PROCLAIM '(FUNCTION FOO (VECTOR) VECTOR))   which would let you compile      (LENGTH (FOO (THE LIST L)))   into      (SYSTEM:LENGTH-ROUTINE-FOR-THINGS-KNOWN-TO-BE-OF-TYPE-LIST (FOO L))   [Sigh. I'd have called it SYSTEM:LIST-LENGTH, but that's taken by CLtL for    something that doesn't mean what I think of as LIST-LENGTH. A poor naming    decision if you ask me...] * This is a placeholder to remind readers that the likelihood that this list is   exhaustive is fairly low.This really gets at the heart of the problem, which is: * Are declarations just for compilation or do they serve some more abstract   higher level goal (eg, "documentation"). * How important is exact-typep information vs typep information. * How much of a modularity violation (or documentation constraint) is it to   have to know the exact conditions under which a function was compiled. * How important are optimal compilations?     ----- Next Message -----Date: Thu, 3 Dec 87 11:57:05 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8712031857.AA21459@orion.utah.edu>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>Cc: Masinter.pa, cl-cleanup@sail.stanford.edu, sandra%orion@cs.utah.eduIn-Reply-To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Thu, 3 Dec 8712:52 ESTOne reason for wanting to use a FUNCTION type specifier is that you mayonly be concerned with how many arguments a function can take, and youdon't care at all about their types.  Back when we were trying toimplement a CL compatibility package in PSL, we wanted to do thematching of actual arguments to lambda variables at compile-time so wecould use the EXPR call protocol instead of the much slower NEXPRprotocol.  (Basically, we had an EXPR entry point for every functionwith a 1-1 correspondence between actual arguments and lambdavariables.)  The problem is, you couldn't do the transformation on acall unless you already knew something about the lambda list for thefunction.I agree that the argument type business is confusing and not very usefulin its current state.  I'd like to say that    (LOCALLY (DECLARE (FTYPE (FUNCTION (INTEGER INTEGER) INTEGER) +))        (+ X Y))is equivalent to    (THE INTEGER (+ (THE INTEGER X) (THE INTEGER Y)))but I'm not sure that's exactly what CLtL is getting at.-Sandra-------     ----- Next Message -----Date: 03 Dec 87 11:23 PSTFrom: Dick Gabriel <RPG@SAIL.Stanford.EDU>Subject: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issues To: cl-cleanup@SAIL.Stanford.EDU I'd like to reiterate what Pavel said: the declaration(declare (function my-cons (float string) list) )means that the function MY-CONS accepts two arguments, the first at leastof the type FLOAT (it can be a more general type), and the second at leastof the type STRING; it returns one value which is of the type LIST (itcould be more specific).Unfortunately, it does not mean that if the two arguments are of typesFLOAT and STRING then the result is of type LIST, which would beuseful.Lucid has a variant of this called RESTRICTIVE-FTYPE (or something),which would mean MY-CONS assumes it receives two arguments of typesFLOAT and STRING and produces something of type LIST.See page 47 (CLtL), the last complete paragraph, to see this.			-rpg-     ----- Next Message -----Date: Thu, 3 Dec 87 14:17 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: sandra%orion@cs.utah.educc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Masinter.pa,cl-cleanup@sail.stanford.eduIn-Reply-To: <8712031857.AA21459@orion.utah.edu>Message-ID: <871203141725.5.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Thu, 3 Dec 87 11:57:05 MST    From: sandra%orion@cs.utah.edu (Sandra J Loosemore)    One reason for wanting to use a FUNCTION type specifier is that you may    only be concerned with how many arguments a function can take, and you    don't care at all about their types. ...Thanks for remembering to mention this issue. It pops into my head from time totimeand then I always forget it before I get to the console.Yes, the same style of issues as I raised in my last message applies to argumentnumber. eg, if I did (PROCLAIM '(FUNCTION FOO (NUMBER NUMBER) NUMBER)) (DEFUN FOO (X Y) (+ X Y)) and later did: (LOCALLY (DECLARE (FUNCTION FOO (FIXNUM &REST (LIST T)) FIXNUM)) ... (FOO ...)...)would I be within reason? ie, is there semantic impact to the &REST which goesbeyondtype declaring the rest of the arguments to be of type T? Am I also declaringthat thefunction was in fact compiled believing that a &REST style argument pickup wasused(and at the same point as I've specified it here). What about: (PROCLAIM '(FUNCTION FOO (NUMBER &REST (LIST NUMBER)) NUMBER)) (DEFUN FOO (X &REST Y) (APPLY #'+ X Y)) and then later (LOCALLY (DECLARE (FUNCTION FOO (NUMBER NUMBER &REST (LIST NUMBER)) NUMBER))   ... (FOO ...at least two arguments...) ...)In my CL conversion of Macsyma, I threw out all the *LEXPR declarations becauseCL couldn't make any use of them and they were just clutter. (And they'd betrivialto re-conjure if they were ever needed.) But I felt funny as I did it because Ididknow I was throwing away information that would be interesting to some compilersand that seemed sad, so I definitely agree that one way or another, this is arealissue.     ----- Next Message -----Date: 9 Dec 87 02:59 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Ram@C.CS.CMU.EDU's message of Tue, 8 Dec 87 14:21 ESTTo: Ram@C.CS.CMU.EDUcc: cl-cleanup@SAIL.STANFORD.EDU, sandra%orion@CS.UTAH.EDUMessage-ID: <871209-030006-1558@Xerox>I think I understand and agree with most of what you say, in particular "I thinkthat we should either entirely flush the concept of "function types" or changethe theory behind them.  The CLtL interpretation is well-defined, but not veryuseful. " There are two components to your proposal: (1) what is allowed (and what itmeans), and (2) how it is described in the standard.I like the part of your proposal which is to change the interpretation offunction declarations to mean an implicit assertion of argument and value types(the "restrictive interpretation"). I like defining  (declare (type (function (frob grid) bunker) x)) to mean (funcall x y z) has implicitly means  (the bunker (funcall (the function x)(the frob y) (the grid z)))I don't see, however, that there is much leverage to removing FUNCTION from thesection on type specifiers. It would do some violence to the otherwise usefulconcept of (deftype binary-arithmetic () '(function (number number) number))to be used in(declare (ftype binary-arithmetic x y z)) .I don't see at all that (funcall #'foo x y) doesn't mean (the t (funcall #'foo(the integer x) (the integer y)))) given (declare (function foo (integerinteger) t)). In the type propagation rules, you can transform funcall and apply expressionsusing the asserted value of the function argument, and the asserted value typeof #'name is derived from the asserted ftype of name. In this interpretation, AND would distribute nicely, Given (proclaim '(function foo (s1 t1) v1)) and (declare (function foo (s2 t2)v2)) you could assert that(foo x y) => (the (and v1 v2) (foo (the (and s1 s2) x) (the (and t1 t2) y))).(OR doesn't distribute as nicely, e.g., given (declare (ftype (or (function (s1t1) v1) (function (s2 t2) v2)) foo)),  there isn't a simple way to describe thetype assertions made for (foo x y).  We might even want to explicitly allow FUNCTION declarations in THEexpressions, as in(funcall (the binary-arithmetic x)  y z).     ----- Next Message -----Date: Tue, 8 Dec 87 14:21 ESTMessage-ID: <RAM.12356893261.BABYL@>From: Ram@C.CS.CMU.EDUTo: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDU, KMP@SCRC-STONY-BROOK.ARPA,sandra%orion@CS.UTAH.EDUSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: Msg of 7 Dec 1987  17:40-EST from Masinter.pa at Xerox.COM    Date: Monday, 7 December 1987  17:40-EST    From: Masinter.pa at Xerox.COM    To:   Ram at C.CS.CMU.EDU    cc:   KMP at SCRC-STONY-BROOK.ARPA, cl-cleanup at SAIL.STANFORD.EDU,	  Masinter.pa at Xerox.COM, sandra%orion at CS.UTAH.EDU    Re:   Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issues    [...] What does (declare (function (integer integer) t) foo) imply?    We've discussed what it could mean, what it should mean, what CLtL    says it means, but I'd to hear about current practice. What, if    anything, do current implementations do with such declarations? Do    any implementations pay attention to the types of arguments in    function declarations?Our current compiler totally ignores function type declarations.I am working on a new compiler that currently gives function typedeclarations a strict interpretation, i.e. the function must be calledonly with two integer arguments.  (I suspect that this is like theRESTRICTIVE-FTYPE declarations that someone from Lucid mentioned.)  Atleast as an interpretation for FTYPE, this is clearly wrong.  I intendto at least rename this declaration, and perhaps entirely flush it asa user-visible facility.I think that we should either entirely flush the concept of "functiontypes" or change the theory behind them.  The CLtL interpretation iswell-defined, but not very useful.  The intuitive strictinterpretation is useful, but is not a type declaration, at least inthe sense used in CLtL.The restrictive interpretation can be modeled as a sort of magicsyntactic shorthand for a bunch of THE declarations at the call site:    (the t (foo (the integer x) (the integer y)))But under this interpretation, a "function type" isn't a type at all,since it isn't in any sense the type of the function object beingcalled.  It wouldn't be meaningful to declare a variable or value tohave a function type.  A "function type declaration" would be a pieceof magic recognized by the implementation that constrains calls to aparticular function variable.If we did this, then the concept of a "function type specifier" shouldbe flushed, since "function types" can't be used in any of the waysreal types can.  The "function type" syntax would become part of thesyntax peculiar to a "function type declaration".  (A minor beneficialside-effect is that it would make obvious the restriction on functiontypes in TYPEP.)One problem that I have with this interpretation is that it makes theevaluation of the functional position even more peculiar than italready is.  Since a "function type declaration" would be purelysyntactic, it would only take effect when there was a syntactic match,i.e. an obvious normal call to a declared function variable.  It wouldprobably be incorrect to do this transformation:    (funcall #'foo x y)  ==>    (the t (funcall #'foo (the integer x) (the integer y))))  Rob     ----- Next Message -----Date: Wed, 9 Dec 87 08:00:48 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8712091500.AA16131@orion.utah.edu>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Masinter.paCc: Ram@c.cs.cmu.edu, cl-cleanup@sail.stanford.edu, sandra%orion@cs.utah.eduIn-Reply-To: Masinter.pa@Xerox.COM, 9 Dec 87 02:59 PST  Date: 9 Dec 87 02:59 PST  From: Masinter.pa@Xerox.COM  Given (proclaim '(function foo (s1 t1) v1)) and (declare (function foo (s2 t2)  v2)) you could assert that  (foo x y) => (the (and v1 v2) (foo (the (and s1 s2) x) (the (and t1 t2) y))).I disagree.  The DECLARE should shadow the PROCLAIM; see p. 156 ofCLtL.  Or is there another proposal in the works to change declarationshadowing as well?  :-)-Sandra-------From: masinter.PADate: 16-Dec-87  1:32:02 PSTSubject: Current practice:argument types in function declarationsTo: common-lisp@sail.stanford.educc: masinterThe cleanup committee is considering various issues surrounding functiondeclarations, and, in particular, declarations of the types of arguments.We've had considerable input about what such declarations could mean, shouldmean, what CLtL says they mean. Rather than going over all of that, this is aquestion about current practice: What do current implementations actually do? What do current users actually usehave in their programs?Is anyone aware of any (released? supported?) Common Lisp implementation thatpays any attention at all to the types of arguments, e.g., for which(proclaim '(function my-function (list vector) t))has any effect different from(proclaim '(function my-function (t t) t))?Does anyone *have* any Common Lisp code which contains such declarations? Whatis the intent of the declarations, other than as documentation?-----------Date: Wed, 16 Dec 87 06:50:49 PSTMessage-Id: <8712161450.AA12099@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: masinter.PA, VANROGGEN@decwrl.dec.comSubject: RE: Current practice:argument types in function declarationsVAX LISP certainly does heed such proclamations when compiling callsto the declared functions.  And we do have such code in our system.			---Walter-----------------------Date: 16 Dec 87 12:42 PSTFrom: Masinter.paSubject: RE: Current practice:argument types in function declarationsIn-reply-to: vanroggen%aitg.DEC@decwrl.dec.com's message of Wed, 16 Dec 8706:50:49 PSTTo: vanroggen%aitg.DEC@decwrl.dec.comcc: masinter.PASigh, I don't have a VAX LISP manual. In what way does it "heed suchproclaimations"? For example, does VAX LISP assume that, given(proclaim '(function my-function (integer symbol) t))that it is an error to call(my-function 'a-symbol 3)?-----------------------Date: Wed, 16 Dec 87 13:02:06 PSTMessage-Id: <8712162102.AA07759@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: Masinter.pa, VANROGGEN@decwrl.dec.comSubject: RE: Current practice:argument types in function declarationsThat's right--your example would be in error. ...-----------------------Date: Wed, 16 Dec 87 13:11 estFrom: mike%acorn@LIVE-OAK.LCS.MIT.EDUTo: masinter.PASubject: Current practice:argument types in function declarationsCc: common-lisp@sail.stanford.edu    From: masinter.PA@Xerox.COM    Date: 16 Dec 87 1:32:02 PST    >Is anyone aware of any (released? supported?) Common Lisp implementation that>pays any attention at all to the types of arguments, e.g., for which>    (proclaim '(function my-function (list vector) t))>has any effect different from>    (proclaim '(function my-function (t t) t))>    ?>Does anyone *have* any Common Lisp code which contains such declarations?>What is the intent of the declarations, other than as documentation?First off, either signature tells you more than nothing at all, sinceit fixes the number of arguments. Presumably, you have to checkthe number of arguments as well as the types for really safe calls.As for use, we are not using them currently, but plan to use them.The goal is to generate "safe" calls for functions when compiling ifthe type signature is unknown. If the type signature is known;however, the checking burden is placed on the caller (and can beminimized via type inference, etc.) and an unsafe call is generated.The type signature can be known either via block compilation, orby using function type proclamations. In any case if you ftype a functionand a call can be shown to contradict the proclamation, then youshould get a warning and a safe (slow) call.The one difficulty with these things is that common lisp's typelanguage doesn't allow you to specify accurate types for things like <. E.G.,(proclaim '(ftype < (function (&rest ??) (or T nil))))For ?? you'd like to say "zero or more non-complex numbers". You do NOT want to say LIST here.I am considering defining a (list-of ...) type specifier.where the argument is a type. This cannot really be written in common lisp, since it doesn't allow parameterized types in general.But we as implementors can put it in place as an extension.Mike BeckerleGold Hill Computers.----------------------Date: Wed, 16 Dec 87 18:13:25 GMTMessage-Id: <561.8712161813@csuna.cvaxa.sussex.ac.uk>To: "masinter.PA" <@NSS.Cs.Ucl.AC.UK,@cvaxa.sussex.ac.uk:masinter.PA@xerox.com>Subject: Re:  Current practice:argument types in function declarationsPOPLOG Common Lisp (POPLOG is a UK AI development environment) willrecognise function declarations in the next release, but only becauseit is interested in knowing how many arguments and results a functiontakes (especially the number of results). John Williams (johnw@uk.ac.sussex.cvaxa)----------------------From: Brad Miller <miller@ACORN.CS.ROCHESTER.EDU>Subject: Re: Current practice:argument types in function declarationsOriginal-Date: Thu, 17 Dec 87 03:05 ESTOrganization: University of Rochester, Department of Computer SciencePostal-address: 401A CS Building, Computer Science Department, University ofRochester, Rochester NY 14627Phone: 716-275-1118    Date: 16 Dec 87 1:32:02 PST    From: masinter.PA@Xerox.COM    Does anyone *have* any Common Lisp code which contains such declarations?What    is the intent of the declarations, other than as documentation?All the code I write has such delcarations, including for the types of allreturned values. The immediate purpose is documentation since it's ignored onthe machine I happen to work on (a symbolics) but it's my hope that in futurethe compiler/interpreter would complain about calls to the function that passthe wrong type of argument at compile time, if it can tell. (runtime woulddepend on OPTIMIZE SAFETY or some such, and probably local declarations insidethe defun or whatever). Also, it could be used as a note to the debugger, since it could flag that anargument was of an unexpected type if some other problem arises and it getsinvoked. (this would help track down the error).But I'm a user, not an implementor: this is just what I hope to eventually getout of it. As I said, right now it's just documentation so the next guy knowswhat I expected the function to handle when I wrote it.Brad Miller------miller@cs.rochester.edu {...allegra!rochester!miller}Brad MillerUniversity of Rochester Computer Science Department----------------------From: <samalone@ATHENA.MIT.EDU>Subject: Re: Current practice:argument types in function declarationsDate: Fri, 18 Dec 87 09:29:12 ESTYes, I often proclaim functions to take arguments of specific types. Usually this happens when I want to proclaim the return value of afunction and my sense of taste insists that I proclaim the types of thearguments as well.  However, none of the implementations I've used seemto do much with the information.There is one time when proclaiming the types of arguments to a function is obviously useful: when compiling the function itself.  True, one coulduse declarations inside of the function to achive the same result, butusing a proclamation keeps all of the function's type specification in oneplace.Without repeating them, I'd also like to voice my support of thecomments made by Mike Bekerle and Brad Miller.				--Stuart A. Malone*start*01154 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 18:25:34 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Sep 88  18:25:18 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 455935; Wed 7-Sep-88 21:23:24 EDTDate: Wed, 7 Sep 88 21:23 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSTo: vanroggen%aitg.DEC@decwrl.dec.comcc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8809071925.AA03511@decwrl.dec.com>Message-ID: <19880908012301.0.MOON@EUPHRATES.SCRC.Symbolics.COM>FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE sounds good to me.I have a small wording problem with it: I can't figure out what ifanything your proposal says about use of the FUNCTION type specifierfor discrimination.  The problem description and conversion costsections sound as if you're proposing something, but the proposalsection doesn't mention it.*start*04819 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 12:28:34 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 7 Sep 88  12:26:25 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA03511; Wed, 7 Sep 88 12:25:14 PDTDate: Wed, 7 Sep 88 12:25:14 PDTMessage-Id: <8809071925.AA03511@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSIssue:        FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSReferences:   CLtL pp 47-48, 158-159Category:     CHANGEEdit history: #1, 7 September 1988, Walter van RoggenProblem description:The current description of the specialized FUNCTION type specifier is not veryuseful to program analysis tools and is not very intuitive to programmersbecause the meaning of the argument type specifiers is not restrictive.Programmers find it useful to add information about the types of the argumentsa function expects and about the type(s) that a function may return. Thisinformation is useful both to human readers of the code as well as to typechecking programs such as compilers and cross referencers. The only apparent(but false) way of providing this information is with the FTYPE declaration andFUNCTION type specifier.Furthermore, implementations may wish to provide additional optimizations basedon avoiding type checking or different methods of argument passing. Theseoptimizations require the same sort of information about the argument types.However, the current definition of FUNCTION type specifiers on pages 47-48 ofCLtL states that a function such as CONS that is of type  (FUNCTION (T T) CONS)is also of type  (FUNCTION (FLOAT STRING) LIST).Unfortunately this information is not useful for the above mentioned purposes.The problem is that the argument types aren't restrictive, so no interestingmatching of types is possible.Another way of looking at the problem is that specialized FUNCTION typespecifiers cannot be used in a meaningful way for discrimination (as the secondarg to TYPEP, nor as the first argument to THE). Furthermore functions areassumed not to be sufficiently self-descriptive that a specialized FUNCTIONtype is possible to be known or can be constructed when a function is passed toTYPE-OF.Unlike all the other type declarations, which can be used for discriminationand have an implicit effect on representation, specialized FUNCTION typespecifiers thus appear to have superfluous information.  By changing themeaning of the argument types to convey additional descriptive informationinstead of behavioral information, we can also satisfy the other needs listedabove.This issue does not address the use of lambda-list-keywords andargument count matching, nor the reproclamation or additional declarationof FUNCTION types, nor having TYPEP treat specialized FUNCTION typesas if they were just the same as the atomic FUNCTION type for purposesof discrimination.Proposal (FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE)For specialized FUNCTION type specifiers  (proclaim '(ftype (function (arg0-type arg1-type ...) val-type) f))implies  (the val-type (f (the arg0-type ...) (the arg1-type ...) ...))If the arguments to F are of the specified types, then the result will be ofthe specified type.  If the arguments do not all match the specified types, itis an error, and then the result is not guaranteed to be of the specified type.Rationale:The proposal seems most like what users expect.Current Practice:VAX LISP already assumes and makes use of the "restrictive" semantics. Lucidhas a RESTRICTIVE-FTYPE declaration with these semantics and ignores thestandard FTYPE declaration. Gold Hill intends to use these declarations in thismanner.  Many implementations don't make use of these declarations.  At leastseveral users make use of declarations assuming the new semantics.Adoption Cost:None, since making use of FUNCTION declarations is "optional".Benefits:Better type checking and more compiler optimizations should be possible.Conversion Cost:There may be some existing "imprecise" function declarations. However, thenatural tendency when providing these declarations is to be as "descriptive"(i.e., restrictive but complete) as possible, both for documentation purposesas well as for potential compiler benefits. There cannot have been any uses ofthe specialized FUNCTION type for discrimination. Thus most existing uses areprobably compatible with this new definition.Esthetics:This is the what most programmers expect the specialized FUNCTION type tomean, particularly those coming from other languages.Discussion:*start*04819 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 12:28:34 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 7 Sep 88  12:26:25 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA03511; Wed, 7 Sep 88 12:25:14 PDTDate: Wed, 7 Sep 88 12:25:14 PDTMessage-Id: <8809071925.AA03511@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSIssue:        FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSReferences:   CLtL pp 47-48, 158-159Category:     CHANGEEdit history: #1, 7 September 1988, Walter van RoggenProblem description:The current description of the specialized FUNCTION type specifier is not veryuseful to program analysis tools and is not very intuitive to programmersbecause the meaning of the argument type specifiers is not restrictive.Programmers find it useful to add information about the types of the argumentsa function expects and about the type(s) that a function may return. Thisinformation is useful both to human readers of the code as well as to typechecking programs such as compilers and cross referencers. The only apparent(but false) way of providing this information is with the FTYPE declaration andFUNCTION type specifier.Furthermore, implementations may wish to provide additional optimizations basedon avoiding type checking or different methods of argument passing. Theseoptimizations require the same sort of information about the argument types.However, the current definition of FUNCTION type specifiers on pages 47-48 ofCLtL states that a function such as CONS that is of type  (FUNCTION (T T) CONS)is also of type  (FUNCTION (FLOAT STRING) LIST).Unfortunately this information is not useful for the above mentioned purposes.The problem is that the argument types aren't restrictive, so no interestingmatching of types is possible.Another way of looking at the problem is that specialized FUNCTION typespecifiers cannot be used in a meaningful way for discrimination (as the secondarg to TYPEP, nor as the first argument to THE). Furthermore functions areassumed not to be sufficiently self-descriptive that a specialized FUNCTIONtype is possible to be known or can be constructed when a function is passed toTYPE-OF.Unlike all the other type declarations, which can be used for discriminationand have an implicit effect on representation, specialized FUNCTION typespecifiers thus appear to have superfluous information.  By changing themeaning of the argument types to convey additional descriptive informationinstead of behavioral information, we can also satisfy the other needs listedabove.This issue does not address the use of lambda-list-keywords andargument count matching, nor the reproclamation or additional declarationof FUNCTION types, nor having TYPEP treat specialized FUNCTION typesas if they were just the same as the atomic FUNCTION type for purposesof discrimination.Proposal (FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE)For specialized FUNCTION type specifiers  (proclaim '(ftype (function (arg0-type arg1-type ...) val-type) f))implies  (the val-type (f (the arg0-type ...) (the arg1-type ...) ...))If the arguments to F are of the specified types, then the result will be ofthe specified type.  If the arguments do not all match the specified types, itis an error, and then the result is not guaranteed to be of the specified type.Rationale:The proposal seems most like what users expect.Current Practice:VAX LISP already assumes and makes use of the "restrictive" semantics. Lucidhas a RESTRICTIVE-FTYPE declaration with these semantics and ignores thestandard FTYPE declaration. Gold Hill intends to use these declarations in thismanner.  Many implementations don't make use of these declarations.  At leastseveral users make use of declarations assuming the new semantics.Adoption Cost:None, since making use of FUNCTION declarations is "optional".Benefits:Better type checking and more compiler optimizations should be possible.Conversion Cost:There may be some existing "imprecise" function declarations. However, thenatural tendency when providing these declarations is to be as "descriptive"(i.e., restrictive but complete) as possible, both for documentation purposesas well as for potential compiler benefits. There cannot have been any uses ofthe specialized FUNCTION type for discrimination. Thus most existing uses areprobably compatible with this new definition.Esthetics:This is the what most programmers expect the specialized FUNCTION type tomean, particularly those coming from other languages.Discussion:*start*01668 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 22:43:14 PDTMessage-ID: <c#ClG@SAIL.Stanford.EDU>Date: 07 Sep 88 22:41 PDTFrom: Dick Gabriel <RPG@SAIL.Stanford.EDU>Subject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS  To: CL-Cleanup@SAIL.Stanford.EDU I have a minor nit to pick with the writeup for this issue. It says:``Adoption Cost:None, since making use of FUNCTION declarations is "optional".''This isn't true because for us it means hooking up the RESTRICTIVE-FTYPEmechanism to the FTYPE declaration. I object to the reasoning thatsays that because making use of something (by implementations, I presume)is optional, there is no adoption cost for any changes to it. For example,making use of any declarations but SPECIAL is optional, so any incompatiblechange to those type declarations would be a no-cost-for-adoption change.Let's say that the cost of adoption is insignificant becaue the only twoimplementations that do something with FTYPE declarations can be easilychanged to conform.An alternative worth considering is to say that  (proclaim '(ftype (function (type1 ... typen) val-type) f))means:if arg1,...,argn are of types type1,...,typen, then(f arg1 ... argn)is of type val-type.This provides a means of describing polymorphic functions andwith some added verbiage to obtain even stricter interpretation.The conditional is impossible to state in a useful way otherwise,and the polymorphic form has some use for CLOS generic functionsand also arithmetic functions.			-rpg-*start*05331 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 SEP 88 08:26:07 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 13 Sep 88  08:25:09 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA28994; Tue, 13 Sep 88 08:23:51 PDTDate: Tue, 13 Sep 88 08:23:51 PDTMessage-Id: <8809131523.AA28994@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 2)Issue:        FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSReferences:   CLtL pp 47-48, 158-159Category:     CHANGEEdit history: #1, 7 Sept 1988, Walter van Roggen	      #2, 13 Sept 1988, Walter van Roggen (costs & proposal limitations)Problem description:The current description of the specialized FUNCTION type specifier is not veryuseful to program analysis tools and is not very intuitive to programmersbecause the meaning of the argument type specifiers is not restrictive.Programmers find it useful to add information about the types of the argumentsa function expects and about the type(s) that a function may return. Thisinformation is useful both to human readers of the code as well as to typechecking programs such as compilers and cross referencers. The only apparent(but false) way of providing this information is with the FTYPE declaration andFUNCTION type specifier.Furthermore, implementations may wish to provide additional optimizations basedon avoiding type checking or different methods of argument passing. Theseoptimizations require the same sort of information about the argument types.However, the current definition of FUNCTION type specifiers on pages 47-48 ofCLtL states that a function such as CONS that is of type  (FUNCTION (T T) CONS)is also of type  (FUNCTION (FLOAT STRING) LIST).Unfortunately this information is not useful for the above mentioned purposes.The problem is that the argument types aren't restrictive, so no interestingmatching of types is possible.Another way of looking at the problem is that specialized FUNCTION typespecifiers cannot be used in a meaningful way for discrimination (as the secondarg to TYPEP, nor as the first argument to THE).  Furthermore functions areassumed not to be sufficiently self-descriptive that a specialized FUNCTIONtype is possible to be known or can be constructed when a function is passed toTYPE-OF.Thus unlike all the other type declarations, which can be used fordiscrimination and have an implicit effect on representation, specializedFUNCTION type specifiers appear to have superfluous information.  By changingthe meaning of the argument types to convey additional descriptive informationinstead of behavioral information, we can also satisfy the other needs listedabove.Proposal (FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE)For specialized FUNCTION type specifiers  (proclaim '(ftype (function (arg0-type arg1-type ...) val-type) f))implies  (the val-type (f (the arg0-type ...) (the arg1-type ...) ...))If the arguments to F are of the specified types, then the result will be ofthe specified type.  If the arguments do not all match the specified types, itis an error, and then the result is not guaranteed to be of the specified type.This proposal does not alter the status (or lack thereof) of other issuesrelated to FUNCTION type specifiers: what lambda-list keywords mean, what theVALUES type means, what implications there are w.r.t. argument counts, doingmultiple PROCLAIMs, doing local DECLAREs that shadow other declarations orproclamations, describing generic functions incrementally, the result of TYPEPwith a specialized FUNCTION type.Rationale:The proposal seems most like what users expect.Current Practice:VAX LISP already assumes and makes use of the "restrictive" semantics. Lucidhas a RESTRICTIVE-FTYPE declaration with these semantics and ignores thestandard FTYPE declaration. Gold Hill intends to use these declarations in thismanner.  Many implementations don't make use of these declarations.  At leastseveral users make use of declarations assuming the new semantics.Cost to Implementors:Since most implementations don't make use of function declarations, and sincethose known to do so can be changed easily, the cost should be minimal.Cost to Users:There may be some existing "imprecise" function declarations.  However, thenatural tendency when providing these declarations is to be as "descriptive"(i.e., restrictive but complete) as possible, both for documentation purposesas well as for potential compiler benefits. There cannot have been any uses ofthe specialized FUNCTION type for discrimination. Thus most existing uses areprobably compatible with this new definition.Cost of Non-Adoption:There already exists user code on many implementations that assume theproposed semantics.  Not adopting this proposal would continue to rendersuch code incorrect or at least non-portable.Benefits:Better type checking and more compiler optimizations should be possible.Esthetics:This is the what most programmers expect the specialized FUNCTION type tomean, particularly those coming from other languages.Discussion:*start*01868 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 15 SEP 88 12:52:38 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 15 Sep 88  12:50:27 PDTReceived: by ti.com id AA17533; Thu, 15 Sep 88 14:48:05 CDTReceived: from Kelvin by tilde id AA08191; Thu, 15 Sep 88 14:39:45 CDTMessage-Id: <2799344496-16167493@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Thu, 15 Sep 88 14:41:36 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: vanroggen%aitg.DEC@decwrl.dec.comCc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 2)In-Reply-To: Msg of Tue, 13 Sep 88 08:23:51 PDT from vanroggen%aitg.DEC@decwrl.dec.comI think that much of the confusion about function type declarations isbecause there are two aspects of the issue that have not been clearlydelimited:  1. Declarations describing the definition of a function.  2. Declarations about functions expected to be received by an argument     or variable.The proposal FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE addressesthe first case, while the discussion in CLtL seems to have primarily thesecond case in mind.  I think that the point of the comment on pages 47-48is that given   (DEFUN FFF (F)    (DECLARE (TYPE (FUNCTION (FLOAT STRING) LIST) F))    ... (FUNCALL F (FOO ...) ...) ... )then #'CONS is a valid argument to be passed to FFF because the declaredtype of the argument is consistent with type (FUNCTION (T T) CONS).Within FFF, the declaration permits us, for example, to assume that FOOreturns a FLOAT.  I don't think this contradicts anything in the proposalFUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE, but the proposal needsto be extended to address this side of the issue also.  -- David Gray*start*01310 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 16 SEP 88 16:29:48 PDTReceived: from mist.math.uoregon.edu by SAIL.Stanford.EDU with TCP; 16 Sep 88  16:29:14 PDTReceived: from fog.cs.uoregon.edu by mist.math.uoregon.edu; Fri, 16 Sep 88 16:24:53 PDTReceived: by fog.cs.uoregon.edu; Fri, 16 Sep 88 16:24:45 PDTDate: Fri, 16 Sep 88 16:24:45 PDTFrom: William Clinger <will@fog.cs.uoregon.edu>Message-Id: <8809162324.AA19754@fog.cs.uoregon.edu>To: Gray@DSG.csc.ti.com, vanroggen%aitg.DEC@decwrl.dec.comSubject: Re: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 2)Cc: CL-Cleanup@SAIL.STANFORD.EDUPerhaps what I am about to say is obvious or has already been pointed out(I haven't been paying much attention to this discussion), but David Gray'snote is related to the fact that the function type constructor is anti-monotonic in its first argument, unlike most other other type constructorswhich are monotonic in all arguments.  That is,If      X is a subtype of Ythen    Z --> X is a subtype of Z --> Ybut     Y --> Z is a subtype of X --> Z.It would be good if Common Lisp's notion of "type" and "subtype" couldbe made consistent with this fact.Peace, Will*start*00797 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 OCT 88 16:07:44 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Oct 88  16:07:56 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 OCT 88 16:06:13 PDTDate: 2 Oct 88 16:06 PDTFrom: masinter.paSubject: Re: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 2)In-reply-to: David N Gray <Gray@DSG.csc.ti.com>'s message of Thu, 15 Sep 88 14:41:36 CDTTo: David N Gray <Gray@DSG.csc.ti.com>cc: vanroggen%aitg.DEC@decwrl.dec.com, CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <881002-160613-2752@Xerox>"the proposal needsto be extended to address this side of the issue also...."Can you? Please?*start*00938 00024 US Return-Path: <Gray@DSG.csc.ti.com>Received: from ti.com ([10.7.0.46]) by Xerox.COM ; 05 OCT 88 09:39:20 PDTReceived: by ti.com id AA09806; Wed, 5 Oct 88 11:39:36 CDTReceived: from Kelvin by tilde id AA23510; Wed, 5 Oct 88 11:07:57 CDTMessage-Id: <2801059730-3880864@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 5 Oct 88 11:08:50 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: masinter.paCc: vanroggen%aitg.DEC@decwrl.dec.comSubject: Re: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 2)In-Reply-To: Msg of 2 Oct 88 16:06 PDT from masinter.pa@Xerox.COM> Date: 2 Oct 88 16:06 PDT> From: masinter.pa@Xerox.COM> Subject: Re: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 2)> > "the proposal needs> to be extended to address this side of the issue also.> ..."> > Can you? Please?It doesn't look like I am going to have time to give this the thought itneeds before the meeting.*start*01171 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 12:13:30 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Oct 88  12:13:32 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 471951; Thu 6-Oct-88 15:11:17 EDTDate: Thu, 6 Oct 88 15:11 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 2)To: vanroggen%aitg.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8809131523.AA28994@decwrl.dec.com>Message-ID: <881006151106.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Is it the case that this proposal makes no statement on the issue ofwhat happens if you do multiple proclamations for the same function?I don't think you can completely ignore the issue because  (FUNCTION (FIXNUM FIXNUM) CONS)is a proper global declaration for CONS if multiple declarations arepermitted, but not if only one declaration is permitted.Am I confused?*start*06374 00024 US Date:  8 Oct 88 17:30 PDTSender: masinter.paSubject: DRAFT Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 2)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterStatus: DRAFT -- several issues raised not addressed hereIssue:        FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSReferences:   CLtL pp 47-48, 158-159Category:     CHANGEEdit history: #1, 7 Sept 1988, Walter van Roggen	      #2, 13 Sept 1988, Walter van Roggen (costs & proposal limitations)Problem description:The current description of the specialized FUNCTION type specifier is not veryuseful to program analysis tools and is not very intuitive to programmersbecause the meaning of the argument type specifiers is not restrictive.Programmers find it useful to add information about the types of the argumentsa function expects and about the type(s) that a function may return. Thisinformation is useful both to human readers of the code as well as to typechecking programs such as compilers and cross referencers. The only apparent(but false) way of providing this information is with the FTYPE declaration andFUNCTION type specifier.Furthermore, implementations may wish to provide additional optimizations basedon avoiding type checking or different methods of argument passing. Theseoptimizations require the same sort of information about the argument types.However, the current definition of FUNCTION type specifiers on pages 47-48 ofCLtL states that a function such as CONS that is of type  (FUNCTION (T T) CONS)is also of type  (FUNCTION (FLOAT STRING) LIST).Unfortunately this information is not useful for the above mentioned purposes.The problem is that the argument types aren't restrictive, so no interestingmatching of types is possible.Another way of looking at the problem is that specialized FUNCTION typespecifiers cannot be used in a meaningful way for discrimination (as the secondarg to TYPEP, nor as the first argument to THE).  Furthermore functions areassumed not to be sufficiently self-descriptive that a specialized FUNCTIONtype is possible to be known or can be constructed when a function is passed toTYPE-OF.Thus unlike all the other type declarations, which can be used fordiscrimination and have an implicit effect on representation, specializedFUNCTION type specifiers appear to have superfluous information.  By changingthe meaning of the argument types to convey additional descriptive informationinstead of behavioral information, we can also satisfy the other needs listedabove.Proposal (FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE)For specialized FUNCTION type specifiers  (proclaim '(ftype (function (arg0-type arg1-type ...) val-type) f))implies  (the val-type (f (the arg0-type ...) (the arg1-type ...) ...))If the arguments to F are of the specified types, then the result will be ofthe specified type.  If the arguments do not all match the specified types, itis an error, and then the result is not guaranteed to be of the specified type.This proposal does not alter the status (or lack thereof) of other issuesrelated to FUNCTION type specifiers: what lambda-list keywords mean, what theVALUES type means, what implications there are w.r.t. argument counts, doingmultiple PROCLAIMs, doing local DECLAREs that shadow other declarations orproclamations, describing generic functions incrementally, the result of TYPEPwith a specialized FUNCTION type.Rationale:The proposal seems most like what users expect.Current Practice:VAX LISP already assumes and makes use of the "restrictive" semantics. Lucidhas a RESTRICTIVE-FTYPE declaration with these semantics and ignores thestandard FTYPE declaration. Gold Hill intends to use these declarations in thismanner.  Many implementations don't make use of these declarations.  At leastseveral users make use of declarations assuming the new semantics.Cost to Implementors:Since most implementations don't make use of function declarations, and sincethose known to do so can be changed easily, the cost should be minimal.Cost to Users:There may be some existing "imprecise" function declarations.  However, thenatural tendency when providing these declarations is to be as "descriptive"(i.e., restrictive but complete) as possible, both for documentation purposesas well as for potential compiler benefits. There cannot have been any uses ofthe specialized FUNCTION type for discrimination. Thus most existing uses areprobably compatible with this new definition.Cost of Non-Adoption:There already exists user code on many implementations that assume theproposed semantics.  Not adopting this proposal would continue to rendersuch code incorrect or at least non-portable.Benefits:Better type checking and more compiler optimizations should be possible.Esthetics:This is the what most programmers expect the specialized FUNCTION type tomean, particularly those coming from other languages.Discussion:Is it the case that this proposal makes no statement on the issue ofwhat happens if you do multiple proclamations for the same function?I don't think you can completely ignore the issue because  (FUNCTION (FIXNUM FIXNUM) CONS)is a proper global declaration for CONS if multiple declarations arepermitted, but not if only one declaration is permitted.I think that much of the confusion about function type declarations isbecause there are two aspects of the issue that have not been clearlydelimited:  1. Declarations describing the definition of a function.  2. Declarations about functions expected to be received by an argument     or variable.The proposal FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE addressesthe first case, while the discussion in CLtL seems to have primarily thesecond case in mind.  - - - - -The function type constructor is anti-monotonic in its first argument, unlike most other other type constructorswhich are monotonic in all arguments.  That is,If      X is a subtype of Ythen    Z --> X is a subtype of Z --> Ybut     Y --> Z is a subtype of X --> Z.It would be good if Common Lisp's notion of "type" and "subtype" couldbe made consistent with this fact.         
TIMESROMAN           TITAN 
                        z*start*01180 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:18:36 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:18:36 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA20783; Thu, 13 Oct 88 15:17:01 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19892; Thu, 13 Oct 88 15:16:58 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132116.AA19892@defun.utah.edu>Date: Thu, 13 Oct 88 15:16:57 MDTSubject: issue FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSTo: cl-cleanup@sail.stanford.eduThe writeup looks pretty good to me.  One thing I would like added issomething to emphasize that both this proposal andFUNCTION-TYPE-REST-LIST-ELEMENT make FTYPE declarations describe callsto the function, not the actual definition of the function.  It mighthelp to present a more coherent view of what an FTYPE declaration is.As I've said elsewhere, I think that the nesting and scoping rules forFTYPE declarations should be as close as possible to those for TYPEdeclarations.-Sandra-------*start*01350 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:36:46 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:37:06 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475938; Thu 13-Oct-88 17:35:35 EDTDate: Thu, 13 Oct 88 17:35 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013173527.8.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Walter was willing to write this up, but had had trouble with net access and was missing some mail. KMP will call him and provide the relevant information for him to do the writing. It seemed reasonable to write a proposal for two things:  - FTYPE, which allowed a total specification of a function's    possible arguments and values.  - PTYPE which allowed a partial specification of same.    Multiple PTYPE specs would presumably be ok, but multiple    FTYPE would presumably not. Proposal should say what FTYPE    does when a PTYPE has been seen already and vice versa.*start*07842 00024 USfDate:  8 Dec 88 00:17 PSTFrom: masinter.paSubject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 3)To: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter, sandra%defun@cs.utah.edu (Sandra J Loosemore), Gray@DSG.csc.ti.comThis issue is in worse shape than I thought. I can't believe thatthe Problem Description and the Rationale talked about how bad itwas that the list form of FUNCTION couldn't be used for discrimination,and then about how nice it was that that was now fixed, but that theProposal didn't actually propose making the list form of FUNCTIONtype specifiers acceptable to TYPEP and the like. I wound up editingthat out of the Problem Description and Rationalebecause the proposal didn't support it. Am I confused? (Don'tanswer that. Am I Confused About This Issue?)I wound up making something up for nested function declarationsthat sounded like it was consistent with our position on DECLARE-TYPE-FREE. All in all, Version 3 looks considerably different thanVersion 2 after all of this hacking. Please review. (Walter,especially.)Forum:        CleanupIssue:        FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSReferences:   CLtL pp 47-48, 158-159Category:     CHANGERelated-issues: DECLARE-TYPE-FREEEdit history: #1, 7 Sept 1988, Walter van Roggen	      #2, 13 Sept 1988, Walter van Roggen (costs & proposal limitations)	      #3,  7-Dec-88, MasinterProblem description:The current description of the specialized FUNCTION type specifier is not veryuseful to program analysis tools and is not very intuitive to programmersbecause the meaning of the argument type specifiers is not restrictive.Programmers find it useful to add information about the types of the argumentsa function expects and about the type(s) that a function may return. Thisinformation is useful both to human readers of the code as well as to typechecking programs such as compilers and cross referencers. The only apparentway of providing this information is with the FTYPE declarationor the FUNCTION type specifier.Furthermore, implementations may wish to provide additional optimizations basedon avoiding type checking or different methods of argument passing. Theseoptimizations require the same sort of information about the argument types.However, the current definition of FUNCTION type specifiers on pages 47-48 ofCLtL states that a function such as CONS that is of type  (FUNCTION (T T) CONS)is also of type  (FUNCTION (FLOAT STRING) LIST).The problem is that the argument types aren't restrictive, so no interestingmatching of types is possible.Proposal (FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE)This proposal is written as if DECLARE-TYPE-FREE (Version 6, 06-Oct-88)is in effect.Specify that a declaration of the form       (ftype (function (arg0-type arg1-type ...) val-type) f))implies that any call of the form (f arg0 arg1 ...) within the scope ofthe declaration can be treated as if it were  (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))That is, it is an error for any of the arguments not to be of the specifiedtypes or the result not to be of the specified type. (In particular,If any argument is not of the correct type,  the result is not guaranteed to be of the specified type.)Thus, an FTYPE declaration for a function describes calls to the function,not the actual definition of the function. Similarly, specify that a declaration of the form    (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)has the interpretation that, within the scope of the declaration, itis an error to call the value of fn-valued-variable with argumentsnot of the specified type; assert that the value resulting from a validcall will be of type val-type.As with variable type declarations (cf DECLARE-TYPE-FREE), nested declarationsimply intersections of types, as follows:If two (or more) declarations of the form "ftype" are in effect,(ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))and(ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))then within the shared scope of the declarations, calls to f can betreated as if it were declared(ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)                 (and val-type1 val-type2))        f))(It is legitimate to ignore one or all of the declarations in force.)If two (or more) type declarations are in effect for a variable, andthey are both FUNCTION declarations, the declarations combine similarly.This proposal does not alter the status (or lack thereof) of other issuesrelated to FUNCTION type specifiers: what lambda-list keywords mean, what theVALUES type means, what implications there are w.r.t. argument counts, doingmultiple PROCLAIMs, doing local DECLAREs that shadow other declarations orproclamations, describing generic functions incrementally, the result of TYPEPwith a specialized FUNCTION type, or the nesting and scoping rules for FTYPE declarations.Example:  (DEFUN FFF (F)    (DECLARE (TYPE (FUNCTION (FLOAT STRING) LIST) F))    ... (FUNCALL F (FOO ...) ...) ... )then #'CONS is a valid argument to be passed to FFF because the declaredtype of the argument is consistent with type (FUNCTION (T T) CONS).Within FFF, the declaration permits us, for example, to assume that FOOreturns a FLOAT. Rationale:The proposal seems most like what users expect.Current Practice:VAX LISP assumes and makes use of the semantics different than CLtLbut not exactly what is specified here. Lucidhas a RESTRICTIVE-FTYPE declaration with these semantics and ignores thestandard FTYPE declaration. Gold Hill intends to use these declarations in thismanner.  Many implementations don't make use of these declarations.  At leastseveral users make use of declarations assuming the new semantics.Cost to Implementors:Since most implementations don't make use of function declarations, and sincethose known to do so can be changed easily, the cost should be minimal.Cost to Users:There may be some existing "imprecise" function declarations.  However, thenatural tendency when providing these declarations is to be as "descriptive"(i.e., restrictive but complete) as possible, both for documentation purposesas well as for potential compiler benefits. There cannot have been any uses ofthe specialized FUNCTION type for discrimination. Thus most existing uses areprobably compatible with this new definition.Cost of Non-Adoption:There already exists user code on many implementations that assume theproposed semantics.  Not adopting this proposal would continue to rendersuch code incorrect or at least non-portable.Benefits:Better type checking and more compiler optimizations should be possible.Esthetics:This is the what most programmers expect the specialized FUNCTION type tomean, particularly those coming from other languages.Discussion:A declaration of (FUNCTION (FIXNUM FIXNUM) CONS)is a not proper global declaration for CONS if any program mightcall CONS with arguments that are not FIXNUM.The list form of the FUNCTION type specifier is different from mosttype specifiers because it cannot be used for discrimination.Thus, the notion of "subtype" does not make sense, since assertionsabout the functional value of a variable are only partiallyabout the actual value of the variable and mainly about thevalues that might be passed to the variables (function) value.        TITAN 
         
TIMESROMAN           TITAN 
                  -                                        =      	7       	      Y              2                                                             
       K                           #      I z*start*07885 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 00:28:27 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  00:19:23 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 DEC 88 00:18:25 PSTDate: 8 Dec 88 00:17 PSTFrom: masinter.paSubject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 3)To: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.pa, sandra%defun@cs.utah.edu (Sandra J Loosemore), Gray@DSG.csc.ti.comMessage-ID: <881208-001825-2891@Xerox>This issue is in worse shape than I thought. I can't believe thatthe Problem Description and the Rationale talked about how bad itwas that the list form of FUNCTION couldn't be used for discrimination,and then about how nice it was that that was now fixed, but that theProposal didn't actually propose making the list form of FUNCTIONtype specifiers acceptable to TYPEP and the like. I wound up editingthat out of the Problem Description and Rationalebecause the proposal didn't support it. Am I confused? (Don'tanswer that. Am I Confused About This Issue?)I wound up making something up for nested function declarationsthat sounded like it was consistent with our position on DECLARE-TYPE-FREE. All in all, Version 3 looks considerably different thanVersion 2 after all of this hacking. Please review. (Walter,especially.)!Forum:        CleanupIssue:        FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSReferences:   CLtL pp 47-48, 158-159Category:     CHANGERelated-issues: DECLARE-TYPE-FREEEdit history: #1, 7 Sept 1988, Walter van Roggen	      #2, 13 Sept 1988, Walter van Roggen (costs & proposal limitations)	      #3,  7-Dec-88, MasinterProblem description:The current description of the specialized FUNCTION type specifier is not veryuseful to program analysis tools and is not very intuitive to programmersbecause the meaning of the argument type specifiers is not restrictive.Programmers find it useful to add information about the types of the argumentsa function expects and about the type(s) that a function may return. Thisinformation is useful both to human readers of the code as well as to typechecking programs such as compilers and cross referencers. The only apparentway of providing this information is with the FTYPE declarationor the FUNCTION type specifier.Furthermore, implementations may wish to provide additional optimizations basedon avoiding type checking or different methods of argument passing. Theseoptimizations require the same sort of information about the argument types.However, the current definition of FUNCTION type specifiers on pages 47-48 ofCLtL states that a function such as CONS that is of type  (FUNCTION (T T) CONS)is also of type  (FUNCTION (FLOAT STRING) LIST).The problem is that the argument types aren't restrictive, so no interestingmatching of types is possible.Proposal (FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE)This proposal is written as if DECLARE-TYPE-FREE (Version 6, 06-Oct-88)is in effect.Specify that a declaration of the form       (ftype (function (arg0-type arg1-type ...) val-type) f))implies that any call of the form (f arg0 arg1 ...) within the scope ofthe declaration can be treated as if it were  (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))That is, it is an error for any of the arguments not to be of the specifiedtypes or the result not to be of the specified type. (In particular,If any argument is not of the correct type,  the result is not guaranteed to be of the specified type.)Thus, an FTYPE declaration for a function describes calls to the function,not the actual definition of the function. Similarly, specify that a declaration of the form    (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)has the interpretation that, within the scope of the declaration, itis an error to call the value of fn-valued-variable with argumentsnot of the specified type; assert that the value resulting from a validcall will be of type val-type.As with variable type declarations (cf DECLARE-TYPE-FREE), nested declarationsimply intersections of types, as follows:If two (or more) declarations of the form "ftype" are in effect,(ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))and(ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))then within the shared scope of the declarations, calls to f can betreated as if it were declared(ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)                 (and val-type1 val-type2))        f))(It is legitimate to ignore one or all of the declarations in force.)If two (or more) type declarations are in effect for a variable, andthey are both FUNCTION declarations, the declarations combine similarly.This proposal does not alter the status (or lack thereof) of other issuesrelated to FUNCTION type specifiers: what lambda-list keywords mean, what theVALUES type means, what implications there are w.r.t. argument counts, doingmultiple PROCLAIMs, doing local DECLAREs that shadow other declarations orproclamations, describing generic functions incrementally, the result of TYPEPwith a specialized FUNCTION type, or the nesting and scoping rules for FTYPE declarations.Example:  (DEFUN FFF (F)    (DECLARE (TYPE (FUNCTION (FLOAT STRING) LIST) F))    ... (FUNCALL F (FOO ...) ...) ... )then #'CONS is a valid argument to be passed to FFF because the declaredtype of the argument is consistent with type (FUNCTION (T T) CONS).Within FFF, the declaration permits us, for example, to assume that FOOreturns a FLOAT. Rationale:The proposal seems most like what users expect.Current Practice:VAX LISP assumes and makes use of the semantics different than CLtLbut not exactly what is specified here. Lucidhas a RESTRICTIVE-FTYPE declaration with these semantics and ignores thestandard FTYPE declaration. Gold Hill intends to use these declarations in thismanner.  Many implementations don't make use of these declarations.  At leastseveral users make use of declarations assuming the new semantics.Cost to Implementors:Since most implementations don't make use of function declarations, and sincethose known to do so can be changed easily, the cost should be minimal.Cost to Users:There may be some existing "imprecise" function declarations.  However, thenatural tendency when providing these declarations is to be as "descriptive"(i.e., restrictive but complete) as possible, both for documentation purposesas well as for potential compiler benefits. There cannot have been any uses ofthe specialized FUNCTION type for discrimination. Thus most existing uses areprobably compatible with this new definition.Cost of Non-Adoption:There already exists user code on many implementations that assume theproposed semantics.  Not adopting this proposal would continue to rendersuch code incorrect or at least non-portable.Benefits:Better type checking and more compiler optimizations should be possible.Esthetics:This is the what most programmers expect the specialized FUNCTION type tomean, particularly those coming from other languages.Discussion:A declaration of (FUNCTION (FIXNUM FIXNUM) CONS)is a not proper global declaration for CONS if any program mightcall CONS with arguments that are not FIXNUM.The list form of the FUNCTION type specifier is different from mosttype specifiers because it cannot be used for discrimination.Thus, the notion of "subtype" does not make sense, since assertionsabout the functional value of a variable are only partiallyabout the actual value of the variable and mainly about thevalues that might be passed to the variables (function) value.*start*00649 00024 US Return-Path: <sandra%defun@cs.utah.edu>Received: from cs.utah.edu ([128.110.4.21]) by Xerox.COM ; 08 DEC 88 08:49:13 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.1-cs)	id AA10071; Thu, 8 Dec 88 09:46:29 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA00538; Thu, 8 Dec 88 09:46:26 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8812081646.AA00538@defun.utah.edu>Date: Thu, 8 Dec 88 09:46:25 MSTSubject: Re: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (version 3)To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM, 8 Dec 88 00:17 PSTLooks good to me.-Sandra-------*start*07071 00024 UU?Date: 12 Dec 88 11:19 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (Version 3)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noForum:        CleanupIssue:        FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSReferences:   CLtL pp 47-48, 158-159Category:     CHANGERelated-issues: DECLARE-TYPE-FREEEdit history: #1, 7 Sept 1988, Walter van Roggen              #2, 13 Sept 1988, Walter van Roggen (costs & proposal limitations)              #3,  7-Dec-88, MasinterProblem description:The current description of the specialized FUNCTION type specifier is not veryuseful to program analysis tools and is not very intuitive to programmersbecause the meaning of the argument type specifiers is not restrictive.Programmers find it useful to add information about the types of the argumentsa function expects and about the type(s) that a function may return. Thisinformation is useful both to human readers of the code as well as to typechecking programs such as compilers and cross referencers. The only apparentway of providing this information is with the FTYPE declarationor the FUNCTION type specifier.Furthermore, implementations may wish to provide additional optimizations basedon avoiding type checking or different methods of argument passing. Theseoptimizations require the same sort of information about the argument types.However, the current definition of FUNCTION type specifiers on pages 47-48 ofCLtL states that a function such as CONS that is of type  (FUNCTION (T T) CONS)is also of type  (FUNCTION (FLOAT STRING) LIST).The problem is that the argument types aren't restrictive, so no interestingmatching of types is possible.Proposal (FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE)This proposal is written as if DECLARE-TYPE-FREE (Version 6, 06-Oct-88)is in effect.Specify that a declaration of the form       (ftype (function (arg0-type arg1-type ...) val-type) f))implies that any call of the form (f arg0 arg1 ...) within the scope ofthe declaration can be treated as if it were  (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))That is, it is an error for any of the arguments not to be of the specifiedtypes or the result not to be of the specified type. (In particular,If any argument is not of the correct type,  the result is not guaranteed to be of the specified type.)Thus, an FTYPE declaration for a function describes calls to the function,not the actual definition of the function. Similarly, specify that a declaration of the form    (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)has the interpretation that, within the scope of the declaration, itis an error to call the value of fn-valued-variable with argumentsnot of the specified type; assert that the value resulting from a validcall will be of type val-type.As with variable type declarations (cf DECLARE-TYPE-FREE), nested declarationsimply intersections of types, as follows:If two (or more) declarations of the form "ftype" are in effect,(ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))and(ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))then within the shared scope of the declarations, calls to f can betreated as if it were declared(ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)                 (and val-type1 val-type2))        f))(It is legitimate to ignore one or all of the declarations in force.)If two (or more) type declarations are in effect for a variable, andthey are both FUNCTION declarations, the declarations combine similarly.This proposal does not alter the status (or lack thereof) of other issuesrelated to FUNCTION type specifiers: what lambda-list keywords mean, what theVALUES type means, what implications there are w.r.t. argument counts, doingmultiple PROCLAIMs, doing local DECLAREs that shadow other declarations orproclamations, describing generic functions incrementally, the result of TYPEPwith a specialized FUNCTION type, or the nesting and scoping rules for FTYPE declarations.Example:  (DEFUN FFF (F)    (DECLARE (TYPE (FUNCTION (FLOAT STRING) LIST) F))    ... (FUNCALL F (FOO ...) ...) ... )then #'CONS is a valid argument to be passed to FFF because the declaredtype of the argument is consistent with type (FUNCTION (T T) CONS).Within FFF, the declaration permits us, for example, to assume that FOOreturns a FLOAT. Rationale:The proposal seems most like what users expect.Current Practice:VAX LISP assumes and makes use of the semantics different than CLtLbut not exactly what is specified here. Lucidhas a RESTRICTIVE-FTYPE declaration with these semantics and ignores thestandard FTYPE declaration. Gold Hill intends to use these declarations in thismanner.  Many implementations don't make use of these declarations.  At leastseveral users make use of declarations assuming the new semantics.Cost to Implementors:Since most implementations don't make use of function declarations, and sincethose known to do so can be changed easily, the cost should be minimal.Cost to Users:There may be some existing "imprecise" function declarations.  However, thenatural tendency when providing these declarations is to be as "descriptive"(i.e., restrictive but complete) as possible, both for documentation purposesas well as for potential compiler benefits. There cannot have been any uses ofthe specialized FUNCTION type for discrimination. Thus most existing uses areprobably compatible with this new definition.Cost of Non-Adoption:There already exists user code on many implementations that assume theproposed semantics.  Not adopting this proposal would continue to rendersuch code incorrect or at least non-portable.Benefits:Better type checking and more compiler optimizations should be possible.Esthetics:This is the what most programmers expect the specialized FUNCTION type tomean, particularly those coming from other languages.Discussion:A declaration of (FUNCTION (FIXNUM FIXNUM) CONS)is a not proper global declaration for CONS if any program mightcall CONS with arguments that are not FIXNUM.The list form of the FUNCTION type specifier is different from mosttype specifiers because it cannot be used for discrimination.Thus, the notion of "subtype" does not make sense, since assertionsabout the functional value of a variable are only partiallyabout the actual value of the variable and mainly about thevalues that might be passed to the variables (function) value.        TITAN 
         TITAN 
           Z       %                            &                                                                            =      	7       	      Y              2                                                             
       K                                   $z*start*07019 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 11:50:31 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  11:29:08 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 11:19:43 PSTDate: 12 Dec 88 11:19 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS (Version 3)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-111943-4569@Xerox>!Forum:        CleanupIssue:        FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSReferences:   CLtL pp 47-48, 158-159Category:     CHANGERelated-issues: DECLARE-TYPE-FREEEdit history: #1, 7 Sept 1988, Walter van Roggen              #2, 13 Sept 1988, Walter van Roggen (costs & proposal limitations)              #3,  7-Dec-88, MasinterProblem description:The current description of the specialized FUNCTION type specifier is not veryuseful to program analysis tools and is not very intuitive to programmersbecause the meaning of the argument type specifiers is not restrictive.Programmers find it useful to add information about the types of the argumentsa function expects and about the type(s) that a function may return. Thisinformation is useful both to human readers of the code as well as to typechecking programs such as compilers and cross referencers. The only apparentway of providing this information is with the FTYPE declarationor the FUNCTION type specifier.Furthermore, implementations may wish to provide additional optimizations basedon avoiding type checking or different methods of argument passing. Theseoptimizations require the same sort of information about the argument types.However, the current definition of FUNCTION type specifiers on pages 47-48 ofCLtL states that a function such as CONS that is of type  (FUNCTION (T T) CONS)is also of type  (FUNCTION (FLOAT STRING) LIST).The problem is that the argument types aren't restrictive, so no interestingmatching of types is possible.Proposal (FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS:RESTRICTIVE)This proposal is written as if DECLARE-TYPE-FREE (Version 6, 06-Oct-88)is in effect.Specify that a declaration of the form       (ftype (function (arg0-type arg1-type ...) val-type) f))implies that any call of the form (f arg0 arg1 ...) within the scope ofthe declaration can be treated as if it were  (the val-type (f (the arg0-type arg0) (the arg1-type arg1) ...))That is, it is an error for any of the arguments not to be of the specifiedtypes or the result not to be of the specified type. (In particular,If any argument is not of the correct type,  the result is not guaranteed to be of the specified type.)Thus, an FTYPE declaration for a function describes calls to the function,not the actual definition of the function. Similarly, specify that a declaration of the form    (type (function (arg0-type arg1-type ...) val-type) fn-valued-variable)has the interpretation that, within the scope of the declaration, itis an error to call the value of fn-valued-variable with argumentsnot of the specified type; assert that the value resulting from a validcall will be of type val-type.As with variable type declarations (cf DECLARE-TYPE-FREE), nested declarationsimply intersections of types, as follows:If two (or more) declarations of the form "ftype" are in effect,(ftype (function (arg0-type1 arg1-type1 ...) val-type1) f))and(ftype (function (arg0-type2 arg1-type2 ...) val-type2) f))then within the shared scope of the declarations, calls to f can betreated as if it were declared(ftype (function ((and arg0-type1 arg0-type2) (and arg1-type1 arg1-type2 ...) ...)                 (and val-type1 val-type2))        f))(It is legitimate to ignore one or all of the declarations in force.)If two (or more) type declarations are in effect for a variable, andthey are both FUNCTION declarations, the declarations combine similarly.This proposal does not alter the status (or lack thereof) of other issuesrelated to FUNCTION type specifiers: what lambda-list keywords mean, what theVALUES type means, what implications there are w.r.t. argument counts, doingmultiple PROCLAIMs, doing local DECLAREs that shadow other declarations orproclamations, describing generic functions incrementally, the result of TYPEPwith a specialized FUNCTION type, or the nesting and scoping rules for FTYPE declarations.Example:  (DEFUN FFF (F)    (DECLARE (TYPE (FUNCTION (FLOAT STRING) LIST) F))    ... (FUNCALL F (FOO ...) ...) ... )then #'CONS is a valid argument to be passed to FFF because the declaredtype of the argument is consistent with type (FUNCTION (T T) CONS).Within FFF, the declaration permits us, for example, to assume that FOOreturns a FLOAT. Rationale:The proposal seems most like what users expect.Current Practice:VAX LISP assumes and makes use of the semantics different than CLtLbut not exactly what is specified here. Lucidhas a RESTRICTIVE-FTYPE declaration with these semantics and ignores thestandard FTYPE declaration. Gold Hill intends to use these declarations in thismanner.  Many implementations don't make use of these declarations.  At leastseveral users make use of declarations assuming the new semantics.Cost to Implementors:Since most implementations don't make use of function declarations, and sincethose known to do so can be changed easily, the cost should be minimal.Cost to Users:There may be some existing "imprecise" function declarations.  However, thenatural tendency when providing these declarations is to be as "descriptive"(i.e., restrictive but complete) as possible, both for documentation purposesas well as for potential compiler benefits. There cannot have been any uses ofthe specialized FUNCTION type for discrimination. Thus most existing uses areprobably compatible with this new definition.Cost of Non-Adoption:There already exists user code on many implementations that assume theproposed semantics.  Not adopting this proposal would continue to rendersuch code incorrect or at least non-portable.Benefits:Better type checking and more compiler optimizations should be possible.Esthetics:This is the what most programmers expect the specialized FUNCTION type tomean, particularly those coming from other languages.Discussion:A declaration of (FUNCTION (FIXNUM FIXNUM) CONS)is a not proper global declaration for CONS if any program mightcall CONS with arguments that are not FIXNUM.The list form of the FUNCTION type specifier is different from mosttype specifiers because it cannot be used for discrimination.Thus, the notion of "subtype" does not make sense, since assertionsabout the functional value of a variable are only partiallyabout the actual value of the variable and mainly about thevalues that might be passed to the variables (function) value.