*start*08476 00024 USfReturn-Path: <@SAIL.STANFORD.EDU:JAR@AI.AI.MIT.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 APR 87 13:37:58 PDTReceived: from AI.AI.MIT.EDU by SAIL.STANFORD.EDU with TCP; 28 Apr 87  13:34:01 PDTDate: Tue, 28 Apr 87 16:35:56 EDTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  Issue: PROCLAIM-LEXICALTo: cl-cleanup@SAIL.STANFORD.EDUcc: KMP@AI.AI.MIT.EDUMessage-ID: <192342.870428.JAR@AI.AI.MIT.EDU>Issue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37), global variables (p68),	      declaration specifiers (p157)Category:     CLARIFICATION/ENHANCEMENTEdit history: Revision 2 by JAR 04/28/87Status:       Very preliminary.Description of problem:  CLtL pp. 55-56 implies that if a name (symbol) is not proclaimed or  declared special, then a free reference to that name is a reference to  the special variable of that name, while a LAMBDA-binding of that name  indicates a binding of the lexical variable of that name.  This would  mean that the following program is legal and that (TST) => 4:    (defun tst ()      (setq x 3)      (funcall (let ((x 4)) #'(lambda () x))))  However, if you feed this program to many Common Lisp compilers  (including Symbolics's and DEC's), a warning message will be  produced for the SETQ, saying something like "Warning: X not  declared or bound, assuming special."  These warnings, unlike the annotations of undefined functions (which  occur only at the end of a compilation), are presented so  prominently that a user would be hard put to say that a program  which elicited such warning messages was "correct" in that  implementation.  Unlike the situation with unused variables, there is  no possible declaration one can write which suppresses the warning  messages.  This disagreement between theory and practice should be mended  somehow.Proposal (PROCLAIM-LEXICAL:CURRENT-PRACTICE):  Change the language definition (page 55?) to say that it is an error  for there to be a free reference or assignment to a name unless a  SPECIAL proclamation or declaration is in effect for that name.  This would legitimize the behavior of current implementations.Proposal (PROCLAIM-LEXICAL:BY-THE-BOOK):  Shame implementors into going by the book.  Implementations should  simply stop intimidating users who want to write code like this.  "Apparently unbound variable" warnings should be given the same  purely advisory status that "apparently undefined function" warnings  now enjoy.  The exact meaning of this is of course implementation-  dependent.Proposal (PROCLAIM-LEXICAL:GENERAL):  Introduce a new declaration specifier, LEXICAL, which is dual to the  SPECIAL declaration specifier; it may appear in proclamations and  declarations.  A name may be proclaimed either lexical or special, but not both.  A free reference or assignment to a name is an error if there is  neither a SPECIAL nor a LEXICAL proclamation or declaration in  effect for the name.  A LAMBDA-binding in the absence of a  declaration or proclamation binds the lexical variable.  The global lexical environment and the global dynamic environment  are identical.  I.e. an assignment to the global binding of a  lexical variable will be reflected in the observed global value of  the dynamic variable of the same name, and vice versa.  Example:    (proclaim '(lexical x))    (proclaim '(special y))    (setq x 1 y 2)    (defun tst ()      (let ((x 3) (y 4))	(locally (declare (special x) (lexical y))	  (list x y	        (funcall (let ((x 5) (y 6))			   #'(lambda () (list x y))))))))    (tst) => (1 2 (5 4))Proposal (PROCLAIM-LEXICAL:RESTRICTED):  Same as PROCLAIM-LEXICAL:GENERAL, but with the following restriction:  If a name is proclaimed lexical, then it is an error for there to be  a special declaration of the same name.  For example, the special  declaration of X in the example is an error.Cost of adopting change:  CURRENT-PRACTICE: Ostensibly none, although implementations which  don't signal this as an error should be explicitly encouraged  to do so.  It ought to be signalled in interpreted code as well.  BY-THE-BOOK: This would be an easy fix to the error reporting and  bookkeepping components of existing compilers.  Of course it is not  a change to the language, so there is no impact on portable code.  GENERAL: This would be straightforward to implement, and is perhaps even  already present, in implementations that use deep binding for  special variables.  In shallow bound implementations there's a  problem because two "global" value cells are needed: one for the  current dynamic binding, and one for the global lexical binding;  and when no dynamic binding is in effect, they must somehow be  "coalesced" so that SETQ's are reflected in both.  RESTRICTED: This is specifically designed to address the  implementation problems of GENERAL.  Having a dynamic binding and  having a global lexical binding are mutually exclusive.Benefits:  CURRENT-PRACTICE is incompatible with Scheme, which explicitly  allows a program to have both a global binding and LAMBDA bindings  of the same variable.  Therefore, adopting any of the other three  proposals would be a major step towards reducing the  incompatibilities between the two languages, since both code  conversion and embedded scheme implementations would be made easier  and more graceful.  GENERAL and RESTRICTED have the additional advantage that, in an  implementation that uses deep binding for dynamic variables, a  lexical proclamation can be used to achieve significant performance  gains on references and assignments to global variables.  A LEXICAL  proclamation would also allow some desirable redundancy, both  for documentation and for error checking.Cost of converting existing code:  CURRENT-PRACTICE: Some programs may rely on the CLtL semantics;  these would have to be changed if what they're doing now becomes  officially erroneous.  People might find consistent enforcement  of this rule rather surprising and frustrating.  GENERAL and RESTRICTED are both upwards compatible.  Of course,  code-walking utilities would have to be taught about the new  feature, since it affects the basic semantics of the language.Aesthetics:  The special/lexical business is generally one of CL's most insidious  and disgusting aspects, and really needs a much more thorough  overhaul than is proposed above (e.g. there ought to be a separate  DYNAMIC-LET or SPECIAL-LET which does dynamic binding).  But this is  probably practically and politically infeasible.  Given that, I  don't think any of these proposals has clear advantages or  disadvantages from the point of view of simplicity or elegance of  description, except that GENERAL is somewhat easier to describe  than RESTRICTED.Discussion:  The four proposals indicate the range of possibilities.  After some  discussion, we ought to be able to prune this down, of course.  JAR thinks that CURRENT-PRACTICE is unacceptable, BY-THE-BOOK is  unsatisfying but somewhat better, and GENERAL has unsolved implementation  problems, even though it seems the most powerful, symmetric, and elegant.  Thus RESTRICTED seems preferable.  This proposal ignores the question of what to do about an analogue  of DEFVAR or DEFPARAMETER for global lexicals.  Interlisp and PSL both  have something along these lines (DEFGLOBAL), don't they?  Given the presence of lexical proclamations in the language, it's  still not clear whether a free, undeclared, unproclaimed reference  should be an error, and if it's not an error, whether it should refer  to the lexical binding or the special binding.  I suggest that it not  be an error, and I don't really care what its meaning should be (since  in the situation I care about I'm not going to be dynamically binding  the variable anyhow, so it doesn't matter).  The RESTRICTED semantics  would imply that such a reference would have to be to the special  variable.  [By the way, I don't like this use of the term "variable," but I'm  trying to be consistent with CLtL p. 55.  Note that according to this  it doesn't make any sense to talk about "declaring a variable to be  special" since any variable is already either special or lexical; it  is names which can be so declared.  The book is definitely NOT  consistent about this, and ought to be fixed.]*start*02678 00024 US Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 APR 87 19:18:53 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 28 Apr 87  19:16:42 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 126601; Tue 28-Apr-87 18:52:26 EDTDate: Tue, 28 Apr 87 18:52 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL To: CL-Cleanup@SAIL.STANFORD.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, JAR@AI.AI.MIT.EDUMessage-ID: <870428185220.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>I support PROCLAIM-LEXICAL:GENERAL if the implementation issues canbe worked out, which I think they can.I spoke with Jonathan briefly about these problems and I think heagrees with me that they're not really a problem if you just keepthe global lexical value cells someplace other than the SYMBOL-VALUEof the symbol.For example, you might write: (DEFVAR SYSTEM:*THE-GLOBAL-LEXICAL-VALUE-CELLS* (MAKE-HASH-TABLE)) (DEFUN SYSTEM:GLOBAL-LEXICAL-VALUE-CELL (SYMBOL)   (OR (GETHASH SYMBOL SYSTEM:*THE-GLOBAL-LEXICAL-VALUES-CELLS*)       (SETF (GETHASH SYMBOL SYSTEM:*THE-GLOBAL-LEXICAL-VALUES-CELLS*)	     (CONS SYMBOL ;For debugging		   SYSTEM:*UNBOUND-MARKER*)))) (DEFMACRO SYSTEM:GLOBAL-LEXICAL-VALUE (SYMBOL)   `(CDR (EVALUATE-AT-LOAD-TIME (SYSTEM:GLOBAL-LEXICAL-VALUE-CELL ',SYMBOL))))Of course (as stated above), this changes his proposal slightly tomake the global lexical and dynamic environments disjoint. That is,programs like (DEFUN MAYBE-EVEN-BUT-SURELY-ODD ()   (+ (LOCALLY (DECLARE (LEXICAL X) (INTEGER X)) X)      (LOCALLY (DECLARE (SPECIAL X) (INTEGER X)) X)))could return odd numbers (since lexical X and special X might denotedifferent quantities).The contract of the compiler would be to turn global lexicalreferences to a symbol into (SYSTEM:GLOBAL-LEXICAL-VALUE 'symbol).The call to SYSTEM:GLOBAL-LEXICAL-VALUE-CELL (ie, the GETHASH) needhappen only once (at load time) so its speed is not important.If the above code wanted to be portable, of course, you'd have to havean S-expression equivalent to #, called EVALUATE-AT-LOAD-TIME. Mostimplementations have such a thing, I think, they just don't let it outfor users to play with. In fact, I think CL should have such a thingsince this isn't the first case where people have wanted it.In any case, portability isn't relevant to this message since allthat's needed is to demonstrate that it would be feasible to implementthis in all systems, which I think the above code demonstrates.*start*01716 00024 US Return-Path: <@SAIL.STANFORD.EDU:masinter.PA@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 APR 87 22:06:25 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 28 Apr 87  22:04:12 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 28 APR 87 22:04:03 PDTFrom: masinter.PADate: 28 Apr 87 22:02:51 PDTSubject: Re: Issue: PROCLAIM-LEXICALIn-reply-to: KMP@STONY-BROOK.SCRC.Symbolics.COM's message of Tue, 28 Apr 87 18:52 EDT, <870428185220.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDU, JAR@AI.AI.MIT.EDUMessage-ID: <870428-220403-2039@Xerox>Jonathan left out the alternative that I thought most natural, namelythat otherwise undeclaredvariables were not an error, but would default lexical. E.g.,(setq x 3)(defun frob () (incf x))would not be an error, but would always refer to the lexically global x.This would bring variable scoping in line with function scoping whenthere were no declarations. (A state of grace.)I presume that Kent didn't really mean to propose that the globallexical environment be different from the global dynamic environment,but that was just an awkward artifact of his sample implementation.Right Kent?The only idiom which might have portability problems are dynamic callsto EVAL that get the dynamic binding, e.g., instead of usingSYMBOL-VALUE, e.g., user has a data base of permutations of variables &values, and also of expressions, binds the variables with PROGV and thenevaluates the expressions.While current practice is that compilers will warn about undeclared freereferences, I know of no interpreter that does, do you?*start*03358 00024 US Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 29 APR 87 06:43:55 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 29 Apr 87  06:35:52 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 126932; Wed 29-Apr-87 09:35:59 EDTDate: Wed, 29 Apr 87 09:35 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PROCLAIM-LEXICALTo: Masinter.PAcc: CL-Cleanup@SAIL.STANFORD.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COM, JAR@AI.AI.MIT.EDUIn-Reply-To: <870428-220403-2039@Xerox>Message-ID: <870429093550.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>I'm sympathetic to the idea that undeclared free variables shoulddefault lexical. Certainly if we had lexical globals I'd expect thatsome compilers would start defaulting free variables lexical whileothers would continue to default them special, so perhaps we shouldjust go ahead and make it well-defined.Anyway, the separation of global lexical environment from global specialenvironment seems to me important. After all, you can already do: (DEFUN F (X) (+ X (LOCALLY (DECLARE (SPECIAL X)) X)))and see two different variables X without any intervening rebinding.I was just assuring that this effect was properly carried through.Also, this assures that people cannot muck with the lexical bindingof any variable. Special variables are kind of 3lispy in nature becausewe're told how they're represented and we have primitives for manipulatingthem either as variables or as data. I think this makes program proofsmore difficult. The feature of lexical variables is that all of theiruses are statically detectable; this would not be so for global lexicalsif their homes were something that users were permitted to read in a non-statically-detectable way (eg, using SYMBOL-VALUE) or set (using SETFof same). By making the lexical bindings totally isolated, you ensurethe right of the compiler to do much better compilation of global lexicalsin some cases than it might be able to do for global specials, and at thesame time you don't make any unpleasant changes to the mechanisms alreadyin place and in use for specials.And finally, if you separate the two spaces, then you can go back andforth between declaring variables special or not without it having strangeeffect on things already compiled. eg, if you needed:(DEFGLOBAL Y 3)(DEFUN F (X) (+ X Y))...(PROCLAIM '(SPECIAL Y))(DEFUN FOO (Y) (BAR))(DEFUN BAR () ... (SETQ Y ...) ...)(PROCLAIM '(LEXICAL Y))without worrying that the global lexical Y=3 binding was in dangerof getting modified (which it seems intuitive to me that it shouldnot have been).MACSYMA, for example, needs an UNSPECIAL declaration because on aper-file basis it goes back and forth between using the same name eitherspecial or lexical. Alternating back and forth between default LEXICALand default SPECIAL would serve it as well if we made that legal.If such alternation meant that programs previously compiled using theother semantics were now in error or might behave differently than Iintended at time-of-definition, then you've defeated the purpose of mydoing the alternation. I think the separation of namespaces ensuresintuitive behavior.*start*01018 00024 US Return-Path: <JAR@AI.AI.MIT.EDU>Received: from AI.AI.MIT.EDU by Xerox.COM ; 29 APR 87 10:26:00 PDTDate: Wed, 29 Apr 87 13:26:40 EDTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  Issue: PROCLAIM-LEXICALTo: masinter.PAcc: CL-Cleanup@SAIL.STANFORD.EDU, KMP@SCRC-STONY-BROOK.ARPAIn-reply-to: Msg of 28 Apr 87 22:02:51 PDT from masinter.PA at Xerox.COMMessage-ID: <192793.870429.JAR@AI.AI.MIT.EDU>    Date: 28 Apr 87 22:02:51 PDT    From: masinter.PA at Xerox.COM    While current practice is that compilers will warn about undeclared free    references, I know of no interpreter that does, do you?The VAX LISP interpreter will generate such warnings if an internal,unreleased switch is set non-nil.  Its default value is nil.  For a weekor two when the feature first appeared (only inside DEC, of course) theswitch was defaultly true.  Some people liked the immediate feedback,but overall the warnings were judged too radical and disconcerting, sothe default was changed.*start*03642 00024 US Return-Path: <@REAGAN.AI.MIT.EDU:MLY@AI.AI.MIT.EDU>Received: from REAGAN.AI.MIT.EDU ([128.52.22.53]) by Xerox.COM ; 29 APR 87 11:21:46 PDTReceived: from MARLEY.AI.MIT.EDU by REAGAN.AI.MIT.EDU via CHAOS with CHAOS-MAIL id 36868; Wed 29-Apr-87 14:22:03 EDTDate: Wed, 29 Apr 87 14:21 EDTFrom: Richard Mlynarik <MLY@AI.AI.MIT.EDU>Subject: Re: Issue: PROCLAIM-LEXICALTo: masinter.PA, KMP@STONY-BROOK.SCRC.Symbolics.COMcc: JAR@AI.AI.MIT.EDUIn-Reply-To: <870428-220403-2039@Xerox>Message-ID: <870429142128.7.MLY@MARLEY.AI.MIT.EDU>    Date: 28 Apr 87 22:02:51 PDT    From: masinter.PA@Xerox.COM    [...]    While current practice is that compilers will warn about undeclared free    references, I know of no interpreter that does, do you?The interpreter I wrote did this.  When I mentioned this to the common-lispa year or two ago I was roundly criticized for my presumption in doingso (mainly by Fahlman, as I remember)  Plus ca change...I don't know whether it was a really good in itself from the point ofview of reference semantics (in particular, in relation to those offunction-reference, which I did not change).  It was certainly agood at making the compiler and interpreter behave more alikeand, as such, at catching a few problems for people who usedthe interpreter.There was a function (EVAL-SPECIALS-OK or something like that)which REP loops instead of raw EVAL.  This function called EVALwith an environment argument, a component of which indicated thatall free references should be treated as special references as in CLtL.This allowed interactions like "(setq foo (frob)) ... (describe foo)"but would err on "(defun lose () foo)"  This was a rather nice solutionto the whole business and left most people happy.(defun interpreter-symeval (symbol environment)  (declare (dbg:uninteresting-function eval))  ... search lexical environment ...  (cond ((get symbol 'special)	 (symbol-value symbol))	((environment-all-free-references-are-special environment)	 ;; Top-level REP loops call EVAL with a special environment         (symbol-value symbol))	(t (var-not-special symbol "evaluate it" t #'symbol-value))))(defun interpreter-set ...)(defun interpreter-value-cell-location ...)(defun var-not-special (symbol attempt must-be-assigned-p			special-function &rest additional-args)  (declare (dbg:error-reporter))  (if *all-free-interpreter-variable-references-special* ;yuckeroo.  For CLtL compatibility.      (apply special-function symbol additional-args)    (flet ((abort-if-unassigned ()	     #+symbolics (declare (sys:downward-function))	     (when (and must-be-assigned-p (not (boundp symbol)))	       (format t "~&~S is unassigned.  Restart would fail.~%" symbol)	       (abort))	     (values)))      (restart-case (error 'free-variable-reference			   :symbol symbol			   :attempt attempt)	(use-value	  (lambda (val) val)	  :report (format t "Return a value to use this once.")	  :interactive (values (accept t "Value to use this time: ")))	(use-dynamic-value	  (lambda () (apply special-function symbol additional-args))	  :interactive #'abort-if-unassigned	  :report (format t "Use the dynamic (special) value of ~S~@[ (Which is unassigned!!)~]."			    symbol (and must-be-assigned-p (not (boundp symbol)))))	(make-special	  (lambda ()	    (setf (get symbol 'special) t)	    (apply special-function symbol additional-args))	  :interactive #'abort-if-unassigned	  :report (format t "Make ~S special and use it~@[ (Note that its dynamic value is unassigned)~]."			  symbol (and must-be-assigned-p (not (boundp symbol)))))))))*start*02948 00024 US Return-Path: <@SAIL.STANFORD.EDU:edsel!bhopal!jonl@navajo.stanford.edu>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 29 APR 87 17:25:49 PDTReceived: from NAVAJO.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 29 Apr 87  17:22:30 PDTReceived: by navajo.stanford.edu; Wed, 29 Apr 87 17:22:02 PDTReceived: from bhopal.edsel.com by edsel.uucp (2.2/SMI-2.0)	id AA01519; Wed, 29 Apr 87 16:33:45 pdtReceived: by bhopal.edsel.com (3.2/SMI-3.2)	id AA13102; Wed, 29 Apr 87 16:30:59 PDTDate: Wed, 29 Apr 87 16:30:59 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8704292330.AA13102@bhopal.edsel.com>To: navajo!KMP%STONY-BROOK.SCRC.Symbolics.COM@navajo.stanford.eduCc: navajo!CL-Cleanup%SAIL@navajo.stanford.eduIn-Reply-To: Kent M Pitman's message of Wed, 29 Apr 87 09:35 EDTSubject: Issue: PROCLAIM-LEXICALIn a deep-bound Lisp, it is critically important to be able to distinguish "global" access/update from "special", or "fluid" access/update.  A note I sent to the CL mailing list about a year ago stressed this point; itexplained the semantic differences and showed some performance consequences.There were not many replies about it since almost all Common Lisps are currently shallow-bound [the upcoming Xerox effort will be an exception, and some parallel research versions of Common Lisp are also an exception]Since none of these proposals for clarifying the semantics of undeclaredvariables propose to do away with "special" variables, then the question of global/fluid distinction for "specials" is still relevant.  So I'm a bit concerned about the proposal to add yet a third environment, the "global lexical", which doesn't address this concern.Consider, for a moment, the example:   (let ((x 1))     (declare (special x))     (load "some-file"))where the contents of "some-file" are   (setq x (+ x 3))The historic interpretation is that this SETQ applies to the specialbinding of x.  To get the effect of setting the global "fluid" binding,one would have to say something like   (proclaim '(global x))  (setq x (+ x 3))or like  (locally (declare (global x)) (setq x (+ x 3)))or use functions like Interlisp's "topval" functions:   (settopval 'x (+ (gettopval 'x) 3))In this example, it would/should be illegal to lambda-bind x if it were declared "global"; thus it is quite satisfactory to use the shallow-binding value cell as both the "global" cell and the "special" cell;  For many reasons, it is very convenient to have the "top-level" fluid environment be the same as the global environment.  That's why I'm a bit taken aback by your proposal that the "global lexical" could not share with the global dynamic (fluid) environment.  Whereas there is the demonstrated need for a declaration which distinguishes special variables from global variables, where is the need for a distinct, yet parallel, global lexical environment?-- JonL --*start*02717 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 29 APR 87 19:28:47 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 29 Apr 87  19:26:35 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 127905; Wed 29-Apr-87 22:26:18 EDTDate: Wed, 29 Apr 87 22:26 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICALTo: Jonathan A Rees <JAR@AI.AI.MIT.EDU>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <192342.870428.JAR@AI.AI.MIT.EDU>Message-ID: <870429222608.2.MOON@EUPHRATES.SCRC.Symbolics.COM>I remember some of this being discussed before, and there being somereason for not doing it that I couldn't remember, so I went backthrough some old Common Lisp documents I have held onto.  Here'swhat I found:21 Dec 1981 Issue #70 - we discussed the issue of what undeclaredfree variable references mean, but couldn't decide.  The alternativesoffered weren't very deep:  (a) interpreter and compiler warn  (b) interpreter never warns, compiler is permitted to warn  (c) "status quo" [it said] the interpreter never warns, but the compiler      never warns for top level forms, but is permitted to warn inside functions21 Dec 1981 Issue #72 - we tentatively introduced a LOCAL declaration,meaning not SPECIAL.  This was by analogy with the UNSPECIAL declarationof Maclisp and Zetalisp, but we decided to change the name.  I don'tthink we had completely understood the DECLARE/PROCLAIM distinctionat that time (although we were discussing it) so I'm not sure whatLOCAL meant as a proclamation; I think the idea was just that as adeclaration it could be used to shadow a SPECIAL proclamation.8/14/82 I found a note of mine saying "there is no way to declarea variable not special.  I guess this got taken out when special waschanged not to be pervasive.  This needs to be fixed."8/21/82 Common Lisp meeting Issue #78: Need some kind of declaration tolocally shadow a globally pervasive special declaration [I think that'sa special proclamation in current terminology].  I have written down that"the vote was yes, GLS will propose, read JonL's paper".  I don't have aclue which JonL paper this refers to.In all later documents, there is special but no unspecial nor local.This confirmed my memory that a lexical declaration had been put in andthen taken out, but I was unable to find any written rationale for thedecisions, which is what I was really looking for.  I didn't go so faras to search the electronic mail archives (but I don't think they goback all the way to 1981).*start*02593 00024 US Return-Path: <@SAIL.STANFORD.EDU:JAR@AI.AI.MIT.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 29 APR 87 19:54:32 PDTReceived: from AI.AI.MIT.EDU by SAIL.STANFORD.EDU with TCP; 29 Apr 87  19:51:22 PDTDate: Wed, 29 Apr 87 22:53:15 EDTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  Issue: PROCLAIM-LEXICALTo: edsel!bhopal!jonl@NAVAJO.STANFORD.EDUcc: CL-Cleanup@SAIL.STANFORD.EDU, KMP@MX.LCS.MIT.EDUIn-reply-to: Msg of Wed 29 Apr 87 16:30:59 PDT from edsel!bhopal!jonl at navajo.stanford.edu (Jon L White)Message-ID: <193127.870429.JAR@AI.AI.MIT.EDU>    Date: Wed, 29 Apr 87 16:30:59 PDT    From: edsel!bhopal!jonl at navajo.stanford.edu (Jon L White)    So I'm a bit concerned about the proposal to add yet a third    environment, the "global lexical", which doesn't address this    concern.I'm having trouble understanding how you count environments.  I count atotal of four:       1. lexical LAMBDA-bindings       2. global lexical       3. dynamic LAMBDA-bindings       4. global dynamicKMP doesn't suggest ADDING a global lexical environment; the globallexical environment is already there in the GENERAL and RESTRICTEDproposals.  He merely suggests making it not be identical to the globaldynamic environment.  This would make a total of 4 environments, not 3.I tend to think of 2 and 4 as being part of 1 and 3.  This is consistentif you imagine that there's an immense cosmic LAMBDA surrounding allthe programs in the world; this LAMBDA binds all possible names.I have no opinion at this point on the virtues of KMP's amendment.    In this example, it would/should be illegal to lambda-bind x if it were    declared "global"; thus it is quite satisfactory to use the    shallow-binding value cell as both the "global" cell and the "special"    cell...This proposal is even more restrictive than RESTRICTED.  I see no reasonto impose this restriction, and I see Scheme compatibility as a bigreason that we SHOULD allow lambda-binding variables which have globalbindings.  The RESTRICTED proposal seems to give you everything you want-- it allows you to have a single global value cell inshallow-dynamic-binding implementations, and it allows the desiredperformance advantages in deep-dynamic-binding implementations.  Why doyou want to rule out lexically lambda-binding global variables?  Doesthis have something to do with shallow lexical binding?If I have told you something you didn't already know, or if you stilldon't understand what I'm getting at, how can I make the proposalsclearer?Jonathan*start*02381 00024 US Return-Path: <@SAIL.STANFORD.EDU:edsel!bhopal!jonl@navajo.stanford.edu>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 30 APR 87 00:55:53 PDTReceived: from NAVAJO.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 30 Apr 87  00:53:24 PDTReceived: by navajo.stanford.edu; Thu, 30 Apr 87 00:52:55 PDTReceived: from bhopal.edsel.com by edsel.uucp (2.2/SMI-2.0)	id AA03157; Wed, 29 Apr 87 23:47:27 pdtReceived: by bhopal.edsel.com (3.2/SMI-3.2)	id AA13625; Wed, 29 Apr 87 23:44:42 PDTDate: Wed, 29 Apr 87 23:44:42 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8704300644.AA13625@bhopal.edsel.com>To: navajo!Moon%STONY-BROOK.SCRC.Symbolics.COM@navajo.stanford.eduCc: navajo!cl-cleanup%SAIL@navajo.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 29 Apr 87 22:26 EDTSubject: Issue: PROCLAIM-LEXICALRe :8/21/82 Common Lisp meeting Issue #78: Need some kind of declaration to    locally shadow a globally pervasive special declaration [I think that's    a special proclamation in current terminology].  I have written down that    "the vote was yes, GLS will propose, read JonL's paper".  I don't have a    clue which JonL paper this refers to.This "Common Lisp meeting" was held at CMU just after the 1982 LispConference.  The "JonL paper" in question could hardly be anything other than my contribution to that conference.  It had a long titlesomething like "Constant Time Interpretation for Variables, in thePresence of Mixed SPECIAL/LOCAL Declarations".  It described the VAX/NILinterpreter, and how it processed "special" and "unspecial" declarationsby pushing a block similar to what a lambda-binding would do, andhow the interpretation of a variable reference was resolved by comparing"declarational level number" with "binding level number".  It was fullof cute little acronyms, for which I can blame GLS.I vaguely remember some flaming about LOCAL declaration being unnecessarybecause, unlike in MacLisp, the SPECIAL declaration of Common Lisp wasn'tto be pervasive.  As you say, I think the "flamers" totally blew it because of not understanding the difference between DECLARE and PROCLAIM.-- JonL --P.S. The technique described in the above-mentioned paper was strictly     for a shallow-bound, non-parallel implementation.  I don't think     I see how to generalize it otherwise.*start*02820 00024 US Return-Path: <@SAIL.STANFORD.EDU:JAR@AI.AI.MIT.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 30 APR 87 19:04:51 PDTReceived: from AI.AI.MIT.EDU by SAIL.STANFORD.EDU with TCP; 30 Apr 87  19:01:20 PDTDate: Thu, 30 Apr 87 22:03:41 EDTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  Issue: PROCLAIM-LEXICALTo: edsel!bhopal!jonl@NAVAJO.STANFORD.EDUcc: KMP@AI.AI.MIT.EDU, CL-Cleanup@SAIL.STANFORD.EDUIn-reply-to: Msg of Thu 30 Apr 87 16:11:01 PDT from edsel!bhopal!jonl at navajo.stanford.edu (Jon L White)Message-ID: <193809.870430.JAR@AI.AI.MIT.EDU>    Date: Thu, 30 Apr 87 16:11:01 PDT    From: edsel!bhopal!jonl at navajo.stanford.edu (Jon L White)    With respect to environments for a "free variable" reference, there are3,     not 4, possibilities.  A lexically-bound variable isn't free, and hence     not, I thought, of concern to this discussion [which was opened up by your     attempt to clarify the semantics of free variables].OK, I see.  "Free" means lexically free.    Re: . . .   I see no reason        to impose this restriction, and I see Scheme compatibility as a big        reason that we SHOULD allow lambda-binding variables which have global        bindings.   . . .     I think you misread this completely backwards.  It WASN'T that you    couldn't lambda-bind anything that had a binding in the global    environment.  It WAS that you couldn't lambda-bind anything that was    explicitly declared or proclaimed GLOBAL rather than SPECIAL (or    LOCAL?).Since you are implicitly proposing a third kind of declaration (GLOBAL,in addition to SPECIAL and my proposed LEXICAL), I take this as animplicit criticism of the proposal; you must consider it inadequate orelse you wouldn't be suggesting this new and different idea.  I'mwondering what  (PROCLAIM '(GLOBAL ...))gives you that  (PROCLAIM '(LEXICAL ...))doesn't.  Forgetting our differences in conceptual model and terminologyfor the moment, the ONLY difference I see between these (assuming theRESTRICTED proposal), either semantically and pragmatically, is that avariable that proclaimed GLOBAL cannot be lexically lambda-bound.Therefore I don't see what GLOBAL adds to my proposal or why you aresuggesting that it's a good idea.  (Certainly in the absence of(PROCLAIM '(LEXICAL ...)), it is a good idea.)I.e. I don't see how your "global" variables are different from my"global lexical" variables.Getting back to terminology: why do you think LOCAL is a better namethan LEXICAL?  LEXICAL seems more general and more descriptive to me, aslong as you buy the idea that there is such a thing as a top-level(global) environment, which serves as BOTH the top-level lexicalenvironment and as the top-level dynamic environment (unless KMP has hisway).Jonathan*start*03816 00024 USaReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 02 MAY 87 18:58:21 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 2 May 87  18:55:47 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sat 2 May 87 21:56:52-EDTDate: Sat, 2 May 87 21:56 EDTMessage-ID: <FAHLMAN.12299293460.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: PROCLAIM-LEXICALIn-reply-to: Msg of 2 May 1987  19:58-EDT from Jonathan A Rees <JAR at AI.AI.MIT.EDU>In reply to JAR:        Not true.  You can suppress this warning by saying (proclaim '(special        <var>)) or (defvar <var>).    *Not* not true!  Look again at the example.    ...    I don't know how you develop code, but I like to get my programs into    a condition where they do not elicit warnings from the compiler.OK, if you really want to use the same names for your specials and yourlexicals, then indeed there is no good way to get rid of the warning.  Ihardly ever do this, so I missed your point.  When I see that warning ina case like your example program, it tells me that it's time to renamesomething, not that I should find some way to inhibit the warning with adeclaration.I assume that we're not going to consider any radical proposals for thehandling of specials, such as separating the name spaces by making the*foo* syntax mandatory for specials.  If we stay close to the statusquo, it seems to me that we really should go ahead and add a LEXICALdeclaration and a LEXICAL proclamation so that those pervasive specialproclamations can be cancelled or shadowed.  I haven't heard any goodarguments against this in the last N years.  The need to eliminatespurious "not declared or bound" warnings is one argument in favor ofthis change, but it would be a useful change for other reasons in anycase.    Why is this any different from an undefined function, which is not    similarly warned about?  I believe these two situations (forward    reference to a variable and to a function) should be treated    symmetrically.No difference in principle.  Both conditions are suspicious and worth awarning, in my view, but how such warnings are handled is up to theimplementor.  It is desirable to emit these warnings when the suspiciouscondition is noticed; that way the location of the problem is marked andthe user has the option of aborting the compilation.  In the case ofundefined functions, forward references are particularly common, so mostimplementations wait till the end of the compilation before emitting thewarning.  In the case of undeclared specials, there does not seem to bea good reason to wait, so we warn at once.        As a separate issue, we might want to try to hammer out a proposal for        what people have called "global lexicals", and we might even want to        make this the default for undeclared symbols used free.    If you look at the proposal carefully you'll see that it contains    exactly this; namely, in the GENERAL and RESTRICTED alternatives, you    can do (PROCLAIM '(LEXICAL ...)).  I'm wondering how you missed    it...I didn't miss it.  Your GENERAL and RESTRICTED proposals seem to re-opena debate that we had some time ago on "global" or "global lexical"variables and what their semantics should be.  A lot of hairy issuescame up in that discussion, and I didn't see those issues beingaddressed here.  So my suggestion was that we ought to separate thisissue from the business about inhibiting warnings and try to come upwith a comprehensive proposal on global variables -- comprehensive inthe sense that we try to deal with all the issues raised in the earlierdiscussion.-- Scott*start*03618 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 02 MAY 87 13:15:39 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 2 May 87  13:13:03 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sat 2 May 87 16:13:50-EDTDate: Sat, 2 May 87 16:13 EDTMessage-ID: <FAHLMAN.12299231012.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: PROCLAIM-LEXICALIn-reply-to: Msg of 28 Apr 1987  16:35-EDT from Jonathan A Rees <JAR at AI.AI.MIT.EDU><Is JAR on CL-CLEANUP now?  If not, we should all include him in theaddress list while discussing this.>I think that this proposal is confused.  The current rule for handling areference to a variable that is neither bound nor declared isunambiguous: the variable is assumed to be special.  There is noambiguity and no need for clarification.  Whether we want to change thisis another question, and an interesting one.      However, if you feed this program to many Common Lisp compilers      (including Symbolics's and DEC's), a warning message will be      produced for the SETQ, saying something like "Warning: X not      declared or bound, assuming special."      These warnings, unlike the annotations of undefined functions (which      occur only at the end of a compilation), are presented so      prominently that a user would be hard put to say that a program      which elicited such warning messages was "correct" in that      implementation.  Unlike the situation with unused variables, there is      no possible declaration one can write which suppresses the warning      messages.Not true.  You can suppress this warning by saying (proclaim '(special<var>)) or (defvar <var>).In my view (the manual doesn't spell this out, so we rely on sharedculture) a Common Lisp compiler is free to issue a warning any time itspots anything suspicious, even though the code may be legal.  The moreof this a compiler does, the better it is as a debugging aid (up to thepoint where the "crying wolf" effect sets in because too many spuriouswarnings are being generated).  The use of an undeclared variable islegal because users like to do this in the interpreter; in a code file,on the other hand, it is either very unstylish or, more likely, theresult of a typo.  In the latter case, I want to see a warning.  If youtell me that I can can't use a warning here because it looks too muchlike an error, then I'll have to create yet another kind of compileroutput ("mild suggestion?") with which I can report these things.I prefer to retain the term warning for this, and to use the term "error"when there really is an error.If a fix really is needed here, it should probably be a compilerdeclaration that suppresses all warnings in a certain stretch of code.Then people who hate to see any warnings can get rid of them, and thoseof use who use them for debugging can have them.  But I see nothingunacceptable or even uncomfortable about the status quo.  Probably thespec should explaint he difference between an error and a warning ratherthan leaving this to the reader's imagination.As a separate issue, we might want to try to hammer out a proposal forwhat people have called "global lexicals", and we might even want tomake this the default for undeclared symbols used free.  But we shouldnot muddle this into a discussion of the current rules or the differencebetween warnings and errors in the compiler.-- Scott*start*03488 00024 US Return-Path: <@SAIL.STANFORD.EDU:JAR@AI.AI.MIT.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 02 MAY 87 16:57:29 PDTReceived: from AI.AI.MIT.EDU by SAIL.STANFORD.EDU with TCP; 2 May 87  16:55:26 PDTDate: Sat, 2 May 87 19:58:08 EDTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  Issue: PROCLAIM-LEXICALTo: Fahlman@C.CS.CMU.EDUcc: cl-cleanup@SAIL.STANFORD.EDUIn-reply-to: Msg of Sat 2 May 1987  16:13 EDT from Scott E. Fahlman <Fahlman at C.CS.CMU.EDU>Message-ID: <194629.870502.JAR@AI.AI.MIT.EDU>    Date: Sat, 2 May 1987  16:13 EDT    From: Scott E. Fahlman <Fahlman at C.CS.CMU.EDU>    Not true.  You can suppress this warning by saying (proclaim '(special    <var>)) or (defvar <var>).*Not* not true!  Look again at the example.  If you declare the variablespecial, you will change the semantics of the program.  In this exampleyou would also have to rename every X that's lexically bound; being anextremely non-local transformation, this is unacceptable.    In my view (the manual doesn't spell this out, so we rely on shared    culture) a Common Lisp compiler is free to issue a warning any time it    spots anything suspicious, even though the code may be legal.I basically agree with this, but you should note that every other sortof warning is avoidable.  E.g. an unreferenced bound variable is often aresult of a program error, but when it's not it can be dealt with by(DECLARE (IGNORE ...)); an OR with only one subform can be a symptom ofa misplaced parenthesis, but where it's the right thing there are waysto get around the problem (make your macros smarter...).  But in thiscase the only way to get rid of the warning is either byalpha-converting or by making the program possibly incorrect, which isdefinitely unfriendly.I don't know how you develop code, but I like to get my programs intoa condition where they do not elicit warnings from the compiler.    The use of an undeclared variable is    legal because users like to do this in the interpreter; in a code file,    on the other hand, it is either very unstylish or, more likely, the    result of a typo.  Why is this any different from an undefined function, which is notsimilarly warned about?  I believe these two situations (forwardreference to a variable and to a function) should be treatedsymmetrically.    If a fix really is needed here, it should probably be a compiler    declaration that suppresses all warnings in a certain stretch of code.Unacceptable in this case (unless we adopt BY-THE-BOOK); many warningsare quite desirable.  I would say a warning is OK if either it indicatesthat an error will happen at run time, or if the code is truly is dubiousstyle AND there is an easy way to fix or annotate the code so that thewarning goes away.    As a separate issue, we might want to try to hammer out a proposal for    what people have called "global lexicals", and we might even want to    make this the default for undeclared symbols used free.If you look at the proposal carefully you'll see that it containsexactly this; namely, in the GENERAL and RESTRICTED alternatives, youcan do (PROCLAIM '(LEXICAL ...)).  I'm wondering how you missed it,although if you only looked at the summary at the top and not the restof the message, that would explain it; the introduction is admittedlymisleading.  I'll fix that next time around.Like I said in the "Status:" line, this is very preliminary.Jonathan*start*01161 00024 US Date:  4 May 87 11:08 PDTFrom: Masinter.paTO: MASINTERSubject: Issue: PROCLAIM-LEXICAL (NOT SENT)My understanding (which is admittedly likely faulty) is that the purpose of PROCLAIM-LEXICAL was not to clear up some possible ambiguities over where a compiler might or might not issue warnings (which is certainly murky given how ill-specified the compiler is), but rather, to provide for the first time a way to reference the "global lexical environment", and to bring the (default) semantics of free variable reference in line with the semantics of free function reference.That is, I agree with you that it is possible and useful to separate the issues of "when the compiler warns" and "what do free variable references mean", but I disagree in the relative priorities. I think we need to decide (and change!) what free variable references mean, by *changing* what otherwise undeclared references mean (and, if possible, adding some additional declarations.)I am not cc'ing cl-cleanup as I should because I am guilty of the sin that I just reminded folks about, of spending time on issues that should slip to a lower priority.*start*01449 00024 US Return-Path: <edsel!bhopal!jonl@navajo.stanford.edu>Received: from navajo.stanford.edu ([36.8.0.48]) by Xerox.COM ; 05 MAY 87 18:38:14 PDTReceived: by navajo.stanford.edu; Tue, 5 May 87 18:36:31 PDTReceived: from bhopal.edsel.uucp by edsel.uucp (2.2/SMI-2.0)	id AA05331; Tue, 5 May 87 18:01:42 pdtReceived: by bhopal.edsel.uucp (3.2/SMI-3.2)	id AA02615; Tue, 5 May 87 17:58:56 PDTDate: Tue, 5 May 87 17:58:56 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8705060058.AA02615@bhopal.edsel.uucp>To: navajo!Masinter.pa%Xerox.COM@navajo.stanford.eduIn-Reply-To: navajo!Masinter.pa@Xerox.COM's message of 5 May 87 11:06 PDT <870505-110857-4729@Xerox>Subject: Your opinion on the multifarious PROCLAIM-LEXICAL issueI thought JAR said he was neutral on the KMP variation; but maybe he wasjust being politic.At any rate, from JAR's misreading of my phrase "declared global" (heunderstood it to mean "has a binding in the global environment"), itwould still appear to me that very few Common Lisper's understandthe subtleties that (DECLARE (GLOBALVAR...)) gives you in Interlisp-D.  I'm somewhat loathe to pursue the issue, since ultimately it would meangiving substance to SETTOPLEVEL,  which is a pain (implementationally)in shallow-binding lisps.  Of course,  this will mean endless arguments with the neophytes as the discover for themselves all the salient issues.-- JonL --*start*03019 00024 US Return-Path: <@SAIL.STANFORD.EDU:edsel!bhopal!jonl@navajo.stanford.edu>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 30 APR 87 16:41:23 PDTReceived: from NAVAJO.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 30 Apr 87  16:38:24 PDTReceived: by navajo.stanford.edu; Thu, 30 Apr 87 16:37:55 PDTReceived: from bhopal.edsel.com by edsel.uucp (2.2/SMI-2.0)	id AA06279; Thu, 30 Apr 87 16:13:47 pdtReceived: by bhopal.edsel.com (3.2/SMI-3.2)	id AA01123; Thu, 30 Apr 87 16:11:01 PDTDate: Thu, 30 Apr 87 16:11:01 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8704302311.AA01123@bhopal.edsel.com>To: navajo!JAR%AI.AI.MIT.EDU@navajo.stanford.eduCc: navajo!CL-Cleanup%SAIL@navajo.stanford.edu, navajo!KMP%MX.LCS.MIT.EDU@navajo.stanford.eduIn-Reply-To: Jonathan A Rees's message of Wed, 29 Apr 87 22:53:15 EDTSubject: Issue: PROCLAIM-LEXICALRe: KMP doesn't suggest ADDING a global lexical environment; the global    lexical environment is already there in the GENERAL and RESTRICTED    proposals.  He merely suggests making it not be identical to the global    dynamic environment.  This would make a total of 4 environments, not 3.Since this "global lexical" environment isn't to be identical with the"global fluid" environment, then it's a "new" environment as far asCommon Lisp is concerned;  that's why I said he was "adding" something.With respect to environments for a "free variable" reference, there are3, not 4, possibilities.  A lexically-bound variable isn't free, and hence not, I thought, of concern to this discussion [which was opened up by your attempt to clarify the semantics of free variables].Have I misread anything here?  Your proposals were clearly worded enough; I only wanted to bring up an objection to the idea of having two totally distinct global environments.  I think calling it an "addition" or notis a really minor point.Re: . . .   I see no reason    to impose this restriction, and I see Scheme compatibility as a big    reason that we SHOULD allow lambda-binding variables which have global    bindings.   . . . I think you misread this completely backwards.  It WASN'T that you couldn't lambda-bind anything that had a binding in the global environment.  It WAS that you couldn't lambda-bind anything that was explicitly declared orproclaimed GLOBAL rather than SPECIAL (or LOCAL?).  In an implementation where the global fluid environment is the same as the top-level environment (the standard state for virtually all deep and shallow bound Lisps -- but not for Lisp 1.5), then a SETtingof any variable without a dynamically intervening lambda-binding wouldjust make a global/top-level binding.  This would happen independently of whether the variable was proclaimed GLOBAL or SPECIAL.  But a variabledelcared GLOBAL would only affect the top-level binding; not any intermediate SPECIAL lambda-bindings.Do you see the difference here? or does this point need more explication?-- JonL --*start*01070 00024 US Return-Path: <edsel!bhopal!jonl@navajo.stanford.edu>Received: from navajo.stanford.edu ([36.8.0.48]) by Xerox.COM ; 06 MAY 87 13:38:38 PDTReceived: by navajo.stanford.edu; Wed, 6 May 87 13:36:53 PDTReceived: from bhopal.edsel.uucp by edsel.uucp (2.2/SMI-2.0)	id AA08416; Wed, 6 May 87 13:04:52 pdtReceived: by bhopal.edsel.uucp (3.2/SMI-3.2)	id AA03461; Wed, 6 May 87 13:02:07 PDTDate: Wed, 6 May 87 13:02:07 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8705062002.AA03461@bhopal.edsel.uucp>To: navajo!masinter.pa%Xerox.COM@navajo.stanford.eduIn-Reply-To: navajo!masinter.pa@Xerox.COM's message of 5 May 87 23:54:12 PDT <870505-235421-1610@Xerox>Subject: Your opinion on the multifarious PROCLAIM-LEXICAL issueRight, except that deep-bound lisps typically already have both --GETTOPVAL and SYMBOL-VALUE -- whereas shallow-bound lisps have electednot to do GETTOPVAL.  So those implementors may be in for a surprise;at the very least, probably, some of them will argue the issue endlessly.-- JonL --*start*11070 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 15 MAY 87 21:45:35 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 15 May 87  21:44:31 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 141562; Sat 16-May-87 00:44:03 EDTDate: Sat, 16 May 87 00:43 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICALTo: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <192342.870428.JAR@AI.AI.MIT.EDU>,             <870428185220.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>,             <870428-220403-2039@Xerox>,             <870429093550.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>,             <192793.870429.JAR@AI.AI.MIT.EDU>,             <8704292330.AA13102@bhopal.edsel.com>,             <870429222608.2.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <193127.870429.JAR@AI.AI.MIT.EDU>,             <8704300644.AA13625@bhopal.edsel.com>,             <8704302311.AA01123@bhopal.edsel.com>,             <193809.870430.JAR@AI.AI.MIT.EDU>,             <8705012012.AA00639@bhopal.edsel.uucp>,             <FAHLMAN.12299231012.BABYL@C.CS.CMU.EDU>,             <194629.870502.JAR@AI.AI.MIT.EDU>,             <FAHLMAN.12299293460.BABYL@C.CS.CMU.EDU>Message-ID: <870516004312.6.MOON@EUPHRATES.SCRC.Symbolics.COM>I finally found the time to read this huge pile of mail carefully and thinkclearly about it.  Here's my considered opinion, but before telling youwhich proposal I support I'd like to clear away some underbrush.  Iapologize for the 200 line length, but I can't make all the conceptsunambiguously clear with a briefer speech.We speak of cells, which are conceptual locations that remember a value andcan be read and written.  Sometimes these conceptual locations areimplemented by actual memory locations, and sometimes they aren't, butthat's an implementation detail and is irrelevant here.  (Sometimes theseare called variables, but other times the word "variable" means somethingelse, so for the sake of clarity I'm not going to use the word "variable".)Right now, Common Lisp has two kinds of cells: global cells and localcells.  Local cells have lexical extent, while global cells have globalextent and can be referenced from anywhere except where they are shadowedby a local cell referenced by the same name.Right now, Common Lisp has two kinds of binding:  Lexical binding creates anew local cell.  Special binding saves the value of a global cell, gives ita new value during the extent of the binding, and later restores the oldvalue.  We know that special binding saves and restores because of whatother functions see when they read the cell.  Please don't get confusedwith issues of shallow-bound versus deep-bound implementation, which areirrelevant here: I said cells are not the same thing as memory locations.Note that I am carefully using different words for the two kinds of cellsfrom the words for the two kinds of binding; lack of differentiation herehas led to a lot of confusion, I think.Right now, Common Lisp has a fairly complicated set of rules for how todetermine what cell is referenced when a program mentions a variable name.(When I say "lexically free", I mean outside of all bindings of that name,regardless of whether those bindings are special or lexical.)  1. If the reference is lexically free, use the global cell.  2. Otherwise, in the absence of a SPECIAL declaration use the cell that     was affected by the innermost binding; if that binding was special,     use the global cell; if it was lexical, use the local cell created     by that binding.  3. Otherwise, the SPECIAL declaration forces use of the global cell.We certainly do not want to introduce a third kind of cell, because thatwould lead to a great deal of confusion.  Nor do we want to introduce athird kind of binding.  What we -are- trying to accomplish is to make theprimitive concepts orthogonally available.  An example of a problem we haveright now that needs to be fixed is that there is no way to say that a nameis not misspelled without simultaneously saying that bindings of that nameshould be special rather than lexical.  These concepts should be availableas separate constructs.There are four things that we would like to be able to proclaim abouta variable name (aside from TYPE): - the default kind of binding if no declaration specifies which kind - the name is not misspelled so don't warn about free references - it is illegal to specially bind the global cell, because it is   a constant or because we want to optimize the performance of a   deep-binding implementation - it is illegal to store into the global cell, because it is a constantIt is already possible in Common Lisp to proclaim all four of these things,but some of them are mixed up with other concepts and not separatelyavailable.  Let's pick names for the four kinds of proclamations, and let'salso agree that any proclamation serves the "not misspelled" purpose.  Let'sfurther agree that these four proclamations are mutually exclusive.  LEXICAL  -- does nothing other than "not misspelled"  SPECIAL  -- changes the default kind of binding from lexical to special  GLOBAL   -- makes it illegal to specially bind the global cell  CONSTANT -- makes it illegal to store into the global cell              CONSTANT implies GLOBAL because special-binding is storingSPECIAL exists now.  LEXICAL is Rees's proposal.  CONSTANT exists nowbut only buried inside the DEFCONSTANT macro.  GLOBAL exists now butonly when implied by DEFCONSTANT.  I propose to make CONSTANT andGLOBAL explicitly available.It appears to be appropriate to make CONSTANT and GLOBAL proclamationschange the default kind of binding to "illegal", rather than leavingit lexical.Now we have to ask what these proclamations mean as declarations.Let us agree that they have the same scoping rules as the SPECIALdeclaration, i.e. they can be attached to a binding and they canalso be wrapped around references, which they pervasively affectuntil shadowed by the next declaration or binding.LEXICAL attached to a binding forces the binding to be lexical evenif there is a SPECIAL, GLOBAL, or CONSTANT proclamation.  LEXICALshadows the effect of a special binding on references; therefore wemust add another rule to the "complicated set":  4. Otherwise, a LEXICAL declaration forces use of the local cell     created by the innermost lexical binding of the name, or if there     is none, use of the global cell.SPECIAL means the same as it has always meant in Common Lisp.GLOBAL or CONSTANT attached to a binding makes the binding illegal.GLOBAL or CONSTANT affects a reference by forcing it to use the globalcell, thus rule 3 in the "complicated set" must be modified to treat GLOBALand CONSTANT the same as SPECIAL.  We could also just make GLOBAL andCONSTANT illegal as declarations.  Another idea would be to make CONSTANTas a declaration allow you to create a new lexical constant.  I'm going totake the path of least addition to the language and make them illegal.Note that PROCLAIM-LEXICAL:RESTRICTED conflates LEXICAL and GLOBAL, whichseems undesirable to me.  We want to make each primitive concept separatelyavailable.Okay, so which proposal do I support?  Well, I support a slight modificationof PROCLAIM-LEXICAL:GENERAL, which I will now explicate (text mostlycopied from Rees):Proposal (PROCLAIM-LEXICAL:GENERAL+GLOBAL):  Introduce new declaration specifiers, LEXICAL, GLOBAL, and CONSTANT, which  are mutually exclusive with the SPECIAL declaration specifier.  All four  may be used as proclamations; only SPECIAL and LEXICAL may be used as  declarations.  A name may be proclaimed only one of LEXICAL, SPECIAL, GLOBAL, or  CONSTANT.  A name is said to be unproclaimed if it has not been  proclaimed to be any of these four.  A free reference or assignment to a name is an error if it is  unproclaimed and undeclared.  A LAMBDA-binding in the absence of a declaration or proclamation binds  the lexical variable.  SPECIAL proclamations and declarations behave as defined in CLtL.  LEXICAL proclamations have no effect other than to make the name  cease to be unproclaimed.  LEXICAL declarations shadow all enclosing  declarations and proclamation of any of these four types.  LEXICAL  declarations have the same scoping rules as SPECIAL declarations.  GLOBAL proclamations make it an error to bind the name.  CONSTANT proclamations make it an error to bind the name and an  error to assign to the name.  DEFCONSTANT is defined in terms of SETQ and the CONSTANT proclamation.  All keyword symbols are automatically proclaimed CONSTANT.  A free reference or assignment accesses the same value regardless  of the declaration or proclamation.  This is called the global value.  SPECIAL binding alters the global value within its extent.  (Multiple process and multiple processor systems will have to make  their own definitions of the extent of a SPECIAL binding, as noted  on p.38 of CLtL--this proposal is not a proposal to standardize that.)  The preceding paragraph should be understood carefully.  There is only  one global value for a name and it is used by all free references, all  free assignments, and all SPECIAL bindings.  Example:    (proclaim '(lexical x))    (proclaim '(special y))    (setq x 1 y 2)    (defun tst ()      (let ((x 3) (y 4))	(locally (declare (special x) (lexical y))	  (list x y	        (funcall (let ((x 5) (y 6))			   #'(lambda () (list x y))))))))    (tst) => (1 4 (5 4))Note that the second element of the list is different fromthe value, 2, it would have in PROCLAIM-LEXICAL:GENERAL.That is because the special binding of y changes the globalvalue to 4, and the declared-lexical reference to y accessesthe global value, since there is no surrounding lexical binding.Cost of adopting change:  I believe this is the same as current practice as specified by CLtL,  except that all of the primitive concepts have been made visible instead  of being hidden inside other concepts.  Compilers and interpreters  will need to support LEXICAL as a declaration.  Referencing or assigning to an unproclaimed and undeclared name  "is an error", not "signals an error", which allows but does not  require an implementation to issue a warning.  This is a change from  current language but does not mandate a change from current practice.Benefits:  LEXICAL proclamation enhances compatibility with Scheme.  GLOBAL proclamation allows more efficient deep-bound implementations  and enhances compatibility with Interlisp and VMLISP.Cost of converting existing code:  None, it's upward compatible.Aesthetics:  The "insidious and disgusting aspect" doesn't get any worse.  Making  primitive concepts explicitly available can only enhance aesthetics.Discussion:  Let's hear it!*start*01200 00024 US Return-Path: <@SAIL.STANFORD.EDU:edsel!bhopal!jonl@navajo.stanford.edu>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 16 MAY 87 03:19:16 PDTReceived: from NAVAJO.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 16 May 87  03:02:07 PDTReceived: by navajo.stanford.edu; Sat, 16 May 87 02:58:25 PDTReceived: from bhopal.edsel.uucp by edsel.uucp (2.2/SMI-2.0)	id AA10964; Sat, 16 May 87 01:33:58 pdtReceived: by bhopal.edsel.uucp (3.2/SMI-3.2)	id AA09180; Sat, 16 May 87 01:35:27 PDTDate: Sat, 16 May 87 01:35:27 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8705160835.AA09180@bhopal.edsel.uucp>To: navajo!Moon%STONY-BROOK.SCRC.Symbolics.COM@navajo.stanford.eduCc: navajo!cl-cleanup%SAIL@navajo.stanford.eduIn-Reply-To: David A. Moon's message of Sat, 16 May 87 00:43 EDT <870516004312.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICALYour summary of the "proclamation" issue is excellent.  It delineates allthe separate issues very well, and also it incorporates all the points I have made in previous notes about these matters.   So I for one would be quite happy to see your revised proposal accepted.-- JonL --*start*03968 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 17 MAY 87 14:48:28 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 17 May 87  14:47:28 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 17 May 87 17:46:49-EDTDate: Sun, 17 May 87 17:46 EDTMessage-ID: <FAHLMAN.12303180096.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: PROCLAIM-LEXICALIn-reply-to: Msg of 16 May 1987  00:43-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>I think that Moon's analysis of this issue is right on the mark, and Ilike his proposal except for two points:First, it is made clear that only one of SPECIAL, LEXICAL, GLOBAL, orDYNAMIC can be in effect for a variable at any one time, but theproposal does not address the question of whether you can over-ride anold proclamation in this set by issuing a new one.  We have to addressthat, I think, and it is a moderately complex question.It seems to me that we want to allow a variable to be re-proclaimed fortwo reasons: to correct proclmations issued in error by the user,without having to kill off the Lisp and start over, and to make iteasier to merge programs written by two different programmers.  (Thelatter reason may be bogus -- these guys shouldn't be in the samepackage anyway -- but there are times when a quick-and-dirty fix isextremely handy.)  On that other hand, we want the compiler to be ableto wire certain things in tight as a result of these proclamations, sowe need to make clear that if you proclaim something to be GLOBAL,compile some code, then proclaim it to be SPECIAL and then compile somemore code the rebinds this variable, you may not get what you expect.Same with unconstantifying a constant.If Rob's compiler proposal, or something like it, were in effect, wecould probably explain what the rules are within that framework.However, given the current state of things, it might be best to say thatit "is an error" to re-proclaim a variable into a different class --this says that portable code cannot do this and count on the result --but that implementations are strongly urged to allow thisre-proclamation as a way of correcting erroneous proclamations, perhapsissuing a warning or signalling a correctable error whenever aproclamation actually gets changed.The second problem is Moon's suggestion that it should be an error toassign or reference an unproclaimed and undeclared variable.  Theproblem I have with this is that most of us like to be able to do thingswith undeclared variables in the interpreter -- stashing things inmade-up variables like FOO -- and I think that there will be blood inthe streets if we take this away from people or if the interpreter isrequired to hassle them for not declaring the variable before using it.And yet, when the compiler comes across an undeclared variable, I wantto get a warning, especially now that I can use a LEXICAL proclamationto flush that warning with no other side effects.I think that the right move is to say that accessing and referencing anundeclared variable is legal, and that such references access the globalcell while leaving the variable in unproclaimed state.  We should thenencourage (require?) compiler writers to issue a warning in such cases.Of course, if you believe that the compiler has no business warningabout anything that is technically legal (and some wording in Moon's"cost of adoption" section suggests to me that he may be in this camp),then the above proposal is a non-sequitur.  In my view, however, thecompiler may issue a warning about code that is legal but suspicious,though I agree with Rees that in all such cases there should besomething you can put in a program to say, "Shut up, I know what I'mdoing here."  The LEXICAL proclamation gives us that.-- Scott*start*02495 00024 US Return-Path: <@SAIL.STANFORD.EDU:edsel!bhopal!jonl@navajo.stanford.edu>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 MAY 87 15:38:42 PDTReceived: from NAVAJO.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 1 May 87  15:36:11 PDTReceived: by navajo.stanford.edu; Fri, 1 May 87 15:35:37 PDTReceived: from bhopal.edsel.uucp by edsel.uucp (2.2/SMI-2.0)	id AA09971; Fri, 1 May 87 13:15:07 pdtReceived: by bhopal.edsel.uucp (3.2/SMI-3.2)	id AA00639; Fri, 1 May 87 13:12:21 PDTDate: Fri, 1 May 87 13:12:21 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8705012012.AA00639@bhopal.edsel.uucp>To: navajo!JAR%AI.AI.MIT.EDU@navajo.stanford.eduCc: navajo!KMP%AI.AI.MIT.EDU@navajo.stanford.edu, navajo!CL-Cleanup%SAIL@navajo.stanford.eduIn-Reply-To: Jonathan A Rees's message of Thu, 30 Apr 87 22:03:41 EDTSubject: Issue: PROCLAIM-LEXICALI believe that the deep-binders would be satisfied with top-level environment being called "global lexical", providing that the "global special" (or, "global fluid" if you will) is the same.  The main issue is: What does a special reference mean when there is no dynamically intervening special binding?   Is it ok for it to access the "globallexical" binding?  I wouldn't want to go so far as to make an alternative proposal, providing you agree that this is no problem with the singletop-level environment.   [Larry -- could you volunteer some opinion?This issue will probably affect Xerox's Lisp the most?].  Re: Getting back to terminology: why do you think LOCAL is a better name    than LEXICAL?  LEXICAL seems more general and more descriptive ...To me, "lexical" means "lexically apparent", or "lexically constrained".In the example:     (DEFUN FOO (X) (DECLARE (SPECIAL X))  (LIST (BAR X) (BAR X)))both instances of "X" in the calls to "BAR" are "lexical" with respectto its binding;  but "X" isn't lexically bound, it is dynamically bound.[Note also; it is not "free".]   Consider the (free) occurances of "X" in some other module, which in fact might access the value of this binding; they are not "lexically apparent".  For this reason -- wanting to talk about lexical context and not imply anything about the bindings of variables therein -- I tend to prefer another term for the opposite of SPECIAL.  But I'm not at all enamored with the term LOCAL, or evenUNSPECIAL;  LEXICAL would be ok as long as the documentation clearly stressed this point.  -- JonL --*start*01320 00024 US Return-Path: <@SAIL.STANFORD.EDU:gls@Think.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 18 MAY 87 13:45:38 PDTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 18 May 87  13:44:21 PDTReceived: from boethius by Think.COM via CHAOS; Mon, 18 May 87 16:46:47 EDTDate: Mon, 18 May 87 16:44 EDTFrom: Guy Steele <gls@Think.COM>Subject: Issue: PROCLAIM-LEXICALTo: cl-cleanup@sail.stanford.eduCc: gls@think.comIn-Reply-To: <870516004312.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-Id: <870518164427.1.GLS@BOETHIUS.THINK.COM>I am in agreement with everything Moon has said, except for thefollowing paragraph:    Right now, Common Lisp has two kinds of cells: global cells and local    cells.  Local cells have lexical extent, while global cells have global    extent and can be referenced from anywhere except where they are shadowed    by a local cell referenced by the same name.I believe this paragraph confuses the notions of extent and scope.In the terminology of CLTL chapter 3, both kinds of cell haveindefinite extent (but the bindings of a global cell have dynamicextent).  The *names* used to refer to these cells have lexicaland <???> scope, respectively.If this bit of language were to be cleaned up, I would favor somethinglike Moon's proposal.--Guy*start*01238 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 18 MAY 87 15:30:44 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 18 May 87  15:29:33 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 142936; Mon 18-May-87 18:28:46 EDTDate: Mon, 18 May 87 18:28 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICALTo: cl-cleanup@sail.stanford.eduIn-Reply-To: <870518164427.1.GLS@BOETHIUS.THINK.COM>Message-ID: <870518182849.9.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 18 May 87 16:44 EDT    From: Guy Steele <gls@Think.COM>    I am in agreement with everything Moon has said, except for the    following paragraph:	Right now, Common Lisp has two kinds of cells: global cells and local	cells.  Local cells have lexical extent, while global cells have global	extent and can be referenced from anywhere except where they are shadowed	by a local cell referenced by the same name.    I believe this paragraph confuses the notions of extent and scope.Quite right.  I must have meant to say "scope", but spazzed.*start*04687 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 19 MAY 87 17:40:58 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 19 May 87  17:39:21 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 144321; Tue 19-May-87 20:38:25 EDTDate: Tue, 19 May 87 20:38 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICALTo: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12303180096.BABYL@C.CS.CMU.EDU>Message-ID: <870519203829.5.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sun, 17 May 1987  17:46 EDT    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>I think I forgot to answer this, but if you're seeing it twice, I apologize.    I think that Moon's analysis of this issue is right on the mark, and I    like his proposal Thanks.		      except for two points:    First, it is made clear that only one of SPECIAL, LEXICAL, GLOBAL, or    DYNAMIC CONSTANT, you mean.	    can be in effect for a variable at any one time, but the    proposal does not address the question of whether you can over-ride an    old proclamation in this set by issuing a new one.  We have to address    that, I think, and it is a moderately complex question.I think this is an environment issue rather than a language issue.    ....    If Rob's compiler proposal, or something like it, were in effect, we    could probably explain what the rules are within that framework.I think Rob's proposal would only tell us how to compile a program thatproclaims a variable one way inside a Lisp that proclaims it another way,but not what happens when the result of that compilation is loaded intothat Lisp.    However, given the current state of things, it might be best to say that    it "is an error" to re-proclaim a variable into a different class --    this says that portable code cannot do this and count on the result --    but that implementations are strongly urged to allow this    re-proclamation as a way of correcting erroneous proclamations, perhaps    issuing a warning or signalling a correctable error whenever a    proclamation actually gets changed.In other words, it's an environment issue.  I agree that it should be"is an error" rather than "signals an error"; I think this is an excellentexample of something where program development environments should haveflexibility and, conversely, no portable program would rely on the errorbeing signalled and want to handle it (using conditions).    The second problem is Moon's suggestion that it should be an error to    assign or reference an unproclaimed and undeclared variable.  Actually I just copied that from Rees.								  The    problem I have with this is that most of us like to be able to do things    with undeclared variables in the interpreter -- stashing things in    made-up variables like FOO -- and I think that there will be blood in    the streets if we take this away from people or if the interpreter is    required to hassle them for not declaring the variable before using it.That's why it's "is an error" rather than "signals an error", isn't it?Is using undeclared variables in the interpreter something for portableprograms to rely on being able to do, or just something for human users?    And yet, when the compiler comes across an undeclared variable, I want    to get a warning, especially now that I can use a LEXICAL proclamation    to flush that warning with no other side effects.    I think that the right move is to say that accessing and referencing an    undeclared variable is legal, and that such references access the global    cell while leaving the variable in unproclaimed state.  We should then    encourage (require?) compiler writers to issue a warning in such cases.That would be okay with me, however people in general might prefer that wejust say it's an error and not try to dictate what the compiler should do.I have no strong opinion here.    Of course, if you believe that the compiler has no business warning    about anything that is technically legal (and some wording in Moon's    "cost of adoption" section suggests to me that he may be in this camp),    then the above proposal is a non-sequitur.  In my view, however, the    compiler may issue a warning about code that is legal but suspicious,    though I agree with Rees that in all such cases there should be    something you can put in a program to say, "Shut up, I know what I'm    doing here."  The LEXICAL proclamation gives us that.True.*start*03453 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 19 MAY 87 18:13:35 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 19 May 87  18:12:08 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 19 May 87 21:11:08-EDTDate: Tue, 19 May 87 21:10 EDTMessage-ID: <FAHLMAN.12303741560.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: PROCLAIM-LEXICALSorry, I hit the wrong key and shot that last message off before I wasdone editing... In reply to: David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>        However, given the current state of things, it might be best to say that        it "is an error" to re-proclaim a variable into a different class --        this says that portable code cannot do this and count on the result --        but that implementations are strongly urged to allow this        re-proclamation as a way of correcting erroneous proclamations, perhaps        issuing a warning or signalling a correctable error whenever a        proclamation actually gets changed.    In other words, it's an environment issue.  I agree that it should be    "is an error" rather than "signals an error"; I think this is an excellent    example of something where program development environments should have    flexibility and, conversely, no portable program would rely on the error    being signalled and want to handle it (using conditions).OK, I think we agree that "is an error" would be the best thing here.I'd like to see some indication in the proposal (maybe down in thediscussion part) that this particular "is an error" is one that someinterpreters might choose to tolerate (preferably with some warning) forthe convenience of interactive users.  Some people equate "is an error"with "don't do it" rather than "don't depend on it in portable code".        The second problem is Moon's suggestion that it should be an error to        assign or reference an unproclaimed and undeclared variable.  The        problem I have with this is that most of us like to be able to do things        with undeclared variables in the interpreter -- stashing things in        made-up variables like FOO -- and I think that there will be blood in        the streets if we take this away from people or if the interpreter is        required to hassle them for not declaring the variable before using it.    That's why it's "is an error" rather than "signals an error", isn't it?    Is using undeclared variables in the interpreter something for portable    programs to rely on being able to do, or just something for human    users?Well, you're right in saying that "is an error" would be the right thingif our ONLY concern were portable programs.  That's our main concern,but not our only one.  I would still like to be able to do a few typicalinterpreter things in any legal Common Lisp, and this is one of thosethings.  So I am strongly opposed to any proposal that says it is OK for(setq foo 27) not to work in some Common Lisp interpreters.So I feel pretty strongly that my earlier formulation was thebest one: references and assignments of undeclared/unproclaimedvariables refer to the global cell, but leave the variable undeclared.And compilers are allowed (not required) to warn about such references.-- Scott*start*00927 00024 USaReturn-Path: <edsel!bhopal!jonl@navajo.stanford.edu>Received: from navajo.stanford.edu ([36.8.0.48]) by Xerox.COM ; 04 MAY 87 22:56:30 PDTReceived: by navajo.stanford.edu; Mon, 4 May 87 22:54:43 PDTReceived: from bhopal.edsel.uucp by edsel.uucp (2.2/SMI-2.0)	id AA01807; Mon, 4 May 87 21:48:11 pdtReceived: by bhopal.edsel.uucp (3.2/SMI-3.2)	id AA01410; Mon, 4 May 87 21:45:29 PDTDate: Mon, 4 May 87 21:45:29 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8705050445.AA01410@bhopal.edsel.uucp>To: navajo!masinter%Xerox.com@navajo.stanford.eduSubject: Your opinion on the multifarious PROCLAIM-LEXICAL issueI'd have thought you'd be more interested in this, due to the implicationsfor a deep-binding lisp.  Why no comment from you? especially on KMP'sdilletante suggestion that the global-lexical and global-dynamic be totallyseparate environments?-- JonL --*start*00659 00024 US Return-Path: <JAR@AI.AI.MIT.EDU>Received: from AI.AI.MIT.EDU by Xerox.COM ; 01 JUN 87 12:18:46 PDTDate: Mon, 1 Jun 87 15:19:35 EDTFrom: "Jonathan A. Rees" <JAR@AI.AI.MIT.EDU>Subject:  Status, Part 2To: Masinter.pacc: cl-cleanup@SAIL.STANFORD.EDUIn-reply-to: Msg of 29 May 87 22:42 PDT from Masinter.pa at Xerox.COMMessage-ID: <208084.870601.JAR@AI.AI.MIT.EDU>    Date: 29 May 87 22:42 PDT    From: Masinter.pa at Xerox.COM    PROCLAIM-LEXICAL  (Version 1)    	In discussion    	Reaching convergence    	Need volunteer to merge comments into new versionI think that "reaching convergence" is a little too optimistic.*start*01161 00024 USmReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 01 JUN 87 15:21:25 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 160975; Mon 1-Jun-87 18:20:53 EDTDate: Mon, 1 Jun 87 18:22 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Status, Part 2 -- PROCLAIM-LEXICALTo: Masinter.pacc: JAR@AI.AI.MIT.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <208084.870601.JAR@AI.AI.MIT.EDU>Message-ID: <870601182241.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Mon,  1 Jun 87 15:19:35 EDT    From: "Jonathan A. Rees" <JAR@AI.AI.MIT.EDU>	Date: 29 May 87 22:42 PDT	From: Masinter.pa at Xerox.COM	PROCLAIM-LEXICAL  (Version 1)	    In discussion	    Reaching convergence	    Need volunteer to merge comments into new version    I think that "reaching convergence" is a little too optimistic.I strongly second this comment. Some progress has been made, but I thinkthere's a long way to go. Just "In discussion" should suffice for now;I'd strike line 2.*start*03299 00024 US Originator: @SAIL.STANFORD.EDU:edsel!bhopal!jonl%labrea.stanford:EDU:XeroxDate:  3 Aug 87 23:44From: edsel!bhopal!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: David A. Moon's message of Mon, 3 Aug 87 16:18 EDT <870803161813.4.MOON@EUPHRATES.SCRC.Symbolics.COMSubject: LET-CONSTANT [or "Anonymous Constants"]To: labrea!Moon%STONY-BROOK.SCRC.Symbolics.COM%labrea.stanford:EDU:Xeroxcc: bhopal!eb%labrea.stanford:EDU:Xerox, labrea!barmar%Think.COM%labrea.stanford:EDU:Xerox, labrea!common-lisp%sail%labrea.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: edsel!bhopal!jonl@labrea.stanford.edu (Jon L White)To: labrea!Moon%STONY-BROOK.SCRC.Symbolics.COM@labrea.stanford.eduCc: bhopal!eb@labrea.stanford.edu, labrea!barmar%Think.COM@labrea.stanford.edu, labrea!common-lisp%sail@labrea.stanford.eduIn-Reply-To: David A. Moon's message of Mon, 3 Aug 87 16:18 EDT <870803161813.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: LET-CONSTANT [or "Anonymous Constants"]Return-Path: <@SAIL.STANFORD.EDU:edsel!bhopal!jonl@labrea.stanford.edu>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 03 AUG 87 23:44:42 PDTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 3 Aug 87  23:17:51 PDTReceived: by labrea.stanford.edu; Mon, 3 Aug 87 23:05:15 PDTReceived: from bhopal.edsel.uucp by edsel.uucp (3.2/SMI-2.0)	id AA12283; Mon, 3 Aug 87 23:00:28 PDTReceived: by bhopal.edsel.uucp (3.2/SMI-3.2)	id AA00205; Mon, 3 Aug 87 22:57:55 PDTOriginal-Date: Mon, 3 Aug 87 22:57:55 PDTMessage-Id: <8708040557.AA00205@bhopal.edsel.uucp>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVA compiler can figure out that a local variable isn't being setq'd, and hence can propogate through the binding as a constant literal *providing*that it can determine that the form it is being bound to is a constant.Admittedly, that seems to be the thrust of the messages so far -- doescommon lisp need a local constant declaration for variables -- and I think the answer is, as you phrase it, "no, because any information that such a declaration provides can equally well be discerned mechanicallyby the compiler."  But I see the need for a local constant declaration for random expressions apart from the issue of properties of program variables.  "AnonymousConstants", if you will.  Consider for example Interlisp's [special-form] function CONSTANT:   (let ((x (constant `(JonL-phone-no ,(call-up-bell-tel-co)))))     (check-phone-book x)      (broadcast-to-friends x (constant (figger-out-broadcast-routing)))     x)Without the very-local "declaration" provided by 'constant', the compilerwould be obliged NOT to propogate the binding value of x, and not toelide the runtim calls to 'call-up-bell-tel-co', 'list', and the totallyrandom 'figger-out-broadcast-routing'.  [And also not to create the list ina static, or read-only area, etc.]Using 'constant' rather than #. is more of an issue in Interlisp style -- the "residential" style as opposed to the EMACS style -- but I don'tthink it should be ignored in CL.  In fact, a later addition to Interlisp was 'loadtimeconstant', which is a functionality that has been under active discussion on this mailing list in recent weeks.-- JonL --*start*01888 00024 USaOriginator: @SAIL.STANFORD.EDU:Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxDate:  3 Aug 87 17:28From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Re: New special form suggestion: LET-CONSTANTIn-Reply-to: <8708031628.AA00890@HADES.MIT.EDU>To: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: New special form suggestion: LET-CONSTANTTo: common-lisp@sail.stanford.eduIn-Reply-To: <8708031628.AA00890@HADES.MIT.EDU>Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 03 AUG 87 17:28:12 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 3 Aug 87  16:58:43 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 205940; Mon 3-Aug-87 19:59:39 EDTOriginal-Date: Mon, 3 Aug 87 19:59 EDTMessage-ID: <870803195934.6.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon, 03 Aug 87 12:28:38 EDT    From: <samalone@ATHENA.MIT.EDU>	It seems like a LET-CONSTANT special form....    As an alternative, I recommend a CONSTANT declaration.The Cleanup subcommittee of X3J13 were discussing just that in May, incidentalto another proposal for language cleanup.  Perhaps such a declaration is a goodidea.  Presumably it would mean that the compiler is allowed to assume that thevariable is never setq'ed and the variable's value is never side-effected(e.g. if an array, its elements are not changed and not side-effected themselves),and the compiler is encouraged to complain if it can prove that these assumptionsare violated.Right now that cleanup proposal is in limbo but perhaps it will get more attentionlater.*start*01063 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 04 AUG 87 10:08:42 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 206326; Tue 4-Aug-87 13:09:14 EDTDate: Tue, 4 Aug 87 13:08 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: New special form suggestion: LET-CONSTANTTo: Masinter.paIn-Reply-To: <870804-100020-3112@Xerox>Message-ID: <870804130853.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 4 Aug 87 10:00 PDT    From: Masinter.pa@Xerox.COM    You'll have to remind me about the proposal. I thought that all of the    declaration/constant stuff was deferred to the compiler committee.It was an aside in PROCLAIM-LEXICAL.  Maybe we deep-sixed that issue bygiving it to the compiler committee, I don't remember anything exceptthat I need to get together with Rees and figure out why he and I don'tquite agree on what's going on there.*start*13070 00024 USfDate: 27 Oct 87 13:40 PSTFrom: Masinter.paSubject:  Issue: PROCLAIM-LEXICAL (Version 4) To: cl-cleanup@SAIL.STANFORD.EDU, JAR@AI.AI.MIT.EDUcc: Masinterline-fold: 80I'm still not very happy with this, if only because the proposed solution is not really motivated well by the problem described.I attempted to reword the various discussion elements to reflect later comments and agreements.We let this one slip. Issue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37),              global variables (p68),	         declaration specifiers (p157)Category:     ENHANCEMENTEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87Problem Description:CLtL pp. 55-56 implies that if a name (symbol) is not proclaimed or declared special, then a free reference to that name is a reference to the special variable of that name, while a LAMBDA-binding of that name indicates a binding of the lexical variable of that name.  This would mean that the following program is legal and that (TST) => 4:    (defun tst ()      (setq x 3)      (funcall (let ((x 4)) #'(lambda () x))))However, if you feed this program to many Common Lisp compilers, a warning message will be produced for the SETQ, saying something like "Warning: X not declared or bound, assuming special."These warnings, unlike the annotations of undefined functions (which occur only at the end of a compilation), are presented so prominently that a user would be hard put to say that a program which elicited such warning messages was "correct" in that implementation.  Unlike the situation with unused variables, there is no possible declaration one can write which suppresses the warning messages. This disagreement between theory and practice should be mended somehow.There is no way to "undo" a SPECIAL proclaimation. Several aspects of variable declarations (including whether the variable is a constant, never rebound, and the like) are impossible in portable Common Lisp, although they exist in several implementations.Proposal (PROCLAIM-LEXICAL:ADD-LEXICAL-GLOBAL-CONSTANT):Introduce new declaration specifiers, LEXICAL, GLOBAL, and CONSTANT, which are mutually exclusive with the SPECIAL declaration specifier.  All four may be used as proclamations; only SPECIAL and LEXICAL may be used as declarations.A name may be proclaimed only one of LEXICAL, SPECIAL, GLOBAL, or CONSTANT.  A name is said to be unproclaimed if it has not been proclaimed to be any of these four.A free reference or assignment to a name is an error if it is unproclaimed and undeclared. (While we expect many programming environments to allow such references in interactive programming, no portable program should rely on free references to unproclaimed and undeclared variables; compiler warnings when encountering them are encouraged.) A LAMBDA-binding in the absence of a declaration or proclamation binds the lexical variable.SPECIAL proclamations and declarations behave as defined in CLtL.LEXICAL proclamations have no effect other than to make the name cease to be unproclaimed.  LEXICAL declarations shadow all enclosing declarations and proclamation of any of these four types.  LEXICAL declarations have the same scoping rules as SPECIAL declarations.GLOBAL proclamations make it an error to bind the name.CONSTANT proclamations make it an error to bind the name and an error to assign to the name.DEFCONSTANT is defined in terms of SETQ and the CONSTANT proclamation. All keyword symbols are automatically proclaimed CONSTANT.A free reference or assignment accesses the same value regardless of the declaration or proclamation.  This is called the global value. SPECIAL binding alters the global value within its extent. (Multiple process and multiple processor systems will have to make their own definitions of the extent of a SPECIAL binding, as noted on p.38 of CLtL--this proposal does not address that.)There is only one global value for a name and it is used by all free references, all free assignments, and all SPECIAL bindings.It is an error to re-proclaim a variable to a different class. (We expect this issue to revisited by the compiler committee, see discussion below.) Example:  (proclaim '(lexical x))  (proclaim '(special y))  (setq x 1 y 2)  (defun tst ()     (let ((x 3) (y 4))	(locally (declare (special x) (lexical y))	  (list x y	        (funcall (let ((x 5) (y 6))			   #'(lambda () (list x y))))))))    (tst) => (1 4 (5 4))Note that the second element of the list is 2. That is because the special binding of y changes the global value to 4, and the declared-lexical reference to y accesses the global value, since there is no surrounding lexical binding.Current Practice:No implementations have all of these proclaimations, although some have LEXICAL and some have GLOBAL.Cost of adopting change:This proposal requires no fundamental changes to implementations; the superficial changes are to expose all of the primitive concepts which are already available to programmers. Compilers and interpreters will need to support LEXICAL as a declaration. Checking that variables proclaimed as GLOBAL are not rebound is possible but not required.Referencing or assigning to an unproclaimed and undeclared name "is an error", not "signals an error", which allows but does not require an implementation to issue a warning.  This is a change from current language but does not mandate a change from current practice. Benefits:LEXICAL proclamation enhances compatibility with Scheme. GLOBAL proclamation allows more efficient deep-bound implementations.Cost of converting existing code:This change is upward compatible and will affect no existing code except for code-walkers and other programs that analyze code.Aesthetics:The distinction between special and lexical variables is one of the more confusing aspects of Common Lisp to those used to programming in Scheme. Some might prefer to have a separate syntax (instead of LET with special declarations) to do dynamic bindings. However, for the most part, such changes are orthogonal to the issues raised here. Making  primitive concepts explicitly available can only enhance aesthetics.Discussion:The original Common Lisp designers had difficulty with this issue; putting in these features was part of the original intent, but time didn't allow.The following discussion carefully uses different words for kinds of "cells" and kinds of "bindings". Lack of differentiation here has led to a lot of confusion. Terminology in this area differs in writings about Lisp and other programming language."Cells" are conceptual locations that remember a value and can be read and written.  Sometimes these conceptual locations are implemented by actual memory locations, and sometimes they aren't, but that's an implementation detail and is irrelevant here.  (Sometimes these are called variables, but other times the word "variable" means something else, so for the sake of clarity I'm not going to use the word "variable".)Common Lisp has several kinds of cells. Local cells have lexical scope, while global cells have global scope and can be referenced from anywhere except where they are shadowed by a local cell referenced by the same name. Common Lisp has two kinds of binding:  Lexical binding creates a new cell.  Special binding saves the value of a cell, gives it a new value during the extent of the binding, and later restores the old value.  We know that special binding saves and restores because of what other functions see when they read the cell.  (This should not be confused by issues of shallow-bound versus deep-bound implementation, which are irrelevant here: cells are not the same thing as memory locations.)In principle, all cells have indefinite extent: they exist as long as a reference to them is possible.  However, for most local cells, in the absense of a closure, no reference to the cell is possible once the invocation which created the cell exits; in those cases, the cell has dynamic extent.Common Lisp has a fairly complicated set of rules for how to determine what cell is referenced when a program mentions a variable name. ("lexically free" means outside of all bindings of that name, regardless of whether those bindings are special or lexical.)  1. If the reference is lexically free, use the global cell.  2. Otherwise, in the absence of a SPECIAL declaration use the cell that     was affected by the innermost binding; if that binding was special,     use the global cell; if it was lexical, use the local cell created     by that binding.  3. Otherwise, the SPECIAL declaration forces use of the global cell.We certainly do not want to introduce a third kind of cell, because that would lead to a great deal of confusion.  Nor do we want to introduce a third kind of binding.  What we -are- trying to accomplish is to make the primitive concepts orthogonally available.  An example of a problem we have right now that needs to be fixed is that there is no way to say that a name is not misspelled without simultaneously saying that bindings of that name should be special rather than lexical.  These concepts should be available as separate constructs.There are four things that we would like to be able to proclaim about a variable name (aside from TYPE): - the default kind of binding if no declaration specifies which kind - the name is not misspelled so don't warn about free references - it is illegal to specially bind the global cell, because it is   a constant or because we want to optimize the performance of a   deep-binding implementation - it is illegal to store into the global cell, because it is a constantIt is already possible in Common Lisp to proclaim all four of these things, but some of them are mixed up with other concepts and not separately available.  Let's pick names for the four kinds of proclamations, and let's also agree that any proclamation serves the "not misspelled" purpose.  Let's further agree that these four proclamations are mutually exclusive.  LEXICAL  -- does nothing other than "not misspelled"  SPECIAL  -- changes the default kind of binding from lexical to special  GLOBAL   -- makes it illegal to specially bind the global cell  CONSTANT -- makes it illegal to store into the global cell              CONSTANT implies GLOBAL because special-binding is storingSPECIAL exists now.  LEXICAL is its logical complement.  CONSTANT exists now but only buried inside the DEFCONSTANT macro.  GLOBAL exists now but only when implied by DEFCONSTANT. This proposal makes them all explicitly available.It is appropriate to make CONSTANT and GLOBAL proclamations change the default kind of binding to "illegal", rather than leaving it lexical, to avoid unforseen interactions.Fahlman added the following on question of overriding an old proclaimation by issuing a new one:We want to allow a variable to be re-proclaimed for two reasons: to correct proclmations issued in error by the user, without having to kill off the Lisp and start over, and to make it easier to merge programs written by two different programmers.  (The latter reason may be bogus -- they shouldn't be in the same package anyway -- but there are times when a quick fix is extremely handy.)  On that other hand, we want the compiler to be able to wire certain things in tight as a result of these proclamations, so we need to make clear that if you proclaim something to be GLOBAL, compile some code, then proclaim it to be SPECIAL and then compile some more code the rebinds this variable, you may not get what you expect. Same with unconstantifying a constant.The current considerations of the compiler committee might give a framework for explaining what the rules are within that framework. However, given the current state of things, it is best to say that it "is an error" to re-proclaim a variable into a different class -- this says that portable code cannot do this and count on the result -- but that implementations are strongly urged to allow this re-proclamation as a way of correcting erroneous proclamations, perhaps issuing a warning or signalling a correctable error whenever a proclamation actually gets changed.The cleanup committee considered numerous alternatives to this proposal, including one where global lexical binding was separate from global dynamic binding, various rules for not allowing a global variable to be shadowed by a special declaration and the like.         TITAN          TITAN           TITAN          TITAN           
TIMESROMAN 
                                                    s                            u             A       9            {       	                    i             g       
                            "                                                                   |      15 %z*start*02626 00024 USfReturn-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 27 OCT 87 20:16:09 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 27 Oct 87 23:15:16-ESTDate: Tue, 27 Oct 87 23:15 ESTMessage-ID: <FAHLMAN.12345980284.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDU, JAR@AI.AI.MIT.EDUSubject: Issue: PROCLAIM-LEXICAL (Version 4) In-reply-to: Msg of 27 Oct 1987  16:40-EST from Masinter.pa at Xerox.COM    I'm still not very happy with this, if only because the proposed    solution is not really motivated well by the problem described.I agree that the problem description needs work.  We started discussingthis set of issues again because someone was grousing about spuriouswarnings, but it quickly became apparent that this was just a symptom ofa badly snarled system for declaraing variable types.  The proposaltries to rationalize this mess.  Probably the right move is to take someof the stuff from the "benefits" section, negate it, and put the resultinto the problem section.I support the substance of thsi proposal now.  I am still uneasy aboutthe statement that it "is an error" to change a variable's proclaimedbinding-type.  I'd be happy to see implementations issue a warning inthis case, but I'd also like to see a guarantee that the newproclamation will take effect, except perhaps in the case of GLOBAL orCONSTANT proclamations that have already had an irreversible effect oncompiled code.  Otherwise, if you accidentally issue the wrongproclamation, you've got no choice but to nuke the Lisp.I suppose this means that KMP and I will have to have another fightabout whether it is OK to issue a warning in a case that neither "is anerror" nor "signals an error".  We're probably never going to agree onwhat warnings are for, so let me state in advance that I think I'mright, but I would settle for a formula that says re-proclaiming is anerror, but implementors are ENCOURAGED to handle it in a way that letsthe re-proclamation take effect.By the way, last time around I argued pretty strongly thatimplementations should be forced to accept SETQ of unproclaimedvariables, at least in the interpreter, so that the time honoeredpractice of saying (SETQ FOO *) to the read-eval-print loop would not bedisrupted. I'm willing to yield on this now.  I've decided that I candefine a macro that will turn (STUFF FOO *) into the properproclaim/setq pair.  But I do want to be able to undo that proclamationlater without nuking hte Lisp.-- Scott*start*02547 00024 USfReturn-Path: <JAR@AI.AI.MIT.EDU>Received: from AI.AI.MIT.EDU by Xerox.COM ; 28 OCT 87 07:06:14 PSTDate: Wed, 28 Oct 87 10:08:20 ESTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  Issue: PROCLAIM-LEXICAL (Version 4) To: Masinter.pacc: JAR@AI.AI.MIT.EDU, cl-cleanup@SAIL.STANFORD.EDU, willc%tekchips.tek.com@RELAY.CS.NET, chapman%aitg.dec@DECWRL.DEC.COMIn-reply-to: Msg of 27 Oct 87 13:40 PST from Masinter.pa at Xerox.COMMessage-ID: <276333.871028.JAR@AI.AI.MIT.EDU>The idea, presented in PROCLAIM-LEXICAL versions 2-4, that specialvariables have corresponding "cells", really bugs me.  It means thatbinding and unbinding are to be thought of as side-effects.  Theenvironment model of binding seems much more elegant and modular to me;note that the McCarthy's original Lisp interpreter, Steele's Art of theInterpreter, and Scott/Strachey-style descriptions of programminglanguages, even dynamically scoped languages, all describe binding interms of environments.  If I were describing the semantics of CommonLisp, I'd say that the inputs to the (semantic) interpreter were: anexpression, a lexical environment (for lexical variables, block names,declarations, etc.), a dynamic environment (for special variables, catchtags, and unwind-protections), a store (to find the values currentlystored in locations like the cars and cdrs of conses), and acontinuation.  Now it's certainly possible to have a "cell" model ofevaluation which is completely equivalent to this; you just multiplexthe store and dynamic environment arguments, and make sure thatunbinding happens at the right time.  These two semantic modelscorrespond to deep- and shallow-bound implementations, which as we allknow are equivalent as far as their behavior is concerned.I would be much happier if the description of special variables was interms of dynamic environments rather than in terms of "cells" andside-effects.  This is what I was beginning to try to do with version 1of the proposal.  (The actual behavior of Common Lisp is less importantto me than its mode of description, so long as I can do what I want todo, which versions 1-4 all do.)  It's easier to derive the shallowsemantics from the deep semantics than vice versa, and it'scorrespondingly easier for users and implementors to understand.  Theenvironment model also adheres more closely to standard practice in therest of the programming languages community -- although I guess the Lispcommunity has never been afraid of provincialism before...*start*00863 00024 USfReturn-Path: <JAR@AI.AI.MIT.EDU>Received: from AI.AI.MIT.EDU by Xerox.COM ; 29 OCT 87 17:18:21 PSTDate: Thu, 29 Oct 87 20:21:07 ESTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  Issue: PROCLAIM-LEXICAL (Version 4) To: Masinter.paIn-reply-to: Msg of 28 Oct 87 12:01 PST from Masinter.pa at Xerox.COMMessage-ID: <277208.871029.JAR@AI.AI.MIT.EDU>    Date: 28 Oct 87 12:01 PST    From: Masinter.pa at Xerox.COM    To:   JAR at AI.AI.MIT.EDU    Re:   Issue: PROCLAIM-LEXICAL (Version 4)     The environment model is more consistent with the multi-process model in    any case....     My schedule between now and the November meeting is tight and this is    tricky writing ... could I convince you (as the original submitter) to    attempt a revision?Gleep.  What's the next deadline?  I'll try to get to it next week.*start*00561 00024 USfReturn-Path: <JAR@AI.AI.MIT.EDU>Received: from AI.AI.MIT.EDU by Xerox.COM ; 13 NOV 87 09:48:31 PSTDate: Fri, 13 Nov 87 12:50:09 ESTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  Issue: PROCLAIM-LEXICAL (Version 4) To: Masinter.paIn-reply-to: Msg of 11 Nov 87 01:55 PST from Masinter.pa at Xerox.COMMessage-ID: <285095.871113.JAR@AI.AI.MIT.EDU>Things have come up.  I was rather busy last week, then all this week Iwas gone due to a family matter.  I don't know if I can give you an ETA;apparently not before the meeting.*start*09850 00024 USfDate: 14 Nov 87 21:04 PSTFrom: Masinter.paSubject:  Issue: PROCLAIM-LEXICAL (Version 5) To: cl-cleanup@SAIL.STANFORD.EDU, JAR@AI.AI.MIT.EDUcc: MasinterJAR didn't come thru with a rewrite, so this is a last minute attempt to construct one. What I mainly did was to omit the summary of Moon's description of the "cell" model.I'd like to present this to X3J13 even in its current interim state. We will discuss it on Monday. (BTW, I intend to try to have a follow up get-together Monday evening to go over and confirm the status of various issues before the Tuesday meeting. Please check the hotel announcement board (I assume there is one.)).Issue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37),              global variables (p68),	         declaration specifiers (p157)Category:     ENHANCEMENTEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87              Version 5 by Masinter 14-Nov-87Problem Description:The distinction between special and lexical variables is one of the more confusing aspects of Common Lisp to those used to programming in Scheme.  There is no way to "undo" a SPECIAL proclaimation. Several aspects of variable declarations (including whether the variable is a constant, never rebound, and the like) are impossible in portable Common Lisp, although they exist in several implementations. There are many combinations of declarations allowed and not allowed.CLtL pp. 55-56 implies that if a name (symbol) is not proclaimed or declared special, then a free reference to that name is a reference to the special variable of that name, while a LAMBDA-binding of that name indicates a binding of the lexical variable of that name.  This would mean that the following program is legal and that (TST) => 4:    (defun tst ()      (setq x 3)      (funcall (let ((x 4)) #'(lambda () x))))However, if you feed this program to many Common Lisp compilers, a warning message will be produced for the SETQ, saying something like "Warning: X not declared or bound, assuming special." These warnings are prominent; it is hard to believe  that a program which elicited such warning messages was "correct" in that implementation. This is a disagreement between theory and practice.Proposal (PROCLAIM-LEXICAL:ADD-LEXICAL-GLOBAL-CONSTANT):Introduce new declaration specifiers, LEXICAL, GLOBAL, and CONSTANT, which are mutually exclusive with the SPECIAL declaration specifier.  All four may be used as proclamations; only SPECIAL and LEXICAL may be used as declarations.A name may be proclaimed only one of LEXICAL, SPECIAL, GLOBAL, or CONSTANT.  A name is said to be unproclaimed if it has not been proclaimed to be any of these four.A free reference or assignment to a name is an error if it is unproclaimed and undeclared. (While we expect many programming environments to allow such references in interactive programming, no portable program should rely on free references to unproclaimed and undeclared variables; compiler warnings when encountering them are encouraged.) A LAMBDA-binding in the absence of a declaration or proclamation binds the lexical variable.SPECIAL proclamations and declarations behave as defined in CLtL.LEXICAL proclamations have no effect other than to make the name cease to be unproclaimed.  LEXICAL declarations shadow all enclosing declarations and proclamation of any of these four types.  LEXICAL declarations have the same scoping rules as SPECIAL declarations.GLOBAL proclamations make it an error to bind the name.CONSTANT proclamations make it an error to bind the name and an error to assign to the name.DEFCONSTANT is defined in terms of SETQ and the CONSTANT proclamation. All keyword symbols are automatically proclaimed CONSTANT.A free reference or assignment accesses the same value regardless of the declaration or proclamation.  This is called the global value. SPECIAL binding alters the global value within its extent. (Multiple process and multiple processor systems will have to make their own definitions of the extent of a SPECIAL binding, as noted on p.38 of CLtL--this proposal does not address that.)There is only one global value for a name and it is used by all free references, all free assignments, and all SPECIAL bindings.It is an error to re-proclaim a variable to a different class. (We expect this issue to revisited by the compiler committee, see discussion below.) Example:  (proclaim '(lexical x))  (proclaim '(special y))  (setq x 1 y 2)  (defun tst ()     (let ((x 3) (y 4))	(locally (declare (special x) (lexical y))	  (list x y	        (funcall (let ((x 5) (y 6))			   #'(lambda () (list x y))))))))    (tst) => (1 4 (5 4))Note that the second element of the list is 2. That is because the special binding of y changes the global value to 4, and the declared-lexical reference to y accesses the global value, since there is no surrounding lexical binding.Current Practice:No implementations have all of these proclaimations, although some have LEXICAL and some have GLOBAL.Cost of adopting change:This proposal requires no fundamental changes to implementations; the superficial changes are to expose all of the primitive concepts which are already available to programmers. Compilers and interpreters will need to support LEXICAL as a declaration. Checking that variables proclaimed as GLOBAL are not rebound is possible but not required.Referencing or assigning to an unproclaimed and undeclared name "is an error", not "signals an error", which allows but does not require an implementation to issue a warning.  This is a change from current language but does not mandate a change from current practice. Benefits:LEXICAL proclamation enhances compatibility with Scheme. GLOBAL proclamation allows more efficient deep-bound implementations.Cost of converting existing code:This change is upward compatible and will affect no existing code except for code-walkers and other programs that analyze code.Aesthetics:The distinction between special and lexical variables is one of the more confusing aspects of Common Lisp to those used to programming in Scheme. Some might prefer to have a separate syntax (instead of LET with special declarations) to do dynamic bindings. However, for the most part, such changes are orthogonal to the issues raised here. Making primitive concepts explicitly available enhances aesthetics.Discussion:The original Common Lisp designers had difficulty with this issue; putting in these features was part of the original intent, but time didn't allow.This proposal and many other proposals were discussed before this version was arrived at.There are four things that we would like to be able to proclaim about a variable name (aside from TYPE): - the default kind of binding if no declaration specifies which kind - the name is not misspelled so don't warn about free references - it is illegal to specially bind the global cell, because it is   a constant or because we want to optimize the performance of a   deep-binding implementation - it is illegal to store into the global cell, because it is a constantIt is already possible in Common Lisp to proclaim all four of these things, but some of them are mixed up with other concepts and not separately available.  LEXICAL  -- does nothing other than "not misspelled"  SPECIAL  -- changes the default kind of binding from lexical to special  GLOBAL   -- makes it illegal to specially bind the global cell  CONSTANT -- makes it illegal to store into the global cell              CONSTANT implies GLOBAL because special-binding is storingSPECIAL exists now.  LEXICAL is its logical complement.  CONSTANT exists now but only buried inside the DEFCONSTANT macro.  GLOBAL exists now but only when implied by DEFCONSTANT. This proposal makes them all explicitly available.It is appropriate to make CONSTANT and GLOBAL proclamations change the default kind of binding to "illegal", rather than leaving it lexical, to avoid unforseen interactions.Is it legal to change the proclaimation of a variable?We want to allow a variable to be re-proclaimed for two reasons: to correct proclaimations issued in error by the user without having to end the Lisp session and start over, and to make it easier to merge programs written by two different programmers.  (The latter reason is suspect -- they shouldn't be in the same package anyway -- but there are times when a quick fix is extremely handy.)  On that other hand, we want the compiler to be able to wire certain things in tight as a result of these proclamations, so we need to make clear that if you proclaim something to be GLOBAL, compile some code, then proclaim it to be SPECIAL and then compile some more code the rebinds this variable, you may not get what you expect. Same with changing the proclaimation of a constant.The current considerations of the compiler committee might give a framework for explaining what the rules are within that framework. However, given the current state of things, it is best to say that it "is an error" to re-proclaim a variable into a different class -- this says that portable code cannot do this and count on the result -- but that implementations are strongly urged to allow this re-proclamation as a way of correcting erroneous proclamations, perhaps issuing a warning or signalling a correctable error whenever a proclamation actually gets changed.        TITAN          TITAN                                       s                                                9      I       	                    h             g       
              "                                       %9 z*start*09902 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 NOV 87 13:28:59 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 15 Nov 87  03:05:47 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 14 NOV 87 21:04:54 PSTDate: 14 Nov 87 21:04 PSTFrom: Masinter.paSubject:  Issue: PROCLAIM-LEXICAL (Version 5) To: cl-cleanup@SAIL.STANFORD.EDU, JAR@AI.AI.MIT.EDUcc: Masinter.paMessage-ID: <871114-210454-3591@Xerox>JAR didn't come thru with a rewrite, so this is a last minute attempt toconstruct one. What I mainly did was to omit the summary of Moon'sdescription of the "cell" model.I'd like to present this to X3J13 even in its current interim state. Wewill discuss it on Monday. (BTW, I intend to try to have a follow upget-together Monday evening to go over and confirm the status of variousissues before the Tuesday meeting. Please check the hotel announcementboard (I assume there is one.)).!Issue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37),              global variables (p68),	         declaration specifiers (p157)Category:     ENHANCEMENTEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87              Version 5 by Masinter 14-Nov-87Problem Description:The distinction between special and lexical variables is one of the moreconfusing aspects of Common Lisp to those used to programming in Scheme.There is no way to "undo" a SPECIAL proclaimation. Several aspects ofvariable declarations (including whether the variable is a constant,never rebound, and the like) are impossible in portable Common Lisp,although they exist in several implementations. There are manycombinations of declarations allowed and not allowed.CLtL pp. 55-56 implies that if a name (symbol) is not proclaimed ordeclared special, then a free reference to that name is a reference tothe special variable of that name, while a LAMBDA-binding of that nameindicates a binding of the lexical variable of that name.  This wouldmean that the following program is legal and that (TST) => 4:    (defun tst ()      (setq x 3)      (funcall (let ((x 4)) #'(lambda () x))))However, if you feed this program to many Common Lisp compilers, awarning message will be produced for the SETQ, saying something like"Warning: X not declared or bound, assuming special." These warnings areprominent; it is hard to believe  that a program which elicited suchwarning messages was "correct" in that implementation. This is adisagreement between theory and practice.Proposal (PROCLAIM-LEXICAL:ADD-LEXICAL-GLOBAL-CONSTANT):Introduce new declaration specifiers, LEXICAL, GLOBAL, and CONSTANT,which are mutually exclusive with the SPECIAL declaration specifier.All four may be used as proclamations; only SPECIAL and LEXICAL may beused as declarations.A name may be proclaimed only one of LEXICAL, SPECIAL, GLOBAL, orCONSTANT.  A name is said to be unproclaimed if it has not beenproclaimed to be any of these four.A free reference or assignment to a name is an error if it isunproclaimed and undeclared. (While we expect many programmingenvironments to allow such references in interactive programming, noportable program should rely on free references to unproclaimed andundeclared variables; compiler warnings when encountering them areencouraged.) A LAMBDA-binding in the absence of a declaration or proclamation bindsthe lexical variable.SPECIAL proclamations and declarations behave as defined in CLtL.LEXICAL proclamations have no effect other than to make the name ceaseto be unproclaimed.  LEXICAL declarations shadow all enclosingdeclarations and proclamation of any of these four types.  LEXICALdeclarations have the same scoping rules as SPECIAL declarations.GLOBAL proclamations make it an error to bind the name.CONSTANT proclamations make it an error to bind the name and an error toassign to the name.DEFCONSTANT is defined in terms of SETQ and the CONSTANT proclamation.All keyword symbols are automatically proclaimed CONSTANT.A free reference or assignment accesses the same value regardless of thedeclaration or proclamation.  This is called the global value. SPECIALbinding alters the global value within its extent. (Multiple process andmultiple processor systems will have to make their own definitions ofthe extent of a SPECIAL binding, as noted on p.38 of CLtL--this proposaldoes not address that.)There is only one global value for a name and it is used by all freereferences, all free assignments, and all SPECIAL bindings.It is an error to re-proclaim a variable to a different class. (Weexpect this issue to revisited by the compiler committee, see discussionbelow.) Example:  (proclaim '(lexical x))  (proclaim '(special y))  (setq x 1 y 2)  (defun tst ()     (let ((x 3) (y 4))	(locally (declare (special x) (lexical y))	  (list x y	        (funcall (let ((x 5) (y 6))			   #'(lambda () (list x y))))))))    (tst) => (1 4 (5 4))Note that the second element of the list is 2. That is because thespecial binding of y changes the global value to 4, and thedeclared-lexical reference to y accesses the global value, since thereis no surrounding lexical binding.Current Practice:No implementations have all of these proclaimations, although some haveLEXICAL and some have GLOBAL.Cost of adopting change:This proposal requires no fundamental changes to implementations; thesuperficial changes are to expose all of the primitive concepts whichare already available to programmers. Compilers and interpreters willneed to support LEXICAL as a declaration. Checking that variablesproclaimed as GLOBAL are not rebound is possible but not required.Referencing or assigning to an unproclaimed and undeclared name "is anerror", not "signals an error", which allows but does not require animplementation to issue a warning.  This is a change from currentlanguage but does not mandate a change from current practice. Benefits:LEXICAL proclamation enhances compatibility with Scheme. GLOBALproclamation allows more efficient deep-bound implementations.Cost of converting existing code:This change is upward compatible and will affect no existing code exceptfor code-walkers and other programs that analyze code.Aesthetics:The distinction between special and lexical variables is one of the moreconfusing aspects of Common Lisp to those used to programming in Scheme.Some might prefer to have a separate syntax (instead of LET with specialdeclarations) to do dynamic bindings. However, for the most part, suchchanges are orthogonal to the issues raised here. Making primitive concepts explicitly available enhances aesthetics.Discussion:The original Common Lisp designers had difficulty with this issue;putting in these features was part of the original intent, but timedidn't allow.This proposal and many other proposals were discussed before thisversion was arrived at.There are four things that we would like to be able to proclaim about avariable name (aside from TYPE): - the default kind of binding if no declaration specifies which kind - the name is not misspelled so don't warn about free references - it is illegal to specially bind the global cell, because it is   a constant or because we want to optimize the performance of a   deep-binding implementation - it is illegal to store into the global cell, because it is a constantIt is already possible in Common Lisp to proclaim all four of thesethings, but some of them are mixed up with other concepts and notseparately available.  LEXICAL  -- does nothing other than "not misspelled"  SPECIAL  -- changes the default kind of binding from lexical tospecial  GLOBAL   -- makes it illegal to specially bind the global cell  CONSTANT -- makes it illegal to store into the global cell              CONSTANT implies GLOBAL because special-binding is storingSPECIAL exists now.  LEXICAL is its logical complement.  CONSTANT existsnow but only buried inside the DEFCONSTANT macro.  GLOBAL exists now butonly when implied by DEFCONSTANT. This proposal makes them allexplicitly available.It is appropriate to make CONSTANT and GLOBAL proclamations change thedefault kind of binding to "illegal", rather than leaving it lexical, toavoid unforseen interactions.Is it legal to change the proclaimation of a variable?We want to allow a variable to be re-proclaimed for two reasons: tocorrect proclaimations issued in error by the user without having to endthe Lisp session and start over, and to make it easier to merge programswritten by two different programmers.  (The latter reason is suspect --they shouldn't be in the same package anyway -- but there are times whena quick fix is extremely handy.)  On that other hand, we want thecompiler to be able to wire certain things in tight as a result of theseproclamations, so we need to make clear that if you proclaim somethingto be GLOBAL, compile some code, then proclaim it to be SPECIAL and thencompile some more code the rebinds this variable, you may not get whatyou expect. Same with changing the proclaimation of a constant.The current considerations of the compiler committee might give aframework for explaining what the rules are within that framework.However, given the current state of things, it is best to say that it"is an error" to re-proclaim a variable into a different class -- thissays that portable code cannot do this and count on the result -- butthat implementations are strongly urged to allow this re-proclamation asa way of correcting erroneous proclamations, perhaps issuing a warningor signalling a correctable error whenever a proclamation actually getschanged.*start*01613 00024 USfDate: 25 Nov 87 15:46 PSTFrom: Masinter.paSubject: Re: Issue: PROCLAIM-LEXICAL (Version 5) In-reply-to: Masinter.pa's message of 14 Nov 87 21:04 PSTTo: Masinter.pacc: cl-cleanup@SAIL.STANFORD.EDU, JAR@AI.AI.MIT.EDUWhat I remember about the discussion in Denver is fading quickly. I remember that there's a problem with CONSTANT, in that (DEFCONSTANT X ...) can't expand into (PROCLAIM '(CONSTANT X)) followed by setting X because it would be an error to set it after it was proclaimed constant, and it can't do the set first and the proclaim second, because it is an error to set it if it isn't declared, and you can't first proclaim it global and then constant because it is an error to change the proclaimation of a variable.There was a lot of confusion about the proposal because people didn't understand GLOBAL; in particular, there was lots of grumbling about the example, where even though a variable was proclaimed lexical and there was a lexical reference to it, a SPECIAL binding could still overwrite the definition. There was a lot of grumbling that the notion of "global LEXICAL" was a contradiction, because "lexical" usually meant "limited scope" and that you could tell when the scope started and ended, but in the case of what we were calling global lexical, there was no way to terminate the scope. There was some mumbling about making a "file" have a global lexical scope or some way of terminating a global lexical scope at the "top level" etc. etc., but it was all at the level of mumble.Frankly, I think these are pretty serious problems... Comments?*start*01514 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 27 NOV 87 07:52:50 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 27 Nov 87  07:51:00 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 289858; Fri 27-Nov-87 10:50:43 ESTDate: Fri, 27 Nov 87 10:50 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PROCLAIM-LEXICAL (Version 5) To: cl-cleanup@SAIL.STANFORD.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: <871125-154700-2532@Xerox>Message-ID: <19871127155030.5.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 25 Nov 87 15:46 PST    From: Masinter.pa@Xerox.COM    There was a lot of grumbling that the notion of "global LEXICAL" was a    contradiction....As I recall, the original motivation for making a proposal here waspopular demand for a notion of "global LEXICAL" in the language.  Theevolution of the proposal was then driven by a desire to straighten outvarious inconsistencies, but may have lead to introducing moreinconsistencies or complexities, a process to which I am afraid I havecontributed.  If there is some kind of concensus that no one wants"global LEXICAL" anyway, maybe we ought to call the whole thing off?  Istill think Common Lisp has some confusion here that would be worthstraightening out, but certainly there are other areas we could becleaning up instead.*start*00885 00024 USaReturn-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 13 SEP 88 21:39:50 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa05385; 8 Sep 88 16:09 BSTDate: Thu, 8 Sep 88 16:40:08 BSTMessage-Id: <18691.8809081540@aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Older version of PROCLAIM-LEXICALTo: Masinter.paThanks for the back mail.  It is also possible to get copies ofearlier versions (1 - 3) or the proposal?  I want to make sureI know at least that much of the history.Ta,JeffJeff Dalton,                      JANET: J.Dalton@uk.ac.ed             AI Applications Institute,        ARPA:  J.Dalton%uk.ac.ed@nss.cs.ucl.ac.ukEdinburgh University.             UUCP:  ...!ukc!ed.ac.uk!J.Dalton*start*01081 00024 USaReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 15 SEP 88 12:32:06 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 459875; Thu 15-Sep-88 15:31:38 EDTDate: Thu, 15 Sep 88 15:31 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: PROCLAIM-LEXICALTo: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <880915153150.8.KMP@GRYPHON.SCRC.Symbolics.COM>Just to warn you, Rees has done a lot of thinking about how to recastPROCLAIM-LEXICAL. He and I have most of a writeup worked out which wewill send soon, so it will want to come off the tabled list. Fortunately,the new proposal is written in a way that makes me happy about not havingseparate lexical and special cells at the global level. Hopefully thatwill relieve some anxiety with previous proposals. Anyway, no sense infurther comment until you see the real proposal -- I just wanted you toknow it was going to be there...*start*09272 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 SEP 88 16:35:33 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 24 Sep 88  16:34:20 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 465093; Sat 24-Sep-88 19:33:03 EDTDate: Sat, 24 Sep 88 19:32 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)To: CL-Cleanup@SAIL.Stanford.EDUcc: JAR@AI.AI.MIT.EDUIn-Reply-To: <3270.8809182113@subnode.aiai.ed.ac.uk>,             <8809160203.AA07003@void>,             <871114-210454-3591@Xerox>Message-ID: <880924193252.5.KMP@GRYPHON.SCRC.Symbolics.COM>Jonathan Rees gave me a dump of a bunch of thinking he'd been doingabout PROCLAIM-LEXICAL and based on my understanding of that, Idecided to rewrite the existing proposals and revive this issue.The focus and presentation is changed substantially -- I hopefor the better.-----Issue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37), global variables (p68),	      declaration specifiers (p157)Category:     CLARIFICATION/ADDITIONEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87              Version 5 by Masinter 14-Nov-87	      Version 6 by Pitman 15-Sep-88	       (major revision, for review by Jonathan Rees and Jeff Dalton)	      Version 7 by Pitman 24-Sep-88   	       (minor revisions based on comments from Rees and Dalton)Status:	      For Internal DiscussionProblem Description:  Although local variables in Common Lisp may be `special' or `lexical,'  global variables (with the exception of named constants) may currently  only be `special.'  The Scheme language permits free variable references to refer to global  bindings. Their experience suggests that such usage would be useful to  the Common Lisp community. The absence of such a facility in Common Lisp  is a barrier both culturally (to the sharing of ideas) and technically  (to the sharing of code).  SPECIAL proclamations are uncontrollably pervasive. There is no way  to locally override or globally undo a SPECIAL proclamation.Background/Analysis:  Variable evaluation may be viewed in Common Lisp as a search through  a set of environments to find a binding, and then the dereferencing of  that binding. The environments with which Common Lisp deals are  Lexical (L), Dynamic (D), and Global (G).  A SPECIAL declaration for a variable amounts to a request that the  variable be resolved by searching first the Dynamic and then the Global  environment (DG).  As currently described in CLtL, lexical variable reference searches  only the Lexical environment (L).  Because undeclared free variables in the interpreter are implicitly   declared SPECIAL by most (perhaps all) implementations, this amounts  to a search of Lexical, Dynamic, and Global (LDG). However, the   accompanying warnings in many implementations make it clear that this  behavior is not intended to be taken seriously.  Constants are looked up solely in the Global environment (G). They  have other properties as well, of course.  In the Scheme language, the default lookup is first Lexical, then  Global (LG). Providing compatibility for Scheme code is, and more  generally for a Scheme working style is therefore difficult because  Common Lisp does not provide the LG search style.  The issue of whether a variable can be assigned is orthogonal.  The issue of whether a variable can be bound and, if it can be, which  environment is used for the new binding is orthogonal.Proposal (PROCLAIM-LEXICAL:LG):  Provide a new declaration (and proclamation) called LEXICAL which does  LG lookup. That is, variables declared LEXICAL would be looked up first  in the lexical environment (L) and then in the global environment (G)  if not found in the lexical.  Clarify that dynamic binding does DG lookup.  That is, variables  declared SPECIAL would be looked up first in the dynamic  environment (D) and then in the global environment (G) if not found  in the lexical. Further clarify that SYMBOL-VALUE does DG lookup.  Define that a dynamic binding of a variable creates a new binding  in the dynamic environment (D) leaving the global environment (G)  unaffected.  Define that a lexical binding of a variable creates a new binding  in the lexical environment (L), leaving the global environment (G)  unaffected.  Note that an assignment to a variable which is bound in the global   environment (G) will affect lexical (LG) lookups for which there is  no lexical (L) binding and dynamic (DG) lookups for which there is  no dynamic (D) binding.  Note that these restrictions describe an abstract model, not a  concrete implementation. An implementation may still choose to  implement dynamic binding as either deep or shallow, but some  searching may be necessary to find the global cell in shallow bound  implementations [unless dynamic binding has been forbidden for  that variable].  Like SPECIAL declarations (and unlike type declarations),  compilers and interpreters would be required to notice and   respect this declaration.Test Case:  #1: (proclaim '(lexical x))      (proclaim '(special y))      (setq x 1 y 2)      (defun tst ()	(let ((x 3) (y 4))	  (locally (declare (special x) (lexical y))		   (list x y			 (funcall (let ((x 5) (y 4))				    #'(lambda () (list x y))))))))      (tst) => (1 4 (5 4)) #2: (proclaim '(lexical x))     (setq x 1)     (defun f (fn) (list x (funcall fn)))     (defun g (fn)       (let ((x 2))         (declare (special x))	 (funcall fn #'(lambda () x))))     (g #'f) => (1 2)Rationale:  This mechanism provides a simple and straightforward answer to  the problems stated above.Current Practice:  Probably no one implements this.Cost to Implementors:  Some compiler work would probably be needed. Some compilers may  have hooks for most of this already laying around, but some may not.  Note well that this proposal does not require separate global lexical  and dynamic cells, so the data storage layout of Lisp need not change.Cost to Users:  For the most part, this change is upward compatible.  Some code-walking tools would have to change.Cost of Non-Adoption:  It would continue to be difficult to share code with Scheme.  New CL users coming from the Scheme community would be confused by  their sometimes inability to map what they know about variable binding  into the CL model of variable binding.  Some interesting native CL applications would be impossible to write  in a syntactically convenient style.Benefits:  Enhanced flexibility of expression.  Rationalization of the semantics of dynamic variables.Aesthetics:  [I'll leave this open to discussion.]  Discussion:  Rees points that it is an oversimplification to describe Scheme's  binding simply as LG since they have no Dynamic environment and  there is no way to distinguish LG and LDG. However, the reasons he  prefers LG are:   1. It's nice for readability and understandability to have a      declaration which tells you that a variable will not be      dynamically bound.   2. It's nice for performance in deep-bound implementations to have a      declaration that says that no search will be needed.  Of course, he notes, there could be a counter-argument to item 2  (in favor of LDG) in order to prefer shallow bound implementations,  but that still would not defeat the argument in item 1. Rees believes  that LG is slightly preferrable, but that LDG would be essentially  adequate for most of his needs.  Pitman supports PROCLAIM-LEXICAL:LG and believes that giving LDG the  name LEXICAL would be a serious mistake, leaving open the door for  program bugs due to accidental binding of variables presumed by the  programmer not to be bound. If someone (Moon?) seriously wanted LDG  type variables in addition to LG variables (under a name other than  LEXICAL), Pitman would not object.  Dalton expressed support for PROCLAIM-LEXICAL:LG (Version 6).  He observes that another reason for opposing LDG is that it suggests  the possibility that someone might want DLG. LG is simpler and still  accomplishes the stated purpose. He adds ``I would like to be able  to explain the global environment as a sort of giant, extensible  LET abound everything.  This proposal seems to get fairly close.''  It would be possible to submit a proposal for a GLOBAL (G) declaration  under separate cover if anyone (Xerox?) was interested. Pitman thinks  this would be an interesting idea. Dalton points out, however, that  already with this proposal there is enough power to at least deal with  globals -- albeit circuitously. For example, to reference a global  variable X, one could write subroutines such as:   (defun     global-x ()      (declare (lexical x)) x)   (defun set-global-x (value) (declare (lexical x)) (setq x value))  Eg, consider:   (defun f (x) (+ (global-x) x))*start*01903 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 12:06:43 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 26 Sep 88  12:06:47 PDTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA09287g; Mon, 26 Sep 88 11:04:43 PSTReceived: by blacksox id AA00135g; Mon, 26 Sep 88 12:02:11 pdtDate: Mon, 26 Sep 88 12:02:11 pdtFrom: Eric Benson <eb@lucid.com>Message-Id: <8809261902.AA00135@blacksox>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: Kent M Pitman's message of Sat, 24 Sep 88 19:32 EDT <880924193252.5.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)   Date: Sat, 24 Sep 88 19:32 EDT   From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>   Test Case:     #1: (proclaim '(lexical x))	 (proclaim '(special y))	 (setq x 1 y 2)	 (defun tst ()	   (let ((x 3) (y 4))	     (locally (declare (special x) (lexical y))		      (list x y			    (funcall (let ((x 5) (y 4))				       #'(lambda () (list x y))))))))	 (tst) => (1 4 (5 4))Maybe I'm confused, but I thought this should be (1 2 (5 4)), sincethe first reference to y is a lexical reference (LG).  The setq of yto 2 is global, but the binding of y to 4 is dynamic, and thereforeinvisible to a lexical reference.  This is an example of the casewhere you stated "some searching may be necessary to find the globalcell in shallow bound implementations [unless dynamic binding has beenforbidden for that variable]" which is also illustrated in the secondexample.  Or did you intend that a lexically apparent dynamic bindingis also a lexical binding?  That seems strange to me.  It would implythat a special binding is not equivalent to a corresponding PROGV, forexample.*start*02854 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 12:46:39 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Sep 88  12:46:42 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 465728; Mon 26-Sep-88 15:45:00 EDTDate: Mon, 26 Sep 88 15:44 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)To: eb@lucid.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: <8809261902.AA00135@blacksox>Message-ID: <880926154450.4.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Mon, 26 Sep 88 12:02:11 pdt    From: Eric Benson <eb@lucid.com>       Date: Sat, 24 Sep 88 19:32 EDT       From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>       Test Case:	 #1: (proclaim '(lexical x))	     (proclaim '(special y))	     (setq x 1 y 2)	     (defun tst ()	       (let ((x 3) (y 4))		 (locally (declare (special x) (lexical y))			  (list x y				(funcall (let ((x 5) (y 4))					   #'(lambda () (list x y))))))))	     (tst) => (1 4 (5 4))    Maybe I'm confused, but I thought this should be (1 2 (5 4)) ...You're not confused -- you're just polite. I was probably too burnt outafter putting this whole thing together to check the example asthoroughly as I should have. It was merged and edited from one of thenumerous other drafts, and... Also, Jonathan's feedback to me saidexplicitly that he didn't bother to check the example. I should haveknown that meant trouble...There's also the other `error' about the second y binding, which shouldhave been to 6, not to 4.Does the following look ok to you?  #1: (proclaim '(lexical x))      (proclaim '(special y))      (setq x 1 y 2)      (defun tst ()	(let ((x 3) (y 4))	  (locally (declare (special x) (lexical y))		   (list x y			 (funcall (let ((x 5) (y 6))				    #'(lambda () (list x y))))))))      (tst) => (1 2 (5 4))By the way, completely as an aside: If LEXICAL were defined to mean LDG search rather than LG search, then the result would have been (1 4 (5 4)). That was what Moon's proposal had suggested. However, there's something very asymmetric and unsettling about having DYNAMIC mean DG and LEXICAL mean LDG. One way to reach harmony is LEXICAL=LG as we've proposed, but it occurs to me as a curiosity that you could define DYNAMIC=DLG. I can't imagine what the practical value of that would be, and it might be kinda odd compiled, but it would keep from upsetting my sense of  symmetry and it would lead to the interesting result of (3 4 (5 4)), which is marginally more intuitive than (1 4 (5 4)).*start*01290 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 14:12:17 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 26 Sep 88  14:12:27 PDTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA09428g; Mon, 26 Sep 88 13:10:21 PSTReceived: by blacksox id AA00152g; Mon, 26 Sep 88 14:07:48 pdtDate: Mon, 26 Sep 88 14:07:48 pdtFrom: Eric Benson <eb@lucid.com>Message-Id: <8809262107.AA00152@blacksox>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: Kent M Pitman's message of Mon, 26 Sep 88 15:44 EDT <880926154450.4.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)   Date: Mon, 26 Sep 88 15:44 EDT   From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>   Does the following look ok to you?     #1: (proclaim '(lexical x))	 (proclaim '(special y))	 (setq x 1 y 2)	 (defun tst ()	   (let ((x 3) (y 4))	     (locally (declare (special x) (lexical y))		      (list x y			    (funcall (let ((x 5) (y 6))				       #'(lambda () (list x y))))))))	 (tst) => (1 2 (5 4))I think that's (1 2 (5 6)).*start*02208 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 14:36:40 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Sep 88  14:36:46 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 465907; Mon 26-Sep-88 17:35:17 EDTDate: Mon, 26 Sep 88 17:35 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)To: eb@lucid.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: <8809262107.AA00152@blacksox>Message-ID: <880926173510.0.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Mon, 26 Sep 88 14:07:48 pdt    From: Eric Benson <eb@lucid.com>       Date: Mon, 26 Sep 88 15:44 EDT       From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>       Does the following look ok to you?	 #1: (proclaim '(lexical x))	     (proclaim '(special y))	     (setq x 1 y 2)	     (defun tst ()	       (let ((x 3) (y 4))		 (locally (declare (special x) (lexical y))			  (list x y				(funcall (let ((x 5) (y 6))					   #'(lambda () (list x y))))))))	     (tst) => (1 2 (5 4))    I think that's (1 2 (5 6)).No, I'm not as tired this time, and I think I'm right ... X gets bound lexically to 3 because X is [pervasively] proclaimed LEXICAL. Y gets bound specially to 4 because Y is [pervasively] proclaimed SPECIAL. Reference style for name X is changed to SPECIAL, making lexical X=3 invisible. Reference style for name Y is changed to LEXICAL, making dynamic Y=4 invisible. Global X=1 and global Y=2 are first two elements of list. X gets bound lexically to 5 because X is [pervasively] proclaimed LEXICAL. Y gets bound specially to 6 because Y is [pervasively] proclaimed SPECIAL. Closure is returned, capturing [lexical] X=5 but not [special] Y=6. Dynamic binding of Y to 6 disappears, dynamic binding of Y to 4 reverts. Closure is funcalled, returning captured X=5 and dynamically active Y=4  in a list which becomes third list element.Make sense?*start*02863 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 14:55:26 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 26 Sep 88  14:55:00 PDTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA09499g; Mon, 26 Sep 88 13:52:42 PSTReceived: by blacksox id AA00173g; Mon, 26 Sep 88 14:50:10 pdtDate: Mon, 26 Sep 88 14:50:10 pdtFrom: Eric Benson <eb@lucid.com>Message-Id: <8809262150.AA00173@blacksox>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: Kent M Pitman's message of Mon, 26 Sep 88 17:35 EDT <880926173510.0.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)   Date: Mon, 26 Sep 88 17:35 EDT   From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>       Date: Mon, 26 Sep 88 14:07:48 pdt       From: Eric Benson <eb@lucid.com>	  Date: Mon, 26 Sep 88 15:44 EDT	  From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>	  Does the following look ok to you?	    #1: (proclaim '(lexical x))		(proclaim '(special y))		(setq x 1 y 2)		(defun tst ()		  (let ((x 3) (y 4))		    (locally (declare (special x) (lexical y))			     (list x y				   (funcall (let ((x 5) (y 6))					      #'(lambda () (list x y))))))))		(tst) => (1 2 (5 4))       I think that's (1 2 (5 6)).   No, I'm not as tired this time, and I think I'm right ...    X gets bound lexically to 3 because X is [pervasively] proclaimed LEXICAL.    Y gets bound specially to 4 because Y is [pervasively] proclaimed SPECIAL.    Reference style for name X is changed to SPECIAL, making lexical X=3 invisible.    Reference style for name Y is changed to LEXICAL, making dynamic Y=4 invisible.    Global X=1 and global Y=2 are first two elements of list.    X gets bound lexically to 5 because X is [pervasively] proclaimed LEXICAL.    Y gets bound specially to 6 because Y is [pervasively] proclaimed SPECIAL.    Closure is returned, capturing [lexical] X=5 but not [special] Y=6.    Dynamic binding of Y to 6 disappears, dynamic binding of Y to 4 reverts.    Closure is funcalled, returning captured X=5 and dynamically active Y=4     in a list which becomes third list element.   Make sense?Clear as mud!  The point I was forgetting is that proclamations affectreferences *and* bindings, while declarations only affect the bindingsto which they are attached (if any), and references *for which arethere are no intervening bindings*.  There's still no such thing as apervasive declaration, either for SPECIAL or LEXICAL.Do you want to make LEXICAL the default for otherwise unspecifiedreferences?  It still might be a good idea to warn about the absenceof any declaration.*start*01809 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 15:23:28 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Sep 88  15:23:12 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 465961; Mon 26-Sep-88 18:21:32 EDTDate: Mon, 26 Sep 88 18:21 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)To: eb@lucid.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: <8809262150.AA00173@blacksox>Message-ID: <880926182124.4.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Mon, 26 Sep 88 14:50:10 pdt    From: Eric Benson <eb@lucid.com>    ... Do you want to make LEXICAL the default for otherwise unspecified    references?  It still might be a good idea to warn about the absence    of any declaration.This proposal doesn't suggest it. I thought hard about it and decided there was really no reason to.After all, you still need to initialize the variable you'll beclosing over, so you can do the proclamation at the same time.The missing component which does need to be followed up on if thisgets approved is how we declare these variables. People will wantlexical analogs of DEFVAR and DEFPARAMETER or perhaps some extendedsyntax to these which allows you to designate that the proclamationshould be LEXICAL instead of DYNAMIC. I suspect that this issue willbe a subject of much controversy as well, so I wanted to make sure itwas fully separated in order to stave off the multiplicative effectsof doing too many controversial things at once.*start*01664 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 10:39:42 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Sep 88  10:39:08 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 466386; Tue 27-Sep-88 13:37:51 EDTDate: Tue, 27 Sep 88 13:37 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: <880924193252.5.KMP@GRYPHON.SCRC.Symbolics.COM>Message-ID: <19880927173749.1.MOON@EUPHRATES.SCRC.Symbolics.COM>I think it would be good to do something resembling this, but there is aserious defect in your proposal, namely that the cost to implementors isgrossly understated ("some compiler work would probably be needed"indeed!).  In fact I have been unable to think of any way to implementthis proposal in a fully shallow-bound system.  Either references to theD environment, or references to the G environment that did not firstsearch the D environment, would have to be implemented with adeep-binding style environment search.  Your proposal gives no hint ofthis efficiency cost.  Maybe there's a clever implementation technique Ihaven't thought of; if so I wish someone would tell me.The KMP/EB discussion suggests that the semantics of the proposal arevery confusing even to experts, although perhaps it's just unfamiliar.*start*03163 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 10:55:33 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Sep 88  10:54:54 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 466400; Tue 27-Sep-88 13:53:37 EDTDate: Tue, 27 Sep 88 13:53 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: <19880927173749.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <880927135318.3.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Tue, 27 Sep 88 13:37 EDT    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    ... the cost to implementors is grossly understated ("some compiler work    would probably be needed" indeed!). ...I had written "a fair amount" in v6 and Rees seemed to think that wasoverstating things. I'm content to add that back in, or something stronger. :-)    In fact I have been unable to think of any way to implement this proposal    in a fully shallow-bound system...Rees suggested (and I was going to add in the next revision), that you couldmark the global cell with a bit saying whether it had been re-bound in theinterim.The only place this cost comes up at all is when a free lexical is referenced.Bound lexicals incur no overhead. As such, only new code can be affected anda slowdown cannot be perceived because there is nothing to compare timings with.Also, I would expect that in by far the majority of situations, variablesdeclared lexical will not be used dynamically and vice versa. As such, theone-bit mark above (assuming an implementation has a place to put that bitwithout increasing the size of symbols by a whole slot-width) will nearlyalways allow you to avoid the search because the valid bit will nearly alwaysbe set (I (very unscientifically) claim).    Your proposal gives no hint of this efficiency cost.Next draft will fix that.    Maybe there's a clever implementation technique I haven't thought of;    if so I wish someone would tell me.You can tell me if the above seems clever enough.    The KMP/EB discussion suggests that the semantics of the proposal are    very confusing even to experts, although perhaps it's just unfamiliar.That example would not be intuitive no matter -what- the semantics.It's an example you created yourself in order to demonstrate the edgeeffects concisely but shouldn't be taken to be model code. It does okbut isn't something to be taken as model code. In practice, programsuse more mnemonic names, don't bind variables and then throw the valuesaway, don't bind a lexical variable and then disable references to thebinding by funny local declarations, etc. In the next draft, I'll putthe other example first so that people can practice on an intuitive casebefore doing the extra credit problem.*start*02770 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 08:52:42 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Sep 88  08:52:30 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 466976; Wed 28-Sep-88 11:22:12 EDTDate: Wed, 28 Sep 88 11:22 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: <880924193252.5.KMP@GRYPHON.SCRC.Symbolics.COM>Message-ID: <19880928152208.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    In fact I have been unable to think of any way to implement    this proposal in a fully shallow-bound system.The problem is that the proposal requires that SPECIAL global referencesand LEXICAL global references share the same value when there has beenno SPECIAL binding, but do not share when there has been a SPECIAL binding.In a fully shallow-bound system (i.e. no environment search in SPECIALreferences and none in LEXICAL global references), this means that thefirst SPECIAL binding has to do something unusual to separate the SPECIALvalue from the LEXICAL value, and the last SPECIAL unbinding has to undothat.Having turned my brain back on, I have now thought of an efficient wayto do this on Lisp machines, using invisible pointers, and anotherefficient way to do it on stock hardware, using one extra instructionon every global reference of one or the other sort, plus a few extrainstructions in SPECIAL binding and unbinding.  Given that, I no longerobject to the proposal as unimplementable.  However, I still think youneed to be more forthcoming about the cost to the implementor: it doesn'tjust require a few compiler changes, it requires some reimplementationof the representation of global variables, with concomitant changes tothe compiler, the loader, the interpreter, and probably the debugger.Every symbol now potentially has two values accessible from theinterpreter (the current SPECIAL and the global LEXICAL) and you needthe corresponding new data structure to keep track of that.A more cogent objection is that the proposal is incomplete.  Common Lispincludes a bunch of mechanisms related to global SPECIAL variables(DEFVAR, SYMBOL-VALUE, MAKUNBOUND, etc.) and some or all of this needsto be replicated for LEXICAL variables.  I suspect not all of it needsto be replicated, but you've got to discuss and decide.I still think it would be good to do something resembling this.*start*03560 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 09:09:16 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 28 Sep 88  09:05:13 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa04769; 28 Sep 88 16:11 BSTDate: Wed, 28 Sep 88 16:51:09 BSTMessage-Id: <28871.8809281551@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: PROCLAIM-LEXICAL (Version 7)To: Jon L White <@NSS.Cs.Ucl.AC.UK,@edu.stanford.edu:jonl@lucid.com>, Moon@scrc-stony-brook.arpaIn-Reply-To: Jon L White's message of Tue, 27 Sep 88 23:56:21 PDTCc: KMP@scrc-stony-brook.arpa, CL-Cleanup@sail.stanford.edu, JAR@ai.ai.mit.edu> his might be something we shouldn't even think about standardizing> until some implementor/vendor takes the plunge in a trial balloon,> Yes, I remember, I was mildly in favor of the original proposal; but that > was a year and a half ago, and I expected a GLOBAL declaration to mean that> it would be illegal to special-bind that name (hence you could depend on> that name *not* being in the D environment).  Had somebody implemented> something like it for their Lisp back then, we might have had results to > talk about now.I think the semantic implications of adding a declaration that preventsdynamic binding are sufficiently straightforward that we should notrule it out just because no one implemented it a year ago.The strangeness in the current proposal is because the dynamic andlexical environments meet in a separate global environment.  Soa shallow bound implementation can't just change the global cellwhen it pushes a new binding.  The shallow binding cell has tobe a separate cell, making symbols (effectively) larger.  KMPand JAR suggested the use of a single cell combined with searchfor the global value if both it and the dynamic are needed.This is a new machanism, so we might want to think twice aboutit.An alternative is to say that a given global variable can be eitherlexical or special but not (as they can be in the current proposal)both.  That's not all that strange, because it's what we get withLET.  It lets us use a single cell and simply rules out the casewhen both are needed.I believe this alternative (which is more or less what was proposedbefore minus all the stuff about CONSTANT proclamations, etc.) solvesthe main problems (an easily referenced global for deep bound implementations and a way to establish a global variable withoutproclaiming it special and without some implementations thinkingit's a spelling error or an omitted proclamation) and is fairlynoncontroversial.We can fight about whether the proclamation for this should be calledGLOBAL or LEXICAL.  I think it is better to think of the new kind ofglobal variable as a kind of lexical variable rather than as aspecial1 variable that can't be bound, but that may be a matter oftaste.We might also fight, I suppose, about whether there should be acorresponding declaration (to override special proclamations).[It occurs to me that people might think of two differentdeclarations.1.  (set-global x 10)    (let ((x 20))      (locally (declare (lexical x)) x)) => 202.  (set-global x 10)    (let ((x 20))      (locally (declare (global x)) x)) => 10The one I have in mind is the 1st.]In any case, I think there is a fallback better than "do nothing".*start*02601 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 23:59:11 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 27 Sep 88  23:59:19 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00631g; Tue, 27 Sep 88 22:56:50 PSTReceived: by bhopal id AA06564g; Tue, 27 Sep 88 23:56:21 PDTDate: Tue, 27 Sep 88 23:56:21 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809280656.AA06564@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU, JAR@AI.AI.MIT.EDUIn-Reply-To: David A. Moon's message of Tue, 27 Sep 88 13:37 EDT <19880927173749.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 7)re: The KMP/EB discussion suggests that the semantics of the proposal are    very confusing even to experts, although perhaps it's just unfamiliar.I agree.  This might be something we shouldn't even think about standard-izing until some implementor/vendor takes the plunge in a trial balloon, presumably based on his belief that these semantics are immensely worthwhileto Common Lisp users -- so important in fact that he's willing to "run ahead" of the X3J13 committee and use it for a couple of years.  Otherwise, withoutsome practical evidence that there is overwhelming gain to be had, I fear we could commit ourselves for an enormous implementational headache purelybecause it "seemed like a nice idea at the time".Yes, I remember, I was mildly in favor of the original proposal; but that was a year and a half ago, and I expected a GLOBAL declaration to mean thatit would be illegal to special-bind that name (hence you could depend onthat name *not* being in the D environment).  Had somebody implementedsomething like it for their Lisp back then, we might have had results to talk about now.Incidentally, Lucid has done a deep-binding implementation -- for QLISP.Needless to say, it wasn't an overnight project; and the performanceresults could be questioned (or else, we could just commit more goodmoney after bad to keep tweaking it indefinitely).  Well, anyway, QLISP*is* a research project.I think it would be better to drop the notion of dynamic bindings --SPECIAL variables -- altogether, than to try to graft a hybrid notionon top of Common Lisp.  There are quite a few folks who really wouldlike to flush special variables; but that's an issue guaranteed tocleave the community down the middle.-- JonL --*start*03214 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 16:16:13 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Sep 88  16:14:45 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01194g; Wed, 28 Sep 88 15:12:19 PSTReceived: by bhopal id AA10177g; Wed, 28 Sep 88 16:11:51 PDTDate: Wed, 28 Sep 88 16:11:51 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809282311.AA10177@bhopal>To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKCc: Jon L White <@NSS.Cs.Ucl.AC.UK,@edu.stanford.edu:jonl@lucid.com>, Moon@scrc-stony-brook.arpa, KMP@scrc-stony-brook.arpa, CL-Cleanup@sail.stanford.edu, JAR@ai.ai.mit.eduIn-Reply-To: Jeff Dalton's message of Wed, 28 Sep 88 16:51:09 BST <28871.8809281551@subnode.aiai.ed.ac.uk>Subject: Issue: PROCLAIM-LEXICAL (Version 7)re: I think the semantic implications of adding a declaration that prevents    dynamic binding are sufficiently straightforward that we should not    rule it out just because no one implemented it a year ago.Of course, your right.  I was reacting to the added complication more recently added to permit "mixing" the D and G situations.re: The strangeness in the current proposal is because the dynamic and    lexical environments meet in a separate global environment.  So    a shallow bound implementation can't just change the global cell    when it pushes a new binding.  The shallow binding cell has to    be a separate cell, making symbols (effectively) larger.  KMP    and JAR suggested the use of a single cell combined with search    for the global value if both it and the dynamic are needed.    This is a new machanism, so we might want to think twice about    it.I think moon was right that the problem is really parallel to theimplementation of deep binding.  In fact, PDP10 MacLisp is "shallowbound", but implemented the restoration stack in such a way thatit could find the toplevel value, or any intermediate value, simplyby "walking" back up that stack -- very similar to a deep-bound search [and such "walking" was in fact used when applying downward funargs].   There are numerous "cacheing" techniques to accellerate deep-bound searches, so I'm not making an inherent performance criticism;rather, I fear that this is a new arena for all except perhaps ENVOS[and Lucid's QLISP] and that simply taking on this coding task andall its performance implications is a venture much bigger than I'd like to see labelled as "cleanup".re: . . .     I believe this alternative (which is more or less what was proposed    before minus all the stuff about CONSTANT proclamations, etc.) solves    the main problems (an easily referenced global for deep bound     implementations and a way to establish a global variable without    proclaiming it special and without some implementations thinking    it's a spelling error or an omitted proclamation) and is fairly    noncontroversial.This is what I thought I liked about the proposal long ago.re: In any case, I think there is a fallback better than "do nothing".Hope so!-- JonL --*start*00909 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 28 SEP 88 18:17:53 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01386g; Wed, 28 Sep 88 17:17:16 PSTReceived: by bhopal id AA10655g; Wed, 28 Sep 88 18:16:49 PDTDate: Wed, 28 Sep 88 18:16:49 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809290116.AA10655@bhopal>To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 28 Sep 88 16:29 PDT <880928-162920-1910@Xerox>Subject: Issue: PROCLAIM-LEXICAL (Version 7)re: Well, the Interlisp-10 code that did the shallow stack walking for ENVEVAL   and the like was written in PDP-10 assembler by Alice Hartley at BBN. ...Right, it's only the "obvious" thing to do.By the bye, did you hear that Alice was laid off by Palladian recently?Looks like they are about to go down the infinite tube.-- JonL --*start*01063 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 05 OCT 88 21:14:14 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 471521; Thu 6-Oct-88 00:14:24 EDTDate: Thu, 6 Oct 88 00:14 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PROCLAIM-LEXICAL (Version 7)To: Masinter.PAcc: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK, KMP@STONY-BROOK.SCRC.Symbolics.COM, JAR@AI.AI.MIT.EDUIn-Reply-To: <881005-205744-2164@Xerox>Message-ID: <881006001414.4.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 5 Oct 88 20:57 PDT    From: masinter.pa@Xerox.COM    Sigh --    Can I possibly hope for a new writeup of this from one of you tomorrow?No problem. I'll put something together. I can't guarantee (nor couldanyone, I suppose) that it will be acceptable to all, but at least wecan bring ourselves up-to-date after the big flurry of messages we'vehad since the last proposal.*start*13470 00024 USfReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 06 OCT 88 02:05:56 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 471589; Thu 6-Oct-88 05:06:10 EDTDate: Thu, 6 Oct 88 05:05 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 8)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881006050558.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Per your request, here's a new version merging recent discussion.I don't think this is in a form where it's ready to be voted on, butmaybe it's suitable for X3J13 to be reading over and thinking aboutwhile we work on banging out the details that are up in the air.-----Issue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37), global variables (p68),	      declaration specifiers (p157)Category:     CLARIFICATION/ADDITIONEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87              Version 5 by Masinter 14-Nov-87	      Version 6 by Pitman 15-Sep-88	       (major revision, for review by Jonathan Rees and Jeff Dalton)	      Version 7 by Pitman 24-Sep-88   	       (minor revisions based on comments from Rees and Dalton)	      Version 8 by Pitman 06-Oct-88 (merge recent discussion)Status:	      For Internal DiscussionProblem Description:  Although local variables in Common Lisp may be `special' or `lexical,'  global variables (with the exception of named constants) may currently  only be `special.'  The Scheme language permits free variable references to refer to global  bindings. Their experience suggests that such usage would be useful to  the Common Lisp community. The absence of such a facility in Common Lisp  is a barrier both culturally (to the sharing of ideas) and technically  (to the sharing of code).  SPECIAL proclamations are uncontrollably pervasive. There is no way  to locally override or globally undo a SPECIAL proclamation.Background/Analysis:  Variable evaluation may be viewed in Common Lisp as a search through  a set of environments to find a binding, and then the dereferencing of  that binding. The environments with which Common Lisp deals are  Lexical (L), Dynamic (D), and Global (G).  A SPECIAL declaration for a variable amounts to a request that the  variable be resolved by searching first the Dynamic and then the Global  environment (DG).  As currently described in CLtL, lexical variable reference searches  only the Lexical environment (L).  Because undeclared free variables in the interpreter are implicitly   declared SPECIAL by most (perhaps all) implementations, this amounts  to a search of Lexical, Dynamic, and Global (LDG). However, the   accompanying warnings in many implementations make it clear that this  behavior is not intended to be taken seriously.  Constants are looked up solely in the Global environment (G). They  have other properties as well, of course.  In the Scheme language, the default lookup is first Lexical, then  Global (LG). Providing compatibility for Scheme code is, and more  generally for a Scheme working style is therefore difficult because  Common Lisp does not provide the LG search style.  The issue of whether a variable can be assigned is orthogonal.  The issue of whether a variable can be bound and, if it can be, which  environment is used for the new binding is orthogonal.Proposal (PROCLAIM-LEXICAL:LG):  Provide a new declaration (and proclamation) called LEXICAL which does  LG lookup. That is, variables declared LEXICAL would be looked up first  in the lexical environment (L) and then in the global environment (G)  if not found in the lexical.  Clarify that dynamic binding does DG lookup.  That is, variables  declared SPECIAL would be looked up first in the dynamic  environment (D) and then in the global environment (G) if not found  in the lexical. Further clarify that SYMBOL-VALUE does DG lookup.  Define that a dynamic binding of a variable creates a new binding  in the dynamic environment (D) leaving the global environment (G)  unaffected.  Define that a lexical binding of a variable creates a new binding  in the lexical environment (L), leaving the global environment (G)  unaffected.  Note that an assignment to a variable which is bound in the global   environment (G) will affect lexical (LG) lookups for which there is  no lexical (L) binding and dynamic (DG) lookups for which there is  no dynamic (D) binding.  Note that these restrictions describe an abstract model, not a  concrete implementation. An implementation may still choose to  implement dynamic binding as either deep or shallow, but some  searching may be necessary to find the global cell in shallow bound  implementations [unless dynamic binding has been forbidden for  that variable].  Like SPECIAL declarations (and unlike type declarations),  compilers and interpreters would be required to notice and   respect this declaration.Test Case: #1: (proclaim '(lexical x))     (setq x 1)     (defun f (fn) (list x (funcall fn)))     (defun g (fn)       (let ((x 2))         (declare (special x))	 (funcall fn #'(lambda () x))))     (g #'f) => (1 2) #2: ; Warning: It is unlikely that any serious program would      ;  be written in so obscure a manner as this example.     ;  This just tests the fringe cases.     (proclaim '(lexical x))     (proclaim '(special y))     (setq x 1 y 2)     (defun tst ()       (let ((x 3) (y 4))	 (locally (declare (special x) (lexical y))		  (list x y			(funcall (let ((x 5) (y 6))				   #'(lambda () (list x y))))))))     (tst) => (1 2 (5 4))    If the results of this example confuse you, keep in mind    that the results of code like this would be somewhat    confusing no matter what the chosen semantics because the    code itself is far from perspicuous.    An explanation of this behavior, which some people find less    than intuitive because of the bizarre choice of constructs:          X gets bound lexically to 3 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 4 because Y is [pervasively]       proclaimed SPECIAL.      Reference style for name X is changed to SPECIAL, making       lexical X=3 invisible.      Reference style for name Y is changed to LEXICAL, making       dynamic Y=4 invisible.      Global X=1 and global Y=2 are first two elements of list.      X gets bound lexically to 5 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 6 because Y is [pervasively]       proclaimed SPECIAL.      Closure is returned, capturing [lexical] X=5 but not       [special] Y=6.      Dynamic binding of Y to 6 disappears, dynamic binding       of Y to 4 reverts.      Closure is funcalled, returning captured X=5 and dynamically       active Y=4 in a list which becomes third list element.Rationale:  This mechanism provides a simple and straightforward answer to  the problems stated above.Current Practice:  Probably no one implements this.Cost to Implementors:  A fair amount compiler work would probably be needed. Some compilers  may have hooks for most of this already laying around, but some may not.  Note well that this proposal does not require separate global lexical  and dynamic cells, so the data storage layout of Lisp need not change.  Moon says...   I have now thought of an efficient way to do this on Lisp machines,   using invisible pointers, and another efficient way to do it on   stock hardware, using one extra instruction on every global   reference of one or the other sort, plus a few extra instructions   in SPECIAL binding and unbinding.  Given that, I no longer object   to the proposal as unimplementable.   It doesn't just require a few compiler changes, it requires some   reimplementation of the representation of global variables, with   concomitant changes to the compiler, the loader, the interpreter,   and probably the debugger. Every symbol now potentially has two   values accessible from the interpreter (the current SPECIAL and   the global LEXICAL) and you need the corresponding new data   structure to keep track of that.  Rees suggests...   In shallow-bound implementations, implementors may have to add a   small run-time routine that searches the dynamic saved-binding   stack to look for the global value in the case where the variable   has been dynamically bound.  One might want a bit (or a count)   somewhere (perhaps in the symbol itself) to speed up the common   case of access to a global binding of a variable that hasn't been   dynamically bound; without some kind of optimization, you have to   search the whole saved-binding stack on every reference to a    free [lexical] variable.    While naively you might think you'd incur the cost of clearing the   valid bit on every dynamic binding (not acceptable), in actuality   the bit is a static property of programs (PROGV excepted).  So the   only places you ever need to clear FOO's valid bit are in PROGV,   in the interpreter, and when FASLOADing code that contains a compiled   dynamic binding of FOO.Cost to Users:  For the most part, this change is upward compatible.  Some code-walking tools would have to change.Cost of Non-Adoption:  It would continue to be difficult to share code with Scheme.  New CL users coming from the Scheme community would be confused by  their sometimes inability to map what they know about variable binding  into the CL model of variable binding.  Some interesting native CL applications would be impossible to write  in a syntactically convenient style.Benefits:  Enhanced flexibility of expression.  Rationalization of the semantics of dynamic variables.Aesthetics:  Improved appeal to a certain sector of the programming community.Discussion:  Rees points that it is an oversimplification to describe Scheme's  binding simply as LG since they have no Dynamic environment and  there is no way to distinguish LG and LDG. However, the reasons he  prefers LG are:   1. It's nice for readability and understandability to have a      declaration which tells you that a variable will not be      dynamically bound.   2. It's nice for performance in deep-bound implementations to have a      declaration that says that no search will be needed.  Of course, he notes, there could be a counter-argument to item 2  (in favor of LDG) in order to prefer shallow bound implementations,  but that still would not defeat the argument in item 1. Rees believes  that LG is slightly preferrable, but that LDG would be essentially  adequate for most of his needs.  Pitman supports PROCLAIM-LEXICAL:LG and believes that giving LDG the  name LEXICAL would be a serious mistake, leaving open the door for  program bugs due to accidental binding of variables presumed by the  programmer not to be bound. If someone (Moon?) seriously wanted LDG  type variables in addition to LG variables (under a name other than  LEXICAL), Pitman would not object.  Dalton expressed support for PROCLAIM-LEXICAL:LG (Version 6).  He observes that another reason for opposing LDG is that it suggests  the possibility that someone might want DLG. LG is simpler and still  accomplishes the stated purpose. He adds ``I would like to be able  to explain the global environment as a sort of giant, extensible  LET abound everything.  This proposal seems to get fairly close.''  It would be possible to submit a proposal for a GLOBAL (G) declaration  under separate cover if anyone (Xerox?) was interested. Pitman thinks  this would be an interesting idea. Dalton points out, however, that  already with this proposal there is enough power to at least deal with  globals -- albeit circuitously. For example, to reference a global  variable X, one could write subroutines such as:   (defun     global-x ()      (declare (lexical x)) x)   (defun set-global-x (value) (declare (lexical x)) (setq x value))  Eg, consider:   (defun f (x) (+ (global-x) x))  In principle, we could imaging saying that free variables should be  lexical by default, but that would only reduce error checking to no  good end. To be really useful, this proposal will need to be followed  by a proposal for primitives analogous to DEFVAR and/or DEFPARAMETER  but for lexical variables. However, since arguments over syntax are  likely to have plenty of issues of their own, we've separated this  proposal for primitive functionality from issues of syntax which  can be dealt with separately once this is passed.  Moon expressed concerns about the efficiency issues but after  thinking about it for a while convinced himself that this is  efficiently implementable both on stock and special purpose hardware.  JonL expressed concerns about the last-minute nature of this change,  which he sees as untested.  Dalton suggests that an alternative solution to the speed issue  might be possible to obtain by restricting a particular variable to  be either LEXICAL or SPECIAL but not both.  Dalton points that even if people don't like the details here, there  must be a better fallback solution than "do nothing". Pitman agrees  heartily.*start*13301 00024 USfReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 21:29:17 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  21:11:58 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 OCT 88 21:06:34 PDTDate: 8 Oct 88 21:06 PDTSender: masinter.paSubject: DRAFT Issue: PROCLAIM-LEXICAL (Version 8)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-210634-2532@Xerox>We're still working on this one.!Status: DRAFTIssue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37), global variables (p68),	      declaration specifiers (p157)Category:     CLARIFICATION/ADDITIONEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87              Version 5 by Masinter 14-Nov-87	      Version 6 by Pitman 15-Sep-88	       (major revision, for review by Jonathan Rees and Jeff Dalton)	      Version 7 by Pitman 24-Sep-88   	       (minor revisions based on comments from Rees and Dalton)	      Version 8 by Pitman 06-Oct-88 (merge recent discussion)Status:	      For Internal DiscussionProblem Description:  Although local variables in Common Lisp may be `special' or `lexical,'  global variables (with the exception of named constants) may currently  only be `special.'  The Scheme language permits free variable references to refer to global  bindings. Their experience suggests that such usage would be useful to  the Common Lisp community. The absence of such a facility in Common Lisp  is a barrier both culturally (to the sharing of ideas) and technically  (to the sharing of code).  SPECIAL proclamations are uncontrollably pervasive. There is no way  to locally override or globally undo a SPECIAL proclamation.Background/Analysis:  Variable evaluation may be viewed in Common Lisp as a search through  a set of environments to find a binding, and then the dereferencing of  that binding. The environments with which Common Lisp deals are  Lexical (L), Dynamic (D), and Global (G).  A SPECIAL declaration for a variable amounts to a request that the  variable be resolved by searching first the Dynamic and then the Global  environment (DG).  As currently described in CLtL, lexical variable reference searches  only the Lexical environment (L).  Because undeclared free variables in the interpreter are implicitly   declared SPECIAL by most (perhaps all) implementations, this amounts  to a search of Lexical, Dynamic, and Global (LDG). However, the   accompanying warnings in many implementations make it clear that this  behavior is not intended to be taken seriously.  Constants are looked up solely in the Global environment (G). They  have other properties as well, of course.  In the Scheme language, the default lookup is first Lexical, then  Global (LG). Providing compatibility for Scheme code is, and more  generally for a Scheme working style is therefore difficult because  Common Lisp does not provide the LG search style.  The issue of whether a variable can be assigned is orthogonal.  The issue of whether a variable can be bound and, if it can be, which  environment is used for the new binding is orthogonal.Proposal (PROCLAIM-LEXICAL:LG):  Provide a new declaration (and proclamation) called LEXICAL which does  LG lookup. That is, variables declared LEXICAL would be looked up first  in the lexical environment (L) and then in the global environment (G)  if not found in the lexical.  Clarify that dynamic binding does DG lookup.  That is, variables  declared SPECIAL would be looked up first in the dynamic  environment (D) and then in the global environment (G) if not found  in the lexical. Further clarify that SYMBOL-VALUE does DG lookup.  Define that a dynamic binding of a variable creates a new binding  in the dynamic environment (D) leaving the global environment (G)  unaffected.  Define that a lexical binding of a variable creates a new binding  in the lexical environment (L), leaving the global environment (G)  unaffected.  Note that an assignment to a variable which is bound in the global   environment (G) will affect lexical (LG) lookups for which there is  no lexical (L) binding and dynamic (DG) lookups for which there is  no dynamic (D) binding.  Note that these restrictions describe an abstract model, not a  concrete implementation. An implementation may still choose to  implement dynamic binding as either deep or shallow, but some  searching may be necessary to find the global cell in shallow bound  implementations [unless dynamic binding has been forbidden for  that variable].  Like SPECIAL declarations (and unlike type declarations),  compilers and interpreters would be required to notice and   respect this declaration.Test Case: #1: (proclaim '(lexical x))     (setq x 1)     (defun f (fn) (list x (funcall fn)))     (defun g (fn)       (let ((x 2))         (declare (special x))	 (funcall fn #'(lambda () x))))     (g #'f) => (1 2) #2: ; Warning: It is unlikely that any serious program would      ;  be written in so obscure a manner as this example.     ;  This just tests the fringe cases.     (proclaim '(lexical x))     (proclaim '(special y))     (setq x 1 y 2)     (defun tst ()       (let ((x 3) (y 4))	 (locally (declare (special x) (lexical y))		  (list x y			(funcall (let ((x 5) (y 6))				   #'(lambda () (list x y))))))))     (tst) => (1 2 (5 4))    If the results of this example confuse you, keep in mind    that the results of code like this would be somewhat    confusing no matter what the chosen semantics because the    code itself is far from perspicuous.    An explanation of this behavior, which some people find less    than intuitive because of the bizarre choice of constructs:          X gets bound lexically to 3 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 4 because Y is [pervasively]       proclaimed SPECIAL.      Reference style for name X is changed to SPECIAL, making       lexical X=3 invisible.      Reference style for name Y is changed to LEXICAL, making       dynamic Y=4 invisible.      Global X=1 and global Y=2 are first two elements of list.      X gets bound lexically to 5 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 6 because Y is [pervasively]       proclaimed SPECIAL.      Closure is returned, capturing [lexical] X=5 but not       [special] Y=6.      Dynamic binding of Y to 6 disappears, dynamic binding       of Y to 4 reverts.      Closure is funcalled, returning captured X=5 and dynamically       active Y=4 in a list which becomes third list element.Rationale:  This mechanism provides a simple and straightforward answer to  the problems stated above.Current Practice:  Probably no one implements this.Cost to Implementors:  A fair amount compiler work would probably be needed. Some compilers  may have hooks for most of this already laying around, but some may not.  Note well that this proposal does not require separate global lexical  and dynamic cells, so the data storage layout of Lisp need not change.  Moon says...   I have now thought of an efficient way to do this on Lisp machines,   using invisible pointers, and another efficient way to do it on   stock hardware, using one extra instruction on every global   reference of one or the other sort, plus a few extra instructions   in SPECIAL binding and unbinding.  Given that, I no longer object   to the proposal as unimplementable.   It doesn't just require a few compiler changes, it requires some   reimplementation of the representation of global variables, with   concomitant changes to the compiler, the loader, the interpreter,   and probably the debugger. Every symbol now potentially has two   values accessible from the interpreter (the current SPECIAL and   the global LEXICAL) and you need the corresponding new data   structure to keep track of that.  Rees suggests...   In shallow-bound implementations, implementors may have to add a   small run-time routine that searches the dynamic saved-binding   stack to look for the global value in the case where the variable   has been dynamically bound.  One might want a bit (or a count)   somewhere (perhaps in the symbol itself) to speed up the common   case of access to a global binding of a variable that hasn't been   dynamically bound; without some kind of optimization, you have to   search the whole saved-binding stack on every reference to a    free [lexical] variable.    While naively you might think you'd incur the cost of clearing the   valid bit on every dynamic binding (not acceptable), in actuality   the bit is a static property of programs (PROGV excepted).  So the   only places you ever need to clear FOO's valid bit are in PROGV,   in the interpreter, and when FASLOADing code that contains a compiled   dynamic binding of FOO.Cost to Users:  For the most part, this change is upward compatible.  Some code-walking tools would have to change.Cost of Non-Adoption:  It would continue to be difficult to share code with Scheme.  New CL users coming from the Scheme community would be confused by  their sometimes inability to map what they know about variable binding  into the CL model of variable binding.  Some interesting native CL applications would be impossible to write  in a syntactically convenient style.Benefits:  Enhanced flexibility of expression.  Rationalization of the semantics of dynamic variables.Aesthetics:  Improved appeal to a certain sector of the programming community.Discussion:  Rees points that it is an oversimplification to describe Scheme's  binding simply as LG since they have no Dynamic environment and  there is no way to distinguish LG and LDG. However, the reasons he  prefers LG are:   1. It's nice for readability and understandability to have a      declaration which tells you that a variable will not be      dynamically bound.   2. It's nice for performance in deep-bound implementations to have a      declaration that says that no search will be needed.  Of course, he notes, there could be a counter-argument to item 2  (in favor of LDG) in order to prefer shallow bound implementations,  but that still would not defeat the argument in item 1. Rees believes  that LG is slightly preferrable, but that LDG would be essentially  adequate for most of his needs.  Pitman supports PROCLAIM-LEXICAL:LG and believes that giving LDG the  name LEXICAL would be a serious mistake, leaving open the door for  program bugs due to accidental binding of variables presumed by the  programmer not to be bound. If someone (Moon?) seriously wanted LDG  type variables in addition to LG variables (under a name other than  LEXICAL), Pitman would not object.  Dalton expressed support for PROCLAIM-LEXICAL:LG (Version 6).  He observes that another reason for opposing LDG is that it suggests  the possibility that someone might want DLG. LG is simpler and still  accomplishes the stated purpose. He adds ``I would like to be able  to explain the global environment as a sort of giant, extensible  LET abound everything.  This proposal seems to get fairly close.''  It would be possible to submit a proposal for a GLOBAL (G) declaration  under separate cover if anyone (Xerox?) was interested. Pitman thinks  this would be an interesting idea. Dalton points out, however, that  already with this proposal there is enough power to at least deal with  globals -- albeit circuitously. For example, to reference a global  variable X, one could write subroutines such as:   (defun     global-x ()      (declare (lexical x)) x)   (defun set-global-x (value) (declare (lexical x)) (setq x value))  Eg, consider:   (defun f (x) (+ (global-x) x))  In principle, we could imaging saying that free variables should be  lexical by default, but that would only reduce error checking to no  good end. To be really useful, this proposal will need to be followed  by a proposal for primitives analogous to DEFVAR and/or DEFPARAMETER  but for lexical variables. However, since arguments over syntax are  likely to have plenty of issues of their own, we've separated this  proposal for primitive functionality from issues of syntax which  can be dealt with separately once this is passed.  Moon expressed concerns about the efficiency issues but after  thinking about it for a while convinced himself that this is  efficiently implementable both on stock and special purpose hardware.  JonL expressed concerns about the last-minute nature of this change,  which he sees as untested.  Dalton suggests that an alternative solution to the speed issue  might be possible to obtain by restricting a particular variable to  be either LEXICAL or SPECIAL but not both.  Dalton points that even if people don't like the details here, there  must be a better fallback solution than "do nothing". Pitman agrees  heartily.     ----- End Forwarded Messages -----*start*02107 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 OCT 88 12:40:15 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 14 Oct 88  12:38:54 PDTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.0-cs)	id AA27687; Fri, 14 Oct 88 13:38:33 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA20475; Fri, 14 Oct 88 13:38:28 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810141938.AA20475@defun.utah.edu>Date: Fri, 14 Oct 88 13:38:27 MDTSubject: Re: issue PROCLAIM-LEXICALTo: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Cc: cl-cleanup@sail.stanford.eduIn-Reply-To: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, Fri, 14 Oct 88 19:11:41 BST> Date: Fri, 14 Oct 88 19:11:41 BST> From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>> There are some problems with the DEFCONSTANT model for "global lexical".> The constants are effectively proclaimed SPECIAL but (special) binding> is disallowed.  Because of the SPECIAL proclamation, this prevents> lexical binding too; but lexical binding should not be prevented for> global lexicals.That isn't what CLtL says about DEFCONSTANT.  From p. 69:  Once a name has been declared by defconstant to be constant, any  further assignment to or binding of that special variable is an error.  [...]  A compiler may also choose to issue warnings about bindings of  the lexical variable of the same name.My impression is that this wording was carefully chosen with thespecific intent of allowing (but maybe not encouraging) lexicalbinding of the name.  Note that it specifically outlaws specialbinding but says something else entirely about lexical binding.  Also,I don't believe this means constants are effectively proclaimedSPECIAL, because (as the language is defined in CLtL) the question oflexical bindings would never come up at all then.> That said, however, I don't think I disagree with you very much.Likewise.-Sandra-------*start*02191 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 15:32:26 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:25:41 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA26040; Thu, 13 Oct 88 16:23:54 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19945; Thu, 13 Oct 88 16:23:52 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132223.AA19945@defun.utah.edu>Date: Thu, 13 Oct 88 16:23:50 MDTSubject: issue PROCLAIM-LEXICALTo: cl-cleanup@sail.stanford.eduI don't really like proposal LG very much.  I gather from the discussionthat there was also a proposal LDG around at one time?  This issue appears to be addressing what I consider to be actually twoseparate problems.  The first problem is a way to undo SPECIALdeclarations.  Wasn't there once a proposal for an UNSPECIALdeclaration to deal with this? The second problem is a way to specify a "global lexical variable".To me that implies something very much like what is specified for thebinding behavior of DEFCONSTANT (it specifies a separate set ofrestrictions on SETQ'ing).  I've thought for a long time that CommonLisp ought to provide a declaration for variable binding correspondingto what DEFCONSTANT does.  Why not assign that meaning to the LEXICALdeclaration, or maybe call it GLOBAL if people object to usingLEXICAL?  (The behavior of DEFCONSTANT is actually pretty close towhat "GLOBAL" variables in PSL were like.) I suppose people would wantan UNGLOBAL too.... The thing about proposal LG that strikes me as being the mostconfusing to users and troublesome to implementors is allowing accessto both the dynamic and global value of the same variable.  I think itwould be reasonable to make the two mutually exclusive. Finally, a comment on the existing writeup.  Given all the differentproposals on the interpretation of declarations that are floatingaround, I had a hard time understanding the second example.  It wouldbe nice if the writeup stated which rules are being used.-Sandra-------*start*01337 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:09:21 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  16:00:35 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476091; Thu 13-Oct-88 18:57:58 EDTDate: Thu, 13 Oct 88 18:57 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 8)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013185748.2.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: KMP will be responsible for writing or acquiring new draft.X3J13 meeting: Masinter: Not ready for vote, but comments solicited. JonL: Would the presence of UNSPECIAL declaration help? KMP: No. UNSPECIAL doesn't address the original issue of closing      over these global variables. JonL hadn't studied this enough and had a bunch of questions. Maybe we'll get more feedback from him when he's read it more carefully.Offline: Julian Padgett (I probably got the spelling wrong) said he supports the LG proposal. He doesn't like the D stuff getting mixed up in there at all.*start*04713 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 OCT 88 12:24:48 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 14 Oct 88  12:18:42 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06776; 14 Oct 88 19:09 BSTDate: Fri, 14 Oct 88 19:11:41 BSTMessage-Id: <27644.8810141811@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICALTo: sandra <@cs.utah.edu:sandra@defun>, cl-cleanup@sail.stanford.eduIn-Reply-To: sandra's message of Thu, 13 Oct 88 16:23:50 MDT> I don't really like proposal LG very much.  I gather from the discussion> that there was also a proposal LDG around at one time?I think the description in termas of LG, LDG, etc. can be confusing.LDG is supposedly what happens to free references: look in L; if notthere, it's dynamic and that means DG.  But variables declared specialare supposed to be just DG.  But what if there's a lexical bindingin the way?  Don't you have to look in L first?  So perhaps thatcase should be called LDG too.I prefer a prepainting model: first paint all special variablesred.  One of the rules for painting has free refs painted red.Then they are just like variables declared special.  In thisway, we separate the question "what's special?" from "how isthe value found?".> This issue appears to be addressing what I consider to be actually> two separate problems.  The first problem is a way to undo SPECIAL> declarations.  Wasn't there once a proposal for an UNSPECIAL> declaration to deal with this? They can be separate.  But they might not be.  If there's a LEXICALproclamation for "global lexical" or "default to lexical and note thatthis is a variable name that might occur free (so don't warn me aboutit)", then the declaration that overrides a SPECIAL proclamationshould probably be LEXICAL too, rather than UNSPECIAL.> The second problem is a way to specify a "global lexical variable".> To me that implies something very much like what is specified for the> binding behavior of DEFCONSTANT (it specifies a separate set of> restrictions on SETQ'ing).  I've thought for a long time that Common> Lisp ought to provide a declaration for variable binding corresponding> to what DEFCONSTANT does.Now, that (i.e., CONSTANT proclamation) I think should be a separateissue.> Why not assign that meaning to the LEXICAL> declaration, or maybe call it GLOBAL if people object to using> LEXICAL?  (The behavior of DEFCONSTANT is actually pretty close to> what "GLOBAL" variables in PSL were like.) I suppose people would want> an UNGLOBAL too.... There are some problems with the DEFCONSTANT model for "global lexical".The constants are effectively proclaimed SPECIAL but (special) bindingis disallowed.  Because of the SPECIAL proclamation, this preventslexical binding too; but lexical binding should not be prevented forglobal lexicals.  "Global" in Lisps like PSL means something like"special but can't bind".Another idea that comes out of Lisps that more or less had only dynamicvariables (and used deep binding) is that one wants to be able to getthe global value even if there are local (lexical) variables with thesame name in the way and perhaps even if there special bindings for thatname.  In the current proposal, the way to get the global value iseither to call a function that refers free (so there's no lexicalshadowing) or to agree not to special bind that name and then use(LOCALLY (DECLARE (SPECIAL V)) V).  I think those are reasonablesolutions; whether the desire for something more is also reasonable isless clear.That said, however, I don't think I disagree with you very much.> The thing about proposal LG that strikes me as being the most> confusing to users and troublesome to implementors is allowing access> to both the dynamic and global value of the same variable.  I think it> would be reasonable to make the two mutually exclusive. True, that would be a reasonable position to fall back to.  But I wouldprefer to think of it as lexical and special being mutually exclusive.Either kind of variable might have a global value.  But, as in a LET,there can be only one kind of binding for a given name at a given level.Global should be a "given level".  You might think of this as sayingthere are only two envs -- L and D -- and no separate G.  In thecurrent "LG" proposal, it's best to think of it as having three envs:L, D, and G.  And if you think of it that way, the proposal makessense.-- Jeff*start*01463 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 OCT 88 15:27:31 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 15 Oct 88  10:12:51 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa01772; 15 Oct 88 17:58 BSTDate: Sat, 15 Oct 88 18:01:42 BSTMessage-Id: <28618.8810151701@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICALTo: sandra <@cs.utah.edu:sandra@defun>In-Reply-To: sandra's message of Fri, 14 Oct 88 13:38:27 MDTCc: cl-cleanup@sail.stanford.edu> > Date: Fri, 14 Oct 88 19:11:41 BST> > From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>> > > There are some problems with the DEFCONSTANT model for "global lexical".> > The constants are effectively proclaimed SPECIAL but (special) binding> > is disallowed.  Because of the SPECIAL proclamation, this prevents> > lexical binding too; but lexical binding should not be prevented for> > global lexicals.> > That isn't what CLtL says about DEFCONSTANT.  From p. 69:You're right, but I was making deductions.  Perhaps I read too muchinto "that special variable" and "like DEFPARAMETER but".  Nonetheless,Lucid CL 2.1 does proclaim it special.All I wanted to establish was that lexical bindings should be OK.*start*02452 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 15:48:32 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 18 Oct 88  14:48:25 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 478250; Tue 18-Oct-88 17:48:10 EDTDate: Tue, 18 Oct 88 17:48 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 8)To: jonl@lucid.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8810182126.AA01653@bhopal>Message-ID: <881018174804.4.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Tue, 18 Oct 88 14:26:28 PDT    From: Jon L White <jonl@lucid.com>    ... The LG proposal doesn't clearly spell out that it is an error to have     dynamic bindings for variables declared LEXICAL -- I don't yet see it as    being distinct from the LDG proposal.It isn't distinct if you prohibit such bindings. But it's gratuitous todo so, in my opinion.If by variable you mean variable name, it is not an error to have adynamic binding for a variable whose name has been proclaimed lexical.Nor is it an error to have a lexical binding of a variable whose namehas been proclaimed special. That's what example 2 illustrates.  Astripped down version is: (PROCLAIM '(LEXICAL X)) (PROCLAIM '(SPECIAL Y)) (SETQ X 1 Y 2) (DEFUN FOO (X Y)   (DECLARE (SPECIAL X) (LEXICAL Y))   (LIST X (LOCALLY (DECLARE (LEXICAL X)) X)         Y (LOCALLY (DECLARE (SPECIAL Y)) Y))) (FOO 3 4) => (3 1 4 2)				;LG    In particular, in the Proposal part, I would change:      Clarify that dynamic binding does DG lookup.  That is, variables      declared SPECIAL would be looked up first in the dynamic      environment (D) and then in the global environment (G) if not found      in the lexical. Further clarify that SYMBOL-VALUE does DG lookup.If this is really out of the proposal; it has a typo. "lexical" in thelast line should be "dynamic".I will ammend the proposal to make some of this clear. At that time I'llreview your wording changes in more detail and if they look good, I'llmerge them.Your message was a bit rambly and so I had trouble extracting a `bottomline.' Am I to mark you as favoring LG over LDG (in the Discussion)?*start*04087 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 15:48:43 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 18 Oct 88  14:28:24 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA06265g; Tue, 18 Oct 88 14:28:01 PDTReceived: by bhopal id AA01653g; Tue, 18 Oct 88 14:26:28 PDTDate: Tue, 18 Oct 88 14:26:28 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810182126.AA01653@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Thu, 13 Oct 88 18:57 EDT <881013185748.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 8)re: . . .      JonL hadn't studied this enough and had a bunch of questions.     Maybe we'll get more feedback from him when he's read it more carefully.    Offline:     Julian Padgett (I probably got the spelling wrong) said he     supports the LG proposal. He doesn't like the D stuff getting     mixed up in there at all.My problem with this proposal was exactly that attributed to Padgett.The LG proposal doesn't clearly spell out that it is an error to have dynamic bindings for variables declared LEXICAL -- I don't yet see it asbeing distinct from the LDG proposal.   If this prohibition were agreed upon, then the whole set of issues discussed under the "Cost to Implementors" section would be moot, and that section could simply say "slight".I'm just a bit puzzled by the current state of the proposal -- yourcomments (KMP's) in the Discussion section indicate that you think it already rules out the objectional case:  Pitman supports PROCLAIM-LEXICAL:LG and believes that giving LDG the  name LEXICAL would be a serious mistake, leaving open the door for  program bugs due to accidental binding of variables presumed by the  programmer not to be bound. If someone (Moon?) seriously wanted LDG  type variables in addition to LG variables (under a name other than  LEXICAL), Pitman would not object.If this is so, then perhaps all we need to do is clarify the wordingof the proposal a bit.In particular, in the Proposal part, I would change:  Clarify that dynamic binding does DG lookup.  That is, variables  declared SPECIAL would be looked up first in the dynamic  environment (D) and then in the global environment (G) if not found  in the lexical. Further clarify that SYMBOL-VALUE does DG lookup.  Define that a dynamic binding of a variable creates a new binding  in the dynamic environment (D) leaving the global environment (G)  unaffected.into:  Clarify that a dynamic binding of a variable creates a new binding  in the dynamic environment (D) leaving the global environment (G)  unaffected.  Clarify that special variable access does DG lookup.  That is,   variables declared SPECIAL would be looked up first in the dynamic  environment (D) and then in the global environment (G) if not found  in the dynamic one. Further clarify that SYMBOL-VALUE does DG lookup.And I would change:  Define that a lexical binding of a variable creates a new binding  in the lexical environment (L), leaving the global environment (G)  unaffected.into:  Define that a lexical binding of a variable creates a new binding  in the lexical environment (L), leaving the global environment (G)  and the dynamic environment (D) unaffected.Furthermore, I would ammended the Discussion section to explain the remark:  JonL expressed concerns about the last-minute nature of this change,  which he sees as untested.so that the "last-minute" is clearly seen to be referring to the mixin of the dynamic environment implicit in the LDG proposal.I have long favored the approach that permitted LEXICAL proclamation tomean basically what QLISP's GLOBAL proclamation does.   I think LEXICAL would also permit local lexical bindings, whereas GLOBAL doesn't, but that isn't important; flushing the dynamic mixin is what I'd like to see.-- JonL --*start*02603 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 MAR 88 17:14:54 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 9 Mar 88  17:11:37 PSTReceived: by labrea.Stanford.EDU; Wed, 9 Mar 88 17:12:21 PSTReceived: from bhopal.lucid.com by edsel id AA14195g; Wed, 9 Mar 88 16:42:42 PSTReceived: by bhopal id AA09327g; Wed, 9 Mar 88 16:49:12 PSTDate: Wed, 9 Mar 88 16:49:12 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8803100049.AA09327@bhopal.lucid.com>To: vanroggen@hudson.dec.comCc: cl-compiler@sail.Stanford.EDU, cl-cleanup@sail.Stanford.EDUIn-Reply-To: "AITG::VANROGGEN"'s message of 9 Mar 88 15:01:00 EDT <8803092111.AA13223@edsel.lucid.com>Subject: PROCLAIM [and "lexical scoping"?]I tend to agree with your feelings about non-DEFUN forms in a file -- thatit's undesirable to have them all implicitly eval-when(eval compile).At worst, one might want to include PROCLAIM in with the 7-extremely-randoms-- perhaps as the eighth wonder of the randomness world.On the other hand, I see lots of need for a lexical file proclaim.  Thiswould be a good time to define something that has DECLARE syntax (i.e.,isn't a function that "evaluates its arguments") but which also hasPROCLAIM pervasiveness within a file.  The reason I call it "lexical fileproclaim" is that I want it to affect only the lexically-apparent code in the file in which it is found at top level (for whatever it means to be "attop level").  So unlike current PROCLAIM, it would not affect the evaluationof random Lisp forms during, say, macro expansion, or during a sub-recursivecall to COMPILE-FILE, etc.  On the other hand, unlike current semantics for (LOCALLY (DECLARE (SPECIAL ...)) ...), it's effect would be "pervasive".Would information from "lexical, file-proclaim" affect the code producedby macroexpansions?  after all, such code isn't "lexically apparent" inthe file?  This issue is no different than the current controversy aboutwhether macro-expansion produced code should be "captured" by thelexical environment surrounding it, or whether it should be insulatedfrom it.  Thus this controversy should be left to the macro committee,or whatever other body addresses it; it's independent of compile-filesemantics.What is a file such that "lexical file-proclaim" makes sense.  Again,I think the answer is to defer to COMPILE-FILE; whatever it thinks a"file" is, then that is what the scope of "lexical file-proclaim" is.-- JonL --*start*13602 00024 USfDate:  8 Dec 88 21:54 PSTFrom: masinter.paSubject: Issue: PROCLAIM-LEXICAL (Version 9)To: cl-cleanup@sail.stanford.educc: Masinterline-fold: NOI've attempted to make the edits that JonL suggested inhis message of 18-Oct-88. I wish this were shorter, e.g., that we could say what we haveto say with less Discussion. I'm sorry I haven't the courageto tackle it.Issue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37), global variables (p68),	      declaration specifiers (p157)Category:     CLARIFICATION/ADDITIONEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87              Version 5 by Masinter 14-Nov-87              Version 6 by Pitman 15-Sep-88	       (major revision, for review by Jonathan Rees and Jeff Dalton)	      Version 7 by Pitman 24-Sep-88   	       (minor revisions based on comments from Rees and Dalton)	      Version 8 by Pitman 06-Oct-88 (merge recent discussion)	      Version 9 by Masinter  8-Dec-88 (make JonL's changes)Problem Description:  Although local variables in Common Lisp may be `special' or `lexical,'  global variables (with the exception of named constants) may currently  only be `special.'  The Scheme language permits free variable references to refer to global  bindings. Their experience suggests that such usage would be useful to  the Common Lisp community. The absence of such a facility in Common Lisp  is a barrier both culturally (to the sharing of ideas) and technically  (to the sharing of code).  SPECIAL proclamations are uncontrollably pervasive. There is no way  to locally override or globally undo a SPECIAL proclamation.Background/Analysis:  Variable evaluation may be viewed in Common Lisp as a search through  a set of environments to find a binding, and then the dereferencing of  that binding. The environments with which Common Lisp deals are  Lexical (L), Dynamic (D), and Global (G).  A SPECIAL declaration for a variable amounts to a request that the  variable be resolved by searching first the Dynamic and then the Global  environment (DG).  As currently described in CLtL, lexical variable reference searches  only the Lexical environment (L).  Because undeclared free variables in the interpreter are implicitly   declared SPECIAL by most (perhaps all) implementations, this amounts  to a search of Lexical, Dynamic, and Global (LDG). However, the   accompanying warnings in many implementations make it clear that this  behavior is not intended to be taken seriously.  Constants are looked up solely in the Global environment (G). They  have other properties as well, of course.  In the Scheme language, the default lookup is first Lexical, then  Global (LG). Providing compatibility for Scheme code is, and more  generally for a Scheme working style is therefore difficult because  Common Lisp does not provide the LG search style.  The issue of whether a variable can be assigned is orthogonal.  The issue of whether a variable can be bound and, if it can be, which  environment is used for the new binding is orthogonal.Proposal (PROCLAIM-LEXICAL:LG):  Provide a new declaration (and proclamation) called LEXICAL which implies  LG lookup. That is, variables declared LEXICAL would be looked up first  in the lexical environment (L) and then in the global environment (G)  if not found in the lexical.  Clarify that a dynamic binding of a variable creates a new binding  in the dynamic environment (D) leaving the global environment (G)  unaffected.  Clarify that special variable access does DG lookup.  That is,   variables declared SPECIAL would be looked up first in the dynamic  environment (D) and then in the global environment (G) if not found  in the dynamic one. Further clarify that SYMBOL-VALUE does DG lookup.  Define that a lexical binding of a variable creates a new binding  in the lexical environment (L), leaving the global environment (G)  and the dynamic environment (D) unaffected.  Note that an assignment to a variable which is bound in the global   environment (G) will affect lexical (LG) lookups for which there is  no lexical (L) binding and dynamic (DG) lookups for which there is  no dynamic (D) binding.  Note that these restrictions describe an abstract model, not a  concrete implementation. An implementation may still choose to  implement dynamic binding as either deep or shallow, but some  searching may be necessary to find the global cell in shallow bound  implementations [unless dynamic binding has been forbidden for  that variable].  Like SPECIAL declarations (and unlike type declarations),  compilers and interpreters would be required to notice and   respect LEXICAL declarations.Examples: #1: (proclaim '(lexical x))     (setq x 1)     (defun f (fn) (list x (funcall fn)))     (defun g (fn)       (let ((x 2))         (declare (special x))	 (funcall fn #'(lambda () x))))     (g #'f) => (1 2) #2: ; Warning: It is unlikely that any serious program would      ;  be written in so obscure a manner as this example.     ;  This just tests the fringe cases.     (proclaim '(lexical x))     (proclaim '(special y))     (setq x 1 y 2)     (defun tst ()       (let ((x 3) (y 4))	 (locally (declare (special x) (lexical y))		  (list x y			(funcall (let ((x 5) (y 6))				   #'(lambda () (list x y))))))))     (tst) => (1 2 (5 4))    If the results of this example confuse you, keep in mind    that the results of code like this would be somewhat    confusing no matter what the chosen semantics because the    code itself is far from perspicuous.    An explanation of this behavior, which some people find less    than intuitive because of the bizarre choice of constructs:          X gets bound lexically to 3 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 4 because Y is [pervasively]       proclaimed SPECIAL.      Reference style for name X is changed to SPECIAL, making       lexical X=3 invisible.      Reference style for name Y is changed to LEXICAL, making       dynamic Y=4 invisible.      Global X=1 and global Y=2 are first two elements of list.      X gets bound lexically to 5 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 6 because Y is [pervasively]       proclaimed SPECIAL.      Closure is returned, capturing [lexical] X=5 but not       [special] Y=6.      Dynamic binding of Y to 6 disappears, dynamic binding       of Y to 4 reverts.      Closure is funcalled, returning captured X=5 and dynamically       active Y=4 in a list which becomes third list element.Rationale:  This mechanism provides a simple and straightforward answer to  the problems stated above.Current Practice:  Probably no one implements this.Cost to Implementors:  A fair amount compiler work would probably be needed. Some compilers  may have hooks for most of this already laying around, but some may not.  Note well that this proposal does not require separate global lexical  and dynamic cells, so the data storage layout of Lisp need not change.  Moon says...   I have now thought of an efficient way to do this on Lisp machines,   using invisible pointers, and another efficient way to do it on   stock hardware, using one extra instruction on every global   reference of one or the other sort, plus a few extra instructions   in SPECIAL binding and unbinding.  Given that, I no longer object   to the proposal as unimplementable.   It doesn't just require a few compiler changes, it requires some   reimplementation of the representation of global variables, with   concomitant changes to the compiler, the loader, the interpreter,   and probably the debugger. Every symbol now potentially has two   values accessible from the interpreter (the current SPECIAL and   the global LEXICAL) and you need the corresponding new data   structure to keep track of that.  Rees suggests...   In shallow-bound implementations, implementors may have to add a   small run-time routine that searches the dynamic saved-binding   stack to look for the global value in the case where the variable   has been dynamically bound.  One might want a bit (or a count)   somewhere (perhaps in the symbol itself) to speed up the common   case of access to a global binding of a variable that hasn't been   dynamically bound; without some kind of optimization, you have to   search the whole saved-binding stack on every reference to a    free [lexical] variable.    While naively you might think you'd incur the cost of clearing the   valid bit on every dynamic binding (not acceptable), in actuality   the bit is a static property of programs (PROGV excepted).  So the   only places you ever need to clear FOO's valid bit are in PROGV,   in the interpreter, and when FASLOADing code that contains a compiled   dynamic binding of FOO.Cost to Users:  For the most part, this change is upward compatible.  Some code-walking tools would have to change.Cost of Non-Adoption:  It would continue to be difficult to share code with Scheme.  New CL users coming from the Scheme community would be confused by  their sometimes inability to map what they know about variable binding  into the CL model of variable binding.  Some interesting native CL applications would be impossible to write  in a syntactically convenient style.Benefits:  Enhanced flexibility of expression.  Rationalization of the semantics of dynamic variables.Aesthetics:  Improved appeal to a certain sector of the programming community.Discussion:  Rees points that it is an oversimplification to describe Scheme's  binding simply as LG since they have no Dynamic environment and  there is no way to distinguish LG and LDG. However, the reasons he  prefers LG are:   1. It's nice for readability and understandability to have a      declaration which tells you that a variable will not be      dynamically bound.   2. It's nice for performance in deep-bound implementations to have a      declaration that says that no search will be needed.  Of course, he notes, there could be a counter-argument to item 2  (in favor of LDG) in order to prefer shallow bound implementations,  but that still would not defeat the argument in item 1. Rees believes  that LG is slightly preferrable, but that LDG would be essentially  adequate for most of his needs.  Pitman supports PROCLAIM-LEXICAL:LG and believes that giving LDG the  name LEXICAL would be a serious mistake, leaving open the door for  program bugs due to accidental binding of variables presumed by the  programmer not to be bound. If someone (Moon?) seriously wanted LDG  type variables in addition to LG variables (under a name other than  LEXICAL), Pitman would not object.  Dalton expressed support for PROCLAIM-LEXICAL:LG (Version 6).  He observes that another reason for opposing LDG is that it suggests  the possibility that someone might want DLG. LG is simpler and still  accomplishes the stated purpose. He adds ``I would like to be able  to explain the global environment as a sort of giant, extensible  LET abound everything.  This proposal seems to get fairly close.''  It would be possible to submit a proposal for a GLOBAL (G) declaration  under separate cover if anyone (Xerox?) was interested. Pitman thinks  this would be an interesting idea. Dalton points out, however, that  already with this proposal there is enough power to at least deal with  globals -- albeit circuitously. For example, to reference a global  variable X, one could write subroutines such as:   (defun     global-x ()      (declare (lexical x)) x)   (defun set-global-x (value) (declare (lexical x)) (setq x value))  Eg, consider:   (defun f (x) (+ (global-x) x))  In principle, we could imaging saying that free variables should be  lexical by default, but that would only reduce error checking to no  good end. To be really useful, this proposal will need to be followed  by a proposal for primitives analogous to DEFVAR and/or DEFPARAMETER  but for lexical variables. However, since arguments over syntax are  likely to have plenty of issues of their own, we've separated this  proposal for primitive functionality from issues of syntax which  can be dealt with separately once this is passed.  Moon expressed concerns about the efficiency issues but after  thinking about it for a while convinced himself that this is  efficiently implementable both on stock and special purpose hardware.  JonL expressed concerns about the last-minute nature of this change,  which he sees as untested. This concern applies to the mixin of  the dynamic environment implicit in the LDG proposal.  Dalton suggests that an alternative solution to the speed issue  might be possible to obtain by restricting a particular variable to  be either LEXICAL or SPECIAL but not both.  Dalton points that even if people don't like the details here, there  must be a better fallback solution than "do nothing". Pitman agrees  heartily.        TITAN 
         TITAN 
         ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))           w                            b                                                      H       
      w              `              %             -              i             h       
       a              F                   3 z*start*13574 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 21:59:08 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  21:56:24 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 DEC 88 21:55:19 PSTDate: 8 Dec 88 21:54 PSTFrom: masinter.paSubject: Issue: PROCLAIM-LEXICAL (Version 9)To: cl-cleanup@sail.stanford.educc: Masinter.paline-fold: NOMessage-ID: <881208-215519-5376@Xerox>I've attempted to make the edits that JonL suggested inhis message of 18-Oct-88. I wish this were shorter, e.g., that we could say what we haveto say with less Discussion. I'm sorry I haven't the courageto tackle it.!Issue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37), global variables (p68),	      declaration specifiers (p157)Category:     CLARIFICATION/ADDITIONEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87              Version 5 by Masinter 14-Nov-87              Version 6 by Pitman 15-Sep-88	       (major revision, for review by Jonathan Rees and Jeff Dalton)	      Version 7 by Pitman 24-Sep-88   	       (minor revisions based on comments from Rees and Dalton)	      Version 8 by Pitman 06-Oct-88 (merge recent discussion)	      Version 9 by Masinter  8-Dec-88 (make JonL's changes)Problem Description:  Although local variables in Common Lisp may be `special' or `lexical,'  global variables (with the exception of named constants) may currently  only be `special.'  The Scheme language permits free variable references to refer to global  bindings. Their experience suggests that such usage would be useful to  the Common Lisp community. The absence of such a facility in Common Lisp  is a barrier both culturally (to the sharing of ideas) and technically  (to the sharing of code).  SPECIAL proclamations are uncontrollably pervasive. There is no way  to locally override or globally undo a SPECIAL proclamation.Background/Analysis:  Variable evaluation may be viewed in Common Lisp as a search through  a set of environments to find a binding, and then the dereferencing of  that binding. The environments with which Common Lisp deals are  Lexical (L), Dynamic (D), and Global (G).  A SPECIAL declaration for a variable amounts to a request that the  variable be resolved by searching first the Dynamic and then the Global  environment (DG).  As currently described in CLtL, lexical variable reference searches  only the Lexical environment (L).  Because undeclared free variables in the interpreter are implicitly   declared SPECIAL by most (perhaps all) implementations, this amounts  to a search of Lexical, Dynamic, and Global (LDG). However, the   accompanying warnings in many implementations make it clear that this  behavior is not intended to be taken seriously.  Constants are looked up solely in the Global environment (G). They  have other properties as well, of course.  In the Scheme language, the default lookup is first Lexical, then  Global (LG). Providing compatibility for Scheme code is, and more  generally for a Scheme working style is therefore difficult because  Common Lisp does not provide the LG search style.  The issue of whether a variable can be assigned is orthogonal.  The issue of whether a variable can be bound and, if it can be, which  environment is used for the new binding is orthogonal.Proposal (PROCLAIM-LEXICAL:LG):  Provide a new declaration (and proclamation) called LEXICAL which implies  LG lookup. That is, variables declared LEXICAL would be looked up first  in the lexical environment (L) and then in the global environment (G)  if not found in the lexical.  Clarify that a dynamic binding of a variable creates a new binding  in the dynamic environment (D) leaving the global environment (G)  unaffected.  Clarify that special variable access does DG lookup.  That is,   variables declared SPECIAL would be looked up first in the dynamic  environment (D) and then in the global environment (G) if not found  in the dynamic one. Further clarify that SYMBOL-VALUE does DG lookup.  Define that a lexical binding of a variable creates a new binding  in the lexical environment (L), leaving the global environment (G)  and the dynamic environment (D) unaffected.  Note that an assignment to a variable which is bound in the global   environment (G) will affect lexical (LG) lookups for which there is  no lexical (L) binding and dynamic (DG) lookups for which there is  no dynamic (D) binding.  Note that these restrictions describe an abstract model, not a  concrete implementation. An implementation may still choose to  implement dynamic binding as either deep or shallow, but some  searching may be necessary to find the global cell in shallow bound  implementations [unless dynamic binding has been forbidden for  that variable].  Like SPECIAL declarations (and unlike type declarations),  compilers and interpreters would be required to notice and   respect LEXICAL declarations.Examples: #1: (proclaim '(lexical x))     (setq x 1)     (defun f (fn) (list x (funcall fn)))     (defun g (fn)       (let ((x 2))         (declare (special x))	 (funcall fn #'(lambda () x))))     (g #'f) => (1 2) #2: ; Warning: It is unlikely that any serious program would      ;  be written in so obscure a manner as this example.     ;  This just tests the fringe cases.     (proclaim '(lexical x))     (proclaim '(special y))     (setq x 1 y 2)     (defun tst ()       (let ((x 3) (y 4))	 (locally (declare (special x) (lexical y))		  (list x y			(funcall (let ((x 5) (y 6))				   #'(lambda () (list x y))))))))     (tst) => (1 2 (5 4))    If the results of this example confuse you, keep in mind    that the results of code like this would be somewhat    confusing no matter what the chosen semantics because the    code itself is far from perspicuous.    An explanation of this behavior, which some people find less    than intuitive because of the bizarre choice of constructs:          X gets bound lexically to 3 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 4 because Y is [pervasively]       proclaimed SPECIAL.      Reference style for name X is changed to SPECIAL, making       lexical X=3 invisible.      Reference style for name Y is changed to LEXICAL, making       dynamic Y=4 invisible.      Global X=1 and global Y=2 are first two elements of list.      X gets bound lexically to 5 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 6 because Y is [pervasively]       proclaimed SPECIAL.      Closure is returned, capturing [lexical] X=5 but not       [special] Y=6.      Dynamic binding of Y to 6 disappears, dynamic binding       of Y to 4 reverts.      Closure is funcalled, returning captured X=5 and dynamically       active Y=4 in a list which becomes third list element.Rationale:  This mechanism provides a simple and straightforward answer to  the problems stated above.Current Practice:  Probably no one implements this.Cost to Implementors:  A fair amount compiler work would probably be needed. Some compilers  may have hooks for most of this already laying around, but some may not.  Note well that this proposal does not require separate global lexical  and dynamic cells, so the data storage layout of Lisp need not change.  Moon says...   I have now thought of an efficient way to do this on Lisp machines,   using invisible pointers, and another efficient way to do it on   stock hardware, using one extra instruction on every global   reference of one or the other sort, plus a few extra instructions   in SPECIAL binding and unbinding.  Given that, I no longer object   to the proposal as unimplementable.   It doesn't just require a few compiler changes, it requires some   reimplementation of the representation of global variables, with   concomitant changes to the compiler, the loader, the interpreter,   and probably the debugger. Every symbol now potentially has two   values accessible from the interpreter (the current SPECIAL and   the global LEXICAL) and you need the corresponding new data   structure to keep track of that.  Rees suggests...   In shallow-bound implementations, implementors may have to add a   small run-time routine that searches the dynamic saved-binding   stack to look for the global value in the case where the variable   has been dynamically bound.  One might want a bit (or a count)   somewhere (perhaps in the symbol itself) to speed up the common   case of access to a global binding of a variable that hasn't been   dynamically bound; without some kind of optimization, you have to   search the whole saved-binding stack on every reference to a    free [lexical] variable.    While naively you might think you'd incur the cost of clearing the   valid bit on every dynamic binding (not acceptable), in actuality   the bit is a static property of programs (PROGV excepted).  So the   only places you ever need to clear FOO's valid bit are in PROGV,   in the interpreter, and when FASLOADing code that contains a compiled   dynamic binding of FOO.Cost to Users:  For the most part, this change is upward compatible.  Some code-walking tools would have to change.Cost of Non-Adoption:  It would continue to be difficult to share code with Scheme.  New CL users coming from the Scheme community would be confused by  their sometimes inability to map what they know about variable binding  into the CL model of variable binding.  Some interesting native CL applications would be impossible to write  in a syntactically convenient style.Benefits:  Enhanced flexibility of expression.  Rationalization of the semantics of dynamic variables.Aesthetics:  Improved appeal to a certain sector of the programming community.Discussion:  Rees points that it is an oversimplification to describe Scheme's  binding simply as LG since they have no Dynamic environment and  there is no way to distinguish LG and LDG. However, the reasons he  prefers LG are:   1. It's nice for readability and understandability to have a      declaration which tells you that a variable will not be      dynamically bound.   2. It's nice for performance in deep-bound implementations to have a      declaration that says that no search will be needed.  Of course, he notes, there could be a counter-argument to item 2  (in favor of LDG) in order to prefer shallow bound implementations,  but that still would not defeat the argument in item 1. Rees believes  that LG is slightly preferrable, but that LDG would be essentially  adequate for most of his needs.  Pitman supports PROCLAIM-LEXICAL:LG and believes that giving LDG the  name LEXICAL would be a serious mistake, leaving open the door for  program bugs due to accidental binding of variables presumed by the  programmer not to be bound. If someone (Moon?) seriously wanted LDG  type variables in addition to LG variables (under a name other than  LEXICAL), Pitman would not object.  Dalton expressed support for PROCLAIM-LEXICAL:LG (Version 6).  He observes that another reason for opposing LDG is that it suggests  the possibility that someone might want DLG. LG is simpler and still  accomplishes the stated purpose. He adds ``I would like to be able  to explain the global environment as a sort of giant, extensible  LET abound everything.  This proposal seems to get fairly close.''  It would be possible to submit a proposal for a GLOBAL (G) declaration  under separate cover if anyone (Xerox?) was interested. Pitman thinks  this would be an interesting idea. Dalton points out, however, that  already with this proposal there is enough power to at least deal with  globals -- albeit circuitously. For example, to reference a global  variable X, one could write subroutines such as:   (defun     global-x ()      (declare (lexical x)) x)   (defun set-global-x (value) (declare (lexical x)) (setq x value))  Eg, consider:   (defun f (x) (+ (global-x) x))  In principle, we could imaging saying that free variables should be  lexical by default, but that would only reduce error checking to no  good end. To be really useful, this proposal will need to be followed  by a proposal for primitives analogous to DEFVAR and/or DEFPARAMETER  but for lexical variables. However, since arguments over syntax are  likely to have plenty of issues of their own, we've separated this  proposal for primitive functionality from issues of syntax which  can be dealt with separately once this is passed.  Moon expressed concerns about the efficiency issues but after  thinking about it for a while convinced himself that this is  efficiently implementable both on stock and special purpose hardware.  JonL expressed concerns about the last-minute nature of this change,  which he sees as untested. This concern applies to the mixin of  the dynamic environment implicit in the LDG proposal.  Dalton suggests that an alternative solution to the speed issue  might be possible to obtain by restricting a particular variable to  be either LEXICAL or SPECIAL but not both.  Dalton points that even if people don't like the details here, there  must be a better fallback solution than "do nothing". Pitman agrees  heartily.*start*13399 00024 US Date: 12 Dec 88 14:08 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: PROCLAIM-LEXICAL (Version 9)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noIssue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37), global variables (p68),	      declaration specifiers (p157)Category:     CLARIFICATION/ADDITIONEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87              Version 5 by Masinter 14-Nov-87              Version 6 by Pitman 15-Sep-88	       (major revision, for review by Jonathan Rees and Jeff Dalton)	      Version 7 by Pitman 24-Sep-88   	       (minor revisions based on comments from Rees and Dalton)	      Version 8 by Pitman 06-Oct-88 (merge recent discussion)	      Version 9 by Masinter  8-Dec-88 (make JonL's changes)Problem Description:  Although local variables in Common Lisp may be `special' or `lexical,'  global variables (with the exception of named constants) may currently  only be `special.'  The Scheme language permits free variable references to refer to global  bindings. Their experience suggests that such usage would be useful to  the Common Lisp community. The absence of such a facility in Common Lisp  is a barrier both culturally (to the sharing of ideas) and technically  (to the sharing of code).  SPECIAL proclamations are uncontrollably pervasive. There is no way  to locally override or globally undo a SPECIAL proclamation.Background/Analysis:  Variable evaluation may be viewed in Common Lisp as a search through  a set of environments to find a binding, and then the dereferencing of  that binding. The environments with which Common Lisp deals are  Lexical (L), Dynamic (D), and Global (G).  A SPECIAL declaration for a variable amounts to a request that the  variable be resolved by searching first the Dynamic and then the Global  environment (DG).  As currently described in CLtL, lexical variable reference searches  only the Lexical environment (L).  Because undeclared free variables in the interpreter are implicitly   declared SPECIAL by most (perhaps all) implementations, this amounts  to a search of Lexical, Dynamic, and Global (LDG). However, the   accompanying warnings in many implementations make it clear that this  behavior is not intended to be taken seriously.  Constants are looked up solely in the Global environment (G). They  have other properties as well, of course.  In the Scheme language, the default lookup is first Lexical, then  Global (LG). Providing compatibility for Scheme code is, and more  generally for a Scheme working style is therefore difficult because  Common Lisp does not provide the LG search style.  The issue of whether a variable can be assigned is orthogonal.  The issue of whether a variable can be bound and, if it can be, which  environment is used for the new binding is orthogonal.Proposal (PROCLAIM-LEXICAL:LG):  Provide a new declaration (and proclamation) called LEXICAL which implies  LG lookup. That is, variables declared LEXICAL would be looked up first  in the lexical environment (L) and then in the global environment (G)  if not found in the lexical.  Clarify that a dynamic binding of a variable creates a new binding  in the dynamic environment (D) leaving the global environment (G)  unaffected.  Clarify that special variable access does DG lookup.  That is,   variables declared SPECIAL would be looked up first in the dynamic  environment (D) and then in the global environment (G) if not found  in the dynamic one. Further clarify that SYMBOL-VALUE does DG lookup.  Define that a lexical binding of a variable creates a new binding  in the lexical environment (L), leaving the global environment (G)  and the dynamic environment (D) unaffected.  Note that an assignment to a variable which is bound in the global   environment (G) will affect lexical (LG) lookups for which there is  no lexical (L) binding and dynamic (DG) lookups for which there is  no dynamic (D) binding.  Note that these restrictions describe an abstract model, not a  concrete implementation. An implementation may still choose to  implement dynamic binding as either deep or shallow, but some  searching may be necessary to find the global cell in shallow bound  implementations [unless dynamic binding has been forbidden for  that variable].  Like SPECIAL declarations (and unlike type declarations),  compilers and interpreters would be required to notice and   respect LEXICAL declarations.Examples: #1: (proclaim '(lexical x))     (setq x 1)     (defun f (fn) (list x (funcall fn)))     (defun g (fn)       (let ((x 2))         (declare (special x))	 (funcall fn #'(lambda () x))))     (g #'f) => (1 2) #2: ; Warning: It is unlikely that any serious program would      ;  be written in so obscure a manner as this example.     ;  This just tests the fringe cases.     (proclaim '(lexical x))     (proclaim '(special y))     (setq x 1 y 2)     (defun tst ()       (let ((x 3) (y 4))	 (locally (declare (special x) (lexical y))		  (list x y			(funcall (let ((x 5) (y 6))				   #'(lambda () (list x y))))))))     (tst) => (1 2 (5 4))    If the results of this example confuse you, keep in mind    that the results of code like this would be somewhat    confusing no matter what the chosen semantics because the    code itself is far from perspicuous.    An explanation of this behavior, which some people find less    than intuitive because of the bizarre choice of constructs:          X gets bound lexically to 3 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 4 because Y is [pervasively]       proclaimed SPECIAL.      Reference style for name X is changed to SPECIAL, making       lexical X=3 invisible.      Reference style for name Y is changed to LEXICAL, making       dynamic Y=4 invisible.      Global X=1 and global Y=2 are first two elements of list.      X gets bound lexically to 5 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 6 because Y is [pervasively]       proclaimed SPECIAL.      Closure is returned, capturing [lexical] X=5 but not       [special] Y=6.      Dynamic binding of Y to 6 disappears, dynamic binding       of Y to 4 reverts.      Closure is funcalled, returning captured X=5 and dynamically       active Y=4 in a list which becomes third list element.Rationale:  This mechanism provides a simple and straightforward answer to  the problems stated above.Current Practice:  Probably no one implements this.Cost to Implementors:  A fair amount compiler work would probably be needed. Some compilers  may have hooks for most of this already laying around, but some may not.  Note well that this proposal does not require separate global lexical  and dynamic cells, so the data storage layout of Lisp need not change.  Moon says...   I have now thought of an efficient way to do this on Lisp machines,   using invisible pointers, and another efficient way to do it on   stock hardware, using one extra instruction on every global   reference of one or the other sort, plus a few extra instructions   in SPECIAL binding and unbinding.  Given that, I no longer object   to the proposal as unimplementable.   It doesn't just require a few compiler changes, it requires some   reimplementation of the representation of global variables, with   concomitant changes to the compiler, the loader, the interpreter,   and probably the debugger. Every symbol now potentially has two   values accessible from the interpreter (the current SPECIAL and   the global LEXICAL) and you need the corresponding new data   structure to keep track of that.  Rees suggests...   In shallow-bound implementations, implementors may have to add a   small run-time routine that searches the dynamic saved-binding   stack to look for the global value in the case where the variable   has been dynamically bound.  One might want a bit (or a count)   somewhere (perhaps in the symbol itself) to speed up the common   case of access to a global binding of a variable that hasn't been   dynamically bound; without some kind of optimization, you have to   search the whole saved-binding stack on every reference to a    free [lexical] variable.    While naively you might think you'd incur the cost of clearing the   valid bit on every dynamic binding (not acceptable), in actuality   the bit is a static property of programs (PROGV excepted).  So the   only places you ever need to clear FOO's valid bit are in PROGV,   in the interpreter, and when FASLOADing code that contains a compiled   dynamic binding of FOO.Cost to Users:  For the most part, this change is upward compatible.  Some code-walking tools would have to change.Cost of Non-Adoption:  It would continue to be difficult to share code with Scheme.  New CL users coming from the Scheme community would be confused by  their sometimes inability to map what they know about variable binding  into the CL model of variable binding.  Some interesting native CL applications would be impossible to write  in a syntactically convenient style.Benefits:  Enhanced flexibility of expression.  Rationalization of the semantics of dynamic variables.Aesthetics:  Improved appeal to a certain sector of the programming community.Discussion:  Rees points that it is an oversimplification to describe Scheme's  binding simply as LG since they have no Dynamic environment and  there is no way to distinguish LG and LDG. However, the reasons he  prefers LG are:   1. It's nice for readability and understandability to have a      declaration which tells you that a variable will not be      dynamically bound.   2. It's nice for performance in deep-bound implementations to have a      declaration that says that no search will be needed.  Of course, he notes, there could be a counter-argument to item 2  (in favor of LDG) in order to prefer shallow bound implementations,  but that still would not defeat the argument in item 1. Rees believes  that LG is slightly preferrable, but that LDG would be essentially  adequate for most of his needs.  Pitman supports PROCLAIM-LEXICAL:LG and believes that giving LDG the  name LEXICAL would be a serious mistake, leaving open the door for  program bugs due to accidental binding of variables presumed by the  programmer not to be bound. If someone (Moon?) seriously wanted LDG  type variables in addition to LG variables (under a name other than  LEXICAL), Pitman would not object.  Dalton expressed support for PROCLAIM-LEXICAL:LG (Version 6).  He observes that another reason for opposing LDG is that it suggests  the possibility that someone might want DLG. LG is simpler and still  accomplishes the stated purpose. He adds ``I would like to be able  to explain the global environment as a sort of giant, extensible  LET abound everything.  This proposal seems to get fairly close.''  It would be possible to submit a proposal for a GLOBAL (G) declaration  under separate cover if anyone (Xerox?) was interested. Pitman thinks  this would be an interesting idea. Dalton points out, however, that  already with this proposal there is enough power to at least deal with  globals -- albeit circuitously. For example, to reference a global  variable X, one could write subroutines such as:   (defun     global-x ()      (declare (lexical x)) x)   (defun set-global-x (value) (declare (lexical x)) (setq x value))  Eg, consider:   (defun f (x) (+ (global-x) x))  In principle, we could imaging saying that free variables should be  lexical by default, but that would only reduce error checking to no  good end. To be really useful, this proposal will need to be followed  by a proposal for primitives analogous to DEFVAR and/or DEFPARAMETER  but for lexical variables. However, since arguments over syntax are  likely to have plenty of issues of their own, we've separated this  proposal for primitive functionality from issues of syntax which  can be dealt with separately once this is passed.  Moon expressed concerns about the efficiency issues but after  thinking about it for a while convinced himself that this is  efficiently implementable both on stock and special purpose hardware.  JonL expressed concerns about the last-minute nature of this change,  which he sees as untested. This concern applies to the mixin of  the dynamic environment implicit in the LDG proposal.  Dalton suggests that an alternative solution to the speed issue  might be possible to obtain by restricting a particular variable to  be either LEXICAL or SPECIAL but not both.  Dalton points that even if people don't like the details here, there  must be a better fallback solution than "do nothing". Pitman agrees  heartily.        TITAN 
          TITAN 
          Z                                   b                                                      H       
      w              `              %             -              i             h       
       a              F                   2  z*start*13383 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 14:56:31 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  14:27:29 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 14:10:50 PSTDate: 12 Dec 88 14:08 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: PROCLAIM-LEXICAL (Version 9)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-141050-5132@Xerox>!Issue:        PROCLAIM-LEXICALReferences:   variables (p55), scope/extent (p37), global variables (p68),	      declaration specifiers (p157)Category:     CLARIFICATION/ADDITIONEdit history: Version 2 by Rees 28-Apr-87              Version 3 by Moon 16-May-87              Version 4 by Masinter 27-Oct-87              Version 5 by Masinter 14-Nov-87              Version 6 by Pitman 15-Sep-88	       (major revision, for review by Jonathan Rees and Jeff Dalton)	      Version 7 by Pitman 24-Sep-88   	       (minor revisions based on comments from Rees and Dalton)	      Version 8 by Pitman 06-Oct-88 (merge recent discussion)	      Version 9 by Masinter  8-Dec-88 (make JonL's changes)Problem Description:  Although local variables in Common Lisp may be `special' or `lexical,'  global variables (with the exception of named constants) may currently  only be `special.'  The Scheme language permits free variable references to refer to global  bindings. Their experience suggests that such usage would be useful to  the Common Lisp community. The absence of such a facility in Common Lisp  is a barrier both culturally (to the sharing of ideas) and technically  (to the sharing of code).  SPECIAL proclamations are uncontrollably pervasive. There is no way  to locally override or globally undo a SPECIAL proclamation.Background/Analysis:  Variable evaluation may be viewed in Common Lisp as a search through  a set of environments to find a binding, and then the dereferencing of  that binding. The environments with which Common Lisp deals are  Lexical (L), Dynamic (D), and Global (G).  A SPECIAL declaration for a variable amounts to a request that the  variable be resolved by searching first the Dynamic and then the Global  environment (DG).  As currently described in CLtL, lexical variable reference searches  only the Lexical environment (L).  Because undeclared free variables in the interpreter are implicitly   declared SPECIAL by most (perhaps all) implementations, this amounts  to a search of Lexical, Dynamic, and Global (LDG). However, the   accompanying warnings in many implementations make it clear that this  behavior is not intended to be taken seriously.  Constants are looked up solely in the Global environment (G). They  have other properties as well, of course.  In the Scheme language, the default lookup is first Lexical, then  Global (LG). Providing compatibility for Scheme code is, and more  generally for a Scheme working style is therefore difficult because  Common Lisp does not provide the LG search style.  The issue of whether a variable can be assigned is orthogonal.  The issue of whether a variable can be bound and, if it can be, which  environment is used for the new binding is orthogonal.Proposal (PROCLAIM-LEXICAL:LG):  Provide a new declaration (and proclamation) called LEXICAL which implies  LG lookup. That is, variables declared LEXICAL would be looked up first  in the lexical environment (L) and then in the global environment (G)  if not found in the lexical.  Clarify that a dynamic binding of a variable creates a new binding  in the dynamic environment (D) leaving the global environment (G)  unaffected.  Clarify that special variable access does DG lookup.  That is,   variables declared SPECIAL would be looked up first in the dynamic  environment (D) and then in the global environment (G) if not found  in the dynamic one. Further clarify that SYMBOL-VALUE does DG lookup.  Define that a lexical binding of a variable creates a new binding  in the lexical environment (L), leaving the global environment (G)  and the dynamic environment (D) unaffected.  Note that an assignment to a variable which is bound in the global   environment (G) will affect lexical (LG) lookups for which there is  no lexical (L) binding and dynamic (DG) lookups for which there is  no dynamic (D) binding.  Note that these restrictions describe an abstract model, not a  concrete implementation. An implementation may still choose to  implement dynamic binding as either deep or shallow, but some  searching may be necessary to find the global cell in shallow bound  implementations [unless dynamic binding has been forbidden for  that variable].  Like SPECIAL declarations (and unlike type declarations),  compilers and interpreters would be required to notice and   respect LEXICAL declarations.Examples: #1: (proclaim '(lexical x))     (setq x 1)     (defun f (fn) (list x (funcall fn)))     (defun g (fn)       (let ((x 2))         (declare (special x))	 (funcall fn #'(lambda () x))))     (g #'f) => (1 2) #2: ; Warning: It is unlikely that any serious program would      ;  be written in so obscure a manner as this example.     ;  This just tests the fringe cases.     (proclaim '(lexical x))     (proclaim '(special y))     (setq x 1 y 2)     (defun tst ()       (let ((x 3) (y 4))	 (locally (declare (special x) (lexical y))		  (list x y			(funcall (let ((x 5) (y 6))				   #'(lambda () (list x y))))))))     (tst) => (1 2 (5 4))    If the results of this example confuse you, keep in mind    that the results of code like this would be somewhat    confusing no matter what the chosen semantics because the    code itself is far from perspicuous.    An explanation of this behavior, which some people find less    than intuitive because of the bizarre choice of constructs:          X gets bound lexically to 3 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 4 because Y is [pervasively]       proclaimed SPECIAL.      Reference style for name X is changed to SPECIAL, making       lexical X=3 invisible.      Reference style for name Y is changed to LEXICAL, making       dynamic Y=4 invisible.      Global X=1 and global Y=2 are first two elements of list.      X gets bound lexically to 5 because X is [pervasively]       proclaimed LEXICAL.      Y gets bound specially to 6 because Y is [pervasively]       proclaimed SPECIAL.      Closure is returned, capturing [lexical] X=5 but not       [special] Y=6.      Dynamic binding of Y to 6 disappears, dynamic binding       of Y to 4 reverts.      Closure is funcalled, returning captured X=5 and dynamically       active Y=4 in a list which becomes third list element.Rationale:  This mechanism provides a simple and straightforward answer to  the problems stated above.Current Practice:  Probably no one implements this.Cost to Implementors:  A fair amount compiler work would probably be needed. Some compilers  may have hooks for most of this already laying around, but some may not.  Note well that this proposal does not require separate global lexical  and dynamic cells, so the data storage layout of Lisp need not change.  Moon says...   I have now thought of an efficient way to do this on Lisp machines,   using invisible pointers, and another efficient way to do it on   stock hardware, using one extra instruction on every global   reference of one or the other sort, plus a few extra instructions   in SPECIAL binding and unbinding.  Given that, I no longer object   to the proposal as unimplementable.   It doesn't just require a few compiler changes, it requires some   reimplementation of the representation of global variables, with   concomitant changes to the compiler, the loader, the interpreter,   and probably the debugger. Every symbol now potentially has two   values accessible from the interpreter (the current SPECIAL and   the global LEXICAL) and you need the corresponding new data   structure to keep track of that.  Rees suggests...   In shallow-bound implementations, implementors may have to add a   small run-time routine that searches the dynamic saved-binding   stack to look for the global value in the case where the variable   has been dynamically bound.  One might want a bit (or a count)   somewhere (perhaps in the symbol itself) to speed up the common   case of access to a global binding of a variable that hasn't been   dynamically bound; without some kind of optimization, you have to   search the whole saved-binding stack on every reference to a    free [lexical] variable.    While naively you might think you'd incur the cost of clearing the   valid bit on every dynamic binding (not acceptable), in actuality   the bit is a static property of programs (PROGV excepted).  So the   only places you ever need to clear FOO's valid bit are in PROGV,   in the interpreter, and when FASLOADing code that contains a compiled   dynamic binding of FOO.Cost to Users:  For the most part, this change is upward compatible.  Some code-walking tools would have to change.Cost of Non-Adoption:  It would continue to be difficult to share code with Scheme.  New CL users coming from the Scheme community would be confused by  their sometimes inability to map what they know about variable binding  into the CL model of variable binding.  Some interesting native CL applications would be impossible to write  in a syntactically convenient style.Benefits:  Enhanced flexibility of expression.  Rationalization of the semantics of dynamic variables.Aesthetics:  Improved appeal to a certain sector of the programming community.Discussion:  Rees points that it is an oversimplification to describe Scheme's  binding simply as LG since they have no Dynamic environment and  there is no way to distinguish LG and LDG. However, the reasons he  prefers LG are:   1. It's nice for readability and understandability to have a      declaration which tells you that a variable will not be      dynamically bound.   2. It's nice for performance in deep-bound implementations to have a      declaration that says that no search will be needed.  Of course, he notes, there could be a counter-argument to item 2  (in favor of LDG) in order to prefer shallow bound implementations,  but that still would not defeat the argument in item 1. Rees believes  that LG is slightly preferrable, but that LDG would be essentially  adequate for most of his needs.  Pitman supports PROCLAIM-LEXICAL:LG and believes that giving LDG the  name LEXICAL would be a serious mistake, leaving open the door for  program bugs due to accidental binding of variables presumed by the  programmer not to be bound. If someone (Moon?) seriously wanted LDG  type variables in addition to LG variables (under a name other than  LEXICAL), Pitman would not object.  Dalton expressed support for PROCLAIM-LEXICAL:LG (Version 6).  He observes that another reason for opposing LDG is that it suggests  the possibility that someone might want DLG. LG is simpler and still  accomplishes the stated purpose. He adds ``I would like to be able  to explain the global environment as a sort of giant, extensible  LET abound everything.  This proposal seems to get fairly close.''  It would be possible to submit a proposal for a GLOBAL (G) declaration  under separate cover if anyone (Xerox?) was interested. Pitman thinks  this would be an interesting idea. Dalton points out, however, that  already with this proposal there is enough power to at least deal with  globals -- albeit circuitously. For example, to reference a global  variable X, one could write subroutines such as:   (defun     global-x ()      (declare (lexical x)) x)   (defun set-global-x (value) (declare (lexical x)) (setq x value))  Eg, consider:   (defun f (x) (+ (global-x) x))  In principle, we could imaging saying that free variables should be  lexical by default, but that would only reduce error checking to no  good end. To be really useful, this proposal will need to be followed  by a proposal for primitives analogous to DEFVAR and/or DEFPARAMETER  but for lexical variables. However, since arguments over syntax are  likely to have plenty of issues of their own, we've separated this  proposal for primitive functionality from issues of syntax which  can be dealt with separately once this is passed.  Moon expressed concerns about the efficiency issues but after  thinking about it for a while convinced himself that this is  efficiently implementable both on stock and special purpose hardware.  JonL expressed concerns about the last-minute nature of this change,  which he sees as untested. This concern applies to the mixin of  the dynamic environment implicit in the LDG proposal.  Dalton suggests that an alternative solution to the speed issue  might be possible to obtain by restricting a particular variable to  be either LEXICAL or SPECIAL but not both.  Dalton points that even if people don't like the details here, there  must be a better fallback solution than "do nothing". Pitman agrees  heartily.*start*02667 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 13 DEC 88 16:44:18 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 508133; Tue 13-Dec-88 19:44:31 ESTDate: Tue, 13 Dec 88 19:44 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICAL (Version 9)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881208-215519-5376@Xerox>Message-ID: <881213194417.9.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 8 Dec 88 21:54 PST    From: masinter.pa@Xerox.COM    I've attempted to make the edits that JonL suggested in    his message of 18-Oct-88. To my great relief, these changes look generally quite fine.Thanks, Larry.    I wish this were shorter, e.g., that we could say what we have    to say with less Discussion. I'm sorry I haven't the courage    to tackle it.Well, My training in writing for newspapers says this is not really muchof an issue as you might think. As long as the presentation is in"inverse pyramid style" (order of diminishing importance), people canstop reading when they've gotten the important stuff if they think thewriteup is too long. Of course, the poor guy we trick into Xeroxing copiesof all these issues and carry them halfway around the world to the meeting(possibly in the other order) may not agree...I have one substantive comment, by the way:    Issue:        PROCLAIM-LEXICAL    Edit history:    ...		  Version 9 by Masinter  8-Dec-88 (make JonL's changes)    ...    Proposal (PROCLAIM-LEXICAL:LG):    ...      Clarify that a dynamic binding of a variable creates a new binding      in the dynamic environment (D) leaving the global environment (G)      unaffected.    ...In the previous version, I used the verb "Define" for this, not "Clarify"here. "Clarify" is technically ok but only if you understand how the formalglobal environment (G) described here potentially differs from the globalenvironment actually implemented in the running Lisp (i.e., if youunderstand why this description does not preclude shallow binding).I had preferred the word "Define" because it makes people read more closely,and because some people may not see this as a simple clarification.I don't think it's worth re-issuing the proposal, but I do think it'ssomething we should be aware of in case it leads to confusion in theopen discussion -- so we can head it off quickly.Overall, I'm extremely pleased with this how this writeup ended up.I'm crossing my fingers that it will be well-received.*start*02427 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 00:38:24 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Jan 89  00:37:52 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 JAN 89 00:34:46 PSTDate: 12 Jan 89 00:34 PSTSender: masinter.paSubject: Issue: PROCLAIM-SPECIAL (Version 9)To: cl-cleanup@sail.stanford.eduFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>line-fold: NOMessage-ID: <890112-003446-11899@Xerox>[From Ballot]    Under this proposal, special proclamations establish a default for    a name but, because of the lexical declaration, no longer force it    to be special everywhere.  It also allows the programmer to say    that a global name is intended as a variable (i.e., references to    it are not spelling mistakes) without proclaiming it special.  I    think these are important changes that should be preserved even if    this proposal fails.  Another important feature is that LG references    to global variables can be fast in deep-bound implementations (since    L "searches" can be compiled away) while DG references (the only    global variables we have now) first have to look in D.  Finally,    the current semantics are subtly confusing, because the specialness    of global variables occasionally shows through.  For all of these    reasons, I support this proposal.    I think the most controversial change is the introduction of a    separate global environment, where before the only globals were    effectively just the global end of the dynamic env.  Most of the    implementation complexity stems from this change, and it is likely    that it lies behind most objections.        A reasonable fallback, if this proposal does not pass, would be    to say that variables that are proclaimed lexical can never by    given dynamic bindings.  That is, the global value would be taken    after searching L or D but not both and so would effectively be    an extension of the L or D env, case by case.  This would be    somewhat unfortunate, because local lexical bindings for names    proclaimed special would still make sense (because they could be    declared lexical) but we wouldn't allow local special declarations    for names proclaimed lexical.  The full proposal is better.    *start*00803 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 11:06:57 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Jan 89  11:05:57 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 JAN 89 11:02:42 PSTDate: 12 Jan 89 11:02 PSTFrom: masinter.paSubject: Re: Issue: PROCLAIM-SPECIAL (Version 9)In-reply-to: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>'s message of 12 Jan 89 00:34 PSTTo: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>cc: cl-cleanup@sail.stanford.eduMessage-ID: <890112-110242-12820@Xerox>I made a mistake when sending out the message; the Subject is incorrect.The issue name  is PROCLAIM-LEXICAL, of course.*start*02167 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 JAN 89 14:53:41 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 20 Jan 89  14:53:41 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.1-cs)	id AA00528; Fri, 20 Jan 89 15:53:22 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA17398; Fri, 20 Jan 89 15:53:14 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8901202253.AA17398@defun.utah.edu>Date: Fri, 20 Jan 89 15:53:12 MSTSubject: issue PROCLAIM-LEXICALTo: cl-cleanup@sail.stanford.eduMy gut feeling on this issue is that people would be willing to voteit in, provided that we can guarantee that you would never have toaccess the symbol's global value when there is a special binding ofthe variable.  I believe this was the purpose of the amendment thatwas accepted (stating that "it is an error" to specially bind a variablethat has been proclaimed lexical), but there are still some otherpossible cases.Here is what I had written on the slide I prepared at the meeting.  Example #1:    (let ((broken (locally (declare (lexical foo))    		      #'(lambda () ... foo ...))))	(let ((foo  37))	    (declare (special foo))	    (funcall broken)))  Example #2:    (defparameter bar 'global-value)    (defun baz ()        (locally (declare (lexical bar))	    bar))    (let ((bar  'dynamic-value))        (baz))  Amendment:    State that it is an error for a "free" LEXICAL declaration to    appear in contexts where there is no lexically visible binding of    that variable. The problem is that, in both examples, a closure over the global valueof the variable is being created, and you cannot prevent that functionfrom being called when there are special bindings of the variable.The rationale for the amendment is to make it impossible to createsuch a closure in the first place. I am not entirely convinced that there aren't other "holes" remainingthat I haven't thought about, but at least this would plug one of them.-Sandra-------*start*03784 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 JAN 89 11:51:30 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Jan 89  10:32:09 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 525283; Mon 23-Jan-89 13:30:02 ESTDate: Mon, 23 Jan 89 13:29 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue PROCLAIM-LEXICALTo: CL-Cleanup@SAIL.Stanford.EDUcc: sandra%defun@CS.UTAH.EDUReferences: <8901202253.AA17398@defun.utah.edu>Message-ID: <890123132952.8.KMP@BOBOLINK.SCRC.Symbolics.COM>I haven't seen an updated copy of PROCLAIM-LEXICAL. Will someone pleasemail something that brings the online record up to date with the meeting?Working from the notes Moon brought back about ammendments made:  -- Can't dynamic bind if proclaimed lexical (passed 11 to 5)I stand firm by my claim that this is a very, very bad idea.Programmers have been -screaming- for the ability to locally work aroundthe effect of having done (PROCLAIM '(SPECIAL var)) by either doing anUNSPECIAL or LEXICAL declaration. If we're going to provide the ability todo: (PROCLAIM '(SPECIAL X)) (DEFUN FOO (X) (DECLARE (LEXICAL X)) (+ X 3)) (DEFUN BAR () (+ X 3))then we should similarly provide the ability to do: (PROCLAIM '(LEXICAL X)) (DEFUN FOO (X) (+ X 3)) (DEFUN BAR () (DECLARE (SPECIAL X)) (+ X 3))The situations are isomorphic. They provide identical functionality. Theonly question is one of notation. No power is gained by prohibiting SPECIAL declarations of things proclaimed LEXICAL -- only frustration.You force users to learn a complicated set of rules that buy them littleor nothing. In practice, the need to SPECIAL bind something which isproclaimed LEXICAL probably almost never comes up, but when it does, itshould be permitted because there is no good reason not to permit it.  -- Referencing a free variable that is neither proclaimed nor declared     LEXICAL nor SPECIAL has undefined results (not voted)This is fine.  -- A free lexical declaration of a variable with no lexically    visible binding is an error; use PROCLAIM (not voted)This is also utter nonsense. There is no similar restriction on SPECIAL,and it is occassionally useful. Also, there is a clear meaning. It meansyou want to capture the global. Why should people assume this is a mistake.I'm one of the people who is asking for this feature and the -reason-I am asking for it is so I -can- capture the global. I want to be ableto capture the global. I want to be able to know that the special bindingis not in the way.If we make a lot of doofy little special case rules about when you canand cannot use LEXICAL and SPECIAL that are (a) unmotivated and  (b)gratuitously different for SPECIAL and LEXICAL for reasons which arenot clearly technically motivated, then we are making a big mistake thatwill just complicate the language.We cannot afford to let this issue fall off the end of the earth becauseit addresses important user needs.We cannot afford to make the language semantics overly complicated becausesomeone is afraid that a programmer might not mean what he wrote, even whenit has a clear meaning and a useful purpose.           Returned to committeeI hope the committee will think seriously about disregarding some of thefull committee suggestions and will spend its time instead better justifyingthe position which was originally presented.I'll probably also reply later to Sandra's message, with which I disagreeon a number of major points, but I don't have time right now.*start*00992 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 JAN 89 15:32:49 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 23 Jan 89  15:32:31 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa08698; 23 Jan 89 23:17 GMTDate: Mon, 23 Jan 89 23:25:50 GMTMessage-Id: <14006.8901232325@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICALTo: sandra <@cs.utah.edu:sandra@defun>, cl-cleanup@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Fri, 20 Jan 89 15:53:12 MSTThe problem with your position is that it would not let me havea free local lexical declaration if there were a lexical proclamation-- or would it?  The ammendment made at the meeting was to make localspecial declaraions illegal in that case.-- Jeff*start*02383 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 JAN 89 20:27:59 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 23 Jan 89  20:27:44 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.1-cs)	id AA19278; Mon, 23 Jan 89 21:26:20 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA19262; Mon, 23 Jan 89 21:26:17 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8901240426.AA19262@defun.utah.edu>Date: Mon, 23 Jan 89 21:26:16 MSTSubject: Re: issue PROCLAIM-LEXICALTo: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Cc: sandra <sandra%defun@cs.utah.edu>, cl-cleanup@sail.stanford.eduIn-Reply-To: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, Mon, 23 Jan 89 23:25:50 GMT> Date: Mon, 23 Jan 89 23:25:50 GMT> From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>> > The problem with your position is that it would not let me have> a free local lexical declaration if there were a lexical proclamation> -- or would it?  The ammendment made at the meeting was to make local> special declaraions illegal in that case.It does seem reasonable that free lexical declarations should just beno-ops in the presence of a lexical proclamation, but you're rightthat the amendment I suggested doesn't allow for that.  But I'm notfirmly wedded to that particular language.  To repeat what I saidbefore, my sense from talking to various people between sessions atthe meeting was that the intent of the other amendment was toguarantee that you'd never be able to reference the global value of avariable when there's a special binding, but that not everybody wasaware that that amendment didn't actually guarantee what it wassupposed to.  Basically, in proposing my amendment, I was just beingobstructionist :-) and trying to prevent taking a vote that we'd endup regretting once we had time to think about its implications. I am rather lukewarm on this whole issue.  I like the intent of thelatest round of amendments better than the existing proposal, but I'dbe just as happy to leave this feature out of the standard entirelyfor now -- it doesn't appear to represent "current practice" and usersseem to have been getting along OK without it. -Sandra-------*start*02437 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 JAN 89 21:48:52 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Jan 89  21:48:36 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 23 JAN 89 21:47:09 PSTDate: 23 Jan 89 21:45 PSTFrom: masinter.paSubject: Re: issue PROCLAIM-LEXICALIn-reply-to: sandra%defun@cs.utah.edu (Sandra J Loosemore)'s message of Mon, 23 Jan 89 21:26:16 MSTTo: sandra%defun@cs.utah.edu (Sandra J Loosemore)cc: cl-cleanup@sail.stanford.eduMessage-ID: <890123-214709-2907@Xerox>The proposal mentions in passing "It would be possible to submit a proposalfor a GLOBAL (G) declaration  under separate cover if anyone (Xerox?) was interested."I'd say that as far as I can tell, with the amendment that local SPECIALdeclarations are not allowed for variables proclaimed lexical, there arefew differences between GLOBAL in Medley and LEXICAL as proposed; the majordifference being that a local LEXICAL declaration will override a globalSPECIAL proclaimation, but in Medley, a local GLOBAL declaration impliesthat no lexical bindings are allowed.Insofar as GLOBAL is very like LEXICAL, it would count for "currentpractice", would it not? The reason for GLOBAL is primarily for performance-- it is a deep-bound implementation, and references to GLOBAL variablesare significantly faster.  I don't think Medley users would get along OKwithout it.  I don't think users of *any* deep-bound implementation wouldget along well without some equivalent. While I hate to see specialfeatures put into the standard for idiosyncratic implementation techniques,deep-binding is not new or idiosyncratic, and this is really the minimaldeclaration necessary consistent with current practice.Given the likelihood of PROCLAIM-LEXICAL:LG failing, I suppose I *would*like to see a GLOBAL proclaimation made standard, since it doesn't seem tohurt shallow bound implementations and is important for deep-boundimplementations. If "it is an error to attempt to bind a variableproclaimed or declared GLOBAL", if you declare it or proclaim it GLOBAL,you can't have any bindings, whether such bindings would be lexical orspecial. In that sense, a GLOBAL variable could be thought of as a subsetof SPECIAL variables which share the "not bindable" property of constants.*start*02132 00024 US Return-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 25 JAN 89 17:10:33 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa05955; 25 Jan 89 16:17 GMTDate: Wed, 25 Jan 89 16:26:36 GMTMessage-Id: <20300.8901251626@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICALTo: masinter.pa, sandra <@cs.utah.edu:sandra@defun>In-Reply-To: masinter.pa@com.xerox's message of 23 Jan 89 21:45 PSTCc: cl-cleanup@sail.stanford.edu> The proposal mentions in passing "It would be possible to submit a proposal> for a GLOBAL (G) declaration>   under separate cover if anyone (Xerox?) was interested."I'm still not quite happy with GLOBAL, particularly if it disallowslocal lexical variables of the same name.  As far as lexical variablesare concerned, the reference can be determined statically.  And if it'sto the global, it's to the global.  No efficiceny need be lost.  That'swhat happens in languages without special variables, and it's whatshould happen in Lisp for variables that are lexical.  So I don'tthink the LG proposal had much need for a GLOBAL declaration.As I understand it, the problem faced by deep-bound implementations(of special variables) is that they don't know whether there areany bindings or not and so have to look before fetching the globalvalue.  But I think it's OK for that to happen to variables thatmight have special bindings; what's wrong is to have to do it eventhough the programmer knows there will never be any bindings.So if GLOBAL is taken to mean only "there will be no specialbindings", then it's probably OK.Some implementations allow one to fetch the global value eventhought there are local special bindings.  I think such usagerepresents a confusion about whether the variable is supposedto have special bindings or not.Nonetheless, although I think a limited meaning for GLOBAL is ok,I still prefer LEXICAL.  LEXICAL sunsumes all the reasonable usesof GLOBAL.*start*01853 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 27 JAN 89 03:24:38 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA13714g; Fri, 27 Jan 89 03:20:40 PSTReceived: by bhopal id AA17677g; Fri, 27 Jan 89 03:22:55 PSTDate: Fri, 27 Jan 89 03:22:55 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901271122.AA17677@bhopal>To: masinter.paCc: sandra%defun@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 23 Jan 89 21:45 PST <890123-214709-2907@Xerox>Subject: issue PROCLAIM-LEXICALre: Insofar as GLOBAL is very like LEXICAL, it would count for "current    practice", would it not? The reason for GLOBAL is primarily for performance    -- it is a deep-bound implementation, and references to GLOBAL variables    are significantly faster.  I don't think Medley users would get along OK    without it.  I don't think users of *any* deep-bound implementation wouldQuite right.  You can also add to current practice that QLISP uses aGLOBAL declaration in just about the same way that Interlisp-D/Medleydoes.  [It was probably my comment in the Discussion that you referred to when you said "It would be possible to submit a proposal for a GLOBAL (G)declaration under separate cover if anyone (Xerox?) was interested."]I think QLISP would find acceptable the minor adjustment about allowing purely local lexical rebinding of proclaimed GLOBAL's.  Surely Medleywould have no trouble accommodating either.-- JonL --P.S.  QLISP is a research prototype of Lucid Common Lisp running on a      certain parallel processor.  It uses deep-binding for the obvious      reason.  By the bye, "research prototype" doesn't mean "it's a dog";      there is some serious research being conducted using QLISP as a tool.*start*07029 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 27 JAN 89 17:52:52 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 528632; Fri 27-Jan-89 20:51:01 ESTDate: Fri, 27 Jan 89 20:51 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue PROCLAIM-LEXICALTo: Sandra J Loosemore <sandra%defun@cs.utah.edu>, Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, masinter.pa, Jon L White <jonl@lucid.com>cc: cl-cleanup@SAIL.STANFORD.EDU, sandra <@cs.utah.edu:sandra@defun>In-Reply-To: <8901202253.AA17398@defun.utah.edu>,             <890123132952.8.KMP@BOBOLINK.SCRC.Symbolics.COM>,             <14006.8901232325@subnode.aiai.ed.ac.uk>,             <8901240426.AA19262@defun.utah.edu>,             <890123-214709-2907@Xerox>,             <20300.8901251626@subnode.aiai.ed.ac.uk>,             <8901271122.AA17677@bhopal>Message-ID: <19890128015132.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Fri, 20 Jan 89 15:53:12 MST    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    My gut feeling on this issue is that people would be willing to vote    it in, provided that we can guarantee that you would never have to    access the symbol's global value when there is a special binding of    the variable.  I believe this was the purpose of the amendment that    was accepted (stating that "it is an error" to specially bind a variable    that has been proclaimed lexical), but there are still some other    possible cases.Yes, I believe that was the unstated goal behind all of the proposedamendments.  I also believe that it would take several additionalamendments beyond the two proposed to completely close this "hole."I agree with Kent that trying to close this "hole" is a very, very badidea.I believe that the reason people have this goal is not at all an issueof desired language semantics, but instead that they believe it would betoo difficult in a shallow-bound implementation to allow access to theglobal value in the presence of special bindings.  I used to believethat too, but I figured out that the implementation expense can be verysmall.  Here is why:On stock hardware, the implementation of special variables is unchangedexcept that associated with each shallow binding cell is a flag thatsays whether a SPECIAL binding has ever been performed.  This flag canbe set by the loader when a function that might make a SPECIAL bindingof that variable is loaded, and also must be set by PROGV.  Theimplementation of global LEXICAL variables checks this flag; if clear(as it will be in the vast majority of cases), use the shallow bindingcell.  If the flag is set, global LEXICAL access must search the SPECIALbinding information to find where the global value has been saved, apleasing symmetry with deep binding.  Note that this implementation puts100% of the performance cost on the new feature, and in the majority ofcases the performance cost is only two instructions to verify that theflag is clear.  In fact, in an implementation that can patch compiledcode, the cost is zero because global LEXICAL accesses can be compiledoptimistically and in the event that the SPECIAL binding flag gets set,they can be patched to call the slow subroutine.  Of course in a deepbound implementation, global LEXICAL access just accesses the globalcell and there is no cost.On machines with invisible pointers, the implementation is to have aglobal SPECIAL cell and a separate global LEXICAL cell, linked togetherby an invisible pointer from the SPECIAL cell to the LEXICAL cell.SYMBOL-VALUE and SET follow the invisible pointer, but binding does not.As desired, the shallow bound cell shares with the global LEXICAL cell ifand only if no special bindings are present.  Of course you only createthese value cells on demand, so for the vast majority of symbols thatare not used in both the SPECIAL way and the global LEXICAL way, you donot pay the overhead of having two cells.My conclusion is that I am strongly opposed to any attempt to amend thisproposal to restrict simultaneous use of special and lexical variables.It would be much preferable not to pass this proposal at all than to pass it in messed-up form.    Date: 23 Jan 89 21:45 PST    From: masinter.pa@Xerox.COM    ....The reason for GLOBAL is primarily for performance    -- it is a deep-bound implementation, and references to GLOBAL variables    are significantly faster.  I don't think Medley users would get along OK    without it.  I don't think users of *any* deep-bound implementation would    get along well without some equivalent.I think the idea that deep-bound implementations can only work well whenthere are GLOBAL declarations is misguided.  What does GLOBAL reallymean?  I claim it is a -declaration- by which the programmer promisesnot to make any special bindings.  But the implementation is perfectlycapable of determining for itself whether there are any specialbindings, without any help from the programmer.  Comparable to what Isuggested above for LEXICAL variables in shallow-bound implementations,accessing a SPECIAL variable in a deep-bound implementation can easilycheck a flag indicating whether any bindings have ever been performed.In the usual case where there are no bindings, the run-time cost iszero, as I indicated above.    Given the likelihood of PROCLAIM-LEXICAL:LG failing, I suppose I *would*    like to see a GLOBAL proclaimation made standard, since it doesn't seem to    hurt shallow bound implementations and is important for deep-bound    implementations. If "it is an error to attempt to bind a variable    proclaimed or declared GLOBAL", if you declare it or proclaim it GLOBAL,    you can't have any bindings, whether such bindings would be lexical or    special. In that sense, a GLOBAL variable could be thought of as a subset    of SPECIAL variables which share the "not bindable" property of constants.In the immortal words of America's last truly great president, we could dothat but it would be wrong.I think we should pass PROCLAIM-LEXICAL as it was before it was amended.    Date: Wed, 25 Jan 89 16:26:36 GMT    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>    As I understand it, the problem faced by deep-bound implementations    (of special variables) is that they don't know whether there are    any bindings or not and so have to look before fetching the global    value.  But I think it's OK for that to happen to variables that    might have special bindings; what's wrong is to have to do it even    though the programmer knows there will never be any bindings.Right, that's what I was trying to say above.    I still prefer LEXICAL.  LEXICAL sunsumes all the reasonable uses    of GLOBAL.I feel the same way.*start*03557 00024 US Return-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 03 FEB 89 06:03:53 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa05472; 2 Feb 89 15:31 GMTDate: Thu, 2 Feb 89 15:46:17 GMTMessage-Id: <8811.8902021546@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICALTo: Jon L White <@sail.stanford.edu:jonl@lucid.com>, Moon@scrc-stony-brook.arpaCc: sandra <@cs.utah.edu:sandra@defun>, KMP@scrc-stony-brook.arpa, masinter.pa, cl-cleanup@sail.stanford.edu> This topic has had enormous amounts of discussion a long time ago.> Perhaps you weren't party to the discussions back then, by my objection> -- shared by several others (e.g. Julian Padgett?)  --  is  *** not> at all *** on the performance implications. Some of the objections at he Hawaii meeting were definitely aboutthe performance implications, and also the question of whether the"bit" needed for the flag can actually be found.  (At least one personsaid they didn't have a free bit.)I am having difficulty understanding the "conceptual" argument.It seems that you end up with local lexical being able to overrideproclaimed special but not the other way around.  The LG proposal isat least symmetric.And, as I tried to say in an earlier message, the reasonable usesof GLOBAL are subsumed by LEXICAL.> Now, QLISP is a deep bound implementation, and thus already has these> algorithms working (patterened, not unsurprisingly, after some of> the Interlisp work).  But we strongly feel that there should not be> two conceptually different "top level" environments -- a global-lexical> one and a global-dynamic one.  The counter argument that these would> be implemented as exactly the same set of value cells is not relevant.Conceptually, there is one global environment in the LG proposal.That's how the proposal's stated, at least, and I do think you cancoherently think of it that way.> Our feeling (if indeed I speak for some of the other objectors) is that > local lexical overrides of global proclamations are acceptable;  the > override has only tightly constrained lexical scope.  Thus a local> "lexical" declaration for a variable proclaimed to be SPECIAL is> not troublesome.  But an override of either a SPECIAL or a GLOBAL                                                   |Do you mean LEXICAL here -------------------------| ?You just said a lexical declaration for a variable proclaimed specialwas OK; so if you don't mean LEXICAL, there's a contradiction.> proclamation that has indefinite scope (yes "scope", not extent) is a > terribly bad and confusing idea.   A special declaration or binding of > a variable globally proclaimed LEXICAL (or, GLOBAL as in QLISP's case) > would be such a violation.Case 1: (let ((a 10))	  (let ((a 20))	    (declare (special a)) ;override lexical	    ...)	  ...)Case 2: (define-lexical a 10)	(let ((a 20))	  (declare (special a))	  ...)Why are these two cases different?  Both set up a new scope in whichthe variable A is special instead of lexical.  Both do it insideanother scope where the variable is lexical.I think these two cases should be analogous.  The only reason thatthey should not be (that I can see) is that PROCLAIM is somehow"more magic" than placing the corresponding declaration on everybinding.  And if it is "more magic", I think it should not be.-- Jeff*start*02347 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 FEB 89 15:18:58 PSTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 5 Feb 89  15:19:16 PSTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA18442@EDDIE.MIT.EDU>; Sun, 5 Feb 89 18:17:37 ESTReceived: by spt.entity.com (smail2.5); 5 Feb 89 18:09:14 EST (Sun)To: cl-cleanup@sail.stanford.eduSubject: issue PROCLAIM-LEXICALMessage-Id: <8902051809.AA16827@spt.entity.com>Date: 5 Feb 89 18:09:14 EST (Sun)From: gz@spt.entity.com (Gail Zacharias)There seem to be three somewhat separate extensions being considered inthis proposal.First is a declaration for variable bindings which allows you to requesta lexical binding, shadowing SPECIAL proclaimations for bindings, e.g.	(proclaim '(special *x*))	(let ((*x* nil)) (declare (lexical *x*)) .. *x* ..)This introduces no new lookup mechanisms or binding environments, anda lot of users are asking for it, so it seems pretty uncontroversial.Second is a declaration for variable references which allows you to requesta reference to the lexical binding of a variable, shadowing SPECIALdeclarations for references, e.g.        (let ((x 'lexical))	  (locally (declare (special x))	  ... (locally (declare (lexical x)) x) ...))This introduces no new concepts whatsoever, being equivalent to:	(let ((x 'lexical))	  (flet ((lexical-x () x))	    (locally (declare (special x))	      ... (lexical-x) ...)))so I would think it would be uncontroversial as well.Finally there is the question of a declaration/proclamation which applies tofree variable references (i.e. not referring to a lexical binding), whichin the current proposal introduces LG lookup allowing you to "close over"global values of variables.  This is a new a new concept to Common Lisp,and is clearly controversial.I think it would be a good idea to put the first two extensions in a separateproposal so they don't get lost or mangled in the controversy over LG lookup.LG lookup can then be considered as an additional extension. This seems betterthan putting it all in one proposal and then waging the battle over the LGaspect in an endless stream of possibly incompatible amendments.*start*03541 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 13:02:55 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 6 Feb 89  13:01:17 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06968; 6 Feb 89 18:07 GMTDate: Mon, 6 Feb 89 18:25:20 GMTMessage-Id: <17283.8902061825@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICALTo: Gail Zacharias <gz%spt.entity.com@NSS.Cs.Ucl.AC.UK>, cl-cleanup@sail.stanford.eduIn-Reply-To: Gail Zacharias's message of 5 Feb 89 18:09:14 EST (Sun)> There seem to be three somewhat separate extensions being considered in> this proposal.I agree that the first two issues you identify should not beparticularly controversial.  However, the existence of a lexicaldeclaration more or less implies that there is a correspondingproclamation, so I think we should try to give that proclamation areasonable meaning and separate the proposals only if that proves toodifficult.> Finally there is the question of a declaration/proclamation which> applies to free variable references (i.e. not referring to a lexical> binding), which in the current proposal introduces LG lookup allowing> you to "close over" global values of variables.  This is a new a new> concept to Common Lisp, and is clearly controversial.It may be misleading to think of it as "closing over".  The LGproposal has only one global environment, and closures would notneed to contain any new information.One of the problems this proposal tries to address is that inCommon Lisp it's difficult to have a global variable whose namecan also be used as a normal (lexical) variable.  Since SPECIALproclamations affect all bindings involving the name so proclaimed(and not just free references), a SPECIAL proclamation, or a DEFVAR,prevents the name from being used as a non-special variable.So how do I get a global variable of the sort that almost allprogramming languages have?  I could try just setting its value,avoiding DEFVAR and the like.  But then many compilers complainabout free references.  I don't suppose any of them actually goso far as to proclaim the name special, but some Lisps certainlydid do that in the past.The LG proposal attempts to solve this problem, plus the twoother cases you mentioned, in a consistent way.  I think theexplanation in terms of L, G, and D environments is fairlyclear and easy to understand, although I'm not entirelyhappy with the emphasis on "searching" the environments.I'd prefer a more static description, if possible.So far, the alternative proposals handle fewer cases (the GLOBALproclamation) or are less consistent (e.g., you can override a SPECIALproclamation by using a LEXICAL declarations on a binding but can'toverride a LEXICAL proclamation by using a SPECIAL declaration).I would be wary of adopting a less consistent proposal, because itwould be harder to explain, understand, and use.  GLOBAL seems to metoo much of a special case and seems more appropriate to a Lisp thatemphasises dynamic binding (such as InterLisp) than to one thatencourages the use of static scoping.  A third possibility, changingSPECIAL proclamations so that they do not affect bindings, is likelyto die on the grounds of incompatibility.So that leaves LG, which is still the alternative I favor.*start*01413 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 07 FEB 89 12:46:42 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02482g; Tue, 7 Feb 89 12:41:45 PSTReceived: by bhopal id AA23898g; Tue, 7 Feb 89 12:44:07 PSTDate: Tue, 7 Feb 89 12:44:07 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8902072044.AA23898@bhopal>To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKCc: @sail.stanford.edu:jonl@lucid.com, Moon@scrc-stony-brook.arpa,        @cs.utah.edu:sandra@defun, KMP@scrc-stony-brook.arpa,        masinter.pa@xerox.com, cl-cleanup@sail.stanford.eduIn-Reply-To: Jeff Dalton's message of Thu, 2 Feb 89 15:46:17 GMT <8811.8902021546@subnode.aiai.ed.ac.uk>Subject: issue PROCLAIM-LEXICALre: I think these two cases should be analogous.  The only reason that    they should not be (that I can see) is that PROCLAIM is somehow    "more magic" than placing the corresponding declaration on every    binding.  And if it is "more magic", I think it should not be.Rather than reply to each of the various question you raise, maybe thislast one is the important one.  Yes, a proclamation is more pervasivethan any bounded set of DECLARE's inserted into code.  In particular,the DECLAREs (of your examples) are in the same lexical scope; butthe PROCLAIM might even be in another separately-compiled file.-- JonL --*start*00932 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 FEB 89 12:52:50 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Feb 89  12:52:10 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02503g; Tue, 7 Feb 89 12:46:42 PSTReceived: by bhopal id AA23943g; Tue, 7 Feb 89 12:49:04 PSTDate: Tue, 7 Feb 89 12:49:04 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8902072049.AA23943@bhopal>To: gz@spt.entity.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Gail Zacharias's message of 5 Feb 89 18:09:14 EST (Sun) <8902051809.AA16827@spt.entity.com>Subject: issue PROCLAIM-LEXICALYour suggestion to separate out the proposal parts that are purelylexically scoped from the PROCLAIM extensions (which are not justlexically scoped) sounds reasonable to me.-- JonL --*start*02886 00024 USaReturn-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 13 FEB 89 12:49:13 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa10389; 13 Feb 89 20:14 GMTDate: Mon, 13 Feb 89 20:34:53 GMTMessage-Id: <8378.8902132034@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICALTo: Jon L White <jonl%lucid.com@NSS.Cs.Ucl.AC.UK>Cc: jonl <@sail.stanford.edu:jonl@lucid.com>, Moon@scrc-stony-brook.arpa, sandra <@cs.utah.edu:sandra@defun>, KMP@scrc-stony-brook.arpa, masinter.pa, cl-cleanup@sail.stanford.edu> Rather than reply to each of the various question you raise, maybe this> last one is the important one.Actually, I'm now more confused rather than less.  My best guess isthat your objection to special declarations that override a lexicalor global proclamation is that special variables have indefinitescope.  (But lexical variables don't -- they have lexical scope --so lexical declarations that override are OK.)But I'm not sure why this is so significant.  A special declarationhas a lexically bounded effect: it affects only certain bindings(actually, at most one) and references.  Suppose I never use a specialproclamation.  It seems that you would still like to forbid me fromever using a special variable that had the same name as a globalvariable (in the LG sense).  And I don't see why.  Perhaps I couldsee why, but I need an "intuition pump" (Dennett) or something.Under the LG proposal, as in CL now, I can go around (statically) andcolor all lexical and global variable references green and all specialreferences red.  (The green ones are just the ones that are not affectedby a special declaration or proclamation.)  The main difficulty indoing this, so that local inspection isn't quite enough, is thepervasive effect on bindings of special proclamations; but thatproblem was already there and not introduced by LG.Then, I can always tell what green references refer to.  There'seither a locally evident lexical binding -- in which case thereference is to it -- or else the reference is to the global.  Redreferences have to be resolved (D or G?) dynamically; but again that'snot something introduced by LG.> Yes, a proclamation is more pervasive> than any bounded set of DECLARE's inserted into code.OK, but I didn't mean a bounded set; I meant every binding.  And Ithink PROCLAIM ought to correspond to something that can be done withDECLARE.> In particular, the DECLAREs (of your examples) are in the same> lexical scope; but the PROCLAIM might even be in another> separately-compiled file.I guess the problem is that I do not see why that is a decisivefactor.  Perhaps I picked the wrong example to elaborate.-- Jeff*start*02920 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 02 FEB 89 09:58:24 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02816g; Thu, 2 Feb 89 05:14:51 PSTReceived: by bhopal id AA28172g; Thu, 2 Feb 89 05:15:43 PSTDate: Thu, 2 Feb 89 05:15:43 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8902021315.AA28172@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: sandra%defun@cs.utah.edu, KMP@STONY-BROOK.SCRC.Symbolics.COM, jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK, masinter.pa, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Fri, 27 Jan 89 20:51 EST <19890128015132.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: issue PROCLAIM-LEXICALre: 	... provided that we can guarantee that you would never have to	access the symbol's global value when there is a special binding of	the variable.  I believe this was the purpose of the amendment that    . . .     I believe that the reason people have this goal is not at all an issue    of desired language semantics, but instead that they believe it would be    too difficult in a shallow-bound implementation to allow access to the    global value in the presence of special bindings.  I used to believe    that too, but I figured out that the implementation expense can be very    small.  Here is why:   . . .This topic has had enormous amounts of discussion a long time ago.Perhaps you weren't party to the discussions back then, by my objection-- shared by several others (e.g. Julian Padgett?)  --  is  *** notat all *** on the performance implications.  In fact, in the earlierdiscussion, I likened the algorithm for global-lexical access inshallow bound implementations as a "dual" to that for dynamic accessin a deep bound implementation; efficient algorithms for this problemhave been known for nearly 15 years or more.Now, QLISP is a deep bound implementation, and thus already has thesealgorithms working (patterened, not unsurprisingly, after some ofthe Interlisp work).  But we strongly feel that there should not betwo conceptually different "top level" environments -- a global-lexicalone and a global-dynamic one.  The counter argument that these wouldbe implemented as exactly the same set of value cells is not relevant.Our feeling (if indeed I speak for some of the other objectors) is that local lexical overrides of global proclamations are acceptable;  the override has only tightly constrained lexical scope.  Thus a local"lexical" declaration for a variable proclaimed to be SPECIAL isnot troublesome.  But an override of either a SPECIAL or a GLOBAL proclamation that has indefinite scope (yes "scope", not extent) is a terribly bad and confusing idea.   A special declaration or binding of a variable globally proclaimed LEXICAL (or, GLOBAL as in QLISP's case) would be such a violation.-- JonL --*start*01171 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 17:25:46 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Mar 89  17:26:13 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 13 MAR 89 17:14:49 PSTDate: 13 Mar 89 17:14 PSTFrom: masinter.paSubject: Re: issue PROCLAIM-LEXICAL (Version 9)In-reply-to: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>'s message of Mon, 13 Feb 89 20:34:53 GMTTo: cl-cleanup@sail.stanford.eduMessage-ID: <890313-171449-21261@Xerox>I'm finally getting back to doing some cleanup work, after a long hiatus.The last version of PROCLAIM-LEXICAL I have is Version 9, which wasdistributed before the Hawaii meeting. There were the various comments onVersion 9, amendments proposed but not passed, and, more recently, mailfrom Sandra Loosemore, Jeff Dalton, JonL White, Gail Zacharias and DavidMoon.However, there's no new version.Who will produce one? If we don't have a new version, we probably won't beable to vote on anything. I think that would be a shame.Larry*start*01743 00024 USaGV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 12:28:17 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 12:27:04 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 15 Mar 89  12:26:28 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa11885; 15 Mar 89 20:13 GMTDate: Wed, 15 Mar 89 20:10:25 GMTMessage-Id: <2348.8903152010@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICAL (Version 9)To: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@com.xerox's message of 13 Mar 89 17:14 PST> The last version of PROCLAIM-LEXICAL I have is Version 9, which was> distributed before the Hawaii meeting. There were the various comments on> Version 9, amendments proposed but not passed, and, more recently, mail> from Sandra Loosemore, Jeff Dalton, JonL White, Gail Zacharias and David> Moon.> > However, there's no new version.Last I knew, JonL had said there were "conceptual" problems.  I saidthat, if there were, I didn't understand what they were.  And that wasthe last I saw on this topic.  Maybe I'd managed to convince JonL?In Hawaii, some people objected on grounds of efficiency or becausethey didn't have a spare bit (see the Rees suggestion in theproposal).I think the ammendments proposed in Hawaii might have answered bothkinds of objection, but I remember thinking that some of theammendments were unnecessary or wrong.Perhaps those who still have objections can say what they would liketo change and why.*start*01057 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Mar-89 10:57:58 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 10:44:22 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  10:44:44 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 16 MAR 89 10:26:03 PSTDate: 16 Mar 89 10:02 PSTFrom: masinter.paSubject: Re: issue PROCLAIM-LEXICAL (Version 9)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 16 Mar 89 12:29 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, cl-cleanup@sail.stanford.eduMessage-ID: <890316-102603-4543@Xerox>What I meant to ask was: what amendments actually passed? If none, then wecan just bring up version 9 again. I think we can certainly ignoreamendments that were were voted on and failed or did not come far enough toget to a vote. *start*00584 00024 US GV-Info: masinter.pa at 16-Mar-89 08:27:32 from massunterDate: 16 Mar 89 08:27 PSTFrom: masinter.paSubject: Re: issue PROCLAIM-LEXICAL (Version 9)In-reply-to: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>'s message of Wed, 15 Mar 89 20:10:25 GMTTo: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>cc: masinter.pa, cl-cleanup@sail.stanford.eduDoes anyone at least have a record of the amendments that were proposed at the last meeting. In lieu of a new version, we are probably obligated to put version 9, as amended, on the table.*start*01494 00024 USaGV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Mar-89 09:51:49 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 09:32:02 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 16 Mar 89  09:32:12 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 558521; Thu 16-Mar-89 12:29:32 ESTDate: Thu, 16 Mar 89 12:29 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: issue PROCLAIM-LEXICAL (Version 9)To: masinter.pacc: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, cl-cleanup@sail.stanford.eduIn-Reply-To: <890316-082748-3893@Xerox>Message-ID: <19890316172923.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 16 Mar 89 08:27 PST    From: masinter.pa@Xerox.COM    Does anyone at least have a record of the amendments that were proposed at    the last meeting. In lieu of a new version, we are probably obligated to    put version 9, as amended, on the table.Maybe I shouldn't take this attitude, but I will anyway.  I have briefnotes on the amendments that were proposed, but since I think all of themwere wrongheaded and braindamaged, I'm not going to help anyone rememberthem.  Only one of the amendments was actually voted on, so we're certainlyfree to forget the other two.*start*00676 00024 US GV-Info: masinter.pa at 16-Mar-89 10:02:36 from massunterDate: 16 Mar 89 10:02 PSTFrom: masinter.paSubject: Re: issue PROCLAIM-LEXICAL (Version 9)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 16 Mar 89 12:29 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, cl-cleanup@sail.stanford.eduWhat I meant to ask was: what amendments actually passed? If none, then we can just bring up version 9 again. I think we can certainly ignore amendments that were were voted on and failed or did not come far enough to get to a vote. *start*01631 00024 US GV-Info: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK at 16-Mar-89 10:16:16 from AGReturn-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 16 MAR 89 09:57:58 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa11885; 15 Mar 89 20:13 GMTDate: Wed, 15 Mar 89 20:10:25 GMTMessage-Id: <2348.8903152010@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICAL (Version 9)To: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@com.xerox's message of 13 Mar 89 17:14 PST> The last version of PROCLAIM-LEXICAL I have is Version 9, which was> distributed before the Hawaii meeting. There were the various comments on> Version 9, amendments proposed but not passed, and, more recently, mail> from Sandra Loosemore, Jeff Dalton, JonL White, Gail Zacharias and David> Moon.> > However, there's no new version.Last I knew, JonL had said there were "conceptual" problems.  I saidthat, if there were, I didn't understand what they were.  And that wasthe last I saw on this topic.  Maybe I'd managed to convince JonL?In Hawaii, some people objected on grounds of efficiency or becausethey didn't have a spare bit (see the Rees suggestion in theproposal).I think the ammendments proposed in Hawaii might have answered bothkinds of objection, but I remember thinking that some of theammendments were unnecessary or wrong.Perhaps those who still have objections can say what they would liketo change and why.*start*01347 00024 US GV-Info: Moon@STONY-BROOK.SCRC.Symbolics.COM at 16-Mar-89 13:47:38 from AGReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 16 MAR 89 13:47:33 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 558521; Thu 16-Mar-89 12:29:32 ESTDate: Thu, 16 Mar 89 12:29 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: issue PROCLAIM-LEXICAL (Version 9)To: masinter.pacc: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, cl-cleanup@sail.stanford.eduIn-Reply-To: <890316-082748-3893@Xerox>Message-ID: <19890316172923.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 16 Mar 89 08:27 PST    From: masinter.pa@Xerox.COM    Does anyone at least have a record of the amendments that were proposed at    the last meeting. In lieu of a new version, we are probably obligated to    put version 9, as amended, on the table.Maybe I shouldn't take this attitude, but I will anyway.  I have briefnotes on the amendments that were proposed, but since I think all of themwere wrongheaded and braindamaged, I'm not going to help anyone rememberthem.  Only one of the amendments was actually voted on, so we're certainlyfree to forget the other two.*start*01226 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Mar-89 14:40:11 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 14:40:12 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 16 Mar 89  14:40:07 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 558955; Thu 16-Mar-89 17:36:38 ESTDate: Thu, 16 Mar 89 17:36 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: issue PROCLAIM-LEXICAL (Version 9)To: masinter.pacc: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, cl-cleanup@sail.stanford.eduIn-Reply-To: <890316-102603-4543@Xerox>Message-ID: <19890316223630.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 16 Mar 89 10:02 PST    From: masinter.pa@Xerox.COM    What I meant to ask was: what amendments actually passed?One amendment actually passed, but I'm still going to be a jerk and nottell you what it was.  If someone wants to propose the same amendmentagain, I don't think that will waste very much time.*start*01468 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 11:23:10 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 10:46:25 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 17 Mar 89  10:46:17 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa08933; 17 Mar 89 18:26 GMTDate: Fri, 17 Mar 89 18:25:09 GMTMessage-Id: <5014.8903171825@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: issue PROCLAIM-LEXICAL (Version 9)To: "David A. Moon" <Moon@scrc-stony-brook.arpa>, masinter.paIn-Reply-To: David A. Moon's message of Thu, 16 Mar 89 12:29 ESTCc: cl-cleanup@sail.stanford.edu> Maybe I shouldn't take this attitude, but I will anyway.  I have brief> notes on the amendments that were proposed, but since I think all of them> were wrongheaded and braindamaged, I'm not going to help anyone remember> them.  Only one of the amendments was actually voted on, so we're certainly> free to forget the other two.I didn't much like the ammendments either.  They were drafted on thespot and probably not very well thought-out.However, it would be nice to know if there are still strong objectionsto version 9 (and what they are if they exist) so there will be timeto consider them before the meeting.*start*01955 00024 US Date:  4 Apr 89 12:44 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: PROCLAIM-LEXICALTo: CL-Cleanup%SAIL.Stanford:EDU:Xeroxcc: JAR%AI.AI.MIT:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PROCLAIM-LEXICALTo: CL-Cleanup@SAIL.Stanford.EDUcc: JAR@AI.AI.MIT.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:39:45 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:36:44 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571257; Tue 4-Apr-89 15:36:39 EDTOriginal-Date: Tue, 4 Apr 89 15:36 EDTMessage-ID: <890404153614.0.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say... KMP made a friendly amendment to clarify the status of undeclared free variables (as undefined). The text of the amendment was: -----   Proposed amendment to PROCLAIM-LEXICAL    KMP 3/30/89   Add:   Referencing a free variable that is neither proclaimed	  nor declared LEXICAL nor SPECIAL has undefined	  consequences.   Rationale:    This enables existing implementations to persist in permitting,    for example,	(SETQ X 3)    without defining X as lexical or special, yet allows those    implementations that want to warn about	(DEFUN F (X) (+ X Y))    when Y is undeclared/proclaimed to legitimately do so. -----  GZ wanted an amendment that would make it an error to use the LEXICAL declaration when there was not a lexically visible binding to which it might refer.  Her amendment failed 5-12.  The proposal (with friendly amendment by KMP but without GZ's  amendment) finally failed 6-11.