*start*02326 00024 UShOriginator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Nov 87 16:53From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: Hiroshi "Gitchang" Okuno's message of Sun, 8 Nov 87 14:26:27 PST <12349062523.26.OKUNO@SUMEX-AIM.STASubject: equality of structures, or *default-structure-type*To: labrea!Okuno%SUMEX%labrea.stanford:EDU:Xeroxcc: labrea!common-lisp%SAIL%labrea.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: labrea!Okuno%SUMEX@labrea.stanford.eduCc: labrea!common-lisp%SAIL@labrea.stanford.eduIn-Reply-To: Hiroshi "Gitchang" Okuno's message of Sun, 8 Nov 87 14:26:27 PST <12349062523.26.OKUNO@SUMEX-AIM.STANFORD.EDU>Subject: equality of structures, or *default-structure-type*Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 16:52:31 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 8 Nov 87  16:16:08 PSTReceived: by labrea.stanford.edu; Sun, 8 Nov 87 16:14:28 PSTReceived: from bhopal.lucid.com by edsel id AA16787g; Sun, 8 Nov 87 16:08:10 PSTReceived: by bhopal id AA13142g; Sun, 8 Nov 87 16:07:52 PSTOriginal-Date: Sun, 8 Nov 87 16:07:52 PSTMessage-Id: <8711090007.AA13142@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVA defstruct not given the :type option is the one area where CL's defstructtries to go beyond the "record structure" semantics, and enter the area oflimited "object based" programming.  It's somewhat ironic that only whenyou don't specify :type do the elements of the defined structure becomefull-fledged members of the common-lisp type system; i.e., they areidentifiably of of the defined type rather than the implementational type.Many persons have criticized this merger of capabilities in defstruct.  Themost popular direction, however, is not to "fix" the problem with non-:typestructures, but to hail the coming of the Common Lisp Object System, whichwill do a much grander job of providing object-oriented capabilities.   All the interesting properties of defaultly-typed defstructs will be subsumedby defclass.  Then, the use of defstruct could be, conventionally, limited to :type structures.-- JonL --*start*02152 00024 UShOriginator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Nov 87 15:06From: Okuno%SUMEX-AIM.STANFORD:EDU:XeroxSubject: equality of structures, or *default-structure-type*To: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Hiroshi "Gitchang" Okuno <Okuno@SUMEX-AIM.STANFORD.EDU>Subject: equality of structures, or *default-structure-type*To: common-lisp@SAIL.STANFORD.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 15:06:30 PSTReceived: from SUMEX-AIM.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 8 Nov 87  14:26:38 PSTOriginal-Date: Sun, 8 Nov 87 14:26:27 PSTOrganization: Knowledge Systems Laboratory, CSD, Stanford UniversityGroup: Heuristic Programming ProjectProject: Advanced Architectures ProjectAddress: 701 Welch Road, Building C, Palo Alto, CA 94304-1703Phone: +1 (415)725-4854Message-ID: <12349062523.26.OKUNO@SUMEX-AIM.STANFORD.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIf the :type option is not specified in defstruct, the structure isrepresented in an implementation-dependent manner (CLtL p.314).However, this implementation-dependentness introduces the ambiguity ofequality of structures.  Suppose that one implementation uses an arrayfor the default representation of a structure, while the otherimplementation uses a list for it (of course, it's a sillyimplementation).  The equality of structures may differ on these twoimplementations, since equality of array is checked by the 'eq'nessand that of list is checked by the equality of corresponding elements(CLtL p.80).  For example,		(defstruct foo a b c)default :type = :array	(equal (make-foo) (make-foo)) ===> nildefault :type = :list	(equal (make-foo) (make-foo)) ===> tThis observation proves that we need introduce a new global variable,say *default-structure-type*, in order to raise the portability ofCOMMON Lisp programs.Since I cannot find any messages on this matter in the archivedfiles at sumex, I post this message.- Gitchang --------*start*02887 00024 UShOriginator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  9 Nov 87 12:48From: goldman%vaxa.isi:EDU:XeroxSubject: equality of structuresTo: COMMON-LISP%sail.stanford:EDU:Xeroxcc: goldman%vaxa.isi:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 NOV 87 12:48:28 PSTReceived: from VAXA.ISI.EDU by SAIL.STANFORD.EDU with TCP; 9 Nov 87  11:58:55 PSTPosted-Date: Mon, 09 Nov 87 11:59:25 PSTMessage-Id: <8711091959.AA14960@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.54/5.51)	id AA14960; Mon, 9 Nov 87 11:59:49 PSTOriginal-Date: Mon, 09 Nov 87 11:59:25 PSTFrom the standpoint of writing TRANSFORMATIONs on common lisp programs,it would be preferable to have EQUAL well defined for structureinstances for which no :type (too bad that wasn't called :implementation)is specified.  Personally, I would like  the definition should be:  two instances are EQL iff they are EQ  two instances are EQUAL iff    a) they are instances of the same most specific structure type, and    b) the contents of all corresponding fields are EQUAL.[This is like the current definition of EQUALP for un:TYPEed structures,at least if you believe structures are objects that have components-- see CLtL's definition  of EQUALP.][However, I suspect that most implementors would rather have it definedlike to have these objects be EQUAL iff they are EQL, so they can be implemented as arrays.]This entire problem, I am sure, stems from the more fundamental "problem"that EQUAL is defined to recur into components of lists, but NOT of arrays,-- except for STRINGs and BIT-VECTORs -- a decision that could ONLY have itsroots in implementation considerations. An alternative  suggested by the earlier message, a *default-structure-type* variable, implies making the definition ofEQUAL implementation specific.  But I think it carried along with it animplication that implementations are limitied to defaulting theimplementation of such structure instancesto the equivalent of what results from either :ARRAY or :LIST, and to defaulting the implementation of ALL instances the same way.Re:  the suggestion that CLOS should subsume (by convention or otherwise)uses of un:TYPEed defstruct types?   I presume that this takes care of the issue of EQUAL, because the CLOSspecifies the semantics of EQUAL for its class instances?  (What is thespecification, by the way?)  But I would be loathe to replace my un:TYPEeddefstructs with DEFCLASSes if I gave up substantial efficiency when I onlywanted the limited power provided by the "record structure" semantics.Are there enough declarations available in CLOS so that I could getmy compiled accesses to slots of such instances down to the equivalentof an array element reference?Neil*start*02103 00024 UShOriginator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  9 Nov 87 14:58From: barmar%Think:COM:XeroxSubject: equality of structures, or *default-structure-type*In-Reply-to: <12349062523.26.OKUNO@SUMEX-AIM.STANFORD.EDU>To: Okuno%sumex-aim.stanford:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: equality of structures, or *default-structure-type*To: "Hiroshi \"Gitchang\" Okuno" <Okuno@sumex-aim.stanford.edu>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <12349062523.26.OKUNO@SUMEX-AIM.STANFORD.EDU>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 NOV 87 14:57:55 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 9 Nov 87  14:09:56 PSTReturn-Path: <@occam.think.com:barmar@Think.COM>Received: from pozzo ([192.5.104.209]) by Think.COM; Mon, 9 Nov 87 11:36:06 ESTReceived: from OCCAM.THINK.COM (occam.think.com.ARPA) by pozzo; Mon, 9 Nov 87 11:31:59 estOriginal-Date: Mon, 9 Nov 87 11:34 ESTMessage-Id: <871109113400.5.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI believe the intent, but not the letter, of the specification was thatwhen you don't specify the type explicitly, an implementation-dependenttype that is distinguishable from all other types would be used.  Theactual implementation may be as some other primitive type (list, array)but the object will be marked in some way that it can be recognized as adefstruct-created structure.I believe that this interpretation is necessary in order to cause thestructure's print-function to be invoked.  If structures weren'tdistinguishable from other data types then they would print as thosedata types print, rather than using the #S notation (or the:PRINT-FUNCTION).Therefore, the definition of EQUAL could be extended to explicitlyspecify its interpretation given two structures of the same type.                                                barmar*start*04143 00024 UShReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 15:54:27 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 14 Nov 87  14:52:54 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 279905; Sat 14-Nov-87 17:52:14 ESTDate: Sat, 14 Nov 87 17:52 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: questions about CLOS [original subject: equality of structures]To: goldman@vaxa.isi.educc: COMMON-LISP@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <8711092000.AA14975@vaxa.isi.edu>Message-ID: <19871114225202.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 09 Nov 87 12:00:35 PST    From: goldman@vaxa.isi.edu    Re:  the suggestion that CLOS should subsume (by convention or otherwise)    uses of un:TYPEed defstruct types?       I presume that this takes care of the issue of EQUAL, because the CLOS    specifies the semantics of EQUAL for its class instances?  (What is the    specification, by the way?)  CLOS does not currently say anything about how the functions EQUAL, EQUALP,and EQL behave on instances of standard classes (you can read the last fourwords as equivalent to "user-defined objects").  It also doesn't sayanything about the type-specific equality functions CHAR-EQUAL,CHAR-NOT-EQUAL, TREE-EQUAL, STRING-EQUAL, and STRING-NOT-EQUAL, northe 6 type-specific = and /= functions.It would fit the structure of CLOS to say that EQUAL and EQUALP will beexpanded to generic functions whose behavior can be extended by definingmethods.  I don't think we would want to allow extending EQL or thetype-specific functions, since CLOS does not claim to be so powerful asto allow you to create new types of numbers, characters, or strings.Extending EQ would not make any sense, of course.I suspect the reason CLOS currently shys away from EQUAL and EQUALP isthat the equality predicates in Common Lisp are clearly not very wellchosen and beg for a lot of cleaning up based on a better theory of whatwe want.  To give just one example, it's peculiar that comparing arrayselement-by-element has been bundled together with ignoring alphabetic case.It's probably better to wait for Common Lisp to get its act togetherbefore extending CLOS into this area; clearly, equality methods can beadded later to the standard or to an individual implementation withoutany incompatibilities, so there's no rush.A possible additional reason is that CLOS does not deal terribly wellwith symmetric two-argument functions such as EQUAL.  It's possible tospecialize them, but you usually have to define a lot of seeminglyextraneous methods, since the generic function dispatch mechanism hasno concept of commutativity nor of type translation.				 But I would be loathe to replace my un:TYPEed    defstructs with DEFCLASSes if I gave up substantial efficiency when I only    wanted the limited power provided by the "record structure" semantics.    Are there enough declarations available in CLOS so that I could get    my compiled accesses to slots of such instances down to the equivalent    of an array element reference?As an implementation-independent language specification, CLOS does notand cannot directly address this issue.  However, it's clear what wouldgenerally need to be declared to allow implementations to do somethinglike that, although you would have to look at each individual implementationto see whether it was faster or slower than arrays with declarations;you might even find an implementation where slot access was faster thanarray access even without declarations.  Basically what you need to declareis that the class cannot be redefined or subclassed.  Some members of theCLOS subcommittee volunteered to propose declaration names and syntaxesto allow for this type of optimization, but they haven't finished yet.However, it is intended that most CLOS implementations either be veryefficient or have a way to make them very efficient through declarations.*start*17725 00024 US Date: 20 Nov 87 12:45 PSTFrom: Masinter.paSubject: Issue: EQUAL-STRUCTURETo: ALarson@HI-MULTICS.Arpacc: edsel!jonl@labrea.stanford.edu, Okuno@SUMEX-AIM.STANFORD.EDU, goldman@vaxa.isi.EDULINE-FOLD: NOcc: MasinterThe "cleanup" issue title is EQUAL-STRUCTURE. The issue is: what do EQUAL, EQUALP and friends do on structures defined with DEFSTRUCT. Pay particular attention to Moon's mention of CLOS; I think that any proposal forwarded should describe the situation both in terms of CLOS and also in non-CLOS terms.Enclosed is a copy of the proposal format and the mail that I have collected on this issue.  Format for proposals to the cleanup committee (Version 13)                    November 20, 1987Replace the text below in >> double inverted angle-brackets <<. Bebrief; leave testimonials and personal opinions to the discussion at theend. Be complete; do not expect someone else to fix or redesign parts.Spell out names (e.g., Masinter rather than LMM) and upper-case all Lispsymbols (DEFUN rather than Defun). I like it better if you write in thethird person rather than first.Issue:         >>A short descriptive label, which starts with a name               which occurs in the index of CLtL, and be a suitable               symbol in the Common Lisp style, e.g., CDR-TERMINATION.<<References:    >>The pages of CLtL which describe the feature being               discussed, and other references, including other               related issues.<<Category:      >>One or more of:               CLARIFICATION -- proposal to resolve an ambiguity or case               of under-specified situation in CLtL, where this               ambiguity interferes with portability of code.               CHANGE -- proposal for an incompatible change.               ADDITION -- proposal for a compatible extension<<Edit history:  >>Author and date of submission (version 1), and author               and date of subsequent versions.<<Problem description:>>Describe the problem being addressed -- why is the current situationunclear or unsatisfactory? Avoid describing the proposal here or arguingfor its adoption. <<Proposal (>>issue-label:proposal-label<<): >> Describe as precisely aspossible what you are proposing.  Ideally, this should take the form oftext that could be dropped into the new specification document.Proposals should be for changes to Common Lisp, rather than changes toCLtL.  If necessary, propose a set of labelled alternatives here, ratherthan a single proposal. Each proposal must be a complete design; do notleave out details.  Avoid arguing for the proposal here, just describeit.<<Test Cases/Examples:>> Examples are samples of Common Lisp code that illustrates the issue.along with explanatory text.Test Cases are simple stand-alone expressions which are valid anddo not signal an error if the proposal is adhered to. (Use ASSERTif you need.)<<Rationale:>> A one or two sentence summary of the arguments that follow. <<Current practice:>>Do some/many/no Common Lisp implementations already work this way?Survey independent Common Lisp implementations - preferably three ormore.<<Cost to Implementors:>>What is the cost to implementors of adopting the proposal?  How muchimplementation effort is required?  Is public-domain code available? Forpervasive changes, can the conversion be automated?<<Cost to Users:>>For incompatible changes, what is the cost to users of convertingexisting user code?  To what extent can the process be automated? How?<<Cost of non-adoption:>>How serious is it if nothing is done? <<Benefits:>>What is better if the proposal is adopted? How serious is the problemif just left as it is? <<Esthetics:>>How does this proposal affect the simplicity of the language, ease oflearning, etc. You can spell it aesthetics if you like. <<Discussion:>> Additional arguments, discussions, endorsements, testimonials, etc.should go here. A blow-by-blow account of debates is not necessary. <<Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Nov 87 16:53From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: Hiroshi "Gitchang" Okuno's message of Sun, 8 Nov 87 14:26:27 PST <12349062523.26.OKUNO@SUMEX-AIM.STASubject: equality of structures, or *default-structure-type*To: labrea!Okuno%SUMEX%labrea.stanford:EDU:Xeroxcc: labrea!common-lisp%SAIL%labrea.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: labrea!Okuno%SUMEX@labrea.stanford.eduCc: labrea!common-lisp%SAIL@labrea.stanford.eduIn-Reply-To: Hiroshi "Gitchang" Okuno's message of Sun, 8 Nov 87 14:26:27 PST <12349062523.26.OKUNO@SUMEX-AIM.STANFORD.EDU>Subject: equality of structures, or *default-structure-type*Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 16:52:31 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 8 Nov 87  16:16:08 PSTReceived: by labrea.stanford.edu; Sun, 8 Nov 87 16:14:28 PSTReceived: from bhopal.lucid.com by edsel id AA16787g; Sun, 8 Nov 87 16:08:10 PSTReceived: by bhopal id AA13142g; Sun, 8 Nov 87 16:07:52 PSTOriginal-Date: Sun, 8 Nov 87 16:07:52 PSTMessage-Id: <8711090007.AA13142@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVA defstruct not given the :type option is the one area where CL's defstructtries to go beyond the "record structure" semantics, and enter the area oflimited "object based" programming.  It's somewhat ironic that only whenyou don't specify :type do the elements of the defined structure becomefull-fledged members of the common-lisp type system; i.e., they areidentifiably of of the defined type rather than the implementational type.Many persons have criticized this merger of capabilities in defstruct.  Themost popular direction, however, is not to "fix" the problem with non-:typestructures, but to hail the coming of the Common Lisp Object System, whichwill do a much grander job of providing object-oriented capabilities.   All the interesting properties of defaultly-typed defstructs will be subsumedby defclass.  Then, the use of defstruct could be, conventionally, limited to :type structures.-- JonL --     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Nov 87 15:06From: Okuno%SUMEX-AIM.STANFORD:EDU:XeroxSubject: equality of structures, or *default-structure-type*To: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Hiroshi "Gitchang" Okuno <Okuno@SUMEX-AIM.STANFORD.EDU>Subject: equality of structures, or *default-structure-type*To: common-lisp@SAIL.STANFORD.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 15:06:30 PSTReceived: from SUMEX-AIM.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 8 Nov 87  14:26:38 PSTOriginal-Date: Sun, 8 Nov 87 14:26:27 PSTOrganization: Knowledge Systems Laboratory, CSD, Stanford UniversityGroup: Heuristic Programming ProjectProject: Advanced Architectures ProjectAddress: 701 Welch Road, Building C, Palo Alto, CA 94304-1703Phone: +1 (415)725-4854Message-ID: <12349062523.26.OKUNO@SUMEX-AIM.STANFORD.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIf the :type option is not specified in defstruct, the structure isrepresented in an implementation-dependent manner (CLtL p.314).However, this implementation-dependentness introduces the ambiguity ofequality of structures.  Suppose that one implementation uses an arrayfor the default representation of a structure, while the otherimplementation uses a list for it (of course, it's a sillyimplementation).  The equality of structures may differ on these twoimplementations, since equality of array is checked by the 'eq'nessand that of list is checked by the equality of corresponding elements(CLtL p.80).  For example,		(defstruct foo a b c)default :type = :array	(equal (make-foo) (make-foo)) ===> nildefault :type = :list	(equal (make-foo) (make-foo)) ===> tThis observation proves that we need introduce a new global variable,say *default-structure-type*, in order to raise the portability ofCOMMON Lisp programs.Since I cannot find any messages on this matter in the archivedfiles at sumex, I post this message.- Gitchang --------     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  9 Nov 87 12:48From: goldman%vaxa.isi:EDU:XeroxSubject: equality of structuresTo: COMMON-LISP%sail.stanford:EDU:Xeroxcc: goldman%vaxa.isi:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 NOV 87 12:48:28 PSTReceived: from VAXA.ISI.EDU by SAIL.STANFORD.EDU with TCP; 9 Nov 87  11:58:55 PSTPosted-Date: Mon, 09 Nov 87 11:59:25 PSTMessage-Id: <8711091959.AA14960@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.54/5.51)	id AA14960; Mon, 9 Nov 87 11:59:49 PSTOriginal-Date: Mon, 09 Nov 87 11:59:25 PSTFrom the standpoint of writing TRANSFORMATIONs on common lisp programs,it would be preferable to have EQUAL well defined for structureinstances for which no :type (too bad that wasn't called :implementation)is specified.  Personally, I would like  the definition should be:  two instances are EQL iff they are EQ  two instances are EQUAL iff    a) they are instances of the same most specific structure type, and    b) the contents of all corresponding fields are EQUAL.[This is like the current definition of EQUALP for un:TYPEed structures,at least if you believe structures are objects that have components-- see CLtL's definition  of EQUALP.][However, I suspect that most implementors would rather have it definedlike to have these objects be EQUAL iff they are EQL, so they can be implemented as arrays.]This entire problem, I am sure, stems from the more fundamental "problem"that EQUAL is defined to recur into components of lists, but NOT of arrays,-- except for STRINGs and BIT-VECTORs -- a decision that could ONLY have itsroots in implementation considerations. An alternative  suggested by the earlier message, a *default-structure-type* variable, implies making the definition ofEQUAL implementation specific.  But I think it carried along with it animplication that implementations are limitied to defaulting theimplementation of such structure instancesto the equivalent of what results from either :ARRAY or :LIST, and to defaulting the implementation of ALL instances the same way.Re:  the suggestion that CLOS should subsume (by convention or otherwise)uses of un:TYPEed defstruct types?   I presume that this takes care of the issue of EQUAL, because the CLOSspecifies the semantics of EQUAL for its class instances?  (What is thespecification, by the way?)  But I would be loathe to replace my un:TYPEeddefstructs with DEFCLASSes if I gave up substantial efficiency when I onlywanted the limited power provided by the "record structure" semantics.Are there enough declarations available in CLOS so that I could getmy compiled accesses to slots of such instances down to the equivalentof an array element reference?Neil     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  9 Nov 87 14:58From: barmar%Think:COM:XeroxSubject: equality of structures, or *default-structure-type*In-Reply-to: <12349062523.26.OKUNO@SUMEX-AIM.STANFORD.EDU>To: Okuno%sumex-aim.stanford:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: equality of structures, or *default-structure-type*To: "Hiroshi \"Gitchang\" Okuno" <Okuno@sumex-aim.stanford.edu>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <12349062523.26.OKUNO@SUMEX-AIM.STANFORD.EDU>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 NOV 87 14:57:55 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 9 Nov 87  14:09:56 PSTReturn-Path: <@occam.think.com:barmar@Think.COM>Received: from pozzo ([192.5.104.209]) by Think.COM; Mon, 9 Nov 87 11:36:06 ESTReceived: from OCCAM.THINK.COM (occam.think.com.ARPA) by pozzo; Mon, 9 Nov 87 11:31:59 estOriginal-Date: Mon, 9 Nov 87 11:34 ESTMessage-Id: <871109113400.5.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI believe the intent, but not the letter, of the specification was thatwhen you don't specify the type explicitly, an implementation-dependenttype that is distinguishable from all other types would be used.  Theactual implementation may be as some other primitive type (list, array)but the object will be marked in some way that it can be recognized as adefstruct-created structure.I believe that this interpretation is necessary in order to cause thestructure's print-function to be invoked.  If structures weren'tdistinguishable from other data types then they would print as thosedata types print, rather than using the #S notation (or the:PRINT-FUNCTION).Therefore, the definition of EQUAL could be extended to explicitlyspecify its interpretation given two structures of the same type.                                                barmar     ----- Next Message -----Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 15:54:27 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 14 Nov 87  14:52:54 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 279905; Sat 14-Nov-87 17:52:14 ESTDate: Sat, 14 Nov 87 17:52 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: questions about CLOS [original subject: equality of structures]To: goldman@vaxa.isi.educc: COMMON-LISP@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <8711092000.AA14975@vaxa.isi.edu>Message-ID: <19871114225202.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 09 Nov 87 12:00:35 PST    From: goldman@vaxa.isi.edu    Re:  the suggestion that CLOS should subsume (by convention or otherwise)    uses of un:TYPEed defstruct types?       I presume that this takes care of the issue of EQUAL, because the CLOS    specifies the semantics of EQUAL for its class instances?  (What is the    specification, by the way?)  CLOS does not currently say anything about how the functions EQUAL, EQUALP,and EQL behave on instances of standard classes (you can read the last fourwords as equivalent to "user-defined objects").  It also doesn't sayanything about the type-specific equality functions CHAR-EQUAL,CHAR-NOT-EQUAL, TREE-EQUAL, STRING-EQUAL, and STRING-NOT-EQUAL, northe 6 type-specific = and /= functions.It would fit the structure of CLOS to say that EQUAL and EQUALP will beexpanded to generic functions whose behavior can be extended by definingmethods.  I don't think we would want to allow extending EQL or thetype-specific functions, since CLOS does not claim to be so powerful asto allow you to create new types of numbers, characters, or strings.Extending EQ would not make any sense, of course.I suspect the reason CLOS currently shys away from EQUAL and EQUALP isthat the equality predicates in Common Lisp are clearly not very wellchosen and beg for a lot of cleaning up based on a better theory of whatwe want.  To give just one example, it's peculiar that comparing arrayselement-by-element has been bundled together with ignoring alphabetic case.It's probably better to wait for Common Lisp to get its act togetherbefore extending CLOS into this area; clearly, equality methods can beadded later to the standard or to an individual implementation withoutany incompatibilities, so there's no rush.A possible additional reason is that CLOS does not deal terribly wellwith symmetric two-argument functions such as EQUAL.  It's possible tospecialize them, but you usually have to define a lot of seeminglyextraneous methods, since the generic function dispatch mechanism hasno concept of commutativity nor of type translation.				 But I would be loathe to replace my un:TYPEed    defstructs with DEFCLASSes if I gave up substantial efficiency when I only    wanted the limited power provided by the "record structure" semantics.    Are there enough declarations available in CLOS so that I could get    my compiled accesses to slots of such instances down to the equivalent    of an array element reference?As an implementation-independent language specification, CLOS does notand cannot directly address this issue.  However, it's clear what wouldgenerally need to be declared to allow implementations to do somethinglike that, although you would have to look at each individual implementationto see whether it was faster or slower than arrays with declarations;you might even find an implementation where slot access was faster thanarray access even without declarations.  Basically what you need to declareis that the class cannot be redefined or subclassed.  Some members of theCLOS subcommittee volunteered to propose declaration names and syntaxesto allow for this type of optimization, but they haven't finished yet.However, it is intended that most CLOS implementations either be veryefficient or have a way to make them very efficient through declarations.     ----- End Forwarded Messages -----*start*06435 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 18 MAR 88 16:35:52 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 18 Mar 88  14:39:05 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 366054; Fri 18-Mar-88 17:39:30 ESTDate: Fri, 18 Mar 88 17:39 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880318173922.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>This is somewhat sketchy, but I thought I'd get it on the table as is and peoplecould flesh it out as the discussion evolves... -kmp-----Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CHANGEEdit history: 18-Mar-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:RADICAL):  Remove EQUAL and EQUALP from the language. (Naturally, they could be retained  as implementation-dependent extensions.)  Rationale:   The name "EQUAL" suggests something very generic. It conjures in the mind   of the naive user the notion that there is a single, uniquely selected   predicate which is always good for equality testing. In fact, there is a   large space of useful equality predicates, each good for different   applications, and the choice of the current definition of EQUAL is   exceedingly arbitrary. Although the function chosen is sometimes quite   useful and some work is occassionally saved by having it be defaultly   available, confusion frequently results from its presence. Users for whom   the operator is not appropriate are inclined to describe it as broken,   rather than to recognize that it does a useful thing but that the   application they have does not call for that useful thing. The thing which   would be useful to them would not be useful in other situations. There is   simply no unique solution. The absence of the operator EQUAL would cause   people to think explicitly about what kind of equivalence is appropriate   to their application, and to write something better suited to that   application.   As an aside, this same notion of uniqueness carries over to COPY. People   have been observed to assert that a generic COPY function should be   present for copying arbitrary objects. A single COPY function is not   provided because there are many kinds of copying and no single function is   entitled to the generic name COPY. This argument does not sit well with   programmers who assert that if this is true, there should be no unique   EQUAL operator. We could solve that problem two ways -- one by creating a   COPY operator; another by eliminating the embarrassment of EQUAL and   friends.Proposal (EQUAL-STRUCTURE:STATUS-QUO):  Leave things as is.  Rationale:   The intent of a structure is different than the intent of an array. A   list is an anonymous entity which makes sense only in terms of its   length and contents, and is not rightly compared just by object identity   (EQ); a structure, on the other hand, has an identity of its own and is   appropriately compared with EQ.Proposal (EQUAL-STRUCTURE:DESCEND):  Change EQUAL and EQUALP to descend structure slots.  Rationale:   A structure is a container and, like many other containers in Lisp,   should be compared by recursing into the contents of that container.Proposal (EQUAL-STRUCTURE:ADD-KEYWORDS):  Add :TEST and :TEST-NOT keywords to EQUAL saying what comparison operator  to use at the leaves.  [This will need more details if anyone decides they want to push this line   of reasoning. I don't claim to have done an adqeuate job of laying the   issue out, though I could imagine someone doing so. -kmp]  Rationale:   There's ample precedent for resolving sticky situations like this in   Common Lisp by just adding a keyword option. :-)Proposal (EQUAL-STRUCTURE:ADD-OPERATOR)  Introduce new operator(s) like EQUAL (and/or EQUALP) which descends  structures.  Rationale:   If people don't want to make EQUAL more complicated, but still like   the idea of a keyword-driven EQUAL, this is the only way to get it.Current Practice:  There is no particular ambiguity in CLtL right now, so presumably  everyone agrees. The only question is whether what CLtL says is  sufficiently useful in practice.Cost to Implementors:  The cost to implementors of most of these options is generally small.  The exception is that the ADD-KEYWORDS option may require hairy compiler  optimizations in order to get back the efficiency that a keyword would lose.Cost to Users:  Writing an EQUAL or EQUALP function which is like the one that Common Lisp  now has would not be that hard to do as a compatibility measure in case  EQUAL or EQUALP were changed or removed. So the cost to users is technically  small.Cost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  Aesthetic considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.  The ADD-KEYWORDS option will be the most controversial because some people  don't like keywords and some compiler writers will not like having to  optimize the keywords.Discussion:  Pitman strongly supports EQUAL-STRUCTURE:RADICAL as the correct choice from  a purely language design standpoint, but acknowledges that it may not  ultimately be deemed practical for pragmatic reasons.*start*02174 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 18 MAR 88 16:35:37 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 18 Mar 88  16:11:40 PSTReceived: by labrea.Stanford.EDU; Fri, 18 Mar 88 15:53:07 PSTReceived: from kent-state.lucid.com by edsel id AA08362g; Fri, 18 Mar 88 15:37:18 PSTReceived: by kent-state id AA03234g; Fri, 18 Mar 88 15:46:22 PSTDate: Fri, 18 Mar 88 15:46:22 PSTFrom: Eric Benson <edsel!eb@labrea.Stanford.EDU>Message-Id: <8803182346.AA03234@kent-state.lucid.com>To: KMP@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Fri, 18 Mar 88 17:39 EST <880318173922.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 1)Here's one more to add to your list.  Kent, I will merge this andcreate Version 2 if you like, otherwise I expect that you will includethese with any other changes you might have.  (I actually preferEQUAL-STRUCTURE:RADICAL myself, but I'm trying to be practical.)Proposal (EQUAL-STRUCTURE:CHANGE-EQUALP):  Change EQUALP so that it descends structures, is case sensitive, and  never considers numbers of different types to be equal.  Rationale:   Several users have independently inquired why there is no predicate   with this definition in Common Lisp.  Also, use of EQUALP is not   widespread.  Rather than invent a new name for a predicate, it   would be preferable to take an existing name which is not being   heavily used and give it a more useful definition.   It would also be useful to have EQUALP type hashtables, given this   new definition for EQUALP.   EQUALP did not exist in Lisp dialects preceding Common Lisp.  There   are few programs that make use of EQUALP and only those depending   on case insensitivity or numeric coercion (or lack of structure   descending) would be affected.Discussion:  Eric Benson supports EQUAL-STRUCTURE:CHANGE-EQUALP.  He has never  used EQUALP in a "serious" program, but in every "casual" use he has  wished that it was case sensitive.*start*03748 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 18 MAR 88 23:23:12 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 18 Mar 88  21:28:27 PSTReceived: by labrea.Stanford.EDU; Fri, 18 Mar 88 21:28:55 PSTReceived: from bhopal.lucid.com by edsel id AA09699g; Fri, 18 Mar 88 21:14:33 PSTReceived: by bhopal id AA24439g; Fri, 18 Mar 88 21:21:51 PSTDate: Fri, 18 Mar 88 21:21:51 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8803190521.AA24439@bhopal.lucid.com>To: KMP@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Fri, 18 Mar 88 17:39 EST <880318173922.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 1)Generally ok write-up of the issues.  You left out the option of addinga jillion-skillion new functions -- one for each conceivable kind of equivalence relation between s-expressions.  But that's ok; I want tofocus on just one of your proposals.re: Proposal (EQUAL-STRUCTURE:DESCEND):    Change EQUAL and EQUALP to descend structure slots.EQUALP is already documented to descend structures (CLtL, p81).  So thisproposal should just say "Change EQUAL ...".Had all the negative arguments against this particular proposal -- the one you call (EQUAL-STRUCTURE:DESCEND) -- been thought of 6 years ago, CL couldnot even have an EQUALP function.  The logical conclusion of these "technical details" arguments is that EQUAL cannot be defined either.These arguments go roughly as follows:   (1) The equivalence which EQUAL implements is not graph-isomorphism --       which *is* uniquely defined -- but rather an ill-defined one       making reference to the underspecified notion of "printing".       Attempts to make it more precise are merely arbitrary.   (2) EQUAL is not a total function since it is permitted to run amok        on circular structures.  In fact, it is much more "likely" that        defstruct instances will contain ultimately circular links than        that cons cells will; hence one will "probably" lose more much        often if EQUAL were to descend structures.The more "wizard", or "theorist" one is, the more compelling the abovearguments seem.  On the other hand, the more a "user" one is, the morelikely he will argue as follows:  I've used the EQUAL function for over 15 years, and have almost never  been dissatisfied with it, as the Doctors of Technology say I should be;   and every instance of dissatisfaction was due to its failue to descend   through pointer vectors.  I keep my house in order, and know exactly  how my data pyramids are built up; so why should I be punished just  because some Conehead somewhere got lost playing around with his  Klein bottles and Moebius strips?All the problems alleged for EQUALP's descent into structures also applyto EQUAL's descent into lists; it's only a matter of probabilities.  Hence,I don't believe this issue can be settled by technical discussion.  The only non-time-wasting effort I can see to do from now on is to look for some way to present our dilemma to a broad "user" community.  We could try to tell them, in cursory terms and few words, of the technical arguments that show EQUAL (and EQUALP) to be ill-behaved functions.  Then let them decide (by straw vote?) if the extra functionality provided by this proposalis worth the extra risk.Related Issues:  -- Are DEFSTRUCT-defined types and CONS, ARRAY, HASH-TABLE, PACKAGE,      READTABLE, STREAM, etc.  pairwise disjoint?  -- Will CLOS require EQUAL to be "generic"?  Also, what about COPY?-- JonL --*start*07220 00024 USfDate:  8 Jun 88 17:47 PDTFrom: Masinter.paSubject: Issue: EQUAL-STRUCTURE (Version 2)TO: x3j13@Sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterLINE-FOLD: NOThis issue is a DRAFT; I hope that discussion at X3J13 can help the cleanup committee focus on the most popular options.Status:	DRAFT - for discussion at June X3J13Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CHANGEEdit history: 18-Mar-88, Version 1 by Pitman	 8-Jun-88, Version 2 by Masinter (add Benson's proposal)Problem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:RADICAL):  Remove EQUAL and EQUALP from the language. (Naturally, they could be retained  as implementation-dependent extensions.)  Rationale:   The name "EQUAL" suggests something very generic. It conjures in the mind   of the naive user the notion that there is a single, uniquely selected   predicate which is always good for equality testing. In fact, there is a   large space of useful equality predicates, each good for different   applications, and the choice of the current definition of EQUAL is   exceedingly arbitrary. Although the function chosen is sometimes quite   useful and some work is occassionally saved by having it be defaultly   available, confusion frequently results from its presence. Users for whom   the operator is not appropriate are inclined to describe it as broken,   rather than to recognize that it does a useful thing but that the   application they have does not call for that useful thing. The thing which   would be useful to them would not be useful in other situations. There is   simply no unique solution. The absence of the operator EQUAL would cause   people to think explicitly about what kind of equivalence is appropriate   to their application, and to write something better suited to that   application.   As an aside, this same notion of uniqueness carries over to COPY. People   have been observed to assert that a generic COPY function should be   present for copying arbitrary objects. A single COPY function is not   provided because there are many kinds of copying and no single function is   entitled to the generic name COPY. This argument does not sit well with   programmers who assert that if this is true, there should be no unique   EQUAL operator. We could solve that problem two ways -- one by creating a   COPY operator; another by eliminating the embarrassment of EQUAL and   friends.Proposal (EQUAL-STRUCTURE:STATUS-QUO):  Leave things as is.  Rationale:   The intent of a structure is different than the intent of an array. A   list is an anonymous entity which makes sense only in terms of its   length and contents, and is not rightly compared just by object identity   (EQ); a structure, on the other hand, has an identity of its own and is   appropriately compared with EQ.Proposal (EQUAL-STRUCTURE:DESCEND):  Change EQUAL and EQUALP to descend structure slots.  Rationale:   A structure is a container and, like many other containers in Lisp,   should be compared by recursing into the contents of that container.Proposal (EQUAL-STRUCTURE:ADD-KEYWORDS):  Add :TEST and :TEST-NOT keywords to EQUAL saying what comparison operator  to use at the leaves.  [This will need more details if anyone decides they want to push this line   of reasoning. I don't claim to have done an adqeuate job of laying the   issue out, though I could imagine someone doing so. -kmp]  Rationale:   There's ample precedent for resolving sticky situations like this in   Common Lisp by just adding a keyword option. :-)Proposal (EQUAL-STRUCTURE:ADD-OPERATOR)  Introduce new operator(s) like EQUAL (and/or EQUALP) which descends  structures.  Rationale:   If people don't want to make EQUAL more complicated, but still like   the idea of a keyword-driven EQUAL, this is the only way to get it.Proposal (EQUAL-STRUCTURE:CHANGE-EQUALP):  Change EQUALP so that it descends structures, is case sensitive, and  never considers numbers of different types to be equal.  Rationale:   Several users have independently inquired why there is no predicate   with this definition in Common Lisp.  Also, use of EQUALP is not   widespread.  Rather than invent a new name for a predicate, it   would be preferable to take an existing name which is not being   heavily used and give it a more useful definition.   It would also be useful to have EQUALP type hashtables, given this   new definition for EQUALP.   EQUALP did not exist in Lisp dialects preceding Common Lisp.  There   are few programs that make use of EQUALP and only those depending   on case insensitivity or numeric coercion (or lack of structure   descending) would be affected.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Current Practice:  There is no particular ambiguity in CLtL right now, so presumably  everyone agrees. The only question is whether what CLtL says is  sufficiently useful in practice.Cost to Implementors:  The cost to implementors of most of these options is generally small.  The exception is that the ADD-KEYWORDS option may require hairy compiler  optimizations in order to get back the efficiency that a keyword would lose.Cost to Users:  Writing an EQUAL or EQUALP function which is like the one that Common Lisp  now has would not be that hard to do as a compatibility measure in case  EQUAL or EQUALP were changed or removed. So the cost to users is technically  small.Cost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  Aesthetic considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.  The ADD-KEYWORDS option will be the most controversial because some people  don't like keywords and some compiler writers will not like having to  optimize the keywords.Discussion:  Pitman strongly supports EQUAL-STRUCTURE:RADICAL as the correct choice from  a purely language design standpoint, but acknowledges that it may not  ultimately be deemed practical for pragmatic reasons.  Eric Benson supports EQUAL-STRUCTURE:CHANGE-EQUALP.  He has never  used EQUALP in a "serious" program, but in every "casual" use he has  wished that it was case sensitive.        TITAN 
          
TIMESROMAN 
          3             z*start*04087 00024 USaReturn-Path: <edsel!jonl@labrea.stanford.edu>Received: from labrea.stanford.edu by Xerox.COM ; 09 JUN 88 21:20:53 PDTReceived: by labrea.stanford.edu; Thu, 9 Jun 88 21:19:39 PDTReceived: from bhopal.lucid.com by edsel id AA17893g; Thu, 9 Jun 88 21:10:37 PDTReceived: by bhopal id AA26479g; Thu, 9 Jun 88 21:09:17 PDTDate: Thu, 9 Jun 88 21:09:17 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8806100409.AA26479@bhopal.lucid.com>To: masinter.paCc: x3j13@sail.stanford.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: Masinter.pa@Xerox.COM's message of 8 Jun 88 17:47 PDT <880608-174735-3615@Xerox>Subject: Issue: EQUAL-STRUCTURE (Version 2)I thought you were going to incorporate my comments into this issue, whichI sent in reply to its first presentation:  Date: Fri, 18 Mar 88 21:21:51 PST  From: Jon L White <edsel!jonl@labrea.Stanford.EDU>  To: KMP@stony-brook.scrc.symbolics.com  Cc: CL-Cleanup@sail.stanford.edu  In-Reply-To: Kent M Pitman's message of Fri, 18 Mar 88 17:39 EST <880318173922.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>  Subject: Issue: EQUAL-STRUCTURE (Version 1)  Generally ok write-up of the issues.  You left out the option of adding  a jillion-skillion new functions -- one for each conceivable kind of   equivalence relation between s-expressions.  But that's ok; I want to  focus on just one of your proposals.  re: Proposal (EQUAL-STRUCTURE:DESCEND):      Change EQUAL and EQUALP to descend structure slots.  EQUALP is already documented to descend structures (CLtL, p81).  So this  proposal should just say "Change EQUAL ...".  Had all the negative arguments against this particular proposal -- the one   you call (EQUAL-STRUCTURE:DESCEND) -- been thought of 6 years ago, CL could  not even have an EQUALP function.  The logical conclusion of these   "technical details" arguments is that EQUAL cannot be defined either.  These arguments go roughly as follows:     (1) The equivalence which EQUAL implements is not graph-isomorphism --	 which *is* uniquely defined -- but rather an ill-defined one	 making reference to the underspecified notion of "printing".	 Attempts to make it more precise are merely arbitrary.     (2) EQUAL is not a total function since it is permitted to run amok 	 on circular structures.  In fact, it is much more "likely" that 	 defstruct instances will contain ultimately circular links than 	 that cons cells will; hence one will "probably" lose more much 	 often if EQUAL were to descend structures.  The more "wizard", or "theorist" one is, the more compelling the above  arguments seem.  On the other hand, the more a "user" one is, the more  likely he will argue as follows:    I've used the EQUAL function for over 15 years, and have almost never    been dissatisfied with it, as the Doctors of Technology say I should be;     and every instance of dissatisfaction was due to its failue to descend     through pointer vectors.  I keep my house in order, and know exactly    how my data pyramids are built up; so why should I be punished just    because some Conehead somewhere got lost playing around with his    Klein bottles and Moebius strips?  All the problems alleged for EQUALP's descent into structures also apply  to EQUAL's descent into lists; it's only a matter of probabilities.  Hence,  I don't believe this issue can be settled by technical discussion.    The only non-time-wasting effort I can see to do from now on is to look for   some way to present our dilemma to a broad "user" community.  We could try   to tell them, in cursory terms and few words, of the technical arguments   that show EQUAL (and EQUALP) to be ill-behaved functions.  Then let them   decide (by straw vote?) if the extra functionality provided by this proposal  is worth the extra risk.  Related Issues:    -- Are DEFSTRUCT-defined types and CONS, ARRAY, HASH-TABLE, PACKAGE,        READTABLE, STREAM, etc.  pairwise disjoint?    -- Will CLOS require EQUAL to be "generic"?  Also, what about COPY?  -- JonL --*start*00734 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 JUN 88 00:01:20 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 10 Jun 88  00:00:21 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 09 JUN 88 23:59:25 PDTDate: 9 Jun 88 23:59 PDTFrom: Masinter.paSubject: Re: Issue: EQUAL-STRUCTURE (Version 2)In-reply-to: Jon L White <edsel!jonl@labrea.stanford.edu>'s message of Thu, 9 Jun 88 21:09:17 PDTTo: edsel!jonl@labrea.stanford.educc: cl-cleanup@sail.stanford.eduMessage-ID: <880609-235925-6154@Xerox>In this case, I had misfiled your message and did not see it when I generatedversion 2. I'm sorry.*start*04031 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Jun 88 12:23From: edsel!jlm%labrea.stanford:EDU:XeroxIn-Reply-to: "Robert W. Kerns"'s message of Mon, 13 Jun 88 02:05:15 EDT <396357.880613.RWK@AI.AI.MIT.EDU>Subject: EQUALTo: RWK%ai.ai.mit:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jim McDonald <edsel!jlm@labrea.stanford.edu>To: RWK@ai.ai.mit.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: "Robert W. Kerns"'s message of Mon, 13 Jun 88 02:05:15 EDT <396357.880613.RWK@AI.AI.MIT.EDU>Subject: EQUALReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 JUN 88 12:24:09 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 13 Jun 88  11:52:41 PDTReceived: by labrea.stanford.edu; Mon, 13 Jun 88 11:50:44 PDTReceived: from bhopal.lucid.com by edsel id AA02227g; Mon, 13 Jun 88 11:37:35 PDTReceived: by bhopal id AA10559g; Mon, 13 Jun 88 11:36:30 PDTOriginal-Date: Mon, 13 Jun 88 11:36:30 PDTMessage-Id: <8806131836.AA10559@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV   While this all sounds very nice, I'm afraid you're engaging in   a bit of historical revisionism.After hitting <return> I had second thoughts along those lines, but third thoughts removed them.  (Now I'm afraid to hit return again. :-)   Originally, LISP didn't have all these nice hairy datatypes.   Those of us who were there (Not me!) can tell about what McCarthy   wrought, but I know I've seen Lisp's without arrays at all.  No fair.  That's an argument for my position.                                                                I know   people have been using EQUAL to compare data more often than to compare   code for a very long time.One of the tenants of evolution is that rather small advantages can drivenatural selection.  If EQUAL and EQUAL' are of comparable utility forcomparing data, but EQUAL is much better for code, then EQUAL willprevail, even if 99% of the comparisons are for data.     In fact, EQUAL doesn't work on code, plain and simple.  To compare   code, you must first recognize that it is not computable to compare   two functions which contain quoted data, unless that quoted data is   EQ.  You also have to place constraints on macros to not be pathological   (i.e. sick).But EQUAL *does* work on code.  E.g., I might have a rewrite system inmy compiler that makes all sorts of modifications and then checks tosee if the result is EQUAL.  If not, it goes around again.  Since thecode analysis is using CAR, CDR, CONS, LIST, etc. and never copyingarrays or other objects, EQUAL is precisely the right test. Textbook arguments and pathological examples miss the historical pointI was making.  My sense is that the early implementers were pragmaticenough not to fall into the trap of avoiding something useful becauseit was not (and could never be) perfect.   In short, what EQUAL is good for is comparing "old-style" data   (that is, data structures like are used in such venerable programs   as Macsyma -- and there are some exceptions there, too).I would include "old-style" and most "new-style" code.  Another way ofphrasing my argument is that "old-style" code and data were so similaras to blur the uses of EQUAL.  "New-style" data has evolved more, sodiscrepencies are emerging between the uses.   I do think it would be reasonable to define an extremely limited set   of new predicates.  I would suggest limiting it to two new ones that   do the two pieces of EQUALP -- descend other structures, and merge   case in strings and characters.I agree with the focus, but probably not the details.   I would strongly discourage any attempt to "solve the problem of   comparisons", on the grounds that it will require more hair, additions   to the language, and discussion than it could possibly be worth.Agreed!  jlm*start*03575 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Jun 88 10:39From: jrose%Sun:COM:XeroxIn-Reply-to: Jim McDonald's message of Fri, 10 Jun 88 18:27:18 PDT <8806110127.AA03445@bhopal.lucid.com>Subject: EQUALTo: edsel!jlm%labrea.stanford:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: jrose@Sun.COM (John Rose)To: edsel!jlm@labrea.stanford.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: Jim McDonald's message of Fri, 10 Jun 88 18:27:18 PDT <8806110127.AA03445@bhopal.lucid.com>Subject: EQUALReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 JUN 88 10:39:20 PDTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 13 Jun 88  10:04:32 PDTReceived: from snail.sun.com by Sun.COM (4.0/SMI-4.0)	id AA22912; Mon, 13 Jun 88 10:02:01 PDTReceived: from lukasiewicz.sun.com by snail.sun.com (4.0/SMI-3.2)	id AA06262; Mon, 13 Jun 88 09:58:29 PDTReceived: by lukasiewicz.sun.com (4.0/SMI-4.0)	id AA07423; Mon, 13 Jun 88 10:04:00 PDTOriginal-Date: Mon, 13 Jun 88 10:04:00 PDTMessage-Id: <8806131704.AA07423@lukasiewicz.sun.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV   Date: Fri, 10 Jun 88 18:27:18 PDT   From: Jim McDonald <edsel!jlm@labrea.stanford.edu>  ...   Thus EQUAL is (in some historical sense) defined to make it easy to do   pattern matching on code.  Since code traditionally becomes read-only,   this is more-or-less consistent with collapsing EQUAL structures to be   EQ.  I claim that the traditional explanation for EQUAL's semantics   (that EQUAL means roughly HAVE-THE-SAME-PRINT-REPRESENTATION-P) is   actually just an observation based on this more fundamental reason.   ...   Also, since people in general have some esthetic sensibilities, a   fully haired roll-your-own equality predicate seems unlikely.  ...     jlm   Date: Sat, 11 Jun 88 17:32:08 PDT   From: Jon L White <edsel!jonl@labrea.stanford.edu>   I like you analysis, and think it explains very well why EQUAL has the    peculiar semantics that it now has.   How would you feel about extending EQUAL to descend defsturct structures   and T-type arrays?  it wouldn't mess up its utility for its original    purpose, and would satisfy an enormous number of Lisp users.  Of course,    EQUAL type hashtables would work with this new definition.  ...   -- JonL --To add fuel to the fire:  Since EQUAL bears an observable relationshipto READ and WRITE, there's an obvious way to supply a "fully hairedroll-your-own equality predicate".  Add, to EQUAL, keyword argumentsanalogous to WRITE, for controlling these debatable behaviors.E.g., the people who want to compare array substructure woulduse a call like this:	(EQUAL X Y :ARRAY T)Comparison of structures would be controlled by the :STRUCTUREkeyword.  Hash tables could be handled similarly, especiallyif hash-table printing is ever made standard.  Perhaps casesensitivity in strings could be controlled by :CASE.Something should be done for numbers too.I hope there's no call for the analogous special variables,e.g., *EQUAL-ARRAY*!We might go further, by allowing the argument to :ARRAY or:STRUCTURE to be an equality predicate instead of a boolean.This would allow somewhat better control over, e.g., whichtypes of structure were to be opened up for comparison.(A DEFSTRUCT option controlling equality behavior would bemuch preferable, for reasons of modularity.)					-- John*start*04012 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 12 Jun 88 23:37From: RWK%AI.AI.MIT:EDU:XeroxSubject: EQUALIn-Reply-to: Msg of Fri 10 Jun 88 18:27:18 PDT from Jim McDonald <edsel!jlm at labrea.stanford.edu>To: edsel!jlm%LABREA.STANFORD:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: "Robert W. Kerns" <RWK@AI.AI.MIT.EDU>Subject: EQUALTo: edsel!jlm@LABREA.STANFORD.EDUcc: common-lisp@SAIL.STANFORD.EDUIn-reply-to: Msg of Fri 10 Jun 88 18:27:18 PDT from Jim McDonald <edsel!jlm at labrea.stanford.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 JUN 88 23:38:08 PDTReceived: from AI.AI.MIT.EDU by SAIL.Stanford.EDU with TCP; 12 Jun 88  23:05:19 PDTOriginal-Date: Mon, 13 Jun 88 02:05:15 EDTMessage-ID: <396357.880613.RWK@AI.AI.MIT.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 10 Jun 88 18:27:18 PDT    From: Jim McDonald <edsel!jlm at labrea.stanford.edu>    Thus EQUAL is (in some historical sense) defined to make it easy to do    pattern matching on code.  Since code traditionally becomes read-only,    this is more-or-less consistent with collapsing EQUAL structures to be    EQ.  I claim that the traditional explanation for EQUAL's semantics    (that EQUAL means roughly HAVE-THE-SAME-PRINT-REPRESENTATION-P) is    actually just an observation based on this more fundamental reason.     When people try to move beyond manipulation of code, the whole basis    for the semantics of EQUAL is removed, so the result is somewhat    chaotic. While this all sounds very nice, I'm afraid you're engaging ina bit of historical revisionism.Originally, LISP didn't have all these nice hairy datatypes.Those of us who were there (Not me!) can tell about what McCarthywrought, but I know I've seen Lisp's without arrays at all.  I knowpeople have been using EQUAL to compare data more often than to comparecode for a very long time.In fact, EQUAL doesn't work on code, plain and simple.  To comparecode, you must first recognize that it is not computable to comparetwo functions which contain quoted data, unless that quoted data isEQ.  You also have to place constraints on macros to not be pathological(i.e. sick).To illustrate a couple examples:(defvar *call-registry* (make-hash-table :test 'eq))(defvar *macro-registry* (make-hash-table :test 'eq))(defun register-macro-marker (marker)  (let ((marker (gethash *macro-registry* marker)))     (unless marker	(setf marker `',(gensym))	(setf (gethash *macro-registry* marker) marker))     marker))(defun register-call (marker result)  (push result (gethash *call-registry* marker)))(defmacro register (&whole marker)  `(register-call ,(register-macro-marker marker) ,(second marker)))(defun confound (flag)  (if flag (register '(MARKER)) (register '(MARKER))))Are the two branches of the IF equivalent?  EQUAL says yes.I leave it as an exercise for the reader to count how manyways and on how many levels those two branches differ.[I apologize in advance for any spazzes in the code; I have totype it in by hand; I don't have any way of transfering filesto or from arpanetland for testing, and editing directly on ITSdoesn't work well for me either].In short, what EQUAL is good for is comparing "old-style" data(that is, data structures like are used in such venerable programsas Macsyma -- and there are some exceptions there, too).I do think it would be reasonable to define an extremely limited setof new predicates.  I would suggest limiting it to two new ones thatdo the two pieces of EQUALP -- descend other structures, and mergecase in strings and characters.I would strongly discourage any attempt to "solve the problem ofcomparisons", on the grounds that it will require more hair, additionsto the language, and discussion than it could possibly be worth.*start*03288 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 10 Jun 88 19:11From: edsel!jlm%labrea.stanford:EDU:XeroxSubject: EQUALTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jim McDonald <edsel!jlm@labrea.stanford.edu>To: common-lisp@sail.stanford.eduSubject: EQUALReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 JUN 88 19:11:48 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 10 Jun 88  18:34:33 PDTReceived: by labrea.stanford.edu; Fri, 10 Jun 88 18:32:21 PDTReceived: from bhopal.lucid.com by edsel id AA22886g; Fri, 10 Jun 88 18:28:36 PDTReceived: by bhopal id AA03445g; Fri, 10 Jun 88 18:27:18 PDTOriginal-Date: Fri, 10 Jun 88 18:27:18 PDTMessage-Id: <8806110127.AA03445@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV>                        Look at the definition of ATOM on pg. 73 ("is>  not a CONS"); it says nothing about the notion of atominicity.  How>  sensible is it to view an array as "atomic"?I think most of the confusion with EQUAL may stem from the fact thatthe syntax of lisp programs is expressed with lists.  When modifying programs, writing macros, etc. it is critical to have primitives thatare sensitive to the components of your code, which effectively meanshaving primitives that are sensitive to the components of lists.[Thus, to answer the question posed above, when transforming a lispprogram, arrays are atomic since they express no syntactic controlinformation.]  There is no comparable historical reason for similaraccess to the contents of strings, arrays, structures, etc.  Thus EQUAL is (in some historical sense) defined to make it easy to dopattern matching on code.  Since code traditionally becomes read-only,this is more-or-less consistent with collapsing EQUAL structures to beEQ.  I claim that the traditional explanation for EQUAL's semantics(that EQUAL means roughly HAVE-THE-SAME-PRINT-REPRESENTATION-P) isactually just an observation based on this more fundamental reason. When people try to move beyond manipulation of code, the whole basisfor the semantics of EQUAL is removed, so the result is somewhatchaotic. Overall, I'll argue that you must first decide what you are trying todo (transform code, manipulate databases, build parse trees, etc.)before you can decide what you want of your equality predicates. Since Common Lisp presumably is not dedicated to any particularapplication (except that code transformations should be supported),I'm pessimistic that people will ever agree on simple semantics.Also, since people in general have some esthetic sensibilities, afully haired roll-your-own equality predicate seems unlikely.Since code transformation is common to almost all lisp endeavors,EQUAL and friends should first be tested for usefulness in thatcontext.  Then, if someone can define another similar class ofendeavors, perhaps another set of predicates can be defined to capturethe semantics needed there.  So far, I have seen no coherentdescription of generic data transformations, let alone one that wouldwarrant modification of the language.  jlm*start*01947 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Jun 88 18:05From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: Jim McDonald's message of Fri, 10 Jun 88 18:27:18 PDT <8806110127.AA03445@bhopal.lucid.com>Subject: EQUALTo: edsel!jlm%labrea.stanford:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: edsel!jlm@labrea.stanford.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: Jim McDonald's message of Fri, 10 Jun 88 18:27:18 PDT <8806110127.AA03445@bhopal.lucid.com>Subject: EQUALReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 JUN 88 18:05:57 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 11 Jun 88  17:37:55 PDTReceived: by labrea.stanford.edu; Sat, 11 Jun 88 17:36:49 PDTReceived: from bhopal.lucid.com by edsel id AA26883g; Sat, 11 Jun 88 17:33:22 PDTReceived: by bhopal id AA05974g; Sat, 11 Jun 88 17:32:08 PDTOriginal-Date: Sat, 11 Jun 88 17:32:08 PDTMessage-Id: <8806120032.AA05974@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI like you analysis, and think it explains very well why EQUAL has the peculiar semantics that it now has.How would you feel about extending EQUAL to descend defsturct structuresand T-type arrays?  it wouldn't mess up its utility for its original purpose, and would satisfy an enormous number of Lisp users.  Of course, EQUAL type hashtables would work with this new definition.As we have often said, EQUALP went a little bit too far -- because ofignoring representation type on numbers and character case in strings.I think there should be an EQUALP type hashtable as long as there'san EQUALP function; but a satisfactorily extended EQUAL function mightmake it less of pressing issue.-- JonL --*start*00791 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 06 JUL 88 18:37:32 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Jul 88  18:36:38 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 06 JUL 88 18:36:11 PDTDate: 6 Jul 88 18:35 PDTFrom: Masinter.paSubject: EQUAL-STRUCTUREto: cl-cleanup@sail.stanford.eduMessage-ID: <880706-183611-1212@Xerox>After all the debate, I'm convinced that the worst thing that we can do is tochange it without fixing it, and that it is unfixable. I think taking it out istoo radical, and so we should just clarify that it doesn't descend into anystructure that CLtL doesn't mention that it explicitly descends into.*start*03485 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 JUN 88 15:55:36 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 24 Jun 88  15:52:33 PDTReceived: by labrea.stanford.edu; Fri, 24 Jun 88 15:52:27 PDTReceived: from bhopal.lucid.com by edsel id AA07541g; Fri, 24 Jun 88 14:38:25 PDTReceived: by bhopal id AA16670g; Fri, 24 Jun 88 14:38:05 PDTDate: Fri, 24 Jun 88 14:38:05 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8806242138.AA16670@bhopal.lucid.com>To: RWK@ai.ai.mit.eduCc: edsel!jlm@labrea.stanford.edu, common-lisp@sail.stanford.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: "Robert W. Kerns"'s message of Mon, 13 Jun 88 02:05:15 EDT <396357.880613.RWK@AI.AI.MIT.EDU>Subject: EQUAL[apologies for so late a reply -- have been out of town for over a week]Jim's point about the historical reference of EQUAL seemed to me to be thatit was made to work for the datatypes that were "in common use" in the Lispsof that day, namely the datatypes necessary for writing programs in the Lisp language.  Hence, conses, symbols, numbers, maybe strings, and not much else.However, I certainly wouldn't expect anything productive to come from a discussion on how to determine whether two programs/functions  *really*  are "equal"!   Possibly you took MacDonald's argument to an extreme that he didn't originally intend?What would be the objections to extending EQUAL to accommodate the serious modern datatypes of Common Lisp? in particular:   (1) Do component-wise EQUAL comparisons on arrays [this implies "descent"       for pointer arrays].  Unlike with EQUALP, the arrays must be of the        same type, but the presence of fill-pointers,  array-element-type       "upgrading", adjustability, and displacement may require some        refinements of this clause.   (2) Descend defstructs, except possibly for "system" defstructs that       are built-in by the implementation [i.e., an implementation can       use defstruct to implement a STREAM, but impose a "private"       definition of EQUAL for streams; probably same for all types        discussed in the cleanup issue TYPE-HIERARCHY-UNDERSPECIFIED].         Possibly extend defstruct to admit an option :equal, similar to        the :copier option, but this isn't a critical requirement now.   (3) Require that EQUAL be a "generic" function, so that CLOS methods       can be written for it; likely, the "default" method for non-built-in       classes would be some sort of error, meaning that mindless descent       isn't a good default.  By analogy with defstructs, you can compare       two defstuct-instances of the same type with the :equal functions,       and you could only compare two clos instances for which there is an        appropriate EQUAL method supplied.This definition would imply that hashtables of :type EQUAL will operate inthe manner expected by so many users of Common Lisp.  Somehow, people havebeen lured into thinking that this is already the current practice; but of course something much more limiting is the current state.Finally, I might point out that recent discussions about EQUALP seem to have overlooked it's variations on numerical equality and array-typeindifference.  Extending EQUAL to descend structures is *not* the same as retracting EQUALP to be case-sensitive.-- JonL --*start*02252 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 JUN 88 16:50:43 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 24 Jun 88  16:47:42 PDTReceived: by labrea.stanford.edu; Fri, 24 Jun 88 16:47:38 PDTReceived: from bhopal.lucid.com by edsel id AA08086g; Fri, 24 Jun 88 16:40:19 PDTReceived: by bhopal id AA18154g; Fri, 24 Jun 88 16:39:58 PDTDate: Fri, 24 Jun 88 16:39:58 PDTFrom: Jim McDonald <edsel!jlm@labrea.stanford.edu>Message-Id: <8806242339.AA18154@bhopal.lucid.com>To: edsel!jonl@labrea.stanford.eduCc: common-lisp@sail.stanford.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Fri, 24 Jun 88 14:38:13 EST <8806242138.AA16670@bhopal.lucid.com>Subject: EQUALMy concern about having EQUAL descend structures and arrays is thatthey are much more likely than lists to be circular.Typically, a list is created after its elements, whereas a structureor array is created before its elements.  (*Typically*, not always!)As a rule of thumb, I'd bet that less than .0001% of all lists arecircular, and that less than 1% of all arrays are circular, but onlythat less than 30% of all structures are circular.  I think there is a tendancy to include fields like CHILDREN andPARENTS, or PREVIOUS and NEXT, etc. in structures, which are thusalmost guaranteed to be circular.  In fact, when I'm creating circulardata I tend to think first of using structures, because I am then lesslikely to get screwed by EQUAL, etc.I don't have time now to think through the algorithmic details, butmaybe DEFSTRUCT could let you specify that specific slots are"back-pointers".  Then EQUAL could record them when descending andperform a more sophisticated comparison than it would for all otherpointers.   Thus you would only pay at runtime for the specificcomplications you did introduce, not those you might have.  Makingbackpointers explicit might help human readability as well.[As something of an aside, I think you should also be able to specify *print-level* and *print-length* for specific structure fields, to avoid losing on some fields when trying to see others.]  jlm*start*03977 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 24 Jun 88 16:39From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: "Robert W. Kerns"'s message of Mon, 13 Jun 88 02:05:15 EDT <396357.880613.RWK@AI.AI.MIT.EDU>Subject: EQUALTo: RWK%ai.ai.mit:EDU:Xeroxcc: edsel!jlm%labrea.stanford:EDU:Xerox, common-lisp%sail.stanford:EDU:Xerox, cl-cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: RWK@ai.ai.mit.eduCc: edsel!jlm@labrea.stanford.edu, common-lisp@sail.stanford.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: "Robert W. Kerns"'s message of Mon, 13 Jun 88 02:05:15 EDT <396357.880613.RWK@AI.AI.MIT.EDU>Subject: EQUALReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 JUN 88 16:39:45 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 24 Jun 88  15:52:08 PDTReceived: by labrea.stanford.edu; Fri, 24 Jun 88 15:52:02 PDTReceived: from bhopal.lucid.com by edsel id AA07541g; Fri, 24 Jun 88 14:38:25 PDTReceived: by bhopal id AA16670g; Fri, 24 Jun 88 14:38:05 PDTOriginal-Date: Fri, 24 Jun 88 14:38:05 PDTMessage-Id: <8806242138.AA16670@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV[apologies for so late a reply -- have been out of town for over a week]Jim's point about the historical reference of EQUAL seemed to me to be thatit was made to work for the datatypes that were "in common use" in the Lispsof that day, namely the datatypes necessary for writing programs in the Lisp language.  Hence, conses, symbols, numbers, maybe strings, and not much else.However, I certainly wouldn't expect anything productive to come from a discussion on how to determine whether two programs/functions  *really*  are "equal"!   Possibly you took MacDonald's argument to an extreme that he didn't originally intend?What would be the objections to extending EQUAL to accommodate the serious modern datatypes of Common Lisp? in particular:   (1) Do component-wise EQUAL comparisons on arrays [this implies "descent"       for pointer arrays].  Unlike with EQUALP, the arrays must be of the        same type, but the presence of fill-pointers,  array-element-type       "upgrading", adjustability, and displacement may require some        refinements of this clause.   (2) Descend defstructs, except possibly for "system" defstructs that       are built-in by the implementation [i.e., an implementation can       use defstruct to implement a STREAM, but impose a "private"       definition of EQUAL for streams; probably same for all types        discussed in the cleanup issue TYPE-HIERARCHY-UNDERSPECIFIED].         Possibly extend defstruct to admit an option :equal, similar to        the :copier option, but this isn't a critical requirement now.   (3) Require that EQUAL be a "generic" function, so that CLOS methods       can be written for it; likely, the "default" method for non-built-in       classes would be some sort of error, meaning that mindless descent       isn't a good default.  By analogy with defstructs, you can compare       two defstuct-instances of the same type with the :equal functions,       and you could only compare two clos instances for which there is an        appropriate EQUAL method supplied.This definition would imply that hashtables of :type EQUAL will operate inthe manner expected by so many users of Common Lisp.  Somehow, people havebeen lured into thinking that this is already the current practice; but of course something much more limiting is the current state.Finally, I might point out that recent discussions about EQUALP seem to have overlooked it's variations on numerical equality and array-typeindifference.  Extending EQUAL to descend structures is *not* the same as retracting EQUALP to be case-sensitive.-- JonL --*start*04988 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 30 Jun 88 08:55From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: goldman@vaxa.isi.edu's message of Fri, 24 Jun 88 18:15:43 PDT <8806250115.AA22390@vaxa.isi.edu>Subject: [Re: EQUAL]To: goldman%vaxa.isi:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: goldman@vaxa.isi.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: goldman@vaxa.isi.edu's message of Fri, 24 Jun 88 18:15:43 PDT <8806250115.AA22390@vaxa.isi.edu>Subject: [Re: EQUAL]Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 30 JUN 88 08:55:38 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 30 Jun 88  08:03:59 PDTReceived: by labrea.stanford.edu; Thu, 30 Jun 88 08:03:29 PDTReceived: from bhopal.lucid.com by edsel id AA14758g; Wed, 29 Jun 88 18:50:50 PDTReceived: by bhopal id AA15565g; Wed, 29 Jun 88 18:57:09 PDTOriginal-Date: Wed, 29 Jun 88 18:57:09 PDTMessage-Id: <8806300157.AA15565@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV[Neil, I'm cc'ing my reply to the whole list, since I think you questionsare of general relevance.  Apologies in advance if you really didn't wantto "go public" with your question. -- JonL --]    From: goldman@vaxa.isi.edu    Date: Fri, 24 Jun 88 18:15:43 PDT    . . .        (2) Descend defstructs, except possibly for "system" defstructs ...    What are potential "system" defstructs?  Is the phrase limited to the list    of types on page 13?  If so, then it sounds ok, since EQUAL is already    (independently) appropriately defined on BIGNUMS and PATHNAMES.  But it    just says "such as ..." on page 13, which leaves some doubt.I was certainly thinking of those types on page 13, since they are theones addressed by the "cleanup" issue "type-hierarchy-underspecfied".       (3) Require that EQUAL be a "generic" function, so that CLOS methods	   can be written for it, likely, the "default" method for non-built-in	   classes would be some sort of error, meaning that mindless descent	   isn't a good default.     First, I would think that (OBJECT OBJECT) would have an EQUAL method    that applied EQL, not ERROR, and that method would inherit to all standard    classes under OBJECT.  I must misunderstand your intent -- you certainly    would want EQUAL to be TRUE whenever EQ was true, not an error?I'm not 100% certain that one would want this.  Perhaps the CLOS subcommitteeof x3j13 will tackle it.  Mostly, the default method is just to say thatyou shouldn't be doing this (calling EQUAL) on an object of this type.  But just having no applicable method may in fact be a better kind of error.  Of course, a default method could check for EQ before causing any other kind of error.    If programmers to extend EQUAL in CLOS style -- which means    with arbitrary procedural definitions for their new classes -- could     EQUAL hash tables be implemented efficiently?  How would they hash     values belonging to the new classes?    As you pointed out in subsequent discussion, a user-supplied EQUAL method,whether for CLOS classes or as a defstruct option, leaves open the questionof mechanically verifying that the alleged predicate is reflexive, symmetric,and transitive.  Another major problem with using hash-tables on objectswith non-default EQUAL methods is that the SXHASH function must be similarlyextended for these data types; SXHASH must obey the property that    (equal x y)   imples   (= (sxhash x) (sxhash x))See CLtL p285.  At one time, there was a suggestion that hash tables admit a user-supplied equivalence predicate; but it never got very far for just this reason, that the equivalence predicate must be *** paired up** with anappropriate "numericalizer" function, and many implementors felt that users wouldn't understand these issues and wouldn't be able to construct up their own versions of sxhash to go with their alleged equivalence predicates. [SXHASH is required to be "good enough" for the EQUAL equivalence releation,and for subsets of that relation such as STRING=, but it is unlikely that any vendor makes it "good enough" for, say, EQUALP.  Lucid has EQUALP hashtables, but they don't use SXHASH.]    . . .     [Pardon me if I am impuning more to your suggestion than you intended.    This discussion that started on the meaning of DEFCONSTANT and QUOTE has    spread out quite a bit, and maybe you are just suggesting this as    an improvement to EQUAL with no implications about it clarifying    defconstant/quote].Yes, the Subject line of this interchange has been "EQUAL" -- not "constant folding/smashing" as before.  Jim MacDonald was simplyinspired by the defconstant/quote issue to open up the EQUAL one.-- JonL --*start*04147 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 30 Jun 88 15:27From: jrose%Sun:COM:XeroxIn-Reply-to: Michael Greenwald's message of Thu, 30 Jun 88 16:36 EDT <19880630203650.3.GREENWALD@SWALLOW.SCRC.SymSubject: EQUAL, and hash tables, and value/object distinctionsTo: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: edsel!jonl%labrea.stanford:EDU:Xerox, goldman%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: jrose@Sun.COM (John Rose)To: Greenwald@STONY-BROOK.SCRC.Symbolics.COMCc: edsel!jonl@labrea.stanford.edu, goldman@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: Michael Greenwald's message of Thu, 30 Jun 88 16:36 EDT <19880630203650.3.GREENWALD@SWALLOW.SCRC.Symbolics.COM>Subject: EQUAL, and hash tables, and value/object distinctionsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 30 JUN 88 15:27:16 PDTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 30 Jun 88  14:38:31 PDTReceived: from snail.sun.com by Sun.COM (4.0/SMI-4.0)	id AA01182; Thu, 30 Jun 88 14:36:25 PDTReceived: from lukasiewicz.sun.com by snail.sun.com (4.0/SMI-3.2)	id AA27554; Thu, 30 Jun 88 14:32:01 PDTReceived: by lukasiewicz.sun.com (4.0/SMI-4.0)	id AA01962; Thu, 30 Jun 88 14:38:29 PDTOriginal-Date: Thu, 30 Jun 88 14:38:29 PDTMessage-Id: <8806302138.AA01962@lukasiewicz.sun.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV   Date: Thu, 30 Jun 88 16:36 EDT   From: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>       Date: Thu, 30 Jun 88 12:40:54 PDT       From: jrose@Sun.COM (John Rose)       Two remarks on EQUAL and hash tables, from a hash table fan.       ...	  Date: Wed, 29 Jun 88 18:57:09 PDT	  From: Jon L White <edsel!jonl@labrea.stanford.edu>	  As you pointed out in subsequent discussion, a user-supplied EQUAL method,	  whether for CLOS classes or as a defstruct option, leaves open the question	  of mechanically verifying that the alleged predicate is reflexive, symmetric,	  and transitive.       ...       [Flame from Rose...]	      (EQUALITY-PREDICATE X Y)   ==>   (= (HASH-FN X) (HASH-FN Y))   Yes, but the equality-predicate must be transitive over the domain of   possible keys in order for a hash-function to work.   For example, one cannot construct a hash-function for #'= unless you limit   the valid keys to not include both a floating point number and two   integers that both coerce to that same float.   (i.e.      (let* ((a (expt 2 56))	    (b (1+ a))	    (c (float a)))       (values (= a b) (= a c) (= b c)))    => NIL T T   )   I'm not voting for condescension, nor for protecting programmers from   themselves.  I just want to point out that it is slightly more   complicated than you make it seem.Well, for the record, I'll try not to gloss over the fact that theEQUALITY-PREDICATE must be an equality predicate (:-).  That is, it mustbe reflexive, symmetric, and transitive.  In my experience, equalitypredicates are not difficult to write, and are verified by inspection,so "reflexive, symmetric, and transitive" is not really a burden.Writing a hash function takes a little more effort, since you've got tomake sure its structure accurately mirrors the equality predicateyou've already written.Your point about #'= and domains is well taken.  I had forgottenabout the CL numeric conversions.  I think the general principlehere is that if you're comparing equality over domains insideof which there are implicit conversions that lose information,equality testing and hashing should be performed in such a way thatthe information is reliably thrown out, or reliably retained.(And these two choices yield key domains of different granularities.)For example, a hash table over real numbers including floats mightuse one of these equality predicates instead of #'=:	;; Coarser grain:	#'(lambda (x y) (= (float x 0L0) (float y 0L0)))	;; Finer grain:	#'(lambda (x y) (= (rational x) (rational y)))					-- John*start*10514 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 30 Jun 88 13:39From: jrose%Sun:COM:XeroxIn-Reply-to: Jon L White's message of Wed, 29 Jun 88 18:57:09 PDT <8806300157.AA15565@bhopal.lucid.com>Subject: EQUAL, and hash tables, and value/object distinctionsTo: edsel!jonl%labrea.stanford:EDU:Xeroxcc: goldman%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: jrose@Sun.COM (John Rose)To: edsel!jonl@labrea.stanford.eduCc: goldman@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: Jon L White's message of Wed, 29 Jun 88 18:57:09 PDT <8806300157.AA15565@bhopal.lucid.com>Subject: EQUAL, and hash tables, and value/object distinctionsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 30 JUN 88 13:39:31 PDTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 30 Jun 88  12:41:10 PDTReceived: from snail.sun.com by Sun.COM (4.0/SMI-4.0)	id AA14063; Thu, 30 Jun 88 12:38:47 PDTReceived: from lukasiewicz.sun.com by snail.sun.com (4.0/SMI-3.2)	id AA24101; Thu, 30 Jun 88 12:34:26 PDTReceived: by lukasiewicz.sun.com (4.0/SMI-4.0)	id AA01804; Thu, 30 Jun 88 12:40:54 PDTOriginal-Date: Thu, 30 Jun 88 12:40:54 PDTMessage-Id: <8806301940.AA01804@lukasiewicz.sun.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTwo remarks on EQUAL and hash tables, from a hash table fan.First, if EQUAL is going to descend structures and arrays to testfor isomorphism, it should compare hash tables for equalityaccording to their contents.  That is, it should verifythat two possibly-equal hash tables have the same set ofkeys, and that for each key the two stored values are EQUAL.Key equality testing must be done using each table'skey comparison function.[Rationale & discussion are below, on the next page.But first I've got to respond to something else.]   Date: Wed, 29 Jun 88 18:57:09 PDT   From: Jon L White <edsel!jonl@labrea.stanford.edu>       From: goldman@vaxa.isi.edu       Date: Fri, 24 Jun 88 18:15:43 PDT  ...       If programmers to extend EQUAL in CLOS style -- which means       with arbitrary procedural definitions for their new classes -- could        EQUAL hash tables be implemented efficiently?  How would they hash        values belonging to the new classes?   As you pointed out in subsequent discussion, a user-supplied EQUAL method,   whether for CLOS classes or as a defstruct option, leaves open the question   of mechanically verifying that the alleged predicate is reflexive, symmetric,   and transitive.  Another major problem with using hash-tables on objects   with non-default EQUAL methods is that the SXHASH function must be similarly   extended for these data types; SXHASH must obey the property that       (equal x y)   imples   (= (sxhash x) (sxhash x))   See CLtL p285.  At one time, there was a suggestion that hash tables admit    a user-supplied equivalence predicate; but it never got very far for just    this reason, that the equivalence predicate must be *** paired up** with an   appropriate "numericalizer" function, and many implementors felt that users    wouldn't understand these issues and wouldn't be able to construct up their    own versions of sxhash to go with their alleged equivalence predicates. Yuck.  Who are these brilliant Implementors, that we may all worshipat their feet?  For they are the curators of such profound knowledge as       (EQUALITY-PREDICATE X Y)   ==>   (= (HASH-FN X) (HASH-FN Y))If we mere Users cannot be trusted with such wisdom, how are we tonavigate the Streams of Extensibility, or handle the Objects ofGenericity?  Oh great Implementors, save us, we pray, from overmuchfunctionality.Seriously, I hear an alarming amount of condescension in the above reasoning.The above logical implication is ALL THAT IS NEEDED to construct anappropriate hash function.  It is the sole and fundamental insight whichmakes hash tables work; I have relied on it for years, building many ahash table in various extensible frameworks.  What's the problem ofrequiring a hash-table builder from promising that his hash and equalityfunctions bear the simple relation to each other?  And if he can'thandle that, what chance does he have of building a working stream type,or making sense out of CLOS?  (Note that many vendors have supplied moreor less hairy stream definition facilities, which usually requireinvariants much more complex than the hash invariant above.)As for "mechanical verification" of the hashing and equality invariants,that's a red herring.  Since when do we mechanically verify any of therequired properties of functional arguments to Lisp primitives?  (I'mthinking particularly of the :KEY and :TEST arguments to sequencefunctions.)  Just say that unless the supplied functions satisfy therequired conditions "it is an error".The "pairing up" of equality and hashing could be done cleanly in CLOSby defining generic equality and hashing methods for particular hashtable types.   [SXHASH is required to be "good enough" for the EQUAL equivalence releation,   and for subsets of that relation such as STRING=, but it is unlikely that    any vendor makes it "good enough" for, say, EQUALP.  Lucid has EQUALP hash   tables, but they don't use SXHASH.]   -- JonL --!Proposal:  EQUAL should check for isomorphism of hash tables.The effect of this rule is to treat hash tables like lists,structures, and arrays for equality testing, under the followingreasonable theory of the semantics of lists, structures, arrays,and hash tables:  The meaning of any such data structure isdetermined by a small set of (call them) "access keys" anda value stored under each access key.  The set of accesskeys for each kind of data structure is {CAR,CDR}, a set ofslot access functions, an initial setquence of non-negative integers,and a set of Lisp objects, respectively.Other than the differences in these "access keys", all fourof the above data structures are tuple types, in that theystore a finite set of values, each accessible under its ownkey.  An equality function which performs an isomorphism checkon any of those tuple types should perform it on all of them,or have a very specific reason not to.If two hash tables differ not in their contents but in theirimplementation parameters (such as size or equality function),we must choose whether to compare structure abstractly(looking only at contents) or concretely (looking alsoat implementation parameters).  This question comes upwith respect to array structural equality also.  Forexample, do we allow a fill pointer to define an array'slength (i.e., its "access key" set), or do we look atthe length of the underlying allocated storage?  Whatabout comparing an (array t) having a fill pointer,with a string?  I believe the people working on thisproblem will come to a more or less abstract viewpoint,and if so, that viewpoint should be applied consistentlyto hash tables.An interesting question arises when two hash tables havedifferent key equality predicates, and (suppose) we've alreadydecided to treat equality predicates as implementation details,and ignore them directly.  Here's one answer:  Declare twohash tables EQUAL if they include each other.  That is, forevery key K in hash table A, require that	(EQUAL (GETHASH A K) (GETHASH B K *UNIQUE-UNKNOWN-VALUE*))and the same for every key in table B.Possible specific reasons not to test for hash table isomorphism,with comments or rebuttals in brackets:  (1) It's too hard to implement.      [No, it's actually pretty easy to implement this test       portably using a MAPHASH over each table; each MAPHASH       tests one direction of inclusion by performing       GETHASHs.]  (2) It's too slow to implement.      [Any recursive descent takes a long time to do.       But hash tables can probably be made faster to compare       than corresponding CONS structures, because they can use       saved key hash values to advantages.  A hash table's       key set can be hashed by combining all its key hash       values.]  (3) Recursive descent into hash tables is too unexpected.      [For programmers unfamiliar with hash tables, many of       their properties are going to be pretty surprising.       Programmers who understand their nature and use are       also going to understand their correspondence with       lists, structures, and (especially) arrays; it is       these programmers whose expectations we should design for.]  (4) Hash tables are different because we expect frequent      side effects on them, and so momentary isomorphism      between two of them is not significant.      [This is the best argument against, I think.  See below.]About (4):  Cons cells, structures, arrays, and hash tables can all beused either as pure values (that is, no updates after initialconstruction, and object identity is not important) or as updatableobjects (updates are expected, and shared object identities arecrucial).  Under current Lisp practice, hash tables are rarely usedas pure values.  (Cons cells usually are, and structures and arraysoccasionally are.)We may call types which are used as pure values "value-like"and types which are used as shared objects "object-like".Notice that EQUAL and EQL differ in their theory of cons cells: EQUALtreats them as pure values, and EQL as sharable objects.  I believea consistent way of accounting for this is to say that the behaviorof EQUAL and EQL differ for types which have this dual nature,of value-like and object-like.  (For types which are only value-like,such as complex numbers, EQL compares substructures, just as EQUALdoes.  For types which are only object-like, such as streams,EQUAL compares object identity, just as EQL does.)So, if you believe all that about EQUAL and EQL, the question of EQUALon hash tables gets down to this:  Are hash tables so object-like thatno one is likely to think of them as pure values?Consider this:  Hash tables can be used to implement sets,if you need to optimize the speed of the set-inclusion operator.Sets are value-like types.  Hash tables can be used to implementfinite functions; if they themselves are hashable and comparable,one can build higher-order functional systems out of them(and get memoization as a bonus).				-- John *start*05096 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 30 Jun 88 14:30From: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: EQUAL, and hash tables, and value/object distinctionsIn-Reply-to: <8806301940.AA01804@lukasiewicz.sun.com>To: jrose%Sun:COM:Xerox, edsel!jonl%labrea.stanford:EDU:Xeroxcc: goldman%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>Subject: EQUAL, and hash tables, and value/object distinctionsTo: jrose@Sun.COM, edsel!jonl@labrea.stanford.educc: goldman@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: <8806301940.AA01804@lukasiewicz.sun.com>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 30 JUN 88 14:29:59 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 30 Jun 88  13:40:04 PDTReceived: from SWALLOW.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 427334; Thu 30-Jun-88 16:36:56 EDTOriginal-Date: Thu, 30 Jun 88 16:36 EDTMessage-ID: <19880630203650.3.GREENWALD@SWALLOW.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 30 Jun 88 12:40:54 PDT    From: jrose@Sun.COM (John Rose)    Two remarks on EQUAL and hash tables, from a hash table fan.    ...       Date: Wed, 29 Jun 88 18:57:09 PDT       From: Jon L White <edsel!jonl@labrea.stanford.edu>       As you pointed out in subsequent discussion, a user-supplied EQUAL method,       whether for CLOS classes or as a defstruct option, leaves open the question       of mechanically verifying that the alleged predicate is reflexive, symmetric,       and transitive.  Another major problem with using hash-tables on objects       with non-default EQUAL methods is that the SXHASH function must be similarly       extended for these data types; SXHASH must obey the property that	   (equal x y)   imples   (= (sxhash x) (sxhash x))       See CLtL p285.  At one time, there was a suggestion that hash tables admit        a user-supplied equivalence predicate; but it never got very far for just        this reason, that the equivalence predicate must be *** paired up** with an       appropriate "numericalizer" function, and many implementors felt that users        wouldn't understand these issues and wouldn't be able to construct up their        own versions of sxhash to go with their alleged equivalence predicates.     Yuck.  Who are these brilliant Implementors, that we may all worship    at their feet?  For they are the curators of such profound knowledge as	   (EQUALITY-PREDICATE X Y)   ==>   (= (HASH-FN X) (HASH-FN Y))Yes, but the equality-predicate must be transitive over the domain ofpossible keys in order for a hash-function to work.For example, one cannot construct a hash-function for #'= unless you limitthe valid keys to not include both a floating point number and twointegers that both coerce to that same float.(i.e.   (let* ((a (expt 2 56))	 (b (1+ a))	 (c (float a)))    (values (= a b) (= a c) (= b c))) => NIL T T)I'm not voting for condescension, nor for protecting programmers fromthemselves.  I just want to point out that it is slightly morecomplicated than you make it seem.My personal opinion is that CLtL should have allowed both the predicateand hash-function to be defined once it included hash tables in thelanguage spec.  In a real application the programmer will probably wantto construct a custom hash function anyway, even for :TEST 'EQ.  If thetable has a known, or typical, set of keys, that might allow a much moreefficient, or more collision-free, hash function.Hash tables aren't so complicated that one can't construct themyourself.  My guess (and only a guess) is that the only reason they'reincluded in the language spec is to give a portable way of hashing on%pointer where that might be useful.  SXHASH would have been enough, andthat allows easy implementation of the common case of EQUAL hash tables,too.  The minimalist in me still wonders why hash tables were included inCLtL.      Seriously, I hear an alarming amount of condescension in the above reasoning.    The above logical implication is ALL THAT IS NEEDED to construct an    appropriate hash function.  It is the sole and fundamental insight which    makes hash tables work; I have relied on it for years, building many a    hash table in various extensible frameworks.  What's the problem of    requiring a hash-table builder from promising that his hash and equality    functions bear the simple relation to each other?  And if he can't    handle that, what chance does he have of building a working stream type,    or making sense out of CLOS?  (Note that many vendors have supplied more    or less hairy stream definition facilities, which usually require    invariants much more complex than the hash invariant above.)*start*03342 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  3 Jul 88 10:31From: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: EQUAL, and hash tables, and value/object distinctionsIn-Reply-to: <19880701191544.6.BARMAR@OCCAM.THINK.COM>To: barmar%Think:COM:Xerox, Greenwald%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: jrose%sun:COM:Xerox, edsel!jonl%labrea.stanford:EDU:Xerox, goldman%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>Subject: EQUAL, and hash tables, and value/object distinctionsTo: barmar@Think.COM, Greenwald@STONY-BROOK.SCRC.Symbolics.COMcc: jrose@sun.com, edsel!jonl@labrea.stanford.edu, goldman@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: <19880701191544.6.BARMAR@OCCAM.THINK.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 03 JUL 88 10:31:16 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 3 Jul 88  09:56:25 PDTReceived: from SWALLOW.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 428227; Sun 3-Jul-88 12:55:06 EDTOriginal-Date: Sun, 3 Jul 88 12:54 EDTMessage-ID: <19880703165454.6.GREENWALD@SWALLOW.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 1 Jul 88 15:15 EDT    From: Barry Margolin <barmar@Think.COM>	Date: Thu, 30 Jun 88 16:36 EDT	From: Michael Greenwald <Greenwald@stony-brook.scrc.symbolics.com>	For example, one cannot construct a hash-function for #'= unless you limit	the valid keys to not include both a floating point number and two	integers that both coerce to that same float.	(i.e. 	  (let* ((a (expt 2 56))		 (b (1+ a))		 (c (float a)))	    (values (= a b) (= a c) (= b c)))	 => NIL T T	)    Actually, it's not that difficult to construct such a hash function.    All it has to do is coerce its argument before hashing, e.g.I think you are confused.  The problem isn't in having a validhash-function ( (DEFUN TRIVIAL-=-HASH (NUMBER) 1) is legal and valid,but inefficient), the problem is which bucket you put a, b, and c in myexample above.In other words, what does (DEFUN TEST-BARMAR-HASH ()  (SETF (GETHASH a TABLE) 0)   (SETF (GETHASH b TABLE) 1)  (SETF (GETHASH c TABLE) 2)  (VALUES (GETHASH a TABLE) (GETHASH b TABLE) (GETHASH c TABLE)))return?)Unless you restrict the domain as specified above, you are in aquandary.   If you coerce them all to long-floats, then (TEST-BARMAR-HASH) => 2,2,2If you coerce them all to integers then (depending on theimplementation) you can get(TEST-BARMAR-HASH) => 0,1,2 or 0,2,2 or 2,1,2    (defun =-hash (number)      (let ((real (realpart number))	    (imag (imagpart number)))	(setq number (complex (coerce real 'long-float)			      (coerce imag 'long-float))))      <compute the hash>)    I admit that this isn't a great hash function if you expect your keys to    include many bignums that are near each other.  But it is guaranteed to    be a correct hash (assuming <compute the hash> is well behaved).The hash isn't a problem.  It's the fact that #'= isn't transitive.						    barmar*start*02493 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  6 Jul 88 17:01From: goldman%vaxa.isi:EDU:XeroxSubject: [Re: EQUAL]In-Reply-to: edsel!jonl@labrea.stanford.edu's message of 2792627829To: edsel!jonl%labrea.stanford:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 06 JUL 88 17:01:07 PDTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 6 Jul 88  16:12:04 PDTPosted-Date: Wed, 06 Jul 88 16:11:58 PDTMessage-Id: <8807062312.AA13550@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.54/5.51)	id AA13550; Wed, 6 Jul 88 16:12:07 PDTOriginal-Date: Wed, 06 Jul 88 16:11:58 PDT   My original response to part of JonL's suggestion regarding CLOS and   EQUAL:	First, I would think that (OBJECT OBJECT) would have an EQUAL method	that applied EQL, not ERROR, and that method would inherit to all standard	classes under OBJECT.  I must misunderstand your intent -- you certainly	would want EQUAL to be TRUE whenever EQ was true, not an error?       JonL's comment on that:    I'm not 100% certain that one would want this.  Perhaps the CLOS subcommittee    of x3j13 will tackle it.  Mostly, the default method is just to say that    you shouldn't be doing this (calling EQUAL) on an object of this type.  But     just having no applicable method may in fact be a better kind of error.  Of     course, a default method could check for EQ before causing any other kind of     error.But because EQUAL is defined to recur to components of certain compoundobjects, saying that it is an error to call EQUAL on objects of type Cimplies that it would be an error to call it on compound objects (say,lists) containing Cs.  It seems wrong to me NOT to be able to choose torepresent something with a CLOS object if you want to use it in a list, orarray, or struct, that is going to tested with EQUAL.I would feel far better if EQ, EQL, EQUAL, and EQUALP (the built-inequivalence predicates) were well defined (no errors) over the entireuniverse of lisp objects.  This does not imply that one couldn'tmake EQUAL a generic function;  only that it would "be an error" towrite EQUAL methods that destroyed the properties of EQUAL that make it auniversal equivalence predicate.  [Like, I'd be very suspicousof any method with different specializers for the two arguments.]Neil*start*01095 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 15 SEP 88 12:00:31 PDTMessage-ID: <#c0AV@SAIL.Stanford.EDU>Date: 15 Sep 88 00:18 PDTFrom: System Files <SYS@SAIL.Stanford.EDU>Subject: Re: Issue: EQUAL-STRUCTURE (Version 2)   Received: from Xerox.COM by SAIL.Stanford.EDU with TCP; 15 Sep 88  00:18:36 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 14 SEP 88 22:35:47 PDTDate: 14 Sep 88 22:35 PDTFrom: masinter.pa@Xerox.COMSubject: Re: Issue: EQUAL-STRUCTURE (Version 2)In-reply-to: Masinter.pa's message of 8 Jun 88 17:47 PDTTo: cl-cleanup@sail.stanford.eduMessage-ID: <880914-223547-1922@Xerox>Since this issue was distributed to X3J13 and debated there, in the mail, and onthe Common Lisp mailing list, we probably need to report on our disposition ofit.My personal opinion is that we cannot fix EQUAL and EQUALP, and we are betteroff leaving them alone. I would like to withdraw the issue; I don't see a needfor a "status quo" clarification. *start*01079 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 18 SEP 88 12:52:06 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 461261; Sun 18-Sep-88 15:52:06 EDTDate: Sun, 18 Sep 88 15:52 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: EQUAL-STRUCTURE (Version 2)To: masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <880914-223547-1922@Xerox>Message-ID: <19880918195209.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 14 Sep 88 22:35 PDT    From: masinter.pa@Xerox.COM    Since this issue was distributed to X3J13 and debated there, in the mail, and on    the Common Lisp mailing list, we probably need to report on our disposition of    it.    My personal opinion is that we cannot fix EQUAL and EQUALP, and we are better    off leaving them alone. I would like to withdraw the issue; I don't see a need    for a "status quo" clarification. I agree.*start*00846 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 19 SEP 88 12:59:45 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 19 Sep 88  12:59:20 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA17936; Mon, 19 Sep 88 12:57:56 PDTDate: Mon, 19 Sep 88 12:57:56 PDTMessage-Id: <8809191957.AA17936@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: EQUAL-STRUCTUREAlthough I agree that we should keep the "status quo", I think a clarificationis still in order.  I believe CLtL isn't clear in saying that EQUAL doesnot look at the slots of a structure in determining equality--i.e., thatEQUAL on user-defined structures is the same as EQ.			---Walter*start*03322 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 SEP 88 02:43:51 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Sep 88  02:42:51 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 SEP 88 02:13:29 PDTDate: 23 Sep 88 02:13 PDTFrom: masinter.paSubject: Issue: EQUAL-STRUCTURE (Version 3)TO: cl-cleanup@Sail.stanford.educc: masinter.paLINE-FOLD: NOMessage-ID: <880923-021329-3994@Xerox>Ready for release?!Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CLARIFICATION/CHANGEEdit history: 18-Mar-88, Version 1 by Pitman	 8-Jun-88, Version 2 by Masinter (add Benson's proposal)	23-Sep-88, Version 3 by Masinter (remove all but STATUS-QUO)Problem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:STATUS-QUO):  Clarify that EQUAL and EQUALP do not descend any structures or  data types other than the ones explicitly specified in CLtL.   (CONSes, bit-vectors, strings, pathnames). EQUAL uses EQL   for numbers and EQ for all other types. Rationale:  There seem to be as many different equality primitives as there  are applications for them. None of the possible ways of changing  EQUAL or EQUALP are flawless. Given the inability to "fix" them,  it is better to leave them alone.Current Practice:  We are unaware of any extensions to CLtL's set of extensions,  although frequently users request them.Cost to Implementors:  Since this seems to be compatible with the status quo, none.Cost to Users:  sameCost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  There seems to be wide debate about what the proper aesthetics for  how equality should work in Common Lisp. While the status quo is not  aesthetically more pleasing than the various alternatives.  Aesthetic  considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.Discussion:  An earlier version of this issue with various alternatives was distributed  at the June 1988 X3J13 meeting. Since  this is a frequently raised issue, we thought we should submit it  as a clarification although there is no change to CLtL.  We considered:     removing EQUAL and EQUALP from the standard.     changing EQUALP to descend structures.     changing EQUALP to be case sensitive.     adding a :TEST keyword to EQUAL.     making EQUAL a generic function  All of these had some serious problems.*start*01279 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 26 SEP 88 17:38:17 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA09634g; Mon, 26 Sep 88 16:37:37 PSTReceived: by bhopal id AA02525g; Mon, 26 Sep 88 17:37:09 PDTDate: Mon, 26 Sep 88 17:37:09 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809270037.AA02525@bhopal>To: masinter.paCc: cl-cleanup@Sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 23 Sep 88 02:13 PDT <880923-021329-3994@Xerox>Subject: Issue: EQUAL-STRUCTURE (Version 3)re:     Proposal (EQUAL-STRUCTURE:STATUS-QUO):      Clarify that EQUAL and EQUALP do not descend any structures or      data types other than the ones explicitly specified in CLtL.       (CONSes, bit-vectors, strings, pathnames). EQUAL uses EQL       for numbers and EQ for all other types. This is definitely NOT the status quo.  You are describing EQUAL, butdefinitely not EQUALP.  CLtL p81 says of EQUALP: "Objects that havecomponents are EQUALP if they are of the same type and correspondingcomponents are EQUALP."Every implementation I've ever seen has in fact implemented EQUALP sothat it "descends" e.g. defstruct instances (among other things).-- JonL --*start*03344 00024 US Date:  1 Oct 88 15:20 PDTFrom: masinter.paSubject: Issue: EQUAL-STRUCTURE (Version 4)TO: cl-cleanup@Sail.stanford.educc: masinter.paLINE-FOLD: NOJonL was right.. I tried to fix it. Ready for release?!Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CLARIFICATION/CHANGEEdit history: 18-Mar-88, Version 1 by Pitman	 8-Jun-88, Version 2 by Masinter (add Benson's proposal)	23-Sep-88, Version 3 by Masinter (remove all but STATUS-QUO)	 1-Oct-88, Version 4 by Masinter (fix description)Problem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:STATUS-QUO):  Clarify that EQUAL and EQUALP do not descend any structures or  data types other than the ones explicitly specified in CLtL.   EQUAL uses EQL for numbers and characters, descends structure for CONSes   bit-vectors, strings; has special behavior for pathnames as specified  in CLtL,  and uses EQ for all other types.   EQUALP is similar, except that it ignores case in strings, descends  the structure of arrays, defstruct and CLOS instances. It uses EQ  for all other types; for example, it does not descend hash tables.Rationale:  There seem to be as many different equality primitives as there  are applications for them. None of the possible ways of changing  EQUAL or EQUALP are flawless. Given the inability to "fix" them,  it is better to leave them alone.Current Practice:  We are unaware of any extensions to CLtL's set of operations,  although frequently users request them.Cost to Implementors:  Since this seems to be compatible with the status quo, none.Cost to Users:  sameCost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  There seems to be wide debate about what the proper aesthetics for  how equality should work in Common Lisp. While the status quo is not  aesthetically more pleasing than the various alternatives.  Aesthetic  considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.Discussion:  An earlier version of this issue with various alternatives was distributed  at the June 1988 X3J13 meeting. Since  this is a frequently raised issue, we thought we should submit it  as a clarification although there is no change to CLtL.  We considered:     removing EQUAL and EQUALP from the standard.     changing EQUALP to descend structures.     changing EQUALP to be case sensitive.     adding a :TEST keyword to EQUAL.     making EQUAL a generic function  All of these had some serious problems.*start*03706 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 15:25:19 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 1 Oct 88  15:21:25 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 01 OCT 88 15:19:54 PDTDate: 1 Oct 88 15:20 PDTFrom: masinter.paSubject: Issue: EQUAL-STRUCTURE (Version 4)TO: cl-cleanup@Sail.stanford.educc: masinter.paLINE-FOLD: NOMessage-ID: <881001-151954-2189@Xerox>JonL was right.. I tried to fix it. Ready for release?!Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CLARIFICATION/CHANGEEdit history: 18-Mar-88, Version 1 by Pitman	 8-Jun-88, Version 2 by Masinter (add Benson's proposal)	23-Sep-88, Version 3 by Masinter (remove all but STATUS-QUO)	 1-Oct-88, Version 4 by Masinter (fix description)Problem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:STATUS-QUO):  Clarify that EQUAL and EQUALP do not descend any structures or  data types other than the ones explicitly specified in CLtL.   EQUAL uses EQL for numbers and characters, descends structure for CONSes   bit-vectors, strings; has special behavior for pathnames as specified  in CLtL,  and uses EQ for all other types.   EQUALP is similar, except that it ignores case in strings, descends  the structure of arrays, defstruct and CLOS instances. It uses EQ  for all other types; for example, it does not descend hash tables.Rationale:  There seem to be as many different equality primitives as there  are applications for them. None of the possible ways of changing  EQUAL or EQUALP are flawless. Given the inability to "fix" them,  it is better to leave them alone.Current Practice:  We are unaware of any extensions to CLtL's set of operations,  although frequently users request them.Cost to Implementors:  Since this seems to be compatible with the status quo, none.Cost to Users:  sameCost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  There seems to be wide debate about what the proper aesthetics for  how equality should work in Common Lisp. While the status quo is not  aesthetically more pleasing than the various alternatives.  Aesthetic  considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.Discussion:  An earlier version of this issue with various alternatives was distributed  at the June 1988 X3J13 meeting. Since  this is a frequently raised issue, we thought we should submit it  as a clarification although there is no change to CLtL.  We considered:     removing EQUAL and EQUALP from the standard.     changing EQUALP to descend structures.     changing EQUALP to be case sensitive.     adding a :TEST keyword to EQUAL.     making EQUAL a generic function  All of these had some serious problems.*start*02104 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 15:52:14 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Oct 88  15:48:14 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 468903; Sat 1-Oct-88 18:46:48 EDTDate: Sat, 1 Oct 88 18:46 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 4)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881001-151954-2189@Xerox>Message-ID: <881001184620.6.KMP@GRYPHON.SCRC.Symbolics.COM>Can we not say "CLOS instances" and just use "instances"?  The singleword is not ambiguous now that CLOS is adopted.  I don't want users of aFlavors compatibility package to get worried that "CLOS instances" and"Flavors instances" might be different. I'd rather the paragraph onEQUALP read: EQUALP is similar, except that it ignores case in strings, descends arrays, structures, and instances. It uses EQ for all other types; for example, it does not descend hash tables.I'd also like to add a paragraph like the following to the proposalpart. Anyone object or want to amend the wording? Document that object equality is not a concept for which there is a uniquely determined correct algorithm. The appropriateness of an equality predicate can be judged only in the context of the needs of some particular program. Although these functions take any type of argument and their names sound very generic, EQUAL and EQUALP are not appropriate for every application. Any decision to use or not use them should be determined by what they are documented to do rather than any abstract characterization of their function. If neither EQUAL nor EQUALP is found to be appropriate in a particular situation, programmers are encouraged to create another operator that is appropriate rather than blame EQUAL or EQUALP for ``doing the wrong thing.''*start*00937 00024 US Date:  1 Oct 88 16:10 PDTFrom: masinter.paSubject: Re: Issue: EQUAL-STRUCTURE (Version 4)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Sat, 1 Oct 88 18:46 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUI think there would be grounds for objection if the cleanup committee started recommending that the standard document this or used particular wording. I certainly wouldn't use an imperative "Document that ...." in the cleanup proposal.I would object to a statement in the Discussion section saying that"It would be useful if descriptions of EQUAL and EQUALPincluded notes to the effect that ..."Since we're both on the Editorial committee, we can bring up there how it might be most appropriate to get those kinds of notes into the standard document and where it would be appropriate to put them. OK?Larry*start*01299 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 16:16:13 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 1 Oct 88  16:12:11 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 01 OCT 88 16:10:33 PDTDate: 1 Oct 88 16:10 PDTFrom: masinter.paSubject: Re: Issue: EQUAL-STRUCTURE (Version 4)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Sat, 1 Oct 88 18:46 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881001-161033-2214@Xerox>I think there would be grounds for objection if the cleanup committeestarted recommending that the standard document this or used particularwording. I certainly wouldn't use an imperative "Document that ...." in thecleanup proposal.I would object to a statement in the Discussion section saying that"It would be useful if descriptions of EQUAL and EQUALPincluded notes to the effect that ..."Since we're both on the Editorial committee, we can bring up there how itmight be most appropriate to get those kinds of notes into the standarddocument and where it would be appropriate to put them. OK?Larry*start*05294 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 16:44:48 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Oct 88  16:40:44 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 468922; Sat 1-Oct-88 19:39:29 EDTDate: Sat, 1 Oct 88 19:39 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 5)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881001193901.9.KMP@GRYPHON.SCRC.Symbolics.COM>Per Masinter's request, here's a version with my comments edited in. - Changed wording of EQUALP portion of Proposal to change   "CLOS instance" to "instance" and "defstruct instance" to "structure". - Added Cleanup committee endorsement for option STATUS-QUO in Discussion. - Added editorial advice in Discussion.-----Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CLARIFICATION/CHANGEEdit history: 18-Mar-88, Version 1 by Pitman	      08-Jun-88, Version 2 by Masinter (add Benson's proposal)	      23-Sep-88, Version 3 by Masinter (remove all but STATUS-QUO)	      01-Oct-88, Version 4 by Masinter (fix description)	      01-Oct-88, Version 5 by Pitman   (correct wording, add discussion)Problem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:STATUS-QUO):  Clarify that EQUAL and EQUALP do not descend any structures or  data types other than the ones explicitly specified in CLtL.   EQUAL uses EQL for numbers and characters, descends structure for CONSes   bit-vectors, strings; has special behavior for pathnames as specified  in CLtL,  and uses EQ for all other types.   EQUALP is similar, except that it ignores case in strings, and it  descends arrays, structures, and instances. It uses EQ for  all other types; for example, it does not descend hash tables.Rationale:  There seem to be as many different equality primitives as there  are applications for them. None of the possible ways of changing  EQUAL or EQUALP are flawless. Given the inability to "fix" them,  it is better to leave them alone.Current Practice:  We are unaware of any extensions to CLtL's set of operations,  although frequently users request them.Cost to Implementors:  Since this seems to be compatible with the status quo, none.Cost to Users:  SameCost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  There seems to be wide debate about what the proper aesthetics for  how equality should work in Common Lisp. While the status quo is not  aesthetically more pleasing than the various alternatives.  Aesthetic  considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.Discussion:  An earlier version of this issue with various alternatives was distributed  at the June 1988 X3J13 meeting. Since  this is a frequently raised issue, we thought we should submit it  as a clarification although there is no change to CLtL.  Options for which we considered proposals were:    - removing EQUAL and EQUALP from the standard.    - changing EQUALP to descend structures.    - changing EQUALP to be case sensitive.    - adding a :TEST keyword to EQUAL.    - making EQUAL a generic function  All of these had some serious problems.  The cleanup committee supports option STATUS-QUO.  It would be useful if descriptions of EQUAL and EQUALP contained some sort  of additional commentary alluding to the complex issues discussed here.  The following is offered to the Editorial staff as a starting point:    Object equality is not a concept for which there is a uniquely    determined correct algorithm. The appropriateness of an equality    predicate can be judged only in the context of the needs of some    particular program. Although these functions take any type of    argument and their names sound very generic, EQUAL and EQUALP are    not appropriate for every application. Any decision to use or not    use them should be determined by what they are documented to do    rather than any abstract characterization of their function. If    neither EQUAL nor EQUALP is found to be appropriate in a particular    situation, programmers are encouraged to create another operator    that is appropriate rather than blame EQUAL or EQUALP for ``doing    the wrong thing.''*start*01738 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 01 OCT 88 20:54:31 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01494g; Sat, 1 Oct 88 19:53:37 PSTReceived: by bhopal id AA08953g; Sat, 1 Oct 88 20:53:11 PDTDate: Sat, 1 Oct 88 20:53:11 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810020353.AA08953@bhopal>To: masinter.paCc: cl-cleanup@Sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 1 Oct 88 15:20 PDT <881001-151954-2189@Xerox>Subject: Issue: EQUAL-STRUCTURE (Version 4)re:   EQUALP is similar, except that it ignores case in strings, descends      the structure of arrays, defstruct and CLOS instances. It uses EQ      for all other types; for example, it does not descend hash tables.Hmmm, wanna try one more time?  This needs to say "uses = for numbers,and uses eql for characters".Also John Rose made what I thought was a good suggestion -- that someextended equality predicate treat hash tables as "objects that havecomponents" (see CLtL p81), and that the correspondence be based on the hash tables' keys.  If you merely want to describe the status quo, I think you have to say this point has not been clear, and cannot be depended upon in any current implementation.re:   We considered:	 removing EQUAL and EQUALP from the standard.	 changing EQUALP to descend structures.	 changing EQUALP to be case sensitive.	 adding a :TEST keyword to EQUAL.	 making EQUAL a generic functionI think it should say that we considered	 changing EQUAL to descend structures.rather than EQUALP.  [If we didn't consider it then, then throw outthe whole thing and lets start again.]-- JonL --*start*01597 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 01 OCT 88 21:29:02 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01513g; Sat, 1 Oct 88 20:28:12 PSTReceived: by bhopal id AA09036g; Sat, 1 Oct 88 21:27:45 PDTDate: Sat, 1 Oct 88 21:27:45 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810020427.AA09036@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Sat, 1 Oct 88 18:46 EDT <881001184620.6.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 4)re: I'd also like to add a paragraph like the following to the proposal    part. Anyone object or want to amend the wording?     Document that object equality is not a concept for which     there is a uniquely determined correct algorithm. ...    . . . I object.  (but take that with a smile!)Let's just say that there are numerous equivalence relations that can be defined on data strucures as rich as those available in Common Lisp, and that EQL, EQUAL and EQUALP are merely three historically important relics.  Phrases that tend to imply that "object equality" is not a "correct" concept, just don't belong in the language specification.One *might* need to remind the lang. spec. reader   (1) just what an equivalence relation is;   (2) that EQ has the maximal number of equivalence classes;   (3) and that as relations, EQ is a subset of EQL, EQL is a subset       of EQUAL, and EQUAL is a subset of EQUALP.-- JonL --*start*01400 00024 US Return-Path: <KMP@Riverside.SCRC.Symbolics.COM>Received: from Riverside.SCRC.Symbolics.COM ([128.81.41.21]) by Xerox.COM ; 02 OCT 88 13:06:50 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 285058; Sun 2-Oct-88 16:05:39 EDTDate: Sun, 2 Oct 88 16:05 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: EQUAL-STRUCTURE (Version 4)To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKcc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <4933.8810021519@subnode.aiai.ed.ac.uk>Message-ID: <881002160549.6.KMP@GRYPHON.SCRC.Symbolics.COM>If someone introduces an incompatible feature under the same name as anexisting feature (such as your example of instances implemented asclosures), the burden should be on them to document their way out of thehole they have dug.If someone introduces a compatible feature (such as Flavors supportthat does not interfere with CLOS support), the documentation burdenshould be only to document the extension -- not to calm their usersabout imagined problems brought on by gratuitously specific wording inthe documentation.Terms like "CLOS instances" suggest the possibility of another kind.If we want to suggest another kind, we'll do so.If it's any help, terms like "character string", "atomic symbol", and soon bother me just as much...*start*01834 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 03 OCT 88 20:40:24 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 469997; Mon 3-Oct-88 23:40:33 EDTDate: Mon, 3 Oct 88 23:40 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 4)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881001184620.6.KMP@GRYPHON.SCRC.Symbolics.COM>Message-ID: <19881004034015.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Sat, 1 Oct 88 18:46 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    Can we not say "CLOS instances" and just use "instances"?  The single    word is not ambiguous now that CLOS is adopted.  I don't want users of a    Flavors compatibility package to get worried that "CLOS instances" and    "Flavors instances" might be different. I'd rather the paragraph on    EQUALP read:     EQUALP is similar, except that it ignores case in strings,     descends arrays, structures, and instances. It uses EQ for     all other types; for example, it does not descend hash tables.The problem with this is that there is no such concept as "an instance"in CLOS.  The word "instance" is only used in the phrase "an instanceof a class".  Every, every object is an instance of some class.  InCLOS terms, where you said "instances" I think you meant "membersof STANDARD-OBJECT" or "instances of STANDARD-OBJECT or of a subclassof that class" (the latter two phrases are synonymous).  Also of courseas I think JonL pointed out what this says is not what EQUALP does,at least remember that it uses = for numbers.*start*01754 00024 US Return-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 03 OCT 88 22:10:16 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa03613; 2 Oct 88 15:37 BSTDate: Sun, 2 Oct 88 16:19:12 BSTMessage-Id: <4933.8810021519@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: EQUAL-STRUCTURE (Version 4)To: Kent M Pitman <KMP@scrc-stony-brook.arpa>, KMP@scrc-stony-brook.arpa, Masinter.PAIn-Reply-To: Kent M Pitman's message of Sat, 1 Oct 88 18:46 EDTCc: CL-Cleanup@sail.stanford.edu> Can we not say "CLOS instances" and just use "instances"?  The single> word is not ambiguous now that CLOS is adopted.  I don't want users of a> Flavors compatibility package to get worried that "CLOS instances" and> "Flavors instances" might be different.I'm inclined to agree that "instances" is better, but Kent's reasonmakes me wonder.  Suppose someone implements an object system whereis isn't possible to descend instances (perhaps they're closures).I don't think we can say they can't be called "instances".  What itwould come down to would be that they weren't implemented as CLOSinstances and so the clause in EQUALP didn't apply.So we want to say "instances", we have to say somewhere what "instance"means in Common Lisp, and then it will be those instances we'll be talkingabout in EQUALP.It would then be up to the documentation for Flavors compatibilitypackages and the like to how their concept of instances maps ontoCommon Lisp.  And I think that is how it should be.So I agree with the first reason (it's no longer ambiguous), butnot the second.*start*05115 00024 US Date:  8 Oct 88 16:33 PDTSender: masinter.paSubject: Issue: EQUAL-STRUCTURE (Version 5)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterOur intent is to leave EQUAL and EQUALP alone. We are just havingdifficulty saying what it does now.We thought this deserved an "issue" even though it is status quobecause the issue arises frequently, and it was circulated for theJune 1988 X3J13 in a different form. Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CLARIFICATION/CHANGEEdit history: 18-Mar-88, Version 1 by Pitman	      08-Jun-88, Version 2 by Masinter (add Benson's proposal)	      23-Sep-88, Version 3 by Masinter (remove all but STATUS-QUO)	      01-Oct-88, Version 4 by Masinter (fix description)	      01-Oct-88, Version 5 by Pitman   (correct wording, add discussion)Problem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:STATUS-QUO):  Clarify that EQUAL and EQUALP do not descend any structures or  data types other than the ones explicitly specified in CLtL.   EQUAL uses EQL for numbers and characters, descends structure for CONSes   bit-vectors, strings; has special behavior for pathnames as specified  in CLtL,  and uses EQ for all other types.   EQUALP is similar, except that it ignores case in strings, and it  descends arrays, structures, and instances. It uses EQ for  all other types; for example, it does not descend hash tables.Rationale:  There seem to be as many different equality primitives as there  are applications for them. None of the possible ways of changing  EQUAL or EQUALP are flawless. Given the inability to "fix" them,  it is better to leave them alone.Current Practice:  We are unaware of any extensions to CLtL's set of operations,  although frequently users request them.Cost to Implementors:  Since this seems to be compatible with the status quo, none.Cost to Users:  SameCost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  There seems to be wide debate about what the proper aesthetics for  how equality should work in Common Lisp. While the status quo is not  aesthetically more pleasing than the various alternatives, aesthetic  considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.Discussion:  An earlier version of this issue with various alternatives was distributed  at the June 1988 X3J13 meeting. Since  this is a frequently raised issue, we thought we should submit it  as a clarification although there is no change to CLtL.  Options for which we considered proposals were:    - removing EQUAL and EQUALP from the standard.    - changing EQUALP to descend structures.    - changing EQUALP to be case sensitive.    - adding a :TEST keyword to EQUAL.    - making EQUAL a generic function  All of these had some serious problems.  The cleanup committee supports option STATUS-QUO.  It would be useful if descriptions of EQUAL and EQUALP contained some sort  of additional commentary alluding to the complex issues discussed here.  The following is offered to the Editorial staff as a starting point:    Object equality is not a concept for which there is a uniquely    determined correct algorithm. The appropriateness of an equality    predicate can be judged only in the context of the needs of some    particular program. Although these functions take any type of    argument and their names sound very generic, EQUAL and EQUALP are    not appropriate for every application. Any decision to use or not    use them should be determined by what they are documented to do    rather than any abstract characterization of their function. If    neither EQUAL nor EQUALP is found to be appropriate in a particular    situation, programmers are encouraged to create another operator    that is appropriate rather than blame EQUAL or EQUALP for ``doing    the wrong thing.''        TITAN 
         TITAN 
                                                                 (                     '                                  l              A              	              M       
                    L             L       z*start*01159 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 18:17:37 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 8 Oct 88  18:18:29 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 473405; Sat 8-Oct-88 21:17:01 EDTDate: Sat, 8 Oct 88 21:16 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 5)To: JonL@Lucid.COMcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881008-163306-2318@Xerox>Message-ID: <881008211646.1.KMP@BOBOLINK.SCRC.Symbolics.COM>It was still on my agenda to fix the complaints you had about the EQUALPdescription. Your comments about my proposed changes to v4 and my v5crossed in the mail so this got left out. Larry sent v5 to X3J13 beforeI had a chance to fix that. Anyway, please just come to the meeting witha proposed change to the wording in hand so we don't have to conjure itfrom scratch when the issue comes up. Thanks. -kmp*start*01532 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:43:30 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:43:49 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475833; Thu 13-Oct-88 16:42:22 EDTDate: Thu, 13 Oct 88 16:42 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 5)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013164213.5.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...X3J13 meeting: Sandra: Why not "fix" EQUALP? KMP: It's not fixable. Very brief discussion in writeup of why we      didn't go with the other options might be appropriate to head      off more questions like this at vote time. Masinter: Just to see how arbitrary the choice of equality operators	   is, note that there is no overlap between any of the Interlisp 	   equality operators and the Common Lisp ones! Beckerle: There would be an extremely high cost to making any change	   to EQUALP. There would be lots of "sleeping" errors, for	   which no error could be signalled -- programs would just	   behave incorrectly in subtle ways. Someone (Slater?) asked why not add keyword arguments? KMP: Among other things, this would mean that EQUALP couldn't be      a hash table predicate.*start*00972 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 OCT 88 14:35:39 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 14 Oct 88  14:34:06 PDTReceived: by ti.com id AA25126; Fri, 14 Oct 88 16:34:04 CDTReceived: from Kelvin by tilde id AA22754; Fri, 14 Oct 88 16:22:18 CDTMessage-Id: <2801856256-4716520@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 14 Oct 88 16:24:16 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: cl-cleanup@sail.stanford.eduSubject: Re: Issue: EQUAL-STRUCTURE (Version 5)In-Reply-To: Msg of 8 Oct 88 16:33 PDT from cl-cleanup@sail.stanford.edu> Our intent is to leave EQUAL and EQUALP alone. We are just having> difficulty saying what it does now.There is one important thing that this proposal does do:  it specifiesthe meaning of EQUALP for CLOS instances, which I don't think waspreviously defined.*start*00862 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 01 NOV 88 16:23:16 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00973g; Tue, 1 Nov 88 12:08:44 PSTReceived: by bhopal id AA05375g; Tue, 1 Nov 88 12:07:18 PSTDate: Tue, 1 Nov 88 12:07:18 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811012007.AA05375@bhopal>To: masinter.paCc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: masinter.pa@Xerox.COM's message of 31 Oct 88 11:45 PST <881031-114518-6098@Xerox>Subject: Issue: EQUAL-STRUCTURE (Version 5)I'm most unhappy with the current state of this venture, and don't planto sink any more wasted time into it. Instead, I focused on the mainbeneficiary of a "happy resolution" -- the hash-table issue -- andsubmitted the hash-table-tests proposal.-- JonL --*start*01722 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 20 JUN 88 11:49:48 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 20 Jun 88  11:49:49 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA21981; Mon, 20 Jun 88 12:48:31 MDTFrom: sandra@cs.utah.edu (Sandra J Loosemore)Message-Id: <8806201848.AA21981@cs.utah.edu>Date: Mon, 20 Jun 88 12:48:30 MDTSubject: comments on draft proposalsTo: cl-cleanup@sail.stanford.eduEQUAL-STRUCTURE:  My favorite alternative is CHANGE-EQUALP.  I have foundthe current definition of EQUALP to be pretty useless.  I actually thinkthat the most useful behavior would be to have EQUAL descend only liststructures and compare everything else with EQL, and have EQUALP descendarrays and structures as well as lists while making it consider charactersof different case and numbers of different types distinct.DEFPACKAGE:  I like this proposal.  About the only thing I would changewould be making the options that only use the names of the symbols(everything but :IMPORT and :SHADOWING-IMPORT) take strings as well.I would also like to see some clarification of the order in which thingshappen:  do the clauses get processed in the order they appear, or in"Put In Seven Extremely Random User Interface commands" order, or insome other order?  The compiler cleanup group would be willing to putforward a proposal to remove the magic status of the N random packageforms, but I think the DEFPACKAGE proposal can stand on its own.DECLARATION-SCOPE:  Seems OK to me.  It is at least more understandablethan the current language in CLtL.-Sandra-------*start*02058 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 15:17:30 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  15:17:11 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 15:16:05 PSTDate: 2 Jan 89 15:15 PSTSender: masinter.paSubject: re: Issue: EQUAL-STRUCTURE (Version 5)To: cl-cleanup@sail.stanford.eduFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Message-ID: <890102-151605-1724@Xerox>I thought this had been pretty well hashed out, so I was surprised to find someserious problems with the proposal.  While I support the general idea of theproposal, I can't vote in favor of it in its current form.  If these things getcleaned up, then I'll vote YES.  Note that all of my problems with the currentproposal have to do with EQUALP; I agree with the proposal for EQUAL, and wouldvote YES for it as a seperate issue if the EQUALP stuff can't be resolved intime. 1. The description of EQUALP's behavior does not match CLtL, since itreferences EQUAL more than it ought.  Specifically, characters should becompared with CHAR-EQUAL, and numbers should be compared with =, while theproposal says EQL for numbers (by defaulting to EQUAL) and is ambiguous aboutcharacters (could be EQL (by defaulting to EQUAL) or CHAR-EQUAL (since stringcomparisons are case insensitive)).2. The proposal says EQUALP descends arrays, structures, and instances, butuses EQ on other types, and gives hash-tables as an example of a data typewhich is not descended.  What if, in a given implementation, hash-tables areimplemented using structures or instances.  Does this mean that such animplementation must include code in EQUALP to explicitely prevent descendinginto hash-tables (and presumably any other COMMON types which are implementedusing structures or instances)?  This question has to be answered if the use ofEQUALP is to have any chance of being portable when applied to such objects.*start*00490 00024 US Date:  8 Jan 89 13:44 PSTFrom: masinter.pato: masinterSubject: re: Issue: EQUAL-STRUCTURE (Version 5)sent  8-Jan-89In-reply-to: Kim A. Barrett <IIM@ECLA.USC.EDU>'s message of 2 Jan 89 15:15 PSTTo: Kim A. Barrett <IIM@ECLA.USC.EDU>You're right. Can I talk you into helping draft a version that says what we mean? Kent and I are burned out on this issue, apparently.Preferably so we can have a version for voting on...Let me know one way or another asap.*start*03256 00024 USaReturn-Path: <IIM%ECLA.#DECnet@ECLC.USC.EDU>Received: from ECLC.USC.EDU ([10.1.0.121]) by Xerox.COM ; 09 JAN 89 10:50:01 PSTDate: Sun, 8 Jan 89 15:48:41 PSTFrom: IIM%ECLA@ECLC.USC.EDUSubject: re: Issue: EQUAL-STRUCTURE (Version 5)To: masinter.pacc: IIM%ECLA@ECLC.USC.EDUIn-Reply-To: <890108-134500-3303@Xerox>Message-ID: <12461012979.22.IIM@ECLA.USC.EDU>> Date: 8 Jan 89 13:44 PST> From: masinter.pa@Xerox.COM> > You're right. Can I talk you into helping draft a version that says what we> mean? Kent and I are burned out on this issue, apparently. > > Preferably so we can have a version for voting on...> Let me know one way or another asap.Well, I'd like to help, but I have two serious problems.First, I expect to have very little time to devote to X3J13 issues for the nextfew weeks, other than attending the meeting and discussing things there, sincestarting tomorrow I'm going to be embarking on a fairly major low-level changein our implementation, the completion of which is on the critical path for thecompletion of several other projects here.  I'm going to try to address as manythings as I can before I go home today (even if it means not leaving untiltomorrow) but after that I'm likely to be pretty unresponsive for a while.Second, I'm really not certain myself what it is "we mean", much less what the"right thing" is, so it's hard for me write it up.  The example problem I keephaving trouble with is hash-tables.  I can't think of any good reason whyEQUALP should specifically recognize them, yet I also think it has to.Consider the following:1. Given 2 EQ hash-tables H1 and H22. For some set of keys and associated values, install them in both H1 and H2,   in the same order.3. Invoke the garbage collector.  (I'm assuming that this will "invalidate" the   hashing in the tables, requiring a rehash to occur on at least some   operations.) 4. Perform some operation on H1 which does not change the key mapping, but   causes a rehash to occur due to the recent gc.It is very likely that under a simple component-wise comparison, H1 and H2 arenow no longer equivelent.  Worse yet, I can readily construct situations inmulti-processing or interruptable environments in which a simple component-wisecomparison implementation of EQUALP will return false for (equalp x x), where xis an eq hash-table.So we have an existance proof of an ill-defined case.  I think you'll have ahard time convincing me either that this is the only such case or that theseproblems don't arise in "user code".  And it seems to me quite likely that theset of problem cases will vary between implementations.  What do we do withsuch things?  I'm afraid I don't have what I consider to be a good answer.  Isuppose we could punt by saying that EQUALP does component-wise comparisonsalways, and add a caveat that this isn't necessarily useful or even "correct"for some datatypes in some implementations.  I don't think we can say anythingabout signaling errors in the bad cases, since if user-defined objects can havethese problems then there really isn't a way to detect when to signal.Besides, I sort of dislike the idea of an equality predicate which signalserrors. kab-------*start*04326 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 11:38:17 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Jan 89  11:25:08 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 09 JAN 89 11:20:39 PSTDate: 9 Jan 89 11:19 PSTFrom: masinter.paSubject: re: Issue: EQUAL-STRUCTURE (Version 5)In-reply-to: your message of Sun, 8 Jan 89 15:48:41 PSTTo: IIM%ECLA@ECLC.USC.EDUcc: cl-cleanup@sail.stanford.eduMessage-ID: <890109-112039-4344@Xerox>You've uncovered an ambiguity in the spec for EQUALP that Ihadn't thought of before. I think your analysis points out thatEQUALP's description should mention HASH-TABLEs as a special case. There are three possibilities: (1) EQUALP uses EQon hash tables, (2) EQUALP descends hash tables, (3) it isn'tspecified. If EQUALP were to descend hash tables, we'd haveto say how: I'd guess that you'd have to compare the set ofkeys using the hash table test function, and then the valuescorresponding to the keys using EQUALP. I like specified betterthan unspecified, and EQ better than descending.(For the rest of cl-cleanup, the relevant part of Kim's messageis...Date: Sun, 8 Jan 89 15:48:41 PSTFrom: IIM%ECLA@ECLC.USC.EDUSubject: re: Issue: EQUAL-STRUCTURE (Version 5)To: masinter.pacc: IIM%ECLA@ECLC.USC.EDUIn-Reply-To: <890108-134500-3303@Xerox>> Date: 8 Jan 89 13:44 PST> From: masinter.pa@Xerox.COM> > You're right. Can I talk you into helping draft a version that says what we> mean? Kent and I are burned out on this issue, apparently. > > Preferably so we can have a version for voting on...> Let me know one way or another asap.Well, I'd like to help, but I have two serious problems.First, I expect to have very little time to devote to X3J13 issues for the nextfew weeks, other than attending the meeting and discussing things there, sincestarting tomorrow I'm going to be embarking on a fairly major low-level changein our implementation, the completion of which is on the critical path for thecompletion of several other projects here.  I'm going to try to address as manythings as I can before I go home today (even if it means not leaving untiltomorrow) but after that I'm likely to be pretty unresponsive for a while.Second, I'm really not certain myself what it is "we mean", much less what the"right thing" is, so it's hard for me write it up.  The example problem I keephaving trouble with is hash-tables.  I can't think of any good reason whyEQUALP should specifically recognize them, yet I also think it has to.Consider the following:1. Given 2 EQ hash-tables H1 and H22. For some set of keys and associated values, install them in both H1 and H2,   in the same order.3. Invoke the garbage collector.  (I'm assuming that this will "invalidate" the   hashing in the tables, requiring a rehash to occur on at least some   operations.) 4. Perform some operation on H1 which does not change the key mapping, but   causes a rehash to occur due to the recent gc.It is very likely that under a simple component-wise comparison, H1 and H2 arenow no longer equivelent.  Worse yet, I can readily construct situations inmulti-processing or interruptable environments in which a simple component-wisecomparison implementation of EQUALP will return false for (equalp x x), where xis an eq hash-table.So we have an existance proof of an ill-defined case.  I think you'll have ahard time convincing me either that this is the only such case or that theseproblems don't arise in "user code".  And it seems to me quite likely that theset of problem cases will vary between implementations.  What do we do withsuch things?  I'm afraid I don't have what I consider to be a good answer.  Isuppose we could punt by saying that EQUALP does component-wise comparisonsalways, and add a caveat that this isn't necessarily useful or even "correct"for some datatypes in some implementations.  I don't think we can say anythingabout signaling errors in the bad cases, since if user-defined objects can havethese problems then there really isn't a way to detect when to signal.Besides, I sort of dislike the idea of an equality predicate which signalserrors. kab-------*start*01047 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 09 JAN 89 22:02:36 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01692g; Mon, 9 Jan 89 21:59:21 PSTReceived: by bhopal id AA12192g; Mon, 9 Jan 89 22:01:37 PSTDate: Mon, 9 Jan 89 22:01:37 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901100601.AA12192@bhopal>To: masinter.paCc: IIM%ECLA@ECLC.USC.EDU, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 9 Jan 89 11:19 PST <890109-112039-4344@Xerox>Subject: Issue: EQUAL-STRUCTURE (Version 5)Some months back, John Rose made a suggestion that two hashtables shouldonly be considered "equivalent" (for constant coalescing purposes) ifthere are equal on a component-by-component basis; _and_ where componentindexing is by the set of hash-table keys.  Several people (includingmyself) supported this view, even though it makes descent into hashtables a bit more complex than descent into simpler structures.-- JonL --*start*00478 00024 US Date:  9 Jan 89 22:30 PSTFrom: masinter.paSubject: Re: Issue: EQUAL-STRUCTURE (Version 5)In-reply-to: Jon L White <jonl@lucid.com>'s message of Mon, 9 Jan 89 22:01:37 PSTTo: Jon L White <jonl@lucid.com>cc: masinter.pa, IIM%ECLA@ECLC.USC.EDU, cl-cleanup@sail.stanford.eduWhat is current practice in this area? What does EQUALP do in current implementations on hash tables?I'd wouldn't want to make everybody extend EQUALP where nobody does it.*start*00840 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 22:33:13 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Jan 89  22:33:07 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 JAN 89 22:30:56 PSTDate: 9 Jan 89 22:30 PSTFrom: masinter.paSubject: Re: Issue: EQUAL-STRUCTURE (Version 5)In-reply-to: Jon L White <jonl@lucid.com>'s message of Mon, 9 Jan 89 22:01:37 PSTTo: Jon L White <jonl@lucid.com>cc: masinter.pa, IIM%ECLA@ECLC.USC.EDU, cl-cleanup@sail.stanford.eduMessage-ID: <890109-223056-5490@Xerox>What is current practice in this area? What does EQUALP do in currentimplementations on hash tables?I'd wouldn't want to make everybody extend EQUALP where nobody does it.*start*01925 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 01:49:51 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 10 Jan 89  01:49:51 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01844g; Tue, 10 Jan 89 01:45:37 PSTReceived: by bhopal id AA12606g; Tue, 10 Jan 89 01:47:53 PSTDate: Tue, 10 Jan 89 01:47:53 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901100947.AA12606@bhopal>To: masinter.paCc: IIM%ECLA@ECLC.USC.EDU, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 9 Jan 89 22:30 PST <890109-223056-5490@Xerox>Subject: Issue: EQUAL-STRUCTURE (Version 5)re: What is current practice in this area? What does EQUALP do in current    implementations on hash tables?Lucid does something slightly wrong -- it descends component-wise usingan arbitrary indexing into each table.  Thus it will be guaranteed toget the wrong answer when the two tables contain the same data, butwere built up in differing orders such that the collision chainsare different [for any reasonable hashing implementation, you canfind an example of this].It would be about a 5-minute job to fix it (i.e. to do the codingfor a fix, and minimal checkout).  Of course this would require a QAstep for any commercial implementation, so that is the painful part.I suspect the reason we have never fixed it is that:  -- So far, no customer/user has discovered the anomaly; or at least,      no one is aware of a bug in their program due to this anomaly.  -- Neither CLtL, nor Guy's "Clarifications" of 6-Dec-85, nor current     Cl-cleanup discussions, have brought a sense of inevitability to     the issue yet.In short, I don't recommend Lucid's current practice or experience ashaving any informational value here.-- JonL --*start*06242 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 14:31:31 PSTReceived: from SAPSUCKER.SCRC.Symbolics.COM ([128.81.41.223]) by SAIL.Stanford.EDU with TCP; 11 Jan 89  12:22:39 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by SAPSUCKER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 268293; Wed 11-Jan-89 14:42:07 ESTDate: Wed, 11 Jan 89 14:39 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EQUAL-STRUCTURE (Version 6)To: CL-Cleanup@SAIL.Stanford.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <890111143950.8.KMP@BOBOLINK.SCRC.Symbolics.COM>Here's another draft. I changed only the proposal part. It triesto correct the EQUALP problem we and others mentioned in mail.Please read this very carefully before voting in favor of it.There were a lot of Yes votes for the last version, which I thinkhad some serious bugs in it. This would be a very bad issue forus to screw up.Things that might need special attention: - Moon contends that standard practice in Symbolics Lisp is   for instances to be compared using EQ under EQUALP, not by   descending. There may be performance issues involved here.   Some agreement needs to be reached. - Neither the previous version of the proposal nor CLtL was   clear on what happens to pathnames under EQUALP. This showed   up when I converted the presentation below. That issue should   be addressed as well.Hopefully if this version of the proposal isn't something you want tovote yes for, at least it's in a suitable form for easy line-itemchanges interactively in the meeting.-----Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CLARIFICATION/CHANGEEdit history: 18-Mar-88, Version 1 by Pitman	      08-Jun-88, Version 2 by Masinter (add Benson's proposal)	      23-Sep-88, Version 3 by Masinter (remove all but STATUS-QUO)	      01-Oct-88, Version 4 by Masinter (fix description)	      01-Oct-88, Version 5 by Pitman   (correct wording, add discussion)	      11-Jan-89, Version 6 by Pitman   (attempt EQUALP correction)Problem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:STATUS-QUO):  Clarify that EQUAL and EQUALP do not descend any structures or data types  other than the ones explicitly specified in CLtL.   Type				EQUAL Behavior		EQUALP Behavior    Number			uses EQL		uses =   Character			uses EQL		uses CHAR-EQUAL   Cons				descends		descends   Bit-Vector			descends		descends   String			descends		descends   Pathname			magic per CLtL		same as EQUAL   Structure			uses EQ			descends   other Array			uses EQ			descends   Instance (Standard-Object)	uses EQ			descends   Hash-Table    		uses EQ			uses EQ   Other			uses EQ			uses EQ  Note that the order of this table is in some cases important, with upper  entries taking priority over lower ones.Rationale:  There seem to be as many different equality primitives as there  are applications for them. None of the possible ways of changing  EQUAL or EQUALP are flawless. Given the inability to "fix" them,  it is better to leave them alone.Current Practice:  We are unaware of any extensions to CLtL's set of operations,  although frequently users request them.Cost to Implementors:  Since this seems to be compatible with the status quo, none.Cost to Users:  SameCost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  There seems to be wide debate about what the proper aesthetics for  how equality should work in Common Lisp. While the status quo is not  aesthetically more pleasing than the various alternatives, aesthetic  considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.Discussion:  An earlier version of this issue with various alternatives was distributed  at the June 1988 X3J13 meeting. Since  this is a frequently raised issue, we thought we should submit it  as a clarification although there is no change to CLtL.  Options for which we considered proposals were:    - removing EQUAL and EQUALP from the standard.    - changing EQUALP to descend structures.    - changing EQUALP to be case sensitive.    - adding a :TEST keyword to EQUAL.    - making EQUAL a generic function  All of these had some serious problems.  The cleanup committee supports option STATUS-QUO.  It would be useful if descriptions of EQUAL and EQUALP contained some sort  of additional commentary alluding to the complex issues discussed here.  The following is offered to the Editorial staff as a starting point:    Object equality is not a concept for which there is a uniquely    determined correct algorithm. The appropriateness of an equality    predicate can be judged only in the context of the needs of some    particular program. Although these functions take any type of    argument and their names sound very generic, EQUAL and EQUALP are    not appropriate for every application. Any decision to use or not    use them should be determined by what they are documented to do    rather than any abstract characterization of their function. If    neither EQUAL nor EQUALP is found to be appropriate in a particular    situation, programmers are encouraged to create another operator    that is appropriate rather than blame EQUAL or EQUALP for ``doing    the wrong thing.''*start*06335 00024 US Date: 12 Jan 89 00:12 PSTSender: masinter.paSubject: Issue: EQUAL-STRUCTURE, (Version 6)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinterline-fold: NoPlease see the Additional Comments at the end. Several peoplenoted problems with Version 5.Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CLARIFICATION/CHANGEEdit history: 18-Mar-88, Version 1 by Pitman	      08-Jun-88, Version 2 by Masinter (add Benson's proposal)	      23-Sep-88, Version 3 by Masinter (remove all but STATUS-QUO)	      01-Oct-88, Version 4 by Masinter (fix description)	      01-Oct-88, Version 5 by Pitman   (correct wording, add discussion)	      11-Jan-89, Version 6 by Pitman   (attempt EQUALP correction)Problem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:MAYBE-STATUS-QUO):  Clarify that EQUAL and EQUALP do not descend any structures or data types  other than the ones explicitly specified in CLtL.   Type				EQUAL Behavior		EQUALP Behavior    Number			uses EQL		uses =   Character			uses EQL		uses CHAR-EQUAL   Cons				descends		descends   Bit-Vector			descends		descends   String			descends		descends   Pathname			magic per CLtL		same as EQUAL   Structure			uses EQ			descends   other Array			uses EQ			descends   Instance (Standard-Object)	uses EQ			descends   Hash-Table    		uses EQ			uses EQ   Other			uses EQ			uses EQ  Note that the order of this table is in some cases important, with upper  entries taking priority over lower ones.Rationale:  There seem to be as many different equality primitives as there  are applications for them. None of the possible ways of changing  EQUAL or EQUALP are flawless. Given the inability to "fix" them,  it is better to leave them alone.Current Practice:  We are unaware of any extensions to CLtL's set of operations,  although frequently users request them.Cost to Implementors:  Since this seems to be compatible with the status quo, none.Cost to Users:  SameCost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  There seems to be wide debate about what the proper aesthetics for  how equality should work in Common Lisp. While the status quo is not  aesthetically more pleasing than the various alternatives, aesthetic  considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.Discussion:  An earlier version of this issue with various alternatives was distributed  at the June 1988 X3J13 meeting. Since  this is a frequently raised issue, we thought we should submit it  as a clarification although there is no change to CLtL.  Options for which we considered proposals were:    - removing EQUAL and EQUALP from the standard.    - changing EQUALP to descend structures.    - changing EQUALP to be case sensitive.    - adding a :TEST keyword to EQUAL.    - making EQUAL a generic function  All of these had some serious problems.  The cleanup committee supports option STATUS-QUO.  It would be useful if descriptions of EQUAL and EQUALP contained some sort  of additional commentary alluding to the complex issues discussed here.  The following is offered to the Editorial staff as a starting point:    Object equality is not a concept for which there is a uniquely    determined correct algorithm. The appropriateness of an equality    predicate can be judged only in the context of the needs of some    particular program. Although these functions take any type of    argument and their names sound very generic, EQUAL and EQUALP are    not appropriate for every application. Any decision to use or not    use them should be determined by what they are documented to do    rather than any abstract characterization of their function. If    neither EQUAL nor EQUALP is found to be appropriate in a particular    situation, programmers are encouraged to create another operator    that is appropriate rather than blame EQUAL or EQUALP for ``doing    the wrong thing.''Additional Comments to Version 6:Version 6 attempts to fix some of the problems noted in Version 5.There are still some open questions. Only the "Proposal"part has been changed since Version 5; some of the costs,benefits & other discussion is now incorrect.Kent says:Please read this very carefully before voting in favor of it.There were a lot of Yes votes for the last version, which I thinkhad some serious bugs in it. This would be a very bad issue forus to screw up.Things that might need special attention: - Moon contends that standard practice in Symbolics Lisp is   for instances to be compared using EQ under EQUALP, not by   descending. There may be performance issues involved here.   Some agreement needs to be reached. - Neither the previous version of the proposal nor CLtL was   clear on what happens to pathnames under EQUALP. This showed   up when I converted the presentation below. That issue should   be addressed as well.Hopefully if this version of the proposal isn't something you want tovote yes for, at least it's in a suitable form for easy line-itemchanges interactively in the meeting.        TITAN 
         TITAN 
          K                                                l                     -                                  l              A              	              M       
                    L             O       "      U      c z*start*01484 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 09:57:24 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 12 Jan 89  09:53:43 PSTReceived: by ti.com id AA15540; Thu, 12 Jan 89 11:52:41 CSTReceived: from Kelvin by tilde id AA23022; Thu, 12 Jan 89 11:32:26 CSTMessage-Id: <2809618485-9099259@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Thu, 12 Jan 89 11:34:45 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: EQUAL-STRUCTURE (Version 6)In-Reply-To: Msg of Wed, 11 Jan 89 14:39 EST from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>>  - Moon contends that standard practice in Symbolics Lisp is>    for instances to be compared using EQ under EQUALP, not by>    descending. There may be performance issues involved here.>    Some agreement needs to be reached.It is also true on the Explorer that Flavor instances are not descended byEQUALP.  However, I imagine that this was just an oversight in the addition ofEQUALP to the implementation, and am of the opinion that it would be better ifit did compare the components.  The only problem I can think of with doing thatis handling unbound slots; perhaps it needs to be specified that two unboundslots are EQUALP and an unbound slot is never EQUALP to a bound slot.*start*01075 00024 US Return-Path: <Gray@DSG.csc.ti.com>Received: from ti.com ([10.7.0.46]) by Xerox.COM ; 12 JAN 89 09:35:11 PSTReceived: by ti.com id AA15485; Thu, 12 Jan 89 11:36:17 CSTReceived: from Kelvin by tilde id AA22767; Thu, 12 Jan 89 11:18:47 CSTMessage-Id: <2809617663-9049854@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Thu, 12 Jan 89 11:21:03 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: masinter.paCc: Jon L White <jonl@lucid.com>, IIM%ECLA@ECLC.USC.EDU, cl-cleanup@sail.stanford.eduSubject: Re: Issue: EQUAL-STRUCTURE (Version 5)In-Reply-To: Msg of 9 Jan 89 22:30 PST from masinter.pa@Xerox.COM> What is current practice in this area? What does EQUALP do in current> implementations on hash tables?It turns out that the Explorer attempts to compare the contents of non-EQ hashtables of the same size but gets an error in the process.  Since no one hasreported this bug before, it appears that no one has been trying to use EQUALPon hash tables.  Might as well take the easy way out and specify that hashtables are only compared by EQ.*start*03019 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 16:32:20 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Jan 89  16:31:25 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 521402; Fri 13-Jan-89 19:26:40 ESTDate: Fri, 13 Jan 89 19:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: EQUAL-STRUCTURE (Version 6)To: David N Gray <Gray@DSG.csc.ti.com>cc: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <2809618485-9099259@Kelvin>Message-ID: <19890114002629.3.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 12 Jan 89  11:34:45 CST    From: David N Gray <Gray@DSG.csc.ti.com>    >  - Moon contends that standard practice in Symbolics Lisp is    >    for instances to be compared using EQ under EQUALP, not by    >    descending. There may be performance issues involved here.    >    Some agreement needs to be reached.    It is also true on the Explorer that Flavor instances are not descended by    EQUALP.  However, I imagine that this was just an oversight in the addition of    EQUALP to the implementation, and am of the opinion that it would be better if    it did compare the components.  The only problem I can think of with doing that    is handling unbound slots; perhaps it needs to be specified that two unbound    slots are EQUALP and an unbound slot is never EQUALP to a bound slot.I really feel that it is badly wrong for EQUALP to descend intocomponents of "standard-objects."  That is an utter violation ofabstraction.  Only the designer of the class knows what makes twoobjects equivalent.  It might depend on information representedelsewhere than in slots.  It might depend on only some of the slots.Instances of one class might be equivalent to instances of a differentclass in some cases.  This is not an implementation issue, not aperformance issue, and not an oversight; it is a fundamental issueof abstraction and semantics.I see only three ways to cope with this:(1) Make EQUALP a generic function, and control its behavior withmultimethods.(2) Make EQUALP do something with standard-objects that's not alwaysuseful and is often dangerous.  That could be use EQ, descend, orsignal an error.  Of the three, using EQ is best since it's compatiblewith EQUAL.(3) Eliminate EQUALP on the grounds that it is an ill-defined concept.Instead, use application-specific equality predicates defined by theuser as needed.Interestingly, the proposal section of the referenced proposal saysthat EQUALP is changed to descend into structures, but the discussionsection says that changing EQUALP to descend into structures wasconsidered and rejected on the grounds that it had serious problems.I think the discussion is right.*start*02430 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 MAR 89 20:32:48 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 1 Mar 89  20:29:13 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02115g; Wed, 1 Mar 89 20:22:38 PSTReceived: by bhopal id AA19722g; Wed, 1 Mar 89 20:25:00 PSTDate: Wed, 1 Mar 89 20:25:00 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8903020425.AA19722@bhopal>To: IIM@ECLA.USC.EDUCc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: Kim A. Barrett's message of Tue 28 Feb 89 13:44:16-PST <12474359674.19.IIM@ECLA.USC.EDU>Subject: Issue EQUAL-STRUCTUREre: [incompatibly changing EQUALP on defstruct instances]    I believe you yourself have taken a position on some    issues that the status quo is wrong and needs to be fixed.Right.  But the issue here is whether the fix is:  (1) to drastically rip up the current default behaviour, or  (2) to provide mechanisms that allow users to modify behaviour      [and presumably, he gets the "default" if he doesn't do so].I've been favoring (2) over (1).So as-and-when an EQUALP-GENERIC issues comes out, I would favorretaining the default behaviour for the various broad meta-classes:  (1) BUILT-IN-CLASS: behaviour for objects from this metaclass are       already detailed in CLtL, on a class-by-class (type-by-type?)      basis;  (2) STRUCTURE-CLASS: again, CLtL fairly directly specifies a default      behaviour that needn't be incompatibly changed;  (3) STANDARD-CLASS: I'm not sure if 88-002R spells it out, but I thought      the consensus was that the default behaviour should be to signal      an error [i.e., you shouldn't let it get that far].  Defaulting to      EQL would probably be workable too, but wouldn't be as much help      in finding obscure bugs.  (4) RANDOM-{user-defined}META-CLASS: Might as well take the same tack as       for STANDARD-CLASS, since that is nearly as stringent as possible.After all, that's what classes (and classes of classes, or "meta-classes") are for -- to separate out just the parts you want to be different.  Andcurrently, I don't see any reason to merge instances of STRUCTURE-OBJECTin with those of STANDARD-OBJECT [yes, I know, "STRUCTURE-OBJECT" is a bitof a neolgism, but one needs the term].-- JonL --*start*01568 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 MAR 89 20:55:14 PSTReceived: from ECLC.USC.EDU by SAIL.Stanford.EDU with TCP; 1 Mar 89  20:55:36 PSTDate: Tue, 28 Feb 89 13:44:16 PSTFrom: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>Subject: Issue EQUAL-STRUCTURETo: JonL@LUCID.COMcc: cl-cleanup@SAIL.STANFORD.EDU, iim%ECLA@ECLC.USC.EDUMessage-ID: <12474359674.19.IIM@ECLA.USC.EDU>> Date: Fri, 24 Feb 89 01:46:12 PST> From: Jon L White <jonl@lucid.com>>> Kim, don't you have something turned around here?  Previous mail referred to> CLtL p81 to show that defstruct instances should be descended componentwise> by EQUALP.  This is not a statement about classes in general -- just about> structure-class, and its historic meaning under EQUALP.  Thus the Hawaii> amendment was an *incompatible* change (which has already raised some> question in Lucid's customer land!). This incompatible change unfortunately> does nothing at all towards supplying the "mechanisms" you call for, and in> fact breaks some existing code (in a very inscrutable way).I stand by what I said.  I believe you yourself have taken a position on someissues that the status quo is wrong and needs to be fixed.> Given the failure to make EQUALP generic, wouldn't it be far better to leave> it alone and not make backwards-incompatible changes which do no one any> good? See new Issue EQUALP-GENERIC, coming soon to a mailbox near you.kab-------*start*01697 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 MAR 89 17:40:42 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 4 Mar 89  17:41:25 PSTDate: Sat, 4 Mar 89 17:39:06 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue EQUAL-STRUCTURETo: JonL@LUCID.COMcc: cl-cleanup@SAIL.STANFORD.EDU, iim@ECLA.USC.EDUMessage-ID: <12475451000.30.IIM@ECLA.USC.EDU>> Date: Wed, 1 Mar 89 20:25:00 PST> From: Jon L White <jonl@lucid.com>>> But the issue here is whether the fix is:>   (1) to drastically rip up the current default behaviour, or>   (2) to provide mechanisms that allow users to modify behaviour>       [and presumably, he gets the "default" if he doesn't do so].> I've been favoring (2) over (1).You're making me sound like an ogre.  I certainly favor allowing users tomodify behaviour.  What we disagree about is what the default behaviour shouldbe.  I firmly believe that specifying component-wise processing as the defaultfor any protocol applicable to user defined classes is wrong.  Without anunderstanding of a class there is no way to know which features of an instanceare 'interesting' and which are merely artifacts of the implementation, or evenhow to find the interesting features (they may not be stored as elements in theinstance).I don't plan on saying anything further on this issue.  I think we've bothpresented our arguments, and its now beginning to sound like theologicaldebate.  If you want us to modify/retract the decision made in Hawaii, generatea cleanup issue and we can all vote on it.kab-------*start*02357 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 MAR 89 10:10:44 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 6 Mar 89  10:05:52 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa00906; 6 Mar 89 16:53 GMTDate: Mon, 6 Mar 89 17:21:27 GMTMessage-Id: <19592.8903061721@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue EQUAL-STRUCTURETo: "Kim A. Barrett" <IIM@ecla.usc.edu>, JonL <@sail.stanford.edu:JonL@lucid.com>In-Reply-To: Kim A. Barrett's message of Sat 4 Mar 89 17:39:06-PSTCc: cl-cleanup@sail.stanford.edu> I firmly believe that specifying component-wise processing as the default> for any protocol applicable to user defined classes is wrong.  Without an> understanding of a class there is no way to know which features of> an instance are 'interesting' and which are merely artifacts of the> implementation, or even how to find the interesting features (they> may not be stored as elements in the instance).I know I shouldn't enter such debates at such a late date, but I don'tthink this issue is as clear-cut as some seem to believe.  While whatKim says about instances is true, we have to remember that that we'retalking about EQUALP.  EQUALP isn't supposed to do the one true rightthing; it's just supposed to be a sometimes useful combination.  Andno one has to use it when it's inappropriate.  Many users want anequality comparison that descends structs, and they used to have one(thought they may not have known it).The whole argument turns around structs being user-defined classes.After all, we're all willing to allow EQUALP on lists; and even forlists there's no way to be sure what parts are really significant(because, as always, this information is in the programmer's head)or where all parts are kept (hash tables work for lists too).But consistency with instances of classes with metaclass standardclass is just one of the factors we have to consider.  Is it better(or more useful) to make struct classes be like standard classesminus some flexibility or to make them like structures in the oldsense plus the ability to define methods?-- Jeff*start*07231 00024 US GV-Info: masinter.pa at 15-Mar-89 05:43:21 from massunterDate: 15 Mar 89 05:42 PSTFrom: masinter.paSubject: Issue: EQUAL-STRUCTURE (Version 7)To: cl-cleanup@Sail.Stanford.Educc: masinterline-fold: NoThis is what I believe was voted in at the last meeting.I'm not sure why we started discussing it again, butI didn't see anything in the discussion that looked likea proposal to revisit this issue.Status:	Passed as amended, Jan 89 X3J13Issue:        EQUAL-STRUCTUREReferences:   EQUAL (p80), EQUALP (p81)Category:     CLARIFICATION/CHANGEEdit history: 18-Mar-88, Version 1 by Pitman	      08-Jun-88, Version 2 by Masinter (add Benson's proposal)	      23-Sep-88, Version 3 by Masinter (remove all but STATUS-QUO)	      01-Oct-88, Version 4 by Masinter (fix description)	      01-Oct-88, Version 5 by Pitman   (correct wording, add discussion)	      11-Jan-89, Version 6 by Pitman   (attempt EQUALP correction)		15-Mar-89, Version 7 by Masinter (amended as per vote at Jan 89 X3J13)Problem Description:  The behavior of EQUAL and EQUALP on structures is a subject of controversy.  At issue are whether these functions should descend the slots of structures  or use simply the structure's primitive identity (i.e., EQ) to test for  equivalence.Proposal (EQUAL-STRUCTURE:MAYBE-STATUS-QUO):  Clarify that EQUAL and EQUALP do not descend any structures or data types  other than the ones explicitly specified in CLtL.   Type                     EQUAL Behavior        EQUALP Behavior    Number                     uses EQL               uses =   Character                  uses EQL               uses CHAR-EQUAL   Cons                       descends               descends   Bit-Vector                 descends               descends   String                     descends               descends   Pathname                   magic per CLtL         same as EQUAL   Structure                  uses EQ                uses EQ   other Array                uses EQ                descends   Hash-Table                 uses EQ                (see below)   Instance (Standard-Object) uses EQ                uses EQ   Other                      uses EQ                uses EQ  Note that the order of this table is in some cases important, with upper  entries taking priority over lower ones.  EQUALP descends hash tables by first comparing the count of entries  and the :TEST function; if those are the same, it compares the  keys of the tables using the :TEST function and then the values  of the matching keys using EQUALP recursively.Rationale:  There seem to be as many different equality primitives as there  are applications for them. None of the possible ways of changing  EQUAL or EQUALP are flawless. Given the inability to "fix" them,  it is better to leave them alone.Current Practice:  We are unaware of any extensions to CLtL's set of operations,  although frequently users request them.Cost to Implementors:  Since this seems to be compatible with the status quo, none.Cost to Users:  SameCost of Non-Adoption:  Ongoing controversy about whether EQUAL and EQUALP "do the right thing".Benefits:  A feeling that EQUAL and EQUALP exist and/or do what they do because serious  consideration was given and we consciously decided on a particular resolution  to the numerous questions that have come up about them.Aesthetics:  There seems to be wide debate about what the proper aesthetics for  how equality should work in Common Lisp. While the status quo is not  aesthetically more pleasing than the various alternatives, aesthetic  considerations vary widely. Different people model structures  differently. Sometimes the same person models structures differently in  different situations. The question of which should be descended and which  should not is a very personal one, and the aesthetic attractiveness of any  of these options will vary from person to person or application to  application.Discussion:  An earlier version of this issue with various alternatives was distributed  at the June 1988 X3J13 meeting. Since  this is a frequently raised issue, we thought we should submit it  as a clarification although there is no change to CLtL.  Options for which we considered proposals were:    - removing EQUAL and EQUALP from the standard.    - changing EQUALP to descend structures.    - changing EQUALP to be case sensitive.    - adding a :TEST keyword to EQUAL.    - making EQUAL a generic function  All of these had some serious problems.  The cleanup committee supports option STATUS-QUO.  It would be useful if descriptions of EQUAL and EQUALP contained some sort  of additional commentary alluding to the complex issues discussed here.  The following is offered to the Editorial staff as a starting point:    Object equality is not a concept for which there is a uniquely    determined correct algorithm. The appropriateness of an equality    predicate can be judged only in the context of the needs of some    particular program. Although these functions take any type of    argument and their names sound very generic, EQUAL and EQUALP are    not appropriate for every application. Any decision to use or not    use them should be determined by what they are documented to do    rather than any abstract characterization of their function. If    neither EQUAL nor EQUALP is found to be appropriate in a particular    situation, programmers are encouraged to create another operator    that is appropriate rather than blame EQUAL or EQUALP for ``doing    the wrong thing.''Additional Comments to Version 6:Version 6 attempts to fix some of the problems noted in Version 5.There are still some open questions. Only the "Proposal"part has been changed since Version 5; some of the costs,benefits & other discussion is now incorrect.Kent says:Please read this very carefully before voting in favor of it.There were a lot of Yes votes for the last version, which I thinkhad some serious bugs in it. This would be a very bad issue forus to screw up.Things that might need special attention: - Moon contends that standard practice in Symbolics Lisp is   for instances to be compared using EQ under EQUALP, not by   descending. There may be performance issues involved here.   Some agreement needs to be reached. - Neither the previous version of the proposal nor CLtL was   clear on what happens to pathnames under EQUALP. This showed   up when I converted the presentation below. That issue should   be addressed as well.Hopefully if this version of the proposal isn't something you want tovote yes for, at least it's in a suitable form for easy line-itemchanges interactively in the meeting.     ----- End Forwarded Messages -----        TITAN 
          TITAN 
        9 +(DEFAULTFONT 1 (GACHA 12) NIL (TERMINAL 8))            :                                                                           -                                  l              A              	              M       
                    L             O       "      V       )        z