*start*01105 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 SEP 88 22:35:56 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 18 Sep 88  22:35:33 PDTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA03000g; Sun, 18 Sep 88 21:32:29 PSTReceived: by blacksox id AA00906g; Sun, 18 Sep 88 22:30:10 pdtDate: Sun, 18 Sep 88 22:30:10 pdtFrom: Eric Benson <eb@lucid.com>Message-Id: <8809190530.AA00906@blacksox>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Sun, 18 Sep 88 16:22 EDT <19880918202212.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 1)For current practice:Lucid implements DECLARE-TYPE-FREE:ALLOW already.  The production modeof the compiler gives a warning that this usage is an extension toCommon Lisp.  The interpreter and the development mode of the compilerdon't pay any attention to declarations except SPECIAL, INLINE andNOTINLINE.*start*02431 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 SEP 88 13:25:36 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 18 Sep 88  13:23:39 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 461285; Sun 18-Sep-88 16:22:13 EDTDate: Sun, 18 Sep 88 16:22 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 1)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19880918202212.8.MOON@EUPHRATES.SCRC.Symbolics.COM>I decided to write this up since it has been discussed endlesslywithout a formal proposal, and to make it clear that it isindependent of the pending DECLARATION-SCOPE issue.Issue:         DECLARE-TYPE-FREEReferences:    CLtL p.158Category:      ADDITIONEdit history:  Version 1, 18-Sep-88, MoonProblem description:Most people interpret CLtL's phrase "(TYPE type var1 var2 ...) affectsonly variable bindings" to mean that code such as the following isnot valid Common Lisp, because a type declaration can only be attachedto a binding, not used free.  (if (and (typep x 'fixnum) (typep y 'fixnum))      (locally (declare (fixnum x y))        ...algorithm using x and y...)      ...similar algorithm using x and y...)Proposal (DECLARE-TYPE-FREE:ALLOW):Change the phrase "affects only variable bindings" to "concerns variablebindings."  Clarify that this makes the above program a valid programand that this kind of declaration means the same thing as insertingTHE in every reference to the variable and every setq of the variable.Rationale:There is no reason to forbid this usage, and people have often askedfor it.Current practice:I don't know.Cost to Implementors:None, it is valid to ignore type declarations.Cost to Users:None, this is a compatible addition.Cost of non-adoption:Common Lisp will be less self-consistent.Benefits:The above example will not have to be written in the following silly way,which only works if x and y are used read-only:  (if (and (typep x 'fixnum) (typep y 'fixnum))      (let ((x x) (y y))        (declare (fixnum x y))        ...algorithm using x and y...)      ...similar algorithm using x and y...)Esthetics:Yes.Discussion:None.*start*03774 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 17:21:40 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 20 Sep 88  17:20:53 PDTReceived: by ti.com id AA27117; Tue, 20 Sep 88 19:17:59 CDTReceived: from dsg by tilde id AA10707; Tue, 20 Sep 88 19:13:49 CDTReceived: From Kelvin By dsg Via CHAOS-NET With CHAOS-MAIL; Tue, 20 Sep 88  19:15:00 CDTMessage-Id: <2799792286-10241446@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 20 Sep 88 19:04:46 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: DECLARE-TYPE-FREE (Version 1)In-Reply-To: Msg of Sun, 18 Sep 88 16:22 EDT from "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>>   (if (and (typep x 'fixnum) (typep y 'fixnum))>       (locally (declare (fixnum x y))>         ...algorithm using x and y...)>       ...similar algorithm using x and y...)> > Proposal (DECLARE-TYPE-FREE:ALLOW):> > Change the phrase "affects only variable bindings" to "concerns variable> bindings."  Clarify that this makes the above program a valid program> and that this kind of declaration means the same thing as inserting> THE in every reference to the variable and every setq of the variable.The phrase "concerns variable bindings" still doesn't seem right.  Thereare really two distinct cases:  a declaration associated with a bindingand a local declaration separate from the binding.  The former differsbecause it not only describes the type of values which the variable willassume, but also permits using a specialized representation for thevariable's value cell.Should add that if there is both a binding declaration and a localdeclaration for the type of the same variable, then, within the scope ofthe local declaration, it is an error for the variable to contain a valuewhich is not a member of the intersection of the two types.  (This impliesthat it would be desirable for the compiler to complain if the two typesare disjoint.)> Rationale:> > There is no reason to forbid this usage, and people have often asked> for it.I don't feel good about this because I'm afraid it would encourage usersto make the incorrect assumption that a local declaration is just as goodas a binding declaration.  There will also be some performance penalty inthe compiler for looking up type declarations on a local declaration stackinstead of just having it as part of the variable table entry.> Cost to Implementors:> > None, it is valid to ignore type declarations.But some implementations will have the (admittedly slight) cost ofremoving or updating an error check.  Besides, you really haven't done theuser any favor to allow him to declare types this way if the compiler isjust going to ignore it, so any implementor that uses type declarationsshould feel obligated to support this fully if at all.> Benefits:> > The above example will not have to be written in the following silly way,> which only works if x and y are used read-only:> >   (if (and (typep x 'fixnum) (typep y 'fixnum))>       (let ((x x) (y y))>         (declare (fixnum x y))>         ...algorithm using x and y...)>       ...similar algorithm using x and y...)But there might actually be an advantage to writing it this way.  If youare compiling for a conventional machine and the declarations are becauseyou want the most efficient code generated, then it may be worthwhile tomove the value to a fixnum cell rather than to reference it from a cellthat can hold a tagged object.  On a Lisp Machine where all cells aretagged, the compiler can optimize out the binding.*start*04994 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 18:01:26 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Sep 88  18:00:04 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 462840; Tue 20-Sep-88 20:55:34 EDTDate: Tue, 20 Sep 88 20:55 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 1)To: David N Gray <Gray@DSG.csc.ti.com>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <2799792286-10241446@Kelvin>Message-ID: <19880921005536.3.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 20 Sep 88  19:04:46 CDT    From: David N Gray <Gray@DSG.csc.ti.com>    >   (if (and (typep x 'fixnum) (typep y 'fixnum))    >       (locally (declare (fixnum x y))    >         ...algorithm using x and y...)    >       ...similar algorithm using x and y...)    >     > Proposal (DECLARE-TYPE-FREE:ALLOW):    >     > Change the phrase "affects only variable bindings" to "concerns variable    > bindings."  Clarify that this makes the above program a valid program    > and that this kind of declaration means the same thing as inserting    > THE in every reference to the variable and every setq of the variable.    The phrase "concerns variable bindings" still doesn't seem right.  You're right.  I cribbed that phrase from the preceding page or two in CLtL,but here I was making the mistake of talking about what CLtL should sayrather than about what Common Lisp should be.  I also think the word"binding" should never be used when discussing Lisp, since some peoplethink it relates to LET (i.e. refers to creating a new variable), somepeople think it relates to SYMBOL-VALUE (i.e. refers to the value associatedwith a special variable), and some people think it relates to EVAL (i.e.refers to the value associated with any kind of variable).  How about"concerns the values that a variable may take on"?  The point is thatit is an error for the value of the variable to be not a member of thedeclared type, within the scope of the declaration; all else is editorial.    Should add that if there is both a binding declaration and a local    declaration for the type of the same variable, then, within the scope of    the local declaration, it is an error for the variable to contain a value    which is not a member of the intersection of the two types.  (This implies    that it would be desirable for the compiler to complain if the two types    are disjoint.)True.  Does the proposal really need to say this?  It's a pretty obviousconsequence.								       There    are really two distinct cases:  a declaration associated with a binding    and a local declaration separate from the binding.  The former differs    because it not only describes the type of values which the variable will    assume, but also permits using a specialized representation for the    variable's value cell.    I don't feel good about this because I'm afraid it would encourage users    to make the incorrect assumption that a local declaration is just as good    as a binding declaration.  There will also be some performance penalty in    the compiler for looking up type declarations on a local declaration stack    instead of just having it as part of the variable table entry.I don't understand why you think local declarations forbid specializedrepresentations (within the scope of the declaration) and I don't understandwhy you think a local declaration is somehow inferior to a binding declaration.It seems to me that a type declaration provides some information to the compiler,and what the compiler does with it is not really the business of the Common Lisplanguage specification, and is also rather difficult to discuss without referringto a specific compiler.    > Benefits:    >     > The above example will not have to be written in the following silly way,    > which only works if x and y are used read-only:    >     >   (if (and (typep x 'fixnum) (typep y 'fixnum))    >       (let ((x x) (y y))    >         (declare (fixnum x y))    >         ...algorithm using x and y...)    >       ...similar algorithm using x and y...)    But there might actually be an advantage to writing it this way.  If you    are compiling for a conventional machine and the declarations are because    you want the most efficient code generated, then it may be worthwhile to    move the value to a fixnum cell rather than to reference it from a cell    that can hold a tagged object.I'd rather that the compiler make this transformation, given the informationit needs to be able to do so, than that the users be required to do it byhand.  Of course, I'd rather that no one ever need to do type declarationsby hand in the first place.*start*01616 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 19:20:35 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Sep 88  19:20:22 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 462882; Tue 20-Sep-88 22:18:37 EDTDate: Tue, 20 Sep 88 22:18 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 1)To: Moon@STONY-BROOK.SCRC.Symbolics.COM, Gray@DSG.csc.ti.comcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <19880921005536.3.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <19880918202212.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <880920221824.5.KMP@GRYPHON.SCRC.Symbolics.COM>I generally support the proposal DECLARE-TYPE-FREE:ALLOW and concur withMoon's comments in subsequent discussion to date.To me, the issue is really this: The programmer knows many things abouthis programs. The more things he tells the compiler, the less the compilerhas to infer; in some cases, the information is invaluable because thecompiler would not be able to ever infer it. We should provide ways forusers to say things about their programs when there is a reasonableexpectation that the compiler can do something useful with the information.It seems clear that some compiler writers want to do useful things withthe information in we're talking about letting the user provide, so I thinkwe should allow it.*start*02283 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 SEP 88 09:07:44 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 21 Sep 88  09:06:20 PDTReceived: by ti.com id AA02684; Wed, 21 Sep 88 11:03:55 CDTReceived: from Kelvin by tilde id AA26526; Wed, 21 Sep 88 10:54:55 CDTMessage-Id: <2799849365-13670868@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 21 Sep 88 10:56:05 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: DECLARE-TYPE-FREE (Version 1)In-Reply-To: Msg of Tue, 20 Sep 88 20:55 EDT from David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>>     Should add that if there is both a binding declaration and a local>     declaration for the type of the same variable, then, within the scope of>     the local declaration, it is an error for the variable to contain a value>     which is not a member of the intersection of the two types.  (This implies>     that it would be desirable for the compiler to complain if the two types>     are disjoint.)> > True.  Does the proposal really need to say this?  It's a pretty obvious> consequence.It may be obvious to us, but it probably wouldn't be to the average user.Anyway, I had to stop and think about whether it should be a subtype orjust non-disjoint.> I don't understand why you think local declarations forbid specialized> representations (within the scope of the declaration)It doesn't forbid it, but in order to do it, the compiler would have tocopy the value, but it can only do that if it knows that it is not SETQ'd.It also would require the compiler to count the number of references todecide if the copy is worthwhile.  Thus, while it would be possible for acompiler to do this, it is unlikely for an implementor to go to that muchtrouble.> It seems to me that a type declaration provides some information to the compiler,> and what the compiler does with it is not really the business of the Common Lisp> language specificationAssuming of course that the information is really useful to a compiler;there wouldn't be much point otherwise.*start*02323 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 SEP 88 09:23:58 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Sep 88  09:23:04 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 463200; Wed 21-Sep-88 12:21:12 EDTDate: Wed, 21 Sep 88 12:21 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 1)To: Gray@DSG.csc.ti.com, Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <2799849365-13670868@Kelvin>Message-ID: <880921122104.2.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Wed, 21 Sep 88  10:56:05 CDT    From: David N Gray <Gray@DSG.csc.ti.com>    >     Should add that if there is both a binding declaration and a local    >     declaration for the type of the same variable, then, within the scope of    >     the local declaration, it is an error for the variable to contain a value    >     which is not a member of the intersection of the two types.  (This implies    >     that it would be desirable for the compiler to complain if the two types    >     are disjoint.)    >     > True.  Does the proposal really need to say this?  It's a pretty obvious    > consequence.    It may be obvious to us, but it probably wouldn't be to the average user.    Anyway, I had to stop and think about whether it should be a subtype or    just non-disjoint. ...Well, it just occurred to me that there is an interpretation to even a disjointtype declaration. Consider that the paranoid programmer might try to help outthe compiler's storage allocation phase by recycling a variable for a new typeusing SETQ because he knows it won't be used further in the program but doesn'tknow for sure that the compiler will realize this fact. Here's an example ofthat style: (DEFUN FOO (X Y)   (DECLARE (FLOAT X Y))   (LET ((SUM (+ X Y)))     (DECLARE (FLOAT SUM))     (COND ((> SUM 3.0)	    (LOCALLY (DECLARE (FIXNUM X))	      ; X won't be used any more, so let's recycle its home...	      (SETQ X (TRUNCATE SUM))	      (+ (* X X) (* SUM Y))))	   (T	    (* X Y SUM)))))*start*01805 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 SEP 88 10:11:27 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 21 Sep 88  10:06:37 PDTReceived: by ti.com id AA03090; Wed, 21 Sep 88 12:04:01 CDTReceived: from Kelvin by tilde id AA27566; Wed, 21 Sep 88 11:49:12 CDTMessage-Id: <2799852627-13866831@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 21 Sep 88 11:50:27 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: DECLARE-TYPE-FREE (Version 1)In-Reply-To: Msg of Wed, 21 Sep 88 12:21 EDT from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>> Well, it just occurred to me that there is an interpretation to even a disjoint> type declaration. Consider that the paranoid programmer might try to help out> the compiler's storage allocation phase by recycling a variable for a new type> using SETQ because he knows it won't be used further in the program but doesn't> know for sure that the compiler will realize this fact. Here's an example of> that style:> >  (DEFUN FOO (X Y)>    (DECLARE (FLOAT X Y))>    (LET ((SUM (+ X Y)))>      (DECLARE (FLOAT SUM))>      (COND ((> SUM 3.0)> 	    (LOCALLY (DECLARE (FIXNUM X))> 	      ; X won't be used any more, so let's recycle its home...> 	      (SETQ X (TRUNCATE SUM))> 	      (+ (* X X) (* SUM Y))))> 	   (T> 	    (* X Y SUM)))))Gag!  This is an example of what we most definitely want to prohibit.This is a highly misguided programming style and can be made meaningfulonly if the compiler is prohibited from using specialized storage forvariables.*start*03111 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 SEP 88 10:08:03 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Sep 88  10:07:24 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 464007; Thu 22-Sep-88 13:06:00 EDTDate: Thu, 22 Sep 88 13:05 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 2)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19880922170548.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Issue:         DECLARE-TYPE-FREEReferences:    CLtL p.158Category:      ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)Problem description:  Most people interpret CLtL's phrase "(TYPE type var1 var2 ...) affects  only variable bindings" to mean that code such as the following is  not valid Common Lisp, because a type declaration can only be attached  to a binding, not used free.      (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))	  ...algorithm using x and y...)	...similar algorithm using x and y...)Proposal (DECLARE-TYPE-FREE:ALLOW):    Avoid the phrase "affects only variable bindings".  Clarify that a type  declaration means that it is an error for the value of the variable to  be not a member of the declared type, within the scope of the  declaration.  Clarify that this makes the above program a valid program  and that this kind of declaration means the same thing as inserting  THE in every reference to the variable and every setq of the variable.  Clarify that if nested type declarations refer to the same variable,  the value of the variable must be a member of the intersection of the  declared types.Rationale:  There is no reason to forbid this usage, and people have often asked  for it.Current practice:  Lucid implements DECLARE-TYPE-FREE:ALLOW already, with a warning that  it is an extension to Common Lisp.Cost to Implementors:  None, it is valid to ignore type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  The above example will not have to be written in the following silly way,  which only works if x and y are used read-only:      (if (and (typep x 'fixnum) (typep y 'fixnum))	(let ((x x) (y y))	  (declare (fixnum x y))	  ...algorithm using x and y...)	...similar algorithm using x and y...)Esthetics:  This provides a clean and simple way for the programmer to express what  she knows about the values a variable may take on within a certain  region of the program.  Different compilers will use this information in  different ways; it's most aesthetic for the portable language to be free  of assumptions about how the compiler will use this information.Discussion:  None.*start*04594 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 SEP 88 19:23:38 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 22 Sep 88  19:23:00 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA07152g; Thu, 22 Sep 88 18:20:49 PSTReceived: by bhopal id AA07675g; Thu, 22 Sep 88 19:20:19 PDTDate: Thu, 22 Sep 88 19:20:19 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809230220.AA07675@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: GLS@Think.com, CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Sun, 18 Sep 88 16:22 EDT <19880918202212.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 1)A number of comments on this first draft:----I raised this issue at the Fort Collins meeting last November, suggesting that it was an unintended aberration in CLtL.  But Guy Steele quickly defended it, and promised to write down his objection to the "ALLOW" interpretation and mail them out (this was in a plenary session, and was only partially relevant to the item under discussion.)  To date, I don't recall seeing his objections, but he should cough them up now or forever hold his peace.----The current statement of "the problem" isn't really right.  Until you wrote it in this message, I don't remember people saying that they thought locally type declarations were "not valid Common Lisp".  Rather, they were thoughtto be un-useful declarations, since the compiler is forbidden to treat variable references differently based on cognizance of that declaration [i.e. declaration can affect "bindings", but not "references"].   In fact,none of the half-dozen or so implementations I've tried this on during thepast year issued any warning or error in such cases.  This is not to say that at least some people didn't think it was "invalid"; merely that the statistical sample leans toward the "un-useful" side.  [Please, gang, no puns on that last sentence.]----The proposal says:    Change the phrase "affects only variable bindings" to "concerns variable    bindings."  . . . Is this really an improvement?  the change seems to have the exactly thesame potential for misinterpretation as the original.  Admittedly, with the subsequent clarification, one is less inclined to think so; then again,one might simply think the specification is inconsistent.----Surely, the matter must be related somewhat to the issue of how a compiled local variable will be implemented.  Pdp10 MacLisp would "home" fixnum and flonum variables on stacks distinct from the one normally used for functioncall frames (or "activation records" or whatever you favorite buzz word forthis concept).  These alternate stacks -- the FXPDL and FLPDL -- were incapable of holding data not of the declared type; so in that world:      (let ((x <some-value>))        (declare (fixnum x))	(somehow-ignore x)	(setq x 5)        ...)would be compiled radically differently from:      (let ((x <some-value>))        (locally (declare (fixnum x))	  (somehow-ignore x)	  (setq x 5)          ...))since the former implementationally restricts the value of <some-value> to be a fixnum, whereas the latter permits it to be, for one instant at the time of binding, any old random type.  The S1/NIL implementation expected to have a "pdlnum" scheme similar to pdp10 MacLisp's, so I wouldthink that CLtL's restriction is due to Guy's experience in trying to accommodate this implementational technique.   At the very least, the proposal needs to show cognizance of the difference between a compiler'stype information propogation (and inferencing) and of the constraints imposed by the compiler's choice of "slots" to hold variables' values.However, I don't believe any vendor today except Lucid employs thisimplementational technique; and Lucid has already long since jumped ahead on this mater to give the locally type declarations theirobvious meaning -- namely, semantically equivalent to wrapping a(the <type-specifier> ...) around each reference to the variable.[Incidentally, in Lucid's implementation, the semantic difficulty refered to in the previous paragraph -- about "affecting the binding" -- manifests itself as a performance pessimization rather than any inconsistency or incorrectness in the code.  so it says here.]Some thoughts like these ought to be in the proposal before it issubmitted to the committee as a whole.-- JonL --*start*03969 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 SEP 88 22:30:53 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 22 Sep 88  22:30:07 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 22 SEP 88 22:25:53 PDTDate: 22 Sep 88 22:25 PDTFrom: masinter.paSubject: Issue: DECLARE-TYPE-FREE (Version 3)To: CL-Cleanup@sail.stanford.eduMessage-ID: <880922-222553-3848@Xerox>I added a reference to DECLARATION-SCOPE. I added a Discussion section. Ichanged "Most people interpret..." to "Some people interpret..." in the problemdiscussion, since we need not argue about how many people think that it is validCommon Lisp.Ready for release? (regrets only, please)!Issue:         DECLARE-TYPE-FREEReferences:    CLtL p.158		DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)		Version 3, 22-Sep-88, Masinter		Problem description:  Some people interpret CLtL's phrase "(TYPE type var1 var2 ...) affects  only variable bindings" to mean that code such as the following is  not valid Common Lisp, because a type declaration can only be attached  to a binding, not used free.      (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))	  ...algorithm using x and y...)	...similar algorithm using x and y...)Proposal (DECLARE-TYPE-FREE:ALLOW):    Avoid the phrase "affects only variable bindings".  Clarify that a type  declaration means that it is an error for the value of the variable to  be not a member of the declared type, within the scope of the  declaration.  Clarify that this makes the above program a valid program  and that this kind of declaration means the same thing as inserting  THE in every reference to the variable and every setq of the variable.  Clarify that if nested type declarations refer to the same variable,  the value of the variable must be a member of the intersection of the  declared types.Rationale:  There is no strong reason to forbid this usage, and people have   often asked  for it.Current practice:  Lucid implements DECLARE-TYPE-FREE:ALLOW already, with a warning that  it is an extension to Common Lisp.Cost to Implementors:  None, it is valid to ignore type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  The above example will not have to be written in the following silly way,  which only works if x and y are used read-only:      (if (and (typep x 'fixnum) (typep y 'fixnum))	(let ((x x) (y y))	  (declare (fixnum x y))	  ...algorithm using x and y...)	...similar algorithm using x and y...)Esthetics:  This provides a clean and simple way for the programmer to express what  she knows about the values a variable may take on within a certain  region of the program.  Different compilers will use this information in  different ways; it's most aesthetic for the portable language to be free  of assumptions about how the compiler will use this information.Discussion:Another cleanup issue, DECLARATION-SCOPE, addresses the scope of declarations. This proposal carefully uses the phrase "within the scope of the declaration" to avoid confounding the two issues. This issue has been discussed at length. There is some possibility that current implementations might be able to generate more efficient code when declarations are associated with a particular binding, e.g., (let ((x v)) (declare (type fixnum x)) (+ x x))might be more efficient than(let ((x v)) (locally (declare (type fixnum x)) (+ x x)))However, the local type declarations allowed by this proposal do provide useful information even when it is not the *most* useful.*start*01241 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 SEP 88 22:48:59 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 22 Sep 88  22:48:57 PDTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA07223g; Thu, 22 Sep 88 21:47:10 PSTReceived: by blacksox id AA01432g; Thu, 22 Sep 88 22:44:55 pdtDate: Thu, 22 Sep 88 22:44:55 pdtFrom: Eric Benson <eb@lucid.com>Message-Id: <8809230544.AA01432@blacksox>To: masinter.paCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 22 Sep 88 22:25 PDT <880922-222553-3848@Xerox>Subject: Issue: DECLARE-TYPE-FREE (Version 3)   Date: 22 Sep 88 22:25 PDT   From: masinter.pa@Xerox.COM   Benefits:     The above example will not have to be written in the following silly way,     which only works if x and y are used read-only:       (if (and (typep x 'fixnum) (typep y 'fixnum))	   (let ((x x) (y y))	     (declare (fixnum x y))	     ...algorithm using x and y...)	   ...similar algorithm using x and y...)I would remove the adjective "silly" from this description.  I don'tfind this especially silly.*start*00701 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 SEP 88 22:53:16 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 22 Sep 88  22:53:04 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 22 SEP 88 22:51:39 PDTDate: 22 Sep 88 22:51 PDTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 3)In-reply-to: Eric Benson <eb@lucid.com>'s message of Thu, 22 Sep 88 22:44:55 pdtTo: Eric Benson <eb@lucid.com>cc: masinter.pa, CL-Cleanup@sail.stanford.eduMessage-ID: <880922-225139-3866@Xerox>OK. Consider Version 3 doesn't have the word "silly" in it.*start*02133 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 SEP 88 16:35:31 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 24 Sep 88  16:35:02 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA08465g; Sat, 24 Sep 88 15:32:48 PSTReceived: by bhopal id AA13708g; Sat, 24 Sep 88 16:32:19 PDTDate: Sat, 24 Sep 88 16:32:19 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809242332.AA13708@bhopal>To: Gray@DSG.csc.ti.comCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: David N Gray's message of Wed, 21 Sep 88  11:50:27 CDT <2799852627-13866831@Kelvin>Subject: Issue: DECLARE-TYPE-FREE (Version 1)re: >  (DEFUN FOO (X Y)    >    (DECLARE (FLOAT X Y))    >    (LET ((SUM (+ X Y)))    >      (DECLARE (FLOAT SUM))    >      (COND ((> SUM 3.0)    > 	    (LOCALLY (DECLARE (FIXNUM X))    > 	      ; X won't be used any more, so let's recycle its home...    > 	      (SETQ X (TRUNCATE SUM))    > 	      (+ (* X X) (* SUM Y))))    > 	   (T    > 	    (* X Y SUM)))))    Gag!  This is an example of what we most definitely want to prohibit.    This is a highly misguided programming style and can be made meaningful    only if the compiler is prohibited from using specialized storage for    variables.Right!  You've put it very well.  However, not everyone is aware of the compiler techniques for "using specialized storage" to good advantage.  I doubt seriously whether the Symbolics lisp compiler would be concerned with these questions, since it is reputed to ignore all type declarations anyway.[I wonder if the CLOE treatment is significantly more advanced.]Does the TI compiler do any of "these techniques"?  Of course, Luciddoes something like PDP10 MacLisp did for certain numeric types, andI'm sure that is why CLtL p158 has such an odd restriction on thescope of type declarations -- i.e., to hinder just such gross programsas the one you gagged upon above.-- JonL -*start*01025 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 SEP 88 17:32:43 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 24 Sep 88  17:32:05 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 465122; Sat 24-Sep-88 20:29:20 EDTDate: Sat, 24 Sep 88 20:29 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 1)To: JonL@Lucid.COM, Gray@DSG.CSC.TI.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8809242332.AA13708@bhopal>Message-ID: <880924202915.2.KMP@GRYPHON.SCRC.Symbolics.COM>Fyi, I didn't mean to suggest that that program was good style. I was justtrying to answer Moon's "Is it necessary to be explicit?" query bydemonstrating that it was necessary.*start*01250 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 19:34:09 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 26 Sep 88  19:33:54 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA09696g; Mon, 26 Sep 88 18:30:59 PSTReceived: by bhopal id AA02793g; Mon, 26 Sep 88 19:30:32 PDTDate: Mon, 26 Sep 88 19:30:32 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809270230.AA02793@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: Gray@DSG.CSC.TI.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Sat, 24 Sep 88 20:29 EDT <880924202915.2.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 1)re: Fyi, I didn't mean to suggest that that program was good style. I was just    trying to answer Moon's "Is it necessary to be explicit?" query by    demonstrating that it was necessary.Understood.  I liked Gray's phraseology re "specialized storage".  Somecommentary alluding to that ought to be in the proposal; that would helpjustify the restriction against this "explicit" style.-- JonL --*start*06486 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 27 SEP 88 17:23:24 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00516g; Tue, 27 Sep 88 16:22:38 PSTReceived: by bhopal id AA05760g; Tue, 27 Sep 88 17:22:11 PDTDate: Tue, 27 Sep 88 17:22:11 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809280022.AA05760@bhopal>To: masinter.paCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 22 Sep 88 22:25 PDT <880922-222553-3848@Xerox>Subject: Issue: DECLARE-TYPE-FREE (Version 4)The comment about Lucid's warning messages made me wonder -- it *isn't* invoked by the sample code in the problem description.  Consequently, I've amended the statement of the problem in what is intended to be a very friendly way (I also laid more of the "blame" at the clear proscription in CLtL p158, rather than on the percentage of people who think it "invalid".)   And I added "setf" to the "setq" part of the proposal -- probably one should understand the unqualified phrase "variable references" to mean "variable updating references" as well as "variable accessing references".Looking over the past mail, I saw a few more loose tidbits that neededto be cleaned up; in particular the msg:    Date: Tue, 20 Sep 88  19:04:46 CDT    From: David N Gray <Gray@DSG.csc.ti.com>suggested the need for a re-wording of the "Rationale" and "Benefits" section, and I extend this to the "Esthetics" section too.Finally, I added a bit to the discussion section, mostly reflectingthe current state regarding "compilers" that use specialized-storagefor type-declared variables (i.e., Lucid's "Production" compiler).By the bye, I'm not happy with the part that allows nested type specifiersto be overly general.  I'd prefer that the inner ones be subtypes of the outter ones, so that the program:    (locally (declare (type x fixnum))       (locally (declare (type x (or bit package)))         (setq x 1)))would be "in error"; i.e., inner types should be more sensitive to theoutter constraints.  But this would not be a "friendly amendment" or minor cleanup; so I haven't done anything about it.-- JonL --!Issue:         DECLARE-TYPE-FREEReferences:    CLtL p.158		DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL 		Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))		    ;LOCALLY does not bind	  ...algorithm using x and y...)	    ; any variables.	...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))				    ;'y' is not being bound in        (declare (fixnum y))			    ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Avoid the phrase "affects only variable bindings".  Clarify that a type  declaration means that it is an error for the value of the variable not  to be a member of the declared type, within the scope of the declaration.  Clarify that the above programs are valid, and that this  kind of   declaration means the same thing as wrapping a THE form around every   reference to the variable, including modifying references by setq or setf.  Clarify that if nested type declarations refer to the same variable, then   the value of the variable must be a member of the intersection of the   declared types.Rationale:  It enables optimizing compilers to make use of the otherwise ignored  type information.  Many people have often asked  for it, and there is   no strong reason to forbid it.  Current practice:  Lucid implements DECLARE-TYPE-FREE:ALLOW already; but under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  None, it is valid to ignore type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.*start*01776 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 SEP 88 14:48:58 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 23 Sep 88  14:47:38 PDTReturn-Path: <gls@Think.COM>Received: from joplin.think.com ([192.31.181.10]) by Think.COM; Fri, 23 Sep 88 17:35:56 EDTReceived: by joplin.think.com; Fri, 23 Sep 88 17:33:46 EDTDate: Fri, 23 Sep 88 17:33:46 EDTFrom: gls@Think.COMMessage-Id: <8809232133.AA03205@joplin.think.com>To: jonl@lucid.comCc: Moon@stony-brook.scrc.symbolics.com, GLS@Think.COM, CL-Cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Thu, 22 Sep 88 19:20:19 PDT <8809230220.AA07675@bhopal>Subject: Issue: DECLARE-TYPE-FREE (Version 1)   Date: Thu, 22 Sep 88 19:20:19 PDT   From: Jon L White <jonl@lucid.com>   I raised this issue at the Fort Collins meeting last November, suggesting    that it was an unintended aberration in CLtL.  But Guy Steele quickly    defended it, and promised to write down his objection to the "ALLOW"    interpretation and mail them out (this was in a plenary session, and was    only partially relevant to the item under discussion.)  To date, I don't    recall seeing his objections, but he should cough them up now or forever    hold his peace.Having pondered the matter, I have concluded that the me of September 1988is considerably less wedged than the me of November 1987 (this follows fromthe more general theorem that the me of now always judges itself lesswedged than me's of other times, past or future), and therefore I willhold my peace.In other words, I see the utility of the proposal, and have no overridingobjections that hold water.--Guy*start*05546 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 SEP 88 21:39:24 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Sep 88  21:35:24 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 30 SEP 88 21:33:54 PDTDate: 30 Sep 88 21:33 PDTFrom: masinter.pato: cl-cleanup@sail.stanford.eduSubject: Issue: DECLARE-TYPE-FREE (Version 5)Message-ID: <880930-213354-1766@Xerox>I added my reaction JonL's comment about nested types to the discussionsection. I also mentioned in the "Cost to Implementors" the possibilitythat it might be necessary to remove error checks.I think this is ready for release. Complain soon if you don't.!Issue:         DECLARE-TYPE-FREEReferences:    CLtL p.158		DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL 		Version 5, 30-Sep-88, Masinter (cost to implementors)		Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))		    ;LOCALLY does not bind	  ...algorithm using x and y...)	    ; any variables.	...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))				    ;'y' is not being bound in        (declare (fixnum y))			    ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Avoid the phrase "affects only variable bindings".  Clarify that a type  declaration means that it is an error for the value of the variable not  to be a member of the declared type, within the scope of the declaration.  Clarify that the above programs are valid, and that this  kind of   declaration means the same thing as wrapping a THE form around every   reference to the variable, including modifying references by setq orsetf.  Clarify that if nested type declarations refer to the same variable, then  the value of the variable must be a member of the intersection of the   declared types.Rationale:  It enables optimizing compilers to make use of the otherwise ignored  type information.  Many people have often asked  for it, and there is   no strong reason to forbid it.  Current practice:  Lucid implements DECLARE-TYPE-FREE:ALLOW already; but under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  A style note might add that since nested type declarations intersect,  it would be bad style to have inner declarations be subtypes of the outer  ones. For example    (locally (declare (type x fixnum))       (locally (declare (type x (or bit package)))         (setq x 1)))   would be confusing. Such code might be generated by macros, however.*start*02658 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 13:42:25 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Oct 88  13:38:35 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 468860; Sat 1-Oct-88 16:37:11 EDTDate: Sat, 1 Oct 88 16:36 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 5)To: masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <880930-213354-1766@Xerox>Message-ID: <881001163641.4.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: 30 Sep 88 21:33 PDT    From: masinter.pa@Xerox.COM    ...    I think this is ready for release. Complain soon if you don't.Sorry, but I have two comments which I think should be addressed beforethis goes out.    Issue:         DECLARE-TYPE-FREE    ...    Discussion:    ...      A style note might add that since nested type declarations intersect,      it would be bad style to have inner declarations be subtypes of the outer      ones. For example	(locally (declare (type x fixnum))	   (locally (declare (type x (or bit package)))	     (setq x 1)))       would be confusing. Such code might be generated by macros, however.This example is buggy because the syntax of TYPE declarations should havethe type first and the variable second. You want (TYPE FIXNUM X)and (TYPE (OR BIT PACKAGE) X)respectively.Anyway, I find this remark about the style note confusing. FIXNUM is nota subtype of (OR BIT PACKAGE) nor vice versa. There are two cases ofinterest: - The outer declaration is a subtype of the inner. eg,   (LOCALLY (DECLARE (TYPE FIXNUM X))     (LOCALLY (DECLARE (TYPE NUMBER X))       ...))   which is redundant but harmless. I don't think it's anything to   stylistically discourage though. - The outer declaration is not a subtype of the inner, and vice versa.   That is, the two types only partly overlap (or don't overlap at all).   You've already discussed the case of no overlap above in the Discussion,   so there's no point in repeating the remarks here. Instead, I'd just   deal with your example, which illustrates the interesting case of   only partially overlapping types. The case is interesting, but I'm a   little worried even here that "bad style" translates to "a compiler   should warn about this" and since, as you say, a macro might legitimately   expand into this, I think it's a very bad idea to identify it as   bad style...*start*01511 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 01 OCT 88 21:02:49 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01501g; Sat, 1 Oct 88 20:01:57 PSTReceived: by bhopal id AA08982g; Sat, 1 Oct 88 21:01:30 PDTDate: Sat, 1 Oct 88 21:01:30 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810020401.AA08982@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Sat, 1 Oct 88 16:36 EDT <881001163641.4.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 5)I agree with you that the "style" comment paragraph should be flushed.re:  "FIXNUM is not a subtype of (OR BIT PACKAGE) nor vice versa.      There are two cases of interest: ..."     - The outer declaration is a subtype of the inner. eg,       ...     - The outer declaration is not a subtype of the inner, and vice versa.       That is, the two types only partly overlap (or don't overlap at all).       ...Well, foo, in a previous message I claimed that the only legitimate caseis when the inner declaration is a subtype of the outter; that is athird case you didn't cover.  I think it was Gray's suggestion thatwe generalize this strict restraint into permitting an inner declarationto merely have a non-null intersection.  But I don't see the value ofit, and it even prevents a certain amount of "strong typing" errorchecking.-- JonL --*start*06152 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 20:22:29 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Oct 88  20:06:49 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472330; Thu 6-Oct-88 23:05:17 EDTDate: Thu, 6 Oct 88 23:05 EDTFrom: Masinter.PA, KMP@STONY-BROOK.SCRC.Symbolics.COMSender: KMP@STONY-BROOK.SCRC.Symbolics.COMReply-To: CL-Cleanup@SAIL.Stanford.EDUSubject: Issue: DECLARE-TYPE-FREE (Version 6)To: X3J13@SAIL.Stanford.EDUMessage-ID: <881006230506.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Issue:         DECLARE-TYPE-FREEReferences:    CLtL p.158	       DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL 	       Version 5, 30-Sep-88, Masinter (cost to implementors)	       Version 6, 06-Oct-88, Pitman (minor edits in Discussion)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))		    ;LOCALLY does not bind	  ...algorithm using x and y...)	    ; any variables.	...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))				    ;'y' is not being bound in        (declare (fixnum y))			    ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Avoid the phrase "affects only variable bindings".  Clarify that a type  declaration means that it is an error for the value of the variable not  to be a member of the declared type, within the scope of the declaration.  Clarify that the above programs are valid, and that this  kind of   declaration means the same thing as wrapping a THE form around every   reference to the variable, including modifying references by setq orsetf.  Clarify that if nested type declarations refer to the same variable, then  the value of the variable must be a member of the intersection of the   declared types.Rationale:  It enables optimizing compilers to make use of the otherwise ignored  type information.  Many people have often asked  for it, and there is   no strong reason to forbid it.  Current practice:  Lucid implements DECLARE-TYPE-FREE:ALLOW already; but under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))	   ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))	 (locally (declare (type number x))	   ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))*start*01568 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 06 OCT 88 19:58:14 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472328; Thu 6-Oct-88 22:58:01 EDTDate: Thu, 6 Oct 88 22:57 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: DECLARE-TYPE-FREETo: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <881006225749.6.KMP@BOBOLINK.SCRC.Symbolics.COM>I'm going to change that last example in the Discussion to the following. Ok?  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))	   ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))	 (locally (declare (type number x))	   ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))*start*01105 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 20:59:20 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Oct 88  20:46:33 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472344; Thu 6-Oct-88 23:45:12 EDTDate: Thu, 6 Oct 88 23:44 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 5)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <880930-213354-1766@Xerox>Message-ID: <19881007034441.5.MOON@EUPHRATES.SCRC.Symbolics.COM>DECLARE-TYPE-FREE:ALLOW in version 5 is okay with me except forthe formatting errors (presumably introduced by the Xerox mailerline-folding) and the omission of the word "not" before "be" in"it would be bad style to have inner declarations be subtypes of theouter ones."  I haven't asked him, but I think this missing word is whatreally provoked Kent's comments.*start*01086 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:01:32 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:01:49 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475761; Thu 13-Oct-88 16:00:26 EDTDate: Thu, 13 Oct 88 16:00 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREETo: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013160017.1.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Thought to be ready to vote.X3J13 meeting: Sandra: DECLARATION-SCOPE conflicts with this: It mentions that free	 declarations are not possible. Make the relationship between	 the two proposals explicit in both. Pierson wants this issue coordinated with this array proposal. See DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES. No vote was attempted.*start*03993 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 OCT 88 11:55:17 PDTReceived: from void.ai.mit.edu by SAIL.Stanford.EDU with TCP; 19 Oct 88  11:53:41 PDTReceived: by void.ai.mit.edu (5.59/1.5)	id AA01461; Wed, 19 Oct 88 14:56:28 EDTDate: Wed, 19 Oct 88 14:56:28 EDTFrom: jar@void.ai.mit.edu (Jonathan Rees)Message-Id: <8810191856.AA01461@void.ai.mit.edu>To: cl-cleanup@sail.stanford.eduIn-Reply-To: System Files's message of 06 Oct 88  2007 PDT <OnAwy@SAIL.Stanford.EDU>Subject: Issue: DECLARE-TYPE-FREE (Version 6)Reply-To: jar@zurich.ai.mit.eduI can't figure out at all what DECLARE-TYPE-FREE:ALLOW is supposed to mean.    From: Masinter.PA@Xerox.COM, KMP@STONY-BROOK.SCRC.Symbolics.COM    Subject: Issue: DECLARE-TYPE-FREE (Version 6)    To: X3J13@SAIL.Stanford.EDU[A]   ... Clarify that a type      declaration means that it is an error for the value of the variable not      to be a member of the declared type, within the scope of the declaration.[B]   Clarify that the above programs are valid, and that this  kind of       declaration means the same thing as wrapping a THE form around every       reference to the variable, including modifying references by setq or      setf.      Clarify that if nested type declarations refer to the same variable, then      the value of the variable must be a member of the intersection of the       declared types.The phrase "within the scope of the declaration" in [A] is in directconflict with the explanation that follows [B].  If "scope" means"lexical scope", then the following would be an error according to [A]but not according to [B]:	(let ((x 12) (y 'foo))	  (flet ((zap () (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      (zap)	      x)))Here the declaration is violated at the "lexical" point in the programbetween the two calls to ZAP.  If "scope" means "dynamic scope", youstill have a problem with	(let ((x 12) (y 'foo))	  (flet ((zap ()		   (rotatef x y)		   (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      x)))since now there is one point *dynamically* where the declaration isviolated.In either case, this seems like a tricky thing for a compiler toattempt to understand, and also pretty tricky for an interpreter (andin particular, a formal semantics) to enforce.  I would think thatrecovering the needed information via data flow would be easier.Even if you decide to trash definition [A] and go with definition [B],I would think that you'd additionally want to specify that thedeclaration must hold not only at all references and assignmentslexically in the scope of the declaration, but also at the point ofthe declaration itself.  Consider the case where the variable isunreferenced in the body; then the declaration wouldn't tell you athing, and e.g. it wouldn't help you with backward flow analysis.  Orthe variable might be referenced, but the declaration might not becomevalid until some time a while after the point of the declaration:	(let ((x 'foo))	  (flet ((zap () (setq x 17)))	    (locally (declare (fixnum x))	      (zap)	      x)))Also, what does the declaration mean for non-lexical variables?  Wouldit apply dynamically to any dynamic binding or reference in thedynamic scope of the declaration, or just to the references to theparticular dynamic binding that was in effect at the point ofdeclaration, or just to lexically apparent references in the lexicalscope of the declaration?I would strongly oppose the proposal in its current vague form.  Ithink I would oppose the proposal in just about any form, because itmakes the semantics of variable references even more hairy than italready is.  Compilers ought to recover this kind of information fromdata flow analysis, assisted if necessary by assertions (e.g. uses ofTHE in for-effect positions).*start*08352 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 OCT 88 12:45:03 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 19 Oct 88  12:42:56 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 478745; Wed 19-Oct-88 15:43:05 EDTDate: Wed, 19 Oct 88 15:42 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 6)To: jar@zurich.ai.mit.educc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8810191856.AA01461@void.ai.mit.edu>Message-ID: <881019154254.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Wed, 19 Oct 88 14:56:28 EDT    From: jar@void.ai.mit.edu (Jonathan Rees)    [A]   ... Clarify that a type	  declaration means that it is an error for the value of the variable not	  to be a member of the declared type, within the scope of the declaration.    [B]   Clarify that the above programs are valid, and that this  kind of 	  declaration means the same thing as wrapping a THE form around every 	  reference to the variable, including modifying references by setq or	  setf.	  Clarify that if nested type declarations refer to the same variable, then	  the value of the variable must be a member of the intersection of the 	  declared types.If you take "A" to refer to "lexical scope", I see no serious inconsistency here.Some minor wording to be dealt with. Probably it should say something to the effectof "...for an access to this variable to occur in the lexical scope and for theresulting value to not to be of the indicated type".The point of this declaration was not to enable the creation of a specialized homefor the variable, so technically it's no trouble for non-matching values to comeand go through mechanisms such as you cite below. The point of this declaration was,rather, to permit operations which occur on the contents of the variable within thelexical scope to be interestingly optimized. eg, (COND ((SYMBOLP X) 	;; You might wish the compiler could guess this one -- and some compilers	;; might, but some not.	(LOCALLY (DECLARE (SYMBOL X))	  (STRING X))) ;Could presumably compile down to (SYMBOL-NAME X).       ((PRIME-INTEGER-P X)	;; I hope you wouldn't expect a compiler to ever guess this one.	(LOCALLY (DECLARE (INTEGER X))	  (ZEROP (- X 7)))) ;Could presumably compile down to (EQL (- X 7) 0)       ((AND (PATHNAMEP X) (FROBBABLE X))        ;; Again I hope you wouldn't expect a compiler to ever guess this one.	;; Maybe FROB-PATHNAME only returns a PATHNAME if its argument is	;; a frobbable pathname. It's hard to imagine having a way to declare	;; that and it would be a violation of modularity for a compiler to	;; notice the fact and compile it into another function, yet it still	;; might be something a programmer could reasonably "just know" and	;; so declaring it could be important.	(LOCALLY (DECLARE (PATHNAME X))	  (SETQ X (FROB-PATHNAME X))	  ;; Note that PATHNAME-NAME is defined in CLtL to work on other	  ;; types than just pathnames, though we could imagine a more	  ;; efficient access being done here if we knew X was going to hold	  ;; a real pathname.	  (PATHNAME-NAME X))))You could insist that the writer should make a new variable and type-declarethe new variable, but that is contrary to the programming style of many CLprogrammers and hence not a practical solution. It also doesn't work for thecase of special variables (mentioned below).    The phrase "within the scope of the declaration" in [A] is in direct    conflict with the explanation that follows [B].  If "scope" means    "lexical scope", then the following would be an error according to [A]    but not according to [B]:	    (let ((x 12) (y 'foo))	      (flet ((zap () (rotatef x y)))		(locally (declare (fixnum x))		  (zap)		  (zap)		  x)))Not so. The X referenced by ZAP is not in the lexical scope of the locallydeclaration. As such, this program is not in error.    Here the declaration is violated at the "lexical" point in the program    between the two calls to ZAP.This is the "If a tree falls in a forest and nobody hears it" problem. Ifyou had referred to X in that interim, your program would be in error.Because you have not, your program is not in error.    If "scope" means "dynamic scope", It does not.    In either case, this seems like a tricky thing for a compiler to    attempt to understand, and also pretty tricky for an interpreter (and    in particular, a formal semantics) to enforce.  I would think that    recovering the needed information via data flow would be easier.The intent of the declaration is not to force anyone to detect all cases.The idea is to permit a compiler to make use of that information if it can.    Even if you decide to trash definition [A] and go with definition [B],    I would think that you'd additionally want to specify that the    declaration must hold not only at all references and assignments    lexically in the scope of the declaration, but also at the point of    the declaration itself.This seems reasonable. It would permit compilers to internally rewritethe LOCALLY as a (LET ((X X)) ...) for its own notational convenience when it could prove that didn't affect other semantics (eg, SETQ wouldgenerally thwart such a rewrite).    Consider the case where the variable is    unreferenced in the body; then the declaration wouldn't tell you a    thing, and e.g. it wouldn't help you with backward flow analysis.I don't have any objection to this sort of thing happening, but it wasn'tour purpose to permit this. But even if you can't infer stuff backward,that's not such a big deal. At least the person could extend the LOCALLYbackward if he cared. Right now you can't locally declare type informationat all, so isn't what we're proposing an improvement?    Or    the variable might be referenced, but the declaration might not become    valid until some time a while after the point of the declaration:	    (let ((x 'foo))	      (flet ((zap () (setq x 17)))		(locally (declare (fixnum x))		  (zap)		  x)))Right. This is a case where your restriction that it have that type goingin would help. Then the compiler could internally rewrite it as(LET ((X X)) (DECLARE (FIXNUM X)) ...).    Also, what does the declaration mean for non-lexical variables?  Would    it apply dynamically to any dynamic binding or reference in the    dynamic scope of the declaration, or just to the references to the    particular dynamic binding that was in effect at the point of    declaration, or just to lexically apparent references in the lexical    scope of the declaration?The declaration itself is lexically scoped -- independent of the scope ofthe variable.    I would strongly oppose the proposal in its current vague form.Thanks for the criticisms. I'm sure they'll be helpful in tightening thingsup.    I think I would oppose the proposal in just about any form, because it    makes the semantics of variable references even more hairy than it    already is.This would be sad. Right now we have no way to do local declarations otherthan at the time a variable binding is instantiated and we're proposing tomake the situation somewhat better. Some of your criticisms sound like they're saying we're not solving the whole problem (which we're not) andso we're doing no good. In fact, I think that solving half the problem willmake serious strides toward people's being able to write programs whichare concise and efficient.    Compilers ought to recover this kind of information from    data flow analysis, assisted if necessary by assertions (e.g. uses of    THE in for-effect positions).That would be cute but not very perspicuous. There's no difference between  (LOCALLY (DECLARE (FIXNUM X)) (+ X X))and  (PROGN (THE FIXNUM X) (+ X X))other than that the former is clumsy and earthy-sounding. The latter is likesaying:  "The accountant... Joe... Joe married Sally."when you want to say:  "Joe, who is an accountant, married Sally."It gets the information across, but not in a way that makes it clear whatyou were trying to say.*start*01596 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 DEC 88 16:43:06 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Dec 88  16:41:17 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 05 DEC 88 16:09:50 PSTDate: 5 Dec 88 16:08 PSTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 6)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 19 Oct 88 15:42 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: jar@zurich.ai.mit.edu, cl-cleanup@sail.stanford.eduMessage-ID: <881205-160950-4543@Xerox>After reviewing this, I think I am in favor of having declarations havemore pervasive extent than you outlined in your 19 Oct message. That is, itshould be an error for a variable to have a value that doesn't match thedeclared type at any *time* during the extent of the variable binding.I think would be the only way to talk about 	    (let ((x 12) (y 'foo))	      (flet ((zap () (rotatef x y)))		(locally (declare (fixnum x))		  (zap)		  (zap)		  x)))Declarations have extent of the enclosing form (until that extent isexited, as per exit-extent). Type declarations don't have scope. For freedeclarations, is an error for the declared variable to have an incorrecttype at any time of the extent of the form; for declarations associatedwith a binding, the declaration holds from the instant the binding iscreated.I think this issue will not be in the ballot, unfortunately.....*start*00644 00024 US Date:  6 Dec 88 11:20 PSTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 6) In-reply-to: Rob.MacLachlan@WB1.CS.CMU.EDU's message of Tue, 06 Dec 88 13:57:12 ESTTo: Rob.MacLachlan@WB1.CS.CMU.EDUcc: CL-Cleanup@SAIL.Stanford.EDU, Masinter.paI see your point. I wanted to make the assertion of type declarations the strongest possible and wound up weakening it for upward funargs. Yes, the point was to allow specialized variable representations. (In my mind, this is related to dynamic extent and the various proposals for it, although I can't explain the connection offhand.)I'll try again...*start*01902 00024 USaReturn-Path: <Rob.MacLachlan@fred.slisp.cs.cmu.edu>Received: from FRED.SLISP.CS.CMU.EDU ([128.2.250.114]) by Xerox.COM ; 06 DEC 88 10:59:58 PSTReceived: from FRED.SLISP.CS.CMU.EDU by FRED.SLISP.CS.CMU.EDU;  6 Dec 88 13:57:45 ESTTo: CL-Cleanup@SAIL.Stanford.EDUcc: Masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 6) In-reply-to: Your message of 05 Dec 88 16:53:00 -0800.             <881205-165330-4655@Xerox> Date: Tue, 06 Dec 88 13:57:12 ESTFrom: Rob.MacLachlan@WB1.CS.CMU.EDUI can't remember the previous proposal, so I don't know if V6 is animprovement, but it seems to me that there are serious problems inattempting to invoke dynamic extent in explaining "free" type declarations.I don't think this proposal is what anyone wants, since it requires thecompiler to prove that any given use isn't within an upward funarg beforeit can use the type declaration.Compilers are much better at understanding static "lexical" relationshipsthan time relationships.  A definition in terms of scope is more usefulthan one in terms of extent.What a compiler writer wants is something like:    Within the scope of the declaration, all references to the variable    will result in a value of the specified type, and all assignments to    the variable will be values of the specified type.  This can be modeled    as a source-to-source transformation by wrapping (THE <type> <var>)    around each reference and wrapping (THE <type> <new-value>) around each    expression assigned to the variable.This version isn't strong enough to ensure that a specializedrepresentation could be used for the variable within the declaration scope,since it is possible that the variable is never actually referenced withinthe scope, so none of the THE declarations apply.  Perhaps it was the intent of V6 to allow specialized variablerepresentations?  Rob*start*01006 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 DEC 88 11:41:18 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Dec 88  11:34:09 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 06 DEC 88 11:22:09 PSTDate: 6 Dec 88 11:20 PSTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 6) In-reply-to: Rob.MacLachlan@WB1.CS.CMU.EDU's message of Tue, 06 Dec 88 13:57:12 ESTTo: Rob.MacLachlan@WB1.CS.CMU.EDUcc: CL-Cleanup@SAIL.Stanford.EDU, Masinter.paMessage-ID: <881206-112209-6260@Xerox>I see your point. I wanted to make the assertion of type declarations thestrongest possible and wound up weakening it for upward funargs. Yes, the point was to allow specialized variable representations. (In mymind, this is related to dynamic extent and the various proposals for it,although I can't explain the connection offhand.)I'll try again...*start*06619 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 DEC 88 17:27:32 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Dec 88  17:26:21 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 05 DEC 88 16:53:30 PSTDate: 5 Dec 88 16:53 PSTSender: masinter.paReply-To: CL-Cleanup@SAIL.Stanford.EDUSubject: Issue: DECLARE-TYPE-FREE (Version 6)To: cl-cleanup@SAIL.Stanford.EDUcc: Masinter.paLine-fold: NOFrom: CL-cleanup@Sail.stanford.eduMessage-ID: <881205-165330-4655@Xerox>Here's a first pass at this writeup. I've convinced myself today thatthe issue for type declarations is their extent, not their scope. Only name bindings have scope; type declarations don't introducename bindings, they only introduce constraints on those bindings, and the constraints are dynamic.I better stop before I dig myself a bigger hole. This writeupalso attempts to fix some of the terminology of the "proposal"part.If you like this, the writeup needs to be extended with JAR's examples of assignments that violate the declarations outsideof the scope but within the extent of the declaration, and shouldsay that they are "in error".!Issue:         DECLARE-TYPE-FREEReferences:    CLtL p.158	       DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL 	       Version 5, 30-Sep-88, Masinter (cost to implementors)	       Version 6, 06-Oct-88, Pitman (minor edits in Discussion)	       Version 7,  5-Dec-88, Masinter (scope->extent)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))		    ;LOCALLY does not bind	  ...algorithm using x and y...)	    ; any variables.	...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))				    ;'y' is not being bound in        (declare (fixnum y))			    ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW-DYNAMIC):    Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations; the interpretation  of a type declaration is that, within the extent of the form containing  the declaration, it is an error for the value of the declared variable not  to be of the declared type.  This is stronger constraint than what would be implied by wrapping  a THE form around every reference to the variable, including modifying references by SETQ or SETF, and, for type declarations that also affect a  variable binding, around the computation of the initial value.Rationale:  This proposal enables optimizing compilers to make use of the otherwise  ignored type information.  Many people have often asked  for it, and  there is no strong reason to forbid it.  Current practice:  Lucid Common Lisp allows "free" type declarations;  under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))	   ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))	 (locally (declare (type number x))	   ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))     ----- End Forwarded Messages -----*start*02756 00024 USfReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 06 DEC 88 19:15:19 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00798g; Tue, 6 Dec 88 19:13:05 PSTReceived: by bhopal id AA11320g; Tue, 6 Dec 88 19:14:58 PSTDate: Tue, 6 Dec 88 19:14:58 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812070314.AA11320@bhopal>To: Masinter.paCc: cl-cleanup@SAIL.Stanford.EDUIn-Reply-To: CL-cleanup@Sail.stanford.edu's message of 5 Dec 88 16:53 PST <881205-165330-4655@Xerox>Subject: Issue: DECLARE-TYPE-FREE (Version 6)I don't see the problem you are trying to fix.  As it stands now, itappears to me that Version 6 is less clear, and less acceptable, than version 5.In particular, the notion of "scope" seems fully adequate for explainingLOCALLY declarations; CLtL didn't find it necessary to invoke thedichotomy of scope/extent in Chapter 9.  The "scope" even of the SPECIALdeclaration is all that is needed to explain the "extent" issue ofspecial variables.Also, I thought Kent did an adequate job of replying to jar's query,and that no substantial criticism was warranted based on them.  Jar'sexample was:	    (let ((x 12) (y 'foo))	      (flet ((zap () (rotatef x y)))		(locally (declare (fixnum x))		  (zap)		  (zap)		  x)))and he was questioning the "extent" issue about the value of X duringthe ROTATEF.  Kent's reply was:    Not so. The X referenced by ZAP is not in the lexical scope of the locally    declaration. As such, this program is not in error.and his message further contained phrases as follows:    If you take "A" to refer to "lexical scope", I see no serious    inconsistency here.  Some minor wording to be dealt with. Probably it    should say something to the effect of "...for an access to this variable    to occur in the lexical scope and for the resulting value to not to be    of the indicated type".    . . .     The point of this declaration was not to enable the creation of a    specialized home for the variable, so technically it's no trouble for    non-matching values to come and go through mechanisms such as you cite    below. The point of this declaration was, rather, to permit operations    which occur on the contents of the variable within the lexical scope to    be interestingly optimized. eg, . . . Unless kmp is ready to retract his analysis, then the only need foremmendation I see is to add the sentence he suggested above.-- JonL --P.S.  It appears as though there is some mail glitch -- I don't think I      have gotten most of today's replies to Cl-Cleanup.  Please bear      with me if it seems I've ignored some clarifying comments anyone      has already made.*start*00755 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 06 DEC 88 19:17:24 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00804g; Tue, 6 Dec 88 19:15:36 PSTReceived: by bhopal id AA11334g; Tue, 6 Dec 88 19:17:30 PSTDate: Tue, 6 Dec 88 19:17:30 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812070317.AA11334@bhopal>To: Masinter.paCc: cl-cleanup@SAIL.Stanford.EDUIn-Reply-To: CL-cleanup@Sail.stanford.edu's message of 5 Dec 88 16:53 PST <881205-165330-4655@Xerox>Subject: Issue: DECLARE-TYPE-FREE (Version 6)The version number is wrong.  You are sending out Version 7, not version 6,n'est-ce pas?  re-number the labels in the msg I just sent out.-- JonL --*start*02023 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 08:59:12 PSTReceived: from FRED.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 7 Dec 88  08:42:31 PSTReceived: from FRED.SLISP.CS.CMU.EDU by FRED.SLISP.CS.CMU.EDU;  6 Dec 88 13:57:45 ESTTo: CL-Cleanup@SAIL.Stanford.EDUcc: Masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 6) In-reply-to: Your message of 05 Dec 88 16:53:00 -0800.             <881205-165330-4655@Xerox> Date: Tue, 06 Dec 88 13:57:12 ESTFrom: Rob.MacLachlan@WB1.CS.CMU.EDUI can't remember the previous proposal, so I don't know if V6 is animprovement, but it seems to me that there are serious problems inattempting to invoke dynamic extent in explaining "free" type declarations.I don't think this proposal is what anyone wants, since it requires thecompiler to prove that any given use isn't within an upward funarg beforeit can use the type declaration.Compilers are much better at understanding static "lexical" relationshipsthan time relationships.  A definition in terms of scope is more usefulthan one in terms of extent.What a compiler writer wants is something like:    Within the scope of the declaration, all references to the variable    will result in a value of the specified type, and all assignments to    the variable will be values of the specified type.  This can be modeled    as a source-to-source transformation by wrapping (THE <type> <var>)    around each reference and wrapping (THE <type> <new-value>) around each    expression assigned to the variable.This version isn't strong enough to ensure that a specializedrepresentation could be used for the variable within the declaration scope,since it is possible that the variable is never actually referenced withinthe scope, so none of the THE declarations apply.  Perhaps it was the intent of V6 to allow specialized variablerepresentations?  Rob*start*07761 00024 US Date:  8 Dec 88 00:13 PSTFrom: masinter.paSubject: Issue: DECLARE-TYPE-FREE (Version 8)To: cl-cleanup@SAIL.Stanford.EDUcc: jar@zurich.ai.mit.edu, Rob.MacLachlan@WB1.CS.CMU.EDU, masinterLine-fold: NOI previously sent out version 7, but the subject line said Version 6.Sorry.This is another try at wording. This time I said "during the execution of any expression within the scope of the declaration."That is, the declaration implies an assertion at a given time, but the time is "the evaluation of expressions" within thescope of the declaration. This is the strongest assertion, andallows specialized variable representation.I think FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSinteracts with this.Forum:         CleanupIssue:         DECLARE-TYPE-FREEReferences:    CLtL p.158	       DECLARATION-SCOPERelated issues: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS	       DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL 	       Version 5, 30-Sep-88, Masinter (cost to implementors)	       Version 6, 06-Oct-88, Pitman (minor edits in Discussion)	       Version 7,  5-Dec-88, Masinter (scope->extent)	       Version 8,  7-Dec-88, Masinter (back to scope)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))		    ;LOCALLY does not bind	  ...algorithm using x and y...)	    ; any variables.	...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))				    ;'y' is not being bound in        (declare (fixnum y))			    ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any expression   within the scope of the declaration,  it is an error for the value of  the declared variable not to be of the declared type. For declarations  that are associated with variable bindings, the type declaration also  applies to the initial binding of the variable. In the special case  of a declaration for which there are no executable expressions  within the scope of the declaration (e.g., (locally (declare (integer x)))),  the result is as if there were executable expressions.Examples:;; this is an error:;; the assertion that x is a fixnum is violated between the two ;; calls to (zap)	(let ((x 12) (y 'foo))	  (flet ((zap () (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      (zap)	      x)));; this is an error, because the assertion that x is a fixnum;; is violated during the call to zap, even though few ;; implementations will be able to check:	(let ((x 12) (y 'foo))	  (flet ((zap ()		   (rotatef x y)		   (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      x)));; this is an error, even though the violation of the type;; constraint happens after the form with the declaration;; is exited.(let ((f (let ((x 3))  (declare (fixnum x)) #'(lambda (z) (incf x z)))))   (funcall f 4.3))Rationale:  This proposal enables optimizing compilers to make use of the otherwise  ignored type information.  Many people have often asked  for it, and  there is no strong reason to forbid it.  Current practice:  Lucid Common Lisp allows "free" type declarations;  under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))	   ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))	 (locally (declare (type number x))	   ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))        TITAN 
         TITAN 
          
TIMESROMAN          ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))                                                                                 %              @                                               $             
                                                              )              .       
                                  	      Q 'z*start*07638 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 00:27:44 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  00:19:18 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 DEC 88 00:13:57 PSTDate: 8 Dec 88 00:13 PSTFrom: masinter.paSubject: Issue: DECLARE-TYPE-FREE (Version 8)To: cl-cleanup@SAIL.Stanford.EDUcc: jar@zurich.ai.mit.edu, Rob.MacLachlan@WB1.CS.CMU.EDU, masinter.paLine-fold: NOMessage-ID: <881208-001357-2889@Xerox>I previously sent out version 7, but the subject line said Version 6.Sorry.This is another try at wording. This time I said "during the execution of any expression within the scope of the declaration."That is, the declaration implies an assertion at a given time, but the time is "the evaluation of expressions" within thescope of the declaration. This is the strongest assertion, andallows specialized variable representation.I think FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICSinteracts with this.!Forum:         CleanupIssue:         DECLARE-TYPE-FREEReferences:    CLtL p.158	       DECLARATION-SCOPERelated issues: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS	       DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL 	       Version 5, 30-Sep-88, Masinter (cost to implementors)	       Version 6, 06-Oct-88, Pitman (minor edits in Discussion)	       Version 7,  5-Dec-88, Masinter (scope->extent)	       Version 8,  7-Dec-88, Masinter (back to scope)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))		    ;LOCALLY does not bind	  ...algorithm using x and y...)	    ; any variables.	...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))				    ;'y' is not being bound in        (declare (fixnum y))			    ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any expression   within the scope of the declaration,  it is an error for the value of  the declared variable not to be of the declared type. For declarations  that are associated with variable bindings, the type declaration also  applies to the initial binding of the variable. In the special case  of a declaration for which there are no executable expressions  within the scope of the declaration (e.g., (locally (declare (integer x)))),  the result is as if there were executable expressions.Examples:;; this is an error:;; the assertion that x is a fixnum is violated between the two ;; calls to (zap)	(let ((x 12) (y 'foo))	  (flet ((zap () (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      (zap)	      x)));; this is an error, because the assertion that x is a fixnum;; is violated during the call to zap, even though few ;; implementations will be able to check:	(let ((x 12) (y 'foo))	  (flet ((zap ()		   (rotatef x y)		   (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      x)));; this is an error, even though the violation of the type;; constraint happens after the form with the declaration;; is exited.(let ((f (let ((x 3))  (declare (fixnum x)) #'(lambda (z) (incf x z)))))   (funcall f 4.3))Rationale:  This proposal enables optimizing compilers to make use of the otherwise  ignored type information.  Many people have often asked  for it, and  there is no strong reason to forbid it.  Current practice:  Lucid Common Lisp allows "free" type declarations;  under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))	   ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))	 (locally (declare (type number x))	   ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))*start*07207 00024 US Date:  9 Dec 88 17:34 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: DECLARE-TYPE-FREE (Version 8)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noThis is one of several variations discussed.Forum:         CleanupIssue:         DECLARE-TYPE-FREEReferences:    CLtL p.158	       DECLARATION-SCOPERelated issues: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS	       DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL 	       Version 5, 30-Sep-88, Masinter (cost to implementors)	       Version 6, 06-Oct-88, Pitman (minor edits in Discussion)	       Version 7,  5-Dec-88, Masinter (scope->extent)	       Version 8,  7-Dec-88, Masinter (back to scope)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))		    ;LOCALLY does not bind	  ...algorithm using x and y...)	    ; any variables.	...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))				    ;'y' is not being bound in        (declare (fixnum y))			    ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any expression   within the scope of the declaration,  it is an error for the value of  the declared variable not to be of the declared type. For declarations  that are associated with variable bindings, the type declaration also  applies to the initial binding of the variable. In the special case  of a declaration for which there are no executable expressions  within the scope of the declaration (e.g., (locally (declare (integer x)))),  the result is as if there were executable expressions.Examples:;; this is an error:;; the assertion that x is a fixnum is violated between the two ;; calls to (zap)	(let ((x 12) (y 'foo))	  (flet ((zap () (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      (zap)	      x)));; this is an error, because the assertion that x is a fixnum;; is violated during the call to zap, even though few ;; implementations will be able to check:	(let ((x 12) (y 'foo))	  (flet ((zap ()		   (rotatef x y)		   (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      x)));; this is an error, even though the violation of the type;; constraint happens after the form with the declaration;; is exited.(let ((f (let ((x 3))  (declare (fixnum x)) #'(lambda (z) (incf x z)))))   (funcall f 4.3))Rationale:  This proposal enables optimizing compilers to make use of the otherwise  ignored type information.  Many people have often asked  for it, and  there is no strong reason to forbid it.  Current practice:  Lucid Common Lisp allows "free" type declarations;  under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))	   ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))	 (locally (declare (type number x))	   ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))        TITAN 
         TITAN 
           Z                                                 %              @                                               $             
                                                              (              .       
                                  	       $z*start*07153 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 17:58:16 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  17:41:49 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 17:35:03 PSTDate: 9 Dec 88 17:34 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: DECLARE-TYPE-FREE (Version 8)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881209-173503-1691@Xerox>This is one of several variations discussed.!Forum:         CleanupIssue:         DECLARE-TYPE-FREEReferences:    CLtL p.158	       DECLARATION-SCOPERelated issues: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS	       DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL 	       Version 5, 30-Sep-88, Masinter (cost to implementors)	       Version 6, 06-Oct-88, Pitman (minor edits in Discussion)	       Version 7,  5-Dec-88, Masinter (scope->extent)	       Version 8,  7-Dec-88, Masinter (back to scope)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))	(locally (declare (fixnum x y))		    ;LOCALLY does not bind	  ...algorithm using x and y...)	    ; any variables.	...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))				    ;'y' is not being bound in        (declare (fixnum y))			    ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any expression   within the scope of the declaration,  it is an error for the value of  the declared variable not to be of the declared type. For declarations  that are associated with variable bindings, the type declaration also  applies to the initial binding of the variable. In the special case  of a declaration for which there are no executable expressions  within the scope of the declaration (e.g., (locally (declare (integer x)))),  the result is as if there were executable expressions.Examples:;; this is an error:;; the assertion that x is a fixnum is violated between the two ;; calls to (zap)	(let ((x 12) (y 'foo))	  (flet ((zap () (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      (zap)	      x)));; this is an error, because the assertion that x is a fixnum;; is violated during the call to zap, even though few ;; implementations will be able to check:	(let ((x 12) (y 'foo))	  (flet ((zap ()		   (rotatef x y)		   (rotatef x y)))	    (locally (declare (fixnum x))	      (zap)	      x)));; this is an error, even though the violation of the type;; constraint happens after the form with the declaration;; is exited.(let ((f (let ((x 3))  (declare (fixnum x)) #'(lambda (z) (incf x z)))))   (funcall f 4.3))Rationale:  This proposal enables optimizing compilers to make use of the otherwise  ignored type information.  Many people have often asked  for it, and  there is no strong reason to forbid it.  Current practice:  Lucid Common Lisp allows "free" type declarations;  under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))	   ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))	 (locally (declare (type number x))	   ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))*start*01860 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 10 DEC 88 05:13:12 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03592g; Sat, 10 Dec 88 05:11:16 PSTReceived: by bhopal id AA00374g; Sat, 10 Dec 88 05:13:13 PSTDate: Sat, 10 Dec 88 05:13:13 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812101313.AA00374@bhopal>To: masinter.paCc: x3j13@sail.stanford.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: cl-cleanup@sail.stanford.edu's message of 9 Dec 88 17:34 PST <881209-173503-1691@Xerox>Subject: Issue: DECLARE-TYPE-FREE (Version 8)Please retract this Issue from X3j13 now.  You (Larry) substantiallyreworked it during the past few days, and provided no opportunity forreview by the principals who originated the proposal.In particular, if I read Kent's commentary right, from the msg:    Date: Wed, 19 Oct 88 15:42 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    Subject: Issue: DECLARE-TYPE-FREE (Version 6)then his intent, along with that of Moon and myself (who also workedon this proposal), is diametrically opposite of what you now have itto be.In particular, your explanation:    ;; this is an error:    ;; the assertion that x is a fixnum is violated between the two     ;; calls to (zap)	    (let ((x 12) (y 'foo))	      (flet ((zap () (rotatef x y)))		(locally (declare (fixnum x))		  (zap)		  (zap)		  x)))was explained as exactly the opposite by Kent on 19-Oct-88; and the rest of us have always agreed that "free" type declarations need not beconsistent with "specialized storage" -- that they are merely equivalentto wrapping (THE <type> ...) around lexical occurances of the variable.It this point is debateable, it should have been debated in subcommitteebefore "release" of the issue.-- JonL --*start*02867 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 00:27:14 PSTReceived: from VALLECITO.SCRC.Symbolics.COM (SCRC-VALLECITO.ARPA) by SAIL.Stanford.EDU with TCP; 3 Jan 89  00:26:59 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by VALLECITO.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 267616; Tue 3-Jan-89 01:32:47 ESTDate: Tue, 3 Jan 89 01:31 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 9)To: masinter.pacc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <890102-221315-1967@Xerox>Message-ID: <890103013157.2.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 2 Jan 89 22:12 PST    From: masinter.pa@Xerox.COM    ...    If I say (DECLARE (TYPE (SIGNED-BYTE 12) X)), I'd think I'd like it to mean    that X never even momentarily holds a value that isn't of the declared    type.    ...The problems I have with this are the following: - It isn't enforceable. - In exactly those cases where it is enforceable, it's useful to enforce.   In those case where it is not enforceable (the odd middle-ground cases   in the Examples), it doesn't help you any to enforce the restriction, and   it might get in your way.    Put another way: If you grant that a language could be internally    consistent, well-formed, and all that sort of thing with the LEXICAL   proposal, then why not attach a useful meaning to the middle ground case?   There are potentially useful things (mostly "patches") that you could   write that way, and even if you permit it, you don't hinder the compiler's   ability to make useful inferences. - My general rule of thumb is that if someone says they need a feature   and someone else says they don't, that the person claiming they do need   the feature has an a priori more interesting case. As such, LEXICAL is   more interesting partly because the fact that some people don't need all   its features is not a compelling thing to me. If you could make a case for   why LEXICAL caused some actual -problem-, that would make the other case   more interesting. After all, nothing about LEXICAL prevents you personally   from meaning that "X never momentarily holds..." since that's compatible   with the meaning proposed in LEXICAL -- just as nothing about the way    false and the empty-list are treated in Lisp keeps you from meaning   that () always means the empty list (even if Lisp doesn't care).   Similarly here, LEXICAL admits both views of the universe while ALLOW   admits only one. To me, this seems unfair, since ALLOW restricts things   to lock out a view of the world, without providing any hint of a reason   for why that view of the world is an unreasonable one.*start*00912 00024 US Date:  3 Jan 89 11:35 PSTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 9)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 3 Jan 89 01:31 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUWell, I think it is enforcable, if you have specialized storage.I think the direction of your inference is backward. ALLOW is more powerful than LEXICAL.  A program that is correct using ALLOW semantics remains correct using LEXICAL semantics. Thus, an implementation that can only enforce LEXICAL will still accept programs that are correct under ALLOW. The converse is not true. Thus, ALLOW is more restrictive, and it allows implementations more freedom, while not putting any unreasonable constraints on programs that want to use declarations.*start*01526 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 18:11:33 PSTReceived: from YUKON.SCRC.Symbolics.COM (SCRC-YUKON.ARPA) by SAIL.Stanford.EDU with TCP; 2 Jan 89  18:11:20 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 415645; Mon 2-Jan-89 21:10:49 ESTDate: Mon, 2 Jan 89 21:09 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 9)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19890103003245.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <890102210923.6.KMP@BOBOLINK.SCRC.Symbolics.COM>My strong preference is for LEXICAL. The ALLOW proposal (which is theonly option offered in v8, which is on the ballot) doesn't sit wellwith me, and I wouldn't have been inclined vote yes on it.Btw, both versions 8 and 9 have the non-preemptive problem that theonly examples they provide illustrate what happens in the screwcases. This might lead some people to think that this whole issueis kind of random. I think there should be a few examples of the"normal use" (such as the un-filled-out examples in the problemdescription). It's probably worth fixing this before the meetingso that people doing last-minute aren't bogged down trying to decipherthe proposal by working backward from the strange examples currentlyin the proposal.*start*04673 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 22:14:47 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  22:14:21 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 22:13:15 PSTDate: 2 Jan 89 22:12 PSTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 9)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 2 Jan 89 19:32 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@sail.stanford.eduMessage-ID: <890102-221315-1967@Xerox>Thanks for doing this, I think it does help clarify the discussion.I had thought -- apparently incorrectly -- that the only objection tomaking type declarations have the strongest possible meaning was thedifficulty in specifying what that meaning might be. I think the ALLOWproposal does so consistently. If I say (DECLARE (TYPE (SIGNED-BYTE 12) X)), I'd think I'd like it to meanthat X never even momentarily holds a value that isn't of the declaredtype.I'd suggest adding to Current Practice that some Common Lispimplementations ignore type declarations completely.I'd like to see the writeup make it clear that the following is subsumed;note that this issue never was released or appeared on a Status list, so itshould probably just be includedRedistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 NOV 8816:21:08 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 4 Nov 88  16:19:26 PSTReceived: by ti.com id AA07547; Fri, 4 Nov 88 18:19:48 CSTReceived: from Kelvin by tilde id AA15412; Fri, 4 Nov 88 18:03:33 CSTMessage-Id: <2803680321-5692691@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 4 Nov 88 18:05:21 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: cl-cleanup@sail.stanford.eduSubject: Issue SPECIAL-TYPE-SHADOWING (V1)In-Reply-To: Msg of 28 Sep 88 20:44 PDT from masinter.pa@Xerox.COMIssue:         SPECIAL-TYPE-SHADOWINGReferences:    CLtL pages 156, 158Related issues: DECLARE-TYPE-FREECategory:      CLARIFICATIONEdit history:  Version 1, 04-Nov-88 by David GrayProblem description:  A Common Lisp user raised the question of whether something like the  following is legal:    (PROCLAIM '(TYPE NUMBER *X*))    (DEFVAR *X*)    (DEFUN FOO ()      (LET ((*X* T))        (DECLARE (TYPE SYMBOL *X*))        (BAR)))  Page 156 of CLtL says that a proclamation is "always in force unless  locally shadowed" and page 158 says type declarations "only affect  variable bindings", which might be interpreted to mean that the DECLARE  locally shadows the PROCLAIM.  However, that interpretation would make  the global type proclamation useless because it could not be relied on  when compiling a function such as BAR. Proposal SPECIAL-TYPE-SHADOWING:CLARIFY    Clarify that if there is a local type declaration for a special  variable, and there is also a global type proclamation for that same  variable, then the value of the variable within the scope of the local  declaration must be a member of the intersection of the two declared  types.Rationale:  Some restriction on local type declarations for special variables is  needed in order for type proclamations to be meaningful.  The wording  used here was chosen for consistency with proposal DECLARE-TYPE-FREE.Current practice:  The TI, Symbolics, and Lucid implementations do not report any error  on the example above, but it isn't clear that they really do anything  with type declarations for special variables anyway.Cost to Implementors:  This is unlikely to require a change in any current implementation.Cost to Users:  Anyone who has written code like the example above would have to  modify it if compilers started enforcing this restriction.Cost of non-adoption:  A minor ambiguity in the language specification that could confuse  users.Performance impact:  None.Benefits:  A clearer definition of the meaning of type declarations for special  variables.Discussion:  This is obviously very closely related to issue DECLARE-TYPE-FREE, but  this is an ambiguity in the existing language that should be resolved  even if the language extension of proposal DECLARE-TYPE-FREE is not  accepted.  Note also that DECLARE-TYPE-FREE makes no mention of type  proclamations.  Other possible resolutions of the ambiguity would be to either rule  out use of local type declarations for special variables, or to say  that the local type must be a subtype of the global type.*start*02719 00024 US Return-Path: <KMP@VALLECITO.SCRC.Symbolics.COM>Received: from VALLECITO.SCRC.Symbolics.COM ([128.81.41.92]) by Xerox.COM ; 02 JAN 89 23:22:47 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by VALLECITO.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 267616; Tue 3-Jan-89 01:32:47 ESTDate: Tue, 3 Jan 89 01:31 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 9)To: masinter.pacc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <890102-221315-1967@Xerox>Message-ID: <890103013157.2.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 2 Jan 89 22:12 PST    From: masinter.pa@Xerox.COM    ...    If I say (DECLARE (TYPE (SIGNED-BYTE 12) X)), I'd think I'd like it to mean    that X never even momentarily holds a value that isn't of the declared    type.    ...The problems I have with this are the following: - It isn't enforceable. - In exactly those cases where it is enforceable, it's useful to enforce.   In those case where it is not enforceable (the odd middle-ground cases   in the Examples), it doesn't help you any to enforce the restriction, and   it might get in your way.    Put another way: If you grant that a language could be internally    consistent, well-formed, and all that sort of thing with the LEXICAL   proposal, then why not attach a useful meaning to the middle ground case?   There are potentially useful things (mostly "patches") that you could   write that way, and even if you permit it, you don't hinder the compiler's   ability to make useful inferences. - My general rule of thumb is that if someone says they need a feature   and someone else says they don't, that the person claiming they do need   the feature has an a priori more interesting case. As such, LEXICAL is   more interesting partly because the fact that some people don't need all   its features is not a compelling thing to me. If you could make a case for   why LEXICAL caused some actual -problem-, that would make the other case   more interesting. After all, nothing about LEXICAL prevents you personally   from meaning that "X never momentarily holds..." since that's compatible   with the meaning proposed in LEXICAL -- just as nothing about the way    false and the empty-list are treated in Lisp keeps you from meaning   that () always means the empty list (even if Lisp doesn't care).   Similarly here, LEXICAL admits both views of the universe while ALLOW   admits only one. To me, this seems unfair, since ALLOW restricts things   to lock out a view of the world, without providing any hint of a reason   for why that view of the world is an unreasonable one.*start*01438 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 03 JAN 89 12:25:47 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 514582; Tue 3-Jan-89 15:25:04 ESTDate: Tue, 3 Jan 89 15:24 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 9)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890103-113603-1600@Xerox>Message-ID: <890103152425.1.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 3 Jan 89 11:35 PST    From: masinter.pa@Xerox.COM    Well, I think it is enforcable, if you have specialized storage.Can you give me a concrete example? I'm basically saying that since it's youthat wants to introduce a restriction, the burden of proof is on you to showa single example where the restriction buys you somthing. If you think itdoes buy you something, I'm not calling you a liar -- I'm just saying I'm notable to see the example you're hinting at.So far, the only concrete example we have is one which has a perfectlylegitimate interpretation or an "is an error" interpretation. You're sayingyou want to opt for the "is an error" interpretation, but you're not sayingwhat I buy for giving up the flexibility.As soon as we start talking about concrete examples, I think we'll be makingheadway.*start*01273 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 18:20:20 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 3 Jan 89  18:18:13 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 03 JAN 89 11:36:03 PSTDate: 3 Jan 89 11:35 PSTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 9)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 3 Jan 89 01:31 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <890103-113603-160@Xerox>Well, I think it is enforcable, if you have specialized storage.I think the direction of your inference is backward. ALLOW is more powerfulthan LEXICAL.  A program that is correct using ALLOW semantics remainscorrect using LEXICAL semantics. Thus, an implementation that can onlyenforce LEXICAL will still accept programs that are correct under ALLOW.The converse is not true. Thus, ALLOW is more restrictive, and it allows implementations morefreedom, while not putting any unreasonable constraints on programs thatwant to use declarations.*start*01585 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 18:31:08 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 3 Jan 89  12:27:03 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 514582; Tue 3-Jan-89 15:25:04 ESTDate: Tue, 3 Jan 89 15:24 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 9)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890103-113603-1600@Xerox>Message-ID: <890103152425.1.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 3 Jan 89 11:35 PST    From: masinter.pa@Xerox.COM    Well, I think it is enforcable, if you have specialized storage.Can you give me a concrete example? I'm basically saying that since it's youthat wants to introduce a restriction, the burden of proof is on you to showa single example where the restriction buys you somthing. If you think itdoes buy you something, I'm not calling you a liar -- I'm just saying I'm notable to see the example you're hinting at.So far, the only concrete example we have is one which has a perfectlylegitimate interpretation or an "is an error" interpretation. You're sayingyou want to opt for the "is an error" interpretation, but you're not sayingwhat I buy for giving up the flexibility.As soon as we start talking about concrete examples, I think we'll be makingheadway.*start*02352 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 04 JAN 89 01:39:55 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04040g; Wed, 4 Jan 89 01:37:07 PSTReceived: by bhopal id AA01494g; Wed, 4 Jan 89 01:39:19 PSTDate: Wed, 4 Jan 89 01:39:19 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901040939.AA01494@bhopal>To: masinter.paCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 2 Jan 89 22:12 PST <890102-221315-1967@Xerox>Subject: Issue: DECLARE-TYPE-FREE (Version 9)re: If I say (DECLARE (TYPE (SIGNED-BYTE 12) X)), I'd think I'd like it to mean    that X never even momentarily holds a value that isn't of the declared    type.For "bound" type declarations, it does mean this -- because the lexical scope includes all the code that can ever be executed during the dynamicextent of that (binding) contour.  But for "free" type declarations,we have a choice; we can say that it applies to the lexical scope,or that it applies to the dynamic extent.  Clearly, the former issimpler, and more in line with our other views on declarationscoping; see for example this issue DECLARATION-SCOPE, especiallythe parallelism between the scoping rules for variables (lexical)and those for declarations.re: I'd like to see the writeup make it clear that the following is subsumed;    note that this issue never was released or appeared on a Status list, so     it should probably just be included:      Date: Fri, 4 Nov 88 18:05:21 CST      From: David N Gray <Gray@DSG.csc.ti.com>      To: cl-cleanup@sail.stanford.edu      Subject: Issue SPECIAL-TYPE-SHADOWING (V1)      . . .       Proposal SPECIAL-TYPE-SHADOWING:CLARIFY	Clarify that if there is a local type declaration for a special	variable, and there is also a global type proclamation for that same	variable, then the value of the variable within the scope of the local	declaration must be a member of the intersection of the two declared	types.I don't think it is subsumed.  The various versions of DECLARE-TYPE-FREEpermitted an inner nested declaration to be merely overlapping withan outer declaration; but Gray's proposal requires local (read: "inner")declarations to be subtypes of the global proclamations (read: "outter")-- JonL --*start*01262 00024 US Date:  5 Jan 89 22:14 PSTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 9)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 3 Jan 89 15:24 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUThe example I keep coming back to is one where it isn't so much that the local declaration is easy to enforce as it is where it is difficult *not* to enforce it.Suppose I have(defun frob (delta) (flet ((more (x) (+ x delta)))	;; if you like, put (declare (inline more)) here   (typecase delta	(float (locally (declare (type float delta))		... (more rho ) ... )       ((signed-byte 8)		(locally (declare (type (signed-byte 8) delta))		... (more zz) ... )   ...)Even without the inline, it is a common & legal transformation to do inline substitution on "small" fletted functions. Even though the reference "delta" in the definition of more isn't  within the lexical scope of the local declaration, it *is* the same delta. While its not impossible to maintain a separate contour in order to segregate the type declarations, it seems like unnecessary work, and in fact, the declaration is quite useful if "more" is inlined.*start*10986 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 16:35:48 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Jan 89  16:34:44 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 514100; Mon 2-Jan-89 19:33:29 ESTDate: Mon, 2 Jan 89 19:32 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 9)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19890103003245.0.MOON@EUPHRATES.SCRC.Symbolics.COM>There was considerable discussion about the released version 8 notreflecting the concensus of the committee.  I don't feel strongly aboutthis either way, but as an aid in discussion I have prepared thisversion, which contains two proposals.The argument is about whether a type declaration affects only variablereferences within its scope, or also affects variable references thatare outside the scope of the declaration but dynamically inside theexecution of a form that is itself inside the scope of the declaration.This really has nothing to do with the original goal of the proposal,since exactly the same issue arises for a type declaration attachedto a binding of a special variable.Forum:         CleanupIssue:         DECLARE-TYPE-FREEReferences:    CLtL p.158               DECLARATION-SCOPERelated issues: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS               DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL                Version 5, 30-Sep-88, Masinter (cost to implementors)               Version 6, 06-Oct-88, Pitman (minor edits in Discussion)               Version 7,  5-Dec-88, Masinter (scope->extent)               Version 8,  7-Dec-88, Masinter (back to scope)               Version 9,  2-Jan-89, Moon (2 proposals, to clarify discussion)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))        (locally (declare (fixnum x y))             ;LOCALLY does not bind          ...algorithm using x and y...)            ; any variables.        ...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))                                  ;'y' is not being bound in        (declare (fixnum y))                        ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any expression   within the scope of the declaration,  it is an error for the value of  the declared variable not to be of the declared type. For declarations  that are associated with variable bindings, the type declaration also  applies to the initial binding of the variable. In the special case  of a declaration for which there are no executable expressions  within the scope of the declaration (e.g., (locally (declare (integer x)))),  the result is as if there were executable expressions.  In this proposal, a type declaration affects not only variable  references within its scope, but also affects variable references that  are outside the scope of the declaration but dynamically inside the  execution of a form that is itself inside the scope of the  declaration.  Such references can exist when the variable is SPECIAL  or when the declaration is not attached to the variable's binding, so  that the scope of the declaration does not include the entire scope  of the variable.Proposal (DECLARE-TYPE-FREE:LEXICAL):  Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any reference to the  declared variable within the scope of the declaration, it is an error for  the value of the declared variable not to be of the declared type; and  during the execution of any SETQ of the declared variable within the scope  of the declaration, it is an error for the newly assigned value of the  declared variable not to be of the declared type; and at the moment the  scope of the declaration is entered, it is an error for the value of the  declared variable not to be of the declared type.  In this proposal, a type declaration affects only variable references within  its scope, and the meaning of "free" and "variable-binding-associated" type  declarations can be described identically.  This proposal is equivalent to saying that the meaning of a type declaration  is equivalent to changing each reference to <var> within the scope of the  declaration to (THE <type> <var>), changing each expression assigned to the  variable within the scope of the declaration to (THE <type> <new-value>),  and executing (THE <type> <var>) at the moment the scope of the declaration  is entered.Examples:;; this is an error under DECLARE-TYPE-FREE:ALLOW:;; the assertion that x is a fixnum is violated between the two ;; calls to (zap);; this is a valid program under DECLARE-TYPE-FREE:LEXICAL        (let ((x 12) (y 'foo))          (flet ((zap () (rotatef x y)))            (locally (declare (fixnum x))              (zap)              (zap)              x)));; this is an error under both proposals        (let ((x 12) (y 'foo))          (flet ((zap () (rotatef x y)))            (locally (declare (fixnum x))              (zap)              (print x)	      (zap)              x)));; this is an error under DECLARE-TYPE-FREE:ALLOW, because;; the assertion that x is a fixnum;; is violated during the call to zap, even though few ;; implementations will be able to check:;; this is a valid program under DECLARE-TYPE-FREE:LEXICAL        (let ((x 12) (y 'foo))          (flet ((zap ()                   (rotatef x y)                   (rotatef x y)))            (locally (declare (fixnum x))              (zap)              x)));; this is an error under both proposals, even though the;; violation of the type constraint happens after the form;; with the declaration is exited.   (let ((f (let ((x 3))              (declare (fixnum x))              #'(lambda (z) (incf x z)))))     (funcall f 4.3))Rationale:  This proposal enables optimizing compilers to make use of the otherwise  ignored type information.  Many people have often asked for it, and  there is no strong reason to forbid it.    DECLARE-TYPE-FREE:ALLOW is more restrictive on programs and hence allows  more freedom for optimizing compilers.  DECLARE-TYPE-FREE:LEXICAL is easier  to understand but allows a specialized representation only where the scope  of the variable is the same as the scope of the declaration or the compiler  can prove that there are no relevant other references to the variable.Current practice:  Lucid Common Lisp allows "free" type declarations;  under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))           ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))         (locally (declare (type number x))           ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))*start*12670 00024 USfReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 23:08:28 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Jan 89  22:52:59 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 06 JAN 89 22:51:48 PSTDate: 6 Jan 89 22:51 PSTFrom: masinter.paTo: X3J13@Sail.Stanford.EduSubject: Issue: DECLARE-TYPE-FREE (Version 9)reply-to: cl-cleanup@sail.stanford.eduline-fold: NOMessage-ID: <890106-225148-2007@Xerox>This issue will be voted separately at the X3J13 meeting.I (unfortunately) caused some controversy by changing thesense of the proposal at the last minute. I'm sorry, as I donot feel stringly about this issue, although there are someadditional considerations. I've included some, but not all,Additional Comments at the end.This version has two proposals, both the ALLOW proposalwhich I introduced with version 8 and a LEXICAL proposal.The difference is about whether a type declaration affects only variablereferences within its scope, or also affects variable references thatare outside the scope of the declaration but dynamically inside theexecution of a form that is itself inside the scope of the declaration.This really has nothing to do with the original goal of the proposal,since exactly the same issue arises for a type declaration attachedto a binding of a special variable.If you've yet to complete your ballot, please indicate whichversion of the proposal you're votes apply to.!Forum:         CleanupIssue:         DECLARE-TYPE-FREEReferences:    CLtL p.158               DECLARATION-SCOPERelated issues: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS               DECLARATION-SCOPECategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL                Version 5, 30-Sep-88, Masinter (cost to implementors)               Version 6, 06-Oct-88, Pitman (minor edits in Discussion)               Version 7,  5-Dec-88, Masinter (scope->extent)               Version 8,  7-Dec-88, Masinter (back to scope)               Version 9,  2-Jan-89, Moon (2 proposals, to clarify discussion)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))        (locally (declare (fixnum x y))             ;LOCALLY does not bind          ...algorithm using x and y...)            ; any variables.        ...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))                                  ;'y' is not being bound in        (declare (fixnum y))                        ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any expression   within the scope of the declaration,  it is an error for the value of  the declared variable not to be of the declared type. For declarations  that are associated with variable bindings, the type declaration also  applies to the initial binding of the variable. In the special case  of a declaration for which there are no executable expressions  within the scope of the declaration (e.g., (locally (declare (integer x)))),  the result is as if there were executable expressions.  In this proposal, a type declaration affects not only variable  references within its scope, but also affects variable references that  are outside the scope of the declaration but dynamically inside the  execution of a form that is itself inside the scope of the  declaration.  Such references can exist when the variable is SPECIAL  or when the declaration is not attached to the variable's binding, so  that the scope of the declaration does not include the entire scope  of the variable.Proposal (DECLARE-TYPE-FREE:LEXICAL):  Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any reference to the  declared variable within the scope of the declaration, it is an error for  the value of the declared variable not to be of the declared type; and  during the execution of any SETQ of the declared variable within the scope  of the declaration, it is an error for the newly assigned value of the  declared variable not to be of the declared type; and at the moment the  scope of the declaration is entered, it is an error for the value of the  declared variable not to be of the declared type.  In this proposal, a type declaration affects only variable references within  its scope, and the meaning of "free" and "variable-binding-associated" type  declarations can be described identically.  This proposal is equivalent to saying that the meaning of a type declaration  is equivalent to changing each reference to <var> within the scope of the  declaration to (THE <type> <var>), changing each expression assigned to the  variable within the scope of the declaration to (THE <type> <new-value>),  and executing (THE <type> <var>) at the moment the scope of the declaration  is entered.Examples:;; this is an error under DECLARE-TYPE-FREE:ALLOW:;; the assertion that x is a fixnum is violated between the two ;; calls to (zap);; this is a valid program under DECLARE-TYPE-FREE:LEXICAL        (let ((x 12) (y 'foo))          (flet ((zap () (rotatef x y)))            (locally (declare (fixnum x))              (zap)              (zap)              x)));; this is an error under both proposals        (let ((x 12) (y 'foo))          (flet ((zap () (rotatef x y)))            (locally (declare (fixnum x))              (zap)              (print x)	      (zap)              x)));; this is an error under DECLARE-TYPE-FREE:ALLOW, because;; the assertion that x is a fixnum;; is violated during the call to zap, even though few ;; implementations will be able to check:;; this is a valid program under DECLARE-TYPE-FREE:LEXICAL        (let ((x 12) (y 'foo))          (flet ((zap ()                   (rotatef x y)                   (rotatef x y)))            (locally (declare (fixnum x))              (zap)              x)));; this is an error under both proposals, even though the;; violation of the type constraint happens after the form;; with the declaration is exited.   (let ((f (let ((x 3))              (declare (fixnum x))              #'(lambda (z) (incf x z)))))     (funcall f 4.3))Rationale:  This proposal enables optimizing compilers to make use of the otherwise  ignored type information.  Many people have often asked for it, and  there is no strong reason to forbid it.    DECLARE-TYPE-FREE:ALLOW is more restrictive on programs and hence allows  more freedom for optimizing compilers.  DECLARE-TYPE-FREE:LEXICAL is easier  to understand but allows a specialized representation only where the scope  of the variable is the same as the scope of the declaration or the compiler  can prove that there are no relevant other references to the variable.Current practice:  Lucid Common Lisp allows "free" type declarations;  under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))           ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))         (locally (declare (type number x))           ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))!Additional Comments:"The ALLOW proposal has the problems that: - It isn't enforceable. - In exactly those cases where it is enforceable, it's useful to enforce.   In those case where it is not enforceable (the odd middle-ground cases   in the Examples), it doesn't help you any to enforce the restriction, and   it might get in your way. ""Btw, both versions 8 and 9 have the non-preemptive problem that theonly examples they provide illustrate what happens in the screwcases. This might lead some people to think that this whole issueis kind of random. I think there should be a few examples of the"normal use" (such as the un-filled-out examples in the problemdescription). ""Suppose I have(defun frob (delta) (flet ((more (x) (+ x delta)))	;; if you like, put (declare (inline more)) here   (typecase delta	(float (locally (declare (type float delta))		... (more rho ) ... )       ((signed-byte 8)		(locally (declare (type (signed-byte 8) delta))		... (more zz) ... )   ...)Even without the INLINE, it is a common & legal transformationto do inline substitution on small FLETted functions. Even though the reference DELTA in the definition of MORE isn't  within the lexical scope of the local declaration, it *is* the same delta. While its not impossible to maintain a separate contour in order to segregate the type declarations, it seems like unnecessary work, and in fact, the declaration is quite useful if MORE is inlined. This is only the casewith the ALLOW proposal and not the LEXICAL proposal."*start*00420 00024 US Date: 10 Jan 89 15:04 PSTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 9)In-reply-to: David N Gray <Gray@DSG.csc.ti.com>'s message of Tue, 10 Jan 89 10:57:15 CSTTo: David N Gray <Gray@DSG.csc.ti.com>cc: Jon L White <jonl@lucid.com>, masinter.pa, CL-Cleanup@sail.stanford.eduI don't think it is subsumed now either; I've left SPECIAL-TYPE-SHADOWING as a separate issue.*start*01551 00024 US Return-Path: <Gray@DSG.csc.ti.com>Received: from ti.com ([10.7.0.46]) by Xerox.COM ; 10 JAN 89 09:05:04 PSTReceived: by ti.com id AA04983; Tue, 10 Jan 89 11:06:01 CSTReceived: from Kelvin by tilde id AA10141; Tue, 10 Jan 89 10:54:55 CSTMessage-Id: <2809443435-15097074@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 10 Jan 89 10:57:15 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Jon L White <jonl@lucid.com>, masinter.paCc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: DECLARE-TYPE-FREE (Version 9)In-Reply-To: Msg of Wed, 4 Jan 89 01:39:19 PST from Jon L White <jonl@lucid.com>> re: I'd like to see the writeup make it clear that the following is subsumed;>       . . . >       Proposal SPECIAL-TYPE-SHADOWING:CLARIFY...> I don't think it is subsumed.  The various versions of DECLARE-TYPE-FREE> permitted an inner nested declaration to be merely overlapping with> an outer declaration; but Gray's proposal requires local (read: "inner")> declarations to be subtypes of the global proclamations (read: "outter")I don't think it is subsumed, but not for that reason.   The treatmentof overlapping declarations is intended to be consistent; butDECLARE-TYPE-FREE still makes no mention of type proclamations.  Also,the proposal section of DECLARE-TYPE-FREE seems to have lost a cleardefinition of the semantics of overlapping declarations, although it isclarified in the discussion section.  The proposal needs to explicitlysay that nested type declarations combine rather than being shadowed.*start*01433 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 12:18:58 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 11 Jan 89  08:08:19 PSTReceived: by ti.com id AA09880; Wed, 11 Jan 89 10:21:03 CSTReceived: from Kelvin by tilde id AA22744; Wed, 11 Jan 89 10:08:23 CSTMessage-Id: <2809527001-3602765@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 11 Jan 89 10:10:01 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Jon L White <jonl@lucid.com>Cc: masinter.pa, CL-Cleanup@sail.stanford.eduSubject: Re: Issue: DECLARE-TYPE-FREE (Version 9)In-Reply-To: Msg of Tue, 10 Jan 89 22:46:24 PST from Jon L White <jonl@lucid.com>> I think you are right that the matter of semantics for nested declarations> isn't adequately treated in the DECLARE-TYPE-FREE proposal.  Sigh.  In> order to accommodate those who argued that mechanical code production> might not be able to guarantee a true SUBTYPE relation for the inner> declarations, I would go for a version that treated an inner declaration> as if it were the intersection of the outter one.  How about you?Agreed.  That's what version 6 of DECLARE-TYPE-FREE said:    Clarify that if nested type declarations refer to the same variable,    then the value of the variable must be a member of the intersection of    the declared types.*start*05611 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 11 JAN 89 10:09:46 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 519282; Wed 11-Jan-89 13:09:06 ESTDate: Wed, 11 Jan 89 13:08 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 9)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890105-221446-191@Xerox>Message-ID: <890111130857.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 5 Jan 89 22:14 PST    From: masinter.pa@Xerox.COM    The example I keep coming back to is one where it isn't so much that the    local declaration is easy to enforce as it is where it is difficult *not*    to enforce it.    Suppose I have    (defun frob (delta)     (flet ((more (x) (+ x delta)))	    ;; if you like, put (declare (inline more)) here       (typecase delta	    (float (locally (declare (type float delta))		    ... (more rho ) ... ))	   ((signed-byte 8)		    (locally (declare (type (signed-byte 8) delta))		    ... (more zz) ... ))	...)))[Parens added.]    Even without the inline, it is a common & legal transformation to do inline    substitution on "small" fletted functions.Absolutely. But not textually. Semantically. For example, you alreadyhave to watch for:(defun add (x y) (+ x y))(defun frob (delta)  (flet ((more (x) (add x delta)))    (flet ((add (x y) (- x y)))      ... (more x) ...)))    Even though the reference "delta" in the definition of more isn't    within the lexical scope of the local declaration, it *is* the same    delta.Right. But that itself implies nothing.    While its not impossible to maintain a separate contour in order to    segregate the type declarations, it seems like unnecessary work, It is not unnecessary. You cannot just substitute a piece of unadornedtext. You have to do the substitution at a lower level using an adornedcall tree or else you have to have resolved out all the relevant lexical things before you start merging source (ie, you have to have assured thatthe flet problem is not going to happen). If your approach is the former,it's possible (maybe even "easy" or at least "standard practice") torepresent every reference to a variable with a pointer to the lexicalenvironment it came from, so you can get the lookup right. If yourapproach is the latter, then it's possible to make all the declarationsexplicit as you do the code-walk looking for flets and whatnot so thatyou don't have to rely on DECLARE info afterward. In that case, the resultof your traversal should be: (defun frob (delta)   (typecase delta     (float ... ((lambda (x) (+ x delta)) rho) ...)     ((signed-byte 8)      ... ((lambda (x) (+ x delta)) zz) ... )     ...))    ... and in fact, the declaration is quite useful if "more" is inlined.Actually, in this case it doesn't provide any information thatthe compiler can't figure out from the TYPECASE. A good compileris not limited in its type inferencing to what has been declared.It can tell that no SETQ is going on, so it can propagate the typefrom the TYPECASE directly without even the aid of the DECLARE.Let's look at a better example which is opaque to the compiler:(defun frob (n m)  (frob1 (cond ((and (typep n 'fixnum) (typep m 'fixnum)) 'fixnum)	       ((and (typep n 'float)  (typep m 'float))  'float)	       (t 't))	 n m))(defun frob1 (type n m)  (flet ((zap () (+ n m)))    (case type      (fixnum (locally (declare (fixnum n m)) (zap)))      (float  (locally (declare (float  n m)) (zap)))      (otherwise (zap)))))In this case, I agree you're potentially losing some slight amountof efficiency, but ... (a) You could use MACROLET instead to get back that efficiency.     I personally believe that it is stylistically the correct     thing for this situation. (b) There is a twin brother of this example which I don't want to     let through, and which your proposal would force me to reckon     with:     (defun frob (n m)       (frob1 (cond ((and (typep n 'fixnum) (typep m 'fixnum)) 'fixnum)		    ((and (typep n 'float)  (typep m 'float))  'float)		    (t 't))	      #'(lambda () 	          (declare (special n m))		  (let ((nn n) (mm m))		    (setq n nil m nil)		    (setq n nn  m mm)		    (+ n m)))	      n m))          (defun frob1 (type fn n m)       (declare (special n m))       (flet ((zap () (funcall fn)))	 (case type	   (fixnum (locally (declare (fixnum n m)) (zap)))	   (float  (locally (declare (float  n m)) (zap)))	   (otherwise (zap)))))     In your interpretation, this code is in error, while in my     interpretation, this code is valid. I consider it a gross     modularity violation for the effect of a type declaration to     have other than lexical scope.     The only alternatives seem to me to be:	- Don't do local type declarations on special variables.	  [This costs efficiency in other places, so your proposal	   would be trading one kind of efficiency barrier for	   another.]	- Scope type declarations for special variables differently	  for lexical and dynamic variables. Curiously, you would	  have lexical variables enforce their type declarations	  dynamically, and dynamic variables enforce their type	  declarations lexically.	- Scope all type declarations lexically.     The only one I have any support for is still the third, which     is Moon's LEXICAL proposal.*start*05759 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 14:34:12 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Jan 89  12:25:42 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 519282; Wed 11-Jan-89 13:09:06 ESTDate: Wed, 11 Jan 89 13:08 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 9)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890105-221446-191@Xerox>Message-ID: <890111130857.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 5 Jan 89 22:14 PST    From: masinter.pa@Xerox.COM    The example I keep coming back to is one where it isn't so much that the    local declaration is easy to enforce as it is where it is difficult *not*    to enforce it.    Suppose I have    (defun frob (delta)     (flet ((more (x) (+ x delta)))	    ;; if you like, put (declare (inline more)) here       (typecase delta	    (float (locally (declare (type float delta))		    ... (more rho ) ... ))	   ((signed-byte 8)		    (locally (declare (type (signed-byte 8) delta))		    ... (more zz) ... ))	...)))[Parens added.]    Even without the inline, it is a common & legal transformation to do inline    substitution on "small" fletted functions.Absolutely. But not textually. Semantically. For example, you alreadyhave to watch for:(defun add (x y) (+ x y))(defun frob (delta)  (flet ((more (x) (add x delta)))    (flet ((add (x y) (- x y)))      ... (more x) ...)))    Even though the reference "delta" in the definition of more isn't    within the lexical scope of the local declaration, it *is* the same    delta.Right. But that itself implies nothing.    While its not impossible to maintain a separate contour in order to    segregate the type declarations, it seems like unnecessary work, It is not unnecessary. You cannot just substitute a piece of unadornedtext. You have to do the substitution at a lower level using an adornedcall tree or else you have to have resolved out all the relevant lexical things before you start merging source (ie, you have to have assured thatthe flet problem is not going to happen). If your approach is the former,it's possible (maybe even "easy" or at least "standard practice") torepresent every reference to a variable with a pointer to the lexicalenvironment it came from, so you can get the lookup right. If yourapproach is the latter, then it's possible to make all the declarationsexplicit as you do the code-walk looking for flets and whatnot so thatyou don't have to rely on DECLARE info afterward. In that case, the resultof your traversal should be: (defun frob (delta)   (typecase delta     (float ... ((lambda (x) (+ x delta)) rho) ...)     ((signed-byte 8)      ... ((lambda (x) (+ x delta)) zz) ... )     ...))    ... and in fact, the declaration is quite useful if "more" is inlined.Actually, in this case it doesn't provide any information thatthe compiler can't figure out from the TYPECASE. A good compileris not limited in its type inferencing to what has been declared.It can tell that no SETQ is going on, so it can propagate the typefrom the TYPECASE directly without even the aid of the DECLARE.Let's look at a better example which is opaque to the compiler:(defun frob (n m)  (frob1 (cond ((and (typep n 'fixnum) (typep m 'fixnum)) 'fixnum)	       ((and (typep n 'float)  (typep m 'float))  'float)	       (t 't))	 n m))(defun frob1 (type n m)  (flet ((zap () (+ n m)))    (case type      (fixnum (locally (declare (fixnum n m)) (zap)))      (float  (locally (declare (float  n m)) (zap)))      (otherwise (zap)))))In this case, I agree you're potentially losing some slight amountof efficiency, but ... (a) You could use MACROLET instead to get back that efficiency.     I personally believe that it is stylistically the correct     thing for this situation. (b) There is a twin brother of this example which I don't want to     let through, and which your proposal would force me to reckon     with:     (defun frob (n m)       (frob1 (cond ((and (typep n 'fixnum) (typep m 'fixnum)) 'fixnum)		    ((and (typep n 'float)  (typep m 'float))  'float)		    (t 't))	      #'(lambda () 	          (declare (special n m))		  (let ((nn n) (mm m))		    (setq n nil m nil)		    (setq n nn  m mm)		    (+ n m)))	      n m))          (defun frob1 (type fn n m)       (declare (special n m))       (flet ((zap () (funcall fn)))	 (case type	   (fixnum (locally (declare (fixnum n m)) (zap)))	   (float  (locally (declare (float  n m)) (zap)))	   (otherwise (zap)))))     In your interpretation, this code is in error, while in my     interpretation, this code is valid. I consider it a gross     modularity violation for the effect of a type declaration to     have other than lexical scope.     The only alternatives seem to me to be:	- Don't do local type declarations on special variables.	  [This costs efficiency in other places, so your proposal	   would be trading one kind of efficiency barrier for	   another.]	- Scope type declarations for special variables differently	  for lexical and dynamic variables. Curiously, you would	  have lexical variables enforce their type declarations	  dynamically, and dynamic variables enforce their type	  declarations lexically.	- Scope all type declarations lexically.     The only one I have any support for is still the third, which     is Moon's LEXICAL proposal.*start*01215 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 14:34:20 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Jan 89  12:25:07 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 519258; 11 Jan 89 12:20:25 ESTDate: Wed, 11 Jan 89 12:20 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 9)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890103003245.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <890111122017.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Btw, I spoke last week on the phone to Jonathan Rees about this. He's notyet gotten around to sending mail but he said...  - he doesn't think the ALLOW proposal is a good idea  - the ALLOW proposal is inconsistent with the proposal in    SYMBOL-MACROLET-SEMANTICSHe hadn't seen the actual LEXICAL proposal yet, but from my descriptionof the differences, he seemed pretty firm on the idea that it was theright idea.*start*01502 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 14:59:39 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Jan 89  14:46:01 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 519656; Wed 11-Jan-89 17:44:14 ESTDate: Wed, 11 Jan 89 17:44 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 9)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.Stanford.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <19890103003245.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Supersedes: <890111122017.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <890111174402.1.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Wed, 11 Jan 89 12:20 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    Btw, I spoke last week on the phone to Jonathan Rees about this. He's not    yet gotten around to sending mail but he said...      - he doesn't think the ALLOW proposal is a good idea      - the ALLOW proposal is inconsistent with the proposal in	SYMBOL-MACROLET-SEMANTICSOops. I meant to say "SYMBOL-MACROLET-DECLARE", of course.    He hadn't seen the actual LEXICAL proposal yet, but from my description    of the differences, he seemed pretty firm on the idea that it was the    right idea.*start*00868 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 15:23:28 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  15:21:49 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 11 JAN 89 15:20:33 PSTDate: 11 Jan 89 15:20 PSTFrom: masinter.paSubject: Re: Issue: DECLARE-TYPE-FREE (Version 9)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 11 Jan 89 17:44 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890111-152033-10869@Xerox>I've been convinced that LEXICAL is reasonable ... Version 9 was released to X3J13 & I think we can probably vote on theLEXICAL proposal at the meeting.*start*01454 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 16:14:45 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 11 Jan 89  16:13:07 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa08811; 11 Jan 89 23:55 GMTDate: Wed, 11 Jan 89 23:58:03 GMTMessage-Id: <18529.8901112358@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: DECLARE-TYPE-FREE (Version 9)To: Kent M Pitman <KMP@scrc-stony-brook.arpa>, Moon@scrc-stony-brook.arpaIn-Reply-To: Kent M Pitman's message of Wed, 11 Jan 89 12:20 ESTCc: CL-Cleanup@sail.stanford.edu> Btw, I spoke last week on the phone to Jonathan Rees about this. He's not> yet gotten around to sending mail but he said...>   - he doesn't think the ALLOW proposal is a good idea>   - the ALLOW proposal is inconsistent with the proposal in>     SYMBOL-MACROLET-SEMANTICS> He hadn't seen the actual LEXICAL proposal yet, but from my description> of the differences, he seemed pretty firm on the idea that it was the> right idea.I agree.  The SYMBOL-MACROLET proposal expalins type declarations asequiv to adding THE <type> to the expansion; and that's also theexplanation for LEXICAL.  I support both.  And votes on these issuesshould at least be consistent.*start*01290 00024 US Return-Path: <Gray@DSG.csc.ti.com>Received: from ti.com ([10.7.0.46]) by Xerox.COM ; 11 JAN 89 08:20:07 PSTReceived: by ti.com id AA09880; Wed, 11 Jan 89 10:21:03 CSTReceived: from Kelvin by tilde id AA22744; Wed, 11 Jan 89 10:08:23 CSTMessage-Id: <2809527001-3602765@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 11 Jan 89 10:10:01 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Jon L White <jonl@lucid.com>Cc: masinter.pa, CL-Cleanup@sail.stanford.eduSubject: Re: Issue: DECLARE-TYPE-FREE (Version 9)In-Reply-To: Msg of Tue, 10 Jan 89 22:46:24 PST from Jon L White <jonl@lucid.com>> I think you are right that the matter of semantics for nested declarations> isn't adequately treated in the DECLARE-TYPE-FREE proposal.  Sigh.  In> order to accommodate those who argued that mechanical code production> might not be able to guarantee a true SUBTYPE relation for the inner> declarations, I would go for a version that treated an inner declaration> as if it were the intersection of the outter one.  How about you?Agreed.  That's what version 6 of DECLARE-TYPE-FREE said:    Clarify that if nested type declarations refer to the same variable,    then the value of the variable must be a member of the intersection of    the declared types.*start*01446 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 12 JAN 89 03:08:12 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04762g; Thu, 12 Jan 89 03:05:07 PSTReceived: by bhopal id AA01044g; Thu, 12 Jan 89 03:07:24 PSTDate: Thu, 12 Jan 89 03:07:24 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901121107.AA01044@bhopal>To: Gray@DSG.csc.ti.comCc: masinter.pa, CL-Cleanup@sail.stanford.eduIn-Reply-To: David N Gray's message of Wed, 11 Jan 89  10:10:01 CST <2809527001-3602765@Kelvin>Subject: Issue: DECLARE-TYPE-FREE (Version 9)re: [JonL] I would go for a version that treated an inner declaration           as if it were the intersection of the outter one.  How about you?    [Gray] Agreed.  That's what version 6 of DECLARE-TYPE-FREE said:      Clarify that if nested type declarations refer to the same variable,      then the value of the variable must be a member of the intersection of      the declared types.Version 2 (but not Version 1) also had that phraseology in it.   Looks like that paragraph fell into "Masinter's Hole" (that's the hole that Larry said he hoped he wouldn't dig himself into when he began tinkeringwith it late at night, just before Releasing it to X3J13).  Probably Moonlost track of it when he added the LEXICAL proposal (i.e., trying to fillin the "Hole").  We definitely need that phrase.-- JonL --*start*10600 00024 US Date: 12 Jan 89 10:55 PSTFrom: masinter.paSubject: Issue: DECLARE-TYPE-FREE (Version 10)To: cl-cleanup@Sail.Stanford.Educc: masinterline-fold: NoI'm not distributing this to X3J13 just in case there are *more*edits necessary.Forum:         CleanupIssue:         DECLARE-TYPE-FREEReferences:    CLtL p.158               DECLARATION-SCOPERelated issues: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS               DECLARATION-SCOPE               SPECIAL-TYPE-SHADOWINGCategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL                Version 5, 30-Sep-88, Masinter (cost to implementors)               Version 6, 06-Oct-88, Pitman (minor edits in Discussion)               Version 7,  5-Dec-88, Masinter (scope->extent)               Version 8,  7-Dec-88, Masinter (back to scope)               Version 9,  2-Jan-89, Moon (2 proposals, to clarify discussion)               Version 10, 12-Jan-89, Masinter (add back lost v.6 phrase                                                 re nested declarations)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))        (locally (declare (fixnum x y))             ;LOCALLY does not bind          ...algorithm using x and y...)            ; any variables.        ...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))                                  ;'y' is not being bound in        (declare (fixnum y))                        ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any expression   within the scope of the declaration,  it is an error for the value of  the declared variable not to be of the declared type. For declarations  that are associated with variable bindings, the type declaration also  applies to the initial binding of the variable. In the special case  of a declaration for which there are no executable expressions  within the scope of the declaration (e.g., (locally (declare (integer x)))),  the result is as if there were executable expressions.  In this proposal, a type declaration affects not only variable  references within its scope, but also affects variable references that  are outside the scope of the declaration but dynamically inside the  execution of a form that is itself inside the scope of the  declaration.  Such references can exist when the variable is SPECIAL  or when the declaration is not attached to the variable's binding, so  that the scope of the declaration does not include the entire scope  of the variable.  Clarify that if nested type declarations refer to the same variable,  then the value of the variable must be a member of the intersection of  the declared types.Proposal (DECLARE-TYPE-FREE:LEXICAL):  Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any reference to the  declared variable within the scope of the declaration, it is an error for  the value of the declared variable not to be of the declared type; and  during the execution of any SETQ of the declared variable within the scope  of the declaration, it is an error for the newly assigned value of the  declared variable not to be of the declared type; and at the moment the  scope of the declaration is entered, it is an error for the value of the  declared variable not to be of the declared type.  In this proposal, a type declaration affects only variable references within  its scope, and the meaning of "free" and "variable-binding-associated" type  declarations can be described identically.  This proposal is equivalent to saying that the meaning of a type declaration  is equivalent to changing each reference to <var> within the scope of the  declaration to (THE <type> <var>), changing each expression assigned to the  variable within the scope of the declaration to (THE <type> <new-value>),  and executing (THE <type> <var>) at the moment the scope of the declaration  is entered.  Clarify that if nested type declarations refer to the same variable,  then the value of the variable must be a member of the intersection of  the declared types.Examples:;; this is an error under DECLARE-TYPE-FREE:ALLOW:;; the assertion that x is a fixnum is violated between the two ;; calls to (zap);; this is a valid program under DECLARE-TYPE-FREE:LEXICAL        (let ((x 12) (y 'foo))          (flet ((zap () (rotatef x y)))            (locally (declare (fixnum x))              (zap)              (zap)              x)));; this is an error under both proposals        (let ((x 12) (y 'foo))          (flet ((zap () (rotatef x y)))            (locally (declare (fixnum x))              (zap)              (print x)	      (zap)              x)));; this is an error under DECLARE-TYPE-FREE:ALLOW, because;; the assertion that x is a fixnum;; is violated during the call to zap, even though few ;; implementations will be able to check:;; this is a valid program under DECLARE-TYPE-FREE:LEXICAL        (let ((x 12) (y 'foo))          (flet ((zap ()                   (rotatef x y)                   (rotatef x y)))            (locally (declare (fixnum x))              (zap)              x)));; this is an error under both proposals, even though the;; violation of the type constraint happens after the form;; with the declaration is exited.   (let ((f (let ((x 3))              (declare (fixnum x))              #'(lambda (z) (incf x z)))))     (funcall f 4.3))Rationale:  This proposal enables optimizing compilers to make use of the otherwise  ignored type information.  Many people have often asked for it, and  there is no strong reason to forbid it.    DECLARE-TYPE-FREE:ALLOW is more restrictive on programs and hence allows  more freedom for optimizing compilers.  DECLARE-TYPE-FREE:LEXICAL is easier  to understand but allows a specialized representation only where the scope  of the variable is the same as the scope of the declaration or the compiler  can prove that there are no relevant other references to the variable.Current practice:  Lucid Common Lisp allows "free" type declarations;  under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))           ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))         (locally (declare (type number x))           ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))        TITAN 
         TITAN 
                                              ,              n                                               $      m       &             
            (f z*start*10733 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 11:07:16 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Jan 89  11:05:47 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 12 JAN 89 10:56:13 PSTDate: 12 Jan 89 10:55 PSTFrom: masinter.paSubject: Issue: DECLARE-TYPE-FREE (Version 10)To: cl-cleanup@Sail.Stanford.Educc: masinter.paline-fold: NoMessage-ID: <890112-105613-12795@Xerox>I'm not distributing this to X3J13 just in case there are *more*edits necessary.!Forum:         CleanupIssue:         DECLARE-TYPE-FREEReferences:    CLtL p.158               DECLARATION-SCOPERelated issues: FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS               DECLARATION-SCOPE               SPECIAL-TYPE-SHADOWINGCategory:      CLARIFICATION/ADDITIONEdit history:  Version 1, 18-Sep-88, Moon               Version 2, 22-Sep-88, Moon                (small edits to reflect mail discussion)               Version 3, 22-Sep-88, Masinter               Version 4, 27-Sep-88, JonL                Version 5, 30-Sep-88, Masinter (cost to implementors)               Version 6, 06-Oct-88, Pitman (minor edits in Discussion)               Version 7,  5-Dec-88, Masinter (scope->extent)               Version 8,  7-Dec-88, Masinter (back to scope)               Version 9,  2-Jan-89, Moon (2 proposals, to clarify discussion)               Version 10, 12-Jan-89, Masinter (add back lost v.6 phrase                                                 re nested declarations)Problem description:  Section 9.2 of CLtL, p158, says that a declaration specifier like  (TYPE type var1 var2 ...) "... affects only variable bindings".    Since declarations can occur in contexts other than establishing   "variable bindings", most people interpret this statement to mean   that type declarations not in such context are either (1) completely   to be ignored, or (2) invalid CL  syntax.  Thus both of the following   forms would be suspect in that the type declarations could not have   any effect:    (if (and (typep x 'fixnum) (typep y 'fixnum))        (locally (declare (fixnum x y))             ;LOCALLY does not bind          ...algorithm using x and y...)            ; any variables.        ...similar algorithm using x and y...)    (let ((y 'foo))      (setq y 10)      (let ((x 5))                                  ;'y' is not being bound in        (declare (fixnum y))                        ; this particular context.        (incf y)         ...random algorithm...))Proposal (DECLARE-TYPE-FREE:ALLOW):    Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any expression   within the scope of the declaration,  it is an error for the value of  the declared variable not to be of the declared type. For declarations  that are associated with variable bindings, the type declaration also  applies to the initial binding of the variable. In the special case  of a declaration for which there are no executable expressions  within the scope of the declaration (e.g., (locally (declare (integer x)))),  the result is as if there were executable expressions.  In this proposal, a type declaration affects not only variable  references within its scope, but also affects variable references that  are outside the scope of the declaration but dynamically inside the  execution of a form that is itself inside the scope of the  declaration.  Such references can exist when the variable is SPECIAL  or when the declaration is not attached to the variable's binding, so  that the scope of the declaration does not include the entire scope  of the variable.  Clarify that if nested type declarations refer to the same variable,  then the value of the variable must be a member of the intersection of  the declared types.Proposal (DECLARE-TYPE-FREE:LEXICAL):  Specify that a type declaration does not only "affect variable bindings";  rather, type declarations are legal in all declarations. The interpretation  of a type declaration is that, during the execution of any reference to the  declared variable within the scope of the declaration, it is an error for  the value of the declared variable not to be of the declared type; and  during the execution of any SETQ of the declared variable within the scope  of the declaration, it is an error for the newly assigned value of the  declared variable not to be of the declared type; and at the moment the  scope of the declaration is entered, it is an error for the value of the  declared variable not to be of the declared type.  In this proposal, a type declaration affects only variable references within  its scope, and the meaning of "free" and "variable-binding-associated" type  declarations can be described identically.  This proposal is equivalent to saying that the meaning of a type declaration  is equivalent to changing each reference to <var> within the scope of the  declaration to (THE <type> <var>), changing each expression assigned to the  variable within the scope of the declaration to (THE <type> <new-value>),  and executing (THE <type> <var>) at the moment the scope of the declaration  is entered.  Clarify that if nested type declarations refer to the same variable,  then the value of the variable must be a member of the intersection of  the declared types.Examples:;; this is an error under DECLARE-TYPE-FREE:ALLOW:;; the assertion that x is a fixnum is violated between the two ;; calls to (zap);; this is a valid program under DECLARE-TYPE-FREE:LEXICAL        (let ((x 12) (y 'foo))          (flet ((zap () (rotatef x y)))            (locally (declare (fixnum x))              (zap)              (zap)              x)));; this is an error under both proposals        (let ((x 12) (y 'foo))          (flet ((zap () (rotatef x y)))            (locally (declare (fixnum x))              (zap)              (print x)	      (zap)              x)));; this is an error under DECLARE-TYPE-FREE:ALLOW, because;; the assertion that x is a fixnum;; is violated during the call to zap, even though few ;; implementations will be able to check:;; this is a valid program under DECLARE-TYPE-FREE:LEXICAL        (let ((x 12) (y 'foo))          (flet ((zap ()                   (rotatef x y)                   (rotatef x y)))            (locally (declare (fixnum x))              (zap)              x)));; this is an error under both proposals, even though the;; violation of the type constraint happens after the form;; with the declaration is exited.   (let ((f (let ((x 3))              (declare (fixnum x))              #'(lambda (z) (incf x z)))))     (funcall f 4.3))Rationale:  This proposal enables optimizing compilers to make use of the otherwise  ignored type information.  Many people have often asked for it, and  there is no strong reason to forbid it.    DECLARE-TYPE-FREE:ALLOW is more restrictive on programs and hence allows  more freedom for optimizing compilers.  DECLARE-TYPE-FREE:LEXICAL is easier  to understand but allows a specialized representation only where the scope  of the variable is the same as the scope of the declaration or the compiler  can prove that there are no relevant other references to the variable.Current practice:  Lucid Common Lisp allows "free" type declarations;  under some   circumstances the compiler issues a warning message that such usage   is an extension to Common Lisp.Cost to Implementors:  Implementations that might currently warn about such declarations  would have to remove the warning; otherwise, it is valid to ignore   type declarations.Cost to Users:  None, this is a compatible addition.Cost of non-adoption:  Common Lisp will be less self-consistent.Benefits:  Programmers will be able to use type declaration to express their  intent, rather than having to manually insert THE wrappers around   every reference.Esthetics:  It is a simpler interpretation for type declaration specifiers, with  fewer special cases; hence reduces the number of exceptions in the  language.Discussion:  Another cleanup issue, DECLARATION-SCOPE, addresses the scope of   declarations. This proposal carefully uses the phrase "within the   scope of the declaration" to avoid confounding the two issues.   This issue has been discussed at the Fort Collins X3J13 meeting in  November 1987, and at length on the various electronic mailing lists.  At least one current implementation is able to generate more efficient  code when declarations are associated with a particular binding, since  it then has the option to choose type-specific specialized storage for   the runtime value of the variable.  So, for example,       (let ((x v)) (declare (type float x)) (+ x x))  is sometimes more efficient than      (let ((x v)) (locally (declare (type float x)) (+ x x)))  However, the local type declarations allowed by this proposal do  provide some useful information, even if it is not the *most* useful.  It is possible for a sufficiently "smart" compiler to infer the   equivalent of a "binding declaration" when it can ascertain that the   type of the binding value -- 'v' above -- is commensurate with the   type locally declared over the scope of usage of the variable.  It may be useful for a compiler to issue a warning whenever it finds  nested type declarations referring to the same variable and the  intersection of the declared types is null.  Documentation might want to discuss the style implications of  nested declarations intersecting. The interesting cases are:   - An inner declaration could be a subtype of an outer one.     This is the most useful case and probably the only one to     be encouraged in code written by humans. e.g.,       (locally (declare (type number x))         (locally (declare (type integer x))           ...use X as integer...))   - An outer declaration could be a subtype of an inner one.     This is useless but harmless. It might happen as the result     of certain macro situations. e.g.,       (locally (declare (type integer x))         (locally (declare (type number x))           ...use X as integer...))   - Two types may only partially overlap. This would presumably     happen only as the result of a macro expansion.       (locally (declare (type fixnum x))         (locally (declare (type (or bit package) x))           ...use X as BIT...))*start*00603 00024 US Date:  3 Feb 89 23:46 PSTFrom: masinter.paSubject: Issue: DECLARE-TYPE-FREE (Version 10)To: moon@symbolics.comcc: masinter.paYour notes said "DECLARE-TYPE-FREE (Version 9, 02-Jan-89) Author:   Moon, Masinter, JonL, Pitman Forum:    Cleanup Status:   Accepted LEXICAL (v10), with amendment to add back something about           nested type declarations mean the value has to be in the intersectionHowever, Version 10 had the added paragraph; my notes are that the :LEXICAL proposal to DECLARE-TYPE-FREE (Version 10, 12-Jan-89) passed without amendment.Do you agree?*start*01360 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 07 FEB 89 11:16:11 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 534898; Tue 7-Feb-89 12:25:59 ESTDate: Tue, 7 Feb 89 12:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-TYPE-FREE (Version 10)To: masinter.paIn-Reply-To: <890203-234704-2879@Xerox>Message-ID: <19890207172627.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 3 Feb 89 23:46 PST    From: masinter.pa@Xerox.COM    Your notes said "DECLARE-TYPE-FREE (Version 9, 02-Jan-89)     Author:   Moon, Masinter, JonL, Pitman     Forum:    Cleanup     Status:   Accepted LEXICAL (v10), with amendment to add back something               about               nested type declarations mean the value has to be in the               intersection    However, Version 10 had the added paragraph; my notes are that the :LEXICAL    proposal to DECLARE-TYPE-FREE (Version 10, 12-Jan-89) passed without    amendment.    Do you agree?I rechecked my notes and I think what I called an amendment was actuallya description of the difference between version 9 and version 10 (whichI had not seen before the meeting).  So I agree.*start*03030 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at  7-Apr-89 11:44:21 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 APR 89 11:15:59 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 7 Apr 89  10:59:26 PDTReceived: from fafnir.think.com by Think.COM; Fri, 7 Apr 89 13:23:25 EDTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 7 Apr 89 13:23:54 EDTReceived: by verdi.think.com; Fri, 7 Apr 89 13:20:57 EDTDate: Fri, 7 Apr 89 13:20:57 EDTFrom: Guy Steele <gls@Think.COM>Message-Id: <8904071720.AA18178@verdi.think.com>To: rpg@lucid.comCc: gls@Think.COM, x3j13@sail.stanford.eduIn-Reply-To: Richard P. Gabriel's message of Thu, 6 Apr 89 15:19:42 PDT <8904062219.AA00440@challenger>Subject: Did you blow it?   Date: Thu, 6 Apr 89 15:19:42 PDT   From: Richard P. Gabriel <rpg@lucid.com>   When I read the effect of Issue: DECLARE-TYPE-FREE on page 223, I   completely flipped. I think you might have gotten it wrong.   You say that in this code:   (defun f (x)     (declare (type float x))     (let ((x 'a)) ...)      ...)   The declaration affects both bindings of x. This cannot make any sense   at all.  I don't have marked which version of this issue passed, but I   think neither implies this. The most that is implied is that if you   say this:   (defun f (x)     ...     (let ((y 'a))      (declare (type float x))      ...)     ...)   then the declaration applies to variable references within the let-y   and not to within some larger scope.   I hope you are wedged, because otherwise the proposal is wedged.I also hope I am wedged.  I am taking the liberty of cc'ing thisto X3J13 so that others can let me know what they think.I believe I was confused by this paragraph from proposalDECLARE-TYPE-FREE:LEXICAL, passed January 1989:  This proposal is equivalent to saying that the meaning of a type declaration  is equivalent to changing each reference to <var> within the scope of the  declaration to (THE <type> <var>), changing each expression assigned to the  variable within the scope of the declaration to (THE <type> <new-value>),  and executing (THE <type> <var>) at the moment the scope of the declaration  is entered.The ambiguity concerns whether in   (defun f (x)     (declare (type float x))     x     ;reference 1     (let ((x 'a)) ...)       x   ;reference 2       ...)the two references are construed to be to the same *variable*.(I readily grant that they refer to different *bindings*.)I assumed that they were contrued to be the same variable,in which case I believe that what I wrote on page 223 of theCLtL II draft is a correct conclusion.Now that you have pointed it out, I agree that a more likelyand more desirable interpretation is that the references areconsidered to be to different variables.  Question: what if xhad been proclaimed SPECIAL?  Then what would the interpretation be?--Guy*start*05268 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at  7-Apr-89 15:28:47 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 APR 89 14:36:21 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 7 Apr 89  14:20:08 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 573609; Fri 7-Apr-89 17:19:10 EDTDate: Fri, 7 Apr 89 17:18 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Did you blow it?To: Guy Steele <gls@Think.COM>, rpg@lucid.comcc: x3j13@sail.stanford.eduIn-Reply-To: <8904071720.AA18178@verdi.think.com>Message-ID: <19890407211851.9.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 7 Apr 89 13:20:57 EDT    From: Guy Steele <gls@Think.COM>       Date: Thu, 6 Apr 89 15:19:42 PDT       From: Richard P. Gabriel <rpg@lucid.com>       When I read the effect of Issue: DECLARE-TYPE-FREE on page 223, I       completely flipped. I think you might have gotten it wrong.He did.       You say that in this code:       (defun f (x)	 (declare (type float x))	 (let ((x 'a)) ...)	  ...)       The declaration affects both bindings of x. This cannot make any sense       at all.  I don't have marked which version of this issue passed, but I       think neither implies this. The most that is implied is that if you       say this:       (defun f (x)	 ...	 (let ((y 'a))	  (declare (type float x))	  ...)	 ...)       then the declaration applies to variable references within the let-y       and not to within some larger scope.       I hope you are wedged, because otherwise the proposal is wedged.    I also hope I am wedged.  I am taking the liberty of cc'ing this    to X3J13 so that others can let me know what they think.    I believe I was confused by this paragraph from proposal    DECLARE-TYPE-FREE:LEXICAL, passed January 1989:      This proposal is equivalent to saying that the meaning of a type declaration      is equivalent to changing each reference to <var> within the scope of the      declaration to (THE <type> <var>), changing each expression assigned to the      variable within the scope of the declaration to (THE <type> <new-value>),      and executing (THE <type> <var>) at the moment the scope of the declaration      is entered.    The ambiguity concerns whether in       (defun f (x)	 (declare (type float x))	 x     ;reference 1	 (let ((x 'a)) ...)	   x   ;reference 2	   ...)    the two references are construed to be to the same *variable*.    (I readily grant that they refer to different *bindings*.)    I assumed that they were contrued to be the same variable,    in which case I believe that what I wrote on page 223 of the    CLtL II draft is a correct conclusion.The phrase "within the scope of the declaration" quoted above issupposed to be a precisely defined phrase.  The passed cleanupissue DECLARATION-SCOPE was supposed to define that phrase.Unfortunately, there is a problem: the precise language in version2 of the proposal was replaced with much less precise language in version 4, which was the version that was voted upon.The version 2 language was:    The scope of a `bound' declaration is exactly the scope of the  associated lexical variable or function.  If the declaration is  associated with a special variable, the scope is the scope the variable  would have had if it had not been special.    `Free' declarations are scoped as if they appeared in a new LOCALLY form  which surrounded the entire special form at the beginning of whose body  the declaration appears.  This is the same as what CLtL p.155 defines to  be the scope of `pervasive' declarations.This answers your question about special variables.  I think thatfor declarations that concern variable or function bindings, but arenot actually attached to a binding (i.e. are used free), the correctscope is the same as the scope of a non-special binding of that namesurrounding the form to which the binding is attached; the languageabout LOCALLY quoted above is out of date.Gurg.  Your example above is misindented.  If you meant       (defun f (x)	 (declare (type float x))	 x     ;reference 1	 (let ((x 'a))	   x   ;reference 2	   ...)then the scope of the declaration does not include (let ((x 'a)) x ...)because type declarations are not "pervasive".  Thus what you wroteon p.223 of CLtL is wrong.But if you meant       (defun f (x)	 (declare (type float x))	 x     ;reference 1	 (let ((x 'a)) ...)	 x   ;reference 2	 ...)then the example does not address the question since reference 1and reference 2 are clearly both in the scope of the type declaration.    Now that you have pointed it out, I agree that a more likely    and more desirable interpretation is that the references are    considered to be to different variables.  Question: what if x    had been proclaimed SPECIAL?  Then what would the interpretation be?A special declaration should not affect the scope of a type declaration.Now, the version of DECLARATION-SCOPING that actually passed does notactually say that.  But I don't think any other position is arguable.*start*01824 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at  8-Apr-89 16:39:59 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 APR 89 16:39:54 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 8 Apr 89  16:27:13 PDTReceived: from bhopal ([192.43.178.13]) by heavens-gate.lucid.com id AA01867g; Sat, 8 Apr 89 16:21:16 PDTReceived: by bhopal id AA09518g; Sat, 8 Apr 89 16:27:49 PDTDate: Sat, 8 Apr 89 16:27:49 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8904082327.AA09518@bhopal>To: gls@Think.COMCc: rpg@lucid.com, x3j13@sail.stanford.eduIn-Reply-To: Guy Steele's message of Fri, 7 Apr 89 13:20:57 EDT <8904071720.AA18178@verdi.think.com>Subject: Did you blow it?re:     I believe I was confused by this paragraph from proposal    DECLARE-TYPE-FREE:LEXICAL, passed January 1989:      This proposal is equivalent to saying that the meaning of a type       declaration is equivalent to changing each reference to <var> within       the scope of the declaration to (THE <type> <var>), changing each       expression assigned to the variable within the scope of the declaration       to (THE <type> <new-value>), and executing (THE <type> <var>) at the       moment the scope of the declaration is entered.I don't have a copy of the proposal in front of me right now, but Iremember explicitly adding other paragraphs to this proposal which stress that LET and LAMBDA bindings establish "new variables" which are "shielded"from the outter scope's declarations.  Indeed, Maclisp had the "inheritance" behaviour which you are describing, but CLtL is quite explicit about not doing that; and I'm sure that atone time the proposal had wording in it to the effect that this wasn'tbeing changed.-- JonL --