*start*00989 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 29 APR 87 14:36:59 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 127568; Wed 29-Apr-87 17:35:59 EDTDate: Wed, 29 Apr 87 17:35 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Status of TAILP-NILTo: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <870427-130708-1239@Xerox>Message-ID: <870429173534.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 27 Apr 87 13:15 PDT    From: Masinter.pa@Xerox.COM    ...    TAILP-NIL	Received but not discussed	Need volunteer to lead discussion, summarize positions.    ...I cannot find any reference to this in any CL-Cleanup mail thatI have, other than mentions of it in the status summaries you'vesent out from time to time. Could you forward me a copy of it?Thanks.*start*01458 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 29 MAY 87 23:11:43 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 29 May 87  23:09:56 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 29 MAY 87 22:36:59 PDTDate: 29 May 87 22:36 PDTFrom: Masinter.paSubject: Issue: TAILP-NILto: CL-cleanup@Sail.stanford.eduMessage-ID: <870529-223659-1341@Xerox>I've been putting this issue in the status list, but had never mailed itout. It is not yet in proper format. For the record:Issue: TAILP-NILReference: Steele p.275Category: clarificationDescription:The description of tailp in Steele differs from current implementationsin the case where the first argument is NIL. In particular, the secondsentence "Another way to look at this is tailp is true if (nthcdr nlist) is sublist, for some value of n." does not accurately describecurrent practice for the case where sublist is nil.The behavior of TAILP on circular structures is also unspecified, e.g.,is  (tailp '() '#0=(x . #0#)) meaningful?Proposal: TAILP-NIL:RETURN-NILClarify that (TAILP NIL X) returns NIL for all lists X, and that tailpmust be true-false-indeterminate equivalent to (defun tailp (x y)   (and x y (or (eq x y) (tailp x (cdr y)))))i.e., if the second argument is circular and the first argument is not a"tail" of the non-circular part of it, tailp may loop indefinitely.*start*01318 00024 USfReturn-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 JUN 87 20:42:51 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 1 Jun 87  20:41:01 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 161243; Mon 1-Jun-87 23:36:32 EDTDate: Mon, 1 Jun 87 23:36 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NILTo: CL-cleanup@Sail.stanford.eduIn-Reply-To: <870529-223659-1341@Xerox>Message-ID: <870601233632.0.MOON@EUPHRATES.SCRC.Symbolics.COM>I vote against releasing this issue until its writeup is in proper format.When you write the current practice section, mention that Symbolicsfollows the second of the two contradictory sentences in the tailpwriteup, hence (tailp nil <anything>) => t.  This may mean that currentpractice is not uniform.For history, you can mention that the unambiguous definition in theMIT Lisp Machine Manual (I consulted the fourth edition) would require(tailp nil <anything>) => nil.I personally don't care which disambiguation is adopted.  If the writeupincludes a proposal to eliminate the function, I will vote for that, sinceI've never understood what use tailp is.*start*05933 00024 USfDate: 20 Nov 87 14:30 PSTFrom: Masinter.paSubject: Issue: TAILP-NILTo: Hadden@HI-Multics.ARPAcc: Masinterline-fold: NOMy notes say that you volunteered to write this issue up. Theproposal format required is documented at the end.Issue: TAILP-NILReference: Steele p.275Category: clarificationDescription:The description of tailp in Steele differs from current implementationsin the case where the first argument is NIL. In particular, the secondsentence "Another way to look at this is tailp is true if (nthcdr nlist) is sublist, for some value of n." does not accurately describecurrent practice for the case where sublist is nil.The behavior of TAILP on circular structures is also unspecified, e.g.,is  (tailp '() '#0=(x . #0#)) meaningful?Proposal: TAILP-NIL:RETURN-NILClarify that (TAILP NIL X) returns NIL for all lists X, and that tailpmust be true-false-indeterminate equivalent to (defun tailp (x y)   (and x y (or (eq x y) (tailp x (cdr y)))))i.e., if the second argument is circular and the first argument is not a"tail" of the non-circular part of it, tailp may loop indefinitely.     ----- Next Message -----Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 JUN 87 20:42:51 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 1 Jun 87  20:41:01 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 161243; Mon 1-Jun-87 23:36:32 EDTDate: Mon, 1 Jun 87 23:36 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NILTo: CL-cleanup@Sail.stanford.eduIn-Reply-To: <870529-223659-1341@Xerox>Message-ID: <870601233632.0.MOON@EUPHRATES.SCRC.Symbolics.COM>I vote against releasing this issue until its writeup is in proper format.When you write the current practice section, mention that Symbolicsfollows the second of the two contradictory sentences in the tailpwriteup, hence (tailp nil <anything>) => t.  This may mean that currentpractice is not uniform.For history, you can mention that the unambiguous definition in theMIT Lisp Machine Manual (I consulted the fourth edition) would require(tailp nil <anything>) => nil.I personally don't care which disambiguation is adopted.  If the writeupincludes a proposal to eliminate the function, I will vote for that, sinceI've never understood what use tailp is.     ----- End Forwarded Messages -----  Format for proposals to the cleanup committee (Version 13)                    November 20, 1987Replace the text below in >> double inverted angle-brackets <<. Bebrief; leave testimonials and personal opinions to the discussion at theend. Be complete; do not expect someone else to fix or redesign parts.Spell out names (e.g., Masinter rather than LMM) and upper-case all Lispsymbols (DEFUN rather than Defun). I like it better if you write in thethird person rather than first.Issue:         >>A short descriptive label, which starts with a name               which occurs in the index of CLtL, and be a suitable               symbol in the Common Lisp style, e.g., CDR-TERMINATION.<<References:    >>The pages of CLtL which describe the feature being               discussed, and other references, including other               related issues.<<Category:      >>One or more of:               CLARIFICATION -- proposal to resolve an ambiguity or case               of under-specified situation in CLtL, where this               ambiguity interferes with portability of code.               CHANGE -- proposal for an incompatible change.               ADDITION -- proposal for a compatible extension<<Edit history:  >>Author and date of submission (version 1), and author               and date of subsequent versions.<<Problem description:>>Describe the problem being addressed -- why is the current situationunclear or unsatisfactory? Avoid describing the proposal here or arguingfor its adoption. <<Proposal (>>issue-label:proposal-label<<): >> Describe as precisely aspossible what you are proposing.  Ideally, this should take the form oftext that could be dropped into the new specification document.Proposals should be for changes to Common Lisp, rather than changes toCLtL.  If necessary, propose a set of labelled alternatives here, ratherthan a single proposal. Each proposal must be a complete design; do notleave out details.  Avoid arguing for the proposal here, just describeit.<<Test Cases/Examples:>> Examples are samples of Common Lisp code that illustrates the issue.along with explanatory text.Test Cases are simple stand-alone expressions which are valid anddo not signal an error if the proposal is adhered to. (Use ASSERTif you need.)<<Rationale:>> A one or two sentence summary of the arguments that follow. <<Current practice:>>Do some/many/no Common Lisp implementations already work this way?Survey independent Common Lisp implementations - preferably three ormore.<<Cost to Implementors:>>What is the cost to implementors of adopting the proposal?  How muchimplementation effort is required?  Is public-domain code available? Forpervasive changes, can the conversion be automated?<<Cost to Users:>>For incompatible changes, what is the cost to users of convertingexisting user code?  To what extent can the process be automated? How?<<Cost of non-adoption:>>How serious is it if nothing is done? <<Benefits:>>What is better if the proposal is adopted? How serious is the problemif just left as it is? <<Esthetics:>>How does this proposal affect the simplicity of the language, ease oflearning, etc. You can spell it aesthetics if you like. <<Discussion:>> Additional arguments, discussions, endorsements, testimonials, etc.should go here. A blow-by-blow account of debates is not necessary. <<*start*06591 00024 USfReturn-Path: <Network_Server.Daemon@HI-MULTICS.ARPA>Received: from HI-MULTICS.ARPA by Xerox.COM ; 21 NOV 87 14:55:38 PSTDate: Sat, 21 Nov 87 16:55 cstFrom: Network_Server.Daemon@HI-MULTICS.ARPASubject: Unable to deliver mail from Masinter.pa@Xerox.COMTo: Masinter.paRecipient >udd>SoftTech>Hadden>Hadden.mbx at HI-MULTICS.ARPA failed because Allocation could not be performed..******************** Failed message follows. ********************Received: from Xerox.COM by HI-MULTICS.ARPA TCP; 21-Nov-1987 16:55:17-cstReceived: from Cabernet.ms by ArpaGateway.ms ; 20 NOV 87 14:30:29 PSTDate: 20 Nov 87 14:30 PSTFrom: Masinter.pa@Xerox.COMSubject: Issue: TAILP-NILTo: Hadden@HI-Multics.ARPAcc: Masinter.pa@Xerox.COMline-fold: NOMessage-ID: <871120-143029-2063@Xerox>My notes say that you volunteered to write this issue up. Theproposal format required is documented at the end.Issue: TAILP-NILReference: Steele p.275Category: clarificationDescription:The description of tailp in Steele differs from current implementationsin the case where the first argument is NIL. In particular, the secondsentence "Another way to look at this is tailp is true if (nthcdr nlist) is sublist, for some value of n." does not accurately describecurrent practice for the case where sublist is nil.The behavior of TAILP on circular structures is also unspecified, e.g.,is  (tailp '() '#0=(x . #0#)) meaningful?Proposal: TAILP-NIL:RETURN-NILClarify that (TAILP NIL X) returns NIL for all lists X, and that tailpmust be true-false-indeterminate equivalent to(defun tailp (x y)   (and x y (or (eq x y) (tailp x (cdr y)))))i.e., if the second argument is circular and the first argument is not a"tail" of the non-circular part of it, tailp may loop indefinitely.     ----- Next Message -----Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 JUN 87 20:42:51 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 1 Jun 87  20:41:01 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 161243; Mon 1-Jun-87 23:36:32 EDTDate: Mon, 1 Jun 87 23:36 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NILTo: CL-cleanup@Sail.stanford.eduIn-Reply-To: <870529-223659-1341@Xerox>Message-ID: <870601233632.0.MOON@EUPHRATES.SCRC.Symbolics.COM>I vote against releasing this issue until its writeup is in proper format.When you write the current practice section, mention that Symbolicsfollows the second of the two contradictory sentences in the tailpwriteup, hence (tailp nil <anything>) => t.  This may mean that currentpractice is not uniform.For history, you can mention that the unambiguous definition in theMIT Lisp Machine Manual (I consulted the fourth edition) would require(tailp nil <anything>) => nil.I personally don't care which disambiguation is adopted.  If the writeupincludes a proposal to eliminate the function, I will vote for that, sinceI've never understood what use tailp is.     ----- End Forwarded Messages -----  Format for proposals to the cleanup committee (Version 13)                    November 20, 1987Replace the text below in >> double inverted angle-brackets <<. Bebrief; leave testimonials and personal opinions to the discussion at theend. Be complete; do not expect someone else to fix or redesign parts.Spell out names (e.g., Masinter rather than LMM) and upper-case all Lispsymbols (DEFUN rather than Defun). I like it better if you write in thethird person rather than first.Issue:         >>A short descriptive label, which starts with a name               which occurs in the index of CLtL, and be a suitable               symbol in the Common Lisp style, e.g., CDR-TERMINATION.<<References:    >>The pages of CLtL which describe the feature being               discussed, and other references, including other               related issues.<<Category:      >>One or more of:               CLARIFICATION -- proposal to resolve an ambiguity or case               of under-specified situation in CLtL, where this               ambiguity interferes with portability of code.               CHANGE -- proposal for an incompatible change.               ADDITION -- proposal for a compatible extension<<Edit history:  >>Author and date of submission (version 1), and author               and date of subsequent versions.<<Problem description:>>Describe the problem being addressed -- why is the current situationunclear or unsatisfactory? Avoid describing the proposal here or arguingfor its adoption. <<Proposal (>>issue-label:proposal-label<<): >> Describe as precisely aspossible what you are proposing.  Ideally, this should take the form oftext that could be dropped into the new specification document.Proposals should be for changes to Common Lisp, rather than changes toCLtL.  If necessary, propose a set of labelled alternatives here, ratherthan a single proposal. Each proposal must be a complete design; do notleave out details.  Avoid arguing for the proposal here, just describeit.<<Test Cases/Examples:>> Examples are samples of Common Lisp code that illustrates the issue.along with explanatory text.Test Cases are simple stand-alone expressions which are valid anddo not signal an error if the proposal is adhered to. (Use ASSERTif you need.)<<Rationale:>> A one or two sentence summary of the arguments that follow. <<Current practice:>>Do some/many/no Common Lisp implementations already work this way?Survey independent Common Lisp implementations - preferably three ormore.<<Cost to Implementors:>>What is the cost to implementors of adopting the proposal?  How muchimplementation effort is required?  Is public-domain code available? Forpervasive changes, can the conversion be automated?<<Cost to Users:>>For incompatible changes, what is the cost to users of convertingexisting user code?  To what extent can the process be automated? How?<<Cost of non-adoption:>>How serious is it if nothing is done? <<Benefits:>>What is better if the proposal is adopted? How serious is the problemif just left as it is? <<Esthetics:>>How does this proposal affect the simplicity of the language, ease oflearning, etc. You can spell it aesthetics if you like. <<Discussion:>> Additional arguments, discussions, endorsements, testimonials, etc.should go here. A blow-by-blow account of debates is not necessary. <<*start*01136 00024 USaReturn-Path: <alarson@src.honeywell.com>Received: from altura.Honeywell.COM by Xerox.COM ; 05 MAY 88 14:12:22 PDTReturn-Path: <alarson@src.honeywell.com>Received: by altura.Honeywell.COM (5.52/smail2.1/05-12-87)	id AA01650; Thu, 5 May 88 16:08:40 CDTPosted-Date: Thu, 5 May 88 16:08:36 CDTReceived: by pavo.src.honeywell.com (3.2/SMI-3.2)	id AA11357; Thu, 5 May 88 16:08:36 CDTDate: Thu, 5 May 88 16:08:36 CDTFrom: alarson@src.honeywell.com (Aaron Larson)Message-Id: <8805052108.AA11357@pavo.src.honeywell.com>To: masinter.paSubject: my x3j13 responsibilities.It appears that my mail system is stable enough now to begin the work Isigned up for at the second from last x3j13 meeting.  George Haddenindicated that perhaps some of the issues I had signed up for had beengiven to other individuals.  If this is the case, I'm willing to take onsome other tasks.  I have communicated with Cris Perdue regarding thepathname issue, and anticipate having something together in the nearfuture (weeks not months).Also, I would appreciate it if you would put me on the cleanup mailinglist. Thanx.*start*02889 00024 US Date: 23 May 88 14:55 PDTFrom: masinter.paSubject:  Issue: TAILP-NILTo: cl-cleanup@sail.stanford.educc: masinter.paI had promised and neglected to mail out this issue again. This is it. I've asked ALarson@src.honeywell.com to write it up again (under the theory that Hadden@HI-Multics.ARPA had volunteered once before.)      ----- Begin Forwarded Messages -----Date: 20 Nov 87 14:30 PSTFrom: Masinter.paSubject: Issue: TAILP-NILTo: Hadden@HI-Multics.ARPAcc: Masinterline-fold: NOMy notes say that you volunteered to write this issue up. Theproposal format required is documented at the end.Issue: TAILP-NILReference: Steele p.275Category: clarificationDescription:The description of tailp in Steele differs from current implementationsin the case where the first argument is NIL. In particular, the secondsentence "Another way to look at this is tailp is true if (nthcdr nlist) is sublist, for some value of n." does not accurately describecurrent practice for the case where sublist is nil.The behavior of TAILP on circular structures is also unspecified, e.g.,is  (tailp '() '#0=(x . #0#)) meaningful?Proposal: TAILP-NIL:RETURN-NILClarify that (TAILP NIL X) returns NIL for all lists X, and that tailpmust be true-false-indeterminate equivalent to (defun tailp (x y)   (and x y (or (eq x y) (tailp x (cdr y)))))i.e., if the second argument is circular and the first argument is not a"tail" of the non-circular part of it, tailp may loop indefinitely.     ----- Next Message -----Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 JUN 87 20:42:51 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 1 Jun 87  20:41:01 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 161243; Mon 1-Jun-87 23:36:32 EDTDate: Mon, 1 Jun 87 23:36 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NILTo: CL-cleanup@Sail.stanford.eduIn-Reply-To: <870529-223659-1341@Xerox>Message-ID: <870601233632.0.MOON@EUPHRATES.SCRC.Symbolics.COM>I vote against releasing this issue until its writeup is in proper format.When you write the current practice section, mention that Symbolicsfollows the second of the two contradictory sentences in the tailpwriteup, hence (tailp nil <anything>) => t.  This may mean that currentpractice is not uniform.For history, you can mention that the unambiguous definition in theMIT Lisp Machine Manual (I consulted the fourth edition) would require(tailp nil <anything>) => nil.I personally don't care which disambiguation is adopted.  If the writeupincludes a proposal to eliminate the function, I will vote for that, sinceI've never understood what use tailp is.     ----- End Forwarded Messages -----*start*03236 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAY 88 15:01:42 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 May 88  15:00:03 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 MAY 88 14:57:52 PDTDate: 23 May 88 14:55 PDTFrom: masinter.paSubject:  Issue: TAILP-NILTo: cl-cleanup@sail.stanford.educc: masinter.paMessage-ID: <880523-145752-5438@Xerox>I had promised and neglected to mail out this issue again. This is it. I'veasked ALarson@src.honeywell.com to write it up again (under the theory thatHadden@HI-Multics.ARPA had volunteered once before.)      ----- Begin Forwarded Messages -----Date: 20 Nov 87 14:30 PSTFrom: Masinter.paSubject: Issue: TAILP-NILTo: Hadden@HI-Multics.ARPAcc: Masinterline-fold: NOMy notes say that you volunteered to write this issue up. Theproposal format required is documented at the end.!Issue: TAILP-NILReference: Steele p.275Category: clarificationDescription:The description of tailp in Steele differs from current implementationsin the case where the first argument is NIL. In particular, the secondsentence "Another way to look at this is tailp is true if (nthcdr nlist) is sublist, for some value of n." does not accurately describecurrent practice for the case where sublist is nil.The behavior of TAILP on circular structures is also unspecified, e.g.,is  (tailp '() '#0=(x . #0#)) meaningful?Proposal: TAILP-NIL:RETURN-NILClarify that (TAILP NIL X) returns NIL for all lists X, and that tailpmust be true-false-indeterminate equivalent to (defun tailp (x y)   (and x y (or (eq x y) (tailp x (cdr y)))))i.e., if the second argument is circular and the first argument is not a"tail" of the non-circular part of it, tailp may loop indefinitely.     ----- Next Message -----Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 JUN 87 20:42:51 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 1 Jun 8720:41:01 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COMvia CHAOS with CHAOS-MAIL id 161243; Mon 1-Jun-87 23:36:32 EDTDate: Mon, 1 Jun 87 23:36 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NILTo: CL-cleanup@Sail.stanford.eduIn-Reply-To: <870529-223659-1341@Xerox>Message-ID: <870601233632.0.MOON@EUPHRATES.SCRC.Symbolics.COM>I vote against releasing this issue until its writeup is in proper format.When you write the current practice section, mention that Symbolicsfollows the second of the two contradictory sentences in the tailpwriteup, hence (tailp nil <anything>) => t.  This may mean that currentpractice is not uniform.For history, you can mention that the unambiguous definition in theMIT Lisp Machine Manual (I consulted the fourth edition) would require(tailp nil <anything>) => nil.I personally don't care which disambiguation is adopted.  If the writeupincludes a proposal to eliminate the function, I will vote for that, sinceI've never understood what use tailp is.     ----- End Forwarded Messages -----*start*04837 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 SEP 88 16:02:38 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Sep 88  15:42:23 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 458628; Tue 13-Sep-88 18:41:32 EDTDate: Tue, 13 Sep 88 18:40 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NIL (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880913184048.5.KMP@GRYPHON.SCRC.Symbolics.COM>I just can't buy into this. I think it's a big mistake to require asublist to be a CONS. It teaches people to confuse the notion of CONSwith the notion of LIST. The latter may include NIL. I have addedanother option which I can support.-----Issue:		TAILP-NILReferences:	TAILP (p275)Category:	CLARIFICATION/CHANGEEdit History:	13-Sep-88, version 1 by Walter van Roggen,		13-Sep-88, version 2 by PitmanProblem Description:  CLtL (p275) specifies TAILP as:    TAILP sublist list				[Function]    This predicate is true if SUBLIST is a sublist of LIST (i.e.,    one of the conses that makes up LIST); otherwise, it is false.    Another way to look at this is that TAILP is true if    (NTHCDR n list) is SUBLIST, for some value of N. See LDIFF.  Two common implementations of this definition are:   (defun tailp (sublist list)			;Definition "A"     (do ((list list (cdr list)))	 ((endp list) nil)       (if (eq sublist list)	   (return t))))   (defun tailp (sublist list)			;Definition "B"     (do ((list list (cdr list)))	 ((atom list) (eq list sublist))       (if (eq sublist list)	   (return t))))  They differ only in their treatment of the atomic case.  At issue is the fact that () is a list, and hence some would  argue that it is a sublist of all other lists. On the other hand,  the definition of TAILP seems to imply that being a cons is a  necessary precondition of being a "sublist".Proposal (TAILP-NIL:NIL):  Clarify that the sublist argument to TAILP must be a list  and that (TAILP NIL X) returns NIL for all lists X.  Qualify the description in CLtL by saying that (TAILP sublist list)  is true if SUBLIST is a cons and (NTHCDR n list) is SUBLIST for  some value of N, and is false otherwise.  Rationale:   This is the status quo in a number of implementations.Proposal (TAILP-NIL:T):  Strike any text in the definition of TAILP which suggests that a  sublist must be a cons.  Clarify that (TAILP any-atom list) returns T iff (NTHCDR n list) is  SUBLIST for some value of N, and false otherwise.  Rationale:   This is more consistent with the definition of LDIFF, which   gives a useful meaning to arbitrary atomic SUBLIST arguments.   This gives a more elegant definition of SUBLIST, allowing it to   refer to any list -- including the empty list -- which is a   part of another list.Test Cases: #1: (LET ((X '(B C))) (TAILP X (CONS 'A X)))     should return T in all implementations. #2: (TAILP '(X Y) '(A B C))     should return NIL in all implementations. #3: (TAILP '() '(A B C))     returns NIL under proposal TAILP-NIL:NIL     returns T   under proposal TAILP-NIL:T #4: (TAILP 3 '(A B C))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:T #5: (TAILP 3 '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns T under proposal TAILP-NIL:T #6: (TAILP '(X Y) '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:TCurrent Practice:  Symbolics Genera is consistent with TAILP-NIL:T.  [Walter alleges TAILP-NIL:NIL is what all implementations already   do, but since Genera is not in conformance, KMP regards that   hypothesis as suspect. We need real data points, folks.]Cost to Implementors:  An implementation of TAILP-NIL:NIL is given as Definition "A" in the  problem description.  An implementation of TAILP-NIL:T is given as Definition "B" in the  problem description.  Some implementations might have compiler optimizers for these definitions  as well, so a slight amount of additional effort might be required.Cost to Users:  Given that current practice varies widely on the disputed case,  this is unlikely to have a practical effect on existing portable code.Benefits:  Either description makes the language more precise.  [Pitman believes that] TAILP-NIL:T is more consistent with the behavior  of TAILP and more consistent with what he thinks should be the   definition of a sublist.Discussion:  This issue was first raised in ">GLS>clarifications.text" of 12/06/85.  Pitman supports TAILP-NIL:T.*start*01830 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 SEP 88 12:39:25 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 13 Sep 88  12:38:22 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA14339; Tue, 13 Sep 88 12:37:02 PDTDate: Tue, 13 Sep 88 12:37:02 PDTMessage-Id: <8809131937.AA14339@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: TAILP-NIL (version 1)Issue:		TAILP-NILReferences:	TAILP (p 275 of CLtL)Category:	CLARIFICATION/CHANGEEdit History:	13-Sept-88, version 1 by Walter van RoggenProblem Description:  CLtL, in the description of TAILP, states:    (TAILP sublist list)  "is true if (NTHCDR n list) is sublist, for some value of n.  See   LDIFF."  However, the behavior when sublist is NIL is not what was intended,  as implied by the description of LDIFF and a common definition of  TAILP:  (defun tailp (sublist list)    (do ((list list (cdr list)))        ((null list) nil)      (if (eq sublist list)          (return t))))Proposal: (TAILP-NIL:NIL)  (TAILP NIL X) returns NIL for all lists X.  Qualify the description  in CLtL by saying that:    (TAILP sublist list)  "is true if (NTHCDR n list) is sublist for some value of n, if sublist   is a non-null list, and is false if sublist is NIL."Current Practice:  This is probably what all implementations already do.Cost to Implementors:  An implementation is given in the Problem Description.Cost to Users:  Unlikely to affect any portable code, due to the Current Practice.Benefits:  A slightly more precise description of the language.Discussion:  This first appeared in ">GLS>clarifications.text" of 12/06/85.*start*01191 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 SEP 88 06:52:45 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 14 Sep 88  06:51:25 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA00737; Wed, 14 Sep 88 06:49:27 PDTDate: Wed, 14 Sep 88 06:49:27 PDTMessage-Id: <8809141349.AA00737@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: KMP@stony-brook.scrc.symbolics.comSubject: RE: Issue: TAILP-NIL (Version 2)Well, that's a surprise.  I thought I had spotted a simple, non-controversialitem from Guy's list, which really needed to be done due to the inconsistencyin CLtL.I must admit that I hadn't tried TAILP on a Symbolics machine.  I had justread the description of TAILP in an older manual, which gave the possibleimplementation I originally included (definition "A").  I guess I was guiltyof propagating false concepts.Frankly, I don't really care which way we choose.  If several other wouldprefer TAILP-NIL:T, then let's delete the TAILP-NIL:NIL proposal.  Butlet's not spend a lot of time on it.			---Walter*start*01225 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 20:37:24 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 19 Sep 88  20:36:23 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03955g; Mon, 19 Sep 88 19:34:42 PSTReceived: by bhopal id AA16338g; Mon, 19 Sep 88 20:34:10 PDTDate: Mon, 19 Sep 88 20:34:10 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809200334.AA16338@bhopal>To: vanroggen%aitg.DEC@decwrl.dec.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: vanroggen%aitg.DEC@decwrl.dec.com's message of Tue, 13 Sep 88 12:37:02 PDT <8809131937.AA14339@decwrl.dec.com>Subject: Issue: TAILP-NIL (version 1)TAILP-NIL:NIL is what Lucid Common Lisp supports, albeit for the "wrong" reason.  Since this issue has been around for nearly threeyears (GLS's "Clarifications"), and since there has been no public complaints about the many implementations that do it this way, thencodifying this seems right.I wouldn't mind a line in your proposal that requires TAILP to signalan error if the 'sublis' argument is any non-null atom.-- JonL --*start*04198 00024 US Date:  8 Oct 88 22:07 PDTSender: masinter.paSubject: DRAFT Issue: TAILP-NIL (Version 2)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:		TAILP-NILReferences:	TAILP (p275)Category:	CLARIFICATION/CHANGEEdit History:	13-Sep-88, version 1 by Walter van Roggen,		13-Sep-88, version 2 by PitmanProblem Description:  CLtL (p275) specifies TAILP as:    TAILP sublist list				[Function]    This predicate is true if SUBLIST is a sublist of LIST (i.e.,    one of the conses that makes up LIST); otherwise, it is false.    Another way to look at this is that TAILP is true if    (NTHCDR n list) is SUBLIST, for some value of N. See LDIFF.  Two common implementations of this definition are:   (defun tailp (sublist list)			;Definition "A"     (do ((list list (cdr list)))	 ((endp list) nil)       (if (eq sublist list)	   (return t))))   (defun tailp (sublist list)			;Definition "B"     (do ((list list (cdr list)))	 ((atom list) (eq list sublist))       (if (eq sublist list)	   (return t))))  They differ only in their treatment of the atomic case.  At issue is the fact that () is a list, and hence some would  argue that it is a sublist of all other lists. On the other hand,  the definition of TAILP seems to imply that being a cons is a  necessary precondition of being a "sublist".Proposal (TAILP-NIL:NIL):  Clarify that the sublist argument to TAILP must be a list  and that (TAILP NIL X) returns NIL for all lists X.  Qualify the description in CLtL by saying that (TAILP sublist list)  is true if SUBLIST is a cons and (NTHCDR n list) is SUBLIST for  some value of N, and is false otherwise.  Rationale:   This is the status quo in a number of implementations.Proposal (TAILP-NIL:T):  Strike any text in the definition of TAILP which suggests that a  sublist must be a cons.  Clarify that (TAILP any-atom list) returns T iff (NTHCDR n list) is  SUBLIST for some value of N, and false otherwise.  Rationale:   This is more consistent with the definition of LDIFF, which   gives a useful meaning to arbitrary atomic SUBLIST arguments.   This gives a more elegant definition of SUBLIST, allowing it to   refer to any list -- including the empty list -- which is a   part of another list.Test Cases: #1: (LET ((X '(B C))) (TAILP X (CONS 'A X)))     should return T in all implementations. #2: (TAILP '(X Y) '(A B C))     should return NIL in all implementations. #3: (TAILP '() '(A B C))     returns NIL under proposal TAILP-NIL:NIL     returns T   under proposal TAILP-NIL:T #4: (TAILP 3 '(A B C))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:T #5: (TAILP 3 '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns T under proposal TAILP-NIL:T #6: (TAILP '(X Y) '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:TCurrent Practice:  Symbolics Genera is consistent with TAILP-NIL:T.  [Walter alleges TAILP-NIL:NIL is what all implementations already   do, but since Genera is not in conformance, KMP regards that   hypothesis as suspect. We need real data points, folks.]Cost to Implementors:  An implementation of TAILP-NIL:NIL is given as Definition "A" in the  problem description.  An implementation of TAILP-NIL:T is given as Definition "B" in the  problem description.  Some implementations might have compiler optimizers for these definitions  as well, so a slight amount of additional effort might be required.Cost to Users:  Given that current practice varies widely on the disputed case,  this is unlikely to have a practical effect on existing portable code.Benefits:  Either description makes the language more precise.  [Pitman believes that] TAILP-NIL:T is more consistent with the behavior  of TAILP and more consistent with what he thinks should be the   definition of a sublist.Discussion:  This issue was first raised in ">GLS>clarifications.text" of 12/06/85.  Pitman supports TAILP-NIL:T.     ----- End Forwarded Messages -----*start*04462 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 22:10:55 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  22:11:01 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 OCT 88 22:06:05 PDTDate: 8 Oct 88 22:06 PDTFrom: masinter.paSubject: DRAFT Issue: TAILP-NIL (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881008-220605-2581@Xerox>!Issue:		TAILP-NILReferences:	TAILP (p275)Category:	CLARIFICATION/CHANGEEdit History:	13-Sep-88, version 1 by Walter van Roggen,		13-Sep-88, version 2 by PitmanProblem Description:  CLtL (p275) specifies TAILP as:    TAILP sublist list				[Function]    This predicate is true if SUBLIST is a sublist of LIST (i.e.,    one of the conses that makes up LIST); otherwise, it is false.    Another way to look at this is that TAILP is true if    (NTHCDR n list) is SUBLIST, for some value of N. See LDIFF.  Two common implementations of this definition are:   (defun tailp (sublist list)			;Definition "A"     (do ((list list (cdr list)))	 ((endp list) nil)       (if (eq sublist list)	   (return t))))   (defun tailp (sublist list)			;Definition "B"     (do ((list list (cdr list)))	 ((atom list) (eq list sublist))       (if (eq sublist list)	   (return t))))  They differ only in their treatment of the atomic case.  At issue is the fact that () is a list, and hence some would  argue that it is a sublist of all other lists. On the other hand,  the definition of TAILP seems to imply that being a cons is a  necessary precondition of being a "sublist".Proposal (TAILP-NIL:NIL):  Clarify that the sublist argument to TAILP must be a list  and that (TAILP NIL X) returns NIL for all lists X.  Qualify the description in CLtL by saying that (TAILP sublist list)  is true if SUBLIST is a cons and (NTHCDR n list) is SUBLIST for  some value of N, and is false otherwise.  Rationale:   This is the status quo in a number of implementations.Proposal (TAILP-NIL:T):  Strike any text in the definition of TAILP which suggests that a  sublist must be a cons.  Clarify that (TAILP any-atom list) returns T iff (NTHCDR n list) is  SUBLIST for some value of N, and false otherwise.  Rationale:   This is more consistent with the definition of LDIFF, which   gives a useful meaning to arbitrary atomic SUBLIST arguments.   This gives a more elegant definition of SUBLIST, allowing it to   refer to any list -- including the empty list -- which is a   part of another list.Test Cases: #1: (LET ((X '(B C))) (TAILP X (CONS 'A X)))     should return T in all implementations. #2: (TAILP '(X Y) '(A B C))     should return NIL in all implementations. #3: (TAILP '() '(A B C))     returns NIL under proposal TAILP-NIL:NIL     returns T   under proposal TAILP-NIL:T #4: (TAILP 3 '(A B C))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:T #5: (TAILP 3 '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns T under proposal TAILP-NIL:T #6: (TAILP '(X Y) '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:TCurrent Practice:  Symbolics Genera is consistent with TAILP-NIL:T.  [Walter alleges TAILP-NIL:NIL is what all implementations already   do, but since Genera is not in conformance, KMP regards that   hypothesis as suspect. We need real data points, folks.]Cost to Implementors:  An implementation of TAILP-NIL:NIL is given as Definition "A" in the  problem description.  An implementation of TAILP-NIL:T is given as Definition "B" in the  problem description.  Some implementations might have compiler optimizers for these definitions  as well, so a slight amount of additional effort might be required.Cost to Users:  Given that current practice varies widely on the disputed case,  this is unlikely to have a practical effect on existing portable code.Benefits:  Either description makes the language more precise.  [Pitman believes that] TAILP-NIL:T is more consistent with the behavior  of TAILP and more consistent with what he thinks should be the   definition of a sublist.Discussion:  This issue was first raised in ">GLS>clarifications.text" of 12/06/85.  Pitman supports TAILP-NIL:T.     ----- End Forwarded Messages -----*start*04522 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 22:24:50 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  22:11:11 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 08 OCT 88 22:07:06 PDTDate: 8 Oct 88 22:07 PDTSender: masinter.paSubject: DRAFT Issue: TAILP-NIL (Version 2)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-220706-2582@Xerox>!Issue:		TAILP-NILReferences:	TAILP (p275)Category:	CLARIFICATION/CHANGEEdit History:	13-Sep-88, version 1 by Walter van Roggen,		13-Sep-88, version 2 by PitmanProblem Description:  CLtL (p275) specifies TAILP as:    TAILP sublist list				[Function]    This predicate is true if SUBLIST is a sublist of LIST (i.e.,    one of the conses that makes up LIST); otherwise, it is false.    Another way to look at this is that TAILP is true if    (NTHCDR n list) is SUBLIST, for some value of N. See LDIFF.  Two common implementations of this definition are:   (defun tailp (sublist list)			;Definition "A"     (do ((list list (cdr list)))	 ((endp list) nil)       (if (eq sublist list)	   (return t))))   (defun tailp (sublist list)			;Definition "B"     (do ((list list (cdr list)))	 ((atom list) (eq list sublist))       (if (eq sublist list)	   (return t))))  They differ only in their treatment of the atomic case.  At issue is the fact that () is a list, and hence some would  argue that it is a sublist of all other lists. On the other hand,  the definition of TAILP seems to imply that being a cons is a  necessary precondition of being a "sublist".Proposal (TAILP-NIL:NIL):  Clarify that the sublist argument to TAILP must be a list  and that (TAILP NIL X) returns NIL for all lists X.  Qualify the description in CLtL by saying that (TAILP sublist list)  is true if SUBLIST is a cons and (NTHCDR n list) is SUBLIST for  some value of N, and is false otherwise.  Rationale:   This is the status quo in a number of implementations.Proposal (TAILP-NIL:T):  Strike any text in the definition of TAILP which suggests that a  sublist must be a cons.  Clarify that (TAILP any-atom list) returns T iff (NTHCDR n list) is  SUBLIST for some value of N, and false otherwise.  Rationale:   This is more consistent with the definition of LDIFF, which   gives a useful meaning to arbitrary atomic SUBLIST arguments.   This gives a more elegant definition of SUBLIST, allowing it to   refer to any list -- including the empty list -- which is a   part of another list.Test Cases: #1: (LET ((X '(B C))) (TAILP X (CONS 'A X)))     should return T in all implementations. #2: (TAILP '(X Y) '(A B C))     should return NIL in all implementations. #3: (TAILP '() '(A B C))     returns NIL under proposal TAILP-NIL:NIL     returns T   under proposal TAILP-NIL:T #4: (TAILP 3 '(A B C))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:T #5: (TAILP 3 '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns T under proposal TAILP-NIL:T #6: (TAILP '(X Y) '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:TCurrent Practice:  Symbolics Genera is consistent with TAILP-NIL:T.  [Walter alleges TAILP-NIL:NIL is what all implementations already   do, but since Genera is not in conformance, KMP regards that   hypothesis as suspect. We need real data points, folks.]Cost to Implementors:  An implementation of TAILP-NIL:NIL is given as Definition "A" in the  problem description.  An implementation of TAILP-NIL:T is given as Definition "B" in the  problem description.  Some implementations might have compiler optimizers for these definitions  as well, so a slight amount of additional effort might be required.Cost to Users:  Given that current practice varies widely on the disputed case,  this is unlikely to have a practical effect on existing portable code.Benefits:  Either description makes the language more precise.  [Pitman believes that] TAILP-NIL:T is more consistent with the behavior  of TAILP and more consistent with what he thinks should be the   definition of a sublist.Discussion:  This issue was first raised in ">GLS>clarifications.text" of 12/06/85.  Pitman supports TAILP-NIL:T.     ----- End Forwarded Messages -----*start*00698 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 19:45:31 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  18:19:58 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA27775; Thu, 13 Oct 88 17:10:51 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19983; Thu, 13 Oct 88 17:10:49 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132310.AA19983@defun.utah.edu>Date: Thu, 13 Oct 88 17:10:47 MDTSubject: issue TAILP-NILTo: cl-cleanup@sail.stanford.eduI support proposal TAILP-NIL:T.-Sandra-------*start*01148 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 OCT 88 14:51:12 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 14 Oct 88  14:49:18 PDTReceived: by ti.com id AA25239; Fri, 14 Oct 88 16:49:18 CDTReceived: from Kelvin by tilde id AA23070; Fri, 14 Oct 88 16:39:35 CDTMessage-Id: <2801857295-4778903@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 14 Oct 88 16:41:35 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: DRAFT Issue: TAILP-NIL (Version 2)In-Reply-To: Msg of 8 Oct 88 22:06 PDT from masinter.pa@XEROX.COM> Current Practice:> >   Symbolics Genera is consistent with TAILP-NIL:T.> >   [Walter alleges TAILP-NIL:NIL is what all implementations already>    do, but since Genera is not in conformance, KMP regards that>    hypothesis as suspect. We need real data points, folks.]The Explorer is consistent with TAILP-NIL:NIL, in accordance with the1985 "clarifications" list, but I don't really have an opinion onwhether this is the best choice.*start*03764 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 11:39:30 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 18 Oct 88  11:37:42 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA01883; Tue, 19 Apr 88 19:33:14 PDTDate: Tue, 19 Apr 88 19:33:14 PDTMessage-Id: <8804200233.AA01883@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: TAILP-NIL (version 3)Issue:		TAILP-NILReferences:	TAILP (p275)Category:	CLARIFICATION/CHANGEEdit History:	13-Sep-88, version 1 by Walter van Roggen,		13-Sep-88, version 2 by Pitman                18-Oct-88, version 3 by van Roggen (just one proposal) Problem Description:   CLtL (p275) specifies TAILP as:     TAILP sublist list				[Function]     This predicate is true if SUBLIST is a sublist of LIST (i.e.,    one of the conses that makes up LIST); otherwise, it is false.    Another way to look at this is that TAILP is true if    (NTHCDR n list) is SUBLIST, for some value of N. See LDIFF.   Two common implementations of this definition are:    (defun tailp (sublist list)			;Definition "A"     (do ((list list (cdr list)))	 ((endp list) nil)       (if (eq sublist list)	   (return t))))    (defun tailp (sublist list)			;Definition "B"     (do ((list list (cdr list)))	 ((atom list) (eq list sublist))       (if (eq sublist list)	   (return t))))   They differ only in their treatment of the atomic case.   At issue is the fact that () is a list, and hence some would  argue that it is a sublist of all other lists. On the other hand,  the definition of TAILP seems to imply that being a cons is a  necessary precondition of being a "sublist".Proposal (TAILP-NIL:T):   Strike any text in the definition of TAILP which suggests that a  sublist must be a cons.   Clarify that (TAILP any-atom list) returns T iff (NTHCDR n list) is  SUBLIST for some value of N, and false otherwise. Rationale:   This is more consistent with the definition of LDIFF, which  gives a useful meaning to arbitrary atomic SUBLIST arguments.   This gives a more elegant definition of SUBLIST, allowing it to  refer to any list -- including the empty list -- which is a  part of another list. Test Cases:  #1: (LET ((X '(B C))) (TAILP X (CONS 'A X)))     should return T in all implementations.  #2: (TAILP '(X Y) '(A B C))     should return NIL in all implementations.  #3: (TAILP '() '(A B C))     returns NIL under proposal TAILP-NIL:NIL     returns T   under proposal TAILP-NIL:T  #4: (TAILP 3 '(A B C))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:T  #5: (TAILP 3 '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns T under proposal TAILP-NIL:T  #6: (TAILP '(X Y) '(A B C . 3))     is an error under proposal TAILP-NIL:NIL     returns NIL under proposal TAILP-NIL:T Current Practice:   Symbolics Genera is consistent with TAILP-NIL:T.  VAX LISP implements  TAILP-NIL:NIL. Cost to Implementors:   An implementation of TAILP-NIL:T is given as Definition "B" in the  problem description.   Some implementations might have compiler optimizers for these definitions  as well, so a slight amount of additional effort might be required. Cost to Users:   Given that current practice varies widely on the disputed case,  this is unlikely to have a practical effect on existing portable code. Benefits:   Avoids unnecessary incompatibilities between implementations. Discussion:   This issue was first raised in ">GLS>clarifications.text" of 12/06/85.  It recommended TAILP-NIL:NIL.*start*01016 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 13:41:09 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 18 Oct 88  12:25:31 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA04896; Tue, 19 Apr 88 20:20:17 PDTDate: Tue, 19 Apr 88 20:20:17 PDTMessage-Id: <8804200320.AA04896@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: KMP@stony-brook.scrc.symbolics.comSubject: RE: Issue: TAILP-NIL (version 3)Yes, I guess I endorse it also.  Either way was fine with me; I wasjust surprised to see the alternate definition after reading theoriginal proposal both in Guy's clarifications list and in oldSymbolics documentation.I don't feel justified in writing down recommendations in the Discussionsection unless I've heard from "enough" people.  So far most people seemto have stayed away from this issue, as well as many others.			---Walter*start*01005 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 13:41:29 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 18 Oct 88  12:17:53 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 478149; Tue 18-Oct-88 15:17:34 EDTDate: Tue, 18 Oct 88 15:17 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NIL (version 3)To: vanroggen%aitg.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8804200233.AA01883@decwrl.dec.com>Message-ID: <881018151727.3.KMP@BOBOLINK.SCRC.Symbolics.COM>as you might expect, i support this writeup and the statedproposal (TAILP-NIL:T).do i take it from the fact that you removed the NIL proposal that youalso endorse it? your writeup is devoid of recommendations in theDiscussion.*start*02723 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 OCT 88 18:35:37 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 27 Oct 88  18:32:50 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01614g; Thu, 27 Oct 88 18:32:19 PDTReceived: by bhopal id AA12570g; Thu, 27 Oct 88 18:30:51 PDTDate: Thu, 27 Oct 88 18:30:51 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810280130.AA12570@bhopal>To: vanroggen%aitg.DEC@decwrl.dec.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: vanroggen%aitg.DEC@decwrl.dec.com's message of Tue, 19 Apr 88 19:33:14 PDT <8804200233.AA01883@decwrl.dec.com>Subject: Issue: TAILP-NIL (version 3), or NTHCDR-P?The difference between your Definition "A" and Definition "B" isn't just "in their treatment of the atomic case", but also that the loop terminationcriteron is ENDP in one and ATOM in the other.  There is still something desirable about an ENDP termination test as long as the first argument to TAILP is described as a "sublist" [i.e. some kind of LIST].  For example, it is not acceptable to consider 35 as a list.  On the other hand, maybe you really want to suggest that TAILP be changed into the functionality implied by the name NTHCDR-P?  In  short, which of the following twooptions is preferable?  1.   (tailp 35 l)        ==> an error  2.   (tailp 35 l)        ==> either true, or false.Under Rationale, I would add that the current proposal makes the documentation of TAILP more consistent with the type definition of LIST, which isn't restricted to CONS cells.Under Current Practice, Lucid does not implement TAILP-NIL:T, as previouslyexplained in my note:    Date: Mon, 19 Sep 88 20:34:10 PDT    From: Jon L White <jonl>    To: vanroggen%aitg.DEC@decwrl.dec.com    Cc: cl-cleanup@sail.stanford.edu    In-Reply-To: vanroggen%aitg.DEC@decwrl.dec.com's message of Tue, 13 Sep 88 12:37:02 PDT <8809131937.AA14339@decwrl.dec.com>    Subject: Issue: TAILP-NIL (version 1)    TAILP-NIL:NIL is what Lucid Common Lisp supports, albeit for the     "wrong" reason.  Since this issue has been around for nearly three    years (GLS's "Clarifications"), and since there has been no public     complaints about the many implementations that do it this way, then    codifying this seems right.    I wouldn't mind a line in your proposal that requires TAILP to signal    an error if the 'sublis' argument is any non-null atom.    -- JonL --For Lucid, the choice between TAILP-NIL:NIL and TAILP-NIL:T is quitearbitrary [i.e., don't read anything into "supports" above].-- JonL --*start*00976 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 NOV 88 21:30:57 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Nov 88  21:29:56 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 30 NOV 88 21:29:16 PSTDate: 30 Nov 88 21:29 PSTFrom: masinter.paSubject: Re: Issue: TAILP-NIL (version 3)In-reply-to: vanroggen%aitg.DEC@decwrl.dec.com's message of Tue, 19 Apr 88 19:33:14 PDT (really of 18 Oct 88)To: vanroggen%aitg.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduMessage-ID: <881130-212916-3785@Xerox>Your version 3 eliminated proposal TAILP-NIL:NIL, but retained somereferences to that proposal.If there are still some folks in favor of TAILP-NIL:NIL, we can go back totwo proposals for the ballot; I don't think that is the case, and we justneed a minor rewrite to fix the current practice, discussion sections.*start*06796 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 DEC 88 11:10:38 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Dec 88  11:07:54 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 500797; Thu 1-Dec-88 14:07:46 ESTDate: Thu, 1 Dec 88 14:07 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NIL (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881201140733.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Ok, I updated this per discussion. - Added a paragraph to Problem Description acknowledging JonL's claim   that this is not only about what is a sublist, but also about whether   dotted lists are permissible arg2's. - Tried to clarify wording of Proposal to not confuse people about   the relation between NTHCDR and TAILP. - Added Rationale for choosing ATOM over ENDP. - Eliminated references to TAILP-NIL:NIL, except as clearly identified   historical reference in the Discussion. - Updated current practice. - Added a Non-Benefits section to note JonL's gripe that this might   slow things down slightly.Hopefully this makes the presentation fair.-----Issue:		TAILP-NILReferences:	TAILP (p275)Category:	CLARIFICATION/CHANGEEdit History:	13-Sep-88, version 1 by Walter van Roggen,		13-Sep-88, version 2 by Pitman                18-Oct-88, version 3 by van Roggen (just one proposal)		01-Dec-88, version 4 by Pitman (minor edits per discussion) Problem Description:   CLtL (p275) specifies TAILP as:     TAILP sublist list				[Function]     This predicate is true if SUBLIST is a sublist of LIST (i.e.,    one of the conses that makes up LIST); otherwise, it is false.    Another way to look at this is that TAILP is true if    (NTHCDR n list) is SUBLIST, for some value of N. See LDIFF.   Two common implementations of this definition are:    (defun tailp (sublist list)			;Definition "A"     (do ((list list (cdr list)))	 ((endp list) nil)       (if (eq sublist list)	   (return t))))    (defun tailp (sublist list)			;Definition "B"     (do ((list list (cdr list)))	 ((atom list) (eq list sublist))       (if (eq sublist list)	   (return t))))   They differ only in their treatment of the atomic case.   At issue is the fact that () is a list, and hence some would  argue that it is a sublist of all other lists. On the other hand,  the definition of TAILP seems to imply that being a cons is a  necessary precondition of being a "sublist".  Also at issue is the question of whether dotted lists are permissible  second arguments.Proposal (TAILP-NIL:T):   Strike any text in the definition of TAILP which suggests that a  sublist must be a cons.   Clarify that (TAILP any-atom list) returns T iff (NTHCDR n list) is  SUBLIST for some value of N, and false otherwise.  Note, however, that since the LIST may be dotted, so the end test  used by TAILP must be ATOM, not ENDP. That is, if (TAILP x l)  returns T, it means there was n such that (NTHCDR n list) would  return x; however, it doesn't follow that if TAILP returns false,  it is safe to go blithely NTHCDR's into the list looking for it,   since the list might be dotted and NTHCDR might hit bad data.Rationale:   This is more consistent with the definition of LDIFF, which  gives a useful meaning to arbitrary atomic SUBLIST arguments.   This gives a more elegant definition of SUBLIST, allowing it to  refer to any list -- including the empty list -- which is a  part of another list.   Some reasons for preferring an ATOM check to ENDP include:   - The name TAILP suggests tails, not sublists. Some users might     expect this distinction to mean that data more general than     proper sublists.   - Making TAILP require lists limits its usefulness. If we did     not make this choice, some users would end up having to write     their own extended TAILP which we could just as well have     provided compatibly.   - TAILP is not considered to be used frequently enough in code     that the minor loss in speed to an ATOM check is worth the     lost functionality. Indeed, expanding the scope of its      capabilities may lead to more uses for TAILP.   - Other operators (eg, APPEND) have recently been extended to     treat dotted lists in an interesting way because users have     expressed a desire for this. As such, this change is      culturally consistent.   - Some implementations already support this feature, and the      wording in CLtL is sufficiently ambiguous that some users     might think it appropriate to depend on the feature. In the     absence of compelling efficiency reasons to the contrary,     we should lean toward extending some implementations rather     than tightening others in our efforts to achieve cross-dialect     consistency.Test Cases:  #1: (LET ((X '(B C))) (TAILP X (CONS 'A X)))     should return T in all implementations.  #2: (TAILP '(X Y) '(A B C))     should return NIL in all implementations.  #3: (TAILP '() '(A B C))     returns T under this proposal.  #4: (TAILP 3 '(A B C))     returns NIL under this proposal.  #5: (TAILP 3 '(A B C . 3))     returns T under this proposal.  #6: (TAILP '(X Y) '(A B C . 3))     returns NIL under this proposal. Current Practice:   Symbolics Genera is consistent with TAILP-NIL:T.  Neither Lucid nor VAX LISP currently implements TAILP-NIL:T.  VAX LISP effectively implements definition "A" from the   Problem Description above.Cost to Implementors:   An implementation of TAILP-NIL:T is given as Definition "B" in the  problem description.   Some implementations might have compiler optimizers for these definitions  as well, so a slight amount of additional effort might be required. Cost to Users:   Given that current practice varies widely on the disputed case,  this is unlikely to have a practical effect on existing portable code. Benefits:   Avoids unnecessary incompatibilities between implementations. Non-Benefits:  Slows down TAILP slightly in some implementations because ENDP is  potentially faster than ATOM.Discussion:   This issue was first raised in ">GLS>clarifications.text" of 12/06/85.  It recommended an earlier proposal, TAILP-NIL:NIL, which is effectively  equivalent to Definition "A" from the Problem Description.  Pitman introduced TAILP-NIL:T as an alternative, arguing that the  definition TAILP-NIL:NIL offered no practical value to programmers  in the disputed situations, while TAILP-NIL:T was of arguable usefulness.  Pitman and van Roggen support TAILP-NIL:T.*start*01012 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 DEC 88 11:13:52 PSTReceived: from argus.Stanford.EDU by SAIL.Stanford.EDU with TCP; 1 Dec 88  11:12:39 PSTReceived: from Riverside.SCRC.Symbolics.COM (SCRC-RIVERSIDE.ARPA) by argus.Stanford.EDU with TCP; Thu, 1 Dec 88 11:05:31 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 297761; Thu 1-Dec-88 14:11:42 ESTDate: Thu, 1 Dec 88 14:12 ESTFrom: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>Subject: Issue: TAILP-NIL (Version 4)To: CL-Cleanup@sail.stanford.eduMessage-Id: <881201141215.3.KMP@BOBOLINK.SCRC.Symbolics.COM>Drat. I left out the following in bringing things up to date: - Gray says TI implements TAILP-NIL:NIL, but that he personally is neutral. - Sandra supports TAILP-NIL:T.If another draft ends up getting made, these should get squeezed in.*start*00921 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 DEC 88 23:48:49 PSTReceived: from RELAY.CS.NET (GW1.CS.NET) by SAIL.Stanford.EDU with TCP; 1 Dec 88  23:47:55 PSTReceived: from relay2.cs.net by RELAY.CS.NET id aa26115; 2 Dec 88 1:01 ESTReceived: from draper.com by RELAY.CS.NET id aa09871; 2 Dec 88 0:50 ESTDate: Fri, 2 Dec 88 00:01 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: TAILP-NIL (Version 4)To: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525re: test case #5:    (TAILP 3 '(A B C . 3))    returns T under this proposal.  Not necessarily.  It must be kept in mind that numbers are not necessarily EQ.I know you believe that all implementations have immediate fixnums, but thisisn't the case with ours (tho it hurts to admit it).*start*00823 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 DEC 88 10:14:43 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Dec 88  10:13:52 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 DEC 88 09:44:06 PSTDate: 2 Dec 88 09:43 PSTFrom: masinter.paSubject: Re: Issue: TAILP-NIL (Version 4)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 2 Dec 88 04:16 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: SEB1525@draper.com, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881202-094406-1195@Xerox>This gives me a reason for wanting to disallow non-lists as the firstargument to TAILP -- that it would have to use EQL to be consistent.*start*01814 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 DEC 88 01:54:49 PSTReceived: from YUKON.SCRC.Symbolics.COM (SCRC-YUKON.ARPA) by SAIL.Stanford.EDU with TCP; 2 Dec 88  01:53:26 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 408896; Fri 2-Dec-88 04:19:05 ESTDate: Fri, 2 Dec 88 04:16 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: TAILP-NIL (Version 4)To: SEB1525@draper.comcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: The message of 2 Dec 88 00:01 EST from "Steve Bacher (Batchman)" <SEB1525@draper.com>Message-ID: <881202041609.8.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri, 2 Dec 88 00:01 EST    From: "Steve Bacher (Batchman)" <SEB1525@draper.com>    re: test case #5:	(TAILP 3 '(A B C . 3))	returns T under this proposal.      Not necessarily.  It must be kept in mind that numbers are not necessarily EQ.    I know you believe that all implementations have immediate fixnums, but this    isn't the case with ours (tho it hurts to admit it).Good point. Clearly the bug is that we say EQ and not EQL in thedescription.  Hardly anything defaults to EQ tests, after all. Thiswould be irregular if we let it through using EQL.Someone's going to tell me that this slows it down again. [It needn'tslow it much, of course, though for inlined code you'd get a little codebloating because you'd have to jumpt to one of two loops. For TAILPnotinline, it would be little overhead to have the two loops. I don'tknow how many implementations inline this, though -- certainly oursdoesn't]Does anyone think that making it use EQL rather than EQ is going to beprohibitive?*start*03514 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 02 DEC 88 12:43:45 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 502067; Fri 2-Dec-88 15:44:22 ESTDate: Fri, 2 Dec 88 15:43 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: TAILP-NIL (Version 4)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COM, SEB1525@draper.com, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881202-094406-1195@Xerox>Message-ID: <881202154353.4.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 2 Dec 88 09:43 PST    From: masinter.pa@Xerox.COM    This gives me a reason for wanting to disallow non-lists as the first    argument to TAILP -- that it would have to use EQL to be consistent.Having had a night to think about it, I don't think the need touse EQL is much of an argument against. If the implementation does not inline TAILP, then TAILP can select one of two trivial loops based on its argument type. No significant slowdown there. If the implementation does inline TAILP, then it can just put in EQL and leave it to optimizers for variable declarations and/or THE to notice that things declared to be LIST (or at least (AND (NOT NUMBER) (NOT CHARACTER)) can be optimized).We use effectively the same argument to justify making EQL theproper test for MEMBER in spite of the superficial impression ofnon-efficiency, so I'll be interested to hear anyone try to refutethis position.As to the use of ENDP, I think the overriding argument has to bethat ENDP is appropriate only for list abstractions, and I absolutelydon't see this as a useful list abstraction. [Explanation below.]As to the use of EQL, I think there is no justification for usingEQ in the language anywhere, other than providing the function itselfand providing the facility of other functions to take [#]'EQ as anargument, and even that is fairly questionable in portable code.The reason I don't think TAILP is an operation on lists is that allthe list abstractions go to a lot of trouble to say that cars andcdrs can be changed willy-nilly. If you do much of anything to a list,you have to be afraid that EQ-ness of something in the containerhas been destroyed. The only thing all the list operations tend topreserve is overall shape. Hence, it's dumb to have an operationwhich claims to be about lists and yet which uses a type predicatewhich is seriously inappropriate to lists. If TAILP were reallyabout lists, it would want to use something like EQUAL as a predicate.I think TAILP is most useful when you've gone to some care to constructa cdr-chain from scratch using only cons and custom maintenance primitives. In any case where custom primitives are involved, anyexpectation that ever cdr-chain is going to be a proper list is outthe window. If you restrict TAILP to work only on proper lists, youplace an arbitrary restriction on it which makes it not useful ina number of places where it might otherwise be useful.I think the reason we don't have anyone arguing passionately aboutwhat TAILP should do from experience is that it is seldom useful inpractice.I think the reason it is seldom useful is that it is not defined on thefull set of data types that it needs to be defined on.My now-considered position is that I am firm in the idea that the endtest should be ATOM and that the test should be EQL.*start*01188 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 06 DEC 88 23:04:33 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00915g; Tue, 6 Dec 88 23:01:51 PSTReceived: by bhopal id AA11587g; Tue, 6 Dec 88 23:03:43 PSTDate: Tue, 6 Dec 88 23:03:43 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812070703.AA11587@bhopal>To: masinter.paCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, SEB1525@draper.com, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: masinter.pa@Xerox.COM's message of 2 Dec 88 09:43 PST <881202-094406-1195@Xerox>Subject: Issue: TAILP-NIL (Version 4)re: This gives me a reason for wanting to disallow non-lists as the first    argument to TAILP -- that it would have to use EQL to be consistent.Yea, it seems like we're beginning to over-generalize TAILP.  Who usesthis blasted thing anyway?  I think I'd MUCH rather support a proposalto throw it out of the language, on the basis that:   (1) the "test" questions is at least as complex as for defining       EQUAL -- and we never did come to agreement about that;   (2) since almost nobody uses it (??), it's moot anyway.-- JonL --*start*06759 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 14:32:15 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  14:30:47 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 14:26:34 PSTDate: 9 Dec 88 14:26 PSTFrom: masinter.pato: cl-cleanup@sail.stanford.eduSubject: TAILP-NIL (Version 5)Message-ID: <881209-142634-1107@Xerox>I'd rather not have a debate about this one at X3J13. There will be littleenough time there. So lets get this one "straight" at least in our ownminds.I occasionally forget about the caveat in CLtL that, unless otherwisespecified, a "list" is a proper list, and does not end in dotted tails. Iforgot about it when discussing this issue.Given that caveat, doesn't it mean that currently it "is an error" to passa dotted list as the second argument to TAILP? And thus TAILP should useENDP?!Issue:		TAILP-NILReferences:	TAILP (p275)Category:	CLARIFICATION/CHANGEEdit History:	13-Sep-88, version 1 by Walter van Roggen,		13-Sep-88, version 2 by Pitman                18-Oct-88, version 3 by van Roggen (just one proposal)		01-Dec-88, version 4 by Pitman (minor edits per discussion) 		 9-Dec-88, Version 5 by Masinter (clarify EQL)Problem Description:   CLtL (p275) specifies TAILP as:     TAILP sublist list				[Function]     This predicate is true if SUBLIST is a sublist of LIST (i.e.,    one of the conses that makes up LIST); otherwise, it is false.    Another way to look at this is that TAILP is true if    (NTHCDR n list) is SUBLIST, for some value of N. See LDIFF.   Two implementations of this definition might be:    (defun tailp (sublist list)			;Definition "A"     (do ((list list (cdr list)))	 ((endp list) nil)       (if (eql sublist list)	   (return t))))    (defun tailp (sublist list)			;Definition "B"     (do ((list list (cdr list)))	 ((atom list) (eql list sublist))       (if (eql sublist list)	   (return t))))   They differ only in their treatment of the atomic case.   At issue is the fact that () is a list, and hence some would  argue that it is a sublist of all other lists. On the other hand,  the definition of TAILP seems to imply that being a cons is a  necessary precondition of being a "sublist".  Also at issue is the question of whether dotted lists are permissible  second arguments.Proposal (TAILP-NIL:T):   Strike any text in the definition of TAILP which suggests that a  sublist must be a cons.   Clarify that (TAILP sublist list) returns true iff (NTHCDR n list) is  sublist for some value of n, and false otherwise.  Note, however, that since the list may be dotted, so the end test  used by TAILP must be ATOM, not ENDP. That is, if (TAILP x l)  returns true, it means there was n such that (NTHCDR n list) would  return x; however, it doesn't follow that if TAILP returns false,  it is safe to go blithely NTHCDR's into the list looking for it,   since the list might be dotted and NTHCDR might hit bad data.  Note that TAILP uses EQL or  equivalent to compare  sublist to list in the case where sublist is a number, etc.Rationale:   This is more consistent with the definition of LDIFF, which  gives a useful meaning to arbitrary atomic SUBLIST arguments.   This gives a more elegant definition of SUBLIST, allowing it to  refer to any list -- including the empty list -- which is a  part of another list.   Some reasons for preferring an ATOM check to ENDP include:   - The name TAILP suggests tails, not sublists. Some users might     expect this distinction to mean that data more general than     proper sublists.   - Making TAILP require lists limits its usefulness. If we did     not make this choice, some users would end up having to write     their own extended TAILP which we could just as well have     provided compatibly.   - TAILP is not considered to be used frequently enough in code     that the minor loss in speed to an ATOM check is worth the     lost functionality. Indeed, expanding the scope of its      capabilities may lead to more uses for TAILP.   - Other operators (eg, APPEND) have recently been extended to     treat dotted lists in an interesting way because users have     expressed a desire for this. As such, this change is      culturally consistent.   - Some implementations already support this feature, and the      wording in CLtL is sufficiently ambiguous that some users     might think it appropriate to depend on the feature. In the     absence of compelling efficiency reasons to the contrary,     we should lean toward extending some implementations rather     than tightening others in our efforts to achieve cross-dialect     consistency.Examples:  #1: (LET ((X '(B C))) (TAILP X (CONS 'A X)))     should return T in all implementations.  #2: (TAILP '(X Y) '(A B C))     should return NIL in all implementations.  #3: (TAILP '() '(A B C))     returns T under this proposal.  #4: (TAILP 3 '(A B C))     returns NIL under this proposal.  #5: (TAILP 3 '(A B C . 3))     returns T under this proposal.  #6: (TAILP '(X Y) '(A B C . 3))     returns NIL under this proposal. Current Practice:   Symbolics Genera is consistent with TAILP-NIL:T.  Neither Lucid nor VAX LISP currently implements TAILP-NIL:T.  VAX LISP effectively implements definition "A" from the   Problem Description above.Cost to Implementors:   An implementation of TAILP-NIL:T is given as Definition "B" in the  problem description.   Some implementations might have compiler optimizers for these definitions  as well, so a slight amount of additional effort might be required. Cost to Users:   Given that current practice varies widely on the disputed case,  this is unlikely to have a practical effect on existing portable code. Benefits:   Avoids unnecessary incompatibilities between implementations. Non-Benefits:  Slows down TAILP slightly in some implementations because ENDP is  potentially faster than ATOM.Discussion:   This issue was first raised in ">GLS>clarifications.text" of 12/06/85.  It recommended an earlier proposal, TAILP-NIL:NIL, which is effectively  equivalent to Definition "A" from the Problem Description.  Pitman introduced TAILP-NIL:T as an alternative, arguing that the  definition TAILP-NIL:NIL offered no practical value to programmers  in the disputed situations, while TAILP-NIL:T was of arguable usefulness.  Pitman and van Roggen support TAILP-NIL:T.  It was suggested more than once by more than one cleanup   committee member that we remove TAILP from the language  "since almost nobody uses it". *start*06371 00024 US Date: 12 Dec 88 15:17 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: TAILP-NIL (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noIssue:        TAILP-NILReferences:   TAILP (p275)Category:     CLARIFICATION/CHANGEEdit History: 13-Sep-88, version 1 by Walter van Roggen,              13-Sep-88, version 2 by Pitman              18-Oct-88, version 3 by van Roggen (just one proposal)              01-Dec-88, version 4 by Pitman (minor edits per discussion)               9-Dec-88, Version 5 by Masinter (clarify EQL)Problem Description:   CLtL (p275) specifies TAILP as:     TAILP sublist list				[Function]     This predicate is true if SUBLIST is a sublist of LIST (i.e.,    one of the conses that makes up LIST); otherwise, it is false.    Another way to look at this is that TAILP is true if    (NTHCDR n list) is SUBLIST, for some value of N. See LDIFF.   Two implementations of this definition might be:    (defun tailp (sublist list)			;Definition "A"     (do ((list list (cdr list)))	 ((endp list) nil)       (if (eql sublist list)	   (return t))))    (defun tailp (sublist list)			;Definition "B"     (do ((list list (cdr list)))	 ((atom list) (eql list sublist))       (if (eql sublist list)	   (return t))))   They differ only in their treatment of the atomic case.   At issue is the fact that () is a list, and hence some would  argue that it is a sublist of all other lists. On the other hand,  the definition of TAILP seems to imply that being a cons is a  necessary precondition of being a "sublist".  Also at issue is the question of whether dotted lists are permissible  second arguments.Proposal (TAILP-NIL:T):   Strike any text in the definition of TAILP which suggests that a  sublist must be a cons.   Clarify that (TAILP sublist list) returns true iff (NTHCDR n list) is  sublist for some value of n, and false otherwise.  Note, however, that since the list may be dotted, so the end test  used by TAILP must be ATOM, not ENDP. That is, if (TAILP x l)  returns true, it means there was n such that (NTHCDR n list) would  return x; however, it doesn't follow that if TAILP returns false,  it is safe to go blithely NTHCDR's into the list looking for it,   since the list might be dotted and NTHCDR might hit bad data.  Note that TAILP uses EQL or  equivalent to compare  sublist to list in the case where sublist is a number, etc.Rationale:   This is more consistent with the definition of LDIFF, which  gives a useful meaning to arbitrary atomic SUBLIST arguments.   This gives a more elegant definition of SUBLIST, allowing it to  refer to any list -- including the empty list -- which is a  part of another list.   Some reasons for preferring an ATOM check to ENDP include:   - The name TAILP suggests tails, not sublists. Some users might     expect this distinction to mean that data more general than     proper sublists.   - Making TAILP require lists limits its usefulness. If we did     not make this choice, some users would end up having to write     their own extended TAILP which we could just as well have     provided compatibly.   - TAILP is not considered to be used frequently enough in code     that the minor loss in speed to an ATOM check is worth the     lost functionality. Indeed, expanding the scope of its      capabilities may lead to more uses for TAILP.   - Other operators (eg, APPEND) have recently been extended to     treat dotted lists in an interesting way because users have     expressed a desire for this. As such, this change is      culturally consistent.   - Some implementations already support this feature, and the      wording in CLtL is sufficiently ambiguous that some users     might think it appropriate to depend on the feature. In the     absence of compelling efficiency reasons to the contrary,     we should lean toward extending some implementations rather     than tightening others in our efforts to achieve cross-dialect     consistency.Examples:  #1: (LET ((X '(B C))) (TAILP X (CONS 'A X)))     should return T in all implementations.  #2: (TAILP '(X Y) '(A B C))     should return NIL in all implementations.  #3: (TAILP '() '(A B C))     returns T under this proposal.  #4: (TAILP 3 '(A B C))     returns NIL under this proposal.  #5: (TAILP 3 '(A B C . 3))     returns T under this proposal.  #6: (TAILP '(X Y) '(A B C . 3))     returns NIL under this proposal. Current Practice:   Symbolics Genera is consistent with TAILP-NIL:T.  Neither Lucid nor VAX LISP currently implements TAILP-NIL:T.  VAX LISP effectively implements definition "A" from the   Problem Description above.Cost to Implementors:   An implementation of TAILP-NIL:T is given as Definition "B" in the  problem description.   Some implementations might have compiler optimizers for these definitions  as well, so a slight amount of additional effort might be required. Cost to Users:   Given that current practice varies widely on the disputed case,  this is unlikely to have a practical effect on existing portable code. Benefits:   Avoids unnecessary incompatibilities between implementations. Non-Benefits:  Slows down TAILP slightly in some implementations because ENDP is  potentially faster than ATOM.Discussion:   This issue was first raised in ">GLS>clarifications.text" of 12/06/85.  It recommended an earlier proposal, TAILP-NIL:NIL, which is effectively  equivalent to Definition "A" from the Problem Description.  Pitman introduced TAILP-NIL:T as an alternative, arguing that the  definition TAILP-NIL:NIL offered no practical value to programmers  in the disputed situations, while TAILP-NIL:T was of arguable usefulness.  Pitman and van Roggen support TAILP-NIL:T.  It was suggested more than once by more than one cleanup   committee member that we remove TAILP from the language  "since almost nobody uses it".         TITAN 
         TITAN 
           Z       	              
                                         %             O                          3       
                                                       
       D              f             o       z*start*06373 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 15:42:19 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  15:27:54 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 15:18:20 PSTDate: 12 Dec 88 15:17 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: TAILP-NIL (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-151820-5387@Xerox>!Issue:        TAILP-NILReferences:   TAILP (p275)Category:     CLARIFICATION/CHANGEEdit History: 13-Sep-88, version 1 by Walter van Roggen,              13-Sep-88, version 2 by Pitman              18-Oct-88, version 3 by van Roggen (just one proposal)              01-Dec-88, version 4 by Pitman (minor edits per discussion)               9-Dec-88, Version 5 by Masinter (clarify EQL)Problem Description:   CLtL (p275) specifies TAILP as:     TAILP sublist list				[Function]     This predicate is true if SUBLIST is a sublist of LIST (i.e.,    one of the conses that makes up LIST); otherwise, it is false.    Another way to look at this is that TAILP is true if    (NTHCDR n list) is SUBLIST, for some value of N. See LDIFF.   Two implementations of this definition might be:    (defun tailp (sublist list)			;Definition "A"     (do ((list list (cdr list)))	 ((endp list) nil)       (if (eql sublist list)	   (return t))))    (defun tailp (sublist list)			;Definition "B"     (do ((list list (cdr list)))	 ((atom list) (eql list sublist))       (if (eql sublist list)	   (return t))))   They differ only in their treatment of the atomic case.   At issue is the fact that () is a list, and hence some would  argue that it is a sublist of all other lists. On the other hand,  the definition of TAILP seems to imply that being a cons is a  necessary precondition of being a "sublist".  Also at issue is the question of whether dotted lists are permissible  second arguments.Proposal (TAILP-NIL:T):   Strike any text in the definition of TAILP which suggests that a  sublist must be a cons.   Clarify that (TAILP sublist list) returns true iff (NTHCDR n list) is  sublist for some value of n, and false otherwise.  Note, however, that since the list may be dotted, so the end test  used by TAILP must be ATOM, not ENDP. That is, if (TAILP x l)  returns true, it means there was n such that (NTHCDR n list) would  return x; however, it doesn't follow that if TAILP returns false,  it is safe to go blithely NTHCDR's into the list looking for it,   since the list might be dotted and NTHCDR might hit bad data.  Note that TAILP uses EQL or  equivalent to compare  sublist to list in the case where sublist is a number, etc.Rationale:   This is more consistent with the definition of LDIFF, which  gives a useful meaning to arbitrary atomic SUBLIST arguments.   This gives a more elegant definition of SUBLIST, allowing it to  refer to any list -- including the empty list -- which is a  part of another list.   Some reasons for preferring an ATOM check to ENDP include:   - The name TAILP suggests tails, not sublists. Some users might     expect this distinction to mean that data more general than     proper sublists.   - Making TAILP require lists limits its usefulness. If we did     not make this choice, some users would end up having to write     their own extended TAILP which we could just as well have     provided compatibly.   - TAILP is not considered to be used frequently enough in code     that the minor loss in speed to an ATOM check is worth the     lost functionality. Indeed, expanding the scope of its      capabilities may lead to more uses for TAILP.   - Other operators (eg, APPEND) have recently been extended to     treat dotted lists in an interesting way because users have     expressed a desire for this. As such, this change is      culturally consistent.   - Some implementations already support this feature, and the      wording in CLtL is sufficiently ambiguous that some users     might think it appropriate to depend on the feature. In the     absence of compelling efficiency reasons to the contrary,     we should lean toward extending some implementations rather     than tightening others in our efforts to achieve cross-dialect     consistency.Examples:  #1: (LET ((X '(B C))) (TAILP X (CONS 'A X)))     should return T in all implementations.  #2: (TAILP '(X Y) '(A B C))     should return NIL in all implementations.  #3: (TAILP '() '(A B C))     returns T under this proposal.  #4: (TAILP 3 '(A B C))     returns NIL under this proposal.  #5: (TAILP 3 '(A B C . 3))     returns T under this proposal.  #6: (TAILP '(X Y) '(A B C . 3))     returns NIL under this proposal. Current Practice:   Symbolics Genera is consistent with TAILP-NIL:T.  Neither Lucid nor VAX LISP currently implements TAILP-NIL:T.  VAX LISP effectively implements definition "A" from the   Problem Description above.Cost to Implementors:   An implementation of TAILP-NIL:T is given as Definition "B" in the  problem description.   Some implementations might have compiler optimizers for these definitions  as well, so a slight amount of additional effort might be required. Cost to Users:   Given that current practice varies widely on the disputed case,  this is unlikely to have a practical effect on existing portable code. Benefits:   Avoids unnecessary incompatibilities between implementations. Non-Benefits:  Slows down TAILP slightly in some implementations because ENDP is  potentially faster than ATOM.Discussion:   This issue was first raised in ">GLS>clarifications.text" of 12/06/85.  It recommended an earlier proposal, TAILP-NIL:NIL, which is effectively  equivalent to Definition "A" from the Problem Description.  Pitman introduced TAILP-NIL:T as an alternative, arguing that the  definition TAILP-NIL:NIL offered no practical value to programmers  in the disputed situations, while TAILP-NIL:T was of arguable usefulness.  Pitman and van Roggen support TAILP-NIL:T.  It was suggested more than once by more than one cleanup   committee member that we remove TAILP from the language  "since almost nobody uses it". *start*00947 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 12 DEC 88 17:55:07 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 507602; Mon 12-Dec-88 20:55:04 ESTDate: Mon, 12 Dec 88 20:55 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NIL (Version 5)To: x3j13@sail.stanford.educc: cl-cleanup@sail.stanford.edu, masinter.paIn-Reply-To: <881212-151820-5387@Xerox>Message-ID: <19881213015522.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoCorrection: Contrary to what the current practice section says,the proposal TAILP-NIL:T is not what Symbolics Genera does.  Infact I know of no implementation that does what the proposal says.However, I support the proposal anyway, because I think it's themost consistent with the rest of Common Lisp.*start*01284 00024 US Return-Path: <barmar@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 13 DEC 88 08:29:45 PSTReturn-Path: <barmar@fafnir.think.com>Received: from sauron.think.com by Think.COM; Tue, 13 Dec 88 10:38:42 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Tue, 13 Dec 88 11:25:07 ESTDate: Tue, 13 Dec 88 11:25 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: TAILP-NIL (Version 5)To: David A. Moon <Moon@stony-brook.scrc.symbolics.com>Cc: cl-cleanup@sail.stanford.edu, masinter.paIn-Reply-To: <19881213015522.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-Id: <19881213162522.6.BARMAR@OCCAM.THINK.COM>    Date: Mon, 12 Dec 88 20:55 EST    From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>    Correction: Contrary to what the current practice section says,    the proposal TAILP-NIL:T is not what Symbolics Genera does.  In    fact I know of no implementation that does what the proposal says.    However, I support the proposal anyway, because I think it's the    most consistent with the rest of Common Lisp.I just tried all the examples in the mailing, and they all had theresults that they were supposed to.  How does Genera differ fromTAILP-NIL:T?                                                barmar*start*01229 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 13 DEC 88 08:56:02 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 507776; Tue 13-Dec-88 11:52:01 ESTDate: Tue, 13 Dec 88 11:52 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NIL (Version 5)To: Barry Margolin <barmar@Think.COM>cc: cl-cleanup@sail.stanford.edu, masinter.paIn-Reply-To: <19881213162522.6.BARMAR@OCCAM.THINK.COM>Message-ID: <19881213165206.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Tue, 13 Dec 88 11:25 EST    From: Barry Margolin <barmar@Think.COM>    How does Genera differ from TAILP-NIL:T?Genera uses EQ, the proposal uses EQL (maybe you didn't notice that).Since I don't believe EQ belongs in Common Lisp in the first place, Iagree that any system function that uses EQ as a test is wrong andshould be using EQL, which is why I support the proposal.  (EQ is onlyin Common Lisp as a concession to implementors who haven't figured outhow to implement EQL efficiently (it isn't hard), or hadn't figured itout yet in 1984).*start*02133 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 14 DEC 88 10:37:02 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 508548; Wed 14-Dec-88 13:35:49 ESTDate: Wed, 14 Dec 88 13:35 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NIL (Version 5)To: Jon L White <jonl@lucid.com>cc: barmar@Think.COM, cl-cleanup@sail.stanford.edu, masinter.paIn-Reply-To: <8812140805.AA12044@bhopal>Message-ID: <19881214183553.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Wed, 14 Dec 88 00:05:20 PST    From: Jon L White <jonl@lucid.com>    re: . . . (EQ is only	in Common Lisp as a concession to implementors who haven't figured out	how to implement EQL efficiently (it isn't hard), or hadn't figured it	out yet in 1984).    Hmmm, I may remember something similar said in the late 1960's or very    early 1970's about why EQ was still in the language -- but back then,    the contender was EQUAL rather than EQL.  Plus ca change . . . maybe    there is a more fundamental reason than incompotent implementors.  Just to clarify what I meant, since as usual I didn't express myselfvery clearly in the initial message: I think of EQL as theimplementation-independent version of EQ.  The behavior of EQ isdifferent from EQL only in implementation-dependent situations thatportable programs are not supposed to depend on.  This is very differentfrom EQUAL, which is a semantically different operation in a way thatis meaningful across all implementations.								       Like,    maybe some folks implement their memory management systems in Lisp, and    are reluctant to give up all user-accessibility to this historic, object    identity function?Could be.  But I claim that EQ has no portable meaning distinct from EQL,only an implementation-dependent meaning, so that indeed we should be speakingin terms of "reluctance" rather than "semantics".Anyway, that's more than enough time on that side-issue.*start*01431 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 14 DEC 88 00:06:16 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA07168g; Wed, 14 Dec 88 00:03:21 PSTReceived: by bhopal id AA12044g; Wed, 14 Dec 88 00:05:20 PSTDate: Wed, 14 Dec 88 00:05:20 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812140805.AA12044@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: barmar@Think.COM, cl-cleanup@sail.stanford.edu, masinter.paIn-Reply-To: David A. Moon's message of Tue, 13 Dec 88 11:52 EST <19881213165206.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: TAILP-NIL (Version 5)re: . . . (EQ is only    in Common Lisp as a concession to implementors who haven't figured out    how to implement EQL efficiently (it isn't hard), or hadn't figured it    out yet in 1984).Hmmm, I may remember something similar said in the late 1960's or veryearly 1970's about why EQ was still in the language -- but back then,the contender was EQUAL rather than EQL.  Plus ca change . . . maybethere is a more fundamental reason than incompotent implementors.  Like,maybe some folks implement their memory management systems in Lisp, andare reluctant to give up all user-accessibility to this historic, objectidentity function?But that's just a conjecture.  I really don't know why (and don'tparticularly care why) EQ persists.-- JonL --*start*04365 00024 USaReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 13 DEC 88 16:05:14 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 508117; Tue 13-Dec-88 19:05:23 ESTDate: Tue, 13 Dec 88 19:05 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NIL (Version 5)To: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881212-151820-5387@Xerox>Message-ID: <881213190509.6.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 12 Dec 88 15:17 PST    From: cl-cleanup@sail.stanford.edu    Sender: masinter.pa@Xerox.COM    Issue:        TAILP-NIL    ...    Discussion:    ...      It was suggested more than once by more than one cleanup       committee member that we remove TAILP from the language      "since almost nobody uses it". For the record, at least one member of the cleanup committee thinksthis sentence is Irrelevant.  Removing the operator would be gratuitous. Inflammatory.  It seems to raise the possibility of removing TAILP,   when in fact since such a move would be quickly labeled gratuitous,   only provides fodder for those who wish to muddy the water and avoid   the real issues under discussion. Unfounded.  No evidence is presented to support the claim that almost   nobody uses it. Indeed, it has been repeatedly shown that if an   operator is used at all, we have no way of evaluating what it   means for the operator to be "used a lot" (lines of code, number   of executed funcalls, dollars behind products using, ...). It happens   that this claim's probably true, but as a point of style we oughtn't   be in the habit of making anonymous, unsubstantiated claims about usage   patterns, or especially of encouraging that decisions be made based on   such claims. Shooting in the Dark.  Even if an operator were not often used by some   metric(s), the suggestion that the only or best way to deal with it   is to remove it is random. There are equally good reasons to believe   that the operator would be both useful and more heavily used if its   definition were ammended to accomodate serious uses.   I, for one, have found that nearly every time I think LDIFF would   suffice, the EQL test (rather than EQUAL), and its failure to take   a test argument, has screwed me -- causing me to do what I have always   felt is needless rewrite. I have only rarely needed TAILP and I can't   remember if I ended up actually using it or not -- I'd suspect that   the constraints on it make it next to useless.   The point I want to stress is that the fact that LDIFF and TAILP have   not been what I've needed does not mean that I've not needed to find   the difference of two lists or to find if something was a subtail of   something else. The problem for me has not been that these -operations-   are useless (or nearly so) -- but rather that these -operators- are.   The cure is not necessarily to flush the operators -- it might well be   to fix them. I certainly think fixing them is the correct solution.Only in writing this message did I become cognizant of the significance ofmy problems with LDIFF and its relation to TAILP.Btw, I just looked up LDIFF and its description suffers from a similarnon-clarity about dotted lists to that which TAILP suffers from. Itclearly admits NIL as a possible sublist, but it doesn't really treatatoms. So, the status quo is that the relationship between LDIFF and TAILPis not clear, the proposal TAILP-NIL:NIL would have definitely made themincompatible, TAILP-NIL:T makes them more conceptually compatible, butwithout further clarification, they will not really be compatible.Based on this, I'm strongly tempted to suggest that we should ... - Expand this proposal to deal with LDIFF. - Elaborate this proposal to add a :TEST argument to both   operators. [Clearly a :TEST argument of EQUAL may be dramatically   slower, but if the alternative is to write a LOOP calling EQUAL,   the net effect is the same and the only question is how much coding   I have to do and how much the system will do for me.]So there! That should teach you to add "harmless" little additions to thediscussion at the last minute. :-)*start*01680 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 15 DEC 88 21:35:18 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00886g; Thu, 15 Dec 88 21:33:11 PSTReceived: by bhopal id AA20798g; Thu, 15 Dec 88 21:35:11 PSTDate: Thu, 15 Dec 88 21:35:11 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812160535.AA20798@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Tue, 13 Dec 88 19:05 EST <881213190509.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: TAILP-NIL (Version 5)re:    I, for one, have found that nearly every time I think LDIFF would       suffice, the EQL test (rather than EQUAL), and its failure to take       a test argument, has screwed me -- causing me to do what I have always       felt is needless rewrite. I have only rarely needed TAILP and I can't       remember if I ended up actually using it or not -- I'd suspect that       the constraints on it make it next to useless.This paragraph provides proof in substance of one of the reasons forwanting to toss out TAILP, namely   (1) the "test" questions is at least as complex as for defining       EQUAL -- and we never did come to agreement about that;It would only be sheer conjecture that the currently unused TAILPwould become generally useful if it were extended to take a :testargument.   By the reasoning in your note, you don't believe we haveany way to evaluate this kind of question; you say:    ``. . . we have no way of evaluating what it       means for the operator to be "used a lot"''-- JonL --*start*01825 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 18:52:13 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  18:51:59 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 18:50:54 PSTDate: 2 Jan 89 18:50 PSTFrom: masinter.paSubject: Re: Issue: TAILP-NIL (Version 5)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 13 Dec 88 19:05 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890102-185054-1879@Xerox>For the record, re: whether the following sentence is Irrelevant,Inflammatory, Unfounded, Shooting in the Dark<< It was suggested more than once by more than one cleanup committee member that we remove TAILP from the language"since almost nobody uses it". >>It is relevant, since it is an alternate solution to the proposal.It is inflammatory, evidenced by your flame.It is not unfounded; I have two messages, one from Moon and one from JonL,that mention removing TAILP from the language as a serious possibility,although only one of them used the phrase "since almost nobody uses it".Perhaps you could search through your local sources for calls to TAILP?As for "shooting in the dark", that's likely.However, we did not go so far as to present the proposal of removing TAILPas a serious contender, because we realized the cost of incompatiblechanges. I think if I were designing a good lisp from scratch I might putTAILP low in the list of priorities of things to add, but taking it out hashigh cost and almost no benefit. Your two suggestions (expand the proposal to deal with LDIFF, possibly adda :TEST argument) may have gotten lost.