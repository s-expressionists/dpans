*start*07921 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 JUN 88 10:07:00 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Jun 88  10:05:16 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 423715; Thu 23-Jun-88 13:05:03 EDTDate: Thu, 23 Jun 88 13:04 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-DEFINITION (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880623130442.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        FUNCTION-DEFINITIONReferences:   noneCategory:     ADDITIONEdit history: 23-Jun-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  There are portable ways to turn symbols and lists into functions,  but there are no portable ways to get back the original symbols and  lists given the functions.Proposal (FUNCTION-DEFINITION:OPTIONAL):  Introduce a new function called FUNCTION-DEFINITION which took as  its argument a function and returned three values:   #1: its ``definition'' as a symbol or list, or NIL if the       information was no longer available.   #2: NIL if the definition was enclosed in the null lexical       environment and something non-NIL if the definition was (or       might have been) enclosed in some non-null lexical environment.       [It is always safe for an implementation to return T for this       value.]   #3: the `name' of this function. the name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations would be free to not record this information, or to provide  primitives for flushing some or all of the information at any time.  Examples:      The following examples illustrate some possible return values, but    are not not intended to be exhaustive:      #1:    (FUNCTION-DEFINITION #'(LAMBDA (X) X))	or (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL      #2: (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) NIL), T, NIL	   but -not- (LAMBDA (X) X), NIL, NIL      #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION #'BAR) #'FOO)	(DEFUN FOO (Y) Y)	(FUNCTION-DEFINITION #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, FOO      #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-DEFINITION (FOO))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) X), T, "BAR in FOO"    Rationale:      This functionality would be useful to the pretty printer, debugger,    inspector, and other tools.    Cost to Implementors:      Because NIL can be returned as a first value, the amount of work forced    by this proposal is trivial. The following implementation is technically    legitimate, although many implementations would want to provide something    more useful:       (DEFUN FUNCTION-DEFINITION (FUNCTION)       (CHECK-TYPE FUNCTION FUNCTION)       (VALUES NIL NIL NIL))Proposal (FUNCTION-DEFINITION:REQUIRED):  Introduce a new function called FUNCTION-DEFINITION which took as  its argument a function and returned three values:   #1: its ``definition'' as a symbol or list, or NIL if the       information was no longer available.   #2: NIL if the definition was enclosed in the null lexical       environment and something non-NIL if the definition was (or       might have been) enclosed in some non-null lexical environment.       [It is always safe for an implementation to return T for this       value.]   #3: the `name' of this function. the name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations would be free to not record this information in file  compilations. In-core calls to EVAL and COMPILE would be required to  retain the information, however.  Examples:      The following examples illustrate some possible return values, but    are not not intended to be exhaustive:      #1:    (FUNCTION-DEFINITION #'(LAMBDA (X) X))	or (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL	in compiled code.             (FUNCTION-DEFINITION (EVAL '(LAMBDA (X) X)))	would not be permitted to return NIL, NIL, NIL since the compilation	occurred in the same environment.    #2: (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) NIL), T, NIL	   but -not- (LAMBDA (X) X), NIL, NIL        in compiled code.  	(FUNCTION-DEFINITION (FUNCALL (EVAL '(LAMBDA () #'(LAMBDA (X) X)))))	would not be permitted to return NIL, NIL, NIL since the compilation	occurred in the same environment.    #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION #'BAR) #'FOO)	(DEFUN FOO (Y) Y)	(FUNCTION-DEFINITION #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, FOO        in compiled code.  	If the DEFUN had been done interactively, the call to	FUNCTION-DEFINITION would not be permitted to return NIL, NIL, NIL	since the compilation occurred in the same environment.    #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-DEFINITION (FOO))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) X), T, "BAR in FOO"        in compiled code.  	If the DEFUN had been done interactively, the call to	FUNCTION-DEFINITION would not be permitted to return NIL, NIL, NIL	since the compilation occurred in the same environment.    Rationale:      This functionality would be useful to the pretty printer, debugger,    inspector, and other tools.      Additionally, this would be useful to programs which need to pass    around both a function and a representation of a function because a    single object could be passed which was efficient to call without     compromising the ability to reliably retrieve its representation.  Cost to Implementors:      Because NIL can be returned as a first value, the amount of work forced    by this proposal is small, but not trivial. A simple implementation    might allocate a slot in each function that could hold the definition,    or might allocate a hash table to hold the information.Current Practice:  Many implementations record this information, but not all that do  publish an interface to extracting the information.  The language T has this operation and calls it DISCLOSE. It is the  conceptual inverse of the ENCLOSE which occurs in some Scheme dialects,  and is implemented as what CLOS would call a "generic function".Cost to Users:  None. The change is upward compatible.Cost of Non-Adoption:  Certain kinds of portable debugging tools would be harder to write.Benefits:  The cost of non-adoption would be avoided.Aesthetics:  The phrase ``program is data; data is program'' comes up a lot in discussions  about Lisp. This makes the case for ``program is data'' more interesting.Discussion:  Pitman would prefer FUNCTION-DEFINITION:REQUIRED if people would agree to it  because it is considerably more useful in practice, but would like to see at  least FUNCTION-DEFINITION:OPTIONAL.*start*01334 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 04 AUG 88 17:40:59 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 4 Aug 88  17:39:48 PDTReceived: by labrea.stanford.edu; Thu, 4 Aug 88 17:38:30 PDTReceived: from bhopal.lucid.com by edsel id AA08863g; Thu, 4 Aug 88 17:35:17 PDTReceived: by bhopal id AA14409g; Thu, 4 Aug 88 17:37:05 PDTDate: Thu, 4 Aug 88 17:37:05 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8808050037.AA14409@bhopal.lucid.com>To: skona%csilvax@hub.ucsb.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Skona Brittain's message of Tue, 26 Jul 88 16:53:21 PDT <8807270025.AA26144@edsel.lucid.com>Subject: A lambda questionre: Now that we've supposedly finished with function-type,    is anybody working on a proposal to introduce a func-    tion that would retrieve the lambda-expression defini-    tion from a user-defined function object?Lucid Common Lisp has such a function, called SOURCE-CODE.  It retrieves the lambda expression used in an interpretive definition, even after sub-sequent compilation of the function; but it does not attempt to maintain an "out-of-core" database like the emacs TAGS facility.-- JonL --*start*01339 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 01 AUG 88 10:26:31 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Aug 88  10:24:22 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 440856; Mon 1-Aug-88 13:23:04 EDTDate: Mon, 1 Aug 88 13:22 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: A lambda question (a.k.a. issue FUNCTION-DEFINITION)To: Scott.Fahlman@B.GP.CS.CMU.EDU, skona%csilvax@hub.ucsb.educc: CL-Cleanup@SAIL.Stanford.EDUReferences: <880801104035.4.KMP@PEWEE.SCRC.Symbolics.COM>,            The message of 26 Jul 88 20:20 EDT from Scott.Fahlman@B.GP.CS.CMU.EDU,            The message of 26 Jul 88 16:53 PDT from Skona Brittain <skona%csilvax@hub.ucsb.edu>Message-ID: <880801132228.0.KMP@PEWEE.SCRC.Symbolics.COM>Actually, you faked me into thinking this wasn't written up.In fact, I submitted a proposal on this a while back:  FUNCTION-DEFINITION, Version 1, Pitman, 23-Jun-88Much of my previous message was a re-hash of what had gone intothat proposal. If you don't have a copy and need one, send memail privately and I'll re-transmit it to you.*start*03704 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 01 AUG 88 07:44:50 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Aug 88  07:42:41 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 440759; Mon 1-Aug-88 10:41:05 EDTDate: Mon, 1 Aug 88 10:40 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: A lambda question To: Scott.Fahlman@B.GP.CS.CMU.EDU, skona%csilvax@hub.ucsb.educc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: The message of 26 Jul 88 20:20 EDT from Scott.Fahlman@B.GP.CS.CMU.EDU,             The message of 26 Jul 88 16:53 PDT from Skona Brittain <skona%csilvax@hub.ucsb.edu>Message-ID: <880801104035.4.KMP@PEWEE.SCRC.Symbolics.COM>    Date: Tue, 26 Jul 88 20:20:57 EDT    From: Scott.Fahlman@B.GP.CS.CMU.EDU	If there were to be such a function, what would be a 	good name for it?        How about EXTRACT-LAMBDA-EXPRESSION ?The T language provides such a primitive. It is called DISCLOSE(named for symmetry with the ENCLOSE primitive which occurs in someScheme dialects and coerces a lambda expression into a procedure).DISCLOSE may be overly generic-sounding for CL use, but I recommendDISCLOSE-DEFINITION.    I assume that the proposal will allow this function to return NIL if    the original lambda expression has been compiled or optimized to the    point where it can no longer be retrieved?  I wouldn't want to require    memory-tight implementations to keep around the original form in all    cases.Since some applications for DISCLOSE have semantic impact, I don't agreethat it should be possible for an implementation to simply throw awaythe information. I believe that we should spell out particular casesin which it is or is not permissible. My personal preferences follow: - No compiler should be required to retain the source code   when using the file compiler. That is, using COMPILE-FILE   does not make the definition available in the environment into   which the definitions are subsequently LOADed. - I am agnostic about interactive DEFUN, etc. I am content to see   this information retained only at the discretion of the    interpreter. - I would prefer that arguments to COMPILE be retained, and possibly   defuns done by explicit EVAL as well. The reason for this is that   programs like Macsyma which have need of this function do not just   go around peeking into arbitrary functions (in my experience). They   usually want to peek into functions that they themselves instantiated.   So primitives that allow explicit runtime instantiation of functions   on a case-by-case basis should be reliably invertible (in my opinion).Notes: - I would be ammenable to permitting this function to be SETF-able,   so that people could ``NIL out'' definitions they didn't want to   retain. - I would also be ammenable to having a special argument to COMPILE   saying that the information must be retained. I don't care what   the default value was. - If there is not any reliable situation in which a definition will   have this information retained, then all the uses I have ever had   for this except for pretty printing are nullified. Perhaps the   pretty printing argument is reason enough to have it, though. - There is some question about whether in the case of named objects,   (DEFUN FOO (X) X)   (DISCLOSE-DEFINITION #'FOO) => (LAMBDA (X) X) or (DEFUN FOO (X) X)?   I think the latter.   Does whether FOO is still fdefined matter? I think not.*start*08285 00024 USfDate: 15 Sep 88 18:37 PDTFrom: masinter.paSubject:Issue: FUNCTION-DEFINITION (Version 1)To: cl-cleanuP@sail.stanford.educc: masinter.paline-fold: noSince people seem to have forgotten the original content of this issue, I thought I would refresh your memory. Comments?     ----- Begin Forwarded Messages -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 JUN 88 10:07:00 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Jun 88  10:05:16 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 423715; Thu 23-Jun-88 13:05:03 EDTDate: Thu, 23 Jun 88 13:04 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-DEFINITION (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880623130442.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        FUNCTION-DEFINITIONReferences:   noneCategory:     ADDITIONEdit history: 23-Jun-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  There are portable ways to turn symbols and lists into functions,  but there are no portable ways to get back the original symbols and  lists given the functions.Proposal (FUNCTION-DEFINITION:OPTIONAL):  Introduce a new function called FUNCTION-DEFINITION which took as  its argument a function and returned three values:   #1: its ``definition'' as a symbol or list, or NIL if the       information was no longer available.   #2: NIL if the definition was enclosed in the null lexical       environment and something non-NIL if the definition was (or       might have been) enclosed in some non-null lexical environment.       [It is always safe for an implementation to return T for this       value.]   #3: the `name' of this function. the name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations would be free to not record this information, or to provide  primitives for flushing some or all of the information at any time.  Examples:      The following examples illustrate some possible return values, but    are not not intended to be exhaustive:      #1:    (FUNCTION-DEFINITION #'(LAMBDA (X) X))	or (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL      #2: (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) NIL), T, NIL	   but -not- (LAMBDA (X) X), NIL, NIL      #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION #'BAR) #'FOO)	(DEFUN FOO (Y) Y)	(FUNCTION-DEFINITION #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, FOO      #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-DEFINITION (FOO))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) X), T, "BAR in FOO"    Rationale:      This functionality would be useful to the pretty printer, debugger,    inspector, and other tools.    Cost to Implementors:      Because NIL can be returned as a first value, the amount of work forced    by this proposal is trivial. The following implementation is technically    legitimate, although many implementations would want to provide something    more useful:       (DEFUN FUNCTION-DEFINITION (FUNCTION)       (CHECK-TYPE FUNCTION FUNCTION)       (VALUES NIL NIL NIL))Proposal (FUNCTION-DEFINITION:REQUIRED):  Introduce a new function called FUNCTION-DEFINITION which took as  its argument a function and returned three values:   #1: its ``definition'' as a symbol or list, or NIL if the       information was no longer available.   #2: NIL if the definition was enclosed in the null lexical       environment and something non-NIL if the definition was (or       might have been) enclosed in some non-null lexical environment.       [It is always safe for an implementation to return T for this       value.]   #3: the `name' of this function. the name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations would be free to not record this information in file  compilations. In-core calls to EVAL and COMPILE would be required to  retain the information, however.  Examples:      The following examples illustrate some possible return values, but    are not not intended to be exhaustive:      #1:    (FUNCTION-DEFINITION #'(LAMBDA (X) X))	or (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL	in compiled code.             (FUNCTION-DEFINITION (EVAL '(LAMBDA (X) X)))	would not be permitted to return NIL, NIL, NIL since the compilation	occurred in the same environment.    #2: (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) NIL), T, NIL	   but -not- (LAMBDA (X) X), NIL, NIL        in compiled code.  	(FUNCTION-DEFINITION (FUNCALL (EVAL '(LAMBDA () #'(LAMBDA (X) X)))))	would not be permitted to return NIL, NIL, NIL since the compilation	occurred in the same environment.    #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION #'BAR) #'FOO)	(DEFUN FOO (Y) Y)	(FUNCTION-DEFINITION #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, FOO        in compiled code.  	If the DEFUN had been done interactively, the call to	FUNCTION-DEFINITION would not be permitted to return NIL, NIL, NIL	since the compilation occurred in the same environment.    #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-DEFINITION (FOO))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) X), T, "BAR in FOO"        in compiled code.  	If the DEFUN had been done interactively, the call to	FUNCTION-DEFINITION would not be permitted to return NIL, NIL, NIL	since the compilation occurred in the same environment.    Rationale:      This functionality would be useful to the pretty printer, debugger,    inspector, and other tools.      Additionally, this would be useful to programs which need to pass    around both a function and a representation of a function because a    single object could be passed which was efficient to call without     compromising the ability to reliably retrieve its representation.  Cost to Implementors:      Because NIL can be returned as a first value, the amount of work forced    by this proposal is small, but not trivial. A simple implementation    might allocate a slot in each function that could hold the definition,    or might allocate a hash table to hold the information.Current Practice:  Many implementations record this information, but not all that do  publish an interface to extracting the information.  The language T has this operation and calls it DISCLOSE. It is the  conceptual inverse of the ENCLOSE which occurs in some Scheme dialects,  and is implemented as what CLOS would call a "generic function".Cost to Users:  None. The change is upward compatible.Cost of Non-Adoption:  Certain kinds of portable debugging tools would be harder to write.Benefits:  The cost of non-adoption would be avoided.Aesthetics:  The phrase ``program is data; data is program'' comes up a lot in discussions  about Lisp. This makes the case for ``program is data'' more interesting.Discussion:  Pitman would prefer FUNCTION-DEFINITION:REQUIRED if people would agree to it  because it is considerably more useful in practice, but would like to see at  least FUNCTION-DEFINITION:OPTIONAL.     ----- End Forwarded Messages -----*start*01731 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 OCT 88 14:45:51 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Oct 88  14:46:02 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 OCT 88 14:44:31 PDTDate: 2 Oct 88 14:44 PDTFrom: masinter.paSubject: Re: Issue: FUNCTION-DEFINITION (Version 1)In-reply-to: masinter.pa's message of 15 Sep 88 18:37 PDTTo: cl-cleanup@sail.stanford.eduMessage-ID: <881002-144431-2717@Xerox>After re-reading this for 30 seconds, I'd favor OPTIONAL.(Well, maybe I actually can't tell the difference between OPTIONAL andREQUIRED, and "OPTIONAL" sounds better to me. Maybe I'm someone who votesfor a candidate because of his accent.)I'm a little uneasy about "-DEFINITION", because in the residentialenvironment biz, the "definition" is the entire DEFUN form, and not justthe lambda expression. Is there another postfix you'd also feel comfortable with? You say Manyimplementations record this information, but not all that do publish aninterface to extracting the information.This issue should reference FUNCTION-TYPE as as part of the ProblemStatement say that this is something that people used to do with just plainold lambda expressions, since after (DEFUN FOO (X) ...) that(SYMBOL-FUNCTION 'FOO) would frequently return the lambda expressiondirectly.Now, with KCL and HP Common Lisp, the expression you get may not match whatyou put in, e.g., might have gone thru some kind of preprocessing. (Ithink.)Also, how can the "definition" be a symbol? In CommonLisp?Didn't we go thru (SETF (SYMBOL-FUNCTION X) 'FROB) before?*start*12012 00024 US Date:  8 Oct 88 17:25 PDTSender: masinter.paSubject: DRAFT Issue: FUNCTION-DEFINITION (Version 1)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterThis issue is still actively being developed, as you can see.This is just some evidence that we're working on it.Status: DRAFTIssue:        FUNCTION-DEFINITIONReferences:   noneCategory:     ADDITIONEdit history: 23-Jun-88, Version 1 by PitmanProblem Description:  There are portable ways to turn symbols and lists into functions,  but there are no portable ways to get back the original symbols and  lists given the functions.Proposal (FUNCTION-DEFINITION:OPTIONAL):  Introduce a new function called FUNCTION-DEFINITION which took as  its argument a function and returned three values:   #1: its ``definition'' as a symbol or list, or NIL if the       information was no longer available.   #2: NIL if the definition was enclosed in the null lexical       environment and something non-NIL if the definition was (or       might have been) enclosed in some non-null lexical environment.       [It is always safe for an implementation to return T for this       value.]   #3: the `name' of this function. the name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations would be free to not record this information, or to provide  primitives for flushing some or all of the information at any time.  Examples:      The following examples illustrate some possible return values, but    are not not intended to be exhaustive:      #1:    (FUNCTION-DEFINITION #'(LAMBDA (X) X))	or (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL      #2: (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) NIL), T, NIL	   but -not- (LAMBDA (X) X), NIL, NIL      #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION #'BAR) #'FOO)	(DEFUN FOO (Y) Y)	(FUNCTION-DEFINITION #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, FOO      #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-DEFINITION (FOO))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) X), T, "BAR in FOO"    Rationale:      This functionality would be useful to the pretty printer, debugger,    inspector, and other tools.    Cost to Implementors:      Because NIL can be returned as a first value, the amount of work forced    by this proposal is trivial. The following implementation is technically    legitimate, although many implementations would want to provide something    more useful:       (DEFUN FUNCTION-DEFINITION (FUNCTION)       (CHECK-TYPE FUNCTION FUNCTION)       (VALUES NIL NIL NIL))Proposal (FUNCTION-DEFINITION:REQUIRED):  Introduce a new function called FUNCTION-DEFINITION which took as  its argument a function and returned three values:   #1: its ``definition'' as a symbol or list, or NIL if the       information was no longer available.   #2: NIL if the definition was enclosed in the null lexical       environment and something non-NIL if the definition was (or       might have been) enclosed in some non-null lexical environment.       [It is always safe for an implementation to return T for this       value.]   #3: the `name' of this function. the name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations would be free to not record this information in file  compilations. In-core calls to EVAL and COMPILE would be required to  retain the information, however.  Examples:      The following examples illustrate some possible return values, but    are not not intended to be exhaustive:      #1:    (FUNCTION-DEFINITION #'(LAMBDA (X) X))	or (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL	in compiled code.             (FUNCTION-DEFINITION (EVAL '(LAMBDA (X) X)))	would not be permitted to return NIL, NIL, NIL since the compilation	occurred in the same environment.    #2: (FUNCTION-DEFINITION (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) NIL), T, NIL	   but -not- (LAMBDA (X) X), NIL, NIL        in compiled code.  	(FUNCTION-DEFINITION (FUNCALL (EVAL '(LAMBDA () #'(LAMBDA (X) X)))))	would not be permitted to return NIL, NIL, NIL since the compilation	occurred in the same environment.    #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION #'BAR) #'FOO)	(DEFUN FOO (Y) Y)	(FUNCTION-DEFINITION #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, FOO        in compiled code.  	If the DEFUN had been done interactively, the call to	FUNCTION-DEFINITION would not be permitted to return NIL, NIL, NIL	since the compilation occurred in the same environment.    #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-DEFINITION (FOO))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) X), T, "BAR in FOO"        in compiled code.  	If the DEFUN had been done interactively, the call to	FUNCTION-DEFINITION would not be permitted to return NIL, NIL, NIL	since the compilation occurred in the same environment.    Rationale:      This functionality would be useful to the pretty printer, debugger,    inspector, and other tools.      Additionally, this would be useful to programs which need to pass    around both a function and a representation of a function because a    single object could be passed which was efficient to call without     compromising the ability to reliably retrieve its representation.  Cost to Implementors:      Because NIL can be returned as a first value, the amount of work forced    by this proposal is small, but not trivial. A simple implementation    might allocate a slot in each function that could hold the definition,    or might allocate a hash table to hold the information.Current Practice:  Many implementations record this information, but not all that do  publish an interface to extracting the information.  The language T has this operation and calls it DISCLOSE. It is the  conceptual inverse of the ENCLOSE which occurs in some Scheme dialects,  and is implemented as what CLOS would call a "generic function".Cost to Users:  None. The change is upward compatible.Cost of Non-Adoption:  Certain kinds of portable debugging tools would be harder to write.Benefits:  The cost of non-adoption would be avoided.Aesthetics:  The phrase ``program is data; data is program'' comes up a lot in discussions  about Lisp. This makes the case for ``program is data'' more interesting.Discussion:  Pitman would prefer FUNCTION-DEFINITION:REQUIRED if people would agree to it  because it is considerably more useful in practice, but would like to see at  least FUNCTION-DEFINITION:OPTIONAL.- - - - - Additional comments - - - - - -re: Now that we've supposedly finished with function-type,    is anybody working on a proposal to introduce a func-    tion that would retrieve the lambda-expression defini-    tion from a user-defined function object?Lucid Common Lisp has such a function, called SOURCE-CODE.  It retrieves the lambda expression used in an interpretive definition, even after sub-sequent compilation of the function; but it does not attempt to maintain an "out-of-core" database like the emacs TAGS facility.	If there were to be such a function, what would be a 	good name for it?        How about EXTRACT-LAMBDA-EXPRESSION ?The T language provides such a primitive. It is called DISCLOSE(named for symmetry with the ENCLOSE primitive which occurs in someScheme dialects and coerces a lambda expression into a procedure).DISCLOSE may be overly generic-sounding for CL use, but I recommendDISCLOSE-DEFINITION.    I assume that the proposal will allow this function to return NIL if    the original lambda expression has been compiled or optimized to the    point where it can no longer be retrieved?  I wouldn't want to require    memory-tight implementations to keep around the original form in all    cases.Since some applications for DISCLOSE have semantic impact, I don't agreethat it should be possible for an implementation to simply throw awaythe information. I believe that we should spell out particular casesin which it is or is not permissible. My personal preferences follow: - No compiler should be required to retain the source code   when using the file compiler. That is, using COMPILE-FILE   does not make the definition available in the environment into   which the definitions are subsequently LOADed. - I am agnostic about interactive DEFUN, etc. I am content to see   this information retained only at the discretion of the    interpreter. - I would prefer that arguments to COMPILE be retained, and possibly   defuns done by explicit EVAL as well. The reason for this is that   programs like Macsyma which have need of this function do not just   go around peeking into arbitrary functions (in my experience). They   usually want to peek into functions that they themselves instantiated.   So primitives that allow explicit runtime instantiation of functions   on a case-by-case basis should be reliably invertible (in my opinion).Notes: - I would be ammenable to permitting this function to be SETF-able,   so that people could ``NIL out'' definitions they didn't want to   retain. - I would also be ammenable to having a special argument to COMPILE   saying that the information must be retained. I don't care what   the default value was. - If there is not any reliable situation in which a definition will   have this information retained, then all the uses I have ever had   for this except for pretty printing are nullified. Perhaps the   pretty printing argument is reason enough to have it, though. - There is some question about whether in the case of named objects,   (DEFUN FOO (X) X)   (DISCLOSE-DEFINITION #'FOO) => (LAMBDA (X) X) or (DEFUN FOO (X) X)?   I think the latter.   Does whether FOO is still fdefined matter? I think not.- - - - - -After re-reading this for 30 seconds, I'd favor OPTIONAL.(Well, maybe I actually can't tell the difference between OPTIONAL andREQUIRED, and "OPTIONAL" sounds better to me. Maybe I'm someone who votesfor a candidate because of his accent.)I'm a little uneasy about "-DEFINITION", because in the residentialenvironment biz, the "definition" is the entire DEFUN form, and not justthe lambda expression. Is there another postfix you'd also feel comfortable with? You say Manyimplementations record this information, but not all that do publish aninterface to extracting the information.This issue should reference FUNCTION-TYPE as as part of the ProblemStatement say that this is something that people used to do with just plainold lambda expressions, since after (DEFUN FOO (X) ...) that(SYMBOL-FUNCTION 'FOO) would frequently return the lambda expressiondirectly.Now, with KCL and HP Common Lisp, the expression you get may not match whatyou put in, e.g., might have gone thru some kind of preprocessing. (Ithink.)Also, how can the "definition" be a symbol? In CommonLisp?Didn't we go thru (SETF (SYMBOL-FUNCTION X) 'FROB) before?*start*00883 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:14:05 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:14:04 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA20625; Thu, 13 Oct 88 15:12:27 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19884; Thu, 13 Oct 88 15:12:25 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132112.AA19884@defun.utah.edu>Date: Thu, 13 Oct 88 15:12:24 MDTSubject: issue FUNCTION-DEFINITIONTo: cl-cleanup@sail.stanford.eduI'd be willing to vote for proposal OPTIONAL as long as the name of thefunction is changed to SOURCE-CODE (since it's my understanding that'swhat both Lucid and VaxLisp call their functions that do this).-Sandra-------*start*01955 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:37:31 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:32:43 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475931; Thu 13-Oct-88 17:31:14 EDTDate: Thu, 13 Oct 88 17:31 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-DEFINITION (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013173106.7.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: VAXLISP and Lucid have this function, but call it SOURCE-CODE. KMP agreed to name change.X3J13 meeting: Beckerle: `Let 'em write hash tables.' Skona: This function would be very useful in teaching situations	where people don't yet know about hash tables. KMP: Program modularity does not always permit the hash table      solution. Also, the hash table solution has GC impact unless      we have weak hash tables. Masinter: This would be an undue burden compiled-only implementations. KMP: Cloe is the only compiled-only implementation I can think of      and doesn't consider it to be an undue burden as long as      the info can be discarded by compile-file. van Roggen: VAXLISP now has several different kinds of evaluators,	     and this might impact some of them. Wants to study issue	     further. KMP thinks that some people seemed to have the mistaken belief that one of these proposals required source code info to files because they were worried about gratuitous bloating of dumped applications. Since both proposals only involve compile-to-core, they weren't nearly as wasteful of space as some seemed to believe. This needs to be made more apparent in the writeup.*start*02500 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 20:52:47 PDTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 13 Oct 88  20:51:30 PDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA23995@EDDIE.MIT.EDU>; Thu, 13 Oct 88 23:51:19 EDTReceived: by spt.entity.com (smail2.5); 13 Oct 88 23:41:20 EDT (Thu)To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Thu, 13 Oct 88 17:31 EDT <881013173106.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-DEFINITION (Version 1)Message-Id: <8810132341.AA02256@spt.entity.com>Date: 13 Oct 88 23:41:20 EDT (Thu)From: gz@spt.entity.com (Gail Zacharias)Coral implements something like this proposal (under a different name) withboth the OPTIONAL and REQUIRED options.  The requiredness is controlled by auser variable (*save-definitions*) which applies whenever a function iscreated from a lambda expression (as opposed to being fasloaded).  Thisincludes at least calls to COMPILE and the newly popular (EVAL '(FUNCTION(LAMBDA ...))) idiom.  Thus program-manipulating programs can ensure (bybinding the variable) that the lambda expression is preserved whenever it'scoerced to a function under program control, while users can turn off itsinteractive effect (by setting the global value) if space is tight.Note that we have an (optional) compiler-based evaluator, and not only doesthis not speak against this proposal, it was the main motivation for ourproviding this functionality in the first place.  And since one of theeffects of disallowing the application of lambda expressions is to makeprogram-creating programs behave as if they were in a compiler-basedimplementation, most such programs will require this functionality now, andeach one would need to reimplement it if it's not provided by the language.I strongly prefer a name like FUNCTION-DEFINITION over SOURCE-CODE, as thelatter can be confused with the textual source code (as in meta-.).I would also prefer that FUNCTION-NAME be split off as a separate functionrather than being one of the values from FUNCTION-DEFINITION, especially ifthe suggestion above about unifying the two options with a *save-definitions*variable is adopted.  This is because recording of function names shouldnot be controlled by this variable.*start*01286 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 NOV 88 12:08:11 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Nov 88  11:42:58 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 NOV 88 11:26:22 PSTDate: 8 Nov 88 11:26 PSTFrom: masinter.paSubject: Re: Issue: FUNCTION-DEFINITION (Version 1)In-reply-to: gz@spt.entity.com (Gail Zacharias)'s message of 13 Oct 88 23:41:20 EDT (Thu)To: gz@spt.entity.com (Gail Zacharias)cc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881108-112622-1084@Xerox>I also don't like SOURCE-CODE. I unfortunately don't likeFUNCTION-DEFINITION very much, either, but more for the reason that I'mused to thinking of the "definition" of a function as the entire DEFUNform, rather than the lambda expression that might be recovered from it.FUNCTION-LAMBDA-EXPRESSION? FUNCTION-SOURCE-CODE?I'm unsure how far we're willing to proscribe how much the form of theoriginal definition is retained. For example, after(DEFUN FOO (X) X)what is (FUNCTION-DEFINITION 'FOO)? Can it be(BLOCK-LAMBDA FOO (X) X)or must it be(LAMBDA (X) (BLOCK FOO X))or something else?*start*01592 00024 USfReturn-Path: <gls@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 08 NOV 88 12:50:21 PSTReceived: from fafnir.think.com by Think.COM; Tue, 8 Nov 88 14:41:08 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Tue, 8 Nov 88 15:00:31 ESTReceived: from joplin.think.com by verdi.think.com; Tue, 8 Nov 88 15:04:42 PSTReceived: by joplin.think.com; Tue, 8 Nov 88 15:00:20 ESTDate: Tue, 8 Nov 88 15:00:20 ESTFrom: gls@Think.COMMessage-Id: <8811082000.AA06028@joplin.think.com>To: masinter.paCc: gz@spt.entity.com, KMP@stony-brook.scrc.symbolics.com, CL-Cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@xerox.com's message of 8 Nov 88 11:26 PST <881108-112622-1084@Xerox>Subject: Issue: FUNCTION-DEFINITION (Version 1)   Date: 8 Nov 88 11:26 PST   From: masinter.pa@xerox.com   I also don't like SOURCE-CODE. I unfortunately don't like   FUNCTION-DEFINITION very much, either, but more for the reason that I'm   used to thinking of the "definition" of a function as the entire DEFUN   form, rather than the lambda expression that might be recovered from it.   FUNCTION-LAMBDA-EXPRESSION? FUNCTION-SOURCE-CODE?FUNCTION-SEXPR ?   I'm unsure how far we're willing to proscribe how much the form of the[prescribe?]   original definition is retained. For example, after   (DEFUN FOO (X) X)   what is (FUNCTION-DEFINITION 'FOO)? Can it be   (BLOCK-LAMBDA FOO (X) X)   or must it be   (LAMBDA (X) (BLOCK FOO X))   or something else?For example, can it be the same as the value of #'identity ?*start*05743 00024 USfReturn-Path: <spt!gz@EDDIE.MIT.EDU>Received: from EDDIE.MIT.EDU ([18.62.0.6]) by Xerox.COM ; 09 DEC 88 01:03:20 PSTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA11955@EDDIE.MIT.EDU>; Fri, 9 Dec 88 04:02:53 ESTReceived: by spt.entity.com (smail2.5); 9 Dec 88 03:34:39 EST (Fri)To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 7 Dec 88 22:48 PST <881207-224842-2825@Xerox>Subject: Issue: FUNCTION-DEFINITION (Version 2)Message-Id: <8812090334.AA10414@spt.entity.com>Date: 9 Dec 88 03:34:39 EST (Fri)From: gz@spt.entity.com (Gail Zacharias)   Date: 7 Dec 88 22:48 PST   From: masinter.pa@Xerox.COM   KMP is out of town, and I'm running out of time. Can I convince you to try   to produce a Version 2 that addresses the points made since Version 1 was   distributed?Ok.  I'm not sure what all the details of the format are supposed to be,so I'm sending it to you, I guess you can correct it and pass it on asappropriate...Issue:        FUNCTION-DEFINITIONReferences:   Issue FUNCTION-TYPECategory:     ADDITIONEdit history: 23-Jun-88, Version 1 by Pitman              09-Dec-88, Version 2 by GZ (changed fn name, removed REQUIRED                     option, specified first value to be a lambda, added to	             discussion and current practice)Status:	      For Internal DiscussionProblem Description:  There are portable ways to turn symbols and lists into functions,  but there are no portable ways to get back the original symbols and  lists given the functions.  In many cases, it used to be possible to recover the lambda expression  after a DEFUN by using FUNCTION or SYMBOL-FUNCTION, but the passage of  FUNCTION-TYPE will make this no longer be the case.Proposal (FUNCTION-DEFINITION:FUNCTION-SOURCE):  Introduce a new function called FUNCTION-SOURCE which takes as  its argument a function and returns three values:   #1: The function's defining lambda expression, or NIL if the information       is not available.  The lambda expression may have been pre-processed       in some ways, but it should remain a suitable argument to COMPILE       or FUNCTION.   #2: NIL if the definition was enclosed in the null lexical       environment or something non-NIL if the definition might       have been enclosed in some non-null lexical environment.   #3: the `name' of this function. The name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations are free to always return NIL T NIL, but are encouraged  to return the lambda expression in the case where the argument was created  by an in-core call to COMPILE or EVAL (as opposed to being created by  loading a compiled file).Examples:      The following examples illustrate some possible return values, but    are not intended to be exhaustive:      #1:    (FUNCTION-SOURCE #'(LAMBDA (X) X))	or (FUNCTION-SOURCE (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL    #2: (FUNCTION-SOURCE (FUNCALL #'(LAMBDA (X) #'(LAMBDA () X)) NIL))	might return NIL, T, NIL		  or (LAMBDA () X), T, NIL	   but -not- (LAMBDA () X), NIL, NIL      #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION 'BAR) #'FOO)	(FUNCTION-SOURCE #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) (BLOCK FOO X)), T, NIL		  or (LAMBDA (X) (BLOCK FOO X)), NIL, FOO		  or (SI::BLOCK-LAMBDA FOO (X) X), NIL, FOO    #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-SOURCE (FOO))	might return NIL, T, NIL		  or (LAMBDA (X) (BLOCK BAR X)), T, NIL		  or (LAMBDA (X) (BLOCK BAR X)), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) (BLOCK BAR X)), NIL, "BAR in FOO"  Rationale:      This functionality would be useful to a pretty printer, debugger,    inspector, and other tools.  Cost to Implementors:      The following implementation is technically legitimate, although many    implementations would want to provide something more useful:       (DEFUN FUNCTION-SOURCE (FUNCTION)       (CHECK-TYPE FUNCTION FUNCTION)       (VALUES NIL T NIL))Current Practice:  Many implementations record this information, but not all that do  publish an interface to extracting the information.  VAXLISP and  Lucid call it SOURCE-CODE.  Coral calls it UNCOMPILE-FUNCTION.  The language T has this operation and calls it DISCLOSE. It is the  conceptual inverse of the ENCLOSE which occurs in some Scheme dialects,  and is implemented as what CLOS would call a "generic function".Cost to Users:  None. The change is upward compatible.Cost of Non-Adoption:  Certain kinds of portable debugging tools would be harder to write.Benefits:  The cost of non-adoption would be avoided.Aesthetics:  The phrase ``program is data; data is program'' comes up a lot in discussions  about Lisp. This makes the case for ``program is data'' more interesting.Discussion:  The initial name proposed for this function was FUNCTION-DEFINITION.  This  was changed because of technical uses of the term ``definition'' to refer  to the entire defining form (e.g. a DEFUN form) rather than the lambda  expression that might be recovered from it.  The possibility of _requiring_ the lambda expression to be available for  all functions created by in-core calls to COMPILE or FUNCTION was considered  but didn't receive much support.  Pitman would prefer that option because  it is considerably more useful in practice, but would like to see at least  the current proposal.*start*00262 00024 US Date:  9 Dec 88 01:06 PSTFrom: masinter.paSubject: Re: Issue: FUNCTION-DEFINITION (Version 2)In-reply-to: your message of 9 Dec 88 03:34:39 EST (Fri)To: gz@spt.entity.com (Gail Zacharias)cc: masinter.paGreat. Its going out now...*start*05294 00024 US Date:  9 Dec 88 01:10 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: FUNCTION-DEFINITION (Version 2)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noIssue:        FUNCTION-DEFINITIONReferences:   Issue FUNCTION-TYPECategory:     ADDITIONEdit history: 23-Jun-88, Version 1 by Pitman              09-Dec-88, Version 2 by GZ (change name, remove REQUIRED                     option, specify first value to be a lambda, add to	             discussion and current practice)Problem Description:  There are portable ways to turn symbols and lists into functions,  but there are no portable ways to get back the original symbols and  lists given the functions.  In many cases, it used to be possible to recover the lambda expression  after a DEFUN by using FUNCTION or SYMBOL-FUNCTION, but the passage of  FUNCTION-TYPE will make this no longer be the case.Proposal (FUNCTION-DEFINITION:FUNCTION-SOURCE):  Introduce a new function called FUNCTION-SOURCE which takes as  its argument a function and returns three values:   #1: The function's defining lambda expression, or NIL if the information       is not available.  The lambda expression may have been pre-processed       in some ways, but it should remain a suitable argument to COMPILE       or FUNCTION.   #2: NIL if the definition was enclosed in the null lexical       environment or something non-NIL if the definition might       have been enclosed in some non-null lexical environment.   #3: the `name' of this function. The name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations are free to always return NIL T NIL, but are encouraged  to return the lambda expression in the case where the argument was created  by an in-core call to COMPILE or EVAL (as opposed to being created by  loading a compiled file).Examples:      The following examples illustrate some possible return values, but    are not intended to be exhaustive:      #1:    (FUNCTION-SOURCE #'(LAMBDA (X) X))	or (FUNCTION-SOURCE (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL    #2: (FUNCTION-SOURCE (FUNCALL #'(LAMBDA (X) #'(LAMBDA () X)) NIL))	might return NIL, T, NIL		  or (LAMBDA () X), T, NIL	   but -not- (LAMBDA () X), NIL, NIL      #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION 'BAR) #'FOO)	(FUNCTION-SOURCE #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) (BLOCK FOO X)), T, NIL		  or (LAMBDA (X) (BLOCK FOO X)), NIL, FOO		  or (SI::BLOCK-LAMBDA FOO (X) X), NIL, FOO    #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-SOURCE (FOO))	might return NIL, T, NIL		  or (LAMBDA (X) (BLOCK BAR X)), T, NIL		  or (LAMBDA (X) (BLOCK BAR X)), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) (BLOCK BAR X)), NIL, "BAR in FOO"  Rationale:      This functionality would be useful to a pretty printer, debugger,    inspector, and other tools.  Cost to Implementors:      The following implementation is technically legitimate, although many    implementations would want to provide something more useful:       (DEFUN FUNCTION-SOURCE (FUNCTION)       (CHECK-TYPE FUNCTION FUNCTION)       (VALUES NIL T NIL))Current Practice:  Many implementations record this information, but not all that do  publish an interface to extracting the information.  VAXLISP and  Lucid call it SOURCE-CODE.  Coral calls it UNCOMPILE-FUNCTION.  The language T has this operation and calls it DISCLOSE. It is the  conceptual inverse of the ENCLOSE which occurs in some Scheme dialects,  and is implemented as what CLOS would call a "generic function".Cost to Users:  None. The change is upward compatible.Cost of Non-Adoption:  Certain kinds of portable debugging tools would be harder to write.Benefits:  The cost of non-adoption would be avoided.Aesthetics:  The phrase ``program is data; data is program'' comes up a lot in discussions  about Lisp. This makes the case for ``program is data'' more interesting.Discussion:  The initial name proposed for this function was FUNCTION-DEFINITION.  This  was changed because of technical uses of the term ``definition'' to refer  to the entire defining form (e.g. a DEFUN form) rather than the lambda  expression that might be recovered from it.  The possibility of _requiring_ the lambda expression to be available for  all functions created by in-core calls to COMPILE or FUNCTION was considered  but didn't receive much support.  Pitman would prefer that option because  it is considerably more useful in practice, but would like to see at least  the current proposal.        TITAN 
         TITAN 
           Z              
              x                                   	                           r       0      D       
                    l                                         +              H       
       /                           ]      . "z*start*05258 00024 USfReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 01:29:21 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  01:19:19 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 01:11:17 PSTDate: 9 Dec 88 01:10 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: FUNCTION-DEFINITION (Version 2)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881209-011117-5596@Xerox>!Issue:        FUNCTION-DEFINITIONReferences:   Issue FUNCTION-TYPECategory:     ADDITIONEdit history: 23-Jun-88, Version 1 by Pitman              09-Dec-88, Version 2 by GZ (change name, remove REQUIRED                     option, specify first value to be a lambda, add to	             discussion and current practice)Problem Description:  There are portable ways to turn symbols and lists into functions,  but there are no portable ways to get back the original symbols and  lists given the functions.  In many cases, it used to be possible to recover the lambda expression  after a DEFUN by using FUNCTION or SYMBOL-FUNCTION, but the passage of  FUNCTION-TYPE will make this no longer be the case.Proposal (FUNCTION-DEFINITION:FUNCTION-SOURCE):  Introduce a new function called FUNCTION-SOURCE which takes as  its argument a function and returns three values:   #1: The function's defining lambda expression, or NIL if the information       is not available.  The lambda expression may have been pre-processed       in some ways, but it should remain a suitable argument to COMPILE       or FUNCTION.   #2: NIL if the definition was enclosed in the null lexical       environment or something non-NIL if the definition might       have been enclosed in some non-null lexical environment.   #3: the `name' of this function. The name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations are free to always return NIL T NIL, but are encouraged  to return the lambda expression in the case where the argument was created  by an in-core call to COMPILE or EVAL (as opposed to being created by  loading a compiled file).Examples:      The following examples illustrate some possible return values, but    are not intended to be exhaustive:      #1:    (FUNCTION-SOURCE #'(LAMBDA (X) X))	or (FUNCTION-SOURCE (FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL    #2: (FUNCTION-SOURCE (FUNCALL #'(LAMBDA (X) #'(LAMBDA () X)) NIL))	might return NIL, T, NIL		  or (LAMBDA () X), T, NIL	   but -not- (LAMBDA () X), NIL, NIL      #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION 'BAR) #'FOO)	(FUNCTION-SOURCE #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) (BLOCK FOO X)), T, NIL		  or (LAMBDA (X) (BLOCK FOO X)), NIL, FOO		  or (SI::BLOCK-LAMBDA FOO (X) X), NIL, FOO    #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-SOURCE (FOO))	might return NIL, T, NIL		  or (LAMBDA (X) (BLOCK BAR X)), T, NIL		  or (LAMBDA (X) (BLOCK BAR X)), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) (BLOCK BAR X)), NIL, "BAR in FOO"  Rationale:      This functionality would be useful to a pretty printer, debugger,    inspector, and other tools.  Cost to Implementors:      The following implementation is technically legitimate, although many    implementations would want to provide something more useful:       (DEFUN FUNCTION-SOURCE (FUNCTION)       (CHECK-TYPE FUNCTION FUNCTION)       (VALUES NIL T NIL))Current Practice:  Many implementations record this information, but not all that do  publish an interface to extracting the information.  VAXLISP and  Lucid call it SOURCE-CODE.  Coral calls it UNCOMPILE-FUNCTION.  The language T has this operation and calls it DISCLOSE. It is the  conceptual inverse of the ENCLOSE which occurs in some Scheme dialects,  and is implemented as what CLOS would call a "generic function".Cost to Users:  None. The change is upward compatible.Cost of Non-Adoption:  Certain kinds of portable debugging tools would be harder to write.Benefits:  The cost of non-adoption would be avoided.Aesthetics:  The phrase ``program is data; data is program'' comes up a lot in discussions  about Lisp. This makes the case for ``program is data'' more interesting.Discussion:  The initial name proposed for this function was FUNCTION-DEFINITION.  This  was changed because of technical uses of the term ``definition'' to refer  to the entire defining form (e.g. a DEFUN form) rather than the lambda  expression that might be recovered from it.  The possibility of _requiring_ the lambda expression to be available for  all functions created by in-core calls to COMPILE or FUNCTION was considered  but didn't receive much support.  Pitman would prefer that option because  it is considerably more useful in practice, but would like to see at least  the current proposal.*start*05116 00024 US Date: 11 Feb 89 00:09 PSTFrom: masinter.paTo: cl-cleanup@sail.stanford.eduSubject: Issue: FUNCTION-DEFINITION (Version 3)cc: masinter.paline-fold: noIssue:        FUNCTION-DEFINITIONReferences:   Issue FUNCTION-TYPECategory:     ADDITIONEdit history: 23-Jun-88, Version 1 by Pitman              09-Dec-88, Version 2 by GZ (change name, remove REQUIRED                     option, specify first value to be a lambda, add to	             discussion and current practice)		10-Feb-89, Version 3, as amended Jan 89 X3J13Problem Description:  There are portable ways to turn symbols and lists into functions,  but there are no portable ways to get back the original symbols and  lists given the functions.  In many cases, it used to be possible to recover the lambda expression  after a DEFUN by using FUNCTION or SYMBOL-FUNCTION, but the passage of  FUNCTION-TYPE will make this no longer be the case.Proposal (FUNCTION-DEFINITION:JAN89-X3J13):  Introduce a new function called FUNCTION-LAMBDA-EXPRESSION  which takes as its argument a function and returns three values:   #1: The function's defining lambda expression, or NIL if the information       is not available.  The lambda expression may have been pre-processed       in some ways, but it should remain a suitable argument to COMPILE       or FUNCTION.   #2: NIL if the definition was enclosed in the null lexical       environment or something non-NIL if the definition might       have been enclosed in some non-null lexical environment.   #3: the `name' of this function. The name is intended for debugging       only and may be any lisp object -- not necessarily one that would       be valid for use as a name in DEFUN or FUNCTION, for example.       By convention, NIL is used to mean that the function had no name.  Implementations are free to always return NIL T NIL, but are encouraged  to return the lambda expression in the case where the argument was created  by an in-core call to COMPILE or EVAL (as opposed to being created by  loading a compiled file).Examples:      The following examples illustrate some possible return values, but    are not intended to be exhaustive:      #1:    (FUNCTION-LAMBDA-EXPRESSION #'(LAMBDA (X) X))	or (FUNCTION-LAMBDA-EXPRESSION		(FUNCALL #'(LAMBDA () #'(LAMBDA (X) X))))	might return NIL, NIL, NIL		  or (LAMBDA (X) X), T, NIL		  or (LAMBDA (X) X), NIL, NIL    #2: (FUNCTION-LAMBDA-EXPRESSION 		(FUNCALL #'(LAMBDA (X) #'(LAMBDA () X)) NIL))	might return NIL, T, NIL		  or (LAMBDA () X), T, NIL	   but -not- (LAMBDA () X), NIL, NIL      #3: (DEFUN FOO (X) X)	(SETF (SYMBOL-FUNCTION 'BAR) #'FOO)	(FUNCTION-LAMBDA-EXPRESSION #'BAR)	might return NIL, NIL, NIL		  or (LAMBDA (X) (BLOCK FOO X)), T, NIL		  or (LAMBDA (X) (BLOCK FOO X)), NIL, FOO		  or (SI::BLOCK-LAMBDA FOO (X) X), NIL, FOO    #4: (DEFUN FOO ()	  (FLET ((BAR (X) X))	    #'BAR))	(FUNCTION-LAMBDA-EXPRESSION (FOO))	might return NIL, T, NIL		  or (LAMBDA (X) (BLOCK BAR X)), T, NIL		  or (LAMBDA (X) (BLOCK BAR X)), T, (:INTERNAL FOO 0 BAR)		  or (LAMBDA (X) (BLOCK BAR X)), NIL, "BAR in FOO"  Rationale:      This functionality would be useful to a pretty printer, debugger,    inspector, and other tools.  Cost to Implementors:      The following implementation is technically legitimate, although many    implementations would want to provide something more useful:       (DEFUN FUNCTION-LAMBDA-EXPRESSION (FUNCTION)       (CHECK-TYPE FUNCTION FUNCTION)       (VALUES NIL T NIL))Current Practice:  Many implementations record this information, but not all that do  publish an interface to extracting the information.  VAXLISP and  Lucid call it SOURCE-CODE.  Coral calls it UNCOMPILE-FUNCTION.  The language T has this operation and calls it DISCLOSE. It is the  conceptual inverse of the ENCLOSE which occurs in some Scheme dialects,  and is implemented as what CLOS would call a "generic function".Cost to Users:  None. The change is upward compatible.Cost of Non-Adoption:  Certain kinds of portable debugging tools would be harder to write.Benefits:  The cost of non-adoption would be avoided.Aesthetics:  The phrase ``program is data; data is program'' comes up a lot in discussions  about Lisp. This makes the case for ``program is data'' more interesting.Discussion:  The initial name proposed for this function was FUNCTION-DEFINITION.  This  was changed because of technical uses of the term ``definition'' to refer  to the entire defining form (e.g. a DEFUN form) rather than the lambda  expression that might be recovered from it.  The possibility of _requiring_ the lambda expression to be available for  all functions created by in-core calls to COMPILE or FUNCTION was considered  but didn't receive much support.  Pitman would prefer that option because  it is considerably more useful in practice, but would like to see at least  the current proposal.  Jan 89 X3J13 amended the proposal of Version 2 to change the name  from FUNCTION-SOURCE to FUNCTION-LAMBDA-EXPRESSION.