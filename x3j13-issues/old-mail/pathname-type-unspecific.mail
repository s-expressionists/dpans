*start*04531 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 27 JUN 88 13:23:03 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Jun 88  12:38:20 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 425383; Mon 27-Jun-88 15:38:00 EDTDate: Mon, 27 Jun 88 15:37 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-TYPE-UNSPECIFIC (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880627153746.0.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        PATHNAME-TYPE-UNSPECIFICReferences:   Pathnames (pp410-413)Category:     CHANGEEdit history: 27-Jun-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  CLtL (p412) specifies that the type is ``always a string, NIL,  or :WILD.'' This description is too restrictive to be practical.  In file systems which have no first-class notion of a name/type  distinction, it is possible to make files named "foo." and "foo"  which are distinct. One of these (usually the former) can get a  type of "" but it is not clear how to represent the other. If  NIL is used, merging primitives cannot detect that the field is  filled and should not be merged against.Proposal (PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN):  Permit :UNSPECIFIC as a value of the type field of a pathname for  operating systems in which it makes sense.  When a pathname is converted to a namestring, NIL and :UNSPECIFIC  both cause the component not to appear in the string.  When merging, however, a NIL value for a component will be replaced  with the default for that component, while :UNSPECIFIC will be left  alone.Test Case:  For file systems where :UNSPECIFIC makes sense...  (PATHNAME-TYPE (MAKE-PATHNAME :TYPE :UNSPECIFIC)) => :UNSPECIFIC  (PATHNAME-TYPE (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE :UNSPECIFIC)				  (MAKE-PATHNAME :TYPE "FOO")))Rationale:  This is, by necessity, current practice in some implementations  already.Current Practice:  Symbolics Genera uses a file type of :UNSPECIFIC on Unix and  ITS file systems, for example.Cost to Implementors:  None. No change to any implementation is forced.  Some implementations which use a non-standard token other than :UNSPECIFIC  to implement this functionality might want to switch to use :UNSPECIFIC so  that portable programs could expect it.Cost to Users:  Some programs which manipulate pathnames should be updated to expect  :UNSPECIFIC in the type fields in some situations.  Any program which doesn't already expect :UNSPECIFIC is already not really  portable, however, given that some implementations have been forced to  go beyond the standard in order to represent all possible pathnames.Cost of Non-Adoption:  Some implementations would be unable to both represent all possible pathnames  in a rational way and at the same time to conform to the standard.Benefits:  Some programs involving pathnames would be more portable.Aesthetics:  Sweeping a hairy situation under the rug doesn't make it go away.  This change makes things appear less simple, but since in reality  they were less simple, it is effectively a simplification of the  correspondence between the CL model and reality.Discussion:  Pitman supports PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN.  This feature existed in the Colander draft edition of CLtL, but was  removed for the Laser edition. The following text is excerpted from  the Colander edition, p259:   ``??? Query: Is :unspecific really needed over and above nil?   ``A component of a pathname can also be the keyword     :UNSPECIFIC. This means that the component has been explicitly     determined not to be there, as opposed to be missing. One way     this can occur is with generic pathnames, which refer not to     a file but to a whole family of files. The version, and usually     the type, of a generic pathname are :unspecific. Another way     :unspecific is used to represent components that are not simply     supported by a file system. When a pathname is converted to a     namestring, nil and :unspecific both cause the component not to     appear in the string. When merging, however, a nil value for     a component will be replaced with the default for that     component, while :unspecific will be left alone.''*start*00965 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 23 JUL 88 08:39:35 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 23 Jul 88  08:38:37 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA22032; Sat, 23 Jul 88 09:38:12 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA02390; Fri, 22 Jul 88 10:58:36 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807221658.AA02390@cdr.utah.edu>Date: Fri, 22 Jul 88 10:58:35 MDTSubject: Re: Issue: PATHNAME-TYPE-UNSPECIFIC (Version 1)To: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>Cc: cl-cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Mon, 27 Jun 88 15:37 EDTThis seems like a good idea to me.  We here at Utah ran into the sameproblem with our implementation of pathnames for Unix PCLS.-Sandra-------*start*01381 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 20:31:06 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Sep 88  19:23:23 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 455964; Wed 7-Sep-88 22:22:20 EDTDate: Wed, 7 Sep 88 22:22 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-TYPE-UNSPECIFIC (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880627153746.0.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19880908022204.7.MOON@EUPHRATES.SCRC.Symbolics.COM>I favor PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN.  It's interesting to notethat the rationale quoted from the Colander editor is weak and confused,but the rationale in Kent's proposal (which is actually in the problemdescription section) makes a lot more sense.  The problem isn't filesystems that don't have types at all, but file systems that have typesfor some pathnames but not for other pathnames, for example Unix.I suggest that the proposal be extended to allow :UNSPECIFIC in theversion, directory, device, and host fields as well.  The only fieldthat should not allow :UNSPECIFIC is the name field.*start*04124 00024 USfDate:  7 Oct 88 19:35 PDTFrom: masinter.paSubject: Issue: PATHNAME-TYPE-UNSPECIFIC (Version 1)To: X3J13@SAIL.Stanford.EDUREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterAnother proposal to extend this to other pathname componentswill probably be submitted, but not in time for this meeting.Issue:        PATHNAME-TYPE-UNSPECIFICReferences:   Pathnames (pp410-413)Category:     CHANGEEdit history: 27-Jun-88, Version 1 by PitmanProblem Description:  CLtL (p412) specifies that the type is ``always a string, NIL,  or :WILD.'' This description is too restrictive to be practical.  In file systems which have no first-class notion of a name/type  distinction, it is possible to make files named "foo." and "foo"  which are distinct. One of these (usually the former) can get a  type of "" but it is not clear how to represent the other. If  NIL is used, merging primitives cannot detect that the field is  filled and should not be merged against.Proposal (PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN):  Permit :UNSPECIFIC as a value of the type field of a pathname for  operating systems in which it makes sense.  When a pathname is converted to a namestring, NIL and :UNSPECIFIC  both cause the component not to appear in the string.  When merging, however, a NIL value for a component will be replaced  with the default for that component, while :UNSPECIFIC will be left  alone.Test Case:  For file systems where :UNSPECIFIC makes sense...  (PATHNAME-TYPE (MAKE-PATHNAME :TYPE :UNSPECIFIC)) => :UNSPECIFIC  (PATHNAME-TYPE (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE :UNSPECIFIC)				  (MAKE-PATHNAME :TYPE "FOO")))Rationale:  This is, by necessity, current practice in some implementations  already.Current Practice:  Symbolics Genera uses a file type of :UNSPECIFIC on Unix and  ITS file systems, for example.Cost to Implementors:  None. No change to any implementation is forced.  Some implementations which use a non-standard token other than :UNSPECIFIC  to implement this functionality might want to switch to use :UNSPECIFIC so  that portable programs could expect it.Cost to Users:  Some programs which manipulate pathnames should be updated to expect  :UNSPECIFIC in the type fields in some situations.  Any program which doesn't already expect :UNSPECIFIC is already not really  portable, however, given that some implementations have been forced to  go beyond the standard in order to represent all possible pathnames.Cost of Non-Adoption:  Some implementations would be unable to both represent all possible pathnames  in a rational way and at the same time to conform to the standard.Benefits:  Some programs involving pathnames would be more portable.Aesthetics:  Sweeping a hairy situation under the rug doesn't make it go away.  This change makes things appear less simple, but since in reality  they were less simple, it is effectively a simplification of the  correspondence between the CL model and reality.Discussion:  Pitman supports PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN.  This feature existed in the Colander draft edition of CLtL, but was  removed for the Laser edition. The following text is excerpted from  the Colander edition, p259:   ``??? Query: Is :unspecific really needed over and above nil?   ``A component of a pathname can also be the keyword     :UNSPECIFIC. This means that the component has been explicitly     determined not to be there, as opposed to be missing. One way     this can occur is with generic pathnames, which refer not to     a file but to a whole family of files. The version, and usually     the type, of a generic pathname are :unspecific. Another way     :unspecific is used to represent components that are not simply     supported by a file system. When a pathname is converted to a     namestring, nil and :unspecific both cause the component not to     appear in the string. When merging, however, a nil value for     a component will be replaced with the default for that     component, while :unspecific will be left alone.''*start*00789 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:07:30 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:53:11 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476081; Thu 13-Oct-88 18:51:50 EDTDate: Thu, 13 Oct 88 18:51 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-TYPE-UNSPECIFIC (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013185141.9.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: We thought this was ready to vote.*start*04268 00024 US Date:  8 Dec 88 21:28 PSTFrom: masinter.pato: masinterSubject: Issue:        PATHNAME-TYPE-UNSPECIFIC (Version 1)Issue:        PATHNAME-TYPE-UNSPECIFICReferences:   Pathnames (pp410-413)Category:     CHANGEEdit history: 27-Jun-88, Version 1 by PitmanProblem Description:  CLtL (p412) specifies that the type is ``always a string, NIL,  or :WILD.'' This description is too restrictive to be practical.  In file systems which have no first-class notion of a name/type  distinction, it is possible to make files named "foo." and "foo"  which are distinct. One of these (usually the former) can get a  type of "" but it is not clear how to represent the other. If  NIL is used, merging primitives cannot detect that the field is  filled and should not be merged against.Proposal (PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN):  Permit :UNSPECIFIC as a value of the type field of a pathname for  operating systems in which it makes sense.  When a pathname is converted to a namestring, NIL and :UNSPECIFIC  both cause the component not to appear in the string.  When merging, however, a NIL value for a component will be replaced  with the default for that component, while :UNSPECIFIC will be left  alone.Test Case:  For file systems where :UNSPECIFIC makes sense...  (PATHNAME-TYPE (MAKE-PATHNAME :TYPE :UNSPECIFIC)) => :UNSPECIFIC  (PATHNAME-TYPE (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE :UNSPECIFIC)				  (MAKE-PATHNAME :TYPE "FOO")))Rationale:  This is, by necessity, current practice in some implementations  already.Current Practice:  Symbolics Genera uses a file type of :UNSPECIFIC on Unix and  ITS file systems, for example.Cost to Implementors:  None. No change to any implementation is forced.  Some implementations which use a non-standard token other than :UNSPECIFIC  to implement this functionality might want to switch to use :UNSPECIFIC so  that portable programs could expect it.Cost to Users:  Some programs which manipulate pathnames should be updated to expect  :UNSPECIFIC in the type fields in some situations.  Any program which doesn't already expect :UNSPECIFIC is already not really  portable, however, given that some implementations have been forced to  go beyond the standard in order to represent all possible pathnames.Cost of Non-Adoption:  Some implementations would be unable to both represent all possible pathnames  in a rational way and at the same time to conform to the standard.Benefits:  Some programs involving pathnames would be more portable.Aesthetics:  Sweeping a hairy situation under the rug doesn't make it go away.  This change makes things appear less simple, but since in reality  they were less simple, it is effectively a simplification of the  correspondence between the CL model and reality.Discussion:  Pitman supports PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN.  This feature existed in the Colander draft edition of CLtL, but was  removed for the Laser edition. The following text is excerpted from  the Colander edition, p259:   ``??? Query: Is :unspecific really needed over and above nil?   ``A component of a pathname can also be the keyword     :UNSPECIFIC. This means that the component has been explicitly     determined not to be there, as opposed to be missing. One way     this can occur is with generic pathnames, which refer not to     a file but to a whole family of files. The version, and usually     the type, of a generic pathname are :unspecific. Another way     :unspecific is used to represent components that are not simply     supported by a file system. When a pathname is converted to a     namestring, nil and :unspecific both cause the component not to     appear in the string. When merging, however, a nil value for     a component will be replaced with the default for that     component, while :unspecific will be left alone.''        TITAN 
         TITAN 
           P                                                                             û       /      †              ã              O              b              ú             \              —       
       >                           /      >  zº*start*01214 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 00:33:24 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Jan 89  00:33:05 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 JAN 89 00:31:54 PSTDate: 12 Jan 89 00:30 PSTSender: masinter.paSubject: Issue: PATHNAME-TYPE-UNSPECIFIC (Version 1)To: cl-cleanup@sail.stanford.eduFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Message-ID: <890112-003154-11895@Xerox>[lmm: from Ballot]    I can understand why someone might find the need for :UNSPECIFIC    in Unix unclear, but I think that is because it is not clear what    filenames would be parsed as pathnames with :UNSPECIFIC type [*];    :UNSPECIFIC is nonetheless useful for building pathnames directly    when you know which case you want and need a way to specify it.    [*] Does a name without "." parse as type NIL or :UNSPECIFIC?    Different Unix programs use different conventions.  Some are    willing to merge in a type field, others, such as the C compiler,    leave names as-is.  So the "right" answer may vary.    *start*04435 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 09:28:27 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 12 Jan 89  09:24:48 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 520199; Thu 12-Jan-89 12:22:52 ESTDate: Thu, 12 Jan 89 12:22 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-TYPE-UNSPECIFIC (Version 1)To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <890112-003154-11895@Xerox>Message-ID: <890112122239.6.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 12 Jan 89 00:30 PST    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>    [lmm: from Ballot]	I can understand why someone might find the need for :UNSPECIFIC	in Unix unclear, but I think that is because it is not clear what	filenames would be parsed as pathnames with :UNSPECIFIC type [*];	:UNSPECIFIC is nonetheless useful for building pathnames directly	when you know which case you want and need a way to specify it.	[*] Does a name without "." parse as type NIL or :UNSPECIFIC?	Different Unix programs use different conventions.  Some are	willing to merge in a type field, others, such as the C compiler,	leave names as-is.  So the "right" answer may vary.    Symbolics systems have a consistent rule for use in the absence of a filesystem specific convention: assume that the last dot (if any) separates thename from the type.If there is no last dot, then the type is :UNSPECIFIC. If there is a lastdot, then the text to the right (even if null) is the type and the text tothe left (even if null) is the name.This rule means that: "." has name "" and type "". ".." has name "." and type "".You might say that this is not the optimal mapping, but after all:"." and ".." were quite obviously chosen to be screwy file names so they wouldn't get in the way of other more important namespaces.If you look at it that way, it's quite appropriate that they getinternal names which are not "easy" to generate.Whether "." was name "." and type :unspecific (as I mentionedis possible) or name "" and type "" (as we implement), it would notmerge a type. In either case, you could make a new pathname withthe same fields but with :TYPE NIL and then it would merge a type.Anyway, just to flesh this out, "Foo"  has name "Foo" and type :UNSPECIFIC. "Foo." has name "Foo" and type "" "Foo.Bar.Lisp" has name "Foo.Bar" and type "Lisp" ".Lisp" has name "" and type "Lisp"I wasn't involved in the choice of how this was partitioned and I admitto being surprised at the partitioning, but I've come to believe that itwas the correct thing. For example, it would be very much the wrong thingif a double-dot made for a dotted extension (ie, "Foo.Bar.Lisp" had name"Foo" and type "Bar.Lisp") so you have to take the dots from the right.It would not cause internal confusion to exempt "." and ".." and saythat they parsed as name "." and type :unspecific,etc. since in factthere is no namestring which will parse to that. On the other hand, whileit might appease some people, it would make the rule harder to remember.Anyway, I'm not so much proposing that we standardize this kind of thingbecause personally I think it's very inappropriate for a genericstandard like the one we're making to favor some vendors over others(since it's clear that we can't have info on everyone).  I was just tryingto give you a flavor of where I'm coming from in all this.By the way -- someone asked about why "Foo" can't be parsed as name "Foo" and type NIL. The answer is that it doesn't merge correctly.If your file defaults are something with an extension (eg, name "Foo"and type "Lisp"), and you do (OPEN "Baz"), you should to open "Baz",not "Baz.Lisp". If you don't, there is no way to open "Baz" without putting NIL in the standard pathname defaults before you do the opento make sure that merge doesn't succeed in removing all NILs, and it'smy impression you're not supposed to be doing that kind of thing.If  #S(PATHNAME :NAME "Foo" :TYPE :UNSPECIFIC) keeps a type from mergingand #S(PATHNAME :NAME "Foo" :TYPE NIL) allows a type to merge, thenyou have the best of both worlds.