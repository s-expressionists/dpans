*start*02501 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 10 Nov 88 13:42Subject: backquoteFrom: donc%vaxa.isi:EDU:XeroxTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: common-lisp@sail.stanford.eduSubject: backquoteFrom: Don Cohen <donc@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 13:42:39 PSTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 10 Nov 88  13:11:29 PSTPosted-Date: Thu, 10 Nov 88 11:55:40 PSTMessage-Id: <8811101955.AA11298@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.59/5.51)	id AA11298; Thu, 10 Nov 88 11:55:42 PSTOriginal-Date: Thu, 10 Nov 88 11:55:40 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI don't understand the 3 line explanation of backquotes in backquoteson p. 350 of CLtL.  I'd appreciate some enlightenment.  Also, I'd beinterested in whether backquote is capable of solving the problem below.I surely don't see how to do it, but since I don't really understandembedded backquotes I'm not sure it can't be done.The problem:Suppose we want to declare versions of existing functions that do typechecking, e.g., we want a protected version of (+ x y) which, if x and yare both numbers returns their sum and otherwise returns nil.  This couldbe done by the following macro:(defmacro protected-+ (x y)  `(let ((x ,x) (y ,y)) (and (numberp x) (numberp y) (+ x y))))so that(macroexpand '(protected-+ a b))=>(LET ((X A) (Y B))     (AND (NUMBERP X) (NUMBERP Y) (+ X Y)))(The let assures that each argument is evaluated only once.)Since there are many such functions to declare, we might want a macroto define them, e.g., (define-protected + (numberp x) (numberp y))would be a reasonable way to create the macro above.If we try to define this macro in the straight forward way we startout like so:(defmacro define-protected (function &rest args)  `(defmacro ,(MAKE-PROTECTED-NAME function)	     ,(mapcar #'cadr args)     `(let ,(BUILD-LET-LIST args)	(and ,@args	     ,(BUILD-FUNCTION-CALL function args)))))Unfortunately, it appears that BUILD-LET-LIST has to build an expression with more commas than backquotes, which the backquote readmacro cannot do.Another way to look at it is that I don't see how one backquote can produce different backquoted expressions with varying numbers of commas.*start*04558 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 10 Nov 88 14:28From: barmar%Think:COM:XeroxSubject: backquoteIn-Reply-to: <8811101955.AA11298@vaxa.isi.edu>To: donc%vaxa.isi:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: backquoteTo: Don Cohen <donc@vaxa.isi.edu>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <8811101955.AA11298@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 14:27:43 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 10 Nov 88  13:49:40 PSTReturn-Path: <@Think.COM:barmar@FAFNIR.THINK.COM>Received: from sauron.think.com by Think.COM; Thu, 10 Nov 88 16:24:39 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 10 Nov 88 16:46:56 ESTOriginal-Date: Thu, 10 Nov 88 16:47 ESTMessage-Id: <19881110214739.8.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 10 Nov 88 11:55:40 PST    From: Don Cohen <donc@vaxa.isi.edu>    I don't understand the 3 line explanation of backquotes in backquotes    on p. 350 of CLtL.  I'd appreciate some enlightenment.  Also, I'd be    interested in whether backquote is capable of solving the problem below.    I surely don't see how to do it, but since I don't really understand    embedded backquotes I'm not sure it can't be done.    The problem:    Suppose we want to declare versions of existing functions that do type    checking, e.g., we want a protected version of (+ x y) which, if x and y    are both numbers returns their sum and otherwise returns nil.  This could    be done by the following macro:    (defmacro protected-+ (x y)      `(let ((x ,x) (y ,y)) (and (numberp x) (numberp y) (+ x y))))    so that    (macroexpand '(protected-+ a b))    =>    (LET ((X A) (Y B))	 (AND (NUMBERP X) (NUMBERP Y) (+ X Y)))    (The let assures that each argument is evaluated only once.)    Since there are many such functions to declare, we might want a macro    to define them, e.g.,     (define-protected + (numberp x) (numberp y))    would be a reasonable way to create the macro above.    If we try to define this macro in the straight forward way we start    out like so:    (defmacro define-protected (function &rest args)      `(defmacro ,(MAKE-PROTECTED-NAME function)		 ,(mapcar #'cadr args)	 `(let ,(BUILD-LET-LIST args)	    (and ,@args		 ,(BUILD-FUNCTION-CALL function args)))))    Unfortunately, it appears that BUILD-LET-LIST has to build an expression     with more commas than backquotes, which the backquote readmacro cannot do.    Another way to look at it is that I don't see how one backquote can     produce different backquoted expressions with varying numbers of commas.The problem is that you are insisting on using the same argument namesin both places.  I think it becomes possible if you drop thatrequirement, and just use GENSYMs.  However, I'm not going to try towork it out, because I have a better idea:It would be easier if protected-+ were defined to be a function, and Idon't see any reason why it shouldn't be (for efficiency,DEFINE-PROTECTED could also include an INLINE proclamation).(defmacro define-protected (function &rest arg-specs)  (let ((protected-name (make-protected-name function))	(args (mapcar #'cadr arg-specs)))    `(progn       (proclaim '(inline ,protected-name))       (defun ,protected-name ,args	 (and ,@arg-specs	      (,function .,args))))))Here's another variant.  This has the improvement (in my opinion) thatyou don't build in assumptions about the format of the predicate call(the MAPCAR #'CADR means that an argument can't be described as (and(numberp x) (plusp x)).(defmacro define-protected (function &rest arg-specs)  "(define-protected <function> &rest (<arg1> <type1>) ...)"  (let ((protected-name (make-protected-name function))	(args (mapcar #'car arg-specs)))    `(progn       (proclaim '(inline ,protected-name))       (defun ,protected-name ,args	 ,@(mapcar #'(lambda (arg-spec)		       `(check-type ,.arg-spec))		   arg-specs)	 (,function .,args)))))This allows you to use arbitrary type specifiers (which are completelygeneral because of the (SATISFIES predicate) type spec).  In this case,your example above becomes:(define-protected + (x number) (y number))                                                barmar*start*02646 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 10 Nov 88 15:30From: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: backquoteIn-Reply-to: <8811101955.AA11298@vaxa.isi.edu>To: donc%vaxa.isi:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: backquoteTo: donc@vaxa.isi.educc: common-lisp@sail.stanford.eduIn-Reply-To: <8811101955.AA11298@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 15:30:24 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Nov 88  14:55:38 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 490777; Thu 10-Nov-88 17:55:48 ESTOriginal-Date: Thu, 10 Nov 88 17:55 ESTMessage-ID: <881110175533.0.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI prefer the syntax (define-protected ((x fixnum) (y float)) (+ x y)).In portable code, I would write: (defmacro define-protected (op bvl &body forms)   (let ((vars  (mapcar #'car  bvl))	 (types (mapcar #'cadr bvl)))     `(defmacro ,(intern (format nil "PROTECTED-~A" op)) ,vars	`(let ,(mapcar #'(lambda (var val type)			   `(,var ,val))		       ',vars		       (list ,@vars))	   (when (and ,@',(mapcar #'(lambda (var type) `(typep ,var ',type))				  vars types))	     ,@',forms)))))However, in implementations (such as the Symbolics implementation) whichsupport ",,@" as meaning "map , across the result of the first result, Imight sometimes write:(defmacro define-protected (op bvl &body forms)  (let ((vars  (mapcar #'car  bvl))	(types (mapcar #'cadr bvl)))    `(defmacro ,(intern (format nil "PROTECTED-~A" op)) ,vars       `((lambda ,',vars	   (when (and ,@',(mapcar #'(lambda (var type) `(typep ,var ',type))				  vars types))	     ,@',forms))	 ,,@vars))))I have found ,,@ quite useful in practice, but I've never been clear onwhether it's portable. It had been on my list of things to raise with theCL Cleanup committee, so thanks for giving me motivation to come up witha useful test case.Btw, in case your implementation doesn't support ,,@ -- here are sometest results for comparison: (macroexpand-1    '(define-protected + ((x fixnum) (y float)) (+ x y))) => (DEFMACRO PROTECTED-+ (X Y)      `((LAMBDA (X Y)	  (WHEN (AND (TYPEP X 'FIXNUM)		     (TYPEP Y 'FLOAT))	    (+ X Y)))	,X ,Y))*start*02285 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 10 Nov 88 16:32From: 7thSon%SPAR.SLB:COM:XeroxSubject: backquoteIn-Reply-to: <8811101955.AA11298@vaxa.isi.edu>To: donc%vaxa.isi:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:Xerox, 7thSon%SPAR.SLB:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Christopher Garrigues <7thSon@SPAR.SLB.COM>Subject: backquoteTo: Don Cohen <donc@vaxa.isi.edu>cc: common-lisp@sail.stanford.edu, 7thSon@SPAR.SLB.COMIn-Reply-To: <8811101955.AA11298@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 16:32:01 PSTReceived: from BOOKWORM.SPAR.SLB.COM by SAIL.Stanford.EDU with TCP; 10 Nov 88  16:03:06 PSTReceived: from MOTH.SPAR.SLB.COM by BOOKWORM.SPAR.SLB.COM via CHAOS with CHAOS-MAIL id 13519; Thu 10-Nov-88 16:00:43 PSTOriginal-Date: Thu, 10 Nov 88 16:01 PSTMessage-ID: <19881111000131.2.7THSON@MOTH.SPAR.SLB.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 10 Nov 88 11:55:40 PST    From: Don Cohen <donc@vaxa.isi.edu>    (defmacro protected-+ (x y)      `(let ((x ,x) (y ,y)) (and (numberp x) (numberp y) (+ x y))))I prefer this definition:(defmacro protected-+ (x y &environment env)  (once-only (x y &environment env)    `(and (numberp ,x) (numberp ,y) (+ ,x ,y))))Using this definition, I then defined the macro for defining protectedforms like this.(defmacro define-protected (function &rest args)  (let ((name (make-protected-name function))	(let-list (build-let-list args))	(function-call (build-function-call function args)))    `(defmacro ,name	       ,(mapcar #'cadr args)       (once-only (,@let-list &environment env)	 `(and ,,@args ,,function-call)))))Basically, I simply nested commas within one another.  When writing theouter backquote form, I think of the inner backquote form as if it werein it's expanded form.  Doing this, all you have to do is to make surethat you're out of a quoted form before you put your other comma in.this might require typing something like ",'".  The only tricky thing isthat I can never remember if I want ",,@" or ",@," and I seem to pickthe wrong one every time.*start*02004 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 10 Nov 88 17:17Subject: Re: backquoteIn-Reply-to: Your message of Thu, 10 Nov 88 11:55:40 PST.             <8811101955.AA11298@vaxa.isi.edu>Reply-to: ssmith%nrtc.northrop:COM:XeroxFrom: ssmith%ruffles.nrtc.northrop:COM:XeroxTo: donc%vaxa.isi:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: Don Cohen <donc@vaxa.isi.edu>cc: common-lisp@sail.stanford.eduSubject: Re: backquoteIn-reply-to: Your message of Thu, 10 Nov 88 11:55:40 PST.             <8811101955.AA11298@vaxa.isi.edu>Reply-To: ssmith@nrtc.northrop.comFrom: "Stephen P. Smith" <ssmith@ruffles.nrtc.northrop.com>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 17:17:37 PSTReceived: from ruffles.nrtc.northrop.com ([128.99.0.44]) by SAIL.Stanford.EDU with TCP; 10 Nov 88  16:50:57 PSTReceived: from localhost by RUFFLES.ruffles.nrtc.northrop.com id aa24943;          10 Nov 88 16:46 PSTMoon-Phase: The moon is a waxing crescent (2 percent of full).Original-Date: Thu, 10 Nov 88 16:46:32 -0800GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThough the other solutions are actually better, here isthe macro exactly as you were trying to get it:(defmacro define-protected (fcn &rest args)  (let ((targs (mapcar #'cadr args)))    `(defmacro ,(intern (format nil "PROTECTED-~a" fcn)) ,targs       `(let ,(mapcar #'(lambda (var val)			  `(,var ,val))		      ',targs		      (list ,@targs))	  (and ,',@args (,',fcn ,',@targs)))))) Note that you *must* use the mapcar trick to build the let list; Asyou saw, there is no way to pass a "free" comma around.From your question about the CLtL reference on page 350: It wasalso never clear to me without lots of experimentation whatsuch constructs as ,',@ should do either (or that they were really allowed).--Steve*start*01542 00024 UU?Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 10 Nov 88 14:45Subject: backquoteFrom: donc%vaxa.isi:EDU:XeroxTo: barmar%think:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: Barry Margolin <barmar@think.com>Cc: common-lisp@sail.stanford.eduSubject: backquoteFrom: Don Cohen <donc@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 14:45:28 PSTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 10 Nov 88  14:19:34 PSTPosted-Date: Thu, 10 Nov 88 14:18:19 PSTMessage-Id: <8811102218.AA14351@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.59/5.51)	id AA14351; Thu, 10 Nov 88 14:18:25 PSTOriginal-Date: Thu, 10 Nov 88 14:18:19 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI don't think the argument names are at all relevant - you'rewelcome to use different names.  Also, my specifications werealready completely general, since the car could have been alambda expression.Your reply provides a solution to a different problem.  I agree that if I really only wanted to define protected functions, that would be fine.  However the question was really about whether nested backquotes are really adequate for writing programs that write programs that ...Perhaps you believe that should never be necessary.  I admit itdoesn't seem to arise every day, but I've seen it several times.*start*02158 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 10 Nov 88 22:51From: jonl%lucid:COM:XeroxIn-Reply-to: Kent M Pitman's message of Thu, 10 Nov 88 17:55 EST <881110175533.0.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: backquoteTo: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: donc%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: donc@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Thu, 10 Nov 88 17:55 EST <881110175533.0.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: backquoteReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 22:51:25 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 10 Nov 88  22:22:17 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04475g; Thu, 10 Nov 88 22:19:16 PSTReceived: by bhopal id AA12160g; Thu, 10 Nov 88 22:17:57 PSTOriginal-Date: Thu, 10 Nov 88 22:17:57 PSTMessage-Id: <8811110617.AA12160@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: However, in implementations (such as the Symbolics implementation) which    support ",,@" as meaning "map , across the result of the first result, I    might sometimes write: [... a little test case ...]Lucid Common Lisp supports ",,@" as meaning just exactly what CLtL pages349-350 describe it to be.  And indeed LCL comes up the same results foryour little test case.Yes, I too have carped a bit about having yet another inscrutable meta-language for describing backquote [I think that is the source of DonC'scomplaint -- it's hard to understand CLtL pp349-50].  But Guy Steele has always managed to convince me that, for any given example, the rules onpp349-50 are consistent with the generally perceived notion of how backquote should work.  [By the bye, ask Quux about his favoritelittle doubly-nested backquote example; as far as I know, it doesn'teven parse in the Genera reader.]-- JonL --*start*02400 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 88 10:34From: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: backquoteIn-Reply-to: <8811110617.AA12160@bhopal>To: jonl%lucid:COM:Xerox, KMP%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: donc%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>Subject: backquoteTo: jonl@lucid.com, KMP@STONY-BROOK.SCRC.Symbolics.COMcc: donc@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: <8811110617.AA12160@bhopal>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 10:29:15 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Nov 88  09:59:24 PSTReceived: from SWALLOW.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 491105; Fri 11-Nov-88 12:58:04 ESTOriginal-Date: Fri, 11 Nov 88 12:57 ESTMessage-ID: <19881111175759.2.GREENWALD@SWALLOW.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 10 Nov 88 22:17:57 PST    From: Jon L White <jonl@lucid.com>    re: However, in implementations (such as the Symbolics implementation) which	support ",,@" as meaning "map , across the result of the first result, I	might sometimes write: [... a little test case ...]    Lucid Common Lisp supports ",,@" as meaning just exactly what CLtL pages    349-350 describe it to be.  And indeed LCL comes up the same results for    your little test case.    Yes, I too have carped a bit about having yet another inscrutable meta-    language for describing backquote [I think that is the source of DonC's    complaint -- it's hard to understand CLtL pp349-50].  But Guy Steele has     always managed to convince me that, for any given example, the rules on    pp349-50 are consistent with the generally perceived notion of how     backquote should work.  [By the bye, ask Quux about his favorite    little doubly-nested backquote example; as far as I know, it doesn't    even parse in the Genera reader.]Could you forward this doubly nested example to me, so that the Generareader >will< be able to parse it in future releases?    -- JonL --*start*03905 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 88 10:51Subject: backquoteFrom: donc%vaxa.isi:EDU:XeroxTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: common-lisp@sail.stanford.eduSubject: backquoteFrom: Don Cohen <donc@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 10:49:12 PSTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 11 Nov 88  10:20:46 PSTPosted-Date: Fri, 11 Nov 88 10:18:20 PSTMessage-Id: <8811111818.AA01792@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.59/5.51)	id AA01792; Fri, 11 Nov 88 10:18:59 PSTOriginal-Date: Fri, 11 Nov 88 10:18:20 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFirst, I was hoping for a clear statement of what nested backquotesmeant.  Here's my current theory - the result of experimentation.I don't see how to interpret CLtL to mean this (innermost backquoteexpanded first??), but at least maybe someone in the know caneither confirm my theory (and provide the mapping from CLtL) orcorrect it (and still provide the mapping):When you evaluate a backquote expression (oh, all right, the result of reading one evaluates as if ...), you throw away thebackquote (we're always evaluating the "outermost" backquote now!),find all the "matching" commas (which must all be innermostcommas, although not all innermost commas match this backquote!)and replace them with the results of evaluating them.  Leave allother backquotes and commas (and everything else) alone!  Thus``(a ,s ,',d ,,f `(,g))           --  --results in evaluation of the underlined expressions, yielding something like `(a ,s ,'4 ,7 `(,g)),@ is just like , except that you throw out an outer pair of parens.Is that right?----------------Next some comments on the "solutions".  What they have done is tochange the protected-+ macro from what I would have written originally into something else - my ((x ,x) (y ,y)) has become amapcar.  In other words, as long as the expansion has to be evaluated again, we can replace what we really want with somethingelse which will later evaluate to the same thing.  This works, butstarts to sacrifice some of the clarity which was the reason forbackquote in the first place.I think it would be a lot easier if you COULD "pass a 'free' comma around", and more generally, if you could directly express wheneach expression should be evaluated, i.e., which backquote itwent with.  Here's a "labelled backquote" macro that does this.  Reviews are welcome.  I describe it as a regular macro, not a readmacro.  I wonder whether that's important.  Perhaps backquotecould be extended in this direction.----------------(LBQ <label> ...) finds all occurrences of |,| (|,@|) whichare followed by <label>, throws out the |,| and label and replacesthe following expression with its value.  (defmacro define-protected (function &rest args)  (LBQ outer defmacro |,| outer (MAKE-PROTECTED-NAME function)      |,| outer (mapcar #'cadr args)     (LBQ inner let |,| outer (BUILD-LET-LIST args)	(and |,@| outer args	     |,| outer (BUILD-FUNCTION-CALL function args)))))where BUILD-LET-LIST produces a list of the form((x |,| inner x) (y |,| inner y)):Note that with backquote I couldn't have removed this into anotherfunction - sort of reminds you of lexical scoping, huh?(defun BUILD-LET-LIST (args)  (mapcar #'(lambda (arg) (list (cadr arg) '|,| 'inner (cadr arg))) args))(defun BUILD-FUNCTION-CALL (function args)       (cons function (mapcar #'cadr args)))(macroexpand-1 '(define-protected + (numberp x) (numberp y)))=>(DEFMACRO PROTECTED-+	  (X Y)	  (LBQ INNER LET	      ((X |,| INNER X) (Y |,| INNER Y))	      (AND (NUMBERP X) (NUMBERP Y) (+ X Y))))*start*02166 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 88 18:27From: RWK%f.ila.dialnet.symbolics:COM:XeroxSubject: Re: backquoteIn-Reply-to: The message of 10 Nov 88 19:46 EST from Stephen P. Smith <ssmith@ruffles.nrtc.northrop.com>To: ssmith%nrtc.northrop:COM:Xerox, donc%vaxa.isi:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@f.ila.dialnet.symbolics.com>Subject: Re: backquoteTo: ssmith@nrtc.northrop.com, donc@vaxa.isi.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: The message of 10 Nov 88 19:46 EST from Stephen P. Smith <ssmith@ruffles.nrtc.northrop.com>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 18:27:31 PSTReceived: from argus.Stanford.EDU by SAIL.Stanford.EDU with TCP; 11 Nov 88  18:04:22 PSTReceived: from Riverside.SCRC.Symbolics.COM (SCRC-RIVERSIDE.ARPA) by argus.Stanford.EDU with TCP; Fri, 11 Nov 88 17:57:40 PSTReceived: from F.ILA.Dialnet.Symbolics.COM (FUJI.ILA.Dialnet.Symbolics.COM) by Riverside.SCRC.Symbolics.COM via DIAL with SMTP id 293976; 11 Nov 88 21:01:28 ESTOriginal-Date: Fri, 11 Nov 88 19:08 ESTMessage-Id: <19881112000850.2.RWK@F.ILA.Dialnet.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 10 Nov 88 16:46:32 -0800    From: "Stephen P. Smith" <ssmith@ruffles.nrtc.northrop.com>    From your question about the CLtL reference on page 350: It was    also never clear to me without lots of experimentation what    such constructs as ,',@ should do either (or that they were     really allowed).Well, ,',@X is basically nonsense, unless you KNOW that X is exactlyone element long.  Otherwise you're passing the wrong number ofarguments to the QUOTE special form.  If you thin kyou want ,',@, youprobably want ,@',X.One way to look at ,@',X and ,',X is that these evaluate the X from theOUTER backquote's context.  Remember, the outer one is actually BUILDINGthe inner one.  The inner one being built is then "commafying" a quotedlist.*start*06199 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Nov 88 16:15From: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: backquoteIn-Reply-to: <8811111818.AA01792@vaxa.isi.edu>To: donc%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>Subject: backquoteTo: donc@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: <8811111818.AA01792@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 NOV 88 16:15:40 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Nov 88  15:38:05 PSTReceived: from SWALLOW.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 491650; 13 Nov 88 18:34:25 ESTOriginal-Date: Sun, 13 Nov 88 18:34 ESTMessage-ID: <19881113233411.3.GREENWALD@SWALLOW.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 11 Nov 88 10:18:20 PST    From: Don Cohen <donc@vaxa.isi.edu>    First, I was hoping for a clear statement of what nested backquotes    meant.  Here's my current theory - the result of experimentation.    I don't see how to interpret CLtL to mean this (innermost backquote    expanded first??), but at least maybe someone in the know can    either confirm my theory (and provide the mapping from CLtL) or    correct it (and still provide the mapping):First, you should distinguish between the two cases of nested backquoteswith an intervening comma, and nested backquotes without an interveningcomma.  The former case is unambigously specified by CLtL.  The latterisn't (the outer backquote will capture the intermediate state of thecomputation of the inner backquote.)Yours is an example of the latter case.    When you evaluate a backquote expression (oh, all right, the     result of reading one evaluates as if ...), you throw away the    backquote (we're always evaluating the "outermost" backquote now!),    find all the "matching" commas You can't do this without expanding the inner nested backquotes first.					(which must all be innermost    commas, although not all innermost commas match this backquote!)    and replace them with the results of evaluating them.  Leave all    other backquotes and commas (and everything else) alone!  Thus    ``(a ,s ,',d ,,f `(,g)) 	      --  --    results in evaluation of the underlined expressions, yielding     something like     `(a ,s ,'4 ,7 `(,g))    ,@ is just like , except that you throw out an outer pair of parens.    Is that right?No (it's not outright "wrong").  It is sort of backwards.CLtL states "If the backquote syntax is nested, the innermost backquotedform should be expanded first."This means that you can't start stripping commas until all innerbackquotes have been expanded.  At any given level of expansion youuse the outtermost comma first.The result of expanding a backquote is only defined after evaluation, sothe exact details of the list structure returned by `` will vary fromimplementation to implementation, however, the result of evaluating thevalue of a ``<form> should be consistent.In your example what's happening is something like this:Using the transformation rules at the top of page 350 this means thatthe interpretation of your example proceeds as follows: (forms like <...>, inside angle brackets are uninterpreted expressionsinside a backquote. Note that there's an implicit backquote before a <.You cannot intrepet the body of a <...> unless there are no <>'s insideit.)``(a ,s ,',d ,,f `(,g))<`(a ,s ,',d ,,f `(,g))>;; now we have a problem.  The inner backquote is going to produce a;; form that "when evaluated will ...", but the outer backquote is;; telling us not to actually evaluate that form.  So we exposing the;; innards of whichever reader we happen to be using.;; For the sake of pedagogy we choose a very simple backquote;; implementation.  We use bq-list instead of;; list so that the pretty printer will be able to print out these lists;; in backquote syntax.;; So the next step is:<(bq-list <a> <,s> <,',d> <,,f> <`(,g)>)><(bq-list 'a <,s> <,',d> <,,f> <`(,g)>)><(bq-list 'a s <,',d> <,,f> <`(,g)>)>;; now, the rules tell us how to take off the outermost ","<(bq-list 'a s ',d <,,f> <`(,g)>)>;; ditto<(bq-list 'a s ',d ,f <`(,g)>)><(bq-list 'a s ',d ,f (bq-list <,g>))><(bq-list 'a s ',d ,f (bq-list g))>;; now we can interpret <(bq-list ...)> relative to the outer backquote(bq-list <bq-list> <'a> <s> <',d> <,f> <(bq-list g)>);; the interpretation of <bq-list>, <'a>, and <s> are done in one step here;; because I'm getting bored...(bq-list 'bq-list ''a 's <',d> <,f> <(bq-list g)>);; this should help illustrate what >really< happened to <'a> in all of;; its boring steps.(bq-list 'bq-list ''a 's (list 'quote <,d>) <,f> <(bq-list g)>)(bq-list 'bq-list ''a 's (list 'quote d) <,f> <(bq-list g)>)(bq-list 'bq-list ''a 's (list 'quote d) f <(bq-list g)>)(bq-list 'bq-list ''a 's (list 'quote d) f (list 'bq-list 'g))Say that BQ-LIST acts exactly like LIST, except that the pretty printerknows how to print a list whose car is BQ-LIST by printing a leadingbackquote, and stripping one quote from each elt of the list, and ifthere's no quote to strip, inserting a comma.Then the result of the reading and evaluating your example (if D is 4and F is 7)read of ``(a ,s ,',d ,,f `(,g))   => (bq-list 'bq-list ''a 's (list 'quote d) f (list 'bq-list 'g))Eval of that   => (bq-list 'a s '4 7 (bq-list g))Which would be printed  `(a ,s 4 7 `(,g))So the illusion is that it is matching inner-most comma's to theoutermost backquote, but in fact it is behaving roughly the way Idescribe, and CLtL defines.  (I wasn't very careful about this, so Imight have made some mistakes - it's an awfully baroque transformation).A more common case is where the nested backquote is inside a comma, sothat the backquote implementation isn't exposed in the final result.*start*02192 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Nov 88 20:36From: jonl%lucid:COM:XeroxIn-Reply-to: Michael Greenwald's message of Fri, 11 Nov 88 12:57 EST <19881111175759.2.GREENWALD@SWALLOW.SCRC.SymSubject: backquoteTo: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xerox, donc%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: Greenwald@STONY-BROOK.SCRC.Symbolics.COMCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, donc@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: Michael Greenwald's message of Fri, 11 Nov 88 12:57 EST <19881111175759.2.GREENWALD@SWALLOW.SCRC.Symbolics.COM>Subject: backquoteReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 NOV 88 20:36:53 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 13 Nov 88  20:08:42 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA05685g; Sun, 13 Nov 88 20:06:13 PSTReceived: by bhopal id AA20070g; Sun, 13 Nov 88 20:04:56 PSTOriginal-Date: Sun, 13 Nov 88 20:04:56 PSTMessage-Id: <8811140404.AA20070@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: Could you forward this doubly nested example to me, so that the Genera    reader >will< be able to parse it in future releases?I think it is ``(,@,@x).  Believe it or not, one can "crank" the rulesof CLtL p349-50 to come up with a meaning for it.  Lucid, Xerox, andVAXLISP get it "right" according to that meaning.  Several others generatea read-time error (which is what I think Symbolics 7.0 does).  I've seensome that parse it without error but subsquently generate wrong code.As to whether this was ever used in naturally occurring code -- I dunno.Ask QUUX (Guy L Steele).-- JonL --P.S.: When trying to work out an example using the rules of CLtL p340-50,       it's important to remember that the square-brackets are part of the       syntax of that crufty litle production-rule language. They are not      meta-meta-syntax.*start*01156 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 88 00:36From: barmar%Think:COM:XeroxIn-Reply-to: Jon L White's message of Sun, 13 Nov 88 20:04:56 PST <8811140404.AA20070@bhopal>Subject: backquoteTo: jonl%lucid:COM:Xeroxcc: Greenwald%stony-brook.scrc.symbolics:COM:Xerox, KMP%stony-brook.scrc.symbolics:COM:Xerox, donc%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 00:36:55 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 14 Nov 88  00:07:15 PSTReturn-Path: <barmar@Think.COM>Received: from kulla.think.com by Think.COM; Mon, 14 Nov 88 02:27:39 ESTReceived: by kulla.think.com; Mon, 14 Nov 88 02:43:25 ESTOriginal-Date: Mon, 14 Nov 88 02:43:25 ESTMessage-Id: <8811140743.AA22690@kulla.think.com>Specifically Re: ``(,@,@x)It does still get a read-time error on Genera 7.2.  I also tried somevariants.  ``(,@,@x a) seems to work.  ``(a ,@,@x) doesn't get anerror, but I think it gets the wrong result.						barmar*start*02621 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 88 09:53From: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: backquoteIn-Reply-to: <8811140404.AA20070@bhopal>To: jonl%lucid:COM:Xerox, Greenwald%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xerox, donc%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>Subject: backquoteTo: jonl@lucid.com, Greenwald@STONY-BROOK.SCRC.Symbolics.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, donc@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: <8811140404.AA20070@bhopal>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 09:27:15 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 14 Nov 88  08:43:14 PSTReceived: from SWALLOW.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 491891; Mon 14-Nov-88 11:41:01 ESTOriginal-Date: Mon, 14 Nov 88 11:40 ESTMessage-ID: <19881114164032.1.GREENWALD@SWALLOW.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Sun, 13 Nov 88 20:04:56 PST    From: Jon L White <jonl@lucid.com>    re: Could you forward this doubly nested example to me, so that the Genera	reader >will< be able to parse it in future releases?    I think it is ``(,@,@x).  Believe it or not, one can "crank" the rules    of CLtL p349-50 to come up with a meaning for it.  Once you mention the example, it's not hard to believe at all.The bug in the Symbolics implementation is that it tries to optimize`(,@<form>) to just be <form>.  This isn't legal when you are insideanother backquote, and <form> might have a ",." or a ",@" that mighthave to be further expanded.I've submitted a patch.							Lucid, Xerox, and    VAXLISP get it "right" according to that meaning.  Several others generate    a read-time error (which is what I think Symbolics 7.0 does).  I've seen    some that parse it without error but subsquently generate wrong code.    As to whether this was ever used in naturally occurring code -- I dunno.    Ask QUUX (Guy L Steele).    -- JonL --    P.S.: When trying to work out an example using the rules of CLtL p340-50, 	  it's important to remember that the square-brackets are part of the 	  syntax of that crufty litle production-rule language. They are not	  meta-meta-syntax.Right.*start*02602 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 88 10:24Subject: nested backquotesFrom: donc%vaxa.isi:EDU:XeroxTo: greenwald%stony-brook.scrc.symbolics:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: greenwald@stony-brook.scrc.symbolics.comCc: common-lisp@sail.stanford.eduSubject: nested backquotesFrom: Don Cohen <donc@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 09:50:03 PSTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 14 Nov 88  09:16:59 PSTPosted-Date: Mon, 14 Nov 88 09:11:39 PSTMessage-Id: <8811141711.AA04256@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.59/5.51)	id AA04256; Mon, 14 Nov 88 09:11:42 PSTOriginal-Date: Mon, 14 Nov 88 09:11:39 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI think I understand your description (I think you left out a quote ortwo in the last element).  Furthermore, I strongly suspect (but havenot yet proven) that it is equivalent to mine.  If so, my explanationseems easier to understand.  The only problem was that you evidentlydid not understand what "matching" meant.  It was very simple and didNOT require expanding the inner backquotes.  Let me rephrase the modeland see if you agree that it gives the same results as yours.  Pretend that comma (comma@) reads like quote - ,x = (COMMA x) exceptthat an expression may not be in the scope of more commas than backquotes.Similarly, suppose that backquote reads as the symbol BACKQUOTE consedonto the next read.  So ``(a ,s ,',d ,,f `(,g)) reads as(BACKQUOTE BACKQUOTE a (COMMA s) (COMMA (QUOTE (COMMA d)))	   (COMMA (COMMA f)) (BACKQUOTE ((COMMA g))))Now in order to evaluate that expression we find all forms that arein the scope of as many COMMAs as BACKQUOTEs.  We discard the leadingBACKQUOTE and replace such expressions (along with the matching COMMAs)with their values.  In this case, the d and f are in the scope of 2 of each.  The result is(BACKQUOTE a (COMMA s) (COMMA (QUOTE 4)) (COMMA 7) (BACKQUOTE ((COMMA g))))Evaluating this would similarly give something like(a 3 4 7 (BACKQUOTE ((COMMA g))))If you don't believe this model is equivalent please send me a counterexample.  (The only thing I can see won't work is if somethingEVALUATES to a list containing the symbols BACKQUOTE or COMMA, and Ithink we can pretend that's impossible, even though it's precisely whatI really WANTED to do!)*start*04631 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 88 11:20From: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: nested backquotesIn-Reply-to: <8811141711.AA04256@vaxa.isi.edu>To: donc%vaxa.isi:EDU:Xerox, greenwald%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>Subject: nested backquotesTo: donc@vaxa.isi.edu, greenwald@STONY-BROOK.SCRC.Symbolics.COMcc: common-lisp@sail.stanford.eduIn-Reply-To: <8811141711.AA04256@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 11:19:17 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 14 Nov 88  10:27:20 PSTReceived: from SWALLOW.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 492023; Mon 14-Nov-88 13:27:23 ESTOriginal-Date: Mon, 14 Nov 88 13:27 ESTMessage-ID: <19881114182707.6.GREENWALD@SWALLOW.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon, 14 Nov 88 09:11:39 PST    From: Don Cohen <donc@vaxa.isi.edu>    I think I understand your description (I think you left out a quote or    two in the last element).  Furthermore, I strongly suspect (but have    not yet proven) that it is equivalent to mine.  If so, my explanation    seems easier to understand. You said:   "I don't see how to interpret CLtL to mean this (innermost backquote   expanded first??)"  I was just explaining the behavior of readers (that you determined"experimentally") did conform to CLtL.  I thought you decided that CLtLdid not define the case of nested backquotes unambiguously.  I was justpointing out that CLtL's rules defining the interpretation of nestedbackquote cases *are* well-defined.  I don't claim that the rules are anexample of pedagogic clarity, or that your explication isn't easier tounderstand, I was just showing you how CLtL's rules work.The rule (in concise form) is: Expand the innermost backquote first,always using the outermost comma.The rule itself is simple.  In more complicated situations theproductions are ugly, taking many steps, and your model probablydescribes the behavior more clearly.  I don't know.  I haven't tried toprove that your model is equivalent to CLtL's rule, but intuitively theyseem equivalent.If you understand CLtL's rule now, then you can use your model with moreconfidence, since your original problem seemed to be that you didn'tknow how to derive the behavior of readers from the specification inCLtL.  If you can prove that your model is equivalent, and if it is acceptedthat your model is a clearer and cleaner explanation, then your modelshould probably be included in a future backquote specification as auseful guideline. 				The only problem was that you evidently    did not understand what "matching" meant.  It was very simple and did    NOT require expanding the inner backquotes.  Let me rephrase the model    and see if you agree that it gives the same results as yours.      Pretend that comma (comma@) reads like quote - ,x = (COMMA x) except    that an expression may not be in the scope of more commas than backquotes.    Similarly, suppose that backquote reads as the symbol BACKQUOTE consed    onto the next read.  So ``(a ,s ,',d ,,f `(,g)) reads as    (BACKQUOTE BACKQUOTE a (COMMA s) (COMMA (QUOTE (COMMA d)))	       (COMMA (COMMA f)) (BACKQUOTE ((COMMA g))))    Now in order to evaluate that expression we find all forms that are    in the scope of as many COMMAs as BACKQUOTEs.  We discard the leading    BACKQUOTE and replace such expressions (along with the matching COMMAs)    with their values.  In this case, the d and f are in the scope of 2 of     each.  The result is    (BACKQUOTE a (COMMA s) (COMMA (QUOTE 4)) (COMMA 7) (BACKQUOTE ((COMMA g))))    Evaluating this would similarly give something like    (a 3 4 7 (BACKQUOTE ((COMMA g))))    If you don't believe this model is equivalent please send me a     counterexample.  (The only thing I can see won't work is if something    EVALUATES to a list containing the symbols BACKQUOTE or COMMA, The evaluation does not occur at read-time, unless there's a #,, butthen you can't pass ","'s up, so I don't think this is relevant.								    and I    think we can pretend that's impossible, even though it's precisely what    I really WANTED to do!)*start*03118 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 88 14:25From: gls%Think:COM:XeroxIn-Reply-to: Don Cohen's message of Mon, 14 Nov 88 09:11:39 PST <8811141711.AA04256@vaxa.isi.edu>Subject: nested backquotesTo: donc%vaxa.isi:EDU:Xeroxcc: greenwald%stony-brook.scrc.symbolics:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 14:25:10 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 14 Nov 88  13:50:22 PSTReceived: from fafnir.think.com by Think.COM; Mon, 14 Nov 88 16:27:03 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Mon, 14 Nov 88 16:46:19 ESTReceived: from joplin.think.com by verdi.think.com; Mon, 14 Nov 88 16:46:18 ESTReceived: by joplin.think.com; Mon, 14 Nov 88 16:46:15 ESTOriginal-Date: Mon, 14 Nov 88 16:46:15 ESTMessage-Id: <8811142146.AA29789@joplin.think.com>   Posted-Date: Mon, 14 Nov 88 09:11:39 PST   Date: Mon, 14 Nov 88 09:11:39 PST   From: Don Cohen <donc@vaxa.isi.edu>   I think I understand your description (I think you left out a quote or   two in the last element).  Furthermore, I strongly suspect (but have   not yet proven) that it is equivalent to mine.  If so, my explanation   seems easier to understand.  The only problem was that you evidently   did not understand what "matching" meant.  It was very simple and did   NOT require expanding the inner backquotes.  Let me rephrase the model   and see if you agree that it gives the same results as yours.     Pretend that comma (comma@) reads like quote - ,x = (COMMA x) except   that an expression may not be in the scope of more commas than backquotes.   Similarly, suppose that backquote reads as the symbol BACKQUOTE consed   onto the next read.  So ``(a ,s ,',d ,,f `(,g)) reads as   (BACKQUOTE BACKQUOTE a (COMMA s) (COMMA (QUOTE (COMMA d)))	      (COMMA (COMMA f)) (BACKQUOTE ((COMMA g))))   Now in order to evaluate that expression we find all forms that are   in the scope of as many COMMAs as BACKQUOTEs.  We discard the leading   BACKQUOTE and replace such expressions (along with the matching COMMAs)   with their values.  In this case, the d and f are in the scope of 2 of    each.  The result is   (BACKQUOTE a (COMMA s) (COMMA (QUOTE 4)) (COMMA 7) (BACKQUOTE ((COMMA g))))   Evaluating this would similarly give something like   (a 3 4 7 (BACKQUOTE ((COMMA g))))   If you don't believe this model is equivalent please send me a    counterexample.  (The only thing I can see won't work is if something   EVALUATES to a list containing the symbols BACKQUOTE or COMMA, and I   think we can pretend that's impossible, even though it's precisely what   I really WANTED to do!)I believe that this model can be made to work, but you need additionalrules to explain what happens when ``(a ,,@f) expands to(BACKQUOTE BACKQUOTE a (COMMA (COMMA@ f))).  At the very least youmust allow for COMMA having more than one subform.--Guy*start*02333 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 88 15:16From: jonl%lucid:COM:XeroxIn-Reply-to: Don Cohen's message of Mon, 14 Nov 88 09:11:39 PST <8811141711.AA04256@vaxa.isi.edu>Subject: nested backquotesTo: donc%vaxa.isi:EDU:Xeroxcc: greenwald%stony-brook.scrc.symbolics:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: donc@vaxa.isi.eduCc: greenwald@stony-brook.scrc.symbolics.com, common-lisp@sail.stanford.eduIn-Reply-To: Don Cohen's message of Mon, 14 Nov 88 09:11:39 PST <8811141711.AA04256@vaxa.isi.edu>Subject: nested backquotesReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 15:16:02 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 14 Nov 88  14:37:38 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00533g; Mon, 14 Nov 88 14:35:51 PSTReceived: by bhopal id AA21716g; Mon, 14 Nov 88 14:34:27 PSTOriginal-Date: Mon, 14 Nov 88 14:34:27 PSTMessage-Id: <8811142234.AA21716@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThe problem with "explanations" of backquote is that they tend to bemuch longer than the "production rules" on CLtL p.349-50.  Of course,the problem with CLtL here is opacity.The only rule I ever remember, and found quite useful, is:   "When in doubt, Hack it out."In short, after implementing the rules of CLtL rigorously, then I justtry reading (and sometimes macroexpanding) several variants of the formI'm trying to build up.  Apart from ultimately matching the depth ofnesting for commas and backquotes, I just try a lot of variations of",," ",'," ",,@" etc.  You'd be surprised how useful the "hack it out"rule is!  especially in leanring when ",'," must be used instead of ",,".One program I was writing once wound up 6 levels deep; the "hack it out"rule wasn't very helpful here, because the expression was too large.Ultimately, I wound up finding a "break point", and pulled out some ofthe code into a separate function, much as you originally did in yourfirst example with BUILD-LET-LIST.  At that point it was 4 levels and 2levels -- much more managable.-- JonL --*start*01329 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 88 21:09Subject: Re: nested backquotesIn-Reply-to: Your message of Mon, 14 Nov 88 16:46:15 -0500.             <8811142146.AA29789@joplin.think.com>From: donc%vaxa.isi:EDU:XeroxTo: gls%think:COM:Xeroxcc: greenwald%stony-brook.scrc.symbolics:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: gls@think.comCc: greenwald@stony-brook.scrc.symbolics.com, common-lisp@sail.stanford.eduSubject: Re: nested backquotesIn-Reply-To: Your message of Mon, 14 Nov 88 16:46:15 -0500.             <8811142146.AA29789@joplin.think.com>From: Don Cohen <donc@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 21:08:58 PSTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 14 Nov 88  18:17:11 PSTPosted-Date: Mon, 14 Nov 88 15:29:34 PSTMessage-Id: <8811142330.AA12027@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.59/5.51)	id AA12027; Mon, 14 Nov 88 15:30:27 PSTOriginal-Date: Mon, 14 Nov 88 15:29:34 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVNow there's a good point.  What does that mean anyhow? Please try to justify your answer.*start*02016 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 16 Nov 88 10:38From: gls%Think:COM:XeroxIn-Reply-to: Don Cohen's message of Mon, 14 Nov 88 15:29:34 PST <8811142330.AA12027@vaxa.isi.edu>Subject: nested backquotesTo: donc%vaxa.isi:EDU:Xeroxcc: gls%Think:COM:Xerox, greenwald%stony-brook.scrc.symbolics:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 NOV 88 10:38:27 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 16 Nov 88  10:03:27 PSTReceived: from fafnir.think.com by Think.COM; Wed, 16 Nov 88 12:38:56 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Wed, 16 Nov 88 13:00:27 ESTReceived: from joplin.think.com by verdi.think.com; Wed, 16 Nov 88 13:00:26 ESTReceived: by joplin.think.com; Wed, 16 Nov 88 13:00:23 ESTOriginal-Date: Wed, 16 Nov 88 13:00:23 ESTMessage-Id: <8811161800.AA00323@joplin.think.com>   Posted-Date: Mon, 14 Nov 88 15:29:34 PST   Date: Mon, 14 Nov 88 15:29:34 PST   From: Don Cohen <donc@vaxa.isi.edu>   Now there's a good point.  What does that mean anyhow?    Please try to justify your answer.Look, I've already provided a model.  You're trying to produce a newmodel.  The task is to prove that they are equivalent; in other words,that for any backquoted expression the two models provide equivalentinterpretations.  (Alternatively, where the two models produceinequivalent results, you need to argue that the first model is bogus.That would be a really interesting result!)Now, for some backquoted expressions your model produces intermediateresults in which COMMA has more than one argument form.  So you needeither to provide an interpretation in your model for such intermediateresults (i.e., new productions), or to argue that backquoted expressionsthat produce such intermediate results are not meaningful.--Guy*start*01843 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 16 Nov 88 12:35Subject: Re: nested backquotesIn-Reply-to: Your message of Wed, 16 Nov 88 13:00:23 -0500.             <8811161800.AA00323@joplin.think.com>From: donc%vaxa.isi:EDU:XeroxTo: gls%think:COM:Xeroxcc: greenwald%stony-brook.scrc.symbolics:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: gls@think.comCc: greenwald@stony-brook.scrc.symbolics.com, common-lisp@sail.stanford.eduSubject: Re: nested backquotesIn-Reply-To: Your message of Wed, 16 Nov 88 13:00:23 -0500.             <8811161800.AA00323@joplin.think.com>From: Don Cohen <donc@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 NOV 88 12:34:57 PSTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 16 Nov 88  11:58:11 PSTPosted-Date: Wed, 16 Nov 88 11:54:30 PSTMessage-Id: <8811161954.AA03714@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.59/5.51)	id AA03714; Wed, 16 Nov 88 11:54:49 PSTOriginal-Date: Wed, 16 Nov 88 11:54:30 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI agree that my model does not handle this case.I had a hard time seeing how your model does.The Greenwald explanation gives me a hint of how tointerpret CLtL.  I think what I was missing was theidea that [,,x] would be interpreted by treating theinner comma as part of the form in the outer comma,e.g., [(comma (comma x))] => (list (comma x)).Just to test my new interpretation, does this look right?(setq x '(y z))``(,@,@x) =>`(append [,@,@x] 'nil) =>`(append ,@x 'nil) =>(append [append] [,@x] ['nil] nil) =>(append (list 'append) x (list ''nil) nil)which evaluates to (APPEND Y Z 'NIL)*start*05306 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 88 10:22From: harrisr%turing.cs.rpi:EDU:XeroxSubject: Re:  backquoteTo: donc%vaxa.isi:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: harrisr@turing.cs.rpi.edu (Richard Harris)To: donc@vaxa.isi.eduSubject: Re:  backquoteCc: common-lisp@sail.stanford.eduReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 10:21:29 PSTReceived: from fs3.cs.rpi.edu by SAIL.Stanford.EDU with TCP; 11 Nov 88  09:41:30 PSTReceived: by fs3.cs.rpi.edu (5.54/1.2-RPI-CS-Dept)	id AA01710; Fri, 11 Nov 88 12:37:19 ESTOriginal-Date: Fri, 11 Nov 88 12:37:18 ESTReceived: by turing.cs.rpi.edu (4.0/1.2-RPI-CS-Dept)	id AA12520; Fri, 11 Nov 88 12:37:18 ESTMessage-Id: <8811111737.AA12520@turing.cs.rpi.edu>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI wrote some code that does this a while ago.  It is quite a bitmore complicated than Barry Margolin's solution, but you mightwant to look at it anyway.Rick Harris(defmacro once-only (vars &body body)   ;from pcl  (let ((gensym-var (gensym))        (run-time-vars (gensym))        (run-time-vals (gensym))        (expand-time-val-forms ()))        `(let* (,run-time-vars            ,run-time-vals            (wrapped-body             (let ,(mapcar #'(lambda (var)                               `(,var (if (or (symbolp ,var)                                              (constantp ,var)                                              (and (consp ,var) (eq (car ,var) 'function)))                                          ,var                                          (let ((,gensym-var (gensym)))                                            (push ,gensym-var ,run-time-vars)                                            (push ,var ,run-time-vals)                                            ,gensym-var))))                           vars)               ,@body)))       (if (null ,run-time-vars)           wrapped-body           `(let ,(mapcar #'list                          (reverse ,run-time-vars)                          (reverse ,run-time-vals))              ,wrapped-body)))))(defmacro rest-once-only (rvar &body body)  (let ((var (gensym))        (gensym-var (gensym))        (run-time-vars (gensym))        (run-time-vals (gensym))        (expand-time-val-forms ()))        `(let* (,run-time-vars            ,run-time-vals            (wrapped-body             (let ((,rvar (mapcar #'(lambda (,var)                                      (if (or (symbolp ,var)                                              (constantp ,var)                                              (and (consp ,var) (eq (car ,var) 'function)))                                           ,var                                           (let ((,gensym-var (gensym)))                                             (push ,gensym-var ,run-time-vars)                                             (push ,var ,run-time-vals)                                             ,gensym-var)))                                  ,rvar)))               ,@body)))       (if (null ,run-time-vars)           wrapped-body           `(let ,(mapcar #'list                          (reverse ,run-time-vars)                          (reverse ,run-time-vals))              ,wrapped-body)))))(defmacro define-fixnum-macro (name arg-list &body forms)  (let* ((&rest (member '&rest arg-list))         (rest-arg (and &rest (cadr &rest)))         (required-args (if &rest (ldiff arg-list &rest) arg-list)))    (if rest-arg        `(defmacro ,name ,arg-list           (once-only ,required-args             (rest-once-only ,rest-arg               `(and ,@(list ,@(mapcar #'(lambda (arg)                                         ``(typep ,,arg 'fixnum))                                     required-args))                     ,@(mapcar #'(lambda (arg)                                   `(typep ,arg 'fixnum))                               ,rest-arg)                     ,(let (,@(mapcar #'(lambda (arg)                                          `(,arg `(the fixnum ,,arg)))                                required-args)                            (,rest-arg (mapcar #'(lambda (arg)                                                   `(the fixnum ,arg))                                               ,rest-arg)))                        ,@forms)))))        `(defmacro ,name ,arg-list           (once-only ,required-args             `(and ,@(list ,@(mapcar #'(lambda (arg)                                         ``(typep ,,arg 'fixnum))                                     required-args))                   ,(let ,(mapcar #'(lambda (arg)                                      `(,arg `(the fixnum ,,arg)))                                  required-args)                      ,@forms)))))))(define-fixnum-macro fixnum-logand (&rest args)  `(logand ,@args))(define-fixnum-macro fixnum-logior (&rest args)  `(logior ,@args))(define-fixnum-macro fixnum-logxor (&rest args)  `(logxor ,@args))(define-fixnum-macro fixnum-1+ (x)  `(1+ ,x))(define-fixnum-macro fixnum-ash (x n)  `(ash ,x ,n))*start*01838 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 16 Nov 88 15:53From: gls%Think:COM:XeroxIn-Reply-to: Don Cohen's message of Wed, 16 Nov 88 11:54:30 PST <8811161954.AA03714@vaxa.isi.edu>Subject: nested backquotesTo: donc%vaxa.isi:EDU:Xeroxcc: gls%Think:COM:Xerox, greenwald%stony-brook.scrc.symbolics:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 NOV 88 15:52:52 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 16 Nov 88  15:00:23 PSTReceived: from fafnir.think.com by Think.COM; Wed, 16 Nov 88 17:35:05 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Wed, 16 Nov 88 17:56:39 ESTReceived: from joplin.think.com by verdi.think.com; Wed, 16 Nov 88 17:56:38 ESTReceived: by joplin.think.com; Wed, 16 Nov 88 17:56:34 ESTOriginal-Date: Wed, 16 Nov 88 17:56:34 ESTMessage-Id: <8811162256.AA00511@joplin.think.com>   Posted-Date: Wed, 16 Nov 88 11:54:30 PST   Date: Wed, 16 Nov 88 11:54:30 PST   From: Don Cohen <donc@vaxa.isi.edu>   I agree that my model does not handle this case.   I had a hard time seeing how your model does.   The Greenwald explanation gives me a hint of how to   interpret CLtL.  I think what I was missing was the   idea that [,,x] would be interpreted by treating the   inner comma as part of the form in the outer comma,   e.g., [(comma (comma x))] => (list (comma x)).   Just to test my new interpretation, does this look right?   (setq x '(y z))   ``(,@,@x) =>   `(append [,@,@x] 'nil) =>   `(append ,@x 'nil) =>   (append [append] [,@x] ['nil] nil) =>   (append (list 'append) x (list ''nil) nil)   which evaluates to (APPEND Y Z 'NIL)Right!*start*01133 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 18 Nov 88 03:05In-Reply-to: Michael Greenwald's message of Mon, 14 Nov 88 11:40 EST <19881114164032.1.GREENWALD@SWALLOW.SCRC.SymSubject: backquoteFrom: "jpff%maths.bath.ac.uk%NSS.Cs.Ucl.AC.UK":GV:XeroxTo: Greenwald%scrc-stony-brook:ARPA:Xeroxcc: "jonl%lucid.com%NSS.Cs.Ucl.AC.UK":GV:Xerox, Greenwald%scrc-stony-brook:ARPA:Xerox, KMP%scrc-stony-brook:ARPA:Xerox, donc%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 NOV 88 03:05:39 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 18 Nov 88  02:33:15 PSTReceived: from maths.bath.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa01665; 15 Nov 88 13:02 GMTReceived: from xenakis by mordell.maths.bath.AC.UK id aa12898;          15 Nov 88 11:41 GMTOriginal-Date: Tue, 15 Nov 88 11:40:26 GMTOK, I have tried to read the backquote material.  What is the correctmeaning of ``(,@,@x) please?==John*start*02188 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 18 Nov 88 11:13From: gls%Think:COM:XeroxIn-Reply-to: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK's message of Tue, 15 Nov 88 11:40:26 GMT <8811181010.AA11573@Subject: backquoteTo: "jpff%maths.bath.ac.uk%NSS.Cs.Ucl.AC.UK":GV:Xeroxcc: Greenwald%scrc-stony-brook:ARPA:Xerox, "jonl%lucid.com%NSS.Cs.Ucl.AC.UK":GV:Xerox, Greenwald%scrc-stony-brook:ARPA:Xerox, KMP%scrc-stony-brook:ARPA:Xerox, donc%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 NOV 88 11:13:06 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 18 Nov 88  10:41:07 PSTReceived: from fafnir.think.com by Think.COM; Fri, 18 Nov 88 13:12:41 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 18 Nov 88 13:36:17 ESTReceived: from joplin.think.com by verdi.think.com; Fri, 18 Nov 88 13:36:16 ESTReceived: by joplin.think.com; Fri, 18 Nov 88 13:36:12 ESTOriginal-Date: Fri, 18 Nov 88 13:36:12 ESTMessage-Id: <8811181836.AA01536@joplin.think.com>   Date: Tue, 15 Nov 88 11:40:26 GMT   From: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK   Sender: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK   OK, I have tried to read the backquote material.  What is the correct   meaning of ``(,@,@x) please?   ==JohnHere is a concise, if not precise, description:  `(,@q)   means     "I evaluate to a list with the list named q spliced in"  ``(,@,@x)  means   "I evaluate to an expression that, when evaluated,		      will make a list with the values of lots of		      list spliced in, where x is a list of forms		      that will evaluate to those lists"and, if you can stomach it,  ```(,@,@,@x) means "I evaluate to an expression that, when evaluated,		      produces an expression that, when evaluated,		      will make a list with the values of lots of		      list spliced in, where x is a list of forms,		      each of which will evaluate to a form that		      when evaluated will produce a list for splicing"Got that?--Guy*start*02207 00024 USaSender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 28 Nov 88 18:12From: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: inconsistency in backquote spec?To: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>Subject: inconsistency in backquote spec?To: common-lisp@sail.stanford.eduReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 NOV 88 18:09:33 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Nov 88  17:45:07 PSTReceived: from SWALLOW.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 498891; Mon 28-Nov-88 20:45:07 ESTOriginal-Date: Mon, 28 Nov 88 20:44 ESTMessage-ID: <19881129014452.7.GREENWALD@SWALLOW.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV(setq d '(a . b))'`(,@d) => `(a . b) or `(a)?If you read CLtL, pg 350. it says that it's equivalent to`(,@d . nil)which is (append [,@d] 'nil)(append d 'nil)which suggests the correct value is `(a).If you look at most implementations, and at the examples on pg 351, thenyou'd think it should be `(a . b)However, the example at the bottom of page 350 suggest alternate"legitimate interpretations" continued on the top of pg 351.  All ofthem except the first, consider (APPEND .... D NIL) to be equivalent to(APPEND ... D), which isn't true if D can be a dotted list.I tried Ibuki, Franz, Lucid, and Genera.  In all of them evaluating '`(,@'(a . b)) => `(a . b).In Ibuki and Lucid '`(,@'(a . b) ,@nil) => '([bq-]append '(a . b) nil)while in Genera and Franz '`(,@'(a . b) ,@nil) => `(a . b)Are dotted lists not allowed as values of D?  Is the spec on pg 350correct, and the examples on pg. 351 incorrect?I tend to believe the latter.  In which case, all of the readers I triedare incorrect.  I'm not going to change the Genera reader, though, untilI hear from this list, in case my brain is just wedged.  Can someoneeither deconfuse or support me?*start*05085 00024 USmSender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 29 Nov 88 11:10Subject: Re: inconsistency in backquote spec?From: Larry Masinter:PARC:XeroxIn-Reply-to: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:Xerox's message of 28 Nov 88 18:12To: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 10:57:05 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 29 Nov 88  10:35:37 PSTReceived: from Burger.ms by ArpaGateway.ms ; 29 NOV 88 10:27:42 PSTOriginal-Date: 29 Nov 88 10:23:29 PST (Tuesday)Message-ID: <881129-102742-5383@Xerox>There are two relevant cleanup proposals, one of which passed, and theother still pending. The first, called APPEND-DOTTED, clarifies thebehavior of APPEND given dotted lists. The second, which is really not firmat all,  is called BACKQUOTE-UNDERSPECIFIED, and it will attempt to specifymore precisely the behavior of backquote in terms of what parts of theexpansion get newly consed, etc.Status: PASSEDIssue:        APPEND-DOTTEDReferences:   APPEND (p268)Category:     CHANGE/CLARIFICATIONEdit history: 27-Jul-87, Version 1 by Pitman              29-Oct-87, Version 2 by Pitman (loose ends)              14-Nov-87, Version 3 by Masinter              23-Nov-87, Version 4 by Masinter              14-Jan-88, Version 5 by MasinterProblem Description:The description of APPEND on p268 is not adequately clear on the issue ofwhat happens if an argument to APPEND is a dotted list. The only caseexplicitly mentioned is the last argument, viz:"The last argument [to APPEND] actually need not be a list but may be anyLISP object, which becomes the tail end of the constructed list. Forexample, (append '(a b c) 'd) => (a b c . d)."While this specifies the behavior of APPEND when the last argument is not alist, the behavior when any of the other arguments are not lists is notspecified.Proposal (APPEND-DOTTED:REPLACE):Define that the cdr of the last cons in any but the last argument given toAPPEND or NCONC is discarded (whether NIL or not) when preparing the listto be returned.In the degenerate case where there is no last cons (i.e., the argument isNIL) in any but the last list argument, clarify that the entire argument iseffectively ignored. Point out that in this situation, if the last argumentis a non-list, the result of APPEND or NCONC can be a non-list.Remove any text which suggests that (APPEND x '()) and (COPY-LIST x) arethe same, since these two might legitimately differ in situations involvingdotted lists. As such, deciding which to use is not just a stylistic issue.Examples:(APPEND '(A B C . D) '())       => (A B C)	;Proposed(NCONC (LIST* 'A 'B 'C 'D) '()) => (A B C)	;ProposedNote that (COPY-LIST '(A B C . D)) would still return (A B C . D).(APPEND '(A B . C) '() 3)       => (A B . 3)	;Proposed(NCONC (LIST* 'A 'B 'C) '() 3)  => (A B . 3)	;Proposed(APPEND '() 17)   => 17			;Proposed(NCONC (LIST) 17) => 17			;ProposedRationale: This function is used a lot and its behavior should be well-defined acrossimplementations. This proposal upholds the apparent status quo in a numberof implementations.Current Practice:Symbolics Lisp, Vaxlisp, and Lucid Lisp appear to implement the proposedinterpretation (at least in the interpreter). Franz's Allegro Common Lispconforms to the proposed behavior except in the case of (NCONC (LIST) 17)=> 17, where it returns NIL instead of 17.Kyoto Common Lisp signal an error when using APPEND or NCONC on a dottedlist. Xerox Common Lisp signals an error on APPEND and implements theproposed interpretation on NCONC.Cost to implementors:Technically, the change should be relatively small for thoseimplementations which don't already implement it. However, implementationswhich have microcoded APPEND or NCONC incompatibly may find the smallchange somewhat painful.Some implementations may have optimized their APPEND or NCONC to expectonly NIL when SAFETY is 0. In this case, depending on implementationdetails, requiring an ATOM check rather than a NULL check may slow thingsdown.Cost to users:This change is upward compatible.Benefits:Since non-lists are allowed as a last argument and since APPEND and NCONCcan therefore produce dotted lists, some readers may have (incorrectly)assumed that APPEND and NCONC can reliably deal in general with dottedlists, something that doesn't appear to be guaranteed by a strict reading.The proposed extension would happen to legitimize such assumptions.Aesthetics:Whether or not users will think this improves the aesthetics of thelanguage will depend largely on how they view the relation between listsand dotted lists. Those who view dotted lists as a special kind of list mayfeel differently than those who view lists as a special kind of dottedlist.Discussion:The cleanup committee supports this proposal.*start*02942 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 29 Nov 88 11:18From: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: inconsistency in backquote spec?In-Reply-to: <8811290810.AA00624@bhopal>To: jonl%lucid:COM:Xerox, Greenwald%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>Subject: inconsistency in backquote spec?To: jonl@lucid.com, Greenwald@STONY-BROOK.SCRC.Symbolics.COMcc: common-lisp@sail.stanford.eduIn-Reply-To: <8811290810.AA00624@bhopal>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 11:12:21 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Nov 88  10:50:46 PSTReceived: from NOEL-COWARD.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 499350; 29 Nov 88 13:50:23 ESTOriginal-Date: Tue, 29 Nov 88 13:55 ESTMessage-ID: <19881129185543.0.GREENWALD@NOEL-COWARD.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Tue, 29 Nov 88 00:10:53 PST    From: Jon L White <jonl@lucid.com>    re: However, the example at the bottom of page 350 suggest alternate	"legitimate interpretations" continued on the top of pg 351.  All of	them except the first, consider (APPEND .... D NIL) to be equivalent to	(APPEND ... D), which isn't true if D can be a dotted list.    [This may be a question about "standard lists" more than about backquote.]    I remember some sleeping dogs about APPEND -- all arguments except the last     are required to be "lists".  Since APPEND has to copy the next to last    argument, it must cdr down to the last cell of the list; thus it should    complain about non-standard lists.  [The permission to use non-standard    lists is primarily when the operation of interest will not cdr down to    the last cell, and hence it would be a moot question.]    Long long ago, Lucid made the decision to make non-standard lists acceptable    just about everwhere that "lists" are.  Thus in Lucid Common Lisp:	 (APPEND '(A . B) NIL)  ==> (A)	 (APPEND NIL '(A . B))   ==> (A . B)I agree with this (I think there's a CL cleanup that specifies thisbehavior for APPEND and NCONC), and therefore the Lucid backquoteimplementation is inconsistent with the definition of APPEND.(setq d '(a . b))`(,@d)`(,@d . nil)(append [,@d] 'nil)(append d 'nil)(append '(a . b) 'nil)should be (a), as in your example above.However, it was (a . b) on the version I tried - I didn't try the APPENDcase itself, so maybe in a later version both were made consistent.    I can't say that I am fully happy with this; but it's very low on my    list of worries today.    -- JonL --*start*03155 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 29 Nov 88 11:58From: Greenwald%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: inconsistency in backquote spec?In-Reply-to: <8811291735.AA00711@joplin.think.com>To: gls%Think:COM:Xerox, Greenwald%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Michael Greenwald <Greenwald@STONY-BROOK.SCRC.Symbolics.COM>Subject: inconsistency in backquote spec?To: gls@Think.COM, Greenwald@STONY-BROOK.SCRC.Symbolics.COMcc: common-lisp@sail.stanford.eduIn-Reply-To: <8811291735.AA00711@joplin.think.com>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 11:57:55 PSTReceived: from SAPSUCKER.SCRC.Symbolics.COM ([128.81.41.223]) by SAIL.Stanford.EDU with TCP; 29 Nov 88  11:36:04 PSTReceived: from NOEL-COWARD.SCRC.Symbolics.COM by SAPSUCKER.SCRC.Symbolics.COM via INTERNET with SMTP id 262367; 29 Nov 88 14:02:36 ESTOriginal-Date: Tue, 29 Nov 88 14:05 ESTMessage-ID: <19881129190543.1.GREENWALD@NOEL-COWARD.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Tue, 29 Nov 88 12:35:36 EST    From: gls@Think.COM       Date: Mon, 28 Nov 88 20:44 EST       From: Michael Greenwald <Greenwald@stony-brook.scrc.symbolics.com>       (setq d '(a . b))       '`(,@d) => `(a . b) or `(a)?       If you read CLtL, pg 350. it says that it's equivalent to       `(,@d . nil)       which is        (append [,@d] 'nil)       (append d 'nil)       which suggests the correct value is `(a).       ...       Are dotted lists not allowed as values of D?  Is the spec on pg 350       correct, and the examples on pg. 351 incorrect?       I tend to believe the latter.  In which case, all of the readers I tried       are incorrect.  I'm not going to change the Genera reader, though, until       I hear from this list, in case my brain is just wedged.  Can someone       either deconfuse or support me?    You raise some good points here.  At first I was certain that the book    was not consistent, but now I have the following language lawyer's    argument:    The spec for APPEND says that all arguments but the last must be lists.    The comment about the last argument makes it clear that the others    are meant to be proper lists; see also the middle paragraph of page 27.    Therefore dotted lists are not allowed as values for D.I thought a (recent?) CL Cleanup specified that if arguments (all butthe last) to APPEND (or NCONC) were dotted lists, the non-nil final CDRwas to be ignored.  In which case, the examples on 351 are incorrect.Or, you could say that the list following a ,@ cannot be dotted.Either way, I think, requires a minor clarification in the CL spec.    The examples on page 351 are also correct.  Once you are given that    D may not be dotted, and given that the result of a backquoted    expression may or may not make copies, then the examples shown are    correct optimizations.    --Guy*start*02391 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 29 Nov 88 14:57From: gls%Think:COM:XeroxIn-Reply-to: Michael Greenwald's message of Tue, 29 Nov 88 14:05 EST <19881129190543.1.GREENWALD@NOEL-COWARD.SCRCSubject: inconsistency in backquote spec?To: Greenwald%stony-brook.scrc.symbolics:COM:Xeroxcc: gls%Think:COM:Xerox, Greenwald%stony-brook.scrc.symbolics:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 14:57:01 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 29 Nov 88  14:26:57 PSTReceived: from fafnir.think.com by Think.COM; Tue, 29 Nov 88 17:12:08 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Tue, 29 Nov 88 17:12:45 ESTReceived: from joplin.think.com by verdi.think.com; Tue, 29 Nov 88 17:11:14 ESTReceived: by joplin.think.com; Tue, 29 Nov 88 17:12:40 ESTOriginal-Date: Tue, 29 Nov 88 17:12:40 ESTMessage-Id: <8811292212.AA00825@joplin.think.com>   Date: Tue, 29 Nov 88 14:05 EST   From: Michael Greenwald <Greenwald@stony-brook.scrc.symbolics.com>       Date: Tue, 29 Nov 88 12:35:36 EST       From: gls@Think.COM       ...       You raise some good points here.  At first I was certain that the book       was not consistent, but now I have the following language lawyer's       argument:       The spec for APPEND says that all arguments but the last must be lists.       The comment about the last argument makes it clear that the others       are meant to be proper lists; see also the middle paragraph of page 27.       Therefore dotted lists are not allowed as values for D.   I thought a (recent?) CL Cleanup specified that if arguments (all but   the last) to APPEND (or NCONC) were dotted lists, the non-nil final CDR   was to be ignored.  In which case, the examples on 351 are incorrect.Because you sent the mail out to common-lisp@sail and not toany of the X3J13 mailing lists, I assumed that you were askinga question about the language as defined solely by the book.In other words, I assume that the audience for the common-lispmailing list has not necessarily followed all of the X3J13 work.It is true that eventual adoption of this cleanup item wouldinvalidate the examples.--Guy*start*02418 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 29 Nov 88 10:10From: gls%Think:COM:XeroxIn-Reply-to: Michael Greenwald's message of Mon, 28 Nov 88 20:44 EST <19881129014452.7.GREENWALD@SWALLOW.SCRC.SymSubject: inconsistency in backquote spec?To: Greenwald%stony-brook.scrc.symbolics:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 10:01:05 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 29 Nov 88  09:36:59 PSTReceived: from fafnir.think.com by Think.COM; Tue, 29 Nov 88 12:34:44 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Tue, 29 Nov 88 12:35:41 ESTReceived: from joplin.think.com by verdi.think.com; Tue, 29 Nov 88 12:34:10 ESTReceived: by joplin.think.com; Tue, 29 Nov 88 12:35:36 ESTOriginal-Date: Tue, 29 Nov 88 12:35:36 ESTMessage-Id: <8811291735.AA00711@joplin.think.com>   Date: Mon, 28 Nov 88 20:44 EST   From: Michael Greenwald <Greenwald@stony-brook.scrc.symbolics.com>   (setq d '(a . b))   '`(,@d) => `(a . b) or `(a)?   If you read CLtL, pg 350. it says that it's equivalent to   `(,@d . nil)   which is    (append [,@d] 'nil)   (append d 'nil)   which suggests the correct value is `(a).   ...   Are dotted lists not allowed as values of D?  Is the spec on pg 350   correct, and the examples on pg. 351 incorrect?   I tend to believe the latter.  In which case, all of the readers I tried   are incorrect.  I'm not going to change the Genera reader, though, until   I hear from this list, in case my brain is just wedged.  Can someone   either deconfuse or support me?You raise some good points here.  At first I was certain that the bookwas not consistent, but now I have the following language lawyer'sargument:The spec for APPEND says that all arguments but the last must be lists.The comment about the last argument makes it clear that the othersare meant to be proper lists; see also the middle paragraph of page 27.Therefore dotted lists are not allowed as values for D.The examples on page 351 are also correct.  Once you are given thatD may not be dotted, and given that the result of a backquotedexpression may or may not make copies, then the examples shown arecorrect optimizations.--Guy*start*01602 00024 US Return-Path: <boyer@CLI.COM>Received: from CLI.COM ([10.8.0.62]) by Xerox.COM ; 21 JAN 89 09:17:00 PSTReceived: by CLI.COM (4.0/1); Sat, 21 Jan 89 11:12:14 CSTDate: Sat, 21 Jan 89 11:12:14 CSTFrom: Robert S. Boyer <boyer@CLI.COM>Message-Id: <8901211712.AA17553@CLI.COM>To: masinter.paSubject: Backquote Documentation ElaborationReply-To: boyer@cli.comOn p. 349 of CLTL it states "An implementation is quite free tointerpret backquote in any way such that a backquoted form, whenevaluated, will produce a result equal to that produced by theinterpretation shown here."  It should perhaps be emphasized that thephrase ``when evaluated'' means ``when evaluated in the implementationof Common Lisp that is currently running'' rather than ``whenevaluated in any correct implementation of Common Lisp''.  Thefollowing examples on p. 350 and 351 illustrate alternative results ofbackquote reading that use standard Common Lisp functions such asAPPEND, LIST*, etc., but none that use things from, say, packageLUCID-RUNTIME-SUPPORT.Here is a function that illustrates READ treating backquotedifferently in the three Common Lisps I have at hand, using in twocases functions not defined in CLTL.(in-package "USER")(defun which-lisp ()  (let* ((sym (car (read-from-string "`(foo ,y)")))	 (package-name (package-name (symbol-package sym))))    (cond ((eq sym 'list) 'kcl)	  ((equal package-name "SYSTEM-INTERNALS")	   'symbolics)	  ((equal package-name "LUCID-RUNTIME-SUPPORT")	   ;  works in Sun/Lucid 3.0, but not in 2.1	   'lucid)	  (t 'unknown))))