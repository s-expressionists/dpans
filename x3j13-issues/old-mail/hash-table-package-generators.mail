*start*06201 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 01:23:18 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 24 May 88  01:22:16 PDTReceived: by labrea.stanford.edu; Tue, 24 May 88 01:22:41 PDTReceived: from bhopal.lucid.com by edsel id AA04507g; Tue, 24 May 88 01:10:17 PDTReceived: by bhopal id AA04704g; Tue, 24 May 88 01:14:08 PDTDate: Tue, 24 May 88 01:14:08 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805240814.AA04704@bhopal.lucid.com>To: cl-cleanup@sail.stanford.eduSubject: Issue: HASH-TABLE-PACKAGE-GENERATORSIssue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonLProblem description:The Iteration subcommittee would like the several iteration proposals to bewriteable in portable Common Lisp code.  Unfortunately, the only access tohash-tables and packages is through MAPHASH and DO-SYMBOLS, neither of whichis satisfactory for building complex iteration clauses.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-CREATOR-FUNCTIONS):Add two new functions as follows, which will create upon demand a"generator" for the table in question:    MAKE-HASH-TABLE-ITERATION-GENERATOR (hash-table)		[Function]      ;; Returns a function of no arguments, which iterates over       ;;  the entries of the argument 'hash-table' and returns three       ;;  values at each at each iteration:      ;;    1. a boolean to indicate no more entries (T says "there are more")      ;;    2. the value item (of a <key, value> pair)      ;;    3. the key item (of a <key, value> pair)      ;; If there are no more entries in the hash-table, then only one value      ;;  is returned, namely NIL.    MAKE-PACKAGE-ITERATION-GENERATOR (package iteration-type)	[Function]      ;; First argument is a package (or, a string or symbol       ;;  coercible to a package); second argument is a symbol among:      ;;      do-symbols      ;;      do-all-symbols      ;;      do-external-symbols      ;;      do-internal-symbols      ;;      do-present-symbols		{either :internal or :external}      ;; Returns a function of no arguments, which iterates over the symbols       ;;  in the argument 'package' and returns three values at each iteration:      ;;    1. a boolean to indicate no more entries (T says "there are more")      ;;    2. a symbol (available in the indicated package)      ;;    3. the availability type for that symbol, (i.e. one of      ;;       :internal, :external, or :inherited).      ;; If there are no more symbols available from the package, then only one      ;;  value is returned, namely NIL.Test Case: The following function should return T on any hash-table:(defun test-ht-generator-test (hash-table)  (let ((all-entries '())	(generated-entries '())	(generator-fn (make-hash-table-iteration-generator hash-table))	(unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))	     hash-table)    (loop 	;note -- this is the "trivial" LOOP of CLtL p121      (multiple-value-bind (more? value key) (funcall generator-fn) 	(unless more? (return))	(unless (eql value (gethash key hash-table unique))	  (error "Key ~S not found for value ~S" key value))	(push (list key value) generated-entries)))    (unless (= (length all-entries)	       (length generated-entries)	       (length (union all-entries generated-entries :test #'equal)))     (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package:(defun test-pk-generator-test (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())	(generated-entries '())	(generator-fn (make-package-iteration-generator package 'do-symbols)))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility) 		(find-symbol (symbol-name x) package)	(push (list symbol accessibility) all-entries)))    (loop 	;note -- this is the "trivial" LOOP of CLtL p121      (multiple-value-bind (more? symbol accessibility) (funcall generator-fn) 	(unless more? (return))	(let ((l (multiple-value-list (find-symbol (symbol-name symbol) 						   package))))	  (unless (equal l (list symbol accessibility))	    (error "Symbol ~S not found as ~S in package ~A [~S]"		    symbol accessibility (package-name package) l))	  (push l generated-entries))))    (unless (and (null (set-difference all-entries generated-entries				       :test #'equal))		 (null (set-difference generated-entries all-entries				       :test #'equal)))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))       Rationale:The particular way in which hash-tables and packages are representedneed not standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these generator-creator functions are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of these current primitives will provide generator functions.Current Practice:Both Symbolics and Lucid already have similar generators in theirown implementations of LOOP. Cost to Implementors:Moderate.  Possibly a couple days work for an implementation thathas to start completely afresh.Cost to Users:None.Benefits:Will provide a more primitive root for iterating over hash-tables andpackages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:This proposal was initiated by Dick Waters, who has ported his OSS iterationscheme to many Common Lisps; it was who noted that only the lack of reasonablegenerator functions prevented all three of the currently discussed iterationschemes from being truly portable extensions.The Iteration Subcommittee supports this proposal.*start*04651 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 09:08:26 PDTReceived: from JASPER.SCRC.Symbolics.COM ([128.81.41.58]) by SAIL.Stanford.EDU with TCP; 24 May 88  09:06:37 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by JASPER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 191831; Tue 24-May-88 12:05:59 EDTDate: Tue, 24 May 88 12:06 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORSTo: Jon L White <edsel!jonl@labrea.stanford.edu>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8805240814.AA04704@bhopal.lucid.com>Message-ID: <19880524160601.7.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 24 May 88 01:14:08 PDT    From: Jon L White <edsel!jonl@labrea.stanford.edu>    Problem description:    The Iteration subcommittee would like the several iteration proposals to be    writeable in portable Common Lisp code.  Unfortunately, the only access to    hash-tables and packages is through MAPHASH and DO-SYMBOLS, neither of which    is satisfactory for building complex iteration clauses.A laudable goal, but...    Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-CREATOR-FUNCTIONS):    Add two new functions as follows, which will create upon demand a    "generator" for the table in question.......this technique "can't" work, because of locking issues, especially insystems that have a garbage collector that can change the hash codes ofobjects.  You need to be able to wrap something around the whole iteration,not merely have a function that performs the next step in the iteration.    ....    Rationale:    The particular way in which hash-tables and packages are represented    need not standardized, or even exposed to the user.  Yet a simpler handle     on them is needed for the various iteration paradigms to be written in     portable code.  In fact, after these generator-creator functions are put     into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial     usages of them; but no _efficient_ use of these current primitives will     provide generator functions.You haven't brought out the major reason for using a generator function,which is so that multiple iterations can be performed in parallel.  Manyof the iteration proposals, including LOOP and OSS, allow a programmer tospecify an iteration that iterates simultaneously over the elements ofa hash table and a range of integers, or even over the elements of twohash tables.  Making the advance-to-next-state primitive available isnecessary in order to be able to call this primitive twice on two differenthash tables; no nesting of calls to MAPHASH can perform such a simultaneousiteration.    Current Practice:    Both Symbolics and Lucid already have similar generators in their    own implementations of LOOP. I don't think you've looked at Symbolics' LOOP in a couple years.  Itused to work the way you describe, but the way it works now isdifferent.  It does have a generator function, but it also wraps thewhole thing in a macro, which expands into a generic function invocationwith two arguments:  the hash table, and a closure of the body of theiteration.  There is no need for a standard function to create thegenerator, since it is simply passed to the body as an argument.  Note:the body closure is called once, and iterates inside itself; it is notcalled repeatedly, the way the functional argument to maphash is.This is for hash-tables, but packages can be treated similarly.Here's a relevant code extract:;;; table must be a hash table.;;; generator-var is bound to a generator function, which takes no arguments.;;; Each time the generator function is called, it returns the next entry of the;;; hash table, expressed as three values: the value, the key, and a flag.;;; The flag is nil if the table has been exhausted, otherwise it is the;;; next generator function to use (in all implemented cases, the generator;;; function remains constant, but this provides the flexibility to let it change).;;; When the flag is nil, the first two values are meaningless.;;; The values returned by with-table-elements are the values returned by the body.(defmacro with-table-elements ((table generator-var) &body body)  `(with-table-elements-1 ,table #'(lambda (,generator-var) ,@body)))(defgeneric with-table-elements-1 (table function)  (declare (downward-funarg function)))I have no objection to sending you more of the code if you want to see it,but I doubt that it would be illuminating.*start*04083 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 MAY 88 13:23:30 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 25 May 88  13:19:58 PDTReceived: by labrea.stanford.edu; Wed, 25 May 88 13:20:19 PDTReceived: from bhopal.lucid.com by edsel id AA12174g; Wed, 25 May 88 13:08:49 PDTReceived: by bhopal id AA01499g; Wed, 25 May 88 13:12:47 PDTDate: Wed, 25 May 88 13:12:47 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805252012.AA01499@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 24 May 88 12:06 EDT <19880524160601.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORSre:     Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-CREATOR-FUNCTIONS):	Add two new functions as follows, which will create upon demand a	"generator" for the table in question....    ...this technique "can't" work, because of locking issues, especially in    systems that have a garbage collector that can change the hash codes of    objects.  You need to be able to wrap something around the whole iteration,    not merely have a function that performs the next step in the iteration.You are probably thinking of only one of the several ways to implementEQ-type hash-tables.  Lucid has a technique that guarantees iteration overthe contents which the table had at the time the iteration function is created [this is almost always acceptable, since even maphash calls it "anerror" to alter the table while the iteration is in progress (except for the trivial exception, which works in both cases)].  At worst, this techniquecauses a copying of the hash-table upon a relocating garbage collection,or when first making an entry that would otherwise be "locked-out".  [Justto clear up a point: Lucid's implementation will normally re-order "in place"when necessary due to changing hash-codes, and do that only "lazily".]Thus there is no absolute need to provide locking for iteration.On the other hand, locking of global databases, for whatever purposes, isa laudable goal.  I still don't think it is required for iteration to workin the same cases that it works in for MAPHASH.   But if you think thatSymbolics' system will be compromised unless explicit interlocking is done during hash-table or package iteration, then perhaps the necessary thing to do is to provide context-independent locking mechanisms.  Something likethe dynamically-scoped macro 'with-table-elements', but perhaps with a broader utility?  re: You haven't brought out the major reason for using a generator function,    which is so that multiple iterations can be performed in parallel.  Well, I tried to say so in the following words:    Unfortunately, the only access to hash-tables and packages is through     MAPHASH and DO-SYMBOLS, neither of which is satisfactory for building     complex iteration clauses.but it you'd like to see "complex iteration clauses" fleshed out in more detail, then just adding the paragraph of your note would be fine, don'tyou think?re: I don't think you've looked at Symbolics' LOOP in a couple years. It    used to work the way you describe, but the way it works now is    different.  It does have a generator function, but it also wraps the ...Right, I had looked at version 6+ some time ago.Incidentally, Lucid's implementation of packages uses the same hash-tablemechanism given to the Common-Lisp user, but with a private, undocumented:type argument.  At one time, SpiceLisp had a totally independent versionof hash-tables built into their package code.  The locking issue on packagesis, to my way of thinking, much more critical than that for hash-tables in general.  But the more general solution is, of course, to provide locking mechanisms for the hash-table implementation and let the package code use those mechanisms where appropriate.-- JonL --*start*01250 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 16 SEP 88 01:56:47 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Sep 88  01:56:27 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 SEP 88 01:55:07 PDTDate: 16 Sep 88 01:55 PDTFrom: masinter.paSubject: Re: Issue: HASH-TABLE-PACKAGE-GENERATORSIn-reply-to: Jon L White <edsel!jonl@labrea.stanford.edu>'s message of Wed, 25 May 88 13:12:47 PDTTo: cl-cleanup@sail.stanford.edu, cliter@sail.stanford.eduMessage-ID: <880916-015507-3866@Xerox>There was an interesting interchange on this proposal back in May, but no goodresolution. Would someone care to review the messages and extract a revisedproposal? I think we can't ignore locking because there is a way to implementiterators without locking. Moon says "You need to be able to wrap somethingaround the whole iteration,not merely have a function that performs the next step in the iteration...."Or is this issue moot? E.g., if implementations are required to provide LOOP andOSS (even as a loadable libraries), is there any purpose served in also makingthe lowlevel mechanism visible?*start*01804 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 18 SEP 88 14:31:16 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 461308; Sun 18-Sep-88 17:31:18 EDTDate: Sun, 18 Sep 88 17:31 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: HASH-TABLE-PACKAGE-GENERATORSTo: masinter.pacc: cl-cleanup@sail.stanford.edu, cliter@sail.stanford.eduIn-Reply-To: <880916-015507-3866@Xerox>Message-ID: <19880918213119.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 16 Sep 88 01:55 PDT    From: masinter.pa@Xerox.COM    There was an interesting interchange on this proposal back in May, but no good    resolution. Would someone care to review the messages and extract a revised    proposal? I think we can't ignore locking because there is a way to implement    iterators without locking. Moon says "You need to be able to wrap something    around the whole iteration,    not merely have a function that performs the next step in the iteration...."JonL and I are having a private discussion about this.    Or is this issue moot? E.g., if implementations are required to provide LOOP and    OSS (even as a loadable libraries), is there any purpose served in also making    the lowlevel mechanism visible?Yes.  It's clear that the community is not going to agree on one singleiteration language, which makes it likely that ongoing research on waysof expressing iteration will continue.  Having a standard low-levelmechanism so that the "blessed" iteration packages can be written in aportable way, but refusing to publish its name, would be an unwarranteddeprecation of ongoing research.*start*08272 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 00:17:43 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  00:17:11 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01093g; Fri, 7 Oct 88 00:16:01 PDTReceived: by bhopal id AA07902g; Fri, 7 Oct 88 00:14:21 PDTDate: Fri, 7 Oct 88 00:14:21 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810070714.AA07902@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 2)This is revised at long last.   Moon and I agree on the new syntax.Note also that the hash-table return value sequence was changed toaccord with more peoples' expectations (i.e., <key> before <value>)-- JonL --!Issue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL	       Version 2,  6-Oct-88 JonL (convert to "with" scoping).Problem description:The Iteration subcommittee would like the several iteration proposals to bewriteable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]        Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that each invocation (<next-fn>) will return    the successive items from the hash-table which is the value of    the expression <hash-table>.  Iterating over such a form will thus     make the contents of the hash-table available one at a time.  An     invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean to indicate no more entries (T says "there are more")      ;;    2. the key item (of a <key, value> pair)      ;;    3. the value item (of a <key, value> pair)      ;; If there are no more entries in the hash-table, then only one       ;;  value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package> <type>) &body body)     [Macro]    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that each invocation (<next-fn>) will return    the successive items from the package which is the value of the    expression <package>.  Iterating over such a form will thus make the    contents of the package available one at a time.  The <type> argument    may assume any of the following values, indicating  the sort of     symbols wanted:            DO-SYMBOLS			;any available symbol            DO-EXTERNAL-SYMBOLS		;just the :external symbols            DO-INTERNAL-SYMBOLS		;just the :internal symbols            DO-PRESENT-SYMBOLS		;both :internal and :external symbols            DO-ALL-SYMBOLS		;all symbols;    When <type> evaluates to DO-ALL-SYMBOLS, the <package> argument is    ignored.   An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean to indicate no more entries (T says "there are more")      ;;    2. a symbol (available in the indicated package)      ;;    3. the availability type for that symbol, (i.e. one of      ;;       :INTERNAL, :EXTERNAL, or :INHERITED).      ;; If there are no more symbols available from the package, then only       ;;  one value is returned, namely NIL.There is no guarantee that any state implicit in the invocation of the form (<next-fn>) will survive outside the scope of the WITH-... form.Test-case:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-ht-generator-test (hash-table)  (let ((all-entries '())	(generated-entries '())	(unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))	     hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? key value) (generator-fn)	  (unless more? (return))	  (unless (eql value (gethash key hash-table unique))	    (error "Key ~S not found for value ~S" key value))	  (push (list key value) generated-entries))))    (unless (= (length all-entries)	       (length generated-entries)	       (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-pk-generator-test (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())	(generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility) 		(find-symbol (symbol-name x) package)	(push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package 'do-symbols)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? symbol accessibility) (generator-fn)	  (unless more? (return))	  (let ((l (multiple-value-list (find-symbol (symbol-name symbol) 						     package))))	    (unless (equal l (list symbol accessibility))	      (error "Symbol ~S not found as ~S in package ~A [~S]"		     symbol accessibility (package-name package) l))	    (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)		 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))       Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.*start*03261 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 11:02:45 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  11:02:36 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472615; Fri 7-Oct-88 14:00:33 EDTDate: Fri, 7 Oct 88 14:00 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 2)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8810070714.AA07902@bhopal>Message-ID: <19881007180006.0.MOON@EUPHRATES.SCRC.Symbolics.COM>I favor this for the most part, but it needs some corrections.I hope you get this mail before Monday, as I won't be at the meeting.    There is no guarantee that any state implicit in the invocation of the     form (<next-fn>) will survive outside the scope of the WITH-... form.The word "scope" here is a typo for "extent".  In addition, it's hard tofigure out what this means, since it does not use the standardterminology for describing exceptions.  Why not say, "It is an error toevaluate the form (<next-fn>) outside the dynamic extent of the body ofthe WITH-... form"?Clarify that <hash-table>, <package>, and <type> are only evaluated once.The phrase `a boolean to indicate no more entries (T says "there are more")'used in the description of the first value of the generator can beinterpreted ambiguously.  The example makes it clear that the value returnedfor the last hash-table or package entry is T, but a reader could thinkthat the intention was that NIL is returned with the last entry.  Perhapsthis could be rephrased in terms of the validity of the second and thirdvalues?  Or in words such as "it either returns T and an entry, or NILwhen all entries have already been returned."The syntax of WITH-PACKAGE-ITERATOR is rather baroque.  It has an optionalsubform (<package>) preceding a required subform (<type>), and it usesnon-keyword symbols as flags, of which three are in the LISP package andtwo are not.  Here's a possible alternative that I think is cleaner:  WITH-PACKAGE-ITERATOR ((<next-fn> <type> &optional <package>) &body body)     [Macro]  Within the lexical scope of 'body', the name <next-fn> is defined  via MACROLET such that each invocation (<next-fn>) will return  the successive items from the package which is the value of the  expression <package>.  Iterating over such a form will thus make the  contents of the package available one at a time.  The <type> argument  may assume any of the following values, indicating the sort of   symbols wanted:	  :ACCESSIBLE		;all symbols present or inherited	  :PRESENT		;all symbols present in the package          :EXTERNAL		;all symbols exported by the package	  :INTERNAL		;all symbols present and not exported	  :ALL			;all symbols in all packages  <package> is required unless <type> evaluates to :ALL, then <package>  can be omitted.One could debate the set of types provided, e.g. removing :INTERNALor adding :INHERITED.  I don't care about that.*start*04002 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 16:40:57 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  16:40:48 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00842g; Fri, 7 Oct 88 16:39:32 PDTReceived: by bhopal id AA02095g; Fri, 7 Oct 88 16:37:53 PDTDate: Fri, 7 Oct 88 16:37:53 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810072337.AA02095@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 7 Oct 88 14:00 EDT <19881007180006.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 2)I'll make another version of this proposal before Larry's ultimate deadline;but first I'd like to see if there are any other reactions to thesecomments.re:     There is no guarantee that any state implicit in the invocation of the 	form (<next-fn>) will survive outside the scope of the WITH-... form.    The word "scope" here is a typo for "extent".  In addition, it's hard to    figure out what this means, since it does not use the standard    terminology for describing exceptions.  Why not say, "It is an error to    evaluate the form (<next-fn>) outside the dynamic extent of the body of    the WITH-... form"?Both "scope" and "extent" are involved here -- the form  (<next-fn>)  isdefined only within the scope, and any objects which it may create havevalidity only within the "extent" of the WITH-...  The reason I don'twant to use "It is an error ..." to describe the "extent" constraint is that the buzz phrase "It is unspecified" (from the "new" error terminology) is more appropriate here.  Implementations which don't use the Symbolics style "locking" might actually provide indefinite extent so that the Generators proposal will not be limited.re: Clarify that <hash-table>, <package>, and <type> are only evaluated once.Right.re: The phrase `a boolean to indicate no more entries (T says "there are more")    used in the description of the first value of the generator can be    interpreted ambiguously.  ... this could be rephrased ... "it either     returns T and an entry, or NIL when all entries have already been returned"Sounds good.re: The syntax of WITH-PACKAGE-ITERATOR is rather baroque.  It has an optional    subform (<package>) preceding a required subform (<type>), Yea, I didn't like that either.  An &optional is fine with me; Mlynarikeven suggested &key parameters.								and it uses    non-keyword symbols as flags, of which three are in the LISP package and    two are not.  Here's a possible alternative that I think is cleaner:I used exactly the names of the (extended) CLtL macros for iteration overpackages; e.g.,   (defmacro do-external-symbols ((var &optional pkg result) &body body)    `(with-package-iterator (next ,pkg 'do-external-symbols)       ,@body)The uniformity of implementing the DO-mumble-SYMBOLS seemed like a nicemnemonic for "flag" choices; unfortunately, it appears that no one ever submitted the DO-PRESENT-SYMBOLS proposal, so that is why one is not in the Lisp package.  But it's no big thing, so I'll opt for keyword "flags"if it will help acceptance of the proposal.re:	  :ACCESSIBLE		;all symbols present or inherited	  :PRESENT		;all symbols present in the package          :EXTERNAL		;all symbols exported by the package	  :INTERNAL		;all symbols present and not exported	  :ALL			;all symbols in all packagesI might mention that Lucid's implementation has certain optimizationssuch that doing the :EXTERNAL case is not at all performance-wiseequivalent to simpely doing the :PRESENT case and filtering out the internals.  Since it just may be that other implmenetations have similarassymetries about the :INHERITED case, we should add it for completeness.-- JonL --*start*02816 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 20:18:50 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  20:18:53 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472984; Fri 7-Oct-88 21:50:18 EDTDate: Fri, 7 Oct 88 21:50 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 2)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8810072337.AA02095@bhopal>Message-ID: <19881008015000.9.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 7 Oct 88 16:37:53 PDT    From: Jon L White <jonl@lucid.com>    I'll make another version of this proposal before Larry's ultimate deadline;    but first I'd like to see if there are any other reactions to these    comments.    re:     There is no guarantee that any state implicit in the invocation of the 	    form (<next-fn>) will survive outside the scope of the WITH-... form.	The word "scope" here is a typo for "extent".  In addition, it's hard to	figure out what this means, since it does not use the standard	terminology for describing exceptions.  Why not say, "It is an error to	evaluate the form (<next-fn>) outside the dynamic extent of the body of	the WITH-... form"?    Both "scope" and "extent" are involved here -- the form  (<next-fn>)  is    defined only within the scope, and any objects which it may create have    validity only within the "extent" of the WITH-...  The reason I don't    want to use "It is an error ..." to describe the "extent" constraint     is that the buzz phrase "It is unspecified" (from the "new" error     terminology) is more appropriate here.  Implementations which don't use     the Symbolics style "locking" might actually provide indefinite extent     so that the Generators proposal will not be limited.I haven't gotten myself up to date on the new exception terminology yet,not being on the editorial committee.  I think you don't think "is an error"means the same thing that I think it means, but "unspecified" is okay with me.I hope the new exception terminology doesn't use words with legal forcesuch as "guarantee."    re: The syntax of WITH-PACKAGE-ITERATOR is rather baroque.  It has an optional	subform (<package>) preceding a required subform (<type>),     Yea, I didn't like that either.  An &optional is fine with me; Mlynarik    even suggested &key parameters.That might be a good idea, then :INTERNAL and :EXTERNAL and :INHERITEDcan be specified independently.  I haven't thought about it for morethan five seconds.*start*10296 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 21:28:36 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  21:28:26 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01220g; Fri, 7 Oct 88 21:27:13 PDTReceived: by bhopal id AA03150g; Fri, 7 Oct 88 21:25:34 PDTDate: Fri, 7 Oct 88 21:25:34 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080425.AA03150@bhopal>To: cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Fri, 7 Oct 88 00:14:21 PDT <8810070714.AA07902@bhopal>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 3)I've altered the syntax of with-package-iterator after seeing a suggestionfrom Richard Mlynarik; also I've clarified a few wordings as per moon'srecent mail.  And finally, I've added another example.-- JonL --!Issue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL	       Version 2,  6-Oct-88 JonL (convert to "with" scoping).	       Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)Problem description:The Iteration subcommittee would like the several iteration proposals to bewriteable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]        Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the hash-table which is obtained     by evaluating <hash-table> [only once].    An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. the key item (of a <key, value> pair)      ;;    3. the value item (of a <key, value> pair)      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package>                         [Macro]                            &key external internal inherited)                           &body body)    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the package which is obtained     by evaluating <package> [only once].      An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. a symbol (available in the indicated package)      ;;    3. the availability type for that symbol; i.e. one of      ;;       :INTERNAL, :EXTERNAL, or :INHERITED,  or unspecified for       ;;       the DO-ALL-SYMBOLS case.      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    The keyword arguments are flags indicating which kinds of symbols are     wanted; they are not "evaluated".  The following combinations are     recognized:    +----------+----------+-------------+--------------------------------------    | external | internal | inherited   |   CLtL macro equivalent     +----------+----------+-------------+-------------------------------------    |    T     |    T     |     T       |    DO-SYMBOLS    |    T     |    T     |    NIL      |    DO-PRESENT-SYMBOLS      [not CLtL]    |    T     |   NIL    |     T       |    <none> 		  [unspecified]    |    T     |   NIL    |    NIL      |    DO-EXTERNAL-SYMBOLS    |   NIL    |    T     |     T       |    <none> 		  [unspecified]    |   NIL    |    T     |    NIL      |    DO-INTERNAL-SYMBOLS     [not CLtL]    |   NIL    |   NIL    |     T       |    DO-INHERITED-SYMBOLS    [not CLtL]    |   NIL    |   NIL    |    NIL      |    DO-ALL-SYMBOLS    +----------+----------+-------------+--------------------------------------    In the default case, equivalent to DO-ALL-SYMBOLS, the value of the    <package> argument is ignored.  The lines marked "[not CLtL]" mention    package iterator macros found in some implementations of Common Lisp;    their meaning should be self-explanatory.  The lines marked "unspecified"     may be extended by an implementation to have the implied meaning.    In accord with common practice, the options that include "inherited"    symbols, and the DO-ALL-SYMBOLS option, are allowed to present the     same symbol multiple times.  This is because a symbol may be "inherited"    from several different used packages; and a symbol may be present in     several different packages (in the DO-ALL-SYMBOLS case).It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the WITH-...form (such as by returning some closure over the invocation form).Test-case:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-hash-table-iterator (hash-table)  (let ((all-entries '())	(generated-entries '())	(unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))	     hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? key value) (generator-fn)	  (unless more? (return))	  (unless (eql value (gethash key hash-table unique))	    (error "Key ~S not found for value ~S" key value))	  (push (list key value) generated-entries))))    (unless (= (length all-entries)	       (length generated-entries)	       (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-package-iterator (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())	(generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility) 		(find-symbol (symbol-name x) package)	(push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package 			     :internal t :external t :inherited t)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? symbol accessibility) (generator-fn)	  (unless more? (return))	  (let ((l (multiple-value-list (find-symbol (symbol-name symbol) 						     package))))	    (unless (equal l (list symbol accessibility))	      (error "Symbol ~S not found as ~S in package ~A [~S]"		     symbol accessibility (package-name package) l))	    (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)		 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))The following functions prints out every interned symbol:(defun print-all-symbols ()   (with-package-iterator (next-symbol nil)    (print (next-symbol))))       Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.  Something like this is already beingdone by the standard package macros [CLtL, p187].Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.Of course, if an implementation _can_ support an indefinite extent fora "generator" object returned out of the iterator forms, it is allowed to do so by this proposal.*start*10296 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 21:28:36 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  21:28:26 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01220g; Fri, 7 Oct 88 21:27:13 PDTReceived: by bhopal id AA03150g; Fri, 7 Oct 88 21:25:34 PDTDate: Fri, 7 Oct 88 21:25:34 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080425.AA03150@bhopal>To: cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Fri, 7 Oct 88 00:14:21 PDT <8810070714.AA07902@bhopal>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 3)I've altered the syntax of with-package-iterator after seeing a suggestionfrom Richard Mlynarik; also I've clarified a few wordings as per moon'srecent mail.  And finally, I've added another example.-- JonL --!Issue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL	       Version 2,  6-Oct-88 JonL (convert to "with" scoping).	       Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)Problem description:The Iteration subcommittee would like the several iteration proposals to bewriteable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]        Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the hash-table which is obtained     by evaluating <hash-table> [only once].    An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. the key item (of a <key, value> pair)      ;;    3. the value item (of a <key, value> pair)      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package>                         [Macro]                            &key external internal inherited)                           &body body)    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the package which is obtained     by evaluating <package> [only once].      An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. a symbol (available in the indicated package)      ;;    3. the availability type for that symbol; i.e. one of      ;;       :INTERNAL, :EXTERNAL, or :INHERITED,  or unspecified for       ;;       the DO-ALL-SYMBOLS case.      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    The keyword arguments are flags indicating which kinds of symbols are     wanted; they are not "evaluated".  The following combinations are     recognized:    +----------+----------+-------------+--------------------------------------    | external | internal | inherited   |   CLtL macro equivalent     +----------+----------+-------------+-------------------------------------    |    T     |    T     |     T       |    DO-SYMBOLS    |    T     |    T     |    NIL      |    DO-PRESENT-SYMBOLS      [not CLtL]    |    T     |   NIL    |     T       |    <none> 		  [unspecified]    |    T     |   NIL    |    NIL      |    DO-EXTERNAL-SYMBOLS    |   NIL    |    T     |     T       |    <none> 		  [unspecified]    |   NIL    |    T     |    NIL      |    DO-INTERNAL-SYMBOLS     [not CLtL]    |   NIL    |   NIL    |     T       |    DO-INHERITED-SYMBOLS    [not CLtL]    |   NIL    |   NIL    |    NIL      |    DO-ALL-SYMBOLS    +----------+----------+-------------+--------------------------------------    In the default case, equivalent to DO-ALL-SYMBOLS, the value of the    <package> argument is ignored.  The lines marked "[not CLtL]" mention    package iterator macros found in some implementations of Common Lisp;    their meaning should be self-explanatory.  The lines marked "unspecified"     may be extended by an implementation to have the implied meaning.    In accord with common practice, the options that include "inherited"    symbols, and the DO-ALL-SYMBOLS option, are allowed to present the     same symbol multiple times.  This is because a symbol may be "inherited"    from several different used packages; and a symbol may be present in     several different packages (in the DO-ALL-SYMBOLS case).It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the WITH-...form (such as by returning some closure over the invocation form).Test-case:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-hash-table-iterator (hash-table)  (let ((all-entries '())	(generated-entries '())	(unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))	     hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? key value) (generator-fn)	  (unless more? (return))	  (unless (eql value (gethash key hash-table unique))	    (error "Key ~S not found for value ~S" key value))	  (push (list key value) generated-entries))))    (unless (= (length all-entries)	       (length generated-entries)	       (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-package-iterator (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())	(generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility) 		(find-symbol (symbol-name x) package)	(push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package 			     :internal t :external t :inherited t)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? symbol accessibility) (generator-fn)	  (unless more? (return))	  (let ((l (multiple-value-list (find-symbol (symbol-name symbol) 						     package))))	    (unless (equal l (list symbol accessibility))	      (error "Symbol ~S not found as ~S in package ~A [~S]"		     symbol accessibility (package-name package) l))	    (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)		 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))The following functions prints out every interned symbol:(defun print-all-symbols ()   (with-package-iterator (next-symbol nil)    (print (next-symbol))))       Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.  Something like this is already beingdone by the standard package macros [CLtL, p187].Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.Of course, if an implementation _can_ support an indefinite extent fora "generator" object returned out of the iterator forms, it is allowed to do so by this proposal.*start*09608 00024 UU?Date:  8 Oct 88 17:38 PDTSender: masinter.paSubject: DRAFT Issue: HASH-TABLE-PACKAGE-GENERATORS (version 3)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL	       Version 2,  6-Oct-88 JonL (convert to "with" scoping).	       Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)Problem description:The Iteration subcommittee would like the several iteration proposals to bewriteable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]        Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the hash-table which is obtained     by evaluating <hash-table> [only once].    An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. the key item (of a <key, value> pair)      ;;    3. the value item (of a <key, value> pair)      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package>                         [Macro]                            &key external internal inherited)                           &body body)    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the package which is obtained     by evaluating <package> [only once].      An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. a symbol (available in the indicated package)      ;;    3. the availability type for that symbol; i.e. one of      ;;       :INTERNAL, :EXTERNAL, or :INHERITED,  or unspecified for       ;;       the DO-ALL-SYMBOLS case.      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    The keyword arguments are flags indicating which kinds of symbols are     wanted; they are not "evaluated".  The following combinations are     recognized:    +----------+----------+-------------+--------------------------------------    | external | internal | inherited   |   CLtL macro equivalent     +----------+----------+-------------+-------------------------------------    |    T     |    T     |     T       |    DO-SYMBOLS    |    T     |    T     |    NIL      |    DO-PRESENT-SYMBOLS      [not CLtL]    |    T     |   NIL    |     T       |    <none> 		  [unspecified]    |    T     |   NIL    |    NIL      |    DO-EXTERNAL-SYMBOLS    |   NIL    |    T     |     T       |    <none> 		  [unspecified]    |   NIL    |    T     |    NIL      |    DO-INTERNAL-SYMBOLS     [not CLtL]    |   NIL    |   NIL    |     T       |    DO-INHERITED-SYMBOLS    [not CLtL]    |   NIL    |   NIL    |    NIL      |    DO-ALL-SYMBOLS    +----------+----------+-------------+--------------------------------------    In the default case, equivalent to DO-ALL-SYMBOLS, the value of the    <package> argument is ignored.  The lines marked "[not CLtL]" mention    package iterator macros found in some implementations of Common Lisp;    their meaning should be self-explanatory.  The lines marked "unspecified"     may be extended by an implementation to have the implied meaning.    In accord with common practice, the options that include "inherited"    symbols, and the DO-ALL-SYMBOLS option, are allowed to present the     same symbol multiple times.  This is because a symbol may be "inherited"    from several different used packages; and a symbol may be present in     several different packages (in the DO-ALL-SYMBOLS case).It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the WITH-...form (such as by returning some closure over the invocation form).Test-case:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-hash-table-iterator (hash-table)  (let ((all-entries '())	(generated-entries '())	(unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))	     hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? key value) (generator-fn)	  (unless more? (return))	  (unless (eql value (gethash key hash-table unique))	    (error "Key ~S not found for value ~S" key value))	  (push (list key value) generated-entries))))    (unless (= (length all-entries)	       (length generated-entries)	       (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-package-iterator (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())	(generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility) 		(find-symbol (symbol-name x) package)	(push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package 			     :internal t :external t :inherited t)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? symbol accessibility) (generator-fn)	  (unless more? (return))	  (let ((l (multiple-value-list (find-symbol (symbol-name symbol) 						     package))))	    (unless (equal l (list symbol accessibility))	      (error "Symbol ~S not found as ~S in package ~A [~S]"		     symbol accessibility (package-name package) l))	    (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)		 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))The following functions prints out every interned symbol:(defun print-all-symbols ()   (with-package-iterator (next-symbol nil)    (print (next-symbol))))       Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.  Something like this is already beingdone by the standard package macros [CLtL, p187].Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.Of course, if an implementation _can_ support an indefinite extent fora "generator" object returned out of the iterator forms, it is allowed to do so by this proposal.*start*09932 00024 UU?Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 18:01:57 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  17:41:35 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 08 OCT 88 17:38:18 PDTDate: 8 Oct 88 17:38 PDTSender: masinter.paSubject: DRAFT Issue: HASH-TABLE-PACKAGE-GENERATORS (version 3)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-173818-2382@Xerox>!Issue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL	       Version 2,  6-Oct-88 JonL (convert to "with" scoping).	       Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)Problem description:The Iteration subcommittee would like the several iteration proposals to bewriteable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]        Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the hash-table which is obtained     by evaluating <hash-table> [only once].    An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. the key item (of a <key, value> pair)      ;;    3. the value item (of a <key, value> pair)      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package>                         [Macro]                            &key external internal inherited)                           &body body)    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the package which is obtained     by evaluating <package> [only once].      An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. a symbol (available in the indicated package)      ;;    3. the availability type for that symbol; i.e. one of      ;;       :INTERNAL, :EXTERNAL, or :INHERITED,  or unspecified for       ;;       the DO-ALL-SYMBOLS case.      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    The keyword arguments are flags indicating which kinds of symbols are     wanted; they are not "evaluated".  The following combinations are     recognized:    +----------+----------+-------------+--------------------------------------    | external | internal | inherited   |   CLtL macro equivalent     +----------+----------+-------------+-------------------------------------    |    T     |    T     |     T       |    DO-SYMBOLS    |    T     |    T     |    NIL      |    DO-PRESENT-SYMBOLS      [not CLtL]    |    T     |   NIL    |     T       |    <none> 		  [unspecified]    |    T     |   NIL    |    NIL      |    DO-EXTERNAL-SYMBOLS    |   NIL    |    T     |     T       |    <none> 		  [unspecified]    |   NIL    |    T     |    NIL      |    DO-INTERNAL-SYMBOLS     [not CLtL]    |   NIL    |   NIL    |     T       |    DO-INHERITED-SYMBOLS    [not CLtL]    |   NIL    |   NIL    |    NIL      |    DO-ALL-SYMBOLS    +----------+----------+-------------+--------------------------------------    In the default case, equivalent to DO-ALL-SYMBOLS, the value of the    <package> argument is ignored.  The lines marked "[not CLtL]" mention    package iterator macros found in some implementations of Common Lisp;    their meaning should be self-explanatory.  The lines marked "unspecified"     may be extended by an implementation to have the implied meaning.    In accord with common practice, the options that include "inherited"    symbols, and the DO-ALL-SYMBOLS option, are allowed to present the     same symbol multiple times.  This is because a symbol may be "inherited"    from several different used packages; and a symbol may be present in     several different packages (in the DO-ALL-SYMBOLS case).It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the WITH-...form (such as by returning some closure over the invocation form).Test-case:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-hash-table-iterator (hash-table)  (let ((all-entries '())	(generated-entries '())	(unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))	     hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? key value) (generator-fn)	  (unless more? (return))	  (unless (eql value (gethash key hash-table unique))	    (error "Key ~S not found for value ~S" key value))	  (push (list key value) generated-entries))))    (unless (= (length all-entries)	       (length generated-entries)	       (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-package-iterator (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())	(generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility) 		(find-symbol (symbol-name x) package)	(push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package 			     :internal t :external t :inherited t)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? symbol accessibility) (generator-fn)	  (unless more? (return))	  (let ((l (multiple-value-list (find-symbol (symbol-name symbol) 						     package))))	    (unless (equal l (list symbol accessibility))	      (error "Symbol ~S not found as ~S in package ~A [~S]"		     symbol accessibility (package-name package) l))	    (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)		 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))The following functions prints out every interned symbol:(defun print-all-symbols ()   (with-package-iterator (next-symbol nil)    (print (next-symbol))))       Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.  Something like this is already beingdone by the standard package macros [CLtL, p187].Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.Of course, if an implementation _can_ support an indefinite extent fora "generator" object returned out of the iterator forms, it is allowed to do so by this proposal.*start*01653 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 23:47:13 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 8 Oct 88  23:47:40 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 473524; Sun 9-Oct-88 02:46:12 EDTDate: Sun, 9 Oct 88 02:45 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: DRAFT Issue: HASH-TABLE-PACKAGE-GENERATORS (version 3)To: JonL@Lucid.COMcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881008-173818-2382@Xerox>Message-ID: <881009024557.1.KMP@BOBOLINK.SCRC.Symbolics.COM>I didn't find your Proposal section to be clear on whether thebody was naturally iterated or whether you had to do your owniteration. I assumed the latter, but it should be made clearer.The following example you gave makes things very muddy:    The following functions prints out every interned symbol:    (defun print-all-symbols ()       (with-package-iterator (next-symbol nil)	(print (next-symbol))))The problem this caused me is: - This doesn't iterate. I assume it just prints one thing and exits. - NEXT-SYMBOL is supposed to return a boolean value as its primary   value. That means this will print a lot of T's, no?Why not make the first value returned be something useful. I suggestit should be the hash-key for hash-tables and the symbol for packages.The second value should be the hash-value or the status, and the lastvalue should be the valid-p info.*start*01140 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 OCT 88 10:07:21 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Oct 88  10:07:24 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 474104; Tue 11-Oct-88 13:05:21 EDTDate: Tue, 11 Oct 88 13:05 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 3)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8810080425.AA03150@bhopal>Message-ID: <19881011170501.9.MOON@EUPHRATES.SCRC.Symbolics.COM>As Kent pointed out, the new example doesn't make any sense.  AlsoI still think the with-package-iterator syntax isn't right.  The wayyou have it now, there is a required argument <package> which bydefault is ignored!  Richard's idea of using keyword arguments isa good one, but something is still a little bit off.  I think everythingelse is okay.*start*01247 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 07:25:51 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 13 Oct 88  07:25:58 PDTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 13 Oct 88 10:23:36 EDTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 13 Oct 88 10:22:43 EDTDate: Thu, 13 Oct 88 10:23 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: DRAFT Issue: HASH-TABLE-PACKAGE-GENERATORS (version 3)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881008-173818-2382@Xerox>Message-Id: <19881013142325.5.BARMAR@OCCAM.THINK.COM>    Date: 8 Oct 88 17:38 PDT    From: cl-cleanup@sail.stanford.edu    The following functions prints out every interned symbol:    (defun print-all-symbols ()       (with-package-iterator (next-symbol nil)	(print (next-symbol))))This example is incorrect.  It should be:(defun print-all-symbols ()   (with-package-iterator (next-symbol nil)    (loop      (multiple-value-bind (more? symbol) (next-symbol)	(if more? (next-symbol)	    (return))))))                                                barmar*start*01197 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 OCT 88 16:37:46 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 17 Oct 88  16:36:37 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA05372g; Mon, 17 Oct 88 16:36:33 PDTReceived: by bhopal id AA04724g; Mon, 17 Oct 88 16:34:59 PDTDate: Mon, 17 Oct 88 16:34:59 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810172334.AA04724@bhopal>To: barmar@Think.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Barry Margolin's message of Thu, 13 Oct 88 10:23 EDT <19881013142325.5.BARMAR@OCCAM.THINK.COM>Subject: DRAFT Issue: HASH-TABLE-PACKAGE-GENERATORS (version 3)re: This example is incorrect.  It should be: . . .Right, the 'print-all-symbols' example was prematurely "printed".   Yourrewrite of it was almost correct; it should be(defun print-all-symbols ()   (with-package-iterator (next-symbol nil)    (loop      (multiple-value-bind (more? symbol) (next-symbol)	(if more?            (print symbol)				<<---	   (return))))))I'll fix up the proposal "shortly".-- JonL --*start*01835 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 OCT 88 16:48:12 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 17 Oct 88  16:46:56 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA05400g; Mon, 17 Oct 88 16:46:46 PDTReceived: by bhopal id AA04777g; Mon, 17 Oct 88 16:45:13 PDTDate: Mon, 17 Oct 88 16:45:13 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810172345.AA04777@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 11 Oct 88 13:05 EDT <19881011170501.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 3)re: I still think the with-package-iterator syntax isn't right.  The way    you have it now, there is a required argument <package> which by    default is ignored! The only time the <package> argument is ignored is when the other argumentsimply DO-ALL-SYMBOLS.  MLY's original suggestion (to me, privately) was to have the <package> argument be optional; that would work too, and make for abit nicer syntax in the one case of DO-ALL-SYMBOLS.  Richard [MLY] actuallysuggested dropping the DO-ALL-SYMBOLS case, but I don't think we can do that.However, there is a constraint that isn't easy to express in the existing CL language: namely, that the <package> argument is required if any of the other keyword arguments are supplied as non-nil.  One way out of this bind is to let the &optional <package> argument default to the symbol *PACKAGE*; this way, there would be no problem of syntax consistency, but only that of remembering that, in the DO-ALL-SYMBOLS case, passing the optional argumentdoesn't do anything.-- JonL --*start*11418 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 10:36:22 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 10 Nov 88  10:34:32 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03352g; Thu, 10 Nov 88 10:33:20 PSTReceived: by bhopal id AA05895g; Thu, 10 Nov 88 10:32:01 PSTDate: Thu, 10 Nov 88 10:32:01 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811101832.AA05895@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)Final nits:    <KMP@STONY-BROOK.SCRC.Symbolics.COM>: Sun, 9 Oct 88 02:45 EDT    <barmar@Think.COM> Thu, 13 Oct 88 10:23 EDT    <jonl@LUCID.COM> Mon, 17 Oct 88 16:45:13 PDTand dded discussion about syntax of with-package-iterator.-- JonL --!Issue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Issue: DO-SYMBOLS-DUPLICATES Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL	       Version 2,  6-Oct-88 JonL (convert to "with" scoping).	       Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)	       Version 4,  8-Nov-88 JonL (fix example; clarify some nits)Problem description:The Iteration subcommittee would like the several iteration proposals to bewriteable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]        Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the hash-table which is obtained     by evaluating <hash-table> [only once].    An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. the key item (of a <key, value> pair)      ;;    3. the value item (of a <key, value> pair)      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package>                         [Macro]                            &key external internal inherited)                           &body body)    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the package which is obtained     by evaluating <package> [only once].      An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. a symbol (available in the indicated package)      ;;    3. the availability type for that symbol; i.e. one of      ;;       :INTERNAL, :EXTERNAL, or :INHERITED,  or unspecified for       ;;       the DO-ALL-SYMBOLS case.      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    The keyword arguments are flags indicating which kinds of symbols are     wanted; they are not "evaluated".  The following combinations are     recognized:    +----------+----------+-------------+-------------------------------------    | external | internal | inherited   |   CLtL macro equivalent     +----------+----------+-------------+-------------------------------------    |    T     |    T     |     T       |    DO-SYMBOLS    |    T     |    T     |    NIL      |    DO-PRESENT-SYMBOLS      [not CLtL]    |    T     |   NIL    |     T       |    <none> 		  [unspecified]    |    T     |   NIL    |    NIL      |    DO-EXTERNAL-SYMBOLS    |   NIL    |    T     |     T       |    <none> 		  [unspecified]    |   NIL    |    T     |    NIL      |    DO-INTERNAL-SYMBOLS     [not CLtL]    |   NIL    |   NIL    |     T       |    DO-INHERITED-SYMBOLS    [not CLtL]    |   NIL    |   NIL    |    NIL      |    DO-ALL-SYMBOLS    +----------+----------+-------------+--------------------------------------    In the default case, equivalent to DO-ALL-SYMBOLS, the value of the    <package> argument is ignored.  The lines marked "[not CLtL]" mention    package iterator macros found in some implementations of Common Lisp;    their meaning should be self-explanatory.  The lines marked "unspecified"     may be extended by an implementation to have the implied meaning.    In accord with common practice, the options that include any "inherited"    symbols, and the DO-ALL-SYMBOLS option, are allowed to present the     same symbol multiple times.  This is because a symbol may be "inherited"    from several different used packages; and a symbol may be present in     several different packages (in the DO-ALL-SYMBOLS case).  See the     proposal DO-SYMBOLS-DUPLICATES:ALLOWED.It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the WITH-...form (such as by returning some closure over the invocation form).Test-case:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-hash-table-iterator (hash-table)  (let ((all-entries '())	(generated-entries '())	(unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))	     hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? key value) (generator-fn)	  (unless more? (return))	  (unless (eql value (gethash key hash-table unique))	    (error "Key ~S not found for value ~S" key value))	  (push (list key value) generated-entries))))    (unless (= (length all-entries)	       (length generated-entries)	       (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-package-iterator (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())	(generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility) 		(find-symbol (symbol-name x) package)	(push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package 			     :internal t :external t :inherited t)      (loop 		;;Note -- this is the "trivial" LOOP of CLtL p121	(multiple-value-bind (more? symbol accessibility) (generator-fn)	  (unless more? (return))	  (let ((l (multiple-value-list (find-symbol (symbol-name symbol) 						     package))))	    (unless (equal l (list symbol accessibility))	      (error "Symbol ~S not found as ~S in package ~A [~S]"		     symbol accessibility (package-name package) l))	    (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)		 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))The following functions prints out every interned symbol:(defun print-all-symbols ()   (with-package-iterator (next-symbol nil)    (loop      ;;Note -- this is the "trivial" LOOP of CLtL p121      (multiple-value-bind (more? symbol) (next-symbol)	(if more?            (print symbol)	   (return))))))Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.  Something like this is already beingdone by the standard package macros [CLtL, p187].Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.Of course, if an implementation _can_ support an indefinite extent fora "generator" object returned out of the iterator forms, it is allowed to do so by this proposal.There has been some concern that the syntax of keyword arguments to WITH-PACKAGE-ITERATOR may be problematical; especially, it seems oddthat the <package> argument is a required argument, but is not usedat all in the case when the keyword arguments select a DO-ALL-SYMBOLSmeaning.  This is a constraint that isn't easy to express in the existing CL language: namely, that the <package> argument is required if and onlyif any of the keyword arguments are supplied as non-nil.  One way out of this bind is to let the <package> argument be optional, defaulting to thesymbol *PACKAGE*.  Then the example above for 'print-all-symbols' couldbe written as:  (with-package-iterator (next-symbol) ...)instead of:  (with-package-iterator (next-symbol nil) ...)or, instead of:  (with-package-iterator         (next-symbol nil :external nil :internal nil :inherited nil )     ...)*start*02902 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 12:23:37 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Nov 88  12:21:35 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 490570; Thu 10-Nov-88 15:21:44 ESTDate: Thu, 10 Nov 88 15:21 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8811101832.AA05895@bhopal>Message-ID: <19881110202131.3.MOON@EUPHRATES.SCRC.Symbolics.COM>I approve the WITH-HASH-TABLE-ITERATOR portion ofHASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER.I have two problems with WITH-PACKAGE-ITERATOR.  First, you use theundefined phrase "available in the indicated package" a few times.  Ithink you mean "accessible in the indicated package" (defined on CLtLp.172).  The more important problem is that I think the syntacticproblem noted in the discussion section makes WITH-PACKAGE-ITERATORunacceptable.  I don't like having a required argument that is ignored,and I don't like having those two unspecified cases: either the meaningshould be specified or they should signal an error.I have two suggested alternatives that I think solve this.  Either ofthem would be acceptable to me.  The second is simpler than the first soI mildly prefer it.  If you like I can edit up an alternative proposal,but I thought I would start by just presenting alternatives to this onesmall piece of your proposal.Alternative syntax #1:  In place of	WITH-PACKAGE-ITERATOR ((<next-fn> <package>                         [Macro]				&key external internal inherited)			       &body body)let's use the syntax	WITH-PACKAGE-ITERATOR ((<next-fn>                                   [Macro]				&optional <package>				&rest symbol-types)			       &body body)The symbol-types arguments are symbols from the set {:INTERNAL, :EXTERNAL,:INHERITED}.  Their order does not matter.(WITH-PACKAGE-ITERATOR (next) body) is DO-ALL-SYMBOLS.(WITH-PACKAGE-ITERATOR (next pkg) body) signals an error for invalid syntax.(WITH-PACKAGE-ITERATOR (next pkg :EXTERNAL) body) is DO-EXTERNAL-SYMBOLS(WITH-PACKAGE-ITERATOR (next pkg :INTERNAL :EXTERNAL :INHERITED) body) is DO-SYMBOLSetc. for the other five cases.Alternative syntax #2: Use the syntax	WITH-PACKAGE-ITERATOR ((<next-fn>                                   [Macro]				&optional <package>)			       &body body)If <package> is supplied, this is DO-SYMBOLS, otherwise it is DO-ALL-SYMBOLS.The third value returned by <next-fn> can be used to filter out unwanted symbolswhen doing such operations as DO-EXTERNAL-SYMBOLS.*start*01408 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 13:30:08 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 10 Nov 88  13:28:34 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03612g; Thu, 10 Nov 88 13:27:23 PSTReceived: by bhopal id AA06710g; Thu, 10 Nov 88 13:26:05 PSTDate: Thu, 10 Nov 88 13:26:05 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811102126.AA06710@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Thu, 10 Nov 88 15:21 EST <19881110202131.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)Your alternative syntax #1 is clearly superior to all the others.  Could you take the time to alter the proposal accordingly, and at the same time fix the typo "available" into "accessible"? [and also proof read the whole proposal again?]Alternative #2 is unacceptable, because it presumes that filtering aDO-ALL-SYMBOLS is a reasonable implementation of DO-EXTERNAL-SYMBOLS.  In fact, in Lucid Common Lisp, the situation is much more complex; the "filtering" step could, in extreme circumstances, become pragmatically unworkable, whereas the native implementation has no trouble.-- JonL --*start*03355 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 14:17:45 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 14 Nov 88  14:16:21 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 492279; Mon 14-Nov-88 17:16:09 ESTDate: Mon, 14 Nov 88 17:15 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8811102126.AA06710@bhopal>Message-ID: <19881114221549.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 10 Nov 88 13:26:05 PST    From: Jon L White <jonl@lucid.com>    Your alternative syntax #1 is clearly superior to all the others.  Could     you take the time to alter the proposal accordingly, and at the same time     fix the typo "available" into "accessible"? [and also proof read the     whole proposal again?]Before I take the time to do that...    Alternative #2 is unacceptable, because it presumes that filtering a    DO-ALL-SYMBOLS is a reasonable implementation of DO-EXTERNAL-SYMBOLS.      In fact, in Lucid Common Lisp, the situation is much more complex; the     "filtering" step could, in extreme circumstances, become pragmatically     unworkable, whereas the native implementation has no trouble....could you explain why the syntax should be made more complicated todeal with the special needs of a particular implementation?  It might bethat I don't understand just what these pragmatic unworkablenesses are,and don't understand whether they are peculiar to Lucid or more general.However, my immediate inclination is to suggest that Lucid'simplementation of WITH-PACKAGE-ITERATOR should check for and optimizecases that look like  (WITH-PACKAGE-ITERATOR (next-symbol package)     ...     (MULTIPLE-VALUE-BIND (valid symbol flag) (next-symbol)       (WHEN valid	 (WHEN (EQ flag :EXTERNAL)           ...))))Of course you don't want to look for that one particular source pattern,what you want to look for is cases where no side-effects are affected bysuppressing returning of the internal symbols.This is a somewhat complicated optimization but surely well within thecapabilities of Lucid's compiler writers.Also, MLY had a good suggestion, which was that instead of havingspecial cases for one package and all packages, the macro should simplyaccept a list of packages.  An implementation can of course recognizeand treat as a special case forms such as  (WITH-PACKAGE-ITERATOR (next-symbol (LIST-ALL-PACKAGES)) ...)and forms such as  (WITH-PACKAGE-ITERATOR (next-symbol (LIST package)) ...)We could also allow a single package in place of a list if we think thatconvenience is worthwhile; USE-PACKAGE is a precedent for this.  Thiseliminates the oddity of the optional argument that you omit to tell itto do all packages.If we adopt this suggestion I will feel better about having keywordarguments for which symbols to access, although I still feel the simplersyntax with no options is preferable unless you can show me that Lucid'sneeds outweigh the desire for syntactic simplicity.*start*01144 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 16:03:23 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Nov 88  16:01:05 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 NOV 88 15:33:01 PSTDate: 14 Nov 88 15:32 PSTFrom: masinter.paSubject: Re: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 14 Nov 88 17:15 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: Jon L White <jonl@lucid.com>, cl-cleanup@sail.stanford.eduMessage-ID: <881114-153301-2381@Xerox>Frankly, although option #2 with filtering looks like it is simpler --certainly the syntax description is shorter -- I think option #1, where youspell out more explicitly the kind of iteration you want to do, looks likeit is easier to understand.So I would vote for option #2 over option #1 even without some specialLucid-specific circumstances.The writeup should reference issue DO-SYMBOL-DUPLICATES which passed. *start*03080 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 NOV 88 13:14:14 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 16 Nov 88  13:12:52 PSTReceived: from bhopal by heavens-gate.lucid.com id AA00269g; Tue, 15 Nov 88 00:29:22 PSTReceived: by bhopal id AA25376g; Tue, 15 Nov 88 00:28:06 PSTDate: Tue, 15 Nov 88 00:28:06 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811150828.AA25376@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Mon, 14 Nov 88 17:15 EST <19881114221549.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)re: ...could you explain why the syntax should be made more complicated to    deal with the special needs of a particular implementation?  ...I don't think either syntax is superior enough to warrant spending timetrying to figure out compiler optimizations.  After all, this fool function is definitely _not_ for the masses --  it is being designedfor precisely the 3 or 4 hackers who are working on portable iterationparadigms; and they will use it in precisely three or four placesin their code.Also, I think you are overestimating the complexity of what the currentSSC's[*] in our community can handle.  By making the iteration scopemacro define a 'macrolet' name, the implementor can put lots of"smarts" into that one macro.  But expecting the compiler to doenough source code analysis to figure out that when a bound variablehas a certain value, nothing "interesting" will be done ... I justcan't believe you're actually suggesting this.  And it's not justthe compiler -- people *do* run code interpretively, you know!The particular thing I was referring to in Lucid's DO-EXTERNAL-SYMBOLSis that Lucid represents packages differently depending on the ratio ofof internal and external symbols.  [This is consistent with good database design -- you have several "baskets" to use, depending on how big a fish you want to carry home.]  But even without Lucid's particularoptimizations, consider doing a DO-INHERITED-SYMBOLS over a packageMONGO, that uses LISP; and suppose MONGO is a "development" package with 80,000 internal symbols present.  Would you really want to iteratethrough 79,000 internal symbols, swapping in all those jillions ofpages, before finding the desired 1000?  Probably not.  Any implementation -- not just Lucid's -- that takes the obvious step ofiterating thru the package-use-list and ignoring certain shadows wouldbe infinitely better than requiring user-level code to do filtering ofall accessible symbols.  This is *not* a LUCID-specific issue.Even if I were to agree that your alternative #2 is minutely simpler than alternative #1, the point is that #1 is "real good" all by itself;and this doesn't feel like a place where 50.001% is that much better than 49.999%.-- JonL --[*] SSC = "Sufficiently Smart Compiler"*start*01224 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 16 NOV 88 16:30:43 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01012g; Wed, 16 Nov 88 16:27:18 PSTReceived: by bhopal id AA05000g; Wed, 16 Nov 88 16:25:54 PSTDate: Wed, 16 Nov 88 16:25:54 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811170025.AA05000@bhopal>To: masinter.paCc: Moon@STONY-BROOK.SCRC.Symbolics.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 14 Nov 88 15:32 PST <881114-153301-2381@Xerox>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)re: Frankly, although option #2 with filtering looks like it is simpler --   certainly the syntax description is shorter -- I think option #1, where you   spell out more explicitly the kind of iteration you want to do, looks like   it is easier to understand.   So I would vote for option #2 over option #1 even without some special   Lucid-specific circumstances.You made a typo here -- your "vote" is for option #1.  [Not only is this clear from the context of the remainder of the msg, but I checked it with Larry, by telephone.]  Moon take note.-- JonL --*start*01575 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 14 NOV 88 18:43:18 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 492501; Mon 14-Nov-88 21:43:53 ESTDate: Mon, 14 Nov 88 21:43 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)To: masinter.pacc: Jon L White <jonl@lucid.com>, cl-cleanup@sail.stanford.eduIn-Reply-To: <881114-153301-2381@Xerox>Message-ID: <19881115024345.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 14 Nov 88 15:32 PST    From: masinter.pa@Xerox.COM    Frankly, although option #2 with filtering looks like it is simpler --    certainly the syntax description is shorter -- I think option #1, where you    spell out more explicitly the kind of iteration you want to do, looks like    it is easier to understand.Are you sure you really mean that?  Option 1 is the same as option 2 exceptthat it offers a bunch of additional features, so how can it be simpler?Or to put it another way, option 1 is the same as option 2 except that youwrite some of the control structure of your program in a special languageinstead of Lisp.    So I would vote for option #2 over option #1 even without some special    Lucid-specific circumstances.Oh, okay, so actually you think option 2 is easier to understand.    The writeup should reference issue DO-SYMBOL-DUPLICATES which passed. Noted.*start*01445 00024 US Date: 17 Nov 88 15:37 PSTFrom: masinter.paSubject: Re: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)to: masinter>> not sent !!! <<In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 14 Nov 88 21:43 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, Jon L White <jonl@lucid.com>, cl-cleanup@sail.stanford.eduLet me say first that I don't feel strongly about this issue. My point, which is a minor one, is that in some cases a syntax with more options is "simpler to understand" than a syntax with less options, where you have to write extra Lisp code. There are frequently design decisions where we need to decide whether we want to use different names, the same name with different options, or one name with idiomatic control structure which determines the options desired. The decisions were node made uniformly in Common Lisp, because the tradeoffs in each situation are different. In this instance, given that currently there are separate iteration macros (DO-SYMBOLS and DO-EXTERNAL-SYMBOLS ), I think it is better to make the distinction an option within the macro rather than as an idiomatic use. This is consistent with the goal having the macros able to generate code with the correct "order-of-magnitude" behavior without complex compiler optimizations.  We might also consider making "DO-SYMBOLS" and "DO-EXTERNAL-SYMBOLS" obsolete. *start*00900 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 15:48:52 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Nov 88  15:32:53 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496892; Tue 22-Nov-88 18:32:16 ESTDate: Tue, 22 Nov 88 18:32 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 4)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8811150828.AA25376@bhopal>Message-ID: <19881122233213.3.MOON@EUPHRATES.SCRC.Symbolics.COM>OK, I will write up a version 5 that uses alternative #1, as you suggest,and also incorporates MLY's suggestion.*start*13027 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 16:30:53 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Nov 88  16:28:39 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496925; Tue 22-Nov-88 19:27:59 ESTDate: Tue, 22 Nov 88 19:27 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)To: cl-cleanup@sail.stanford.eduReferences: <8811101832.AA05895@bhopal>Message-ID: <19881123002752.4.MOON@EUPHRATES.SCRC.Symbolics.COM>I have updated this according to suggestions from JonL and MLY.  Ielaborated on the description of <package-list> with more detail thanwas in MLY's suggestion.  I also added examples and fixed the typo inthe discussion of package iteration and one or two other typos andmisspellings.  I'm happy with this version if everyone else is.!Issue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Issue: DO-SYMBOLS-DUPLICATES Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL               Version 2,  6-Oct-88 JonL (convert to "with" scoping).               Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)               Version 4,  8-Nov-88 JonL (fix example; clarify some nits)               Version 5, 22-Nov-88 Moon (improve syntax for package iterator,                                          add examples, fix typos)Problem description:The Iteration subcommittee would like the several iteration proposals to bewritable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.  In particular,these primitives are fully packaged and do not allow control over theindividual operations of starting the iteration, stopping the iteration,and advancing to the next step of the iteration.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the hash-table which is obtained     by evaluating <hash-table> only once.    An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. the key item (of a <key, value> pair)      ;;    3. the value item (of a <key, value> pair)      ;; After all entries have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package-list>                    [Macro]                            &rest <symbol-types>)                           &body body)    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return symbols, one by one, from the packages that are elements    of the list which is obtained by evaluating <package-list> only once.      Each element of <package-list> can be a package or the name of a    package.    The order of symbols returned does not necessarily reflect the order    of packages in <package-list>.  When <package-list> has more than    one element, it is unspecified whether duplicate symbols are    returned once or more than once.  Even when <package-list> has only    one element, it is unspecified whether symbols inherited from    multiple packages are returned more than once.  See the proposal    DO-SYMBOLS-DUPLICATES:ALLOWED.    As a convenience, the value of <package-list> can be a package or    the name of a package; this is equivalent to a list of one element.    An argument of NIL is treated as an empty list of packages.    The <symbol-types> subform consists of one or more symbols from the    set {:INTERNAL, :EXTERNAL, :INHERITED}.  Their order does not    matter.  The <symbol-types> subform is not evaluated.  This controls    which symbols accessible in a package are returned.      :INTERNAL means the symbols that are present in the package and      not exported.      :EXTERNAL means the symbols that are exported.      :INHERITED means the symbols that are exported by used packages and      not shadowed.    If more than one <symbol-type> is specified, all symbols that    satisfy at least one of the <symbol-types> are returned.    WITH-PACKAGE-ITERATOR signals an error if no <symbol-types> are    specified or if a <symbol-type> not recognized by the implementation    is specified.  Implementations are permitted to extend this syntax    by recognizing additional symbol types.    An invocation (<next-fn>) returns four values as follows:      ;;    1. a boolean indicating whether a symbol is returned (T says yes)      ;;    2. a symbol (accessible in the indicated package)      ;;    3. a package (in which the symbol is accessible)      ;;    4. the accessibility type for that symbol; i.e. one of      ;;       :INTERNAL, :EXTERNAL, or :INHERITED      ;; After all symbols have been returned [by successive invocations of      ;;   (<next-fn>)], then only one value is returned, namely NIL.It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the WITH-...form (such as by returning some closure over the invocation form).Any number of invocations of with-hash-table-iterator andwith-package-iterator can be nested, and the body of the innermost onecan invoke all of the MACROLET'ed macros, provided all those macroshave distinct names.Test-case:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-hash-table-iterator (hash-table)  (let ((all-entries '())        (generated-entries '())        (unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))             hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop             ;;Note -- this is the "trivial" LOOP of CLtL p121        (multiple-value-bind (more? key value) (generator-fn)          (unless more? (return))          (unless (eql value (gethash key hash-table unique))            (error "Key ~S not found for value ~S" key value))          (push (list key value) generated-entries))))    (unless (= (length all-entries)               (length generated-entries)               (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-package-iterator (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())        (generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility)           (find-symbol (symbol-name x) package)        (push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package                             :internal :external :inherited)      (loop             ;;Note -- this is the "trivial" LOOP of CLtL p121        (multiple-value-bind (more? symbol pkg accessibility)            (generator-fn)          (unless more? (return))          (let ((l (multiple-value-list (find-symbol (symbol-name symbol)                                                      package))))            (unless (equal l (list symbol accessibility))              (error "Symbol ~S not found as ~S in package ~A [~S]"                     symbol accessibility (package-name package) l))            (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)                 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))The following function prints out every interned symbol:(defun print-all-symbols ()   (with-package-iterator (next-symbol (list-all-packages)                          :internal :external)    (loop      ;;Note -- this is the "trivial" LOOP of CLtL p121      (multiple-value-bind (more? symbol) (next-symbol)        (if more?            (print symbol)           (return))))))Examples:The following macro definitions show how certain builtin Common Lispmacros and functions could have been defined in terms of the proposedprimitives.  They are intended as illustrative examples, not as newspecifications of those builtin Common Lisp facilities.(defun maphash (function hash-table)  (with-hash-table-iterator (next-entry hash-table)    (loop (multiple-value-bind (more key value) (next-entry)            (unless more (return nil))            (funcall function key value)))))(defmacro do-symbols ((var &optional (package `*package*) result-form)                      &body body)  `(with-package-iterator (next-symbol (list ,package)                           :internal :external :inherited)     (loop (multiple-value-bind (more ,var) (next-symbol)             (cond (more ,@body)                   (t (return ,result-form)))))))(defmacro do-all-symbols ((var &optional result-form) &body body)  `(with-package-iterator (next-symbol (list-all-packages)                           :internal :external)     (loop (multiple-value-bind (more ,var) (next-symbol)             (cond (more ,@body)                   (t (return ,result-form)))))))(defmacro do-external-symbols ((var &optional (package `*package*) result-form)                               &body body)  `(with-package-iterator (next-symbol (list ,package)                           :external)     (loop (multiple-value-bind (more ,var) (next-symbol)             (cond (more ,@body)                   (t (return ,result-form)))))))Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.  Something like this is already beingdone by the standard package macros [CLtL, p187].Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.Of course, if an implementation _can_ support an indefinite extent fora "generator" object returned out of the iterator forms, it is allowed to do so by this proposal.*start*02532 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 NOV 88 22:01:35 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Nov 88  22:00:26 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01379g; Mon, 28 Nov 88 21:58:13 PSTReceived: by bhopal id AA00442g; Mon, 28 Nov 88 21:57:06 PSTDate: Mon, 28 Nov 88 21:57:06 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811290557.AA00442@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 22 Nov 88 19:27 EST <19881123002752.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)This is all fine with me now, except for one odd addition you made: theadditional return value for the iterator over packages.  Whereas itused to be:    An invocation (<next-fn>) returns three values as follows:      ;;    1. a boolean indicating whether an entry is returned (T says yes)      ;;    2. a symbol (available in the indicated package)      ;;    3. the availability type for that symbol; i.e. one of      ;;       :INTERNAL, :EXTERNAL, or :INHERITED,  or unspecified for       ;;       the DO-ALL-SYMBOLS case.      . . . it is now:    An invocation (<next-fn>) returns four values as follows:      ;;    1. a boolean indicating whether a symbol is returned (T says yes)      ;;    2. a symbol (accessible in the indicated package)      ;;    3. a package (in which the symbol is accessible)      ;;    4. the accessibility type for that symbol; i.e. one of      ;;       :INTERNAL, :EXTERNAL, or :INHERITED      . . . First off, I much prefer that such information be passed as the 4thvalue, rather than disturbing the original ordering (since I have codethat needs the accessibility type, particularly when doing DO-SYMBOLS;but never have code that needs merely "a package").  But of what valueis it anyway?  simply saying that it is "a package" in which the symbolis "accessible" doesn't really tell one anything important.  For example,in DO-SYMBOLS over package FOO, a given symbol may be inheritable fromthree distinct packages "used" by FOO; but your prescription here makesit legal simply to return FOO each time.  Maybe you meant "present"rather than "accessible"?  Even then, I'm not sure how you would specifyit to mean what I suspect you want it to mean.-- JonL --*start*02861 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 09:22:51 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Nov 88  09:22:05 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 499263; Tue 29-Nov-88 12:20:03 ESTDate: Tue, 29 Nov 88 12:19 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8811290557.AA00442@bhopal>Message-ID: <19881129171957.5.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 28 Nov 88 21:57:06 PST    From: Jon L White <jonl@lucid.com>    This is all fine with me now, except for one odd addition you made: the    additional return value for the iterator over packages.The reason was that I don't see how the accessibility type means anything atall except relative to a package.  This is not an issue when the <package-list>argument is of length 1, since the <package> value will always be the soleelement of that list.  But when iterating over several packages, or allpackages, to use the accessibility type for anything you need to know whichpackage the iteration is operating on.    in DO-SYMBOLS over package FOO, a given symbol may be inheritable from    three distinct packages "used" by FOO; but your prescription here makes    it legal simply to return FOO each time.Not just legal, but required.  Sorry about the ambiguity.    First off, I much prefer that such information be passed as the 4th    value, rather than disturbing the original ordering (since I have codeI don't care about the order.  I didn't realize that you did.Sorry about the unclarity, when I said	  ;;    2. a symbol (accessible in the indicated package)	  ;;    3. a package (in which the symbol is accessible)	  ;;    4. the accessibility type for that symbol; i.e. one of	  ;;       :INTERNAL, :EXTERNAL, or :INHERITEDI meant that those three values were to be interpreted jointly.  Howabout this clarification: The package value is one of the packages present or named in the <package-list> argument.  The meaning of the second, third, and fourth values is that the returned symbol is accessible in the returned package in the specified way: present and not exported if :INTERNAL, present and exported if :EXTERNAL, or not present and inherited from some other package and not shadowed if :INHERITED.I think the alternative to returning a package-type value is to makethe accessibility-type value unspecified whenever the <package-list>argument has more one element.  I am loath to do that.What shall we do?*start*01616 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 20:54:11 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Nov 88  20:53:03 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 499774; Tue 29-Nov-88 23:52:41 ESTDate: Tue, 29 Nov 88 23:52 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8811300131.AA02796@bhopal>Message-ID: <19881130045224.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 29 Nov 88 17:31:48 PST    From: Jon L White <jonl@lucid.com>    re:  The package value is one of the packages present or named in the	 <package-list> argument.  The meaning of the second, third, and fourth	 values is that the returned symbol is accessible in the returned package	 in the specified way: present and not exported if :INTERNAL, present	 and exported if :EXTERNAL, or not present and inherited from some other	 package and not shadowed if :INHERITED.    This paragraph looks fine.  If not one else has comments, the either you    or I should emmed the final version accordingly; also don't forget    to swap the (3) and (4) items for return value.Could you do it?  I'm not going to be able to do any more Common Lisp workuntil after December 7.  Maybe I'll read the mail, maybe I won't.*start*01426 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 17:37:46 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 29 Nov 88  17:37:12 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02327g; Tue, 29 Nov 88 17:34:24 PSTReceived: by bhopal id AA02796g; Tue, 29 Nov 88 17:31:48 PSTDate: Tue, 29 Nov 88 17:31:48 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811300131.AA02796@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 29 Nov 88 12:19 EST <19881129171957.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)re:  The package value is one of the packages present or named in the     <package-list> argument.  The meaning of the second, third, and fourth     values is that the returned symbol is accessible in the returned package     in the specified way: present and not exported if :INTERNAL, present     and exported if :EXTERNAL, or not present and inherited from some other     package and not shadowed if :INHERITED.This paragraph looks fine.  If not one else has comments, the either youor I should emmed the final version accordingly; also don't forgetto swap the (3) and (4) items for return value.-- JonL --*start*01576 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 NOV 88 16:49:45 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 30 Nov 88  16:48:51 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03120g; Wed, 30 Nov 88 16:45:55 PSTReceived: by bhopal id AA04741g; Wed, 30 Nov 88 16:44:47 PSTDate: Wed, 30 Nov 88 16:44:47 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812010044.AA04741@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 29 Nov 88 23:52 EST <19881130045224.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)re: [fix final nits]Ok, I'll do it.  I would also like to embellish the sample code for thedo-mumble-symbols guys to be more nearly workable.  What would you say to the following for DO-SYMBOLS?  [PARSE-BODY is as defined in Guy Steele's "Clarifications" of 6-Dec-85.](defmacro do-symbols ((var &optional (package `*package*) result-form)                      &body body)  (multiple-value-bind (body decls docstring) (parse-body body)    `(with-package-iterator (next-symbol (list ,package)                             :internal :external :inherited)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (return ,result-form))           ,@body)))))           -- JonL --*start*02150 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 NOV 88 17:33:24 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 30 Nov 88  17:31:32 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 500382; Wed 30-Nov-88 20:26:28 ESTDate: Wed, 30 Nov 88 20:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8812010044.AA04741@bhopal>Message-ID: <19881201012612.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Wed, 30 Nov 88 16:44:47 PST    From: Jon L White <jonl@lucid.com>    re: [fix final nits]    Ok, I'll do it.  I would also like to embellish the sample code for the    do-mumble-symbols guys to be more nearly workable.  What would you say to     the following for DO-SYMBOLS?  [PARSE-BODY is as defined in Guy Steele's     "Clarifications" of 6-Dec-85.]I don't see much advantage to adding more complexity to the macro when we'retrying to show what with-package-iterator does, not how to use parse-body(which I don't think was ever accepted into Common Lisp anyway).If you do go down this road, you're just going to have me complainingthat your macro doesn't take an &environment argument, and things ofthat ilk.  I'd rather keep it simple.  However, you're writing the writeup,so do whatever you want.  I only am going to complain about things thatchange the definition of Common Lisp, not stylistic details of the examples.    (defmacro do-symbols ((var &optional (package `*package*) result-form)			  &body body)      (multiple-value-bind (body decls docstring) (parse-body body)	`(with-package-iterator (next-symbol (list ,package)				 :internal :external :inherited)	   (let (more? ,var)	     ,@decls	     (loop	       (unless (multiple-value-setq (more? ,var) (next-symbol))		 (return ,result-form))	       ,@body)))))*start*14523 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 DEC 88 00:07:53 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 3 Dec 88  00:02:32 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA05266g; Sat, 3 Dec 88 00:00:16 PSTReceived: by bhopal id AA04330g; Fri, 2 Dec 88 23:59:11 PSTDate: Fri, 2 Dec 88 23:59:11 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812030759.AA04330@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 6)Final nits, as per msgs last week.  I added the &environment argument toPARSE-BODY in the DO-mumble-SYMBOLS examples (which were also moved tothe discussion section, since they are repetitive, and not needed perse in the examples section.)  [Incidentally, it looks like the cleanupcommittee has let PARSE-BODY "fall onto the floor" -- possibly there is less need for it given the sentiment for rejecting the macros-expand-into-declarations situation?  but every reasonable implmentationseems to have a version of it.]-- JonL --!Issue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Issue: DO-SYMBOLS-DUPLICATES Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL               Version 2,  6-Oct-88 JonL (convert to "with" scoping).               Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)               Version 4,  8-Nov-88 JonL (fix example; clarify some nits)               Version 5, 22-Nov-88 Moon (improve syntax for package iterator,                                          add examples, fix typos)               Version 6,  6-Oct-88 JonL (final nits)Problem description:The Iteration subcommittee would like the several iteration proposals to bewritable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.  In particular,these primitives are fully packaged and do not allow control over theindividual operations of starting the iteration, stopping the iteration,and advancing to the next step of the iteration.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the hash-table which is obtained     by evaluating <hash-table> only once.    An invocation (<next-fn>) returns three values as follows:        1. a boolean indicating whether an entry is returned (T says yes)        2. the key item (of a <key, value> pair)        3. the value item (of a <key, value> pair)    After all entries have been returned [by successive invocations of    (<next-fn>)], then only one value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package-list>                    [Macro]                            &rest <symbol-types>)                           &body body)    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return symbols, one by one, from the packages that are elements    of the list which is obtained by evaluating <package-list> only once.      Each element of <package-list> can be a package or the name of a    package.    The order of symbols returned does not necessarily reflect the order    of packages in <package-list>.  When <package-list> has more than    one element, it is unspecified whether duplicate symbols are    returned once or more than once.  Even when <package-list> has only    one element, it is unspecified whether symbols inherited from    multiple packages are returned more than once.  See the proposal    DO-SYMBOLS-DUPLICATES:ALLOWED.    As a convenience, the value of <package-list> can be a package or    the name of a package; this is equivalent to a list of one element.    An argument of NIL is treated as an empty list of packages.    The <symbol-types> subform consists of one or more symbols from the    set {:INTERNAL, :EXTERNAL, :INHERITED}.  Their order does not    matter.  The <symbol-types> subform is not evaluated.  This controls    which symbols accessible in a package are returned:        :INTERNAL  means the symbols that are present in the package,                   but which are not exported;        :EXTERNAL  means the symbols that are present and exported;        :INHERITED means the symbols that are exported by used packages                   and that are not shadowed.    When more than one argument is supplied for <symbol-types>, then a     symbol is returned if its accessibility matches any one of the     <symbol-types> specified.  WITH-PACKAGE-ITERATOR signals an error if     no <symbol-types> are specified or if a <symbol-type> not recognized     by the implementation is specified.  Implementations are permitted to     extend this syntax by recognizing additional symbol accessibility types.    An invocation (<next-fn>) returns four values as follows:        1. a boolean indicating whether a symbol is returned (T says yes)	2. a symbol (accessible in one the indicated packages)	3. the accessibility type for that symbol; i.e. one of	   :INTERNAL, :EXTERNAL, or :INHERITED	4. the package from which the symbol has been accessed.    After all symbols have been returned [by successive invocations of    (<next-fn>)], then only one value is returned, namely NIL.   The fourth return value is one of the packages present or named in the   <package-list> argument.  The meaning of the second, third, and fourth   values is that the returned symbol is accessible in the returned package   in the way indicated by the second return value:        :INTERNAL   ==>  present, and not exported,        :EXTERNAL   ==>  present, and exported,         :INHERITED  ==>  not present (thus not shadowed) but inherited                         from some used package.It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the WITH-...form (such as by returning some closure over the invocation form).Any number of invocations of with-hash-table-iterator andwith-package-iterator can be nested, and the body of the innermost onecan invoke all of the MACROLET'ed macros, provided all those macroshave distinct names.Test-case:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-hash-table-iterator (hash-table)  (let ((all-entries '())        (generated-entries '())        (unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))             hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop             ;;Note -- this is the "trivial" LOOP of CLtL p121        (multiple-value-bind (more? key value) (generator-fn)          (unless more? (return))          (unless (eql value (gethash key hash-table unique))            (error "Key ~S not found for value ~S" key value))          (push (list key value) generated-entries))))    (unless (= (length all-entries)               (length generated-entries)               (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-package-iterator (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())        (generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility)           (find-symbol (symbol-name x) package)        (push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package                             :internal :external :inherited)      (loop             ;;Note -- this is the "trivial" LOOP of CLtL p121        (multiple-value-bind (more? symbol pkg accessibility)            (generator-fn)          (unless more? (return))          (let ((l (multiple-value-list (find-symbol (symbol-name symbol)                                                      package))))            (unless (equal l (list symbol accessibility))              (error "Symbol ~S not found as ~S in package ~A [~S]"                     symbol accessibility (package-name package) l))            (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)                 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))Examples:The following function prints out every interned symbol (possiblymore than once):(defun print-all-symbols ()   (with-package-iterator (next-symbol (list-all-packages)                          :internal :external)    (loop      ;;Note -- this is the "trivial" LOOP of CLtL p121      (multiple-value-bind (more? symbol) (next-symbol)        (if more?            (print symbol)           (return))))))The following could be an acceptable definition of the functionMAPHASH, implemented by WITH-HASH-TABLE-ITERATOR"(defun maphash (function hash-table)  (with-hash-table-iterator (next-entry hash-table)    (loop (multiple-value-bind (more key value) (next-entry)            (unless more (return nil))            (funcall function key value)))))Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.  Something like this is already beingdone by the standard package macros [CLtL, p187].Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.Of course, if an implementation _can_ support an indefinite extent fora "generator" object returned out of the iterator forms, it is allowed to do so by this proposal.The following macro definitions show how Common Lisp's DO-mumble-SYMBOLS macros could have been defined in terms of WITH-PACKAGE-ITERATOR.  They are intended as illustrative examples, not as new specifications of those built-in Common Lisp facilities. [PARSE-BODY is as defined in Guy Steele's "Clarifications" of 6-Dec-85.](defmacro do-symbols ((var &optional (package `*package*) result-form)                      &body body                       &environment env)   (multiple-value-bind (body decls docstring) (parse-body body env)    `(with-package-iterator (next-symbol (list ,package)                             :internal :external :inherited)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (setq ,var nil)             (return ,result-form))           ,@body)))))(defmacro do-external-symbols ((var &optional (package `*package*) result-form)                               &body body                                &environment env)   (multiple-value-bind (body decls docstring) (parse-body body env)    `(with-package-iterator (next-symbol (list ,package)                             :external)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (setq ,var nil)             (return ,result-form))           ,@body)))))(defmacro do-all-symbols ((var &optional result-form)                           &body body                           &environment env)   (multiple-value-bind (body decls docstring) (parse-body body env)    `(with-package-iterator (next-symbol (list-all-packages)                             :internal :external)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (setq ,var nil)             (return ,result-form))           ,@body)))))*start*01187 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 DEC 88 17:43:15 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 5 Dec 88  17:42:28 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA00349; Mon, 5 Dec 88 17:45:04 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA17229; Mon, 5 Dec 88 17:41:42 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA03217; Mon, 5 Dec 88 17:42:39 PSTDate: Mon, 5 Dec 88 17:42:39 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8812060142.AA03217@clam.sun.com>To: cl-cleanup@sail.stanford.eduSubject: Re:  [David A. Moon: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)]Jeff Peck has forwarded me a copy of this proposal.  (I had seen anearlier versions.)  I have one comment at this point:Why not define <next-fn> as a local function as if defined byFLET rather than a macro as if defined by MACROLET?  It seemsto me that a local function is more useful, and that it is notpossible to prevent the user from defining a local function,so no problems are avoided.				-Cris*start*01584 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 DEC 88 17:55:08 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 5 Dec 88  17:52:26 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 503535; Mon 5-Dec-88 20:51:27 ESTDate: Mon, 5 Dec 88 20:51 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re:  [David A. Moon: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)]To: Cris Perdue <cperdue@Sun.COM>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8812060142.AA03217@clam.sun.com>Message-ID: <19881206015109.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 5 Dec 88 17:42:39 PST    From: cperdue@Sun.COM (Cris Perdue)    Jeff Peck has forwarded me a copy of this proposal.  (I had seen an    earlier versions.)  I have one comment at this point:    Why not define <next-fn> as a local function as if defined by    FLET rather than a macro as if defined by MACROLET?  It seems    to me that a local function is more usefulI wanted to allow it to be a local function, but JonL convincedme that a macro gave more scope to the implememtation to optimizewithout losing anything essential in these circumstances.  I thinkJonL was right.    , and that it is not    possible to prevent the user from defining a local function,    so no problems are avoided.I don't understand this part of your comment.*start*01277 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 19:58:03 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 7 Dec 88  19:48:04 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AB12278; Wed, 7 Dec 88 19:50:18 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA11944; Wed, 7 Dec 88 11:09:31 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA05061; Wed, 7 Dec 88 11:10:27 PSTDate: Wed, 7 Dec 88 11:10:27 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8812071910.AA05061@clam.sun.com>To: Moon@STONY-BROOK.SCRC.Symbolics.COMSubject: Re:  [David A. Moon: Issue: HASH-TABLE-PACKAGE-GENERATORS (version 5)]Cc: cl-cleanup@sail.stanford.edu>     , and that it is not>     possible to prevent the user from defining a local function,>     so no problems are avoided.> > I don't understand this part of your comment.I see that the proposal refers to the possibilities I was thinkingof:"It is unspecified what happens if any of the implicit interiorstate of an iteration is returned outside the dyamic extent of theWITH-... form (such as by retuning some closure over the invocation form)."*start*14291 00024 US Date:  8 Dec 88 11:30 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: HASH-TABLE-PACKAGE-GENERATORS (Version 7)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noForum:         CleanupIssue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Issue: DO-SYMBOLS-DUPLICATES Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL               Version 2,  6-Oct-88 JonL (convert to "with" scoping).               Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)               Version 4,  8-Nov-88 JonL (fix example; clarify some nits)               Version 5, 22-Nov-88 Moon (improve syntax for package iterator,                                          add examples, fix typos)               Version 6,  6-Oct-88 JonL (final nits)               Version 7,  8-Dec-88, Masinter (add comment to discussion)Problem description:The Iteration subcommittee would like the several iteration proposals to bewritable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.  In particular,these primitives are fully packaged and do not allow control over theindividual operations of starting the iteration, stopping the iteration,and advancing to the next step of the iteration.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the hash-table which is obtained     by evaluating <hash-table> only once.    An invocation (<next-fn>) returns three values as follows:        1. a boolean indicating whether an entry is returned (T says yes)        2. the key item (of a <key, value> pair)        3. the value item (of a <key, value> pair)    After all entries have been returned [by successive invocations of    (<next-fn>)], then only one value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package-list>                    [Macro]                            &rest <symbol-types>)                           &body body)    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return symbols, one by one, from the packages that are elements    of the list which is obtained by evaluating <package-list> only once.      Each element of <package-list> can be a package or the name of a    package.    The order of symbols returned does not necessarily reflect the order    of packages in <package-list>.  When <package-list> has more than    one element, it is unspecified whether duplicate symbols are    returned once or more than once.  Even when <package-list> has only    one element, it is unspecified whether symbols inherited from    multiple packages are returned more than once.  See the proposal    DO-SYMBOLS-DUPLICATES:ALLOWED.    As a convenience, the value of <package-list> can be a package or    the name of a package; this is equivalent to a list of one element.    An argument of NIL is treated as an empty list of packages.    The <symbol-types> subform consists of one or more symbols from the    set {:INTERNAL, :EXTERNAL, :INHERITED}.  Their order does not    matter.  The <symbol-types> subform is not evaluated.  This controls    which symbols accessible in a package are returned:        :INTERNAL  means the symbols that are present in the package,                   but which are not exported;        :EXTERNAL  means the symbols that are present and exported;        :INHERITED means the symbols that are exported by used packages                   and that are not shadowed.    When more than one argument is supplied for <symbol-types>, then a     symbol is returned if its accessibility matches any one of the     <symbol-types> specified.  WITH-PACKAGE-ITERATOR signals an error if     no <symbol-types> are specified or if a <symbol-type> not recognized     by the implementation is specified.  Implementations are permitted to     extend this syntax by recognizing additional symbol accessibility types.    An invocation (<next-fn>) returns four values as follows:        1. a boolean indicating whether a symbol is returned (T says yes)	2. a symbol (accessible in one the indicated packages)	3. the accessibility type for that symbol; i.e. one of	   :INTERNAL, :EXTERNAL, or :INHERITED	4. the package from which the symbol has been accessed.    After all symbols have been returned [by successive invocations of    (<next-fn>)], then only one value is returned, namely NIL.   The fourth return value is one of the packages present or named in the   <package-list> argument.  The meaning of the second, third, and fourth   values is that the returned symbol is accessible in the returned package   in the way indicated by the second return value:        :INTERNAL   ==>  present, and not exported,        :EXTERNAL   ==>  present, and exported,         :INHERITED  ==>  not present (thus not shadowed) but inherited                         from some used package.It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the WITH-...form (such as by returning some closure over the invocation form).Any number of invocations of with-hash-table-iterator andwith-package-iterator can be nested, and the body of the innermost onecan invoke all of the MACROLET'ed macros, provided all those macroshave distinct names.Examples:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-hash-table-iterator (hash-table)  (let ((all-entries '())        (generated-entries '())        (unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))             hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop             ;;Note -- this is the "trivial" LOOP of CLtL p121        (multiple-value-bind (more? key value) (generator-fn)          (unless more? (return))          (unless (eql value (gethash key hash-table unique))            (error "Key ~S not found for value ~S" key value))          (push (list key value) generated-entries))))    (unless (= (length all-entries)               (length generated-entries)               (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-package-iterator (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())        (generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility)           (find-symbol (symbol-name x) package)        (push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package                             :internal :external :inherited)      (loop             ;;Note -- this is the "trivial" LOOP of CLtL p121        (multiple-value-bind (more? symbol pkg accessibility)            (generator-fn)          (unless more? (return))          (let ((l (multiple-value-list (find-symbol (symbol-name symbol)                                                      package))))            (unless (equal l (list symbol accessibility))              (error "Symbol ~S not found as ~S in package ~A [~S]"                     symbol accessibility (package-name package) l))            (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)                 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))The following function prints out every interned symbol (possiblymore than once):(defun print-all-symbols ()   (with-package-iterator (next-symbol (list-all-packages)                          :internal :external)    (loop      ;;Note -- this is the "trivial" LOOP of CLtL p121      (multiple-value-bind (more? symbol) (next-symbol)        (if more?            (print symbol)           (return))))))The following could be an acceptable definition of the functionMAPHASH, implemented by WITH-HASH-TABLE-ITERATOR"(defun maphash (function hash-table)  (with-hash-table-iterator (next-entry hash-table)    (loop (multiple-value-bind (more key value) (next-entry)            (unless more (return nil))            (funcall function key value)))))Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.  Something like this is already beingdone by the standard package macros [CLtL, p187].Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.Of course, if an implementation _can_ support an indefinite extent fora "generator" object returned out of the iterator forms, it is allowed to do so by this proposal.The following macro definitions show how Common Lisp's DO-mumble-SYMBOLS macros could have been defined in terms of WITH-PACKAGE-ITERATOR.  They are intended as illustrative examples, not as new specifications of those built-in Common Lisp facilities. [PARSE-BODY is as defined in Guy Steele's "Clarifications" of 6-Dec-85.](defmacro do-symbols ((var &optional (package `*package*) result-form)                      &body body                       &environment env)   (multiple-value-bind (body decls docstring) (parse-body body env)    `(with-package-iterator (next-symbol (list ,package)                             :internal :external :inherited)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (setq ,var nil)             (return ,result-form))           ,@body)))))(defmacro do-external-symbols ((var &optional (package `*package*) result-form)                               &body body                                &environment env)   (multiple-value-bind (body decls docstring) (parse-body body env)    `(with-package-iterator (next-symbol (list ,package)                             :external)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (setq ,var nil)             (return ,result-form))           ,@body)))))(defmacro do-all-symbols ((var &optional result-form)                           &body body                           &environment env)   (multiple-value-bind (body decls docstring) (parse-body body env)    `(with-package-iterator (next-symbol (list-all-packages)                             :internal :external)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (setq ,var nil)             (return ,result-form))           ,@body)))))-------"Why not define <next-fn> as a local function as if defined by    FLET rather than a macro as if defined by MACROLET? ""A macro gave more scope to the implememtation to optimizewithout losing anything essential in these circumstances."        TITAN 
         TITAN 
           Z              
              y                                                 
             
             6       :      L       
                                 J                            	       
                     h                   6S "z*start*14255 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 12:13:30 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  11:45:17 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 DEC 88 11:32:56 PSTDate: 8 Dec 88 11:30 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: HASH-TABLE-PACKAGE-GENERATORS (Version 7)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881208-113256-4026@Xerox>!Forum:         CleanupIssue:         HASH-TABLE-PACKAGE-GENERATORSReferences:    Issue: DO-SYMBOLS-DUPLICATES Category:      ADDITIONEdit history:  Version 1, 23-May-88 JonL               Version 2,  6-Oct-88 JonL (convert to "with" scoping).               Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)               Version 4,  8-Nov-88 JonL (fix example; clarify some nits)               Version 5, 22-Nov-88 Moon (improve syntax for package iterator,                                          add examples, fix typos)               Version 6,  6-Oct-88 JonL (final nits)               Version 7,  8-Dec-88, Masinter (add comment to discussion)Problem description:The Iteration subcommittee would like the several iteration proposals to bewritable in portable Common Lisp code.  Unfortunately, the only completeaccess to hash-tables and packages is through MAPHASH and DO-SYMBOLS (andDO-EXTERNAL-SYMBOLS and DO-ALL-SYMBOLS); none of these existing primitives is satisfactory for building complex iteration clauses.  In particular,these primitives are fully packaged and do not allow control over theindividual operations of starting the iteration, stopping the iteration,and advancing to the next step of the iteration.Proposal (HASH-TABLE-PACKAGE-GENERATORS:ADD-WITH-WRAPPER)Add two new macros WITH-HASH-TABLE-ITERATOR and WITH-PACKAGE-ITERATOR to the language as follows:    WITH-HASH-TABLE-ITERATOR ((<next-fn> <hash-table>) &body body)      [Macro]    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return the items, one by one, from the hash-table which is obtained     by evaluating <hash-table> only once.    An invocation (<next-fn>) returns three values as follows:        1. a boolean indicating whether an entry is returned (T says yes)        2. the key item (of a <key, value> pair)        3. the value item (of a <key, value> pair)    After all entries have been returned [by successive invocations of    (<next-fn>)], then only one value is returned, namely NIL.    WITH-PACKAGE-ITERATOR ((<next-fn> <package-list>                    [Macro]                            &rest <symbol-types>)                           &body body)    Within the lexical scope of 'body', the name <next-fn> is defined    via MACROLET such that successive invocations of (<next-fn>) will     return symbols, one by one, from the packages that are elements    of the list which is obtained by evaluating <package-list> only once.      Each element of <package-list> can be a package or the name of a    package.    The order of symbols returned does not necessarily reflect the order    of packages in <package-list>.  When <package-list> has more than    one element, it is unspecified whether duplicate symbols are    returned once or more than once.  Even when <package-list> has only    one element, it is unspecified whether symbols inherited from    multiple packages are returned more than once.  See the proposal    DO-SYMBOLS-DUPLICATES:ALLOWED.    As a convenience, the value of <package-list> can be a package or    the name of a package; this is equivalent to a list of one element.    An argument of NIL is treated as an empty list of packages.    The <symbol-types> subform consists of one or more symbols from the    set {:INTERNAL, :EXTERNAL, :INHERITED}.  Their order does not    matter.  The <symbol-types> subform is not evaluated.  This controls    which symbols accessible in a package are returned:        :INTERNAL  means the symbols that are present in the package,                   but which are not exported;        :EXTERNAL  means the symbols that are present and exported;        :INHERITED means the symbols that are exported by used packages                   and that are not shadowed.    When more than one argument is supplied for <symbol-types>, then a     symbol is returned if its accessibility matches any one of the     <symbol-types> specified.  WITH-PACKAGE-ITERATOR signals an error if     no <symbol-types> are specified or if a <symbol-type> not recognized     by the implementation is specified.  Implementations are permitted to     extend this syntax by recognizing additional symbol accessibility types.    An invocation (<next-fn>) returns four values as follows:        1. a boolean indicating whether a symbol is returned (T says yes)	2. a symbol (accessible in one the indicated packages)	3. the accessibility type for that symbol; i.e. one of	   :INTERNAL, :EXTERNAL, or :INHERITED	4. the package from which the symbol has been accessed.    After all symbols have been returned [by successive invocations of    (<next-fn>)], then only one value is returned, namely NIL.   The fourth return value is one of the packages present or named in the   <package-list> argument.  The meaning of the second, third, and fourth   values is that the returned symbol is accessible in the returned package   in the way indicated by the second return value:        :INTERNAL   ==>  present, and not exported,        :EXTERNAL   ==>  present, and exported,         :INHERITED  ==>  not present (thus not shadowed) but inherited                         from some used package.It is unspecified what happens if any of the implicit interior state of an iteration is returned outside the dynamic extent of the WITH-...form (such as by returning some closure over the invocation form).Any number of invocations of with-hash-table-iterator andwith-package-iterator can be nested, and the body of the innermost onecan invoke all of the MACROLET'ed macros, provided all those macroshave distinct names.Examples:The following function should return T on any hash-table, and signalan error if the usage of 'with-hash-table-iterator' doesn't agreewith the corresponding usage of 'maphash'.(defun test-hash-table-iterator (hash-table)  (let ((all-entries '())        (generated-entries '())        (unique (list nil)))    (maphash #'(lambda (key value) (push (list key value) all-entries))             hash-table)    (with-hash-table-iterator (generator-fn hash-table)      (loop             ;;Note -- this is the "trivial" LOOP of CLtL p121        (multiple-value-bind (more? key value) (generator-fn)          (unless more? (return))          (unless (eql value (gethash key hash-table unique))            (error "Key ~S not found for value ~S" key value))          (push (list key value) generated-entries))))    (unless (= (length all-entries)               (length generated-entries)               (length (union all-entries generated-entries :test #'equal)))      (error "Generated entries and Maphash entries don't correspond"))    t))The following function should return T on any package, and signalan error if the usage of 'with-package-iterator' doesn't agreewith the corresponding usage of 'do-symbols'.(defun test-package-iterator (package)  (unless (packagep package)    (setq package (find-package package)))  (let ((all-entries '())        (generated-entries '()))    (do-symbols (x package)       (multiple-value-bind (symbol accessibility)           (find-symbol (symbol-name x) package)        (push (list symbol accessibility) all-entries)))    (with-package-iterator (generator-fn package                             :internal :external :inherited)      (loop             ;;Note -- this is the "trivial" LOOP of CLtL p121        (multiple-value-bind (more? symbol pkg accessibility)            (generator-fn)          (unless more? (return))          (let ((l (multiple-value-list (find-symbol (symbol-name symbol)                                                      package))))            (unless (equal l (list symbol accessibility))              (error "Symbol ~S not found as ~S in package ~A [~S]"                     symbol accessibility (package-name package) l))            (push l generated-entries)))))    (unless (and (subsetp all-entries generated-entries :test #'equal)                 (subsetp generated-entries all-entries :test #'equal))     (error "Generated entries and Do-Symbols entries don't correspond"))    t))The following function prints out every interned symbol (possiblymore than once):(defun print-all-symbols ()   (with-package-iterator (next-symbol (list-all-packages)                          :internal :external)    (loop      ;;Note -- this is the "trivial" LOOP of CLtL p121      (multiple-value-bind (more? symbol) (next-symbol)        (if more?            (print symbol)           (return))))))The following could be an acceptable definition of the functionMAPHASH, implemented by WITH-HASH-TABLE-ITERATOR"(defun maphash (function hash-table)  (with-hash-table-iterator (next-entry hash-table)    (loop (multiple-value-bind (more key value) (next-entry)            (unless more (return nil))            (funcall function key value)))))Rationale:The particular way in which hash-tables and packages are representedneed not be standardized, or even exposed to the user.  Yet a simpler handle on them is needed for the various iteration paradigms to be written in portable code.  In fact, after these iterator macros are put into an implementation, then MAPHASH and DO-<mumble>-SYMBOLS are trivial usages of them; but no _efficient_ use of the current primitives will provide the effect of the new macros, namely a form that _returns_ the elementsof a table "one by one".Current Practice:Nobody does it this way, but both Symbolics and Lucid are not far off.Cost to Implementors:Moderate.  Possibly a couple day's to a week's work for an implementation that has to start completely afresh.  Something like this is already beingdone by the standard package macros [CLtL, p187].Cost to Users:None.Benefits:Will provide a more basic primitive for iterating over hash-tables and packages; will permit new iteration paradigms to be written in portable code.Aesthetics:All other things being equal, it is better to have more general primitivesthan less general ones.  Discussion:The Iteration Subcommittee supports this proposal (or, "used to" -- JonL 6-Oct-88).One must be careful not to assume that the invocation (<next-fn>) is a "generator" function call -- since <next-fn> is MACROLET'd in an implementation dependent way, it could even turn into a special form like    (if something        (values nil)        (yet-another-function-call))The scoping called for herein may not be quite so useful to the "generators"style proposals; in particular they offer an interface wherein one may create a "generator" function of indefinite extent that returns, one-by-one,the elements of the table.  The constrained scoping implicit in theseWITH-... macros is not so much for any kind of optimization, but ratherfor coordination of such hash-table "locking" as may occur in multi-processing implementations like Symbolics.  Nevertheless, Dick Waters thinks these macros should be put in anyway, since it clearly is a requirement for a portable LOOP, and can be use in a limited context (i.e., not "indefinite scope") for portable versions of ITERATE and OSS.Of course, if an implementation _can_ support an indefinite extent fora "generator" object returned out of the iterator forms, it is allowed to do so by this proposal.The following macro definitions show how Common Lisp's DO-mumble-SYMBOLS macros could have been defined in terms of WITH-PACKAGE-ITERATOR.  They are intended as illustrative examples, not as new specifications of those built-in Common Lisp facilities. [PARSE-BODY is as defined in Guy Steele's "Clarifications" of 6-Dec-85.](defmacro do-symbols ((var &optional (package `*package*) result-form)                      &body body                       &environment env)   (multiple-value-bind (body decls docstring) (parse-body body env)    `(with-package-iterator (next-symbol (list ,package)                             :internal :external :inherited)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (setq ,var nil)             (return ,result-form))           ,@body)))))(defmacro do-external-symbols ((var &optional (package `*package*) result-form)                               &body body                                &environment env)   (multiple-value-bind (body decls docstring) (parse-body body env)    `(with-package-iterator (next-symbol (list ,package)                             :external)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (setq ,var nil)             (return ,result-form))           ,@body)))))(defmacro do-all-symbols ((var &optional result-form)                           &body body                           &environment env)   (multiple-value-bind (body decls docstring) (parse-body body env)    `(with-package-iterator (next-symbol (list-all-packages)                             :internal :external)       (let (more? ,var)         ,@decls         (loop           (unless (multiple-value-setq (more? ,var) (next-symbol))             (setq ,var nil)             (return ,result-form))           ,@body)))))-------"Why not define <next-fn> as a local function as if defined by    FLET rather than a macro as if defined by MACROLET? ""A macro gave more scope to the implememtation to optimizewithout losing anything essential in these circumstances."*start*01434 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 12:16:44 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  12:15:51 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 8 Dec 88 14:34:14 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 8 Dec 88 15:13:58 ESTDate: Thu, 8 Dec 88 15:14 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (Version 7)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881208-113256-4026@Xerox>Message-Id: <19881208201413.5.BARMAR@OCCAM.THINK.COM>    Date: 8 Dec 88 11:30 PST    From: cl-cleanup@sail.stanford.edu    !    Forum:         Cleanup    Issue:         HASH-TABLE-PACKAGE-GENERATORS    Edit history:  Version 1, 23-May-88 JonL		   Version 2,  6-Oct-88 JonL (convert to "with" scoping).		   Version 3,  7-Oct-88 JonL (mly's syntax for package iterator)		   Version 4,  8-Nov-88 JonL (fix example; clarify some nits)		   Version 5, 22-Nov-88 Moon (improve syntax for package iterator,					      add examples, fix typos)		   Version 6,  6-Oct-88 JonL (final nits)		   Version 7,  8-Dec-88, Masinter (add comment to discussion)How is it that Version 6 was written before Versions 3-5?                                                barmar*start*00993 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 16:18:35 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 9 Dec 88  16:17:04 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01902g; Fri, 9 Dec 88 16:14:28 PSTReceived: by bhopal id AA06950g; Fri, 9 Dec 88 16:16:24 PSTDate: Fri, 9 Dec 88 16:16:24 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812100016.AA06950@bhopal>To: barmar@Think.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Barry Margolin's message of Thu, 8 Dec 88 15:14 EST <19881208201413.5.BARMAR@OCCAM.THINK.COM>Subject: Issue: HASH-TABLE-PACKAGE-GENERATORS (Version 7)re: How is it that Version 6 was written before Versions 3-5?The date on version 6 is, of course, a typo -- it comes from the initial"revised" version (version 2) , as referenced in the discussion section.-- JonL --