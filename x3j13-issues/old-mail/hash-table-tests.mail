*start*04906 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 23:02:20 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 26 Sep 88  23:02:07 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00238g; Mon, 26 Sep 88 22:00:09 PSTReceived: by bhopal id AA03266g; Mon, 26 Sep 88 22:59:40 PDTDate: Mon, 26 Sep 88 22:59:40 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809270559.AA03266@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue HASH-TABLE-TESTSIssue: 		HASH-TABLE-TESTSReferences: 	CLtL, p382 (third paragraph), and p383            	Issue EQUAL-STRUCTURE		Issue: CONTAGION-ON-NUMERICAL-COMPARISONSCategory: 	AdditionEdit history:  	26-Sep-88 Version 1 by JonLProblem Description:A great many users try to coalesce two equivalent defstruct instances,or two equivalent pointer arrays, using hash tables; but they are rudelyawakened when they find out that EQUAL is not an appropriate test forthis case, and that there is no :test argument to MAKE-HASH-TABLE which will "hash on non-tree structures".Proposal: HASH-TABLE-TESTS:ADD-EQUALPWith the advent of the issue CONTAGION-ON-NUMERICAL-COMPARISONS, wecan expect EQUALP to be a true equivalence function, and thus a suitablecandidate for the :test function to MAKE-HASH-TABLE.   Hash-tables will come in four kinds, the difference being whether the keys are compared with EQ, EQL, EQUAL, or EQUALP.Examples:> (defstruct foo a b c)FOO> (setq x      (make-foo :a 1 :b 'b :c '(1 . 2))        x-copy (make-foo :a 1 :b 'b :c '(1 . 2)))#S(FOO A 1 B B C (1 . 2))> (setq y      #(1 B (1 . 2))        y-copy (copy-seq y))#(1 B (1 . 2))> (setq ht-equal  (make-hash-table :test 'equal)         ht-equalp (make-hash-table :test 'equalp))#<Hash-Table BB1F7B>> (progn (setf (gethash x ht-equal) t) (setf (gethash x ht-equalp) t)          (setf (gethash y ht-equal) t) (setf (gethash y ht-equalp) t))T> (gethash x-copy ht-equal)NILNIL> (gethash x-copy ht-equalp)TT> (gethash y-copy ht-equal)NILNIL> (gethash (copy-seq y) ht-equalp)TT> Rationale:	Implementing hash-tables efficiently is not an easy task; it makes moresense for this to be standardly available (implemented by the wizards at the Lisp vendor companies) than for individual programmers to keep tryingto re-invent this obscure part of technology.Current Practice:Lucid's release 3.0 implements this proposal [some 2.1-level releasesupported it "provisionally"].  Symbolics implementation is reputedto be robust enough to implement this proposal trivially.Cost to Implementors:Moderate.  Implementors have already dealt with EQUAL; the only tricky part will be ensuring the implication:    "If 'a' is EQUALP to 'b', then 'a' and 'b' must lie in the     same collision chain in any given EQUALP hash table"It has been suggested that merely linear searching a table is an acceptableimplementation technique for CL's hash-tables  [although no serious implementation limits itself thus] and that such tables have no "collision chains"; but in fact, this is the degenerate case wherein all entries are in the same collision chain, so the implication is trivially satisfied.Some persons prefer to say that the "reprobe sequence will be the same forthe two items", rather than using the term "collision chain"; the meaning is the same. Cost to Users:None.  This is an entirely upwards-compatible addition.Cost of non-adoption:Continuing bug reports from CL vendors' customers  about why "hashing doesn't work" when said customer tries entering pointer-containing objectsother than cons cells into hash tables.  Continuing delay in samecustomers work until they figure out a new strategy for identifyingequivalent structures.  More difficulty in debugging their alternatives.Benefits:Addresses one aspect of the difficult equivalence problem.  Makeshash tables usable with the major, remaining equivalence predicateof CL.  Also as a "side effect", permits case-insensitive hashingon strings [tables of type EQUAL are case-sensitive on strings]; another "side effect" is the abililty to use the CL numeric comparison"=" for numbers [tables of type EQUAL use EQL on numbers].Aesthetics:Reduces the discontinuity between basic equivalence functions and thoseusable as equivalence relations in hash-tables.Discussion:With the rejection of all the issues related to EQUAL-STRUCTURE, there is little or no hope that EQUAL will be "beefed up" to meet the expectationsof so many of the user community on compound structures.   If one wantsa hash-table with a :test function that has fewer equivalence classes (i.e.,  does more "coalescing"), then there is no alternative now except to use the function EQUALP.*start*00914 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 09:36:36 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Sep 88  09:36:37 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 466350; Tue 27-Sep-88 12:35:19 EDTDate: Tue, 27 Sep 88 12:35 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue HASH-TABLE-TESTS (Version 1)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <8809270559.AA03266@bhopal>Message-ID: <19880927163514.9.MOON@EUPHRATES.SCRC.Symbolics.COM>HASH-TABLE-TESTS:ADD-EQUALP is okay with me.  It needs to be madevery clear that this proposal cannot pass unless the proposal forCONTAGION-ON-NUMERICAL-COMPARISONS passes.*start*04490 00024 USfDate:  7 Oct 88 14:45 PDTFrom: masinter.paSubject: Issue HASH-TABLE-TESTS (Version 1)To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue: 		HASH-TABLE-TESTSReferences: 	CLtL, p382 (third paragraph), and p383            	Issue EQUAL-STRUCTURERequires Issue: CONTAGION-ON-NUMERICAL-COMPARISONSCategory: 	AdditionEdit history:  	26-Sep-88 Version 1 by JonLProblem Description:A great many users try to coalesce two equivalent defstruct instances,or two equivalent pointer arrays, using hash tables; but they are rudelyawakened when they find out that EQUAL is not an appropriate test forthis case, and that there is no :test argument to MAKE-HASH-TABLE which will "hash on non-tree structures".Proposal: HASH-TABLE-TESTS:ADD-EQUALPWith the advent of the issue CONTAGION-ON-NUMERICAL-COMPARISONS, wecan expect EQUALP to be a true equivalence function, and thus a suitablecandidate for the :test function to MAKE-HASH-TABLE.   Hash-tables will come in four kinds, the difference being whether the keys are compared with EQ, EQL, EQUAL, or EQUALP.Examples:> (defstruct foo a b c)FOO> (setq x      (make-foo :a 1 :b 'b :c '(1 . 2))        x-copy (make-foo :a 1 :b 'b :c '(1 . 2)))#S(FOO A 1 B B C (1 . 2))> (setq y      #(1 B (1 . 2))        y-copy (copy-seq y))#(1 B (1 . 2))> (setq ht-equal  (make-hash-table :test 'equal)         ht-equalp (make-hash-table :test 'equalp))#<Hash-Table BB1F7B>> (progn (setf (gethash x ht-equal) t) (setf (gethash x ht-equalp) t)          (setf (gethash y ht-equal) t) (setf (gethash y ht-equalp) t))T> (gethash x-copy ht-equal)NILNIL> (gethash x-copy ht-equalp)TT> (gethash y-copy ht-equal)NILNIL> (gethash (copy-seq y) ht-equalp)TT> Rationale:	Implementing hash-tables efficiently is not an easy task; it makes moresense for this to be standardly available (implemented by the wizards at the Lisp vendor companies) than for individual programmers to keep tryingto re-invent this obscure part of technology.Current Practice:Lucid's release 3.0 implements this proposal [some 2.1-level releasesupported it "provisionally"].  Symbolics implementation is reputedto be robust enough to implement this proposal trivially.Cost to Implementors:Moderate.  Implementors have already dealt with EQUAL; the only tricky part will be ensuring the implication:    "If 'a' is EQUALP to 'b', then 'a' and 'b' must lie in the     same collision chain in any given EQUALP hash table"It has been suggested that merely linear searching a table is an acceptableimplementation technique for CL's hash-tables  [although no serious implementation limits itself thus] and that such tables have no "collision chains"; but in fact, this is the degenerate case wherein all entries are in the same collision chain, so the implication is trivially satisfied.Some persons prefer to say that the "reprobe sequence will be the same forthe two items", rather than using the term "collision chain"; the meaning is the same. Cost to Users:None.  This is an entirely upwards-compatible addition.Cost of non-adoption:Continuing bug reports from CL vendors' customers  about why "hashing doesn't work" when said customer tries entering pointer-containing objectsother than cons cells into hash tables.  Continuing delay in samecustomers work until they figure out a new strategy for identifyingequivalent structures.  More difficulty in debugging their alternatives.Benefits:Addresses one aspect of the difficult equivalence problem.  Makeshash tables usable with the major, remaining equivalence predicateof CL.  Also as a "side effect", permits case-insensitive hashingon strings [tables of type EQUAL are case-sensitive on strings]; another "side effect" is the abililty to use the CL numeric comparison"=" for numbers [tables of type EQUAL use EQL on numbers].Aesthetics:Reduces the discontinuity between basic equivalence functions and thoseusable as equivalence relations in hash-tables.Discussion:With the rejection of all the issues related to EQUAL-STRUCTURE, there is little or no hope that EQUAL will be "beefed up" to meet the expectationsof so many of the user community on compound structures.   If one wantsa hash-table with a :test function that has fewer equivalence classes (i.e.,  does more "coalescing"), then there is no alternative now except to use the function EQUALP.*start*01410 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 15:32:07 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:21:52 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476014; Thu 13-Oct-88 18:20:27 EDTDate: Thu, 13 Oct 88 18:20 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-TESTS (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUSupersedes: <881013181904.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <881013182017.5.KMP@BOBOLINK.SCRC.Symbolics.COM>[One comment was left out of previous version of this message.]My notes from Fairfax meeting...X3J13 meeting: Barmar: Will the CONTAGION-ON-NUMERICAL-COMPARISON issue make = useable	 as a hash table key? [Some people said he could use EQUALP, but	 all agreed that that wouldn't be as perspicuous.] JonL: Hmmm, STRING= could be permitted, too. There was discussion of extending this proposal. People were mixed in their feelings about whether it was advisable to do that. JonL made some comment about how CLtL was ambiguous about what hash on EQ meant, but neither I (KMP) nor anyone sitting near me could figure out what he meant by this.*start*01256 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 16:20:21 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Nov 88  16:18:50 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 NOV 88 16:10:18 PSTDate: 14 Nov 88 16:09 PSTFrom: masinter.paSubject: Re: Issue: HASH-TABLE-TESTS (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881114-161018-2472@Xerox>I am less at ease about adding = and STRING= than I am about EQUALP.Certainly many other test functions could be added. However, given that weare only going to require a limited set, which ones should be required?So, why don't we leave the proposal as is, and merely note in thediscussion that these extensions are also a possibility but not included inthis proposal. Editorial notes: the description again says "vendor" for "implementor".Rather than arguing whether = is more "major" than EQUALP, it might besimpler to remove the claim that the proposal "Makes hash tables usablewith the major, remaining equivalence predicate" and stick to "Makes hashtables more useful."Change 'as a "side effect"' to "as a side benefit". *start*00642 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 16 NOV 88 15:25:22 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00907g; Wed, 16 Nov 88 15:24:21 PSTReceived: by bhopal id AA04765g; Wed, 16 Nov 88 15:22:46 PSTDate: Wed, 16 Nov 88 15:22:46 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811162322.AA04765@bhopal>To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 14 Nov 88 16:09 PST <881114-161018-2472@Xerox>Subject: Issue: HASH-TABLE-TESTS (Version 1)I like all you editorial changes -- why don't you just do them.-- JonL --*start*04897 00024 US Date:  8 Dec 88 15:06 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: HASH-TABLE-TESTS (Version 2)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noIssue: 		HASH-TABLE-TESTSReferences: 	CLtL, p382 (third paragraph), and p383            	Issue EQUAL-STRUCTURERequires Issue:   CONTAGION-ON-NUMERICAL-COMPARISONSCategory:         AdditionEdit history:  	26-Sep-88 Version 1 by JonL               	 8-Dec-88 Version 2 by Masinter				(as per cl-cleanup)Problem Description:A great many users try to coalesce two equivalent DEFSTRUCT instances,or two equivalent pointer arrays, using hash tables; but they are rudelyawakened when they find out that EQUAL is not an appropriate test forthis case, and that there is no :test argument to MAKE-HASH-TABLE which will "hash on non-tree structures".Proposal: HASH-TABLE-TESTS:ADD-EQUALPWith the advent of the issue CONTAGION-ON-NUMERICAL-COMPARISONS, wecan expect EQUALP to be a true equivalence function, and thus a suitablecandidate for the :test function to MAKE-HASH-TABLE.   Hash-tables will come in four kinds, the difference being whether the keys are compared with EQ, EQL, EQUAL, or EQUALP.Examples:> (defstruct foo a b c)FOO> (setq x      (make-foo :a 1 :b 'b :c '(1 . 2))        x-copy (make-foo :a 1 :b 'b :c '(1 . 2)))#S(FOO A 1 B B C (1 . 2))> (setq y      #(1 B (1 . 2))        y-copy (copy-seq y))#(1 B (1 . 2))> (setq ht-equal  (make-hash-table :test 'equal)         ht-equalp (make-hash-table :test 'equalp))#<Hash-Table BB1F7B>> (progn (setf (gethash x ht-equal) t) (setf (gethash x ht-equalp) t)          (setf (gethash y ht-equal) t) (setf (gethash y ht-equalp) t))T> (gethash x-copy ht-equal)NILNIL> (gethash x-copy ht-equalp)TT> (gethash y-copy ht-equal)NILNIL> (gethash (copy-seq y) ht-equalp)TT> Rationale:	Implementing hash-tables efficiently is not an easy task; it makes moresense for this to be standardly available than for individual programmers to keep trying to re-invent this obscure part of technology.Current Practice:Lucid's release 3.0 implements this proposal [some 2.1-level releasesupported it "provisionally"].  Symbolics implementation is reputedto be robust enough to implement this proposal trivially.Cost to Implementors:Moderate.  Implementors have already dealt with EQUAL; the only tricky part will be ensuring the implication:    "If 'a' is EQUALP to 'b', then 'a' and 'b' must lie in the     same collision chain in any given EQUALP hash table"It has been suggested that merely linear searching a table is an acceptableimplementation technique for CL's hash-tables  [although no serious implementation limits itself thus] and that such tables have no "collision chains"; but in fact, this is the degenerate case wherein all entries are in the same collision chain, so the implication is trivially satisfied.Some persons prefer to say that the "reprobe sequence will be the same forthe two items", rather than using the term "collision chain"; the meaning is the same. Cost to Users:None.  This is an entirely upwards-compatible addition.Cost of non-adoption:Continuing bug reports from users  about why "hashing doesn't work" when said user tries entering pointer-containing objectsother than cons cells into hash tables.  Continuing delay in sameuser's work until they figure out a new strategy for identifyingequivalent structures.  More difficulty in debugging their alternatives.Benefits:Addresses one aspect of the difficult equivalence problem.  Makeshash tables more useful.  Permits case-insensitive hashingon strings [tables of type EQUAL are case-sensitive on strings]; another use is to allow = comparison for numbers [tables of type EQUAL use EQL on numbers].Aesthetics:Reduces the discontinuity between basic equivalence functions and thoseusable as equivalence relations in hash-tables.Discussion:With the rejection of all the issues related to EQUAL-STRUCTURE, there is little or no hope that EQUAL will be "beefed up" to meet the expectationsof so many of the user community on compound structures.   If one wantsa hash-table with a :test function that has fewer equivalence classes (i.e.,  does more "coalescing"), then there is no alternative now except to use the function EQUALP.It would also be possible to extend hash tables to allow = orSTRING=, but those are not being proposed at this time.        TITAN 
         TITAN 
           Z                                   J              $              
              e             E       &      A       
      „              Ó              Æ                           ;             M       
                    {                   ¡ "zº*start*04861 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 15:41:21 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  15:24:30 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 08 DEC 88 15:11:34 PSTDate: 8 Dec 88 15:06 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: HASH-TABLE-TESTS (Version 2)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881208-151134-4673@Xerox>!Issue: 		HASH-TABLE-TESTSReferences: 	CLtL, p382 (third paragraph), and p383            	Issue EQUAL-STRUCTURERequires Issue:   CONTAGION-ON-NUMERICAL-COMPARISONSCategory:         AdditionEdit history:  	26-Sep-88 Version 1 by JonL               	 8-Dec-88 Version 2 by Masinter				(as per cl-cleanup)Problem Description:A great many users try to coalesce two equivalent DEFSTRUCT instances,or two equivalent pointer arrays, using hash tables; but they are rudelyawakened when they find out that EQUAL is not an appropriate test forthis case, and that there is no :test argument to MAKE-HASH-TABLE which will "hash on non-tree structures".Proposal: HASH-TABLE-TESTS:ADD-EQUALPWith the advent of the issue CONTAGION-ON-NUMERICAL-COMPARISONS, wecan expect EQUALP to be a true equivalence function, and thus a suitablecandidate for the :test function to MAKE-HASH-TABLE.   Hash-tables will come in four kinds, the difference being whether the keys are compared with EQ, EQL, EQUAL, or EQUALP.Examples:> (defstruct foo a b c)FOO> (setq x      (make-foo :a 1 :b 'b :c '(1 . 2))        x-copy (make-foo :a 1 :b 'b :c '(1 . 2)))#S(FOO A 1 B B C (1 . 2))> (setq y      #(1 B (1 . 2))        y-copy (copy-seq y))#(1 B (1 . 2))> (setq ht-equal  (make-hash-table :test 'equal)         ht-equalp (make-hash-table :test 'equalp))#<Hash-Table BB1F7B>> (progn (setf (gethash x ht-equal) t) (setf (gethash x ht-equalp) t)          (setf (gethash y ht-equal) t) (setf (gethash y ht-equalp) t))T> (gethash x-copy ht-equal)NILNIL> (gethash x-copy ht-equalp)TT> (gethash y-copy ht-equal)NILNIL> (gethash (copy-seq y) ht-equalp)TT> Rationale:	Implementing hash-tables efficiently is not an easy task; it makes moresense for this to be standardly available than for individual programmers to keep trying to re-invent this obscure part of technology.Current Practice:Lucid's release 3.0 implements this proposal [some 2.1-level releasesupported it "provisionally"].  Symbolics implementation is reputedto be robust enough to implement this proposal trivially.Cost to Implementors:Moderate.  Implementors have already dealt with EQUAL; the only tricky part will be ensuring the implication:    "If 'a' is EQUALP to 'b', then 'a' and 'b' must lie in the     same collision chain in any given EQUALP hash table"It has been suggested that merely linear searching a table is an acceptableimplementation technique for CL's hash-tables  [although no serious implementation limits itself thus] and that such tables have no "collision chains"; but in fact, this is the degenerate case wherein all entries are in the same collision chain, so the implication is trivially satisfied.Some persons prefer to say that the "reprobe sequence will be the same forthe two items", rather than using the term "collision chain"; the meaning is the same. Cost to Users:None.  This is an entirely upwards-compatible addition.Cost of non-adoption:Continuing bug reports from users  about why "hashing doesn't work" when said user tries entering pointer-containing objectsother than cons cells into hash tables.  Continuing delay in sameuser's work until they figure out a new strategy for identifyingequivalent structures.  More difficulty in debugging their alternatives.Benefits:Addresses one aspect of the difficult equivalence problem.  Makeshash tables more useful.  Permits case-insensitive hashingon strings [tables of type EQUAL are case-sensitive on strings]; another use is to allow = comparison for numbers [tables of type EQUAL use EQL on numbers].Aesthetics:Reduces the discontinuity between basic equivalence functions and thoseusable as equivalence relations in hash-tables.Discussion:With the rejection of all the issues related to EQUAL-STRUCTURE, there is little or no hope that EQUAL will be "beefed up" to meet the expectationsof so many of the user community on compound structures.   If one wantsa hash-table with a :test function that has fewer equivalence classes (i.e.,  does more "coalescing"), then there is no alternative now except to use the function EQUALP.It would also be possible to extend hash tables to allow = orSTRING=, but those are not being proposed at this time.