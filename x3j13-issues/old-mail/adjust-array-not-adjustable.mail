*start*04343 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 22 APR 87 13:55:37 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 22 Apr 87  13:51:32 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 122107; Wed 22-Apr-87 16:51:08 EDTDate: Wed, 22 Apr 87 16:51 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: ADJUST-ARRAY-NOT-ADJUSTABLETo: CL-Cleanup@SAIL.STANFORD.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <870422165116.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297)Category:     ENHANCEMENTEdit history: 22-Apr-87, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  The description of ADJUST-ARRAY on pp297-298 says that it is ``not permitted  to call ADJUST-ARRAY on an array that was not created with the :ADJUSTABLE  option.''Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:OK):  Change the definition of ADJUST-ARRAY to say that any array is a valid argument.  Say that if the array is not adjustable or if its old rank is not compatible  with the newly specified rank, then a new array will be created and returned.  In the case where a new array is returned, an implementation is permitted to  (but not required to) recycle the storage backing up that array if it is also  willing to do appropriate error checking to assure that AREFs to that array   will signal an error. In other words, the actual pointer to the array cannot  be reclaimed unless the compiler can prove that there are no pointers to it  and if the array is not reclaimed, references through it must not point to  recycled storage. [Note: I'm flexible on this, but it seems about right. I'm  patterning this after `dead arrays' in Maclisp. --KMP]  As with other destructive operations (most of which have names starting with  the letter "N"), users would be encouraged to use this for value wherever  possible and would be told that they can rely on the array to be adjusted  `for effect' only when it was adjustable and the new rank matched the old.Rationale:  ADJUST-ARRAY offers features which are offered by no other function and which  are useful in cases involving non-adjustable arrays (for what amounts to copying).  This change would allow an expression such as:    (SETQ X (ADJUST-ARRAY X ...))  to work reliably. Those desiring the old behavior could do:    (IF (OR (NOT (ADJUSTABLE-ARRAY-P X))	    (NOT (EQUAL (ARRAY-RANK X) (LENGTH NEW-DIMENSIONS))))        (ERROR "Array cannot be adjusted."))    to get the old style error checking.Current Practice:  Probably no one implements this extension.Adoption Cost:  Although this change is not trivial, it is localized and would probably not  require an excessive amount of work to install. Probably most of the necessary  routines already exist and it's just a matter of offering an interface.Benefits:  In cases where a user would want to adjust an array but the array is not  adjustable, he may well decide to try to simulate the contract of   ADJUST-ARRAY in copying the array. This can be tedious and may be error  prone. It would be better for such code to be written once, efficiently   and uniformly, and then offered to the user in a well-packaged way.Conversion Cost:  No correct user code currently tries to modify arrays which are   non-adjustable, so this change is technically upward compatible.  Some advanced code-walking tools which believe that this function   works only by side-effect would have to be modified very slightly  to know that its return value was of interest.Aesthetics:  I'm not sure how people's sense of aesthetics is affected by this.Discussion:  MACSYMA needed something like this.  If people don't like this, I could construct an alternate variation of  this proposal which involved the introduction of a new COPY-ARRAY   primitive that took an input array and some combination of the args  now allowed by MAKE-ARRAY and ADJUST-ARRAY. The variation above seemed  the simplest to me, but the presence of a COPY-ARRAY such as described  in this paragraph would also have satisfied my needs.*start*01413 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 23 APR 87 21:59:58 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 23 Apr 87  21:57:36 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 123694; Fri 24-Apr-87 00:57:35 EDTDate: Fri, 24 Apr 87 00:57 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: ADJUST-ARRAY-NOT-ADJUSTABLETo: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <870422165116.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <870424005727.9.MOON@EUPHRATES.SCRC.Symbolics.COM>The wording of your proposal is such that it implies that implementationsthat ignore the :ADJUSTABLE argument and simply make all arrays adjustablewould no longer be valid.  I doubt that you intended this.  Implementationsshould not be required to implement the non-adjustability complexity ifthey don't need it.Your comment about dead arrays is too obscure.Having ADJUST-ARRAY sometimes adjust the original array and sometimesmake a copy is dangerous.  I suppose it's no more dangerous thanNREVERSE and SORT, but we know that programmers from all walks of lifeconsistently have trouble using NREVERSE and SORT correctly.  I'd liketo see some thought given to improving the proposal to make it lessdangerous.*start*02664 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:edsel!bhopal!jonl@navajo.stanford.edu>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 24 APR 87 18:49:23 PDTReceived: from NAVAJO.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 24 Apr 87  18:46:54 PDTReceived: by navajo.stanford.edu; Fri, 24 Apr 87 17:46:11 PSTReceived: from bhopal.edsel.com by edsel.uucp (2.2/SMI-2.0)	id AA29466; Fri, 24 Apr 87 17:09:51 pstReceived: by bhopal.edsel.com (3.2/SMI-3.2)	id AA07893; Fri, 24 Apr 87 18:07:26 PDTDate: Fri, 24 Apr 87 18:07:26 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8704250107.AA07893@bhopal.edsel.com>To: navajo!Moon%STONY-BROOK.SCRC.Symbolics.COM@navajo.stanford.eduCc: navajo!CL-Cleanup%SAIL@navajo.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 24 Apr 87 00:57 EDTSubject: ADJUST-ARRAY-NOT-ADJUSTABLEThe complexity of this discussion about adjust-array makes me wonder if this function isn't striving for too much generality.   Virtually all usages I've seen or heard of are really for adjust-array-size.  KMP's proposal sounds like he's trying to avoid simply makeing a new array and copying (after some fashion) the old into the new.  Maybe it's a simpler language design not to try to cover every possible base, but to provide the primitives that permit end-users to "roll their own".  In line with your remarks:    Having ADJUST-ARRAY sometimes adjust the original array and sometimes    make a copy is dangerous.  I suppose it's no more dangerous than    NREVERSE and SORT, but we know that programmers from all walks of life    consistently have trouble using NREVERSE and SORT correctly.  I'd like    to see some thought given to improving the proposal to make it less    dangerous.How about the following simplification for adjust-array:  (1) a new function shall be added which will copy parts of the contents      of one array into another; MacLisp's FILLARRAY is a base-level start      for such a function, but one would like something for multi-dimensional       arrays that is more meaningful than simple linear, row-wise fill.  (2) adjust array will only "mess" with the size (or dimensions) and with      the displacement (i.e., to a new target array, or new index-offset).      Fill-pointers can already be modified with setf.  Getting new contents      into a displaced, "adjusted" array can be done by first calling the       function ARRAY-DISPLACED-P (as specified in GLS's "clarifications" of      6-Dec-85) and then using the function called for in (1) to copy parts      of the original displaced-to array into the newly-displaced one.-- JonL --*start*00968 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 MAY 87 19:49:39 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 1 May 87  19:47:18 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Fri 1 May 87 22:48:23-EDTDate: Fri, 1 May 87 22:48 EDTMessage-ID: <FAHLMAN.12299040692.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: ADJUST-ARRAY-NOT-ADJUSTABLEIn-reply-to: Msg of 22 Apr 1987  16:51-EDT from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>I don't like this proposed extension.  It seems confusing and dangerousto do the destructive operation in some cases and a copy in other cases.I think that I would be more comfortable with some sort of COPY-ARRAYfunction, though I'd need to see the details in order to be sure.-- Scott*start*00831 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 12:47:30 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  12:47:57 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475727; Thu 13-Oct-88 15:46:28 EDTDate: Thu, 13 Oct 88 15:46 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013154620.6.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Responsibility for writing next draft of this issue was delegated to KMP.*start*10425 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 NOV 88 14:37:36 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Nov 88  14:34:44 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 493022; Tue 15-Nov-88 17:34:53 ESTDate: Tue, 15 Nov 88 17:34 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Versions 2a,2b,2c)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881115173439.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Ok, three proposals follow. There isn't enough overlap for me to to bothertrying to  share their components. Please just vote for one or more andhopefully we can discard the unpopular ones as it becomes more clear whichthey are. I would hope that ultimately we can present a single proposalto X3J13, but I can't at this time figure out which that will be. -kmp-----Version 2a (ADJUST-ARRAY-NOT-ADJUSTABLE:IMPLICT-COPY)-----Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297)Category:     ADDITIONEdit history: 22-Apr-87, Version 1 by Pitman	      15-Nov-88, Version 2a by PitmanStatus:	      For Internal DiscussionProblem Description:  The description of ADJUST-ARRAY on pp297-298 says that it is ``not permitted  to call ADJUST-ARRAY on an array that was not created with the :ADJUSTABLE  option.''Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:IMPLICIT-COPY):  Change the definition of ADJUST-ARRAY to say that any array is a valid argument.  Say that if the array is not adjustable or if its old rank is not compatible  with the newly specified rank, then a new array will be created and returned.  In the case where the argument was not adjustable and a new array was returned,  an implementation is permitted to (but not required to) recycle the storage  backing up the original array. It is an error to continue to use an array  which was not adjustable.  As with other destructive operations (most of which have names starting with  the letter "N"), are encouraged to use this for value wherever possible and  would be told that they can rely on the array to be adjusted `for effect'  only when it was adjustable and the new rank matched the old.Rationale:  ADJUST-ARRAY offers features which are offered by no other function and which  are useful in cases involving non-adjustable arrays (for what amounts to copying).  This change would allow an expression such as:    (SETQ X (ADJUST-ARRAY X ...))  to work reliably. Those desiring the old behavior could do:    (IF (OR (NOT (ADJUSTABLE-ARRAY-P X))	    (NOT (EQUAL (ARRAY-RANK X) (LENGTH NEW-DIMENSIONS))))	(ERROR "Array cannot be adjusted."))    to get the old style error checking.Current Practice:  Probably no one implements this extension.Adoption Cost:  Although this change is not trivial, it is localized and would probably not  require an excessive amount of work to install. Probably most of the necessary  routines already exist and it's just a matter of offering an interface.Benefits:  In cases where a user would want to adjust an array but the array is not  adjustable, he may well decide to try to simulate the contract of   ADJUST-ARRAY in copying the array. This can be tedious and may be error  prone. It would be better for such code to be written once, efficiently   and uniformly, and then offered to the user in a well-packaged way.  Some implementations have implementation-specific array attributes.  A COPY-ARRAY program written in Common Lisp cannot correctly copy  arrays with implementation-dependent attributes, but the implicit array  copying feature described here could preserve such attributes. As such,  this feature could help Common Lisp code to be more compatible with  native data objects.Conversion Cost:  No correct user code currently tries to modify arrays which are   non-adjustable, so this change is technically upward compatible.  Some advanced code-walking tools which believe that this function   works only by side-effect would have to be modified very slightly  to know that its return value was of interest.Aesthetics:  Some people think this change is unaesthetic because it loses  potential error checking.  Some people think the whole notion of :ADJUSTABLE is unaesthetic,  and so this change improves aesthetics.  Some people worry that a delete like the `DELETE bug' (failure to  SETQ the array back) might lead to confusion. For that reason, they  find this change unaesthetic.Discussion:  MACSYMA needed something like this.-----Version 2b (ADJUST-ARRAY-NOT-ADJUSTABLE:SIGNAL-ERROR)-----Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297)Category:     CLARIFICATION/CHANGEEdit history: 22-Apr-87, Version 1 by Pitman	      15-Nov-88, Version 2b by PitmanStatus:	      For Internal DiscussionProblem Description:  The description of ADJUST-ARRAY on pp297-298 says that it is ``not permitted  to call ADJUST-ARRAY on an array that was not created with the :ADJUSTABLE  option.''Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:SIGNAL-ERROR):  Change the definition of ADJUSTABLE-ARRAY-P to say that it will return T  if and only if the array was created with :ADJUSTABLE T.  Change the definition of ADJUST-ARRAY to say that it will signal an error  if and only if the array to be adjusted was not created with :ADJUSTABLE T.Rationale:  Although implementations such as Genera which make adjustable arrays  even when :ADJUSTABLE NIL is specified (or when not :ADJUSTABLE option  is specified) are within the letter of the law, many argue that they  are not within the spirit of the law. They argue that this `feature'  just reduces error checking. The failure of ADJUST-ARRAY to recognize  arrays which were not explicitly requested to be adjustable leads to  portability problems when moving to other implementations which do not  support this feature.  Many users do not expect to have to do (SETQ X (ADJUST-ARRAY X ...)) when  adjusting an array. If they expect ADJUST-ARRAY to work by side-effect,  serious problems might be introduced by the IMPLICIT-COPY option above.Current Practice:  Symbolics Genera is incompatible with this proposal (though not with CLtL).  Many implementations implement this proposal.Adoption Cost:  Some implementations may not have enough bits in their current  array representation to represent the :ADJUSTABLE option. This may be  true of Symbolics Genera -- I don't think anyone's done a full study of  all array types on all processor types in order to prove  whether this change is feasible or not.Benefits:  Portability of programs using ADJUST-ARRAY between some implementations  is improved.Conversion Cost:  None to portable code. This change is technically upward compatible.  Note however, that some implementation-specific code is affected  adversely since :ADJUSTABLE T options would have to be added to some  calls to MAKE-ARRAY in order to accomodate a more restrictive  ADJUST-ARRAY.Aesthetics:  Some people think this change is very aesthetic because it increases  the amount of error checking which can be done by ADJUST-ARRAY.  Some people find the kind of error checking done by ADJUST-ARRAY to  be gratuitous because they think the whole notion of :ADJUSTABLE is  unaesthetic. To them, any attempt to enforce adjustability is an intrusion.Discussion:  None yet.-----Version 2c (ADJUST-ARRAY-NOT-ADJUSTABLE:SIGNAL-ERROR+NEW-FUNCTION)-----Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297)Category:     CLARIFICATION/CHANGE/ADDITIONEdit history: 22-Apr-87, Version 1 by Pitman	      15-Nov-88, Version 2c by PitmanStatus:	      For Internal DiscussionProblem Description:  The description of ADJUST-ARRAY on pp297-298 says that it is ``not permitted  to call ADJUST-ARRAY on an array that was not created with the :ADJUSTABLE  option.''Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:SIGNAL-ERROR+NEW-FUNCTION):  Change the definition of ADJUSTABLE-ARRAY-P to say that it will return T  if and only if the array was created with :ADJUSTABLE T.  Change the definition of ADJUST-ARRAY to say that it will signal an error  if and only if the array to be adjusted was not created with :ADJUSTABLE T.  Introduce a function COPY-ARRAY which is like ADJUST-ARRAY which treats  its arguments like COPY-ARRAY but which always produces a new array rather  than modifying the original array.Rationale: Current Practice:  Symbolics Genera is incompatible with the part of this proposal which  deals with ADJUST-ARRAY (though not with the analogous part of CLtL).  Many other implementations are already compatible with that part of  this proposal.  Probably no one implements COPY-ARRAY.Adoption Cost:  Some implementations may not have enough bits in their current  array representation to represent the :ADJUSTABLE option. This may be  true of Symbolics Genera -- I don't think anyone's done a full study of  all array types on all processor types in order to prove  whether this change is feasible or not.Benefits:  Some implementations have implementation-specific array attributes.  A COPY-ARRAY program written in Common Lisp cannot correctly copy  arrays with implementation-dependent attributes, but a COPY-ARRAY  function could. As such, the presence of COPY-ARRAY would help  Common Lisp code to be more compatible with native data objects.Conversion Cost:  None to portable code. This change is technically upward compatible.  Note however, that some implementation-specific code is affected  adversely since :ADJUSTABLE T options would have to be added to some  calls to MAKE-ARRAY in order to accomodate a more restrictive  ADJUST-ARRAY.Aesthetics:  Some people think this change is very aesthetic because it increases  the amount of error checking which can be done by ADJUST-ARRAY.  Some people find the kind of error checking done by ADJUST-ARRAY to  be gratuitous because they think the whole notion of :ADJUSTABLE is  unaesthetic. To them, any attempt to enforce adjustability is an intrusion.Discussion:  MACSYMA needed something like this.*start*00893 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 NOV 88 15:10:55 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 15 Nov 88  15:09:51 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA00972; Tue, 15 Nov 88 18:08:27 ESTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA07151; Tue, 15 Nov 88 18:12:22 ESTMessage-Id: <8811152312.AA07151@mist.UUCP>To: Kent M Pitman <KMP%STONY-BROOK.SCRC.Symbolics.COM@multimax.encore.com>Cc: CL-Cleanup%SAIL.Stanford.EDU@Multimax.encore.comSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Versions 2a,2b,2c) In-Reply-To: Your message of Tue, 15 Nov 88 17:34:00 -0500.Date: Tue, 15 Nov 88 18:12:20 ESTFrom: Dan L. Pierson <pierson@mist.ARPA>I mildly prefer IMPLICT-COPY.*start*01753 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 NOV 88 10:54:50 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 16 Nov 88  10:52:47 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 493547; Wed 16-Nov-88 13:52:46 ESTDate: Wed, 16 Nov 88 13:52 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Versions 2a,2b,2c)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881115173439.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19881116185239.5.MOON@EUPHRATES.SCRC.Symbolics.COM>I strongly oppose ADJUST-ARRAY-NOT-ADJUSTABLE:SIGNAL-ERROR andADJUST-ARRAY-NOT-ADJUSTABLE:SIGNAL-ERROR+NEW-FUNCTION, since they wouldbreak an existing implementation (Genera) by forcing it to enforce the:ADJUSTABLE keyword for all arrays.  Currently Genera includes theextension that all non-displaced arrays are adjustable (on Ivory, displacedarrays are also adjustable).  There may be other implementations withsimilar extensions.  Such a change would probably break large numbersof user programs that were never intended to be portable and don'tbother with the :ADJUSTABLE keyword.I haven't seen any good reason for this change; the only argument offeredis an argument that would forbid all extensions of any kind -- the argumentis that any program that uses an extension cannot be ported to animplementation that lacks the extension.I mildly favor ADJUST-ARRAY-NOT-ADJUSTABLE:IMPLICIT-COPY, although Ithink I would be just as happy with the status quo.*start*03141 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 NOV 88 18:56:24 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 20 Nov 88  18:54:50 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 20 Nov 88 21:53:06 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Versions 2a,2b,2c) In-reply-to: Your message of Tue, 15 Nov 88 17:34:00 -0500.             <881115173439.7.KMP@BOBOLINK.SCRC.Symbolics.COM> Date: Sun, 20 Nov 88 21:52:46 ESTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUA few comments on KMP's triple-barrelled proposal:First, the problem statement says:  The description of ADJUST-ARRAY on pp297-298 says that it is ``not permitted  to call ADJUST-ARRAY on an array that was not created with the :ADJUSTABLE  option.''That's just a statement of fact.  It doesn't give the reader any clear ideawhat we think the problem is.I'm strongly opposed to the IMPLICIT-COPY option.  For users ofimplementations that have non-adjustable arrays and that therefore do thecopy, this change would be very treacherous.  If the user is holding on toold pre-adjustment array, things could start to fail in very mysterious andconfusing ways.  We get lots of spurious bug reports from users who screwthemselves by calling DELETE without doing the SETQ, despite all ourwarnings.  This would bite fewer people, but might be harder to diagnosewhen it did bite them.  And since code written on Symbolics systems, forexample, would work fine without the SETQ, it would bite people at the timeof a port to a standard architecture, often when the original author of thecode is not readily available for consultation.I've got no strong objection to the SIGNAL-ERROR proposal, but if I were aSymbolics-only user whose code was going to be broken by this, I might wellobject.Of the three options offered, I prefer SIGNAL-ERROR+NEW-FUNCTION, but againI think this might bother users who are living happily under the currentsystem.  Also, a minor point, I think the new function should not be calledCOPY-ARRAY if in fact it does adjustment.  It would be clearer to call itFORCE-ADJUST-ARRAY or something like that.  Better still, we could just adda :FORCE keyword arg to ADJUST-ARRAY that, if non-null, says to do the copyin the case of receiving a non-adjustable array; the default value would beNIL.There's a fourth option we might want to consider: it would be likeSIGNAL-ERROR+NEW-FUNCTION, but implementations are only required to signalthe error in cases where they are unable to return an adjusted array thatis EQ to the old one.  If they can manage to adjust the array and returnit, they are allowed to do so, regardless of whether it was created withthe ADJUSTABLE keyword.  This would not break existing code in systemswhere all arrays are adjustable, but would signal a nice solidnon-mysterious error when this code is ported to a different system.-- Scott*start*02886 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 NOV 88 19:49:48 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Nov 88  19:48:42 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00964g; Mon, 21 Nov 88 19:46:24 PSTReceived: by bhopal id AA15102g; Mon, 21 Nov 88 19:45:10 PSTDate: Mon, 21 Nov 88 19:45:10 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811220345.AA15102@bhopal>To: Scott.Fahlman@B.GP.CS.CMU.EDUCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Sun, 20 Nov 88 21:52:46 EST <8811210257.AA03776@lucid.com>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Versions 2a,2b,2c) re: First, the problem statement says:      The description of ADJUST-ARRAY on pp297-298 says that it is       ``not permitted to call ADJUST-ARRAY on an array that was not       created with the :ADJUSTABLE option.''    That's just a statement of fact.  It doesn't give the reader any clear idea    what we think the problem is.I for one don't think there is anything wrong with that "statement offact".  But since Symbolics' array implementation has always been indirect violation of this prescription, we must assume that they (andKent in particular) feel that adjustability must not be "an option" --that it must be required of all arrays.Lucid will oppose any measures to make adjustablility required of all arrays.  This is precisly the one place where a good compiler on "stock hardware" must have some options for creating and using a subclass of arrays competitively with "Conventional" computer lanugages [note that "Conventional" begins with a "C"].  CL's SIMPLE-ARRAYs are that subclass;and SIMPLE implies "not adjustable" because, regardless of whether ornot ADJUST-ARRAY returns a copy, there is no way to modify such low-overhead arrays as per CLtL 297 [special-purpose hardware systems can do so however, by using "invisible pointers"].Incidentally, Lucid has a function SYS:COPY-ARRAY which does just that-- it makes a copy preserving all the array's attributes; thus I toowould not like to see this name taken for some ersatz ADJUST-ARRAY.  Lucid implements (ADJUST-ARRAY-NOT-ADJUSTABLE:SIGNAL-ERROR).There was one aspect of your "fourth option" suggestion that bears some thought.  Suppose we made the default value of the :adjustable argument to MAKE-ARRAY be implementation-dependent?  That way, when adjustabilitycomes "for free", the user might as well have it.  But if the user***explicitly*** passes in the :adjustable argument as NIL, thenhe ought to be able to check out portable code that way [i.e., findout just where he may trying to adjust a "non-adjustable" array.]-- JonL --*start*04118 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 NOV 88 22:53:15 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Nov 88  22:51:48 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496430; Tue 22-Nov-88 01:51:41 ESTDate: Tue, 22 Nov 88 01:51 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Versions 2a,2b,2c)To: jonl@lucid.comcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8811220345.AA15102@bhopal>Message-ID: <881122015109.9.KMP@BOBOLINK.SCRC.Symbolics.COM>fyi, KMP does -not- want all arrays to be adjustable, and would preferstrong checking -- ie, signal of error required when attempting to adjustan array not declared adjustable.arguably, this is because KMP has a lot of experience in trying to portprograms where this happened to be a problem and he wants not to have suchproblems recur for himself or anyone else. further, KMP does not currentlymaintain any programs which would be hurt by this change, so doesn't worryabout the cost of upgrading his code.in contrast, Symbolics (a company with financial investment in a particularinterpretation of the topic in question) would have to reimplement a bunchof stuff at considerable expense, and would have to (arguably gratuitously)break its users' code.the symbolics view is not that all arrays must be adjustable, by the way.the symbolics view is that we recognize that in some implementations thatis too expensive even though in ours it is not. as such, from the localperspective, :adjustable is present so that portable code can specify whicharrays need the greater overhead for the sake of implementations which mustdistinguish. adjustable-array-p does not predicate whether the array wascreated with :adjustable t, it predicates whether the array is adjustable.nothing in CLtL specifies that omitting :adjustable or specifying :adjustable nil means you can't make the array adjustable. as such, symbolics makes all arrays (except for a -very- few) adjustable but you canalways reliably detect which arrays will be adjustable by calling adjustable-array-p (if you don't know the array's lineage from context),and you can always force an array to be adjustable in the first place bydoing :adjustable t. this is a fully consistent point of view that is notin conflict with CLtL. you may be sad that this loophole is there, but iassure you that it is no perverse reading of CLtL that led to thisinterpretation. it is my belief that if there is confusion it is becausepeople had differing views on what :adjustable was about when they went intowriting CLtL and the wording was frobbed to make everyone happy withoutbeing explicit about why that particular wording made everyone happy.it's a case of a situation where person A thinks that everything is eitherblack or white and person B does not. person A describes a frob as Black.person B, thinking frobs are really gray says "couldn't we just say it'snot white?" person A, thinking this is the same thing, says "sure." andvoila, person A and person B both have their model of the world supported,they both agree that frobs are not white, but yet they have -- in some othersense -- not really agreed.this is a lot of what the `explicitly vague' issues are about. just to makethe disagreement visible to the reader, so that people from neither camp willlater be surprised by the discrepancies which are bound to arise fromdiffering world models.and, getting back to the original subject, other companies have usedextraordinary expense as a show-stopper on other issues. even though idisagree with moon from an abstract point of view on this, i certainlythink it's both fair and appropriate for him to characterize my favoritealternative as unreasonably expensive for symbolics, and i hope everyonewill give that position its due consideration.*start*01386 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 15:04:41 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 22 Nov 88  15:03:32 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01845g; Tue, 22 Nov 88 15:01:42 PSTReceived: by bhopal id AA16647g; Tue, 22 Nov 88 15:00:25 PSTDate: Tue, 22 Nov 88 15:00:25 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811222300.AA16647@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Tue, 22 Nov 88 01:51 EST <881122015109.9.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Versions 2a,2b,2c)Hmmm, that's a most interesting view!Still, I would very much like to hear you opinion on my suggestion for away out of the "loophole" conflict; namely, allow the default setting ofthe of :adjustable argument to MAKE-ARRAY to be implementation-dependent.That way, we could maintain portability on what the :adjustable argument means (i.e. NIL means "Not Adjustable").   Symbolics' users would likely have no code broken, since the Symbolics default setting would be justbe :adjustable = T.  (Does any user *ever* explicitly supply a NIL for this argument?).-- JonL --*start*02680 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 15:41:51 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Nov 88  15:37:18 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496895; Tue 22-Nov-88 18:36:48 ESTDate: Tue, 22 Nov 88 18:37 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Versions 2a,2b,2c)To: jonl@lucid.comcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8811222300.AA16647@bhopal>Message-ID: <881122183700.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Tue, 22 Nov 88 15:00:25 PST    From: Jon L White <jonl@lucid.com>    ... I would very much like to hear you opinion on my suggestion for a    way out of the "loophole" conflict; namely, allow the default setting of    the of :adjustable argument to MAKE-ARRAY to be implementation-dependent.    That way, we could maintain portability on what the :adjustable argument     means (i.e. NIL means "Not Adjustable").   Symbolics' users would likely     have no code broken, since the Symbolics default setting would be just    be :adjustable = T.  (Does any user *ever* explicitly supply a NIL for     this argument?).I don't usually supply :ADJUSTABLE NIL only because I know that's the default.If you made the default implementation-dpeendent, I would have to supply ita whole lot more than I do now. I recently spent a lot of time going throughsome code of mine removing the need for ``:ADJUSTABLE T'' (ie, implicitlymaking things ``:ADJUSTABLE NIL'' in order to incur less overhead in someimplementations to which I needed to be porting).So I don't think what you're suggesting would be the easy solution you suggestbecause any way you cut it, if you make NIL really mean not adjustable, thenyou make Genera not compatible. We just don't have that bit allocated right nowand it's fairly possible that there's no room to add it. So you'd be breakingus fairly badly under any scheme which required the distinction, regardless ofthe default.In terms of perceived breakage, your strategy might reduce the initialperception of a problem because initially people's code would seem to run wellsince most people don't have :ADJUSTABLE NIL explicitly in their code, but you'dfind that some code didn't run as efficiently when ported as it used to (and thatwould be bad!) and so people would start to add :ADJUSTABLE NIL, and so theproblem would gradually become more visible.*start*07808 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 DEC 88 02:24:48 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Dec 88  02:23:36 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 501647; Fri 2-Dec-88 05:23:29 ESTDate: Fri, 2 Dec 88 05:23 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881202052314.9.KMP@BOBOLINK.SCRC.Symbolics.COM>Since there was some criticism of the problem statement, I fixed that.Since there was no agreement on which way to go, I decided to take theconservative approach and just justify the status quo. This proposalis very different than any of the previous versions.-----Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),	      MAKE-ARRAY (pp286-289)Category:     CLARIFICATION/CHANGEEdit history: 22-Apr-87, Version 1 by Pitman	      15-Nov-88, Versions 2a,2b,2c by Pitman	      02-Dec-88, Version 3 by PitmanStatus:	      For Internal DiscussionProblem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  Some of the original Common Lisp designers assert that the  :ADJUSTABLE option exists in order to allow a user to select  between getting adjustable and non-adjustable arrays.    Others of the original Common Lisp designers assert that the  :ADJUSTABLE option existed to permit implementations in which  making all arrays adjustable was very expensive to make some  arrays not adjustable.  The former camp therefore believes that :ADJUSTABLE NIL means  that the array MUST be non-adjustable. The latter camp believes  that :ADJUSTABLE NIL means that the array MIGHT be non-adjustable.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' Although this sentence  is slightly ambiguous (one might argue that :ADJUSTABLE NIL  involves supplying the :ADJUSTABLE option), it is generally  interpreted to mean that ``... with :ADJUSTABLE T.''   One problem is that since ADJUSTABLE-ARRAY-P does not predicate  whether the :ADJUSTABLE option was provided, then  ADJUSTABLE-ARRAY-P is not an appropriate predicate in all  implementations to determine whether an array is adjustable.  Technically, :ADJUSTABLE NIL could create and adjustable array  (one for which ADJUSTABLE-ARRAY-P returns true), and yet   ADJUST-ARRAY might refuse to adjust it (if it had recorded a  separate bit saying whether :ADJUSTABLE T had been specified  and used that bit for ADJUST-ARRAY). Fortunately, this problem  has not been observed to occur in practice, but it is present  in principle.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY. That expectation is violated by  legitimate implementations, since it is permissible for an   implementation to create an adjustable array even though it has  not been asked for, and since calling adjust array on such an  array "is an error" (and hence the behavior can be extended).  This perceived lack of error checking may become a legitimate  portability error to someone who has debugged his code in a   an implementation where :ADJUSTABLE NIL arrays might still be  adjustable and then tried ported his code to an implementation  which is more conservative in its interpretation.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:STATUS-QUO):  Document clearly that omitting the :ADJUSTABLE option to MAKE-ARRAY  or explicitly supplying :ADJUSTABLE NIL may not guarantee a non-adjustable  array. ADJUSTABLE-ARRAY-P MUST be true of an array created using  :ADJUSTABLE T, and MIGHT be true of an array created with no :ADJUSTABLE  option or with :ADJUSTABLE NIL.  Change the description of ADJUST-ARRAY to say that the effect of  adjusting an array which "is not adjustable" (vs "was not created with  the :ADJUSTABLE option")  is not defined.  Clarify that this legitimizes ADJUSTABLE-ARRAY-P an appropriate predicate  to determine whether ADJUST-ARRAY will reliably succeed.  Define that if ADJUSTABLE-ARRAY-P of the array given to ADJUST-ARRAY is  false, then an error must be signalled.Rationale:  This effectively makes the status quo explicit.  While changing this to a tighter interpretation would be desirable, some  implementations have suggested that such a change might be very expensive  or impossible given their existing data storage layouts.  Although technically the changes to ADJUST-ARRAY are incompatible changes  from the spec, it's not believed that there are any implementations which  deviate, so we're still categorizing this as a clarification.Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and is compatible with this proposal.  Symbolics Cloe makes :ADJUSTABLE NIL arrays non-adjustable in all cases,  and is compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.Discussion:  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.*start*07808 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 DEC 88 02:24:48 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Dec 88  02:23:36 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 501647; Fri 2-Dec-88 05:23:29 ESTDate: Fri, 2 Dec 88 05:23 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881202052314.9.KMP@BOBOLINK.SCRC.Symbolics.COM>Since there was some criticism of the problem statement, I fixed that.Since there was no agreement on which way to go, I decided to take theconservative approach and just justify the status quo. This proposalis very different than any of the previous versions.-----Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),	      MAKE-ARRAY (pp286-289)Category:     CLARIFICATION/CHANGEEdit history: 22-Apr-87, Version 1 by Pitman	      15-Nov-88, Versions 2a,2b,2c by Pitman	      02-Dec-88, Version 3 by PitmanStatus:	      For Internal DiscussionProblem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  Some of the original Common Lisp designers assert that the  :ADJUSTABLE option exists in order to allow a user to select  between getting adjustable and non-adjustable arrays.    Others of the original Common Lisp designers assert that the  :ADJUSTABLE option existed to permit implementations in which  making all arrays adjustable was very expensive to make some  arrays not adjustable.  The former camp therefore believes that :ADJUSTABLE NIL means  that the array MUST be non-adjustable. The latter camp believes  that :ADJUSTABLE NIL means that the array MIGHT be non-adjustable.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' Although this sentence  is slightly ambiguous (one might argue that :ADJUSTABLE NIL  involves supplying the :ADJUSTABLE option), it is generally  interpreted to mean that ``... with :ADJUSTABLE T.''   One problem is that since ADJUSTABLE-ARRAY-P does not predicate  whether the :ADJUSTABLE option was provided, then  ADJUSTABLE-ARRAY-P is not an appropriate predicate in all  implementations to determine whether an array is adjustable.  Technically, :ADJUSTABLE NIL could create and adjustable array  (one for which ADJUSTABLE-ARRAY-P returns true), and yet   ADJUST-ARRAY might refuse to adjust it (if it had recorded a  separate bit saying whether :ADJUSTABLE T had been specified  and used that bit for ADJUST-ARRAY). Fortunately, this problem  has not been observed to occur in practice, but it is present  in principle.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY. That expectation is violated by  legitimate implementations, since it is permissible for an   implementation to create an adjustable array even though it has  not been asked for, and since calling adjust array on such an  array "is an error" (and hence the behavior can be extended).  This perceived lack of error checking may become a legitimate  portability error to someone who has debugged his code in a   an implementation where :ADJUSTABLE NIL arrays might still be  adjustable and then tried ported his code to an implementation  which is more conservative in its interpretation.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:STATUS-QUO):  Document clearly that omitting the :ADJUSTABLE option to MAKE-ARRAY  or explicitly supplying :ADJUSTABLE NIL may not guarantee a non-adjustable  array. ADJUSTABLE-ARRAY-P MUST be true of an array created using  :ADJUSTABLE T, and MIGHT be true of an array created with no :ADJUSTABLE  option or with :ADJUSTABLE NIL.  Change the description of ADJUST-ARRAY to say that the effect of  adjusting an array which "is not adjustable" (vs "was not created with  the :ADJUSTABLE option")  is not defined.  Clarify that this legitimizes ADJUSTABLE-ARRAY-P an appropriate predicate  to determine whether ADJUST-ARRAY will reliably succeed.  Define that if ADJUSTABLE-ARRAY-P of the array given to ADJUST-ARRAY is  false, then an error must be signalled.Rationale:  This effectively makes the status quo explicit.  While changing this to a tighter interpretation would be desirable, some  implementations have suggested that such a change might be very expensive  or impossible given their existing data storage layouts.  Although technically the changes to ADJUST-ARRAY are incompatible changes  from the spec, it's not believed that there are any implementations which  deviate, so we're still categorizing this as a clarification.Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and is compatible with this proposal.  Symbolics Cloe makes :ADJUSTABLE NIL arrays non-adjustable in all cases,  and is compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.Discussion:  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.*start*02766 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 DEC 88 22:49:56 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 6 Dec 88  22:41:03 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00906g; Tue, 6 Dec 88 22:38:29 PSTReceived: by bhopal id AA11552g; Tue, 6 Dec 88 22:40:23 PSTDate: Tue, 6 Dec 88 22:40:23 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812070640.AA11552@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Fri, 2 Dec 88 05:23 EST <881202052314.9.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3)I am strongly opposed to this proposal.  It is not documenting thestatus quo, but rather tries to resolve a bitter debate by fiat!The proposal claims the following as the status quo:  Document clearly that omitting the :ADJUSTABLE option to MAKE-ARRAY  or explicitly supplying :ADJUSTABLE NIL may not guarantee a non-adjustable  array. ADJUSTABLE-ARRAY-P ...  MIGHT be true of an array created with   no :ADJUSTABLE option or with :ADJUSTABLE NIL.This may be the Symbolics 3600 status quo (and TI Explorer); but no otherimplementation I'm aware of takes this variant view of CLtL.  Consideringthe strong, though not unanimous,  opposition  to making all arrays adjustable, I don't see how you can expect to resolve the debate simplymaking such a statement.Why not just admit that the intent of simple arrays was to accommodate the needs of "stock" hardware implementations?  Thus remembered, no one could mistake the intent for SIMPLE-ARRAYs -- that they be non-adjustable.Indeed, why create such an arbitrary type subset if it were only of theoretical interest?  [Remember also the "RPG Memorial Array" proposal.]  Then this whole disingenuous re-reading of the history of adjustable arrays and "loopholes" in CLtL could be dropped; and Symbolics could simply say something like:    "Symbolics extends Common Lisp ARRAY functionality in an improved,     but technically incompatible, way." That simple, frank statement would make everybody much more comfortable(especially 3600 user's who wonder why their code doesn't port), and would finally close the debate so that we don't have to waste yet more and more time on it.   [Yes, I'm aware that Symbolics would have to face persistent demands from some of their users to "come into compliance"; but it's much more likely that you can make satisfactory explanations to these customers than that you can convince the "stock hardware" types to swallow universal adjustability.]-- JonL --*start*03402 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 15:32:31 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 7 Dec 88  14:10:06 PSTDate: Wed, 7 Dec 88 13:41:44 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3)To: jonl@LUCID.COMcc: IIM@ECLA.USC.EDU, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8812070640.AA11552@bhopal>Message-ID: <12452601261.24.IIM@ECLA.USC.EDU>> Date: Tue, 6 Dec 88 22:40:23 PST> From: Jon L White <jonl@lucid.com>Perhaps I'm misunderstanding where your objections are coming from.  If theyare based on implementation issues, then I don't see the problem (see below).If you don't want to allow the kind of extension that Symbolics and othershave made because of porting issues or some such thing, that's something elseentirely, and my comments below don't address your objections at all.I really don't understand your opposition to the latest proposal (STATUS-QUO).I don't see anything in it that would imply that all arrays must be adjustablein all Common Lisp implementations.  It has always been my understanding thatthe :adjustable argument had the following meaning::ADJUSTABLE T  The implementation is required to return an array representation which it is  capable of adjusting, using adjust-array.:ADJUSTABLE NIL  The implementation is given license to return an array representation which  is not adjustable, in the interest of efficiency.  This is the default  because it is the most commonly used case, thus avoiding the requirement  that programmers explicitely supply it all over the place in order to get  a possibly efficiency improvement.> Document clearly that omitting the :ADJUSTABLE option to MAKE-ARRAY> or explicitly supplying :ADJUSTABLE NIL may not guarantee a non-adjustable> array. ADJUSTABLE-ARRAY-P ...  MIGHT be true of an array created with > no :ADJUSTABLE option or with :ADJUSTABLE NIL.The paragraph above, which you quoted from the proposal, seems to me to be anattempt to make it clear that specifying :adjustable NIL only permits anon-adjustable representation be returned, but does not guarantee that theobject returned will be non-adjustable.  This sounds like a pretty goodcharacterization of current practice to me.  Symbolics makes all arraysadjustable because they can do so for free, while stock hardwareimplementations are free to use specialized non-adjustable representationsunless the programmer specifically requests otherwise.Note that IIM Common Lisp implements ADJUST-ARRAY-NOT-ADJUSTABLE:SIGNAL-ERROR.However, I am opposed to making this be the required behavior, in part becauseof the significant incompatability with current practice and in part becausethe Symbolics "extension" really doesn't seem all that unreasonable to me, soI'm reluctant to say that it shouldn't be permitted.  (I use quotes because,strictly speaking, I don't consider it to be an extension.  Rather, I think itis a particular implementation which falls within the range of behaviorspecified by CLtL).I am strongly opposed to ADJUST-ARRAY-NOT-ADJUSTABLE:IMPLICIT-COPY, forreasons that others have stated pretty well, so I won't repeat them here.(See Fahlman's response, for example).kab-------*start*04306 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 23:38:46 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 9 Dec 88  23:37:49 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02995g; Fri, 9 Dec 88 23:35:15 PSTReceived: by bhopal id AA07690g; Fri, 9 Dec 88 23:37:12 PSTDate: Fri, 9 Dec 88 23:37:12 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812100737.AA07690@bhopal>To: IIM@ECLA.USC.EDUCc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: Kim A. Barrett's message of Wed 7 Dec 88 13:41:44-PST <12452601261.24.IIM@ECLA.USC.EDU>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3)re: [an] attempt to make it clear that specifying :adjustable NIL only permits    a non-adjustable representation be returned, but does not guarantee that     the object returned will be non-adjustable.  This sounds like a pretty     good characterization of current practice to me. I thought I made my opposition clear enough -- that the Symbolics "status quo" is not the status quo for the community at large; their "extension" is not one that is fully compatible with (the obvious reading of) CLtL.In particular, the part that of the proposal that suggests that         (make-arry n :adjustable nil)can legitimately return an adjustable array flies in the face of thevery reason reason why the type SIMPLE-ARRAY was introduced into CommonLisp in the first place!  Listen very carefully to those implementingLisp on stock hardware -- ask if they think it is perfectly fine to**** have no way whatsoever *** to guarantee getting a non-adjustable array.The history you might be missing is that, from the very beginning,  some folks from the "special purpose Lisp machine" companies  opposed the compromise to admit SIMPLE-ARRAYs.  It makes one factor of "stock hardware"efficiency visible in the language itself.  I called their re-reading of CLtL on this point disingenuous, because there is no precedent whatsoever for the alleged loophole whereby the English phrases:    "... [an array that] is not to have its size adjusted dynamically     after creation is called a simple array."     [p.28]    "If make-array is called with the :adjustable [option] ... not supplied      or  NIL, then the resulting array is guaranteed to be a simple array."      [p.289]    "It is not permitted to call ADJUST-ARRAY on an array that was     not created with the :ADJUSTABLE option"  [p.297]can mean just the opposite of what the are evidently saying.  In contrast,  -- p.28 evidently says that a simple array *must not* be adjustable.  -- p.289 evidently says that "not supplying" the adjustable option is a      required part of *** the only way specified *** for makeing a simple      array  [supplying NIL is the same as "not supplying"].  -- p.297 evidently implies the converse, that a non-NIL value must be      supplied to MAKE-ARRAY, as the :ADJUSTABLE option, in order to be able      to dynamically adjust the result.I think this language of CLtL, p.28, p.289, and p.297 is adequately clear.  One might ask for additional clarifying statements, but it should be obvious to just about anyone that if the :ADJUSTABLE argument/option could belegitimately ignored, then *** an explicit statement to the effect *** would have been put somewhere in the text.  I can even hazard a guess as to why p.297 says "created with the :ADJUSTABLE option", rather than saying "created by supplying a non-NIL value for the :ADJUSTABLE argument".   Many Lisp Machine functions and macros would permit the user to specify some alternative simply by includinga certain keyword in a list of options; DEFSTRUCT still has this style of syntax (see CLtL p.311).   At one point in time, someone working on thetext that became CLtL considered adjustability an "option" for arrays, which could simply be specified by supplying the :ADJUSTABLE argument;only later did we notice that &keyword arguments are not by themselves"options", but rather "named arguments".  Clearly,    (make-array n :adjustable t)supplies the :adjustable option, whereas   (make-array n :adjustable nil)does not supply it.-- JonL ---*start*01430 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 DEC 88 06:55:35 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 10 Dec 88  06:55:04 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 10 Dec 88 09:44:20 ESTTo: Jon L White <jonl@lucid.com>cc: IIM@ECLA.USC.EDU, cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3) In-reply-to: Your message of Fri, 09 Dec 88 23:37:12 -0800.             <8812100737.AA07690@bhopal> Date: Sat, 10 Dec 88 09:43:55 ESTFrom: Scott.Fahlman@B.GP.CS.CMU.EDULike JONL, I found it a bit irritating that this proposal was presented asmerely clarifying the "obvious" status quo.  It is indeed the status quothat certain vendors make all arrays adjustable; however, I don't think itis universally agreed that this is altogether legal, given astraightforward reading of CLtL.But despite these reservations about how the issue is presented, I thinkthat something like this proposal is the right thing to do, so I supportthe substance of the proposal.  At this point, our goal should be to avoidbreaking huge amounts of existing code, while clarifying what is legal andproviding as much support and error checking as possible for people portingcode from one world to the other.-- Scott*start*02238 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 09:30:10 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 12 Dec 88  09:29:22 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA00368; Mon, 12 Dec 88 12:28:03 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA10750; Mon, 12 Dec 88 11:34:43 ESTMessage-Id: <8812121634.AA10750@mist.>To: Jon L White <jonl@lucid.com>Cc: IIM@ECLA.USC.EDU, cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3) In-Reply-To: Your message of Fri, 09 Dec 88 23:37:12 -0800.             <8812100737.AA07690@bhopal> Date: Mon, 12 Dec 88 11:34:39 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    I thought I made my opposition clear enough -- that the Symbolics "status     quo" is not the status quo for the community at large; their "extension"     is not one that is fully compatible with (the obvious reading of) CLtL.    In particular, the part that of the proposal that suggests that             (make-arry n :adjustable nil)    can legitimately return an adjustable array flies in the face of the    very reason reason why the type SIMPLE-ARRAY was introduced into Common    Lisp in the first place!  Listen very carefully to those implementing    Lisp on stock hardware -- ask if they think it is perfectly fine to    **** have no way whatsoever *** to guarantee getting a    non-adjustable array.     While I agree with you here, I would like to point out that theposition you are taking here strikes me as being the opposite of yourposition on REQUIRE-PATHNAME-DEFAULTS.  In both cases, the status quoallows careful programmers to write portable code as in:    - Never adjust a "non-adjustable" array    - Never use REQUIRE in a context that would cause file loadingThe, quite legitimate, objection to the status quo is that it makes it_very_ likely that programmers, being human and fallible, willaccidently wind up producing non-portable code because the currentversions of these features lack adaquate (read any) portable errorchecking. *start*09243 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 DEC 88 21:12:14 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Dec 88  21:11:04 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 508226; Wed 14-Dec-88 00:10:13 ESTDate: Wed, 14 Dec 88 00:09 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3)To: jonl@lucid.comcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8812070640.AA11552@bhopal>Message-ID: <881214000958.8.KMP@BOBOLINK.SCRC.Symbolics.COM>Disclaimer: The contents of this note are my personal opinion and not	    necessarily the opinion of Symbolics.Summary: I'm quite upset by this message of JonL's, not because of its	 technical position, but because of the lack of personal respect	 JonL has shown for my technical position. This message has some	 technical content, and therefore I want it in the CL-Cleanup	 archives, but its primary content is political, emotional, and	 personal. As such, recipients other than JonL shouldn't treat it	 as high priority reading.-----    Date: Tue, 6 Dec 88 22:40:23 PST    From: Jon L White <jonl@lucid.com>    ...     This may be the Symbolics 3600 status quo (and TI Explorer); but no other    implementation I'm aware of takes this variant view of CLtL.  Considering    the strong, though not unanimous,  opposition  to making all arrays     adjustable, I don't see how you can expect to resolve the debate simply    making such a statement.Status quo has, to the best of my knowledge, always been taken in ourdiscussions to mean "what is implemented", not "what is understood by anelite group of people who designed CLtL in the first place". We have usuallyreserved the phrase "what was intended" to refer to what people might havehad in mind, and we might debate what was intended, but as far as I'mconcerned there is never any debate on the status quo.I discount from the status quo only obvious violations (eg, an implementationfails to support bignums) where no defensible reading of the manual will cover.I count for the status quo -any- implementation for which there is a passagein CLtL which the implementors claim to have faithfully interpreted and whichthey have made a financial investment in.I did not question the validity of someone's claim that Choral had implementedNCONC as APPEND. They claim this was a mere bug, but if they hadn't, I wouldhave been willing to accept it as the "status quo" (even if not "what wasintended") because they can probably find text to back it up.If you take a different view of the status quo, you should go back to Mathis orthat nice lady who on the first day of X3J13 gave us a lesson on the legalitiesof X3J13 and the dangers of claiming to be able to "interpret" CLtL. You'dbetter be -very- careful not to make any public statements of the form"Implementation X is not conforming because of ..." unless you're prepared tocite written text (not popular myth) to back yourself up or you may find yourselfin court backing up such slanderous claims. Such, at least, was their contention,and I'm inclined to believe they were right to warn us thus.It is not the business of this committee to retroactively invalidate good faithimplementations of CLtL. If we want to make tougher standards, we can do so onlyby making a new standard which is more rigorously defined.    Why not just admit that the intent of simple arrays was to accommodate     the needs of "stock" hardware implementations?I admitted this already.    Thus remembered, no one could mistake the intent for SIMPLE-ARRAYs -- that    they be non-adjustable. Not so. Our collective recollection is that you were -permitted- (not -required-)to make them be non-adjustable.    Indeed, why create such an arbitrary type subset if it were only of     theoretical interest?  [Remember also the "RPG Memorial Array" proposal.]  It isn't only of theoretical interest. It's clearly a bug that ADJUSTABLE-ARRAY-Pdoesn't predicate whether ADJUST-ARRAY will work. That should just be fixed.It's not clear that it's a bug that the effect of doing :ADJUSTABLE NILwas not specified. There are plenty of useful applications that derivefrom the interpretation we support.    Then this whole disingenuous Excuse me, but this kind of thing really pisses me off. This adjective has noplace in any discussion of this sort and if I see it again I will disinvolvemyself with this and perhaps any further discussion.We could not be more up front and sincere: We have said some people here believethe wording is as it is for a reason. The reason, while not popular -- I don'teven like it personally -- is completely defensible from a technical standpointand not subject to any kind of common sense arguments that there was "only onepossible interpretation". There may have been only one "obvious interpretation"but on inspection you should be willing (as am I) to agree, at least reluctantly,that this is a valid point of view -- if for no other reason because peoplewhom you hopefully respect have asserted that it is a valid point of view.In general, my rule of thumb for what is ambiguous is anything for which allparties cannot be convinced, through discussion, is not ambiguous. This is,if one party thinks something is ambiguous and one party thinks it is not, thenby (my) definition, it is ambiguous. The only exceptions are extreme cases wherewhere the individual claiming ambiguity can be demonstrated to have insufficientcommand of the issue (eg, hairy floating point stuff) or insufficient commandof the English language; I assert that on this issue, I have neither of thesedeficiencies, and that my claim of ambiguity is generous.    re-reading of the history of adjustable     arrays and "loopholes" in CLtL could be dropped; and Symbolics could     simply say something like:	"Symbolics extends Common Lisp ARRAY functionality in an improved,	 but technically incompatible, way." It is your burden to demonstrate that it is incompatible. I have citedspecific passages with which you might quibble about "original intent" butyou cannot quibble about "technically compatible". In point of fact, we arewithin the letter of the stated rules, and we have cited reasons I've said over and over that I don't happen to personally like the Symbolics [Genera] interpretation (Cloe's interpretation is different :-), but I thinkthey/we are within their/our rights to claim it.    That simple, frank statement would make everybody much more comfortable    (especially 3600 user's who wonder why their code doesn't port), and     would finally close the debate so that we don't have to waste yet more     and more time on it.Don't hold your breath. It's just not as simple as that. There are really major issues of compatibility and QA that we have to deal with, and the expense forus would probably not be small.Besides, the Cloe development environment (which is what I and many othershere recommend for people porting code out to other environments) does offerthe interpretation you suggest.    [Yes, I'm aware that Symbolics would have to face     persistent demands from some of their users to "come into compliance";     but it's much more likely that you can make satisfactory explanations to     these customers than that you can convince the "stock hardware" types to     swallow universal adjustability.]I don't see why either of these extremes is necessary. I'm not advocatingthat stock hardware swallow universal adjustability and I'm asking them notto force this change on us.Virtually every other vendor has at one time or another indicated that someproposed change would be prohibitively expensive. We have generally treatedsuch claims with respect. Rarely has anyone had the gall to suggest that theyshould just bite the bullet and accept an enormous incompatible change or"just declare themselves to be incompatible" (a dangerous trend). In general,such proposals have stopped dead in their tracks until/unless someone couldpropose a serious way around the difficulty -- and "just declare yourself tobe incompatible" has never been an avenue open to us before. I am awestruckthat you could suggest this.If you want to disagree with our proposal on technical grounds, that's fine.But keep in mind that compatibility with existing code, transition cost, etc.are legitimate concerns applied in every other proposal writeup and we'refully entitled to assert that this is a proposal of major cost to us. I think, too, we're within our rights to ask for a little respect from theother members of CL-Cleanup when we assert such a position.I personally would like to see the tighter definition you'd like to see,but given the potential expenses involved, I see nothing disingenuousabout my having described the status quo as I did, and nothingunreasonable about my having suggested that this is our only viablealternative.*start*01762 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 DEC 88 13:15:40 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 15 Dec 88  13:15:16 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00434g; Thu, 15 Dec 88 13:11:36 PSTReceived: by bhopal id AA19775g; Thu, 15 Dec 88 13:13:34 PSTDate: Thu, 15 Dec 88 13:13:34 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812152113.AA19775@bhopal>To: pierson@mist.encore.comCc: IIM@ECLA.USC.EDU, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: Dan L. Pierson's message of Mon, 12 Dec 88 11:34:39 EST <8812121634.AA10750@mist.>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3) re: In both cases, the status quo    allows careful programmers to write portable code as in:	- Never adjust a "non-adjustable" array	- Never use REQUIRE in a context that would cause file loading    The, quite legitimate, objection to the status quo is that it makes it    _very_ likely that programmers, being human and fallible, will    accidently wind up producing non-portable code because the current    versions of these features lack adaquate (read any) portable error    checking. The problem with the Symbolics implementation (as conveyed to us bythose inside symbolics) is that there is *** no place available ***in an array to remember the :adjustable option.  Hence it is not atrivial option for them to accommodate to the "Lucid status quo".However, the "compromise" proposal for REQUIRE would expose a global variable to make inhibition of vendor-specific extensions possible.This would be trivial in anybody's implementation.-- JonL --*start*01429 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 22:48:02 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Jan 89  22:45:31 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 06 JAN 89 11:48:01 PSTDate: 6 Jan 89 11:37 PSTFrom: masinter.paSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 3)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 2 Dec 88 05:23 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.eduMessage-ID: <890106-114801-253@Xerox>I'd like to see the following changes to the proposal:a) I don't like saying that the effect of adjusting an array which "is notadjustable" is not defined. I don't see any reason not to say that itsignals an error. b) I like defining clearly that "is not adjustable" means"ADJUSTABLE-ARRAY-P returns false", and clarifying that MAKE-ARRAY mayreturn an adjustable array even if the :ADJUSTABLE array is given NIL.c) I would like to say that either all arrays are adjustable, or else onlythose that are specified with :ADJUSTABLE true, and that a conformalimplementation will document which behavior it uses.d) Rename the proposal name from "STATUS-QUO" to "MAY-BE-ADJUSTABLE" andchange  "Document clearly" to "Specify". Is this OK?*start*10367 00024 USfReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 11 JAN 89 08:58:16 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 519251; Wed 11-Jan-89 11:57:21 ESTDate: Wed, 11 Jan 89 11:57 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 4)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.eduIn-Reply-To: <890106-114801-253@Xerox>Message-ID: <890111115708.4.KMP@BOBOLINK.SCRC.Symbolics.COM>A new proposal follows this initial commentary...Current practice is ammended for Lucid and IIM. Please check foraccuracy.The proposal is ammended per my responses to the following mailfrom Larry:    Date: 6 Jan 89 11:37 PST    From: masinter.pa@Xerox.COM    I'd like to see the following changes to the proposal:    a) I don't like saying that the effect of adjusting an array which "is not    adjustable" is not defined. I don't see any reason not to say that it    signals an error. It actually said this already (last paragraph), but it also had aconflicting paragraph which I removed. Please check the result to see thatit is coherent.    b) I like defining clearly that "is not adjustable" means    "ADJUSTABLE-ARRAY-P returns false", and clarifying that MAKE-ARRAY may    return an adjustable array even if the :ADJUSTABLE array is given NIL.Right. I think I made this more clear.    c) I would like to say that either all arrays are adjustable, or else only    those that are specified with :ADJUSTABLE true, and that a conformal    implementation will document which behavior it uses.I think this complicates the user model because it suggests that there isadvantage to be had from knowing that all arrays are adjustable. I can'timagine any serious way in which a truly portable program could takeadvantage of this information even if we could guarantee it.In fact, though, the Symbolics implementation makes -most- but not allarrays adjustable. There are some odd situations involving displaced arrayswhere I'm told the arrays are not adjustable. So we couldn't be conforming ifyou did this. I therefore made no change.    d) Rename the proposal name from "STATUS-QUO" to "MAY-BE-ADJUSTABLE" and    change  "Document clearly" to "Specify". It wasn't clear what the noun was in "may be adjustable", so I avoided thisname and tried to pick a name that had no connotations at all: DONKEY.(Surely there's no chance anyone will even think to connect the spirit ofthis proposal or the character of its author with derogatory synonyms,stubborn animals, or Massachusetts liberal democrats... :-) Anyway, hopefullythis will avoid wasted discussion on a supposedly semantics-free symbol.    Is this OK?Except for item C, I think I've done the best I could. Proposal follows...-----Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),	      MAKE-ARRAY (pp286-289)Category:     CLARIFICATION/CHANGEEdit history: 22-Apr-87, Version 1 by Pitman	      15-Nov-88, Versions 2a,2b,2c by Pitman	      02-Dec-88, Version 3 by Pitman	      11-Jan-89, Version 4 by PitmanStatus:	      For Internal DiscussionProblem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  Some of the original Common Lisp designers assert that the  :ADJUSTABLE option exists in order to allow a user to select  between getting adjustable and non-adjustable arrays.    Others of the original Common Lisp designers assert that the  :ADJUSTABLE option existed to permit implementations in which  making all arrays adjustable was very expensive to make some  arrays not adjustable.  The former camp therefore believes that :ADJUSTABLE NIL means  that the array MUST be non-adjustable. The latter camp believes  that :ADJUSTABLE NIL means that the array MIGHT be non-adjustable.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' Although this sentence  is slightly ambiguous (one might argue that :ADJUSTABLE NIL  involves supplying the :ADJUSTABLE option), it is generally  interpreted to mean that ``... with :ADJUSTABLE T.''   One problem is that since ADJUSTABLE-ARRAY-P does not predicate  whether the :ADJUSTABLE option was provided, then  ADJUSTABLE-ARRAY-P is not an appropriate predicate in all  implementations to determine whether an array is adjustable.  Technically, :ADJUSTABLE NIL could create and adjustable array  (one for which ADJUSTABLE-ARRAY-P returns true), and yet   ADJUST-ARRAY might refuse to adjust it (if it had recorded a  separate bit saying whether :ADJUSTABLE T had been specified  and used that bit for ADJUST-ARRAY). Fortunately, this problem  has not been observed to occur in practice, but it is present  in principle.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY. That expectation is violated by  legitimate implementations, since it is permissible for an   implementation to create an adjustable array even though it has  not been asked for, and since calling adjust array on such an  array "is an error" (and hence the behavior can be extended).  This perceived lack of error checking may become a legitimate  portability error to someone who has debugged his code in a   an implementation where :ADJUSTABLE NIL arrays might still be  adjustable and then tried ported his code to an implementation  which is more conservative in its interpretation.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:DONKEY):  Define that omitting the :ADJUSTABLE option to MAKE-ARRAY or  explicitly supplying :ADJUSTABLE NIL may not guarantee a  non-adjustable array.  Define that ADJUSTABLE-ARRAY-P -must- be true of an array created  using :ADJUSTABLE T.  Define that ADJUSTABLE-ARRAY-P -might- be true of an array created  with no :ADJUSTABLE option or with :ADJUSTABLE NIL, but that it  -might- return false.  Clarify that the implication of the above is that saying that an  array A "is adjustable" means that (ADJUSTABLE-ARRAY-P A) => true.  Further clarify that the adjustability of an array has no necessary  relation to any value was given (or not given) as the :ADJUSTABLE  option in the call to MAKE-ARRAY which created the array A.  Clarify that there is no portable way to create a non-adjustable  array (that is, an array for which ADJUSTABLE-ARRAY-P is  guaranteed to return false).  Change the description of ADJUST-ARRAY to say that if an attempt  is made to adjust an array which is not adjustable (that is, an  array for which ADJUSTABLE-ARRAY-P would return false), an error  will be signalled.  Clarify that this legitimizes ADJUSTABLE-ARRAY-P as an appropriate  predicate to determine whether ADJUST-ARRAY will reliably succeed.Rationale:  This effectively makes the status quo explicit.  While changing this to a tighter interpretation would be desirable, some  implementations have suggested that such a change might be very expensive  or impossible given their existing data storage layouts.  Although technically the changes to ADJUST-ARRAY are incompatible changes  from the spec, it's not believed that there are any implementations which  deviate, so we're still categorizing this as a clarification.Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and are compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.Discussion:  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.*start*00913 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 11 JAN 89 16:22:00 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 519783; Wed 11-Jan-89 19:21:23 ESTDate: Wed, 11 Jan 89 19:21 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 4)To: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <890111-141158-10579@Xerox>Message-ID: <890111192114.4.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 11 Jan 89 14:11 PST    From: masinter.pa@Xerox.COM    Who is DON and why does he need a KEY?Well, ok, I guess I was wrong in thinking no one would inspect the namefurther... :-)Just trying to keep the discussion as light as possible in the heat ofthe battle on this one.*start*08112 00024 US Date: 12 Jan 89 01:02 PSTSender: masinter.paSubject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 4)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinterline-fold: NoThere was debate over the meaning of the phrase"status quo" an whether this proposal reflected it. It wasn't a very useful debate. I hope we can avoid moreof it. Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),	      MAKE-ARRAY (pp286-289)Category:     CLARIFICATION/CHANGEEdit history: 22-Apr-87, Version 1 by Pitman	      15-Nov-88, Versions 2a,2b,2c by Pitman	      02-Dec-88, Version 3 by Pitman	      11-Jan-89, Version 4 by PitmanProblem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  Some of the original Common Lisp designers assert that the  :ADJUSTABLE option exists in order to allow a user to select  between getting adjustable and non-adjustable arrays.    Others of the original Common Lisp designers assert that the  :ADJUSTABLE option existed to permit implementations in which  making all arrays adjustable was very expensive to make some  arrays not adjustable.  The former camp therefore believes that :ADJUSTABLE NIL means  that the array MUST be non-adjustable. The latter camp believes  that :ADJUSTABLE NIL means that the array MIGHT be non-adjustable.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' Although this sentence  is slightly ambiguous (one might argue that :ADJUSTABLE NIL  involves supplying the :ADJUSTABLE option), it is generally  interpreted to mean that ``... with :ADJUSTABLE T.''   One problem is that since ADJUSTABLE-ARRAY-P does not predicate  whether the :ADJUSTABLE option was provided, then  ADJUSTABLE-ARRAY-P is not an appropriate predicate in all  implementations to determine whether an array is adjustable.  Technically, :ADJUSTABLE NIL could create and adjustable array  (one for which ADJUSTABLE-ARRAY-P returns true), and yet   ADJUST-ARRAY might refuse to adjust it (if it had recorded a  separate bit saying whether :ADJUSTABLE T had been specified  and used that bit for ADJUST-ARRAY). Fortunately, this problem  has not been observed to occur in practice, but it is present  in principle.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY. That expectation is violated by  legitimate implementations, since it is permissible for an   implementation to create an adjustable array even though it has  not been asked for, and since calling adjust array on such an  array "is an error" (and hence the behavior can be extended).  This perceived lack of error checking may become a legitimate  portability error to someone who has debugged his code in a   an implementation where :ADJUSTABLE NIL arrays might still be  adjustable and then tried ported his code to an implementation  which is more conservative in its interpretation.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:DONKEY):  Define that omitting the :ADJUSTABLE option to MAKE-ARRAY or  explicitly supplying :ADJUSTABLE NIL may not guarantee a  non-adjustable array.  Define that ADJUSTABLE-ARRAY-P -must- be true of an array created  using :ADJUSTABLE T.  Define that ADJUSTABLE-ARRAY-P -might- be true of an array created  with no :ADJUSTABLE option or with :ADJUSTABLE NIL, but that it  -might- return false.  Clarify that the implication of the above is that saying that an  array A "is adjustable" means that (ADJUSTABLE-ARRAY-P A) => true.  Further clarify that the adjustability of an array has no necessary  relation to any value was given (or not given) as the :ADJUSTABLE  option in the call to MAKE-ARRAY which created the array A.  Clarify that there is no portable way to create a non-adjustable  array (that is, an array for which ADJUSTABLE-ARRAY-P is  guaranteed to return false).  Change the description of ADJUST-ARRAY to say that if an attempt  is made to adjust an array which is not adjustable (that is, an  array for which ADJUSTABLE-ARRAY-P would return false), an error  will be signalled.  Clarify that this legitimizes ADJUSTABLE-ARRAY-P as an appropriate  predicate to determine whether ADJUST-ARRAY will reliably succeed.Rationale:  This effectively makes the status quo explicit.  While changing this to a tighter interpretation would be desirable, some  implementations have suggested that such a change might be very expensive  or impossible given their existing data storage layouts.  Although technically the changes to ADJUST-ARRAY are incompatible changes  from the spec, it's not believed that there are any implementations which  deviate, so we're still categorizing this as a clarification.Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and are compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.Discussion:  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.        TITAN 
         TITAN 
           >                                                 N                                                /                                0                            H       
       %                            7                   B  z*start*08978 00024 USfReturn-Path: <Moon@ALDERAAN.SCRC.Symbolics.COM>Received: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by Xerox.COM ; 25 JAN 89 16:32:05 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 262758; Mon 23-Jan-89 16:27:19 ESTDate: Mon, 23 Jan 89 16:27 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: RPG@lucid.com, JonL@lucid.com, Dussud@lucid.com, Masinter.pa, Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <19890123212739.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoThere were some wording problems with the amended version ofADJUST-ARRAY-NOT-ADJUSTABLE that was passed at the X3J13 meetinglast week.  It ended up not saying what I think was intended.Two problems:(1) The amendment made the following function have undefined behaviorin some perfectly meaningful cases, such as the call shown:  (defun double (a)     (if (adjustable-array-p a)         (adjust-array a (* (length a) 2))         (let ((new (make-array (* (length a) 2))))           (replace new a :end1 (length a))           new)))  (double (make-array 30))(2) The meaning of the SIMPLE-ARRAY type remains unclear.  In particular,it is not clear whether the following function is valid Common Lisp orcan violate the type declaration:  (defun foo ()    (let ((a (make-array 100)))      (declare (simple-array a))      ...))The unamended proposal addressed issue 1, but neither it nor theamendment addressed issue 2.I propose to replace the amended proposal, which X3J13 has already votedin, with the following.  Any comments?  Should this be sent out in theupcoming letter ballot?  Should I remove the discussion, since the proposalhas in effect been rewritten twice since that discussion occurred?Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289)Category:     CLARIFICATION/CHANGEEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting to shorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bug introduced                        by the amendment, add clarification of SIMPLE-ARRAY type.Problem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' This is inconsistent with  ADJUSTABLE-ARRAY-P.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY.  The definition of the SIMPLE-ARRAY type and its subtypes needs  clarification of its relationship to adjustability.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):  1. ADJUST-ARRAY signals an error if ADJUSTABLE-ARRAY-P of its  first argument is false.  ADJUST-ARRAY does not signal an "array  not adjustable" error if ADJUSTABLE-ARRAY-P of its first argument  is true.  2. ADJUSTABLE-ARRAY-P is true of all arrays created with a non-NIL  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.  3. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER, and  :DISPLACED-TO arguments each either unspecified or NIL, the resulting  array is a simple array.  (This just repeats what CLtL says on page 289,  it's here to aid in understanding the next point.)  4. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments non-NIL, whether the resulting  array is simple is unspecified.Rationale:  This effectively makes the status quo explicit.  This preserves the  raison d'etre of simple arrays, which is to provide a portable interface  to implementation-dependent specialized arrays that trade decreased  functionality for faster access.  Specifying the points left unspecified (requiring all simple arrays to be  non-adjustable and all adjustable arrays to be non-simple) would require  large changes to some implementations and would be of little benefit to  users, merely making one kind of nonconforming program fail in all  implementations instead of failing only in some implementations.  Users  need to know that certain arrays are simple, so they can put in  declarations and get higher performance, but users have no need to be  able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable (to cause errors).The following are logical consequences of this proposal:  Whether an array can be both simple and adjustable is unspecified.  There is no specified way to create an array for which ADJUSTABLE-ARRAY-P  definitely returns NIL.  There is no specified way to create an array that is non-simple.  This legitimizes ADJUSTABLE-ARRAY-P as an appropriate predicate to  determine whether ADJUST-ARRAY will reliably succeed.Examples:  1. The following program is conforming.  It is unspecified which branch  of the IF it follows.      (defun double (a)       (if (adjustable-array-p a)           (adjust-array a (* (length a) 2))           (let ((new (make-array (* (length a) 2))))             (replace new a :end1 (length a))             new)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is simple,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and make all arrays non-simple unless the Common Lisp  language requires them to be simple, and are compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language explicitly unspecified is more aesthetic than having it  implicitly unspecified on account of vague or inconsistent documentation.Discussion:  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.*start*02527 00024 US Return-Path: <dussud@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 27 JAN 89 08:37:22 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA14498g; Fri, 27 Jan 89 08:33:30 PSTReceived: by challenger id AA21144g; Fri, 27 Jan 89 08:29:20 PSTDate: Fri, 27 Jan 89 08:29:20 PSTFrom: Patrick Dussud <dussud@lucid.com>Message-Id: <8901271629.AA21144@challenger>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: RPG@lucid.com, JonL@lucid.com, Masinter.pa, Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: David A. Moon's message of Mon, 23 Jan 89 16:27 EST <19890123212739.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)   I propose to replace the amended proposal, which X3J13 has already voted   in, with the following.  Any comments?  Should this be sent out in the   upcoming letter ballot?  Should I remove the discussion, since the proposal   has in effect been rewritten twice since that discussion occurred?   Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):     1. ADJUST-ARRAY signals an error if ADJUSTABLE-ARRAY-P of its     first argument is false.  ADJUST-ARRAY does not signal an "array     not adjustable" error if ADJUSTABLE-ARRAY-P of its first argument     is true.     2. ADJUSTABLE-ARRAY-P is true of all arrays created with a non-NIL     :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is     true of some other arrays is unspecified.     3. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER, and     :DISPLACED-TO arguments each either unspecified or NIL, the resulting     array is a simple array.  (This just repeats what CLtL says on page 289,     it's here to aid in understanding the next point.)     4. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,     :FILL-POINTER, or :DISPLACED-TO arguments non-NIL, whether the resulting     array is simple is unspecified.I have no objections to the rewrite in itself, except that we still need to propose a change to the definition of simple-array. This proposal tighten itsbehavior, but does not propose a description for it. The only description thatI found in CLtL is on page 28: "An array that is not displaced to anotherarray, has no fill pointerm and is not to have its size adjusted dynamicallyafter creation is called simple-array...". Do you think that an amendeddefinition of simple-array can be included in this issue?Patrick.*start*02593 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 27 JAN 89 19:23:32 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 528666; Fri 27-Jan-89 22:22:23 ESTDate: Fri, 27 Jan 89 22:22 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: Patrick Dussud <dussud@lucid.com>cc: RPG@lucid.com, JonL@lucid.com, Masinter.pa, KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <8901271629.AA21144@challenger>Message-ID: <19890128032256.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Fri, 27 Jan 89 08:29:20 PST    From: Patrick Dussud <dussud@lucid.com>    I have no objections to the rewrite in itself, except that we still need to     propose a change to the definition of simple-array. This proposal tighten its    behavior, but does not propose a description for it. The only description that    I found in CLtL is on page 28: "An array that is not displaced to another    array, has no fill pointerm and is not to have its size adjusted dynamically    after creation is called simple-array...". Do you think that an amended    definition of simple-array can be included in this issue?You left out half of what CLtL said: "Some implementations can handlesimple arrays in an especially efficient manner; for example, simplearrays may have a more compact representation than non-simple arrays."Also p.247 says that sequence functions that construct new arraysconstruct simple ones, page 302 says MAKE-STRING returns a simplestring, and page 349 says the " reader macro returns a simple string.That's enough for me.  Pulling that together with what my referencedproposal said, we have the following.  Can you tell me whether you thinkthis is sufficient, and, if not, what's wrong with it?  Some implementations can handle simple arrays in an especially  efficient manner; for example, simple arrays may have a more compact  representation than non-simple arrays.  If MAKE-ARRAY is called with  the :ADJUSTABLE, :FILL-POINTER, and :DISPLACED-TO arguments each  either unspecified or NIL, the resulting array is a simple array.  If  any of the functions <insert list here> creates a new array, it  creates a simple array.  If MAKE-ARRAY is called with one or more of  the :ADJUSTABLE, :FILL-POINTER, or :DISPLACED-TO arguments non-NIL,  whether the resulting array is simple is unspecified.*start*01300 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 30 JAN 89 08:34:41 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 529916; Mon 30-Jan-89 11:00:59 ESTDate: Mon, 30 Jan 89 11:00 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: Moon@STONY-BROOK.SCRC.Symbolics.COM, dussud@lucid.comcc: RPG@lucid.com, JonL@lucid.com, Masinter.pa, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <19890128032256.5.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <8901271629.AA21144@challenger>,             <19890123212739.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <890130110045.5.KMP@BOBOLINK.SCRC.Symbolics.COM>Just so you know, I have read the (referenced) private conversation onthe fate of ADJUST-ARRAY-NOT-ADJUSTABLE and concur with Moon'ssuggestions about how to proceed. In particular, I think we shouldcirculate his version of the proposal.As far as his most recent coalesced description of simple arrays, Ithink that follows from the other stuff in the discussion, so shouldjust be given to Kathy as editorial advice once this proposal has beenpassed.*start*01961 00024 US Return-Path: <dussud@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 30 JAN 89 08:24:01 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA02287g; Mon, 30 Jan 89 08:17:11 PSTReceived: by challenger id AA03528g; Mon, 30 Jan 89 08:13:00 PSTDate: Mon, 30 Jan 89 08:13:00 PSTFrom: Patrick Dussud <dussud@lucid.com>Message-Id: <8901301613.AA03528@challenger>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: RPG@lucid.com, JonL@lucid.com, Masinter.pa, KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: David A. Moon's message of Fri, 27 Jan 89 22:22 EST <19890128032256.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)   Date: Fri, 27 Jan 89 22:22 EST   From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>   Line-Fold: No   You left out half of what CLtL said: "Some implementations can handle   simple arrays in an especially efficient manner; for example, simple   arrays may have a more compact representation than non-simple arrays."I put only the incompatible part of the description of simple-arrays.     Some implementations can handle simple arrays in an especially     efficient manner; for example, simple arrays may have a more compact     representation than non-simple arrays.  If MAKE-ARRAY is called with     the :ADJUSTABLE, :FILL-POINTER, and :DISPLACED-TO arguments each     either unspecified or NIL, the resulting array is a simple array.  If     any of the functions <insert list here> creates a new array, it     creates a simple array.  If MAKE-ARRAY is called with one or more of     the :ADJUSTABLE, :FILL-POINTER, or :DISPLACED-TO arguments non-NIL,     whether the resulting array is simple is unspecified.I have no objection, provided than a sentence under EDITORIAL CHANGES, says that the incompatible part of the sentence in CLtL should be flushed.Patrick.*start*01105 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 30 JAN 89 09:35:30 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 529962; Mon 30-Jan-89 11:49:08 ESTDate: Mon, 30 Jan 89 11:49 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: Patrick Dussud <dussud@lucid.com>cc: RPG@lucid.com, JonL@lucid.com, Masinter.pa, KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <8901301613.AA03528@challenger>Message-ID: <19890130164936.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Mon, 30 Jan 89 08:13:00 PST    From: Patrick Dussud <dussud@lucid.com>    I have no objection, provided than a sentence under EDITORIAL CHANGES,     says that the incompatible part of the sentence in CLtL should be flushed.I don't see anything incompatible in CLtL.  Perhaps it depends on howan ambiguous statement is read?  Please explain.*start*02931 00024 US Return-Path: <rpg@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 30 JAN 89 10:00:18 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA02511g; Mon, 30 Jan 89 09:54:53 PSTReceived: by challenger id AA03759g; Mon, 30 Jan 89 09:50:42 PSTDate: Mon, 30 Jan 89 09:50:42 PSTFrom: Richard P. Gabriel <rpg@lucid.com>Message-Id: <8901301750.AA03759@challenger>To: KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, dussud@lucid.com, JonL@lucid.com, Masinter.paSubject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)I think that David's proposal is almost good enough. I think weneed to make explicit that the following program is to be avoided:  (let ((a (make-array 100)))    (adjust-array a (* (length a) 2))    ...)Here is some wording I worked out at the meeting but never got tomention (at the end of the note I will propose a modification toDavid's proposal):  The results are undefined if ADJUST-ARRAY is invoked on an array that  was created without supplying :ADJUSTABLE true, unless  ADJUSTABLE-ARRAY-P returns true on that array.  ADJUSTABLE-ARRAY-P returns true on an array created by MAKE-ARRAY  supplying :ADJUSTABLE true.  An array created by MAKE-ARRAY supplying :ADJUSTABLE, :FILL-POINTER,  and :DISPLACED-TO false is a simple array.  The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.One thing I found problematic with David's proposal was the statementthat ADJUST-ARRAY signals an error. This takes away someimplementation freedom that currently exists (as I read CLtL). Thatis, I believe is should be allowed for an implementation to bomb outwhen adjusting a non-adjustable array in certain compiled code. Mydesire would be consistent with a requirement that ADJUST-ARRAY shouldsignal an error, but I think we should retain the current status.We could amend David's proposal as follows to take my concerns into account:  1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.  2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER, and  :DISPLACED-TO arguments each either unspecified or false, the resulting  array is a simple array.  (This just repeats what CLtL says on page 289,  it's here to aid in understanding the next point.)  3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the resulting  array is simple is unspecified.  4. The results are undefined if ADJUST-ARRAY is invoked on an array that  was created without supplying :ADJUSTABLE true, unless  ADJUSTABLE-ARRAY-P returns true on that array.   5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.I can't easily determine whether 1-4 implies 5, so I added it.			-rpg-*start*05180 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 30 JAN 89 11:30:01 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 530113; Mon 30-Jan-89 14:28:39 ESTDate: Mon, 30 Jan 89 14:28 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: rpg@lucid.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, dussud@lucid.com, JonL@lucid.com, Masinter.paIn-Reply-To: <8901301750.AA03759@challenger>Message-ID: <890130142828.2.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Mon, 30 Jan 89 09:50:42 PST    From: Richard P. Gabriel <rpg@lucid.com>    I think that David's proposal is almost good enough. I think we    need to make explicit that the following program is to be avoided:      (let ((a (make-array 100)))	(adjust-array a (* (length a) 2))	...)As long as it's not prohibited for an implementation to define this, thisis fine. I believe your wording below does that.    Here is some wording I worked out at the meeting but never got to    mention (at the end of the note I will propose a modification to    David's proposal):      The results are undefined if ADJUST-ARRAY is invoked on an array that      was created without supplying :ADJUSTABLE true, unless      ADJUSTABLE-ARRAY-P returns true on that array.Ok. The use of "undefined" addresses my concern above because it leavesroom for an implementation to define it.      ADJUSTABLE-ARRAY-P returns true on an array created by MAKE-ARRAY      supplying :ADJUSTABLE true.Ok.      An array created by MAKE-ARRAY supplying :ADJUSTABLE, :FILL-POINTER,      and :DISPLACED-TO false is a simple array.Ok.      The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.Ok.    One thing I found problematic with David's proposal was the statement    that ADJUST-ARRAY signals an error. This takes away some implementation    freedom that currently exists (as I read CLtL).    That is, I believe is should be allowed for an implementation to bomb out    when adjusting a non-adjustable array in certain compiled code. I thought it was the sense of the committee that we wanted to change CLtLto signal in some cases where it was now not required to, and that it wasthe definition of the circumstances under which it would signal thatprecipitated this discussion. Would you compromise on "should signal"?    My desire would be consistent with a requirement that ADJUST-ARRAY    should signal an error, but I think we should retain the current status.I couldn't parse this sentence. By "current status" I assumed you meant CLtL.Since "should signal" is new terminology, it can't be the current status.Maybe you either meant "current status" to refer to work of this committeeor you meant "should signal" only informally.    We could amend David's proposal as follows to take my concerns into account:      1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true      :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is      true of some other arrays is unspecified.Ok. Same as Moon's #2.      2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER, and      :DISPLACED-TO arguments each either unspecified or false, the resulting      array is a simple array.  (This just repeats what CLtL says on page 289,      it's here to aid in understanding the next point.)Ok. Same as Moon's #3.      3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,      :FILL-POINTER, or :DISPLACED-TO arguments true, whether the resulting      array is simple is unspecified.Ok. Same as Moon's #4.      4. The results are undefined if ADJUST-ARRAY is invoked on an array that      was created without supplying :ADJUSTABLE true, unless      ADJUSTABLE-ARRAY-P returns true on that array.Two problems... - Moon's wording made it an error to call ADJUST-ARRAY on an array created   without :ADJUSTABLE true unless ADJUSTABLE-ARRAY-P is true. Your wording   doesn't address this case. I presume this is an oversight. - Could we compromise on "should signal" instead of "is undefined" since you   seem uncomfortable with "must signal"?I suggest: 4. ADJUST-ARRAY should signal an "array not adjustable" error if    ADJUSTABLE-ARRAY-P is false for its first argument. ADJUST-ARRAY must    not signal an "array not adjustable" error if ADJUSTABLE-ARRAY-P is    true for its first argument.      5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.    I can't easily determine whether 1-4 implies 5, so I added it.This was effectively in Moon's list of "logical consequences" but Iapprove of its being listed here explicitly. Actually, I think thelogical consequences part should be moved into the proposal so that it'sclear on the off chance there's any doubt that any of the others areimplied. That shouldn't cause a problem unless there's an inconsistency,and if there's an inconsistency, we'd better fix it regardless of whereit is.*start*00927 00024 US Return-Path: <dussud@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 30 JAN 89 11:41:38 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA02760g; Mon, 30 Jan 89 11:37:41 PSTReceived: by challenger id AA03928g; Mon, 30 Jan 89 11:33:28 PSTDate: Mon, 30 Jan 89 11:33:28 PSTFrom: Patrick Dussud <dussud@lucid.com>Message-Id: <8901301933.AA03928@challenger>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: RPG@lucid.com, JonL@lucid.com, Masinter.pa, KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: David A. Moon's message of Mon, 30 Jan 89 11:49 EST <19890130164936.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)I thought that "not to have its size adjusted dynamically after creation"meant that all simple arrays cannot be adjusted. I misunderstood the sentence.Patrick.*start*03732 00024 US Return-Path: <rpg@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 30 JAN 89 14:03:20 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA03150g; Mon, 30 Jan 89 13:59:02 PSTReceived: by challenger id AA04106g; Mon, 30 Jan 89 13:54:50 PSTDate: Mon, 30 Jan 89 13:54:50 PSTFrom: Richard P. Gabriel <rpg@lucid.com>Message-Id: <8901302154.AA04106@challenger>To: KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, dussud@lucid.com, JonL@lucid.com, Masinter.paSubject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)Kent writes:``    4. The results are undefined if ADJUST-ARRAY is invoked on an array that      was created without supplying :ADJUSTABLE true, unless      ADJUSTABLE-ARRAY-P returns true on that array.Two problems... - Moon's wording made it an error to call ADJUST-ARRAY on an array created   without :ADJUSTABLE true unless ADJUSTABLE-ARRAY-P is true. Your wording   doesn't address this case. I presume this is an oversight. - Could we compromise on "should signal" instead of "is undefined" since you   seem uncomfortable with "must signal"?I suggest: 4. ADJUST-ARRAY should signal an "array not adjustable" error if    ADJUSTABLE-ARRAY-P is false for its first argument. ADJUST-ARRAY must    not signal an "array not adjustable" error if ADJUSTABLE-ARRAY-P is    true for its first argument.''My version of 4. attempted to capture the status quo. It is currentlynot clear that ADJUST-ARRAY is supposed to ever signal an error. Page297 talks about replacing the original array with a displaced array.Also, my version tries to make it clear that in portable code, callingADJUST-ARRAY on an array not created to be adjustable is a no-no.Thus, my version links the undefinedness of ADJUST-ARRAY with theMAKE-ARRAY that created it, but I want to also imply thatARRAY-ADJUSTABLE-P can be used to determine adjustableness.In short, I would approve of this: 4. ADJUST-ARRAY should signal an "array not adjustable" error if    ADJUSTABLE-ARRAY-P is false for its first argument. ADJUST-ARRAY must    not signal an "array not adjustable" error if ADJUSTABLE-ARRAY-P is    true for its first argument.'' Programmers who use ADJUST-ARRAY on    arrays created by MAKE-ARRAY without supplying :ADJUSTABLE true are    stupid and should not be allowed to hack Lisp for pay.More seriously, I propose this:  1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.  2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER, and  :DISPLACED-TO arguments each either unspecified or false, the resulting  array is a simple array.  (This just repeats what CLtL says on page 289,  it's here to aid in understanding the next point.)  3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the resulting  array is simple is unspecified.  4. If ADJUST-ARRAY is invoked on an array that was created without  supplying :ADJUSTABLE true, an error should be signaled, unless   ADJUSTABLE-ARRAY-P returns true on that array. ADJUST-ARRAY must  not signal the error if ADJUSTABLE-ARRAY-P is true for its first argument.   5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.Notice that ``should signal'' implies that if the code is compiled ina certain way and an implementation is not going to signal the error,the results are undefined. Also, if you called MAKE-ARRAY the wrongway and if ADJUSTABLE-ARRAY-P returns NIL, you could lose as well(should signal an error).			-rpg-*start*04332 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 30 JAN 89 14:37:14 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 530250; Mon 30-Jan-89 17:36:06 ESTDate: Mon, 30 Jan 89 17:35 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: rpg@lucid.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, dussud@lucid.com, JonL@lucid.com, Masinter.paIn-Reply-To: <8901302154.AA04106@challenger>Message-ID: <890130173552.5.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Mon, 30 Jan 89 13:54:50 PST    From: Richard P. Gabriel <rpg@lucid.com>    ... My version of 4. attempted to capture the status quo. It is    currently not clear that ADJUST-ARRAY is supposed to ever signal    an error...Right. This is what I meant when I wrote: I thought it was the sense of the committee that we wanted to change CLtL to signal in some cases where it was now not required to, and that it was the definition of the circumstances under which it would signal that precipitated this discussion.    ...    More seriously, I propose this:      1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true      :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is      true of some other arrays is unspecified.      2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER, and      :DISPLACED-TO arguments each either unspecified or false, the resulting      array is a simple array.  (This just repeats what CLtL says on page 289,      it's here to aid in understanding the next point.)      3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,      :FILL-POINTER, or :DISPLACED-TO arguments true, whether the resulting      array is simple is unspecified.      4. If ADJUST-ARRAY is invoked on an array that was created without      supplying :ADJUSTABLE true, an error should be signaled, unless       ADJUSTABLE-ARRAY-P returns true on that array. ADJUST-ARRAY must      not signal the error if ADJUSTABLE-ARRAY-P is true for its first argument. I'm -completely- weirded out that you want to write it this way. The only reasonI can see for not just writing   "If ADJUST-ARRAY is invoked on an array for which ADJUSTABLE-ARRAY-P   returns false, an error should be signalled.  ADJUST-ARRAY must   not signal the error if ADJUSTABLE-ARRAY-P is true for its first argument."is emphasis for idiots who cannot do the simplest logical inference. Yet thewording you've chosen is so convoluted that the reader would have to becapable of doing serious logic just to assure himself that this was in factdefined in all cases. If you're -really- worried about this, I'd suggest takingmy wording and asking Kathy to add an extra sentence, unrelated to the definition,that says something plain like "Note that it follows from all of the above thatyou are a dodo if you create an array without specifying :ADJUSTABLE true andthen you try to use ADJUST-ARRAY on the array in portable code."I don't intend to pursue this since there is now no difference in thetruth table between what you've written and what I've asked for.  Let'sjust vote on it as is. However, don't be surprised if Kathy receiveseditorial advice on the side from me, suggesting my simpler presentation.      5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.    Notice that ``should signal'' implies that if the code is compiled in    a certain way and an implementation is not going to signal the error,    the results are undefined.This "notice" will have already been clearly defined elsewhere in the spec.I hope you don't mean it as part of the text to be voted on.It would be very unmodular to repeat here, and in fact I think it's veryunmodular for us to repeat it all over the place in discussions because itsuggests that where it's not mentioned, something different might be true.    Also, if you called MAKE-ARRAY the wrong way and if ADJUSTABLE-ARRAY-P    returns NIL, you could lose as well (should signal an error).Yes, I think there is no dispute about this point under either your or mywording for item 4.*start*01183 00024 US Date: 30 Jan 89 14:47 PSTFrom: masinter.paSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 30 Jan 89 17:35 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: rpg@lucid.com, Moon@STONY-BROOK.SCRC.Symbolics.COM, dussud@lucid.com, JonL@lucid.com, Masinter.pa, cl-cleanup@sail.stanford.eduI'd just as soon that technical discussions about cleanup proposals happen on the cl-cleanup distribution list. As long as we're quibbling about wording, we might as well get wording that we like. If we're not already quibbling about wording, then we can put it off for cl-editorial to do. I'd rather proposals be explicit about the cases and cut things down later. We do best if we describe the input/output behavior of functions with a case analysis, where it is clear that all of the cases are covered.  In a cleanup proposal, you can omit repeating CLtL by saying "as described in CLtL", or, if necessary for clarity (e.g., when there is some evidence that CLtL's reading has been misread or not read), to repeat CLtL or rephrase it with a "Clarify".*start*01049 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 30 JAN 89 15:13:38 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 530310; Mon 30-Jan-89 18:12:55 ESTDate: Mon, 30 Jan 89 18:12 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <890130-144905-6017@Xerox>Message-ID: <890130181244.6.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 30 Jan 89 14:47 PST    From: masinter.pa@Xerox.COM    ... We do best if we describe the input/output behavior of functions with a    case analysis, where it is clear that all of the cases are covered. ...Please break the deadlock between RPG and me by suggesting whose wordingto go with so we can put together a full proposal corresponding to thecurrent state of this discussion and get it out on CL-Cleanup.*start*02027 00024 US Return-Path: <Moon@ALDERAAN.SCRC.Symbolics.COM>Received: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by Xerox.COM ; 30 JAN 89 20:54:03 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 265610; Mon 30-Jan-89 23:52:41 ESTDate: Mon, 30 Jan 89 23:53 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: Richard P. Gabriel <rpg@lucid.com>cc: KMP@STONY-BROOK.SCRC.Symbolics.COM, dussud@lucid.com, JonL@lucid.com, Masinter.pa, Moon@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <8901301750.AA03759@challenger>Message-ID: <19890131045316.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Mon, 30 Jan 89 09:50:42 PST    From: Richard P. Gabriel <rpg@lucid.com>    One thing I found problematic with David's proposal was the statement    that ADJUST-ARRAY signals an error. This takes away some    implementation freedom that currently exists (as I read CLtL). That    is, I believe is should be allowed for an implementation to bomb out    when adjusting a non-adjustable array in certain compiled code. My    desire would be consistent with a requirement that ADJUST-ARRAY should    signal an error, but I think we should retain the current status.I hadn't intended to propose a change to the status quo here.  I was misledby something someone remarked to me, and then did not read CLtL carefullyenough.  CLtL pp.297-8 list three error situations for adjust-array, thefirst two (relating to :element-type and :fill-pointer) say "an erroris signalled"; the third (relating to adjustable-array-p says "it isnot permitted").In fact I cannot see any harm in adjust-array signalling an error in thethird situation too, but I don't want to press the point.  I don'tconsider it important, nor part of the issue at hand.The rest of the discussion has gotten too complicated for me to followright now.  I'll take another look at it tomorrow I hope.*start*08289 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 FEB 89 21:24:46 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 1 Feb 89  21:23:19 PSTReturn-Path: <gls@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 2 Feb 89 00:13:00 ESTReceived: by sauron.think.com; Thu, 2 Feb 89 00:19:06 ESTDate: Thu, 2 Feb 89 00:19:06 ESTFrom: gls@Think.COMMessage-Id: <8902020519.AA03069@sauron.think.com>To: cl-cleanup@sail.stanford.eduCc: gls@Think.COMSubject: New issue ADJUST-ARRAY-NOT-ADJUSTABLE-BROKENIssue: ADJUST-ARRAY-NOT-ADJUSTABLE-BROKENReferences:	ADJUST-ARRAY (p297)		MAKE-ARRAY (pp286-289)		ADJUSTABLE-ARRAY-P (p293)		ADJUST-ARRAY-NOT-ADJUSTABLECategory:      CLARIFICATION/CHANGEEdit history:  02-Feb-89, Version 1 by SteeleProblem description:The vote at the January 1989 meeting on ADJUST-ARRAY-NOT-ADJUSTABLEleft the language in an inconsistent state.  It also leftADJUSTABLE-ARRAY-P with a fairly useless definition.The amendment presented and approved at the January meeting stated:(1) The results are undefined if ADJUST-ARRAY is invoked on an array    that was created by MAKE-ARRAY without supplying :ADJUSTABLE <non-nil>.(2) ADJUSTABLE-ARRAY-P returns true of an array created using    :ADJUSTABLE <non-nil>.(3) If ADJUST-ARRAY is invoked on an array for which ADJUSTABLE-ARRAY-P    returns false, an error is signalled.The inconsistency is that the amendment failed to strike theseparts of the original proposal:    Clarify that the implication of [the first three paragraphs of the    original proposal] is that saying that an array A "is adjustable"    means that (ADJUSTABLE-ARRAY-P A) => true. ...    Clarify that this legitimizes ADJUSTABLE-ARRAY-P as an appropriate    predicate to determine whether ADJUST-ARRAY will reliably succeed.The latter is in conflict with the amendment, for ADJUSTABLE-ARRAY-Pbeing true is no longer a guarantee that ADJUST-ARRAY can succeed.  Thebest that can be said is that if ADJUSTABLE-ARRAY-P is false thenADJUST-ARRAY is guaranteed to signal an error.  (Some implementationsmight provide the extension that ADJUSTABLE-ARRAY-P being true guaranteesthat ADJUST-ARRAY will win.)  Therefore the former is also nonsensical,because it is silly to say that an array is adjustable if in fact anadjustable array (one for which ADJUSTABLE-ARRAY-P is true) cannot beadjusted by ADJUST-ARRAY.Another point is that some persons have been concerned about the languagebeing in a state where one cannot guarantee that MAKE-ARRAY will create asimple array.  The concerns surround the question of a portable way tomake declarations about arrays that can be exploited by implementationson stock hardware to produce fast compiled array accesses.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE-BROKEN:TURKEY):Rescind the amendment approved at the January 1989 meeting, cited above,thereby restoring and approving the proposal ADJUST-ARRAY-NOT-ADJUSTABLE:DONKEYto its state as of version 4.Furthermore make the following change: the behavior of :ADJUSTABLE NIL,explicitly supplied, may differ from the behavior of omitting the:ADJUSTABLE argument in some implementations.Implementations may be divided into three kinds, according to the behaviorof MAKE-ARRAY when given :ADJUSTABLE NIL or when :ADJUSTABLE is omitted:(1) Always return a non-adjustable array.(2) Always return an adjustable array.(3) Sometimes return one kind, sometimes another.In implementations of kind (1), a declaration that an array is simple(using the SIMPLE-ARRAY, SIMPLE-VECTOR, SIMPLE-STRING, or SIMPLE-BIT-VECTORtype specifier) may be taken literally: it is a guarantee that the arrayin question will be, among other things, not adjustable.  The compiler insuch an implementation may rely on this declaration to produce goodcompiled code.In implementations of kinds (2) and (3), a declaration that an arrayis simple is understood a little bit differently: it constitutes aguarantee by the user that he made a good-faith effort to create asimple array, that is, MAKE-ARRAY was given an *explicit* argument:ADJUSTABLE NIL.  The compiler for an implementation of kind (2) willknow that its arrays are always adjustable anyway and can generate codeaccordingly.  The compiler for an implementation of kind (3) may throwup its hands, or it may use implementation-specific knowledge aboutthe behavior of MAKE-ARRAY to determine what code to produce; for example,an implementation of kind (3) might provide non-adjustable strings butnot provide non-adjustable general arrays.Therefore there is a difference between using :ADJUSTABLE NIL and omitting it;using it entitles the user to make certain type declarations, whereasomitting it does not entitle the user to make such type declarations.Implementations of kind (3) might choose to interpret an explicit passingof :ADJUSTABLE NIL as requiring a non-adjustable array, but an omission asleaving the implementation free to make the choice; but this is only oneof many permitted interpretations.Nevertheless, ADJUSTABLE-ARRAY-P is the sole run-time arbiter of whetheror not ADJUST-ARRAY will succeed.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE-BROKEN:MONKEY):Rescind the amendment approved at the January 1989 meeting, cited above,thereby restoring and approving the proposal ADJUST-ARRAY-NOT-ADJUSTABLE:DONKEYto its state as of version 4.Implementations may be divided into three kinds, according to the behaviorof MAKE-ARRAY when given :ADJUSTABLE NIL or when :ADJUSTABLE is omitted:(1) Always return a non-adjustable array.(2) Always return an adjustable array.(3) Sometimes return one kind, sometimes another.This proposal forbids implementations of kind (3).In implementations of kind (1), a declaration that an array is simple(using the SIMPLE-ARRAY, SIMPLE-VECTOR, SIMPLE-STRING, or SIMPLE-BIT-VECTORtype specifier) may be taken literally: it is a guarantee that the arrayin question will be, among other things, not adjustable.  The compiler insuch an implementation may rely on this declaration to produce goodcompiled code.In implementations of kind (2), a declaration that an arrayis simple is understood a little bit differently: it constitutes aguarantee by the user that he made a good-faith effort to create asimple array, that is, MAKE-ARRAY was not given :ADJUSTABLE <non-NIL>.The compiler for an implementation of kind (2) willknow that its arrays are always adjustable anyway and can generate codeaccordingly.ADJUSTABLE-ARRAY-P is the sole run-time arbiter of whetheror not ADJUST-ARRAY will succeed.Rationale:It is silly to play a semantic game wherein one might or might notbe able to adjust an array terminologically defined to be "adjustable".It is recognized that implementations differ on whether and when arraysare to be adjustable, and that this state of affairs is desirable, beingmotivated not only by inertia but by questions of flexibility andefficiency as a function of hardware.  The hope is that by being just alittle more explicit about the permitted range of implementation optionswe can provide a more useful semantics for ADJUSTABLE-ARRAY-P and forarray type declarations.Current practice:Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL (or omitted) arraysnon-adjustable, and therefore are compatible with either proposal.Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most casesand I believe it does not depend on type declarations of simple arrays,and therefore is compatible with either proposal.Cost to implementors:Perhaps some implementation would have to change, but I don't know of any.Cost to users:None.  This is a fully compatible change from the user's standpoint.Benefits:Users would know what to expect; in particular, ADJUSTABLE-ARRAY-Preally would mean "can I adjust this array?"Aesthetics:The status quo is yukky.Discussion:Steele favors ADJUST-ARRAY-NOT-ADJUSTABLE-BROKEN:MONKEY, but fears thatthere may be some implementation of kind (3) out there that is of kind (3)for some important reason.  Proposal TURKEY has been provided to coverthat contingency.*start*00870 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 FEB 89 15:39:08 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 3 Feb 89  15:37:40 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 533496; 3 Feb 89 18:32:12 ESTDate: Fri, 3 Feb 89 18:32 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: New issue ADJUST-ARRAY-NOT-ADJUSTABLE-BROKENTo: gls@Think.COMcc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8902020519.AA03069@sauron.think.com>Message-ID: <19890203233247.3.MOON@EUPHRATES.SCRC.Symbolics.COM>I think both proposals are wrong.  Also this issue is beingdiscussed privately.  More comments later.*start*01227 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 FEB 89 16:03:06 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 3 Feb 89  16:01:55 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 03 FEB 89 15:57:37 PSTDate: 3 Feb 89 15:57 PSTFrom: masinter.paSubject: Re: New issue ADJUST-ARRAY-NOT-ADJUSTABLE-BROKENIn-reply-to: gls@Think.COM's message of Thu, 2 Feb 89 00:19:06 ESTTo: gls@Think.COMcc: cl-cleanup@sail.stanford.eduMessage-ID: <890203-155737-2252@Xerox>Procedurally, I'd rather handle this as a motion to reconsider the previousversion of ADJUST-ARRAY-NOT-ADJUSTABLE rather than as a new issue. Myreason is that at some point we will probably need to release the "passed"issues as a description to the community as to what we did and why; I'drather not leave ADJUST-ARRAY-NOT-ADJUSTABLE as unamended. So I'm happy tomail out your message with Problem and Proposal, but in the final state,just have an amended ADJUST-ARRAY-NOT-ADJUSTABLE issue.This is not terribly important, but we would need a revised version ofADJUST-ARRAY-NOT-ADJUSTABLE if the motion passes.*start*01764 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 08:41:34 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 6 Feb 89  08:41:29 PSTReceived: from fafnir.think.com by Think.COM; Mon, 6 Feb 89 11:28:47 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Mon, 6 Feb 89 11:37:12 ESTReceived: by verdi.think.com; Mon, 6 Feb 89 11:36:43 ESTDate: Mon, 6 Feb 89 11:36:43 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8902061636.AA27928@verdi.think.com>To: masinter.paCc: gls@Think.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@xerox.com's message of 3 Feb 89 15:57 PST <890203-155737-2252@Xerox>Subject: New issue ADJUST-ARRAY-NOT-ADJUSTABLE-BROKEN   Date: 3 Feb 89 15:57 PST   From: masinter.pa@xerox.com   Procedurally, I'd rather handle this as a motion to reconsider the previous   version of ADJUST-ARRAY-NOT-ADJUSTABLE rather than as a new issue. My   reason is that at some point we will probably need to release the "passed"   issues as a description to the community as to what we did and why; I'd   rather not leave ADJUST-ARRAY-NOT-ADJUSTABLE as unamended. So I'm happy to   mail out your message with Problem and Proposal, but in the final state,   just have an amended ADJUST-ARRAY-NOT-ADJUSTABLE issue.   This is not terribly important, but we would need a revised version of   ADJUST-ARRAY-NOT-ADJUSTABLE if the motion passes.Fine.  By the way, as a result of discussions with RPG this weekend,I have concluded that the solutions I offered are themselves broken.However, I still believe that there is a problem to be solved here.--Guy*start*09072 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 FEB 89 12:42:19 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Feb 89  12:41:45 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02467g; Tue, 7 Feb 89 12:36:19 PSTReceived: by bhopal id AA23870g; Tue, 7 Feb 89 12:38:40 PSTDate: Tue, 7 Feb 89 12:38:40 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8902072038.AA23870@bhopal>To: gls@Think.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Guy Steele's message of Mon, 6 Feb 89 11:36:43 EST <8902061636.AA27928@verdi.think.com>Subject: New issue ADJUST-ARRAY-NOT-ADJUSTABLE-BROKEN, or Hokey-Pokey-ADJUST-ARRAY[The "Hokey" comes from RPG]I've resisted commenting on this issue, until all the ballyhoo died down.Looking at Dick's somewhat murky amendment, and Moon's attempt to simplifyit, I would characterize those as "good faith" attempts to reduce thedegree of discrepancy between the 3600 implementation and virtuallyall other Common Lisps, by *** merely retracting some of the formerlyrequired error checking in ADJUST-ARRAY ***.   Nevertheless, this "reduction in degree" does not address the underlying problem, which is the portabililty of the type SIMPLE-ARRAY.  Appallingly,I see that many readers of this mailing list actually believe that the proposal is to retract the portable type SIMPLE-ARRAY, and leave it in as murky a state as FIXNUM formerly was.  This is the disaster which I have so vehemently opposed.  Unfortunately, your "new proposal" fosters this confusion, in the following explanatory phrases:  In implementations of kind (1), a declaration that an array is simple  (using the SIMPLE-ARRAY, SIMPLE-VECTOR, SIMPLE-STRING, or SIMPLE-BIT-VECTOR  type specifier) may be taken literally: it is a guarantee that the array  in question will be, among other things, not adjustable.  The compiler in  such an implementation may rely on this declaration to produce good  compiled code.  In implementations of kinds (2) and (3), a declaration that an array  is simple is understood a little bit differently: it constitutes a  guarantee by the user that he made a good-faith effort to create a  . . . Postscripted to this message is a copy of the message I sent to X3J13 regarding the character proposal *** and in this message I argue very very strongly against imbuing CL with non-portable types [I'm including it with this note since not everyone reading cl-cleanup is on x3j13].  Your phrase "In implementations of kinds (2) and (3), [type SIMPLE-ARRAY]is understood a little bit differently" would be a giant step backwards in this regard.Despite opaque, clever wordings -- and despite parliamentary legerdemain at the Hawaii meeting --  more and more people are beginning to see the light on this.  No matter what we do to ADJUST-ARRAY, there are onlytwo real alternatives:   (1) 3600 Lisp (and TI Lisp?) remain technically incompatible on the       definition of SIMPLE-ARRAY -- they could choose to defend this       technicality to their customers on the grounds that it provides        a very worthwhile extension to CL, while at the same time alerting       their users to the potential for porting problems.   (2) we decide to "break" the type SIMPLE-ARRAY in some way (such as       by just removing it from the language altogether);  of course,        the stock hardware implementations will do nothing of the sort        -- they will continue to use the type just as at present for the        enormous benefit it provides to "fast" compilation -- and the 1989        CL Standard will simply fail to describe this most critical and        widespread feature [i.e., the standardization process will have        broken down].Incidentally, it's not obvious to everyone just why the definition ofSIMPLE-ARRAY found on CLtL p28 is so critical to open-coding on stockhardware.  I don't want to go into a long lecture on implementationaltechniques now, but at the Hawaii meeting I spoke with three othercompiler writers for stock hardware, and we all seem (independently)to have come up with the same techniques.  We all stand firmly behindthe current dichotomy between SIMPLE-ARRAY and (non-simple) ARRAY, which excludes adjustability from "simpleness";  the matter is similarto the use of "specialized storage" for various array element types.-- JonL --Date: Thu, 2 Feb 89 13:04:21 PSTFrom: Jon L White <jonl>In-Reply-To: David A. Moon's message of Tue, 31 Jan 89 16:53 ESTSubject: Really about TYPEP failures: Comments on the Character proposal dated January 1, 1989re: I'm afraid I don't understand your comment.  What's inadequately     specified about SIMPLE-BASE-STRING?  Sorry, I wasn't clear enough here.  The phrase used was "wishy-washy", and it didn't mean that the specification was unclear or something; rather, it called in question the enforcement of the specification.  As I understand it, it's entirely permissible for one implementation tomerge SIMPLE-BASE-STRING and SIMPLE-GENERAL-STRING into one type,whereas another may make them type-disjoint.This is a problem not specific to SIMPLE-BASE-STRING etc, but also appliesto any "wishy-washyness" about the disjointedness of types, wherethere is good reason to believe that some implementations will trulyutilize that disjointnedness.  Recall my comment about the situation with the FLOAT datatype:    Contrast this with the situation regarding the type FLOAT.  Although    there are many aspects of non-portability regarding the _use_ of    floating point numbers, there is no permitted variance in the definition    of the type FLOAT.  It is never permissible, for example, for one    implementation to implement the FLOAT datatype as lists of integers,    and another to implement it as some low-level primitive datatype.    Thus if a user's "declaration" (CHECK-TYPE X FLOAT) fails in one    implementation, but works in another, it is not due to an inherent    weakness in the specification of the type FLOAT.Suppose for the moment that one implementation merges the FLOAT and CONS datatypes by implementing FLOATs as a list of three integers (such as the the values returned by integer-decode-float), but another implementation makes them disjoint as "primitive" types.  At first blush, one might want to dismiss this case as simply an "efficiency" concern for the second implementation.  But consider the problems for someone developing the following program on the first implementation and delivering it on the second:     (defun foo (x)        (if (typep x 'float)            (sin x)           (error "Must have a float")))     (foo (list 1 0 1))                  ;; knowing that (float 1.0) is ...This is a valid program in the first implementation, because the list(1 0 1) is a valid FLOAT in that implementation.  But when moving it to the second implementation, you get a bug.  Now, implementing FLOATs as LISTs may look artificial, but this example exactly parallels one of the more annoying porting problems that some 3600 users have when going intovirtually any of the stock hardare implementations.  See footnote below.Recall the recent cleanup proposal to "tighten up" the definition of   FIXNUM so that its use will more frequently be portable.Recall also the recent cleanup issue to tighten the FUNCTION type so   that it is no longer ambiguous with SYMBOL.Recall also the CLOS need to tighten up the disjointedness of the types   found on CLtL p.31 (along with others too); 88-002R, p.1-17.Recall the trouble we've had with the ambiguity in the alternatives    for SHORT-FLOAT, SINGLE-FLOAT, DOUBLE-FLOAT, and LONG-FLOAT.Given this long history of misguided permissiveness, and our frequentneed to "tighten things up", don't you think it would a mistake to start out with the types SIMPLE-BASE-STRING and SIMPLE-GENERAL-STRING ambiguous?. . . -- JonL --Footnote:Actually, the FLOATs-as-LISTs example is of more than passing interest,because if you change the names appropriately, you will see exactlythe same problem that certain users have when porting code from the 3600implementation to *any* stock hardware implementation that does seriousopen-coding of AREF.  Note that the only function I've mentioned isTYPEP -- not hokey-pokey-adjust-array or whatever; that's why all thethousands of lines of discussion about adjust-array etc on cl-cleanup are not germane to the real problem.  Focusing on adjust-array can, at best, emasculate some of its mandated error checking; at worst, it can confuse some would-be heros into thinking that the type disjointedness in questionis merely a matter of semantics that can cleared up by clever wording.  Make no mistake.  The disjointedness is essential to the optimization strategies of *all* the commercial stock hardware implementationsrepresented at the Hawaii meeting.  *start*00745 00024 US Date:  7 Feb 89 15:00 PSTFrom: masinter.paSubject: Re: New issue ADJUST-ARRAY-NOT-ADJUSTABLE-BROKEN, or Hokey-Pokey-ADJUST-ARRAYIn-reply-to: Jon L White <jonl@lucid.com>'s message of Tue, 7 Feb 89 12:38:40 PSTTo: Jon L White <jonl@lucid.com>cc: MasinterJonL:Please try to tone down your remarks on this issue. There are a number of places where it might be possible to characterize our actions as "reducing the amount of discrepancy between the Lucid implementation and virtually all other Common Lisps."I think if we can avoid characterizing our actions at all, we'll not miss anything. Similarly, try to choose more neutral words than "Appallingly", and "disaster". I think it will help. Thanks,Larry*start*10629 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 FEB 89 16:16:06 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Feb 89  16:15:08 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 FEB 89 15:57:52 PSTDate: 14 Feb 89 15:56 PSTFrom: masinter.paSubject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: cl-cleanup@sail.stanford.eduMessage-ID: <890214-155752-10883@Xerox>I'm sorry it has taken me so long to get back to this. Unfortunately, not all of the mail was cc'd to cl-cleanup, which resultedin a number of crossed signals.I have a fairly lengthy conversation initiated by the enclosed messagewhich transpired between Jan 27 and Jan 30, plus Guy Steele's attempt tofix the same problem, and the discussion of that, and then a fairlystrongly-worded rejoinder from JonL on the issue.The status is that Version 5 (i.e., Version 4, with an amendedment) passedat the January 1989 X3J13 meeting.   David has proposed a Version 6, whichI enclose. I'm uncertain whether this version is really unacceptable; itlooks OK to me, and, I think, if I re-read all the mail from Dussud, maybeit is OK with him too. (Still.)At the risk of making you repeat yourself, if you have specificrecommendations you think would make Version 6 better than it is now, couldyou please restate them?It will help if we can keep the tone of the discussion low-key. Please keepperjoratives and characterizations to a minimum. Thanks,Larry     ----- Begin Forwarded Messages -----Return-Path: <Moon@ALDERAAN.SCRC.Symbolics.COM>Received: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by Xerox.COM ;25 JAN 89 16:32:05 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COMvia CHAOS with CHAOS-MAIL id 262758; Mon 23-Jan-89 16:27:19 ESTDate: Mon, 23 Jan 89 16:27 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: RPG@lucid.com, JonL@lucid.com, Dussud@lucid.com, Masinter.pa,Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <19890123212739.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoThere were some wording problems with the amended version ofADJUST-ARRAY-NOT-ADJUSTABLE that was passed at the X3J13 meetinglast week.  It ended up not saying what I think was intended.Two problems:(1) The amendment made the following function have undefined behaviorin some perfectly meaningful cases, such as the call shown:  (defun double (a)     (if (adjustable-array-p a)         (adjust-array a (* (length a) 2))         (let ((new (make-array (* (length a) 2))))           (replace new a :end1 (length a))           new)))  (double (make-array 30))(2) The meaning of the SIMPLE-ARRAY type remains unclear.  In particular,it is not clear whether the following function is valid Common Lisp orcan violate the type declaration:  (defun foo ()    (let ((a (make-array 100)))      (declare (simple-array a))      ...))The unamended proposal addressed issue 1, but neither it nor theamendment addressed issue 2.I propose to replace the amended proposal, which X3J13 has already votedin, with the following.  Any comments?  Should this be sent out in theupcoming letter ballot?  Should I remove the discussion, since the proposalhas in effect been rewritten twice since that discussion occurred?Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289)Category:     CLARIFICATION/CHANGEEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting toshorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bugintroduced                        by the amendment, add clarification of SIMPLE-ARRAYtype.Problem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' This is inconsistent with  ADJUSTABLE-ARRAY-P.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY.  The definition of the SIMPLE-ARRAY type and its subtypes needs  clarification of its relationship to adjustability.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):  1. ADJUST-ARRAY signals an error if ADJUSTABLE-ARRAY-P of its  first argument is false.  ADJUST-ARRAY does not signal an "array  not adjustable" error if ADJUSTABLE-ARRAY-P of its first argument  is true.  2. ADJUSTABLE-ARRAY-P is true of all arrays created with a non-NIL  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.  3. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER, and  :DISPLACED-TO arguments each either unspecified or NIL, the resulting  array is a simple array.  (This just repeats what CLtL says on page 289,  it's here to aid in understanding the next point.)  4. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments non-NIL, whether the resulting  array is simple is unspecified.Rationale:  This effectively makes the status quo explicit.  This preserves the  raison d'etre of simple arrays, which is to provide a portable interface  to implementation-dependent specialized arrays that trade decreased  functionality for faster access.  Specifying the points left unspecified (requiring all simple arrays to be  non-adjustable and all adjustable arrays to be non-simple) would require  large changes to some implementations and would be of little benefit to  users, merely making one kind of nonconforming program fail in all  implementations instead of failing only in some implementations.  Users  need to know that certain arrays are simple, so they can put in  declarations and get higher performance, but users have no need to be  able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable (to cause errors).The following are logical consequences of this proposal:  Whether an array can be both simple and adjustable is unspecified.  There is no specified way to create an array for which ADJUSTABLE-ARRAY-P  definitely returns NIL.  There is no specified way to create an array that is non-simple.  This legitimizes ADJUSTABLE-ARRAY-P as an appropriate predicate to  determine whether ADJUST-ARRAY will reliably succeed.Examples:  1. The following program is conforming.  It is unspecified which branch  of the IF it follows.      (defun double (a)       (if (adjustable-array-p a)           (adjust-array a (* (length a) 2))           (let ((new (make-array (* (length a) 2))))             (replace new a :end1 (length a))             new)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is simple,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and make all arrays non-simple unless the Common Lisp  language requires them to be simple, and are compatible with thisproposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have tochange.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language explicitly unspecified is more aesthetic than having it  implicitly unspecified on account of vague or inconsistent documentation.Discussion:  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.     ----- End Forwarded Messages -----*start*10629 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 FEB 89 16:16:06 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Feb 89  16:15:08 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 FEB 89 15:57:52 PSTDate: 14 Feb 89 15:56 PSTFrom: masinter.paSubject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: cl-cleanup@sail.stanford.eduMessage-ID: <890214-155752-10883@Xerox>I'm sorry it has taken me so long to get back to this. Unfortunately, not all of the mail was cc'd to cl-cleanup, which resultedin a number of crossed signals.I have a fairly lengthy conversation initiated by the enclosed messagewhich transpired between Jan 27 and Jan 30, plus Guy Steele's attempt tofix the same problem, and the discussion of that, and then a fairlystrongly-worded rejoinder from JonL on the issue.The status is that Version 5 (i.e., Version 4, with an amendedment) passedat the January 1989 X3J13 meeting.   David has proposed a Version 6, whichI enclose. I'm uncertain whether this version is really unacceptable; itlooks OK to me, and, I think, if I re-read all the mail from Dussud, maybeit is OK with him too. (Still.)At the risk of making you repeat yourself, if you have specificrecommendations you think would make Version 6 better than it is now, couldyou please restate them?It will help if we can keep the tone of the discussion low-key. Please keepperjoratives and characterizations to a minimum. Thanks,Larry     ----- Begin Forwarded Messages -----Return-Path: <Moon@ALDERAAN.SCRC.Symbolics.COM>Received: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by Xerox.COM ;25 JAN 89 16:32:05 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COMvia CHAOS with CHAOS-MAIL id 262758; Mon 23-Jan-89 16:27:19 ESTDate: Mon, 23 Jan 89 16:27 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: RPG@lucid.com, JonL@lucid.com, Dussud@lucid.com, Masinter.pa,Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <19890123212739.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoThere were some wording problems with the amended version ofADJUST-ARRAY-NOT-ADJUSTABLE that was passed at the X3J13 meetinglast week.  It ended up not saying what I think was intended.Two problems:(1) The amendment made the following function have undefined behaviorin some perfectly meaningful cases, such as the call shown:  (defun double (a)     (if (adjustable-array-p a)         (adjust-array a (* (length a) 2))         (let ((new (make-array (* (length a) 2))))           (replace new a :end1 (length a))           new)))  (double (make-array 30))(2) The meaning of the SIMPLE-ARRAY type remains unclear.  In particular,it is not clear whether the following function is valid Common Lisp orcan violate the type declaration:  (defun foo ()    (let ((a (make-array 100)))      (declare (simple-array a))      ...))The unamended proposal addressed issue 1, but neither it nor theamendment addressed issue 2.I propose to replace the amended proposal, which X3J13 has already votedin, with the following.  Any comments?  Should this be sent out in theupcoming letter ballot?  Should I remove the discussion, since the proposalhas in effect been rewritten twice since that discussion occurred?Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289)Category:     CLARIFICATION/CHANGEEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting toshorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bugintroduced                        by the amendment, add clarification of SIMPLE-ARRAYtype.Problem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' This is inconsistent with  ADJUSTABLE-ARRAY-P.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY.  The definition of the SIMPLE-ARRAY type and its subtypes needs  clarification of its relationship to adjustability.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):  1. ADJUST-ARRAY signals an error if ADJUSTABLE-ARRAY-P of its  first argument is false.  ADJUST-ARRAY does not signal an "array  not adjustable" error if ADJUSTABLE-ARRAY-P of its first argument  is true.  2. ADJUSTABLE-ARRAY-P is true of all arrays created with a non-NIL  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.  3. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER, and  :DISPLACED-TO arguments each either unspecified or NIL, the resulting  array is a simple array.  (This just repeats what CLtL says on page 289,  it's here to aid in understanding the next point.)  4. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments non-NIL, whether the resulting  array is simple is unspecified.Rationale:  This effectively makes the status quo explicit.  This preserves the  raison d'etre of simple arrays, which is to provide a portable interface  to implementation-dependent specialized arrays that trade decreased  functionality for faster access.  Specifying the points left unspecified (requiring all simple arrays to be  non-adjustable and all adjustable arrays to be non-simple) would require  large changes to some implementations and would be of little benefit to  users, merely making one kind of nonconforming program fail in all  implementations instead of failing only in some implementations.  Users  need to know that certain arrays are simple, so they can put in  declarations and get higher performance, but users have no need to be  able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable (to cause errors).The following are logical consequences of this proposal:  Whether an array can be both simple and adjustable is unspecified.  There is no specified way to create an array for which ADJUSTABLE-ARRAY-P  definitely returns NIL.  There is no specified way to create an array that is non-simple.  This legitimizes ADJUSTABLE-ARRAY-P as an appropriate predicate to  determine whether ADJUST-ARRAY will reliably succeed.Examples:  1. The following program is conforming.  It is unspecified which branch  of the IF it follows.      (defun double (a)       (if (adjustable-array-p a)           (adjust-array a (* (length a) 2))           (let ((new (make-array (* (length a) 2))))             (replace new a :end1 (length a))             new)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is simple,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and make all arrays non-simple unless the Common Lisp  language requires them to be simple, and are compatible with thisproposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have tochange.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language explicitly unspecified is more aesthetic than having it  implicitly unspecified on account of vague or inconsistent documentation.Discussion:  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.     ----- End Forwarded Messages -----*start*02563 00024 USaReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 15 FEB 89 06:44:21 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 539457; Wed 15-Feb-89 09:43:48 ESTDate: Wed, 15 Feb 89 09:43 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890214-155752-10883@Xerox>Message-ID: <890215094330.2.KMP@BOBOLINK.SCRC.Symbolics.COM>The message you sent to CL-Cleanup is only the earliest of a lot ofmessages from that private conversation. To avoid replaying that wholeconversation, I offer here a summary of the discussion. For brevity,I have paraphrased rather than quoted. RPG - This proposal (v6) says ADJUST-ARRAY must signal. CLtL says       ``is an error.''  Moon - This introduction of incompatible change was not intentional.	Still, ``must signal'' doesn't seem bad. RPG - Eliminates option of ignoring error checking in highly optimized code. Pitman - Can we compromise on ``should signal'' ? RPG - OK. RPG - Not sure if this is implied, should add:        5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified. No one objected. RPG - Alternate presentation, incorporating new items and clarifications       per above, and changing subtle aspects of the presentation:	1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true	:ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is	true of some other arrays is unspecified.      	2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,         and :DISPLACED-TO arguments each either unspecified or false, the        resulting array is a simple array.  (This just repeats what CLtL        says on page 289, it's here to aid in understanding the next point.)      	3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,	:FILL-POINTER, or :DISPLACED-TO arguments true, whether the        resulting array is simple is unspecified.      	4. If ADJUST-ARRAY is invoked on an array that was created without	supplying :ADJUSTABLE true, an error should be signaled, unless 	ADJUSTABLE-ARRAY-P returns true on that array. ADJUST-ARRAY must	not signal the error if ADJUSTABLE-ARRAY-P is true for its first        argument.       	5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified. KMP - Looks ok. No one else commented.*start*01069 00024 US Return-Path: <dussud@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 15 FEB 89 08:16:08 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA01940g; Wed, 15 Feb 89 08:09:39 PSTReceived: by challenger id AA03972g; Wed, 15 Feb 89 08:03:49 PSTDate: Wed, 15 Feb 89 08:03:49 PSTFrom: Patrick Dussud <dussud@lucid.com>Message-Id: <8902151603.AA03972@challenger>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 14 Feb 89 15:56 PST <890214-155752-10883@Xerox>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)   Date: 14 Feb 89 15:56 PST   From: masinter.pa@Xerox.COM   The status is that Version 5 (i.e., Version 4, with an amendedment) passed   at the January 1989 X3J13 meeting.   David has proposed a Version 6, which   I enclose. I'm uncertain whether this version is really unacceptable; it   looks OK to me, and, I think, if I re-read all the mail from Dussud, maybe   it is OK with him too. (Still.)This version is OK with me. *start*00688 00024 US Date: 15 Feb 89 08:27 PSTFrom: masinter.paSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 15 Feb 89 09:43 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUYes, there was lots of subsequent discussion. However, it remains that I only have version 6. One of the following can happen:Someone can write Version 7We can release Version 6We can let Version 5 (i.e., as amended at the meeting) stand.We can vote to rescind version 5 at the next meeting.I can't think of any other options. Which do you prefer?*start*02382 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 FEB 89 10:00:14 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 15 Feb 89  09:57:12 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa08188; 15 Feb 89 17:19 GMTDate: Wed, 15 Feb 89 17:41:50 GMTMessage-Id: <4398.8902151741@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@com.xerox's message of 14 Feb 89 15:56 PST>   The description of ADJUST-ARRAY on pp297-298 says that it is>   ``not permitted to call ADJUST-ARRAY on an array that was not>   created with the :ADJUSTABLE option.'' This is inconsistent with>   ADJUSTABLE-ARRAY-P.Well, the other sections don't say anything explicitly, and this onedoes; so why doesn't this one take precedence?>   Specifying the points left unspecified (requiring all simple arrays to be>   non-adjustable and all adjustable arrays to be non-simple) would require>   large changes to some implementations and would be of little benefit to>   users, merely making one kind of nonconforming program fail in all>   implementations instead of failing only in some implementations. This is kind of strange.  I think it's a good thing when nonconformingprograms fail everywhere, and not something we should just dismiss.We should allow such differences only when there are good reasons todo so.>   Users>   need to know that certain arrays are simple, so they can put in>   declarations and get higher performance, but users have no need to be>   able to create arrays that are definitely non-simple (for lower>   performance) or definitely non-adjustable (to cause errors).Surely the performance of an array with certain characteristicsis the same whether or not we say it's simple.  So creating arraysthat are definitely non-simple is not a request for lower performance.>   Pitman wishes some of the other proposals were economically feasible to>   pursue but reluctantly agrees that maintaining (and clearly documenting)>   the status quo is probably the most reasonable avenue left to us.Sigh.*start*03378 00024 USaReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 15 FEB 89 10:56:24 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 539710; Wed 15-Feb-89 13:55:11 ESTDate: Wed, 15 Feb 89 13:54 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKcc: masinter.pa, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <4398.8902151741@subnode.aiai.ed.ac.uk>Message-ID: <890215135452.8.KMP@BOBOLINK.SCRC.Symbolics.COM>[CL-Cleanup removed to avoid repeating a debate that I'd thought was settled. Masinter retained just so he knows this exchange occurred.]    Date: Wed, 15 Feb 89 17:41:50 GMT    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>    >   The description of ADJUST-ARRAY on pp297-298 says that it is    >   ``not permitted to call ADJUST-ARRAY on an array that was not    >   created with the :ADJUSTABLE option.'' This is inconsistent with    >   ADJUSTABLE-ARRAY-P.    Well, the other sections don't say anything explicitly, and this one    does; so why doesn't this one take precedence?Over what? I don't understand the point you're trying to make here.I suspect that if you made a positive assertion about some statementyou thought was a unique interpretation, or some claim about how weshould proceed that was different than how we are proceeding, then Icould respond appropriately.    >   Specifying the points left unspecified (requiring all simple arrays to be    >   non-adjustable and all adjustable arrays to be non-simple) would require    >   large changes to some implementations and would be of little benefit to    >   users, merely making one kind of nonconforming program fail in all    >   implementations instead of failing only in some implementations.     This is kind of strange.  I think it's a good thing when nonconforming    programs fail everywhere, and not something we should just dismiss.    We should allow such differences only when there are good reasons to    do so.I agree it's not unuseful, but in terms of dollars (or pick yourfavorite monetary unit) it is hard to say how useful. On the other hand, thecost to Symbolics of a change could be extremely high. It would invalidateall our current implementation's data structures, require recoding of numerousthings in our system, require potentially extensive debugging, require changesin documentation, etc.  The cost in dollars could be extremely high.The X3J13 charter says that we are to weigh the costs, and from where Istand the difference between real and measurable costs of that sort vsthe possible advantages of making the change (which is that no newprogram would become valid) makes the choice clear.Symbolics has bowed to other implementations in the past on their needto not make extraordinary changes or suffer enormous penalties that putthem at some competitive disadvantage -- in doing semantic prescan inthe interpreter, in permitting other implementations to not catch allarithmetic type errors all the time, etc.  It seems only fair that weshould occassionally also be able to have potential costs to us be takeninto account by others.*start*01877 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 FEB 89 11:25:52 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 15 Feb 89  11:26:18 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 15 FEB 89 11:16:23 PSTDate: 15 Feb 89 11:12 PSTFrom: masinter.paSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 15 Feb 89 13:54 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK, cl-cleanup@sail.stanford.eduline-fold: NOMessage-ID: <890215-111623-12827@Xerox>>	[CL-Cleanup removed to avoid repeating a debate that I'd thought was>	 settled. Masinter retained just so he knows this exchange occurred.]Those who send private mail have to take the risk of having to see theirarguments repeated.I think that the only issue we really have the charter to attack is to"fix" what we think was a mistake in the wording of the amendment thatwas accepted at the last meeting. I don't think we should revisit the issue itself. The intent at the X3J13meeting was to endorse a proposal where ADJUST-ARRAY might in factwork in some implementations on arrays that were made with :ADJUSTABLENIL as long as they were ADJUSTABLE-ARRAY-P. We think that theamendment made to achieve that purpose also made some other programs which we think are portable now invalid/non-conformal, and so lets fix that.I see no reason to reconsider the entire issue.The question remains: does Version 6 adequately fix the "mistake" madein Version 5? Dussud and Moon think so.Do KMP and RPG disagree? I'm unclear about whether the "Alternate presentation"from RPG is meant as an improvement over Version 6. *start*10011 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 FEB 89 11:24:21 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Feb 89  11:24:16 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 539743; Wed 15-Feb-89 14:22:16 ESTDate: Wed, 15 Feb 89 14:21 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: [Moon@STONY-BROOK.SCRC.Symbolics.COM: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)]To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890215-082818-12355@Xerox>References: <19890123212739.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <890215142157.9.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 15 Feb 89 08:27 PST    From: masinter.pa@Xerox.COM        ... it remains that I only have version 6. ... Someone can     write Version 7 ...Ok, you asked for it... This version makes the following changes: - It makes adjust array `should signal' rather than `must signal'   in the array-not-adjustable case. I believe this to be the only   `consequential' difference between this and version 6. - It uses RPG's presentation for the proposal, except for RPG's   item #4 (Moon's item #1). I've used Moon's presentation style   but have effectively added RPG's presentation under    "Clarifications and Logical Consequences". Hopefully that will   make things doubly clear. - I've moved "the clarifications up above the rationale" so that   they feel more like an extension of the proposal itself. - I've split paragraph 2 of the Rationale into two paragraphs,   adding a sentence at the end of the new paragraph 2 to help   address Jeff's perception that we were characterizing error   detection as an activity without value. - Everything else is pretty much left untouched.-----Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289)Category:     CLARIFICATION/CHANGEEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting to shorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bug introduced                        by the amendment, add clarification of SIMPLE-ARRAY type.	      15-Feb-89, Version 7, by Pitman. Minor changes per comments from			RPG and Dalton.Problem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' This is inconsistent with  ADJUSTABLE-ARRAY-P.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY.  The definition of the SIMPLE-ARRAY type and its subtypes needs  clarification of its relationship to adjustability.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):  1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.   2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,   and :DISPLACED-TO arguments each either unspecified or false, the  resulting array is a simple array.  (This just repeats what CLtL  says on page 289, it's here to aid in understanding the next point.)        3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the  resulting array is simple is unspecified.        4. ADJUST-ARRAY ``should signal'' an error if ADJUSTABLE-ARRAY-P  of its first argument is false.  ADJUST-ARRAY must not signal an  `array not adjustable' error if ADJUSTABLE-ARRAY-P of its first  argument is true.  5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.  Note: ``should signal'' is taken from the new error terminology.  It means that in ``safe code'' (code compiled with highest safety)  an error must be signalled, but that in unsafe code (code not compiled  with highest safety), an error might or might not be signalled.Clarifications and Logical Consequences:  a. Whether an array can be both simple and adjustable is unspecified.  b. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.  c. There is no specified way to create an array that is non-simple.  d. This legitimizes ADJUSTABLE-ARRAY-P as an appropriate predicate to     determine whether ADJUST-ARRAY will reliably succeed.  e. If ADJUST-ARRAY is invoked on an array that was created without     supplying :ADJUSTABLE true, an `array not adjustable' error     ``should be signalled'' unless ADJUSTABLE-ARRAY-P returns true on     that array (in which case it must not signal an `array not adjustable'     error).Rationale:  This effectively makes the status quo explicit.  This preserves the  raison d'etre of simple arrays, which is to provide a portable interface  to implementation-dependent specialized arrays that trade decreased  functionality for faster access.  Specifying the points left unspecified (requiring all simple arrays to be  non-adjustable and all adjustable arrays to be non-simple) would require  large changes to some implementations and would be of little benefit to  users, merely making one kind of nonconforming program fail in all  implementations instead of failing only in some implementations. The   argument here is not that the error checking would not be useful for  developers of portable code, but only that the cost of introducing that  error checking would be exceedingly high for some implementations.  Users need to know that certain arrays are simple, so they can put in  declarations and get higher performance, but users have no need to be  able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable (to cause errors).Examples:  1. The following program is conforming.  It is unspecified which branch  of the IF it follows.      (defun double (a)       (if (adjustable-array-p a)           (adjust-array a (* (length a) 2))           (let ((new (make-array (* (length a) 2))))             (replace new a :end1 (length a))             new)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is simple,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and make all arrays non-simple unless the Common Lisp  language requires them to be simple, and are compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language explicitly unspecified is more aesthetic than having it  implicitly unspecified on account of vague or inconsistent documentation.Discussion:  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.*start*04584 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 28 FEB 89 02:38:42 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00847g; Tue, 28 Feb 89 02:33:59 PSTReceived: by bhopal id AA08748g; Tue, 28 Feb 89 02:36:21 PSTDate: Tue, 28 Feb 89 02:36:21 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8902281036.AA08748@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 15 Feb 89 11:12 PST <890215-111623-12827@Xerox>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)re: I think that the only issue we really have the charter to attack is to    "fix" what we think was a mistake in the wording of the amendment that    was accepted at the last meeting. There were two sorts of "bugs" in the proposal as brought to, andvoted upon in, Hawai:  (1) a number of little unclarities about the precise relationship      between ADJUSTABLE-ARRAY-P and error signalling in ADJUST-ARRAY  (2) Confusion as to whether or not the type SIMPLE-ARRAY was to      changed from the simple defintion on CLtL p28.Presumably (1) has been the subject of the volumes of "private" mail,and much related public mail.  However, I still don't see any clear statement in the latest proposal regarding point (2) -- namely that it is not trying to change the type SIMPLE-ARRAY.  There is in fact avery confusing statement in the rationale section of the most recentversion:  "Specifying the points left unspecified (requiring all simple arrays to be   non-adjustable and all adjustable arrays to be non-simple) would require   large changes to some implementations and would be of little benefit to   ..."Virtually everyone who reads the last paragraph of CLtL p.28 believes it to be a _definition_ of SIMPLE-ARRAY (except some folks at Symbolics) -- and that clearly says non-adjustable.  In previous mail, I alluded to reasons why the _utility_ of the type SIMPLE-ARRAY requires it to mean non-adjustable; that was the clear consensus of all the "stock-hardware" compiler implementors who where at Hawaii (and at least one otherimplementor too).  There is simply no point at all in having SIMPLE-ARRAYin the language if it isn't of critical use to these implementations.As someone mentioned, there is language in CLtL about how simple-arraysmight be implemented "differently" from implementation to implementation(i.e., "be more efficient on some implementations", or whatever).  Couldthat statement be the source that has misled so many people to believe that the permission to implement the  internal structure differently gives a permission to implement the type differently?  Considering the tremendous amount of time wasted arguing this non point, it would be a great help if the final version of the issue contained the simple statement: "This proposal does not alter the definition of SIMPLE-ARRAY in any way."Here's a synopsis of the damage that can occur unless some suchclarification is made.  Consider the following function:     (defun fast-aref (x i)       (declare (optimize (safety 0) (speed 3)))       (check-type x (simple-array t 1))       (setf (aref (the (simple-array t 1) x) i)	;open-compiled             :encountered)       t)     (defparameter foo (make-array 5 :adjustable t))What happens when FOO is passed to FAST-AREF?  If SIMPLE-ARRAY can't be assured to mean non-adjustable, then either the aforementioned compiler-writers must give up their long-held technology that allows Lisp to compete with C; or perhaps they would ignore this issue entirely, andthe portability of Common Lisp would be officially compromised.  That is,if the language permits SIMPLE-ARRAY to mean one thing in one implementation,and another thing in another implementation (under a false sense of permitting optional efficiency), then this little example will "break" in one implementation but will "work" in the other -- in short, the type SIMPLE-ARRAY will not be portable.  I seriously doubt that the "stock hardware" types will give up their optimizations.  Hence we must ask ourselves whether we would view non-portability of SIMPLE-ARRAY as a simply a fact that one (or two?) implementations never did (and never will?) fulfill the definition on p28; or whether we view it is a **good thing** to be non-portable (as in the remaining cases of the FIXNUM type).  If it comes to the latter, then I think we will have to admit that the standardization process will have failed.-- JonL --*start*07925 00024 US Return-Path: <gls@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 28 FEB 89 11:46:29 PSTReceived: from fafnir.think.com by Think.COM; Tue, 28 Feb 89 14:15:16 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Tue, 28 Feb 89 14:13:09 ESTReceived: by verdi.think.com; Tue, 28 Feb 89 14:13:37 ESTDate: Tue, 28 Feb 89 14:13:37 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8902281913.AA03555@verdi.think.com>To: jonl@lucid.comCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Tue, 28 Feb 89 02:36:21 PST <8902281036.AA08748@bhopal>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)It is important at this stage to have specific code examples to look at,and I am glad that Jonl has provided one.  Unfortunately, it does notappear to back his claim.  (This is not to say that there cannot be someother piece of code to back his claim, and I hope that he will produceanother example.)   Date: Tue, 28 Feb 89 02:36:21 PST   From: Jon L White <jonl@lucid.com>   ...   Here's a synopsis of the damage that can occur unless some such   clarification is made.  Consider the following function:	(defun fast-aref (x i)	  (declare (optimize (safety 0) (speed 3)))	  (check-type x (simple-array t 1))	  (setf (aref (the (simple-array t 1) x) i)	;open-compiled		:encountered)	  t)	(defparameter foo (make-array 5 :adjustable t))   What happens when FOO is passed to FAST-AREF?Let's look at this closely.  Consider two implementations (A) and (B).  In(A) ["Symbolics"] an array may be both adjustable and simple; that is,simpleness might depend on fill-pointerness and displacedness but isindependent of adjustability.  In (B) ["stock hardware"] an array can neverbe both adjustable and simple. For each implementation I will consider compile-time actions and thenrun-time actions.  Assume that both compilers open-code SETF, and forsimplicity assume that displacedness or fill-pointerness does not affectthe open-coding.(1) The compiler for implementation (A), knowing that simple arrays maynevertheless be adjustable, will generate code that handles arraysregardless of adjustability.The CHECK-TYPE form will determine that the array is simple, and executionwill continue.  Because the array is in fact simple, the declaration in theTHE form is correct.  The SETF will be executed.(2)  The compiler for implementation (B) is justified in generating open codefor the SETF that does not handle adjustable arrays, because the array hasbeen declared via THE to be simple, and the compiler knows that inimplementation (B) simple arrays are not adjustable.  Moreover, thecompiler is justified in producing such code even at high safety, becausenon-simple arrays will not get past the CHECK-TYPE form.The CHECK-TYPE form will determine that the array is not simple, and anerror will be signalled.Now, the two implementations behave differently on the example, and that isa cause for concern.Let us now examine the two behaviors described above under two differentinterpretations of "simple-array" type specifiers.  One is the strictinterpretation that adjustable arrays may never be simple.  The other isthe more liberal interpretation that I proposed: namely that fordeclaration "simple-array" means that you *tried* to make it simple (byspecifying :adjustable nil) or that you have checked that it is simple; andfor discrimination an adjustable array is considered non-simple only if theimplementation in fact relies on that distinction.Before I proceed further I must reaffirm an important principle on which Ijudge correctness and conformance.	It is *not* required that two implementations have the same behavior	when executing an erroneous program.This has two consequences:(i) It is permitted for an implementation to extend the language by definingwithin that implementation a meaning for particular kinds of erroneous code.(ii) A programmer may not rely on a valid implementation to identify everyerror in a program.  In other words, successful execution of a program inone implementation is not a guarantee that the program is free of errors,and is not a guarantee that the program will execute successfully inanother implementation.  The only guarantee of equivalent execution in twoimplmentations is that the program in fact be free of errors.This principle is relevant to evaluating Jonl's claim:   ... if the language permits SIMPLE-ARRAY to mean one thing in one   implementation, and another thing in another implementation (under a   false sense of permitting optional efficiency), then this little example   will "break" in one implementation but will "work" in the other --   in short, the type SIMPLE-ARRAY will not be portable.  because his argument about nonportability is not sound unless the programin question is correct (and I have seen this argument advanced in previousdiscussions in cases where the example under discussion was not correct).Therefore we must establish that the program is correct before comparingthe implementations.  (In preparing this analysis I considered a variant ofthe given example in which the CHECK-TYPE form was omitted, and concludedthat this program was erroneous under either interpretation.)I argue that the program is correct under both interpretations.  Thepresence of the CHECK-TYPE form is crucial to correctness, for it isguaranteed to filter out non-simple arrays before the AREF is encountered.(From the point of view of code generation, it is guaranteed to filter outarrays that the open code for SETF cannot handle.)Under the strict interpretation implementation (A) is incorrect bydefinition.  Under the liberal interpretation implementation (A) iscorrect, and accomplishes a useful purpose.Let us therefore examine the question of which interpretation is tobe preferred.(a) The strict interpretation would seem to adhere more closely to thedefinition of simple arrays given in CLtL, p. 28, and some weight must begiven to adhering to CLtL.  However, there is arguably some ambiguity inthe wording, as it refers to an array that "is not to be adjusted"; perhapsadjustable arrays fall into this category if the program in fact nevermakes any attempt to adjust them.(b) A program might attempt to use adjustability as an explicitinformation conduit, rather than simply as advice to the implementationon speedy array implementations:	(defun hairy-print (a)	  (let ((*print-pretty* (typep a 'simple-array)))	    (print wazoo)))	(hairy-print (make-array 3 :adjustable nil))In implementation (A) this would not have the (bizarrely) intended effect.I conclude that the strict interpretation may be preferred, but not for thereasons Jonl has advanced!  The liberal interpretation does *not* preventcompilers for stock hardware from producing good code, and therefore thecode example does not support his claim to the contrary.Moreover, an argument that code might behave differently in twoimplementations and therefore impede debugging is rather a red herring,because (I claim) such differing behaviors occur only when the program iserroneous (in which case implementations are permitted to differ) or whenthe program is using adjustability as an information conduit for reasonsunrelated to getting good array performance.We may wish to regard the latter point as justification for preferring thestrict interpretation anyway, because implementations are required tofaithfully execute *all* correct programs, not just sensible ones.Whichever interpretation is agreed upon, let it be for good and carefulreasons.  I don't believe that the arguments advanced so far based on adesire for good open code on stock hardware have yet provided a clearcriterion for preferring one interpretation over the other.--Guy*start*01143 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 07 MAR 89 15:31:34 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 552530; Tue 7-Mar-89 18:30:57 ESTDate: Tue, 7 Mar 89 18:30 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 7)To: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMReferences: <890215142157.9.KMP@BOBOLINK.SCRC.Symbolics.COM>,            The message of 15 Feb 89 14:21 EST from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Message-ID: <890307183051.5.KMP@BOBOLINK.SCRC.Symbolics.COM>The referenced message, which bore the subject line: [Moon@STONY-BROOK.SCRC.Symbolics.COM: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)]was really version 7 in disguise.In spite of GLS's and JonL's detailed side-track since then,I think this represents as close as we're going to get priorto meeting time, and I think it should be forwarded to X3J13.If you disagree, we should talk about it.*start*04155 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 09 MAR 89 12:24:24 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 553963; Thu 9-Mar-89 15:23:35 ESTDate: Thu, 9 Mar 89 15:23 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 7)To: Patrick Dussud <dussud@lucid.com>, Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Richard P. Gabriel <rpg@lucid.com>, masinter.pa, gls@Think.COM, Jon L White <jonl@lucid.com>, Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8901271629.AA21144@challenger>,             <19890128032256.5.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <890130110045.5.KMP@BOBOLINK.SCRC.Symbolics.COM>,             <8901301613.AA03528@challenger>,             <19890130164936.0.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <8901301750.AA03759@challenger>,             <890130142828.2.KMP@BOBOLINK.SCRC.Symbolics.COM>,             <8901301933.AA03928@challenger>,             <8901302154.AA04106@challenger>,             <890130173552.5.KMP@BOBOLINK.SCRC.Symbolics.COM>,             <890130-144905-6017@Xerox>,             <19890131045316.7.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <8902020519.AA03069@sauron.think.com>,             <8902061636.AA27928@verdi.think.com>,             <8902072038.AA23870@bhopal>,             <890214-155752-10883@Xerox>,             <890215094330.2.KMP@BOBOLINK.SCRC.Symbolics.COM>,             <8902151603.AA03972@challenger>,             <890215-082818-12355@Xerox>,             <4398.8902151741@subnode.aiai.ed.ac.uk>,             <890215-111623-12827@Xerox>,             <890215142157.9.KMP@BOBOLINK.SCRC.Symbolics.COM>,             <8902281036.AA08748@bhopal>,             <8902281913.AA03555@verdi.think.com>Message-ID: <19890309202310.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoAfter re-reading all 24 of these messages, I believe that version 7,mailed by KMP on Feb 15, adequately captures the result of the discussion.I would certainly like to vote yes on it at the end of this monthand then never hear about it again.  There are a couple of smallchanges that are worth making; see below.I believe it captures what RPG was looking for, but I'd like to hearconfirmation of that from Dick.Part of this issue is JonL's concern that the type SIMPLE-ARRAY is notadequately specified.  I believe that the logical implications of theversion 7 proposal adequately specify the meaning of SIMPLE-ARRAY, andthat this is not a change from CLtL, only a clarification.  Evidentlythere are other ways to read the sentence at the bottom of p.28, but theway I read it, it says that simple arrays are ones that animplementation can handle in a more efficient manner, and that arraysthat don't use certain features are simple, but does not say that noother arrays can be simple.  Do we need to add any language to theversion 7 proposal to clarify this?  Adding JonL's suggested "This proposal does not alter the definition of SIMPLE-ARRAY in any way."would be fine with me.  By the way I feel that I completely understandthe stock hardware implementors' concern with simple arrays and thatthis proposal does not harm that concern in any fashion.The front of the version 7 writeup says Category: CLARIFICATION/CHANGE,but I believe it is only a clarification.  The only part that might becounted as a change is the replacement of CLtL's "It is not permitted tocall ADJUST-ARRAY on an array that was not created with the :ADJUSTABLEoption" (p.297) with "ADJUST-ARRAY should signal an error ifADJUSTABLE-ARRAY-P of its first argument is false."  I think it's not achange, because it doesn't affect any conforming programs, it onlyaffects implementations.  As the proposal says  Cost to Users:      None. This is a fully compatible change from the user's standpoint.Thus I would like to see the category at the front changed to plainCLARIFICATION.*start*00955 00024 US Return-Path: <rpg@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 09 MAR 89 13:09:41 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA06442g; Thu, 9 Mar 89 13:03:35 PSTReceived: by challenger id AA01857g; Thu, 9 Mar 89 12:58:59 PSTDate: Thu, 9 Mar 89 12:58:59 PSTFrom: Richard P. Gabriel <rpg@lucid.com>Message-Id: <8903092058.AA01857@challenger>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: dussud@lucid.com, KMP@STONY-BROOK.SCRC.Symbolics.COM, masinter.pa, gls@Think.COM, jonl@lucid.com, jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Thu, 9 Mar 89 15:23 EST <19890309202310.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 7)I agree with ADJUST-ARRAY-NOT-ADJUSTABLE (Version 7) as written byKMP.  I agree with Moon that it is a clarification not a change.			-rpg-*start*01020 00024 US Return-Path: <gls@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 10 MAR 89 12:09:55 PSTReceived: from fafnir.think.com by Think.COM; Fri, 10 Mar 89 14:41:47 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 10 Mar 89 14:43:13 ESTReceived: by verdi.think.com; Fri, 10 Mar 89 14:40:01 ESTDate: Fri, 10 Mar 89 14:40:01 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903101940.AA18605@verdi.think.com>To: rpg@lucid.comCc: Moon@stony-brook.scrc.symbolics.com, dussud@lucid.com, KMP@stony-brook.scrc.symbolics.com, masinter.pa, gls@Think.COM, jonl@lucid.com, jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK, cl-cleanup@sail.stanford.eduIn-Reply-To: Richard P. Gabriel's message of Thu, 9 Mar 89 12:58:59 PST <8903092058.AA01857@challenger>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 7)I also agree with ADJUST-ARRAY-NOT-ADJUSTABLE (Version 7) as written byKMP.  I agree with Moon that it is a clarification not a change.--Guy*start*01170 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 MAR 89 12:11:04 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 10 Mar 89  12:11:33 PSTReceived: from fafnir.think.com by Think.COM; Fri, 10 Mar 89 14:41:47 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 10 Mar 89 14:43:13 ESTReceived: by verdi.think.com; Fri, 10 Mar 89 14:40:01 ESTDate: Fri, 10 Mar 89 14:40:01 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903101940.AA18605@verdi.think.com>To: rpg@lucid.comCc: Moon@stony-brook.scrc.symbolics.com, dussud@lucid.com, KMP@stony-brook.scrc.symbolics.com, masinter.pa, gls@Think.COM, jonl@lucid.com, jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK, cl-cleanup@sail.stanford.eduIn-Reply-To: Richard P. Gabriel's message of Thu, 9 Mar 89 12:58:59 PST <8903092058.AA01857@challenger>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 7)I also agree with ADJUST-ARRAY-NOT-ADJUSTABLE (Version 7) as written byKMP.  I agree with Moon that it is a clarification not a change.--Guy*start*09017 00024 USfReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 11 MAR 89 12:22:35 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 555128; Sat 11-Mar-89 15:22:01 ESTDate: Sat, 11 Mar 89 15:21 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)To: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <890311152144.3.KMP@BOBOLINK.SCRC.Symbolics.COM>To save you editing time, I made changes per recent mail: - Changed Category to "Clarification" - Added endorsements of RPG, GLS, and Moon.I didn't cc CL-Cleanup to save some mail traffic since I think this isready to send to all of X3J13. -kmp-----Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289)Category:     CLARIFICATIONEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting to shorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bug introduced                        by the amendment, add clarification of SIMPLE-ARRAY type.	      15-Feb-89, Version 7, by Pitman. Minor changes per comments from			RPG and Dalton.	      11-Mar-89, Version 8, by Pitman. Change category, add endorsements.Problem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' This is inconsistent with  ADJUSTABLE-ARRAY-P.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY.  The definition of the SIMPLE-ARRAY type and its subtypes needs  clarification of its relationship to adjustability.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):  1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.   2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,   and :DISPLACED-TO arguments each either unspecified or false, the  resulting array is a simple array.  (This just repeats what CLtL  says on page 289, it's here to aid in understanding the next point.)        3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the  resulting array is simple is unspecified.        4. ADJUST-ARRAY ``should signal'' an error if ADJUSTABLE-ARRAY-P  of its first argument is false.  ADJUST-ARRAY must not signal an  `array not adjustable' error if ADJUSTABLE-ARRAY-P of its first  argument is true.  5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.  Note: ``should signal'' is taken from the new error terminology.  It means that in ``safe code'' (code compiled with highest safety)  an error must be signalled, but that in unsafe code (code not compiled  with highest safety), an error might or might not be signalled.Clarifications and Logical Consequences:  a. Whether an array can be both simple and adjustable is unspecified.  b. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.  c. There is no specified way to create an array that is non-simple.  d. This legitimizes ADJUSTABLE-ARRAY-P as an appropriate predicate to     determine whether ADJUST-ARRAY will reliably succeed.  e. If ADJUST-ARRAY is invoked on an array that was created without     supplying :ADJUSTABLE true, an `array not adjustable' error     ``should be signalled'' unless ADJUSTABLE-ARRAY-P returns true on     that array (in which case it must not signal an `array not adjustable'     error).Rationale:  This effectively makes the status quo explicit.  This preserves the  raison d'etre of simple arrays, which is to provide a portable interface  to implementation-dependent specialized arrays that trade decreased  functionality for faster access.  Specifying the points left unspecified (requiring all simple arrays to be  non-adjustable and all adjustable arrays to be non-simple) would require  large changes to some implementations and would be of little benefit to  users, merely making one kind of nonconforming program fail in all  implementations instead of failing only in some implementations. The   argument here is not that the error checking would not be useful for  developers of portable code, but only that the cost of introducing that  error checking would be exceedingly high for some implementations.  Users need to know that certain arrays are simple, so they can put in  declarations and get higher performance, but users have no need to be  able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable (to cause errors).Examples:  1. The following program is conforming.  It is unspecified which branch  of the IF it follows.      (defun double (a)       (if (adjustable-array-p a)           (adjust-array a (* (length a) 2))           (let ((new (make-array (* (length a) 2))))             (replace new a :end1 (length a))             new)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is simple,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and make all arrays non-simple unless the Common Lisp  language requires them to be simple, and are compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language explicitly unspecified is more aesthetic than having it  implicitly unspecified on account of vague or inconsistent documentation.Discussion:  Pitman, Moon, Gabriel, and Steele support this amended proposal.  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.*start*09333 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 15-Mar-89 05:34:27 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 05:34:20 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 15 Mar 89  05:19:57 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 15 MAR 89 05:14:05 PSTDate: 15 Mar 89 05:13 PSTFrom: masinter.pato: X3J13@Sail.stanford.eduSubject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)reply-to: cl-cleanup@sail.stanford.eduline-fold: NOMessage-ID: <890315-051405-3472@Xerox>At the January '89 meeting, Version 4 of this issue was amended,and then accepted.We think there were some wording problems with the amendment,in that it ended up not saying what we think was intended.The amendment made some meaningful programs have undefinedbehavior, and left the meaning of SIMPLE-ARRAY unclear.After a good deal of work by the members of the cleanup committee,we've arrived at the following version, which we would liketo submit to you for consideration as to whether it moreproperly reflects the intent of the group.!Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289)Category:     CLARIFICATIONEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting to shorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bug introduced                        by the amendment, add clarification of SIMPLE-ARRAY type.	      15-Feb-89, Version 7, by Pitman. Minor changes per comments from			RPG and Dalton.	      11-Mar-89, Version 8, by Pitman. Change category, add endorsements.Problem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' This is inconsistent with  ADJUSTABLE-ARRAY-P.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY.  The definition of the SIMPLE-ARRAY type and its subtypes needs  clarification of its relationship to adjustability.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):  1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.   2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,   and :DISPLACED-TO arguments each either unspecified or false, the  resulting array is a simple array.  (This just repeats what CLtL  says on page 289, it's here to aid in understanding the next point.)        3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the  resulting array is simple is unspecified.        4. ADJUST-ARRAY ``should signal'' an error if ADJUSTABLE-ARRAY-P  of its first argument is false.  ADJUST-ARRAY must not signal an  `array not adjustable' error if ADJUSTABLE-ARRAY-P of its first  argument is true.  5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.  Note: ``should signal'' is taken from the new error terminology.  It means that in ``safe code'' (code compiled with highest safety)  an error must be signalled, but that in unsafe code (code not compiled  with highest safety), an error might or might not be signalled.Clarifications and Logical Consequences:  a. Whether an array can be both simple and adjustable is unspecified.  b. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.  c. There is no specified way to create an array that is non-simple.  d. This legitimizes ADJUSTABLE-ARRAY-P as an appropriate predicate to     determine whether ADJUST-ARRAY will reliably succeed.  e. If ADJUST-ARRAY is invoked on an array that was created without     supplying :ADJUSTABLE true, an `array not adjustable' error     ``should be signalled'' unless ADJUSTABLE-ARRAY-P returns true on     that array (in which case it must not signal an `array not adjustable'     error).Rationale:  This effectively makes the status quo explicit.  This preserves the  raison d'etre of simple arrays, which is to provide a portable interface  to implementation-dependent specialized arrays that trade decreased  functionality for faster access.  Specifying the points left unspecified (requiring all simple arrays to be  non-adjustable and all adjustable arrays to be non-simple) would require  large changes to some implementations and would be of little benefit to  users, merely making one kind of nonconforming program fail in all  implementations instead of failing only in some implementations. The   argument here is not that the error checking would not be useful for  developers of portable code, but only that the cost of introducing that  error checking would be exceedingly high for some implementations.  Users need to know that certain arrays are simple, so they can put in  declarations and get higher performance, but users have no need to be  able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable (to cause errors).Examples:  1. The following program is conforming.  It is unspecified which branch  of the IF it follows.      (defun double (a)       (if (adjustable-array-p a)           (adjust-array a (* (length a) 2))           (let ((new (make-array (* (length a) 2))))             (replace new a :end1 (length a))             new)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is simple,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and make all arrays non-simple unless the Common Lisp  language requires them to be simple, and are compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language explicitly unspecified is more aesthetic than having it  implicitly unspecified on account of vague or inconsistent documentation.Discussion:  Pitman, Moon, Gabriel, and Steele support this amended proposal.  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.*start*00963 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 10:07:54 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 10:07:46 PSTReceived: from Aquinas.Think.COM by SAIL.Stanford.EDU with TCP; 15 Mar 89  09:36:35 PSTReceived: from OCCAM.THINK.COM by Aquinas.Think.COM via INTERNET with SMTP id 124413; 15 Mar 89 12:34:29 ESTDate: Wed, 15 Mar 89 12:34 ESTFrom: Barry Margolin <barmar@FAFNIR.THINK.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)To: cl-cleanup@sail.stanford.educc: X3J13@sail.stanford.eduIn-Reply-To: <890315-051405-3472@Xerox>Message-ID: <19890315173420.1.BARMAR@OCCAM.THINK.COM>    Date: 15 Mar 89 05:13 PST    From: masinter.pa@xerox.com    Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):Hooray!  We finally got our collective acts together on this one!                                                barmar*start*00999 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 09:37:05 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 09:35:45 PSTReceived: from Aquinas.Think.COM by SAIL.Stanford.EDU with TCP; 15 Mar 89  09:36:35 PSTReceived: from OCCAM.THINK.COM by Aquinas.Think.COM via INTERNET with SMTP id 124413; 15 Mar 89 12:34:29 ESTDate: Wed, 15 Mar 89 12:34 ESTFrom: Barry Margolin <barmar@FAFNIR.THINK.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)To: cl-cleanup@sail.stanford.educc: X3J13@sail.stanford.eduIn-Reply-To: <890315-051405-3472@Xerox>Message-ID: <19890315173420.1.BARMAR@OCCAM.THINK.COM>    Date: 15 Mar 89 05:13 PST    From: masinter.pa@xerox.com    Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):Hooray!  We finally got our collective acts together on this one!                                                barmar*start*02974 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 12:18:09 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 12:17:24 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 17 Mar 89  12:14:37 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01413g; Wed, 15 Mar 89 23:32:00 PSTReceived: by bhopal id AA11607g; Wed, 15 Mar 89 23:32:47 PSTDate: Wed, 15 Mar 89 23:32:47 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8903160732.AA11607@bhopal>To: cl-cleanup@sail.stanford.eduCc: X3J13@Sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 15 Mar 89 05:13 PST <890315-051405-3472@Xerox>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)Although I haven't had time to join the overly-lengthy discussion on thismatter,  I did point out one particularly confusing direction -- that thisproposal to "fix" the function ADJUST-ARRAY has become a proposal to alter the semantics of the type SIMPLE-ARRAY.  Compare CLtL, p28, with thesentence in the Rationale Section:  "Specifying the points left unspecified (requiring all simple arrays to be   non-adjustable and all adjustable arrays to be non-simple) would require   large changes to some implementations and would be of little benefit to   ..."and with an item in the Clarification section:  "a. Whether an array can be both simple and adjustable is unspecified."[CLtL definition *does* specify it].I suggested that a simple statement be added to the proposal as follows:  "This proposal does not attempt to alter the meaning of the type   SIMPLE-ARRAY in any way"Moon expressed approval of adding that statement.Altered semantics would mean that it is no longer a portable type.  I have sent out several trivially small examples that show this.  Some people have interpreted those examples as simply showing what happens with "broken" code; but quite to the contrary, they show how code can be "correct" on one implementation and "broken" on another ****** when the definition of SIMPLE-ARRAY is allowed to vary between one implementation and the other ******.  Very carefully, CLtL spells out that implementations may vary on the efficiency with which they implement SIMPLE-ARRAYS; but nowhere does it provide for optional exclusion of some parts of the definition thereof.Also, I note that all of the discussion on the Cl-cleanup list was bypersons other than the half-dozen or so maintainers of "stock hardware"compilers.  I personally spoke with three others (not including myself)at Hawaii, and we all have identical requirements for the type SIMPLE-ARRAY,and identical resolve that it must not be changed.  Our compilers willcontinue to offer this C-level optimization capability; the only question is whether or not the CL1989 Standard will be cognizant of it.-- JonL --*start*02938 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 12:47:41 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 12:43:23 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 17 Mar 89  12:14:37 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01413g; Wed, 15 Mar 89 23:32:00 PSTReceived: by bhopal id AA11607g; Wed, 15 Mar 89 23:32:47 PSTDate: Wed, 15 Mar 89 23:32:47 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8903160732.AA11607@bhopal>To: cl-cleanup@sail.stanford.eduCc: X3J13@Sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 15 Mar 89 05:13 PST <890315-051405-3472@Xerox>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)Although I haven't had time to join the overly-lengthy discussion on thismatter,  I did point out one particularly confusing direction -- that thisproposal to "fix" the function ADJUST-ARRAY has become a proposal to alter the semantics of the type SIMPLE-ARRAY.  Compare CLtL, p28, with thesentence in the Rationale Section:  "Specifying the points left unspecified (requiring all simple arrays to be   non-adjustable and all adjustable arrays to be non-simple) would require   large changes to some implementations and would be of little benefit to   ..."and with an item in the Clarification section:  "a. Whether an array can be both simple and adjustable is unspecified."[CLtL definition *does* specify it].I suggested that a simple statement be added to the proposal as follows:  "This proposal does not attempt to alter the meaning of the type   SIMPLE-ARRAY in any way"Moon expressed approval of adding that statement.Altered semantics would mean that it is no longer a portable type.  I have sent out several trivially small examples that show this.  Some people have interpreted those examples as simply showing what happens with "broken" code; but quite to the contrary, they show how code can be "correct" on one implementation and "broken" on another ****** when the definition of SIMPLE-ARRAY is allowed to vary between one implementation and the other ******.  Very carefully, CLtL spells out that implementations may vary on the efficiency with which they implement SIMPLE-ARRAYS; but nowhere does it provide for optional exclusion of some parts of the definition thereof.Also, I note that all of the discussion on the Cl-cleanup list was bypersons other than the half-dozen or so maintainers of "stock hardware"compilers.  I personally spoke with three others (not including myself)at Hawaii, and we all have identical requirements for the type SIMPLE-ARRAY,and identical resolve that it must not be changed.  Our compilers willcontinue to offer this C-level optimization capability; the only question is whether or not the CL1989 Standard will be cognizant of it.-- JonL --*start*01606 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 12:19:00 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 12:18:20 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 17 Mar 89  12:14:13 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01417g; Wed, 15 Mar 89 23:39:01 PSTReceived: by bhopal id AA11617g; Wed, 15 Mar 89 23:39:49 PSTDate: Wed, 15 Mar 89 23:39:49 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8903160739.AA11617@bhopal>To: gls@Think.COMCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: Guy Steele's message of Tue, 28 Feb 89 14:13:37 EST <8902281913.AA03555@verdi.think.com>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)re: I conclude that the strict interpretation may be preferred, but not for the    reasons Jonl has advanced!  The liberal interpretation does *not* prevent    compilers for stock hardware from producing good code, and therefore the    code example does not support his claim to the contrary.Guy, I fear that you have made an error of logic in analyzing my example.You use the "strict" interpretation to conclude that the example isincorrect code (as it should be!); but the whole point of the example is to show that under the "liberal" interpretation, it's correctness depends on the implementation rather than on a implementation-independent definition.If you don't see this, then perhaps we should talk about it "off line".-- JonL --*start*01439 00024 US GV-Info: jonl@lucid.com at 17-Mar-89 12:15:52 from AGReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 17 MAR 89 12:11:58 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01417g; Wed, 15 Mar 89 23:39:01 PSTReceived: by bhopal id AA11617g; Wed, 15 Mar 89 23:39:49 PSTDate: Wed, 15 Mar 89 23:39:49 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8903160739.AA11617@bhopal>To: gls@Think.COMCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: Guy Steele's message of Tue, 28 Feb 89 14:13:37 EST <8902281913.AA03555@verdi.think.com>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)re: I conclude that the strict interpretation may be preferred, but not for the    reasons Jonl has advanced!  The liberal interpretation does *not* prevent    compilers for stock hardware from producing good code, and therefore the    code example does not support his claim to the contrary.Guy, I fear that you have made an error of logic in analyzing my example.You use the "strict" interpretation to conclude that the example isincorrect code (as it should be!); but the whole point of the example is to show that under the "liberal" interpretation, it's correctness depends on the implementation rather than on a implementation-independent definition.If you don't see this, then perhaps we should talk about it "off line".-- JonL --*start*01593 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 13:23:44 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 13:23:05 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 17 Mar 89  12:54:39 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 559814; Fri 17-Mar-89 15:51:33 ESTDate: Fri, 17 Mar 89 15:51 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.edu, X3J13@Sail.stanford.eduIn-Reply-To: <8903160732.AA11607@bhopal>Message-ID: <19890317205125.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Wed, 15 Mar 89 23:32:47 PST    From: Jon L White <jonl@lucid.com>    Although I haven't had time to join the overly-lengthy discussion on this    matter,  I did point out one particularly confusing direction -- that this    proposal to "fix" the function ADJUST-ARRAY has become a proposal to alter     the semantics of the type SIMPLE-ARRAY.Adding the discussion of SIMPLE-ARRAY was at *+*YOUR*+* request, JonL.There is !!NO!! change to the semantics, as I thought you had agreed inthe last message you sent on the topic.  If now you're taking that backand saying that you still think what this proposal says is a change tothe semantics, okay, but I have yet to figure out why you think that orwhat you think is changed.*start*01477 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 13:07:45 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 13:07:17 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  12:57:27 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Fri, 17 Mar 89 15:52:50 ESTDate: Fri, 17 Mar 89 15:53 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)To: Jon L White <jonl@lucid.com>Cc: cl-cleanup@sail.stanford.edu, X3J13@sail.stanford.eduIn-Reply-To: <8903160732.AA11607@bhopal>Message-Id: <19890317205329.0.BARMAR@OCCAM.THINK.COM>What happens in implementations that allow all arrays to be adjusted?If you require that (typep x 'simple-array) implies (not(adjustable-array-p x)), I see two possible resolutions: 1) suchimplementations are not conforming; 2) the type SIMPLE-ARRAY is empty.I find (1) distasteful, because non-adjustable arrays and theSIMPLE-ARRAY type exist solely for the benefit of implementations thatneed them, and this would require support of these concepts inimplementations that don't derive any benefit from them.  I think (2)makes the SIMPLE-ARRAY type pretty useless, since a portable programcan't expect anything to be of this type (FIXNUM had this problem untilwe fixed it in Hawaii).                                                barmar*start*01513 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 13:27:14 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 13:27:11 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  12:57:27 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Fri, 17 Mar 89 15:52:50 ESTDate: Fri, 17 Mar 89 15:53 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)To: Jon L White <jonl@lucid.com>Cc: cl-cleanup@sail.stanford.edu, X3J13@sail.stanford.eduIn-Reply-To: <8903160732.AA11607@bhopal>Message-Id: <19890317205329.0.BARMAR@OCCAM.THINK.COM>What happens in implementations that allow all arrays to be adjusted?If you require that (typep x 'simple-array) implies (not(adjustable-array-p x)), I see two possible resolutions: 1) suchimplementations are not conforming; 2) the type SIMPLE-ARRAY is empty.I find (1) distasteful, because non-adjustable arrays and theSIMPLE-ARRAY type exist solely for the benefit of implementations thatneed them, and this would require support of these concepts inimplementations that don't derive any benefit from them.  I think (2)makes the SIMPLE-ARRAY type pretty useless, since a portable programcan't expect anything to be of this type (FIXNUM had this problem untilwe fixed it in Hawaii).                                                barmar*start*02066 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 16:06:04 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 16:04:48 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  15:40:34 PSTReceived: from fafnir.think.com by Think.COM; Fri, 17 Mar 89 16:23:16 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 17 Mar 89 16:24:05 ESTReceived: by verdi.think.com; Fri, 17 Mar 89 16:20:53 ESTDate: Fri, 17 Mar 89 16:20:53 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903172120.AA09400@verdi.think.com>To: jonl@lucid.comCc: cl-cleanup@sail.stanford.edu, X3J13@sail.stanford.eduIn-Reply-To: Jon L White's message of Wed, 15 Mar 89 23:32:47 PST <8903160732.AA11607@bhopal>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)   Date: Wed, 15 Mar 89 23:32:47 PST   From: Jon L White <jonl@lucid.com>   ...   Also, I note that all of the discussion on the Cl-cleanup list was by   persons other than the half-dozen or so maintainers of "stock hardware"   compilers.  I personally spoke with three others (not including myself)   at Hawaii, and we all have identical requirements for the type SIMPLE-ARRAY,   and identical resolve that it must not be changed.  Our compilers will   continue to offer this C-level optimization capability; the only    question is whether or not the CL1989 Standard will be cognizant of it.I am very concerned about the stock hardware, but also very confused.I understand that the stock-hardware implementors adamantly opposethe proposed change, but I still have not seen a single convincingexample of why the proposed change would prevent them from accomplishingthe desired optimizations or why the proposed change would defeatportability.  I acknowledge that JonL has provided an example or two,but I have not found them convincing.  So either these examples arewrong, or I am badly wedged; in either case I need further explanation.--Guy*start*09545 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 13:41:09 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 13:40:25 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 17 Mar 89  13:37:36 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 559887; Fri 17-Mar-89 16:33:57 ESTDate: Fri, 17 Mar 89 16:33 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)To: Jon L White <jonl@lucid.com>, Masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8903160732.AA11607@bhopal>Message-ID: <19890317213333.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoThis version is edited to reflect the changes I think JonL wants,which I had thought were already in.  I'll mail this to X3J13 tosupersede version 8, unless one of you asks me not to.  That wouldprobably be more constructive than the intemperate message I alreadysent.Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289)Category:     CLARIFICATIONEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting to shorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bug introduced                        by the amendment, add clarification of SIMPLE-ARRAY type.	      15-Feb-89, Version 7, by Pitman. Minor changes per comments from			RPG and Dalton.	      11-Mar-89, Version 8, by Pitman. Change category, add endorsements.              17-Mar-89, Version 9, by Moon, fix wording and examples to make it			clear that the semantics of simple-array is unchanged.Problem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' This is inconsistent with  ADJUSTABLE-ARRAY-P.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY.  The definition of the SIMPLE-ARRAY type and its subtypes needs  clarification of its relationship to adjustability.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):  1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.   2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,   and :DISPLACED-TO arguments each either unspecified or false, the  resulting array is a simple array.  (This just repeats what CLtL  says on page 289, it's here to aid in understanding the next point.)        3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the  resulting array is simple is unspecified.        4. ADJUST-ARRAY ``should signal'' an error if ADJUSTABLE-ARRAY-P  of its first argument is false.  ADJUST-ARRAY must not signal an  `array not adjustable' error if ADJUSTABLE-ARRAY-P of its first  argument is true.  5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.  Note: ``should signal'' is taken from the new error terminology.  It means that in ``safe code'' (code compiled with highest safety)  an error must be signalled, but that in unsafe code (code not compiled  with highest safety), an error might or might not be signalled.Clarifications and Logical Consequences:  a. Whether an array can be both simple and adjustable is unspecified.  b. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.  c. There is no specified way to create an array that is non-simple.  d. This legitimizes ADJUSTABLE-ARRAY-P as an appropriate predicate to     determine whether ADJUST-ARRAY will reliably succeed.  e. If ADJUST-ARRAY is invoked on an array that was created without     supplying :ADJUSTABLE true, an `array not adjustable' error     ``should be signalled'' unless ADJUSTABLE-ARRAY-P returns true on     that array (in which case it must not signal an `array not adjustable'     error).  f. There is no change to the meaning of the type SIMPLE-ARRAY, only     a clarification that a conforming program cannot assume that any     array is not simple.Rationale:  This effectively makes the status quo explicit.  This preserves the  raison d'etre of simple arrays, which is to provide a portable interface  to implementation-dependent specialized arrays that trade decreased  functionality for faster access.  A proposed alternative was to specify a way to create an array that is  guaranteed not to be simple.  This would have required large changes  to some implementations and would be of little benefit to users.  Users need to know that certain arrays are simple, so they can put in  declarations and get higher performance, but users have no need to be  able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable (to cause errors).Examples:  1. The following program is conforming.  It is unspecified which branch  of the IF it follows.      (defun double (a)       (if (adjustable-array-p a)           (adjust-array a (* (length a) 2))           (let ((new (make-array (* (length a) 2))))             (replace new a :end1 (length a))             new)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))  3. The following program is non-conforming.  The consequences of this  program are undefined because the type declaration is violated in some  valid implementations.    (let ((a (make-array 100 :adjustable t)))      (declare (simple-array a))      (frob a))Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is simple,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and make all arrays non-simple unless the Common Lisp  language requires them to be simple, and are compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language explicitly unspecified is more aesthetic than having it  implicitly unspecified on account of vague or inconsistent documentation.Discussion:  Pitman, Moon, Gabriel, and Steele support this amended proposal.  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.*start*02852 00024 US GV-Info: gls@Think.COM at 17-Mar-89 13:45:08 from AGReturn-Path: <gls@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 17 MAR 89 13:44:30 PSTReceived: from fafnir.think.com by Think.COM; Fri, 17 Mar 89 16:41:06 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 17 Mar 89 16:42:07 ESTReceived: by verdi.think.com; Fri, 17 Mar 89 16:38:55 ESTDate: Fri, 17 Mar 89 16:38:55 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903172138.AA09505@verdi.think.com>To: jonl@lucid.comCc: gls@Think.COM, masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Wed, 15 Mar 89 23:39:49 PST <8903160739.AA11617@bhopal>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)   Date: Wed, 15 Mar 89 23:39:49 PST   From: Jon L White <jonl@lucid.com>   re: I conclude that the strict interpretation may be preferred, but not for the       reasons Jonl has advanced!  The liberal interpretation does *not* prevent       compilers for stock hardware from producing good code, and therefore the       code example does not support his claim to the contrary.   Guy, I fear that you have made an error of logic in analyzing my example.   You use the "strict" interpretation to conclude that the example is   incorrect code (as it should be!); but the whole point of the example is    to show that under the "liberal" interpretation, it's correctness depends    on the implementation rather than on a implementation-independent definition.   If you don't see this, then perhaps we should talk about it "off line".I respectfully disagree with your assessment; I believe that you haveerred in analyzing my analysis.  Specifically, I do *not* concludethat the example is incorrect code.  Let me quote further from mymessage of Feb 28:	I argue that the program is correct under both interpretations....	Under the strict interpretation implementation (A) is incorrect by	definition.  Under the liberal interpretation implementation (A) is	correct, and accomplishes a useful purpose. ...According to my analysis, the correctness of the code does not dependon the choice of strict or liberal interpretation; rather, thecorrectness of implementation (A) depends on the choice of interpretation.I conclude: (1) Under the strict interpretation only someimplementations are correct, but under the liberal interpretation manymore are correct.  (2) You can get good code on stock hardwareregardless of the choice of interpretation.Therefore unless some other argument can be advanced for the strictinterpretation, the liberal interpretation is to be preferred because itinvalidates fewer implementation strategies.So there you have a concise summary of my argument that may make iteasier for you to find the hole in it (if any).--Guy*start*01889 00024 US GV-Info: jonl@lucid.com at 17-Mar-89 15:54:28 from AGReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 17 MAR 89 15:53:04 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02075g; Fri, 17 Mar 89 15:47:55 PSTReceived: by bhopal id AA19349g; Fri, 17 Mar 89 15:50:11 PSTDate: Fri, 17 Mar 89 15:50:11 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8903172350.AA19349@bhopal>To: gls@Think.COMCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: Guy Steele's message of Fri, 17 Mar 89 16:38:55 EST <8903172138.AA09505@verdi.think.com>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 6)re: 	Under the strict interpretation implementation (A) is incorrect by	definition.  Under the liberal interpretation implementation (A) is	correct, and accomplishes a useful purpose. ...Guy, I'm totally confused by your "analysis" now;  the whole point ofthe example is to show that portability is sacrificed under what you arecalling the "liberal" interpretation -- that altering the CLtL semanticsof SIMPLE-ARRAY makes it non portable.  As I look back into yourprevious msg, I see that you did say:    Now, the two implementations behave differently on the example, and that     is a cause for concern.Also, your statement just quoted above shows the variations possible underimplementation (A) and (B), thus reiterating the non-portability questionI brought up.   Thus you'll have to admit that my example showed *exactly* what I claimed it did.  However, I disagree with your judgement -- that it is better to accept an interpretation that allows more variation among implementations -- because the variation you are thereby accommodating means that the type is no longer portable.  We may be stuck with that position, but I don't agree that itis a good thing.-- JonL --*start*01351 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 16:09:41 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 16:09:26 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 17 Mar 89  16:00:33 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02088g; Fri, 17 Mar 89 15:53:13 PSTReceived: by bhopal id AA19366g; Fri, 17 Mar 89 15:55:29 PSTDate: Fri, 17 Mar 89 15:55:29 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8903172355.AA19366@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.edu, X3J13@Sail.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 17 Mar 89 15:51 EST <19890317205125.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)re: Adding the discussion of SIMPLE-ARRAY was at *+*YOUR*+* request, JonL.Sorry, Dave, I only ever made a request to add precisely the one statementthat you have already now added -- that the proposal *does not* alterthe CLtL semantics of SIMPLE-ARRAY.  What I critiqued were statementsof the proposal that under reasonable interpretation could be taken tomean that the CLtL p.28 definition of SIMPLE-ARRAY is being abrogated.At any rate, thanks for the one-line addition.-- JonL --*start*01586 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 16:45:06 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 16:38:48 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 17 Mar 89  16:13:52 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02119g; Fri, 17 Mar 89 16:06:33 PSTReceived: by bhopal id AA19436g; Fri, 17 Mar 89 16:08:50 PSTDate: Fri, 17 Mar 89 16:08:50 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8903180008.AA19436@bhopal>To: barmar@Think.COMCc: cl-cleanup@sail.stanford.edu, X3J13@sail.stanford.eduIn-Reply-To: Barry Margolin's message of Fri, 17 Mar 89 15:53 EST <19890317205329.0.BARMAR@OCCAM.THINK.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)re: I find (1) distasteful, because non-adjustable arrays and the    SIMPLE-ARRAY type exist solely for the benefit of implementations that    need them, and this would require support of these concepts in    implementations that don't derive any benefit from them.  Barry, SIMPLE-ARRAY is certainly not the only concept in CLtL that exists"solely for the benefit of implementations that [can really use it]".  Iknow that numerous array capabilities are present but not very usefulin Lucid Common Lisp primarily for compatiblity with Lisp Machine stuff.That's the price to pay for portability.  It just may be that we will have to confess that we didn't succeed at portability in some areas of CL.-- JonL --*start*03484 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 17:06:11 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 17:06:01 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  16:56:32 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Fri, 17 Mar 89 19:52:28 ESTDate: Fri, 17 Mar 89 19:53 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 8)To: Jon L White <jonl@lucid.com>Cc: cl-cleanup@sail.stanford.edu, X3J13@sail.stanford.eduIn-Reply-To: <8903180008.AA19436@bhopal>Message-Id: <19890318005322.4.BARMAR@OCCAM.THINK.COM>    Date: Fri, 17 Mar 89 16:08:50 PST    From: Jon L White <jonl@lucid.com>    re: I find (1) distasteful, because non-adjustable arrays and the	SIMPLE-ARRAY type exist solely for the benefit of implementations that	need them, and this would require support of these concepts in	implementations that don't derive any benefit from them.      Barry, SIMPLE-ARRAY is certainly not the only concept in CLtL that exists    "solely for the benefit of implementations that [can really use it]".  I    know that numerous array capabilities are present but not very useful    in Lucid Common Lisp primarily for compatiblity with Lisp Machine stuff.    That's the price to pay for portability.  It just may be that we will have     to confess that we didn't succeed at portability in some areas of CL.    -- JonL --The general rule has been that implementations that don't need (or don'tprovide) these types of optimizations can safely ignore the languagefeatures that support them.  Some implementations can optimize arrayaccess by knowing that the array can't be adjusted; otherimplementations should not be required to remember this information ifthey don't need it.  Quoting from CLtL: "features that are useful onlyon certain 'ordinary' or 'commercial' processors are avoided or madeoptional."Any feature of the language that provides access to facets of theimplementation allows somewhat non-portable code, meaning that it ispossible to write conforming code that produces different results indifferent implementations.  The simple program (PROGNMOST-POSITIVE-FIXNUM) is conforming but produces many different results,although the program (TYPEP MOST-POSITIVE-FIXNUM 'FIXNUM) is guaranteedto return T in all conforming implementations.  To paraphrase Moon, itwould be wonderful if all conforming programs were portable, but that'sunrealistic (it would be like expecting the grammar of a language toonly permit sensible sentences to be formed -- I suspect Godel'sIncompleteness Theorem comes into play here, pointing out that if thegrammar allows you to say everything you'd want to say, it must alsoinclude some nonsense).  The best I think we can do is provide enoughtools in the language to allow programs to detect implementationdifferences and deal with them.One thing that would help me is if you would post an example of codethat you feel is affected by this issue.  I think you described suchthings to me in words at the last meeting, but I (like GLS) am having ahard time figuring out precisely what the problem is (I had the samedifficulty with the FIXNUM stuff that started the moby flame session inthe car on the way to the Japanese restaurant).                                                barmar*start*09325 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 21-Mar-89 16:43:07 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 MAR 89 16:42:54 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Mar 89  16:29:22 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 562415; Tue 21-Mar-89 19:29:06 ESTDate: Tue, 21 Mar 89 19:28 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)To: X3J13@SAIL.STANFORD.EDUReferences: <19890317213333.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19890322002858.7.MOON@EUPHRATES.SCRC.Symbolics.COM>This version is edited to clarify that the semantics of simple-arrayare not being changed, and supersedes version 8 which you already saw.Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289)Category:     CLARIFICATIONEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting to shorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bug introduced                        by the amendment, add clarification of SIMPLE-ARRAY type.	      15-Feb-89, Version 7, by Pitman. Minor changes per comments from			RPG and Dalton.	      11-Mar-89, Version 8, by Pitman. Change category, add endorsements.              17-Mar-89, Version 9, by Moon, fix wording and examples to make it			clear that the semantics of simple-array is unchanged.Problem Description:  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288  says that ``the argument, if specified and not NIL, indicates that  it must be possible to alter the array's size dynamically after  it is created. This argument defaults to NIL.''  The description of the :ADJUSTABLE option does not say what   MAKE-ARRAY will do if the argument is unsupplied or explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is  true ``if the argument (which must be an array) is adjustable, and  otherwise false.'' However, the description of MAKE-ARRAY makes  it clear that this is not necessarily the same as asking if  the array was created with :ADJUSTABLE T. If ADJUSTABLE-ARRAY-P  returns NIL, you know that :ADJUSTABLE NIL was supplied (or no  :ADJUSTABLE option was supplied), but if ADJUSTABLE-ARRAY-P returns  T, then there is no information about whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is  ``not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.'' This is inconsistent with  ADJUSTABLE-ARRAY-P.    A problem which comes up in practice is that some programmers  expect runtime error checking if they have done  (MAKE-ARRAY ... :ADJUSTABLE NIL) and they later try to adjust  the array using ADJUST-ARRAY.  The definition of the SIMPLE-ARRAY type and its subtypes needs  clarification of its relationship to adjustability.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:CLARIFY):  1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.   2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,   and :DISPLACED-TO arguments each either unspecified or false, the  resulting array is a simple array.  (This just repeats what CLtL  says on page 289, it's here to aid in understanding the next point.)        3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the  resulting array is simple is unspecified.        4. ADJUST-ARRAY ``should signal'' an error if ADJUSTABLE-ARRAY-P  of its first argument is false.  ADJUST-ARRAY must not signal an  `array not adjustable' error if ADJUSTABLE-ARRAY-P of its first  argument is true.  5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.  Note: ``should signal'' is taken from the new error terminology.  It means that in ``safe code'' (code compiled with highest safety)  an error must be signalled, but that in unsafe code (code not compiled  with highest safety), an error might or might not be signalled.Clarifications and Logical Consequences:  a. Whether an array can be both simple and adjustable is unspecified.  b. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.  c. There is no specified way to create an array that is non-simple.  d. This legitimizes ADJUSTABLE-ARRAY-P as an appropriate predicate to     determine whether ADJUST-ARRAY will reliably succeed.  e. If ADJUST-ARRAY is invoked on an array that was created without     supplying :ADJUSTABLE true, an `array not adjustable' error     ``should be signalled'' unless ADJUSTABLE-ARRAY-P returns true on     that array (in which case it must not signal an `array not adjustable'     error).  f. There is no change to the meaning of the type SIMPLE-ARRAY, only     a clarification that a conforming program cannot assume that any     array is not simple.Rationale:  This effectively makes the status quo explicit.  This preserves the  raison d'etre of simple arrays, which is to provide a portable interface  to implementation-dependent specialized arrays that trade decreased  functionality for faster access.  A proposed alternative was to specify a way to create an array that is  guaranteed not to be simple.  This would have required large changes  to some implementations and would be of little benefit to users.  Users need to know that certain arrays are simple, so they can put in  declarations and get higher performance, but users have no need to be  able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable (to cause errors).Examples:  1. The following program is conforming.  It is unspecified which branch  of the IF it follows.      (defun double (a)       (if (adjustable-array-p a)           (adjust-array a (* (length a) 2))           (let ((new (make-array (* (length a) 2))))             (replace new a :end1 (length a))             new)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))  3. The following program is non-conforming.  The consequences of this  program are undefined because the type declaration is violated in some  valid implementations.    (let ((a (make-array 100 :adjustable t)))      (declare (simple-array a))      (frob a))Current Practice:  Probably everyone is compatible with this proposal.   Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is simple,  and is compatible with this proposal.  Lucid, IIM, and Symbolics Cloe make :ADJUSTABLE NIL arrays non-adjustable  in all cases, and make all arrays non-simple unless the Common Lisp  language requires them to be simple, and are compatible with this proposal.Cost to Implementors:  It's in principle possible that some implementation would have to change,  but in practice there are no known implementations that would have to change.Cost to Users:  None. This is a fully compatible change from the user's standpoint.Benefits:  Users would know what to expect.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired error checking.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language explicitly unspecified is more aesthetic than having it  implicitly unspecified on account of vague or inconsistent documentation.Discussion:  Pitman, Moon, Gabriel, and Steele support this amended proposal.  MACSYMA ran into portability problems due to the status quo.  If the issue had been documented, that would have helped.  Encouraging implementations that are able to at least make  (MAKE-ARRAY ... :ADJUSTABLE NIL) create non-adjustable arrays  where possible would help, too.  We considered proposals to incompatibly change this primitive in a  variety of ways, but the community was very split with strong proponents  and opponents of each alternate proposal.  The overriding concern driving this proposal is that Symbolics   has asserted that most of the other really interesting proposals would  likely involve a sizable cost to implementors (and their installed bases)  to implement what were judged by some as gratuitous changes from the  status quo.  Pitman wishes some of the other proposals were economically feasible to  pursue but reluctantly agrees that maintaining (and clearly documenting)  the status quo is probably the most reasonable avenue left to us.*start*26665 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 21-Mar-89 21:11:21 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 MAR 89 21:11:14 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Mar 89  20:48:46 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA01278g; Tue, 21 Mar 89 20:43:21 PSTReceived: by challenger id AA22664g; Tue, 21 Mar 89 20:38:38 PSTDate: Tue, 21 Mar 89 20:38:38 PSTFrom: Richard P. Gabriel <rpg@lucid.com>Message-Id: <8903220438.AA22664@challenger>To: x3j13@sail.stanford.eduSubject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)People have continued to debate this issue. Part of the confusion iswhat CLtL really says about simple arrays and adjustability.  Thecause of the confusion is that various people have advanced difficultto understand arguments and proposals (myself included).As mentioned in the statement of ADJUST-ARRAY-NOT-ADJUSTABLE (Version9), I agreed to support it, and I also agreed that it was aclarification and not a change,Because I had become confused by the issue, I decided to go back toCLtL to find the consistent readings of the passages on simple arraysand adjustability. As part of this exercise I tried to write up ananalysis of the possible interpretations of the the statements inquestion. I often use this hermeneutical act to understand difficultissues. The result is that I think there are exactly two plausible consistentreadings, with one much more plausible than the other. Both readingsare inconsistent with ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9).Therefore, I conclude that ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9) isa change, not a clarification, and I must withdraw my agreement thatit is a clarification.Whether we wish to adopt it is another question, to which I offer nospecific comment or suggestion. I am convinced that if some peoplehave read CLtL as meaning what ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)states and implemented simple arrays that way, we are in quite a bind.The only minor comment I have is a general one: We should be wary ofchanges (rather than clarifications) at this stage of standardization.This message is very long and contains lots of close reasoning andboring details.  By its length and detail some might read it as astrong criticism of the authors of ADJUST-ARRAY-NOT-ADJUSTABLE(Version 9) - it really isn't (in fact, before I this exercise Ibelieved that the contents of ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)would be one of the plausible interpretations).  It is simply what Ifound and how I found it.If you want to get to the heart of the matter, ask your text editor tosearch for <<yoo-hoo>> and start reading there.************************** Start of the Analysis **************************In this message I will use the notation (S-i) to name statements;(S-8) is to be read as ``statement 8.''  I will use (I-i-j) to nameinterpretations of statments; (I-8-2) is to be read as ``the secondinterpretation of statement 8.''  (I-7;8-4) is to be read as ``thefourth interpretation of the statements 7 and 8 taken together.''  Iwill use (*I-i-j) to name incorrect interpretations of statements;(*I-8-2) is to be read as ``the (incorrect) second interpretation ofstatement 8.'' I will use (C-i[J1,...,Jn) to name conclusions derivedfrom statements; (C-2[S-1,I-8-2]) is to be read as ``conclusion 2derived from statement 1 and the second interpretation of statement8.''There are several relevant statements in CLtL.(S-1) [from Page 28] An array that is not displaced to another array,has no fill pointer, and is not to have its size adjusted dynamicallyafter creation is called a simple array.(S-2) [from Page 288] :ADJUSTABLE: This argument, if specified and notNIL, indicates that it must be possible to alter the array's sizedynamically after it is created.(S-3) [immediately follows (S-2)] This argument defaults to NIL.(S-4) [from Page 289] If MAKE-ARRAY is called with the :ADJUSTABLE,:FILL-POINTER, and :DISPLACED-TO arguments each either unspecified orfalse, the resulting array is a simple array.(S-5) [from Page 293] This predicate [ADJUSTABLE-ARRAY-P] is true ifthe argument (which must be an array) is adjustable, and otherwisefalse.(S-6) [from Page 297] It is not permitted to call ADJUST-ARRAY on anarray that was not created with the :ADJUSTABLE option.  (S-7) [immediately follows (S-6)] The predicate ADJUSTABLE-ARRAY-P maybe used to determine whether or not an array is adjustable.First, let's look at the various interpretations of these statements.**************************** Interpretation of (S-1) ****************************The statement (S-1) appears to be in the form of a definition.However, the phrase ``is called'' could be taken as a non-standard wayto introduce a definition and might instead be taken as a conditionalstatement: Schematically, ``X's are called Y's'' could be taken tomean ``If something is an X, then it is a Y.''I don't think this is a plausible reading in a programming languagespecification. Consider this sentence:``A number that is divisible by 9 is called a well-tempered number.''I think this is a fair definition. Certainly we would say that, bythis definition, the number 11 is not a well-tempered number.Nevertheless, a possible interpretation of (S-1) could be:(*I-1-1) If an array is not displaced to another array, has no fillpointer, and is not to have its size adjusted dynamically aftercreation, it is a simple array (and there may be simple arrays that donot satisfy these properties).However, if we look at the other statements in Chapters 2 and 17 wesee the use of ``is called'' throughout in what appears to be adefinitional sense. If (S-1) lacks definitional force, then so dothese statements:Page 29: One-dimensional arrays are called vectors in Common Lispand constitute the type VECTOR (which is therefore a subtypeof ARRAY).Page 29: All implementations provide specialized arrays for the caseswhen the components are characters (or rather, a special subset of thecharacters); the one-dimensional instances of this specialization arecalled strings.Page 29: All implementations are also required to provide specializedarrays of bits, that is, arrays of type (ARRAY BIT); theone-dimensional instances of this specialization are called bitvectors.Page 286: One-dimensional arrays are called vectors.Page 286: Vectors whose elements are restricted to type STRING-CHARare called strings.Page 286: Vectors whose elements are restricted to type BIT are calledbit-vectors.Nothing but one-dimensional arrays are called or considered vectors,and so I think ``is called'' can reasonably be interpreted only asdefinitional.I believe (*I-1-1) is not reasonable by the two arguments of incorrectform for a conditional and the use of the ``is called'' form indefinitional senses elsewhere in Chapter 2.I believe the definitional interpretation of (S-1) is this:(I-1-1.5) Definition: An array is called a simple array if and only ifthe array is not displaced to another array, has no fill pointer, andis not to have its size adjusted dynamically after creation.Further, I think the obvious meaning of (S-1) is this:(I-1-2) Definition: An array is called a simple array if and only ifthe array is not displaced to another array, has no fill pointer, andcannot have its size adjusted dynamically after creation.Another interpretation of (S-1) is possible. Note that the that thephrase ``is not to have its size adjusted dynamically after creation''is used rather than the less equivocal ``cannot have its size adjusteddynamically after creation.''  One way to understand this phrasing isas a stylistic device to produce the relatively uniform pattern ``anarray that is, ..., has, ...  and is...'' rather than the relativelynon-uniform pattern ``an array that is, ..., has, ...  and can....'' Ibelieve that this stylistic nuance is what Steele had in mind, but analternative is possible.The alternative is derived as follows: If something ``is not to be''acted upon in some particular way, then it is not the *intention* ofthe actor to act upon that thing in that way. Therefore, we have thealternative interpretation:(I-1-3) Definition: An array is called a simple array if and only ifthe array is not displaced to another array, has no fill pointer, andis not intended to have its size adjusted dynamically after creation.This results in a curious meaning for ``simple array.'' A simple arrayis a legitimate type (SIMPLE-ARRAY appears on Page 34 in the sentence,``SIMPLE-ARRAY is a subtype of ARRAY.'' It also appears on page 43 asone the Common Lisp Standard Type Specifiers, and on Page 42 itstates, ``in Common Lisp, types are named by Lisp objects,specifically symbols and lists, called type specifiers.''), and so itmust be possible to make such an array and to test objects for thistype. If (typep A 'simple-array) is true, then A is an array that,among other things, was *intended* to not have its size altereddynamically after creation.There is another interpretation of (S-1), which interprets ``is notto have'' as ``doesn't happen to have.''(*I-1-4) An array that is not displaced to another array, has no fillpointer, and doesn't happen to have its size adjusted dynamicallyafter creation is called a simple array.I think this is an unlikely interpretation because it is clear that asimple array can be created, and at the point of creation MAKE-ARRAYwould not know whether the size will happen to be adjusted later.There is yet another interpretation of (S-1), but it cannot be presentedeasily until after some other arguments have been made.**************************** Interpretation of (S-2) ****************************The statement (S-2) states that the argument :ADJUSTABLE can be usedto create an array whose size can be altered dynamically aftercreation.If (I-1-2) is the correct interpretation, then supplying a non-NIL:ADJUSTABLE argument results in an array whose size *can* be altereddynamically after creation, and so an array made this way is not asimple array.If (I-1-3) is the correct interpretation, then supplying a non-NIL:ADJUSTABLE argument results in an array that is *intended* to haveits size altered dynamically after creation, and so an array made thisway is not a simple array.(C-1[I-1-2,I-1-3,S-2]) Supplying a non-NIL :ADJUSTABLE argument toMAKE-ARRAY results in a non-simple array.  The basis for thisconclusion is the definitional nature of (S-1) regardless of the twovariants of the definition.In fact, if we look at the statements regarding :FILL-POINTER and:DISPLACED-TO, we see that if either of them is supplied and true, theresulting array is also not simple (using the same argument used for:ADJUSTABLE).Therefore, (C-2[I-1-2,I-1-3]) An array created with any one of :ADJUSTABLE,:FILL-POINTER, and :DISPLACED-TO specified and non-NIL is not simple.**************************** Interpretation of (S-3) ****************************The statement (S-3) has a single interpretation.**************************** Interpretation of (S-4) ****************************The statement (S-4) states that if all three of the :ADJUSTABLE,:FILL-POINTER, and :DISPLACED-TO arguments are unspecified or false, asimple array is produced.Combining this with (C-2) we get:(C-3[S-4,C-2]) An array created with any one of :ADJUSTABLE,:FILL-POINTER, and :DISPLACED-TO specified and non-NIL is not simple.The force of (S-2) and (S-4) is that only a part of the type structureof arrays is specified. There is definitely a way to create a simplearray, and definitely ways to create non-simple arrays, but whethernon-simple arrays are further distinguished based on the arguments:ADJUSTABLE, :FILL-POINTER, and :DISPLACED-TO is not specified.**************************** Interpretation of (S-5) ****************************We will return to statement (S-5) later. Its interpretation is clear,but which arrays are adjustable is not.**************************** Interpretation of (S-6) ****************************Statement (S-6) is quite tricky. The problem is with the phrase ``is not permitted''; the question iswhether it is synonymous with ``is an error'' or whether it isstronger.The case for ``is not permitted"" being stronger than ``is an error''is very compelling, I feel. First, taken as an English phrase, it isstrong: If you are not permitted to call ADJUST-ARRAY, then you do nothave permission to call it; in other words, you are not allowed tocall it, calling it is not tolerated, consent was not given to callit, you do not have license to call it, you are not authorized to callit, you do not have the opportunity to call it, it is not possible tocall it.Second, ``is not permitted'' is not listed on Page 6 as one of thephrases synonymous with ``is an error.'' If Steele wanted to actuallyprohibit something, he would not be able to use the relativelyintuitive ``must not'' since that means ``is an error,'' which can betaken to mean ``is allowed.'' That is, within the linguistic bounds ofCLtL it is possible to interpret the statement ``you must not do X''as ``you are allowed to do X.''The phrase ``is not permitted'' is used elsewhere in CLtL. The mostdirectly informative usage is on Page 72:``The names NIL and T are constants in Common Lisp. Although they aresymbols like any other symbols, and appear to be treated as variableswhen evaluated, it is not permitted to modify their values. SeeDEFCONSTANT.''Changing the values of NIL and T is a pretty serious offense. Steelecould have directly used the wording ``is an error,'' but he chose aphrase not formally defined. He also could have said that NIL and Tare constants exactly like those defined by DEFCONSTANT, but he choseinformal wording that is stronger than ``is an error.''  Finally, theadvice to see DEFCONSTANT is given, almost as an afterthought.Here is the main interpretation of (S-6):(I-6-1) Calling ADJUST-ARRAY on an array that was not created with the:ADJUSTABLE option is prohibited.An array is ``adjustable'' if it is capable of being adjusted.ADJUST-ARRAY is the only function in Common Lisp that can adjust anarray. Therefore, if ``calling ADJUST-ARRAY...is prohibited'' in somesituation, then that array is not adjustable in that situation. Thesituation pointed out by (I-6-1) is that the ``array ... was notcreated with the :ADJUSTABLE option.''Combining this with (S-2) we get:(C-4[I-6-1,S-2]) An array is adjustable if and only if the array wascreated with the :ADJUSTABLE option.Now let's look at the case for (S-6) being permissive.The remark ``see DEFCONSTANT'' could be taken to mean that NIL and Tare simply constants and are to be treated that way, no more, no less.Under DEFCONSTANT it states that altering the value of a constant ``isan error.''So here is the alternative:(I-6-2) Calling ADJUST-ARRAY on an array that was not created with the:ADJUSTABLE option is an error (that is, it is allowed).**************************** Interpretation of (S-7) ****************************On the face of it, (S-7) is a restatement of (S-5).  The twoalternative readings result from either taking its presence asrelevant or irrelevant. That is, one can either believe that (S-7)conveys some new information by its location relative to otherstatements or that the reading of CLtL is as if (S-7) were deletedI believe that essentially deleting (S-7) is not reasonable, mostlybecause Steele is a better writer than that interpretation wouldimply.The fact that (S-7) immediately follows (S-6) implies that there issome relation between them.  In a two-sentence paragraph it is odd tohave the second sentence add no information to the first.  The obviousrelation is that ADJUSTABLE-ARRAY-P is the predicate that can be usedto determine whether it is permitted to call ADJUST-ARRAY.(I-7-1) ADJUSTABLE-ARRAY-P can be used to determine whether or notADJUST-ARRAY is permitted.Consider (I-6-1). Using (C-4), since ADJUST-ARRAY can be called onexactly those arrays that were created with the :ADJUSTABLE option,and since ADJUSTABLE-ARRAY-P can be used to determine whetherADJUST-ARRAY can be used, we get:(C-5[C-4,S-5]) ADJUSTABLE-ARRAY-P can be used to determine whether ornot an array was created with the :ADJUSTABLE option.Given this, following (S-6) with (S-7) is natural, because it servesto reinforce the interpretation (I-6-1) because ADJUSTABLE-ARRAY-Ptalks about adjustability. Let's put (I-6-1), (I-7-1), and (C-5) together:(I-6;7-1) ADJUST-ARRAY can be called only on adjustable arrays, thatis, only on arrays created with the :ADJUSTABLE option.ADJUSTABLE-ARRAY-P can be used to determine whether an array wascreated with the :ADJUSTABLE option.Consider (I-6-2). The effect of (I-7-1) is to reinforce theinterpretation (I-6-2), because (S-7) states that ADJUSTABLE-ARRAY-Pmust be used to determine adjustability, not the use of the:ADJUSTABLE argument in MAKE-ARRAY.We can rephrase (I-6-2) and (I-7-1) as follows:(I-6;7-2) Calling ADJUST-ARRAY on an array that was not created withthe :ADJUSTABLE option is an error (that is, it is allowed); andADJUSTABLE-ARRAY-P can be used to determine whether or not it isallowed.*************************** Interpretation of CLtL ***************************Now let's look at (I-1-2) and (I-1-3).(I-1-2) can be taken either under (I-6;7-1) or under (I-6;7-2).Under (I-6;7-1) and recalling (C-2), (C-3), and (C-4) we get:Position 1: The only simple arrays are those created with the:ADJUSTABLE, :FILL-POINTER, and :DISPLACED-TO arguments each eitherunspecified or false. All simple arrays are not adjustable.  An arrayis adjustable if and only if it was created with the :ADJUSTABLEoption.  ADJUSTABLE-ARRAY-P is false of all simple arrays.There is an affinity between (I-1-2) and (I-6;7-1) because the:ADJUSTABLE argument states whether it is possible to adjust thearray.Under (I-6;7-2) and recalling (C-2) and (S-5), we get:Position 2: The only simple arrays are those created with the:ADJUSTABLE, :FILL-POINTER, and :DISPLACED-TO arguments each eitherunspecified or false. A simple array may or may not be adjustable.  Anarray created with the :ADJUSTABLE option unspecified or NIL might beadjustable.  ADJUSTABLE-ARRAY-P can be used to determine whether anarray is adjustable.This is weak because (I-1-2), (S-2), and (S-4) taken together impliesthat the :ADJUSTABLE argument controls adjustability. (I-6-2) impliesthat :ADJUSTABLE unspecified or NIL might result in an adjustablearray.(I-1-3) must be considered under both (I-6;7-1) and (I-6;7-2).Looking at (I-1-3) with (I-6;7-1), we get Position 1 again, because the:ADJUSTABLE arguments signals intent to adjust an array.  Here,(I-6;7-1) implies that one cannot call ADJUST-ARRAY on an array thatwas not intended to be adjusted. I feel this is a weak pair ofinterpretations.Looking at (I-1-3) with (I-6;7-2), we get Position 2 again. Here it isallowed to call ADJUST-ARRAY on an array that wasn't intended to beadjusted. There is some affinity between (I-1-3) and (I-6;7-2) becausethe :ADJUSTABLE argument signals intention only.  The only intentionthat is required to be acted upon is specifying a non-NIL :ADJUSTABLEargument, which must result in an adjustable array. If your intentionis to not adjust the array, you should not care whether it is actuallyadjustable. Therefore, (I-6-2) is a sensibly paired with (I-1-3).The variations of ``can not be adjusted'' and ``not intended to beadjusted'' have little differential effect on the finalinterpretations except insofar as Position 1 is stronger when pairedwith (I-1-2) and Position 2 is stronger with (I-1-3). I believe thatthe strength of the argument regarding ``is not permitted'' coupledwith the weakness the plausibility of a type being defined withrespect to intention combine to make Position 1 the strongerinterpretation.************************************** Interpretation of (S-1) Revisited **************************************Given the clearly definitional nature of (S-1), let's look at thequestion of whether there is any basis in CLtL for an array createdwith one of :ADJUSTABLE, :FILL-POINTER, and :DISPLACED-TO specifiedand non-NIL to be simple.The reasoning for such a situation is as follows: Under Position 2 itis possible for a simple array to be adjustable.  The expression(MAKE-ARRAY n :ADJUSTABLE NIL) creates a simple array under Position2, and so why shouldn't (MAKE-ARRAY n :ADJUSTABLE T), since MAKE-ARRAYprobably ignores the :ADJUSTABLE argument.For this to be allowed, (S-1) must be a partial or conditionaldefinition.  That is, (S-1) might be definitional, but only forcertain implementations, or part of the definition might apply onlyfor certain implementations.  The remainder of the paragraph thatstarts with (S-1) continues as follows:(S-8) The user may provide declarations that certain arrays will besimple.(S-9) Some implementations can handle simple arrays in an especiallyefficient manner; for example, simple arrays may have a more compactrepresentation than non-simple arrays.(S-8) and (S-9) clearly imply that the reason for simple arrays isefficiency. (S-8) talks about declarations provided by the user.  Whena Common Lisp programmer provides a declaration that does not havesemantic import, this can signal only intention. Therefore, theinterpretation (I-1-3) would seem to make sense.I believe that nothing in (S-8) and (S-9) alters the definitionalnature of (S-2). The most (S-8) and (S-9) could do is limit itsapplicability of the definition.  That is, neither (S-8) nor (S-9)imply that (S-1) is not a definition, but they could modify theconditions that the definition predicates.The paragraph starting with (S-1) could be taken as a description of atype that is useful only in implementations that act differentlyaccording to the user's intentions as signaled by declarations. Since(S-4) requires that some arrays be simple, implementations that haveno use for simple arrays are forced to have them.Another interpretation of (S-1) is then:(*I-1-5) An array that is not displaced, has no fill pointer, and hasbeen created with the intention not to have its size altereddynamically after creation in an implementation that honorsdeclarations is a simple array.I think this is a far-fetched reading, particularly since Steeleis capable of stating something like this much more precisely thanwith the series (S-1), (S-8), and (S-9).************************ End of the Analysis ************************<<yoo-hoo>>For those of you who could not stand to read the hermeneuticarguments, here are the only two consistent readings of CLtL regardingsimple arrays and adjustability.  I believe that Position 1 has thestronger set of arguments behind it and is, I believe, the preferredreading:Position 1: The only simple arrays are those created with the:ADJUSTABLE, :FILL-POINTER, and :DISPLACED-TO arguments each eitherunspecified or false. All simple arrays are not adjustable.  An arrayis adjustable if and only if it was created with the :ADJUSTABLEoption.  ADJUSTABLE-ARRAY-P is false of all simple arrays.Position 2: The only simple arrays are those created with the:ADJUSTABLE, :FILL-POINTER, and :DISPLACED-TO arguments each eitherunspecified or false. A simple array may or may not be adjustable.  Anarray created with the :ADJUSTABLE option unspecified or NIL might beadjustable.  ADJUSTABLE-ARRAY-P can be used to determine whether anarray is adjustable.Here are the points of ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9). I willnote whether each point is consistent with each of the two Positionsso that Version 9 can be seen to be a change rather than aclarification:  1. ADJUSTABLE-ARRAY-P is true of all arrays created with a true  :ADJUSTABLE option to MAKE-ARRAY.  Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified. This weakly contradicts Position 1, since Position 1 states whicharrays are adjustable and which aren't.  It is consistent withPosition 2.  2. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,   and :DISPLACED-TO arguments each either unspecified or false, the  resulting array is a simple array.  (This just repeats what CLtL  says on page 289, it's here to aid in understanding the next point.)This is simply (S-4).        3. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the  resulting array is simple is unspecified.      This contradicts both Position 1 and Position 2.  4. ADJUST-ARRAY ``should signal'' an error if ADJUSTABLE-ARRAY-P  of its first argument is false.  ADJUST-ARRAY must not signal an  `array not adjustable' error if ADJUSTABLE-ARRAY-P of its first  argument is true.This is consistent with both Position 1 and Position 2.  5. The value of ADJUSTABLE-ARRAY-P on a simple array is unspecified.This contradicts Position 1 and is consistent with Position 2.Let's also look at the ``Clarifications and Logical Consequences''presented in the proposal:  a. Whether an array can be both simple and adjustable is unspecified.This contradicts Position 1 and is consistent with Position 2.  b. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.This contradicts Position 1 and is consistent with Position 2.  c. There is no specified way to create an array that is non-simple.This contradicts both Position 1 and Position 2. In fact, thiscontradicts (S-1) under any reasonable interpretation of it.  d. This legitimizes ADJUSTABLE-ARRAY-P as an appropriate predicate to     determine whether ADJUST-ARRAY will reliably succeed.This is consistent with both Position 1 and Position 2.  e. If ADJUST-ARRAY is invoked on an array that was created without     supplying :ADJUSTABLE true, an `array not adjustable' error     ``should be signaled'' unless ADJUSTABLE-ARRAY-P returns true on     that array (in which case it must not signal an `array not adjustable'     error).This is consistent with both Position 1 and Position 2.Therefore, ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9) is a change toCLtL, and in fact, Point 3 (and Consequence C) is a major change.			-rpg-*start*01281 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 22-Mar-89 10:49:20 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 MAR 89 09:10:44 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Mar 89  08:45:33 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 562901; Wed 22-Mar-89 11:44:59 ESTDate: Wed, 22 Mar 89 11:44 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)To: Richard P. Gabriel <rpg@lucid.com>cc: x3j13@SAIL.STANFORD.EDUIn-Reply-To: <8903220438.AA22664@challenger>Message-ID: <19890322164453.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 21 Mar 89 20:38:38 PST    From: Richard P. Gabriel <rpg@lucid.com>    [603 lines deleted]    Therefore, ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9) is a change to    CLtL, and in fact, Point 3 (and Consequence C) is a major change.Show us any conforming program that would be harmed by this change (ifit is a change, and I don't believe your arguments that it is a change)"c. There is no specified way to create an array that is non-simple."*start*03581 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 22-Mar-89 12:06:27 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 MAR 89 11:50:20 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 22 Mar 89  11:01:59 PSTReceived: from fafnir.think.com by Think.COM; Wed, 22 Mar 89 13:05:17 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Wed, 22 Mar 89 12:56:48 ESTReceived: by verdi.think.com; Wed, 22 Mar 89 12:53:33 ESTDate: Wed, 22 Mar 89 12:53:33 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903221753.AA26200@verdi.think.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 21 Mar 89 19:28 EST <19890322002858.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)After yet more careful study I conclude that the version 9 proposalis not a clarification but a change.  Here is the reasoning.There is only one way in Common Lisp to adjust an array, and that is bycalling ADJUST-ARRAY.  (The definition of VECTOR-PUSH-EXTEND, p. 296,specifically says that it uses ADJUST-ARRAY, and other places in thelanguage, such as FORMAT with a string as first argument, refer toVECTOR-PUSH-EXTEND.)Hence it is senseless to speak of an array that is "adjustable" but cannotunder any circumstances legitimately be given to ADJUST-ARRAY.Now look at the definition of ADJUST-ARRAY, pp. 297-98.  It is not permitted to call ADJUST-ARRAY on an array that was not  created with the :ADJUSTABLE option.  The predicate ADJUSTABLE-ARRAY-P  may be used to determine whether or not an array is adjustable.I reason that the first sentence prohibits any array not created withthe :ADJUSTABLE option from being given to ADJUST-ARRAY under anycircumstances.  This includes having been tested with ADJUSTABLE-ARRAY-P.Therefore any array not created with the :ADJUSTABLE option must benot adjustable.  Therefore ADJUSTABLE-ARRAY-P must return NIL whengiven such an array.  Therefore the following items of the proposalcannot be true of the current (CLtL) specification:  1.                                    ... Whether ADJUSTABLE-ARRAY-P is  true of some other arrays is unspecified.  b. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.Therefore the proposal is a change and not a clarification, andshould be labeled as such.----------------------------------------------------------------I think that the following points also require clarification or comment:(1) What is a compiler permitted to conclude from the declarations	(DECLARE (SIMPLE-ARRAY FOO)	         (TYPE (AND ARRAY (NOT SIMPLE-ARRAY)) BAR))    ?(2) What is a program permitted to conclude from the test	(TYPEP X 'SIMPLE-ARRAY)    both when it returns true and when it returns false?(3) I believe that much of the controversy stems from disagreement over    whether the definition on page 28 is considered to be an implication    or an equivalence.  That is, I think everyone agrees that the    sentence could be rephrased as:	An array is simple __________ it is is not displaced to another	array, has no fill pointer, and is not adjustable.    but they disagree on whether the blank should read "if" or "iff".    The proposal should state explicitly which of these two interpretations    (or what third interpretation) is assumed.--Guy*start*05360 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 23-Mar-89 09:35:33 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 09:35:26 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Mar 89  09:03:25 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 563608; Thu 23-Mar-89 12:03:12 ESTDate: Thu, 23 Mar 89 12:03 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)To: x3j13@SAIL.STANFORD.EDUIn-Reply-To: <8903220438.AA22664@challenger>Message-ID: <19890323170307.4.MOON@EUPHRATES.SCRC.Symbolics.COM>It's not very important to me whether we call it a clarificationor a change.  What's more important is that we agree on a definitionof simple-array and that we get this issue behind us so we can moveon and finish this standard, so we can all go home.The fundamental question, I think, is whether simple-array is aconceptual type or a representation type.  I had assumed based on thediscussions that lead to the writing of CLtL, and on the lack of anycontradiction, that everyone agreed that it is a representation type andall we had to do was state the details more clearly.  Apparently I wasmistaken.Let me explain what I mean by those terms.  A conceptual type is onethat the programmer of a portable program thinks of as conceptuallydistinct data.  For example, RATIO is a conceptual type.  No one thinksa RATIO is another kind of CONS, and probably no one thinks a RATIOis another kind of FLOAT.  All implementations agree on which objectsare of type RATIO and which are not.A representation type is one that is not a conceptually distinct form ofdata.  We have such types in the language in order to expose enough ofthe implementation-dependent representation to permit user programs tobe specialized for one representation, so we can compile better code.Representation types are a compromise between portability andefficiency, and as such their definition is generallyimplementation-dependent.  We define just enough about a representationtype so a programmer can figure out whether to use it, but we do notconstrain all implementations to use the same representation.  Arepresentation type is always a subtype of a conceptual type andincludes some, but not necessarily all, members of that conceptual typethat are implemented in some particularly efficient way.  A good exampleof a representation type is FIXNUM.  Not all implementations agree onwhich objects are of type FIXNUM.  However, we have defined FIXNUMclosely enough (it includes a certain range of the integers, as well aspossibly some other integers) to allow a programmer to decide whether agiven variable in a given program can or cannot be declared FIXNUM.  Wespecify some integers that are guaranteed to be FIXNUM, but we do notspecify any integers that are guaranteed never to be FIXNUM in anyimplementation.Back to SIMPLE-ARRAY.  If SIMPLE-ARRAY is a conceptual type, then anarray is a SIMPLE-ARRAY if-and-only-if it meets certain criteria, andall implementations must agree on exactly which objects are of typeSIMPLE-ARRAY.  Programmers would think of SIMPLE-ARRAYs as distinctlydifferent from ordinary arrays, and when programming would frequentlyask themselves "should I use a SIMPLE-ARRAY here or a regular ARRAY"even when not thinking at all about efficiency or optimization.  Theywould write their program differently depending on whether they useda SIMPLE-ARRAY or a regular ARRAY, just as they would write theirprogram differently depending on whether they used a LIST or a VECTOR.On the other hand, if SIMPLE-ARRAY is a representation type, then anarray is a SIMPLE-ARRAY if-and-only-if it is implemented with asimpler, more efficient representation than regular arrays.  An array isa SIMPLE-ARRAY if, but not only-if, it meets certain criteria.  In otherwords we define a common intersection of the SIMPLE-ARRAY types ofall implementations, but we allow implementations to expand theirSIMPLE-ARRAY types to include other arrays, as appropriate to theirmachine, just like FIXNUM, BASE-CHARACTER, and (ARRAY (UNSIGNED-BYTE 4)).Programmers would only ask themselves "should this be a SIMPLE-ARRAY"when thinking about efficiency and optimization.I believe SIMPLE-ARRAY is a representation type because, as aprogrammer, I don't think of it as conceptually different from anordinary array, and because, as a historian, I know that SIMPLE-ARRAYwas added to Common Lisp in 1982, and attained its current form in 1983,in order to address the concern of many implementors that using thefully general representation for all arrays would be too slow, as aresult of the large number of array features in Common Lisp.  The ideawas to permit use of a simpler, streamlined representation for somearrays, and to make that representation available in TYPE declarationsso the compiler could optimize AREF on it.To proceed, I think we should first reach a concensus on whetherSIMPLE-ARRAY is a conceptual or a representation type.  Once we havedone that, we will have a framework within which to decide the specificdetails of its behavior.*start*03669 00024 USaGV-Info: X3J13-mailer@SAIL.Stanford.EDU at 23-Mar-89 16:12:12 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 16:12:03 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 23 Mar 89  15:51:46 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA03601g; Thu, 23 Mar 89 13:23:09 PSTReceived: by challenger id AA24966g; Thu, 23 Mar 89 13:18:25 PSTDate: Thu, 23 Mar 89 13:18:25 PSTFrom: Richard P. Gabriel <rpg@lucid.com>Message-Id: <8903232118.AA24966@challenger>To: x3j13@sail.stanford.eduSubject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)Moon raises an important point about conceptual versusrepresentational types. It always struck me that simple arrays asdefined in Version 9 were somewhat like each of these two things.Moon also points out the FIXNUM/SIMPLE-ARRAY analogy. Let's look moreat this analogy:Suppose I have some piece of code like this:(defun f (x) ...)and I want to know whether to put in a FIXNUM declaration for adifferent target CL about which I know everything. In order to do thatI have to look at the calls to F to see whether they all produceFIXNUMs for the target CL. Usually I look no further, but in general Imust look all the way back from each call to F to the origin of theargument that is passed to F. The reason I usually have to look nofurther than the call is that this is typically where the number iscreated.Now suppose the piece of code really takes an array, and I want to putin a SIMPLE-ARRAY declaration so that I can get fast array access.  Icannot look only at the calls to F, nor can I look at the creation ofthe arrays that get passed to F, but I have to look at all operationson F to see whether any of them is an ADJUST-ARRAY.  That is, I cannotsimply look all the way back from each invocation of F to the creationof the argument that is passed, but I also have to look all the wayforward to the termination of the program.In the FIXNUM example, this is as if I had to look at all theoperations on the numbers being fed to F (either before or *after* Fin execution order) to see whether some particular operation wasapplied to an argument to F.  That is, I cannot look at dataflow up tothe call to F to determine whether it is an simple array, I have tolook at the entire life history of the objects passed to F.This leads to what I think is an interesting point. Some theoristsdefine a type as being the set of objects that can be passed to aparticular set of functions or operations. That is, a number issomething you can add, subtract, multiply, and divide, for example.Some describe this by saying that a type is the set of objects thatrespond to the same protocol.In all implementations, FIXNUMs and BIGNUMs can be operated on by thesame set of functions and operations. Thus, FIXNUMs and BIGNUMs aremerely representational variants on the same type (namely, INTEGER).In all implementations, ARRAY can be operated on by AREF, SETF ofAREF, and ADJUST-ARRAY (and some others). In some implementations, SIMPLE-ARRAY can be operated on by AREF, SETFof AREF (and some others), but not by ADJUST-ARRAY. Thus, in someimplementations SIMPLE-ARRAY responds to a different protocol and soit is a conceptual type, while in implementations it is arepresentational type.This is, I think, the source of my uneasiness about the whole issue:Version 9 legitimizes SIMPLE-ARRAY being a representational type insome Common Lisps and a conceptual type in others. Only people who areporting will notice the difference.				-rpg-*start*01032 00024 US Date:  4 Apr 89 08:07 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLETo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLETo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 08:07:20 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  08:04:40 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 570859; Tue 4-Apr-89 11:04:34 EDTOriginal-Date: Tue, 4 Apr 89 11:04 EDTMessage-ID: <890404110402.9.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say this was deferred to next meeting.*start*01311 00024 US GV-Info: masinter.pa at  8-Apr-89 23:38:38 from massunterDate:  8 Apr 89 23:38 PDTFrom: masinter.paSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)In-reply-to: Richard P. Gabriel <rpg@lucid.com>'s message of Thu, 23 Mar 89 13:18:25 PSTTo: Richard P. Gabriel <rpg@lucid.com>cc: masinterActually, I don't think very many people who are porting will notice the difference between the 'conceptual' and 'implementation' models of adjustable arrays.Those porting from 'implementation' to 'conceptual' won't notice for the most part, because, for the most part, it is upward compatible.Those porting from 'conceptual' to 'implementation' might notice, too.Maybe we should document :ADJUSTABLE as 'implementation' and just say that treating them as 'conceptual' is an "allowable extension". Its an "extension" in a funny way: some arrays that you don't say should be :ADJUSTABLE T wind up being ADJUSTABLE-ARRAY-P anyway.  The only reason the extension is funny is that there are otherwise conformal programs that will behave differently in implementations with that extension. I think this is a different kind of extension than the other kinds we've discussed; I can't think of any other analogies because there aren't many other kinds of options for other datatypes.*start*02021 00024 US GV-Info: rpg@lucid.com at  9-Apr-89 08:36:45 from AGReturn-Path: <rpg@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 09 APR 89 08:36:40 PDTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA02056g; Sun, 9 Apr 89 08:30:45 PDTReceived: by challenger id AA02438g; Sun, 9 Apr 89 08:25:53 PDTDate: Sun, 9 Apr 89 08:25:53 PDTFrom: Richard P. Gabriel <rpg@lucid.com>Message-Id: <8904091525.AA02438@challenger>To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 8 Apr 89 23:38 PDT <890408-233908-2441@Xerox>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (Version 9)``Actually, I don't think very many people who are porting will noticethe difference between the 'conceptual' and 'implementation' models ofadjustable arrays.''Most people who port Lisp code are moving from Symbolics to stockhardware.  Lucid gets plenty of complaints from users about theirsupposedly portable common lisp code not being portable because theytry to adjust a simple array.I think the solution is something like this:Define simple-array to be exactly the non-fill-pointer, non-displaced,:adjustable NIL arrays. ADJUST-ARRAY returns 2 values: the adjusted arrayand a boolean stating whether the array was copied. ADJUST-ARRAY thereforeworks on all arrays, but it might copy.Moon's proposal is like this in that he wants to installADJUSTABLE-ARRAY-P as the guardian to determine whether the user needsto copy in order to adjusta an array. If so, we should simply bury thecopying behavior in ADJUST-ARRAY with ADJUSTABLE-ARRAY-P the guardianthat states whether the copying will happen.I should point out that I was originally in Moon's camp, and the re-readingof CLtL that the debate inspired and discussions with Steele led meto switch my position.Your proposal seems to legitimize what I think is a non-intuitivechange to CLtL. Possibly it would fly if there were a declaration thatwould state whether an array is adjustable.			-rpg-*start*11501 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 13-Jun-89 15:56:11 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JUN 89 15:56:07 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 13 Jun 89  15:53:25 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 610864; 13 Jun 89 18:55:13 EDTDate: Tue, 13 Jun 89 18:55 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19890613225538.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Version 5 of this proposal passed with amendments at the January1989 X3J13 meeting.  However, the amendments were found to resultin an inconsistent proposal, and it was also pointed out that somerelated problems with simple-arrays were not addressed.  Since thenthere has been a great deal of private discussion, and review ofvarious versions of the proposal including ones earlier than 5.The result is this proposal, which is believed to be acceptable toeveryone and is being offered for a vote in June to replace theJanuary version that was already voted in.Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289),              simple strings with fill pointers (p299)Category:     CLARIFICATION and CHANGEEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting to shorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bug introduced                        by the amendment, add clarification of SIMPLE-ARRAY type.              15-Feb-89, Version 7, by Pitman. Minor changes per comments from                        RPG and Dalton.              11-Mar-89, Version 8, by Pitman. Change category, add endorsements.              17-Mar-89, Version 9, by Moon, fix wording and examples to make it                        clear that the semantics of simple-array is unchanged.               6-Jun-89, Version 10, by Moon and Gabriel, do over.Problem Description:  There are a number of unclear passages in CLtL related to simple arrays  and adjustable arrays.  There is disagreement on precisely how these  passages are to be interpreted, and no one is happy with the fact that  ADJUST-ARRAY works only on an implementation-dependent subset of arrays.  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288 says that  ``the argument, if specified and not NIL, indicates that it must be  possible to alter the array's size dynamically after it is created. This  argument defaults to NIL.''  The description of the :ADJUSTABLE option  does not say what MAKE-ARRAY will do if the argument is unsupplied or  explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is true ``if  the argument (which must be an array) is adjustable, and otherwise  false.'' However, the description of MAKE-ARRAY makes it clear that this  is not necessarily the same as asking if the array was created with  :ADJUSTABLE T.  If ADJUSTABLE-ARRAY-P returns NIL, you know that  :ADJUSTABLE NIL was supplied (or no :ADJUSTABLE option was supplied), but  if ADJUSTABLE-ARRAY-P returns T, then there is no information about  whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is ``not  permitted to call ADJUST-ARRAY on an array that was not created with the  :ADJUSTABLE option.'' This is inconsistent with ADJUSTABLE-ARRAY-P.  The definition of SIMPLE-ARRAY on p.28 says ``an array that is not  displaced to another array, has no fill pointer, and is not to have its  size adjusted dynamically after creation is called a simple array.''  It is left unclear whether this is an implication or an equivalence,  i.e. whether there can be other simple arrays as well.  CLtL p.299 appears to refer to simple strings with fill pointers,  suggesting that it is an implication, but similar language is used for  equivalences in other parts of CLtL.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:IMPLICIT-COPY)  1. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,   and :DISPLACED-TO arguments each either unspecified or false, the  resulting array is a simple array.  (This just repeats what CLtL  says on page 289, it's here to aid in understanding the next point.)        2. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the  resulting array is simple is unspecified.  3. It is permitted to call ADJUST-ARRAY on any array.  (Remove the  restriction documented at the bottom of p.297.)  4. If ADJUST-ARRAY is applied to an array created with :ADJUSTABLE true,  the array returned is EQ to its first argument.  It is not specified  whether ADJUST-ARRAY returns an array EQ to its first argument for any  other arrays.  If the array returned by ADJUST-ARRAY is not EQ to its  first argument, the consequences of any reference to the original array  are undefined.        5. The predicate ADJUSTABLE-ARRAY-P is true if and only if ADJUST-ARRAY  will return a value EQ to this array when given this array as its first  argument.Clarifications and Logical Consequences:  a. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.  b. There is no specified way to create an array that is non-simple.  c. The definition of SIMPLE-ARRAY on p.28 is taken to be an implication,     not an equivalence.  This is either a clarification or a change depending     on one's prior reading of that definition.  d. The meaning of ADJUSTABLE-ARRAY-P is changed.  e. As with such functions as DELETE and NCONC, textbooks should     instruct programmers to be careful to receive the value returned by     ADJUST-ARRAY, as it might not be EQ to the first argument.Rationale:  Points 3 and 4 eliminate the problem of ADJUST-ARRAY only working on a  subset of arrays, by changing it to work on all arrays.  It remains  implementation-dependent whether the array is modified in place or  copied, i.e. whether the result is EQ to the argument, however many other  functions in Common Lisp have similar implementation-dependent behavior.  Implementation-dependent storage allocation or reuse is considered  more benign than implementation-dependent applicability of an operation.  Point 3 recognizes that ADJUST-ARRAY offers features that are offered by  no other function and which are useful in cases involving non-adjustable  arrays (for what amounts to copying).  This change would allow an  expression such as:    (SETQ X (ADJUST-ARRAY X ...))  to work reliably. Those desiring the old behavior could do:    (IF (OR (NOT (ADJUSTABLE-ARRAY-P X))            (NOT (EQUAL (ARRAY-RANK X) (LENGTH NEW-DIMENSIONS))))        (ERROR "Array cannot be adjusted."))    to get the old style error checking.  Point 5 recycles the name ADJUSTABLE-ARRAY-P as a test for whether an  array is adjusted in place or by copying.  Point 2 preserves the raison d'etre of simple arrays, which is to provide  a portable interface to implementation-dependent specialized arrays that  trade decreased functionality for faster access.  A proposed alternative  was to specify a way to create an array that is guaranteed not to be  simple.  This would have made (typep (make-array ...) 'simple-array)  return the same value in all implementations, but would have required  large changes to some implementations and would be of little benefit to  users.  Users need to know that certain arrays are simple, so they can  put in declarations and get higher performance, but users have no need to  be able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable.Examples:  1. The following program is conforming.      (defun double (a)      (adjust-array a (* (length a) 2)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))  3. The following program is non-conforming.  The consequences of this  program are undefined because the type declaration is violated in some  implementations.    (let ((a (make-array 100 :adjustable t)))      (declare (simple-array a))      (frob a))Current Practice:  Every correct CLtL implementation conforms to points 1 and 2.  It is  unlikely that any implementation currently exists that conforms to points  3, 4, and 5.  Points 3 and 4 involve additions to an implementation to  support the copying form of ADJUST-ARRAY.  Point 5 may involve a change  to ADJUSTABLE-ARRAY-P or may be able to use the existing implementation  of the function.  Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is a SIMPLE-ARRAY.  The arrays that are internally simple in Symbolics Genera are a different  subset of arrays from the type SIMPLE-ARRAY, because simplicity in that  implementation depends on the rank and total-size as well as on the  fill-pointer and displacement, thus Genera does not use the type  SIMPLE-ARRAY for anything.  Lucid, IIM, Ibuki, and Symbolics Cloe make :ADJUSTABLE NIL arrays  non-adjustable in all cases, and make every array non-simple that CLTL  does not require to be simple.  Macintosh Allegro Common Lisp v1.2 makes :ADJUSTABLE NIL arrays  non-adjustable in all cases, makes all arrays of rank other than 1  non-simple (violating point 1), and makes every array non-simple that  CLTL does not require to be simple.Cost to Implementors:  The change to ADJUSTABLE-ARRAY-P is easy.  The change to ADJUST-ARRAY may  involve some complex coding but should not be a large task.  No changes  are required to anything connected with SIMPLE-ARRAY.Cost to Users:  None in code that does not call ADJUSTABLE-ARRAY-P.  This is a fully  upward-compatible change from the user's standpoint.Benefits:  Programs that use simple arrays and/or adjust arrays will be easier  to port, as the language specification for these features will be  clearer.  More programs will be able to call ADJUST-ARRAY, as its use  will not be restricted to a subset of arrays.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired signal.  A few programs might have  porting problems due to variation among implementations of whether the  result of ADJUST-ARRAY is EQ to the first argument.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language more clearly specified is an aesthetic improvement.  Allowing ADJUST-ARRAY on all arrays is an aesthetic improvement.Discussion:  There are at least 110 messages of discussion preceding this version of the  proposal.  It does not seem feasible to summarize them here.  Dick Gabriel, Dave Moon, and Guy Steele support this proposal.*start*11450 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 13-Jun-89 16:54:25 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JUN 89 16:54:10 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 13 Jun 89  16:14:51 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 610877; 13 Jun 89 19:16:42 EDTDate: Tue, 13 Jun 89 19:17 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: X3J13@sail.stanford.eduMessage-ID: <19890613231714.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Version 5 of this proposal passed with amendments at the January1989 X3J13 meeting.  However, the amendments were found to resultin an inconsistent proposal, and it was also pointed out that somerelated problems with simple-arrays were not addressed.  Since thenthere has been a great deal of private discussion, and review ofvarious versions of the proposal including ones earlier than 5.The result is this proposal, which is believed to be acceptable toeveryone and is being offered for a vote in June to replace theJanuary version that was already voted in.Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289),              simple strings with fill pointers (p299)Category:     CLARIFICATION and CHANGEEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting to shorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bug introduced                        by the amendment, add clarification of SIMPLE-ARRAY type.              15-Feb-89, Version 7, by Pitman. Minor changes per comments from                        RPG and Dalton.              11-Mar-89, Version 8, by Pitman. Change category, add endorsements.              17-Mar-89, Version 9, by Moon, fix wording and examples to make it                        clear that the semantics of simple-array is unchanged.               6-Jun-89, Version 10, by Moon and Gabriel, do over.Problem Description:  There are a number of unclear passages in CLtL related to simple arrays  and adjustable arrays.  There is disagreement on precisely how these  passages are to be interpreted, and no one is happy with the fact that  ADJUST-ARRAY works only on an implementation-dependent subset of arrays.  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288 says that  ``the argument, if specified and not NIL, indicates that it must be  possible to alter the array's size dynamically after it is created. This  argument defaults to NIL.''  The description of the :ADJUSTABLE option  does not say what MAKE-ARRAY will do if the argument is unsupplied or  explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is true ``if  the argument (which must be an array) is adjustable, and otherwise  false.'' However, the description of MAKE-ARRAY makes it clear that this  is not necessarily the same as asking if the array was created with  :ADJUSTABLE T.  If ADJUSTABLE-ARRAY-P returns NIL, you know that  :ADJUSTABLE NIL was supplied (or no :ADJUSTABLE option was supplied), but  if ADJUSTABLE-ARRAY-P returns T, then there is no information about  whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is ``not  permitted to call ADJUST-ARRAY on an array that was not created with the  :ADJUSTABLE option.'' This is inconsistent with ADJUSTABLE-ARRAY-P.  The definition of SIMPLE-ARRAY on p.28 says ``an array that is not  displaced to another array, has no fill pointer, and is not to have its  size adjusted dynamically after creation is called a simple array.''  It is left unclear whether this is an implication or an equivalence,  i.e. whether there can be other simple arrays as well.  CLtL p.299 appears to refer to simple strings with fill pointers,  suggesting that it is an implication, but similar language is used for  equivalences in other parts of CLtL.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:IMPLICIT-COPY)  1. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,   and :DISPLACED-TO arguments each either unspecified or false, the  resulting array is a simple array.  (This just repeats what CLtL  says on page 289, it's here to aid in understanding the next point.)        2. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the  resulting array is simple is unspecified.  3. It is permitted to call ADJUST-ARRAY on any array.  (Remove the  restriction documented at the bottom of p.297.)  4. If ADJUST-ARRAY is applied to an array created with :ADJUSTABLE true,  the array returned is EQ to its first argument.  It is not specified  whether ADJUST-ARRAY returns an array EQ to its first argument for any  other arrays.  If the array returned by ADJUST-ARRAY is not EQ to its  first argument, the consequences of any reference to the original array  are undefined.        5. The predicate ADJUSTABLE-ARRAY-P is true if and only if ADJUST-ARRAY  will return a value EQ to this array when given this array as its first  argument.Clarifications and Logical Consequences:  a. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.  b. There is no specified way to create an array that is non-simple.  c. The definition of SIMPLE-ARRAY on p.28 is taken to be an implication,     not an equivalence.  This is either a clarification or a change depending     on one's prior reading of that definition.  d. The meaning of ADJUSTABLE-ARRAY-P is changed.  e. As with such functions as DELETE and NCONC, textbooks should     instruct programmers to be careful to receive the value returned by     ADJUST-ARRAY, as it might not be EQ to the first argument.Rationale:  Points 3 and 4 eliminate the problem of ADJUST-ARRAY only working on a  subset of arrays, by changing it to work on all arrays.  It remains  implementation-dependent whether the array is modified in place or  copied, i.e. whether the result is EQ to the argument, however many other  functions in Common Lisp have similar implementation-dependent behavior.  Implementation-dependent storage allocation or reuse is considered  more benign than implementation-dependent applicability of an operation.  Point 3 recognizes that ADJUST-ARRAY offers features that are offered by  no other function and which are useful in cases involving non-adjustable  arrays (for what amounts to copying).  This change would allow an  expression such as:    (SETQ X (ADJUST-ARRAY X ...))  to work reliably. Those desiring the old behavior could do:    (IF (OR (NOT (ADJUSTABLE-ARRAY-P X))            (NOT (EQUAL (ARRAY-RANK X) (LENGTH NEW-DIMENSIONS))))        (ERROR "Array cannot be adjusted."))    to get the old style error checking.  Point 5 recycles the name ADJUSTABLE-ARRAY-P as a test for whether an  array is adjusted in place or by copying.  Point 2 preserves the raison d'etre of simple arrays, which is to provide  a portable interface to implementation-dependent specialized arrays that  trade decreased functionality for faster access.  A proposed alternative  was to specify a way to create an array that is guaranteed not to be  simple.  This would have made (typep (make-array ...) 'simple-array)  return the same value in all implementations, but would have required  large changes to some implementations and would be of little benefit to  users.  Users need to know that certain arrays are simple, so they can  put in declarations and get higher performance, but users have no need to  be able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable.Examples:  1. The following program is conforming.      (defun double (a)      (adjust-array a (* (length a) 2)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))  3. The following program is non-conforming.  The consequences of this  program are undefined because the type declaration is violated in some  implementations.    (let ((a (make-array 100 :adjustable t)))      (declare (simple-array a))      (frob a))Current Practice:  Every correct CLtL implementation conforms to points 1 and 2.  It is  unlikely that any implementation currently exists that conforms to points  3, 4, and 5.  Points 3 and 4 involve additions to an implementation to  support the copying form of ADJUST-ARRAY.  Point 5 may involve a change  to ADJUSTABLE-ARRAY-P or may be able to use the existing implementation  of the function.  Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is a SIMPLE-ARRAY.  The arrays that are internally simple in Symbolics Genera are a different  subset of arrays from the type SIMPLE-ARRAY, because simplicity in that  implementation depends on the rank and total-size as well as on the  fill-pointer and displacement, thus Genera does not use the type  SIMPLE-ARRAY for anything.  Lucid, IIM, Ibuki, and Symbolics Cloe make :ADJUSTABLE NIL arrays  non-adjustable in all cases, and make every array non-simple that CLTL  does not require to be simple.  Macintosh Allegro Common Lisp v1.2 makes :ADJUSTABLE NIL arrays  non-adjustable in all cases, makes all arrays of rank other than 1  non-simple (violating point 1), and makes every array non-simple that  CLTL does not require to be simple.Cost to Implementors:  The change to ADJUSTABLE-ARRAY-P is easy.  The change to ADJUST-ARRAY may  involve some complex coding but should not be a large task.  No changes  are required to anything connected with SIMPLE-ARRAY.Cost to Users:  None in code that does not call ADJUSTABLE-ARRAY-P.  This is a fully  upward-compatible change from the user's standpoint.Benefits:  Programs that use simple arrays and/or adjust arrays will be easier  to port, as the language specification for these features will be  clearer.  More programs will be able to call ADJUST-ARRAY, as its use  will not be restricted to a subset of arrays.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired signal.  A few programs might have  porting problems due to variation among implementations of whether the  result of ADJUST-ARRAY is EQ to the first argument.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language more clearly specified is an aesthetic improvement.  Allowing ADJUST-ARRAY on all arrays is an aesthetic improvement.Discussion:  There are at least 110 messages of discussion preceding this version of the  proposal.  It does not seem feasible to summarize them here.  Dick Gabriel, Dave Moon, and Guy Steele support this proposal.*start*01722 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 18-Jun-89 13:08:14 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 JUN 89 13:08:20 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 18 Jun 89  13:07:01 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA22209; Sun, 18 Jun 89 14:07:25 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA26018; Sun, 18 Jun 89 14:07:18 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8906182007.AA26018@defun.utah.edu>Date: Sun, 18 Jun 89 14:07:17 MDTSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Tue, 13 Jun 89 19:17 EDT[removed x3j13, added cl-cleanup to distribution]>   If the array returned by ADJUST-ARRAY is not EQ to its>   first argument, the consequences of any reference to the original array>   are undefined.I'm not sure I understand the motivation for this restriction.  I'mguessing that you want to permit the storage used by the originalarray to be re-used.  This is OK, however, I think prohibitingreferences to the original array is going overboard -- you probablyreally want to only restrict references to its contents via AREF.For example, the rationale section says you should do  (setq x (adjust-array x ...))Just after ADJUST-ARRAY returns, but before the SETQ happens, Xstill contains a reference to the original array, and hence this exampleis in error.-Sandra-------*start*02063 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 19-Jun-89 09:33:19 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 09:32:48 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 19 Jun 89  09:30:44 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 612975; 19 Jun 89 12:30:58 EDTDate: Mon, 19 Jun 89 12:31 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8906182007.AA26018@defun.utah.edu>Message-ID: <19890619163136.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sun, 18 Jun 89 14:07:17 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    [removed x3j13, added cl-cleanup to distribution]    >   If the array returned by ADJUST-ARRAY is not EQ to its    >   first argument, the consequences of any reference to the original array    >   are undefined.    I'm not sure I understand the motivation for this restriction.  I'm    guessing that you want to permit the storage used by the original    array to be re-used.  I imagine that was the intent.			  This is OK, however, I think prohibiting    references to the original array is going overboard -- you probably    really want to only restrict references to its contents via AREF.    For example, the rationale section says you should do      (setq x (adjust-array x ...))    Just after ADJUST-ARRAY returns, but before the SETQ happens, X    still contains a reference to the original array, and hence this example    is in error.I see, the word "reference" is ambiguous.  It could mean performing anoperation on the array, or it could mean having a reference in the garbagecollector sense.  How about if "any reference to" were amended to read"any operation on"?*start*02426 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 19-Jun-89 12:57:46 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 12:57:48 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 19 Jun 89  12:55:31 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA18852; Mon, 19 Jun 89 13:55:54 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA26744; Mon, 19 Jun 89 13:55:52 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8906191955.AA26744@defun.utah.edu>Date: Mon, 19 Jun 89 13:55:50 MDTSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: Sandra J Loosemore <sandra%defun@cs.utah.edu>, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Mon, 19 Jun 89 12:31 EDT> I see, the word "reference" is ambiguous.  It could mean performing an> operation on the array, or it could mean having a reference in the garbage> collector sense.  How about if "any reference to" were amended to read> "any operation on"?I suppose that would be OK, as would something like "any attempt toaccess".  However, I'm still a little apprehensive here that theremight still be unexpected problems, like if the user is steppingthrough the code with the debugger and tries to examine the values oflocal variables.  The real problem is that this operation canpotentially invalidate the original object by freeing some of itsstorage, or otherwise stuffing garbage into it.  I don't think thatany other destructive operations are permitted to do this, and it doesseem to violate the principle that Lisp objects have indefiniteextent.  I wonder if it's worth adding such ugliness to the languagejust for the sake of an efficiency hack.  I would feel morecomfortable if this sentence were removed entirely and ADJUST-ARRAYnot permitted to bash the original array unless it returns an objectthat is EQ to it.Incidentally, I have discussed this issue more generally with othershere.  We like the idea of making ADJUST-ARRAY work on all arrays, butwe would like to see ADJUSTABLE-ARRAY-P removed from the languagealtogether.  We don't think that the way this proposal redefines it isparticularly useful. -Sandra-------*start*00904 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 19-Jun-89 13:16:05 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 13:16:10 PDTMessage-ID: <120wWO@SAIL.Stanford.EDU>Date: 19 Jun 89 13:13 PDTFrom: Dick Gabriel <RPG@SAIL.Stanford.EDU>Subject: re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: sandra%defun@CS.UTAH.EDUCC: cl-cleanup@SAIL.Stanford.EDU [In reply to message from sandra%defun@cs.utah.edu sent Mon, 19 Jun 89 13:55:50 MDT.]I tend to agree with Sandra: I would just as soon see the arrayhanded to ADJUST-ARRAY either turned into the new array or left alone,depending on whether ADJUST-ARRAY copies.My preference is to see ADJUSTABLE-ARRAY-P removed, but this isbased simply on elegance. I can live with either position.			-rpg-*start*02797 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 19-Jun-89 15:47:24 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 15:47:28 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 19 Jun 89  15:45:05 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 613316; 19 Jun 89 17:49:54 EDTDate: Mon, 19 Jun 89 17:50 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8906191955.AA26744@defun.utah.edu>Message-ID: <19890619215033.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 19 Jun 89 13:55:50 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    > I see, the word "reference" is ambiguous.  It could mean performing an    > operation on the array, or it could mean having a reference in the garbage    > collector sense.  How about if "any reference to" were amended to read    > "any operation on"?    I suppose that would be OK, as would something like "any attempt to    access".  However, I'm still a little apprehensive here that there    might still be unexpected problems, like if the user is stepping    through the code with the debugger and tries to examine the values of    local variables.  The real problem is that this operation can    potentially invalidate the original object by freeing some of its    storage, or otherwise stuffing garbage into it.  I don't think that    any other destructive operations are permitted to do this, and it does    seem to violate the principle that Lisp objects have indefinite    extent.  I wonder if it's worth adding such ugliness to the language    just for the sake of an efficiency hack.  I would feel more    comfortable if this sentence were removed entirely and ADJUST-ARRAY    not permitted to bash the original array unless it returns an object    that is EQ to it.Reusing the storage wasn't my idea, so removing that wart is fine with me.    Incidentally, I have discussed this issue more generally with others    here.  We like the idea of making ADJUST-ARRAY work on all arrays, but    we would like to see ADJUSTABLE-ARRAY-P removed from the language    altogether.  We don't think that the way this proposal redefines it is    particularly useful. I'm neutral on this.  I am able to imagine applications where theADJUSTABLE-ARRAY-P would be useful to call before calling ADJUST-ARRAY.It sounds like I'm elected to prepare a slightly amended version of theproposal in a couple of days.*start*02460 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Jun-89 19:45:00 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 JUN 89 19:45:05 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 20 Jun 89  19:43:13 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 614297; 20 Jun 89 22:45:04 EDTDate: Tue, 20 Jun 89 22:44 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Cl-Cleanup@SAIL.Stanford.EDU, sandra%defun@cs.utah.eduMessage-ID: <19890621024458.5.KMP@BOBOLINK.SCRC.Symbolics.COM>The proposal as written sounds fine to me.  I would be content to voteYes on it as is.Since there was a hint of future changes possible, here are a few comments on the changes I might anticipate based on the discussion... - I agree with Sandra that the array should not be altered unless the EQ   array is going to be returned. - I do not want to see ADJUSTABLE-ARRAY-P removed because it provides   important functionality.  Sometimes you cannot call ADJUST-ARRAY because   you don't own all the pointers and cannot do the magic SETQ and some   applications may need to be able to detect this dynamically, perhaps   going into the debugger in that case, but at least having the option to   know.   I will concede that ADJUSTABLE-ARRAY-P is now misnamed. Perhaps that's   what really makes people want to flush it. It no longer answers the   question it looks like it does -- but it does answer a useful question.   Suppose it was       :ADJUST-ACTION :COPY	    (or :NEW)   or :ADJUST-ACTION :IDENTITY (or :RECYCLE)      Then you would say    (MAKE-ARRAY ... :ADJUST-ACTION :COPY)   and    (ARRAY-ADJUST-ACTION foo) => :COPY      Or if you prefer booleans,    (MAKE-ARRAY ... :ADJUST-WILL-COPY T)  ;or NIL   and    (ARRAY-ADJUST-WILL-COPY foo) => T     ;or NIL   Note that -MIGHT-COPY could be chosen, too, if that was the preferrable sense.   I'm mostly just trying to illustrate the space of possible naming styles, not    take a stand on a particular style.   The latter case is a simple renaming. The former is more in the style   used by the OPEN function.*start*01672 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Jun-89 21:27:14 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 JUN 89 21:27:19 PDTMessage-ID: <n1Bcy@SAIL.Stanford.EDU>Date: 20 Jun 89 21:23 PDTFrom: Dick Gabriel <RPG@SAIL.Stanford.EDU>Subject: re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: KMP@STONY-BROOK.SCRC.SYMBOLICS.COM, Moon@STONY-BROOK.SCRC.SYMBOLICS.COMCC: Cl-Cleanup@SAIL.Stanford.EDU, sandra%defun@CS.UTAH.EDU [In reply to message from KMP@STONY-BROOK.SCRC.Symbolics.COM sent Tue, 20 Jun 89 22:44 EDT.]KMP writes:   Sometimes you cannot call ADJUST-ARRAY because   you don't own all the pointers and cannot do the magic SETQ and some   applications may need to be able to detect this dynamically, perhaps   going into the debugger in that case, but at least having the option to   know.Seems like the smart applications writer is going to write(make-array...:adjustable t ...)rather than go into the debugger or something failure-like. This shouldserve him well, especially if all implementations he uses implements:ADJUST-ARRAY T by making an adjustable-array.ADJUSTABLE-ARRAY-P is an acceptable name because it is testing whether thearray is adjustable, not whether you can invoke ADJUST-ARRAY on it.  Maybethis is the first time it had the right name. ADJUST-ARRAY, on the otherhand, might be better with a different name. Deciding that better nameis as hard as deciding what the right name for ADJUSTABLE-ARRAY-P shouldhave been (ABLE-TO-INVOKE-ADJUST-ARRAY-ON-P?).			-rpg-*start*04035 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 20-Jun-89 22:45:20 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 JUN 89 22:45:26 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 20 Jun 89  22:35:11 PDTReceived: from bhopal ([192.43.178.13]) by heavens-gate id AA05498g; Tue, 20 Jun 89 22:33:25 PDTReceived: by bhopal id AA04536g; Tue, 20 Jun 89 22:35:42 PDTDate: Tue, 20 Jun 89 22:35:42 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8906210535.AA04536@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: X3J13@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 13 Jun 89 19:17 EDT <19890613231714.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)re: Clarifications and Logical Consequences:    . . .       b. There is no specified way to create an array that is non-simple.      c. The definition of SIMPLE-ARRAY on p.28 is taken to be an implication,	 not an equivalence.  This is either a clarification or a change 	 depending on one's prior reading of that definition.This is exactly the same flaw  (and the only one!) that I've been pointingout every time someone has tried to rewrite this proposal.  Namely, whatis alleged to be a proposal to fix a minor annoyance about the functionADJUST-ARRAY turns out to be a proposal that removes the portability ofthe type SIMPLE-ARRAY.  Throughout all the thousands and thousands of lines of commentary on this topic, I've yet to see one that justified breaking the portability of SIMPLE-ARRAY.  Fixing ADJUST-ARRAY as outlined in the proposal is an OK thing to do, but it doesn't by itself require breaking types [In fact, I supported Kent's long-lost proposal that called for ADJUST-ARRAY to worklike DELETE, returning a copy when it couldn't alter the array "inplace".  I had hoped that the :adjustable option to MAKE-ARRAY wouldthus acquire the meaning "adjustable in place".]Since it is so critically important for stock hardware implementations to have some way to DECLARE implementational properties about subclasses of arrays, in order to do optimizations on AREF etc based on the morphologyof the object, then I doubt that any such vendor will give up use of the type SIMPLE-ARRAY, merely to mimic a deficiency in one of the special-purposevendor's implementations.  [Sure there could have been other ways to achieve this end -- other than special-purpose hardware -- but the type system is theone that CLtL chose, and  the *** definition *** of that type on page 28 is the important one.]Rather, the consequence of this proposal is merely to make that very common, standard practice be "non standard" -- that is, it is no longer guaranteed that programs which depend on the type SIMPLE-ARRAY will work the same when moved from one implementation to another.  Note: this *isn't* saying that all such programs will break -- only that some reasonable oneswill either break or work differently.  Consider for example the trivial:      (typep (make-array 5 :adjustable t) 'simple-array)If I read the proposal correctly, it would explicitly permit thisto return true, instead of false.Such a change isn't mitigated by the fact that some types have alwaysbeen non-portable -- e.g. FIXNUM -- but we have generally acted toreduce the variations rather than increase them.  Consider why, for example, the types NUMBER and CHARACTER are portable:        (typep (int-char 100)  'number)      (typep (char-int #\A)  'character)are false in every implementation (and CLtL guarantees this by the clear proscription on page 33.)   But CLtL permits READTABLEs to be implemented as simple general vectors;so the type READTABLE wasn't portable until after passing the CLOS-inspiredresolution that guaranteed a lot more pairwise disjointness.  This, Ibelieve, is the better direction in which to move -- reducing non-portability rather than increasing it.-- JonL --*start*02895 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 21-Jun-89 07:05:42 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 07:05:49 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 21 Jun 89  07:03:43 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA17727; Wed, 21 Jun 89 08:03:24 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA01380; Wed, 21 Jun 89 08:03:21 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8906211403.AA01380@defun.utah.edu>Date: Wed, 21 Jun 89 08:03:20 MDTSubject: Re: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: Jon L White <jonl@lucid.com>Cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White <jonl@lucid.com>, Tue, 20 Jun 89 22:35:42 PDT[Removed X3J13; added cl-cleanup]> Date: Tue, 20 Jun 89 22:35:42 PDT> From: Jon L White <jonl@lucid.com>> > Throughout all the thousands and thousands of lines of commentary on this > topic, I've yet to see one that justified breaking the portability of > SIMPLE-ARRAY.I'm not convinced the breakage is really all that severe.  By analogy,we're now saying that at least a certain subset of INTEGERs areguaranteed to be FIXNUMs, but an implementation may very well haveother numbers that are FIXNUMs too.  People still seem to think thatFIXNUM declarations are useful and can be used portably.  Thisproposal is just saying that at least a certain subset of ARRAYs areguaranteed to be SIMPLE-ARRAYs, but that an implementation ispermitted to have other things be SIMPLE-ARRAYs too.The only thing that might be broken is if somebody is depending on anarray being of type (AND ARRAY (NOT SIMPLE-ARRAY)).  But myunderstanding is that, in current practice, this usage is already notportable.  I think that's justification enough for this aspect of theproposal, although of course it has to be weighed against theadvantages of tightening the definition of SIMPLE-ARRAY.> [In fact, I > supported Kent's long-lost proposal that called for ADJUST-ARRAY to work> like DELETE, returning a copy when it couldn't alter the array "in> place".  I had hoped that the :adjustable option to MAKE-ARRAY would> thus acquire the meaning "adjustable in place".]That is pretty much what the current proposal says for the behavior ofADJUST-ARRAY, especially if the change I suggested (to disallow bashingof the original array unless the return value is EQ to it) is adopted.Incidentally, this also points out our motivation for wantingADJUSTABLE-ARRAY-P removed entirely.  There isn't a correspondingpredicate to test whether DELETE would return a copy or alter thearray "in place", and people have been getting along without it justfine.-Sandra-------*start*02915 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 21-Jun-89 15:20:47 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 15:20:50 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 21 Jun 89  15:06:32 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 614524; 21 Jun 89 13:01:57 EDTDate: Wed, 21 Jun 89 13:02 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: Jon L White <jonl@lucid.com>cc: X3J13@sail.stanford.eduIn-Reply-To: <8906210535.AA04536@bhopal>Message-ID: <19890621170228.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 20 Jun 89 22:35:42 PDT    From: Jon L White <jonl@lucid.com>    ....turns out to be a proposal that removes the portability of    the type SIMPLE-ARRAY.  Haven't we been over and over and over this already?  No portability isremoved.    ....Since it is so critically important for stock hardware implementations     to have some way to DECLARE implementational properties about subclasses     of arrays, in order to do optimizations on AREF etc based on the morphology    of the object, then I doubt that any such vendor will give up use of the     type SIMPLE-ARRAY....There is nothing in the proposal that would require, encourage, orsuggest any vendor to do any such thing.  None of us want to remove thatcapability from stock hardware implementations.  I think you are simplymisreading what the proposal says.  We spent an enormous amount of timein private discussions making sure that the proposal would not do whatyou are accusing it of doing.  Please read the proposal again with anopen mind, not biased by earlier versions of the proposal.    Rather, the consequence of this proposal is merely to make that very     common, standard practice be "non standard" -- that is, it is no longer     guaranteed that programs which depend on the type SIMPLE-ARRAY will work     the same when moved from one implementation to another.  Note: this *isn't*     saying that all such programs will break -- only that some reasonable ones    will either break or work differently.  Consider for example the trivial:	  (typep (make-array 5 :adjustable t) 'simple-array)    If I read the proposal correctly, it would explicitly permit this    to return true, instead of false.That is correct.  How does that break any program?  How does that forceany vendor to change their implementation?  I do not believe that thereis any program that works in any implementation that will stop workingin that implementation as a result of this proposal.  I think if youread carefully what the proposal actually says, not biased by earlierversions of the proposal, you will agree with me in that conclusion.*start*03088 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 22-Jun-89 15:36:45 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 JUN 89 15:36:37 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 22 Jun 89  15:24:41 PDTReceived: from bhopal ([192.43.178.13]) by heavens-gate id AA07823g; Thu, 22 Jun 89 15:22:43 PDTReceived: by bhopal id AA08358g; Thu, 22 Jun 89 15:24:58 PDTDate: Thu, 22 Jun 89 15:24:58 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8906222224.AA08358@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: X3J13@sail.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 21 Jun 89 13:02 EDT <19890621170228.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)re: Haven't we been over and over and over this already?  No portability is    removed.    . . .         Consider for example the trivial:	      (typep (make-array 5 :adjustable t) 'simple-array)	If I read the proposal correctly, it would explicitly permit this	to return true, instead of false.    That is correct.  How does that break any program?  How does that force    any vendor to change their implementation?  I do not believe that there    is any program that works in any implementation that will stop working    in that implementation as a result of this proposal.  I think if you    read carefully what the proposal actually says, not biased by earlier    versions of the proposal, you will agree with me in that conclusion.Let's review the ground rules on what one means by "non-portable" and"break".  If FOO is a primitive specified in the language, and X refersto some data object calculated by a program, the one would expect(FOO X) to evaluate the same on two different implementations.  The"same" for type predicates simply means that either both implementationsreturn true, or both return false.The program:    (typep (make-array 5 :adjustable t) 'simple-array)"breaks" under this proposal -- it doesn't "break" under the definitionfound on CLtL p.28.By contrast  -- just to show that this isn't a trivial, inconsequentialfeature, the two programs:      (typep (int-char 100)  'number)      (typep (char-int #\A)  'character)don't break under CLtL definitions, and aren't (yet!) broken by anyX3J13 proposals.Programmers who add declarations to their programs will frequentlyadd  runtime type discriminations, expecting different consequences.Your reasoning that no "conformal" programs are broken is based onthe preassumption that there are no portability guarantees forthe type SIMPLE-ARRAY.  I do not grant that presumption.  This isa change -- even if the primary programmatic effect is seen onlywhen one calls TYPEP.  Of course, it has no effect whatsoever onthose who do not port their code form one so-called "conforming" implementation to another so-called "conforming" implementation; but from those who do such porting, we have heard numerous complaints on precisely such variation.-- JonL --*start*03770 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 22-Jun-89 16:14:13 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 JUN 89 16:12:14 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 22 Jun 89  16:00:30 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 615657; 22 Jun 89 19:01:43 EDTDate: Thu, 22 Jun 89 19:01 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: jonl@lucid.comcc: Moon@STONY-BROOK.SCRC.Symbolics.COM, X3J13@sail.stanford.eduIn-Reply-To: <8906222224.AA08358@bhopal>Message-ID: <19890622230138.5.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Thu, 22 Jun 89 15:24:58 PDT    From: Jon L White <jonl@lucid.com>    ... Let's review the ground rules on what one means by "non-portable" and    "break".  If FOO is a primitive specified in the language, and X refers    to some data object calculated by a program, the one would expect    (FOO X) to evaluate the same on two different implementations.  The    "same" for type predicates simply means that either both implementations    return true, or both return false.No, wrong on two points.For example, (DEFUN FOO (X) "Determines if FOO is a fixnum." (TYPEP X 'FIXNUM))might be portable, and yet might yield a different result on differentimplementations.Furthermore, you are not using the working definition of portable for CLtLprogrammers.It is not the case that simply having an expectation that conforms with CLtLand writing a program which is true to that expectation makes the programportable.  Right now, a program is portable only if it runs in allimplementations which claim to be conforming.CLtL is at best legitimately ambiguous on the point in question. There aretwo valid interpretations which conforming processors can use.  Lucid haschosen one, Symbolics the other.  A portable program is one that does notget into the gray area.  Programs are non-portable if they do the kinds ofthings you suggest.For example, it is currently (under CLtL) conforming for (SUBTYPEP X anything)to always return NIL,NIL.  As such, any program which ever seriously expects SUBTYPEP to return T is not portable because there might be a conformingimplementation that violates this assumption.Conforming doesn't imply portable, nor does portable imply conforming.It is probably conforming to declare your program SIMPLE-ARRAY.It just happens not to be portably meaningful. As such, this is notan incompatible change.As precedent, I cite the fact that Steele made a similar remark about unbounddeclarations. e.g., (LOCALLY (DECLARE (FIXNUM X)) (+ X 3)). His claim wasthat this was conforming to CLtL because CLtL permitted it but meaninglessbecause CLtL did not define its meaning.  When we did this issue, I thinkwe called it a clarification because no one claimed that it would breakportable code.  But it could have broken conforming code, because some codemight have done it already, and it might have changed the effect of that conforming code, even though the user had no reason to expect any particularresult from such conforming code.I have tried to use the terminology CLARIFICATION/CHANGE in cleanupissues I've written in which the issue is a CLARIFICATION from the pointof view of portable programs, but the issue infringes on conformingextensions which particular implementations (such as yours) might havemade.  I think you can make a case that this issue causes yourimplementation some grief, but I don't think you can make the claim thatthis issue causes a problem for portable programs.*start*04506 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 22-Jun-89 16:33:18 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 JUN 89 16:31:53 PDTReceived: from Think.COM (Gateway.Think.COM) by SAIL.Stanford.EDU with TCP; 22 Jun 89  16:20:24 PDTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Thu, 22 Jun 89 19:20:33 EDTDate: Thu, 22 Jun 89 19:18 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 10)To: Jon L White <jonl@lucid.com>Cc: Moon@stony-brook.scrc.symbolics.com, X3J13@sail.stanford.eduIn-Reply-To: <8906222224.AA08358@bhopal>Message-Id: <19890622231840.7.BARMAR@OCCAM.THINK.COM>    Date: Thu, 22 Jun 89 15:24:58 PDT    From: Jon L White <jonl@lucid.com>    Let's review the ground rules on what one means by "non-portable" and    "break".  If FOO is a primitive specified in the language, and X refers    to some data object calculated by a program, the one would expect    (FOO X) to evaluate the same on two different implementations.  The    "same" for type predicates simply means that either both implementations    return true, or both return false.    The program:	(typep (make-array 5 :adjustable t) 'simple-array)    "breaks" under this proposal -- it doesn't "break" under the definition    found on CLtL p.28.By that definition, (typep (expt 2 20) 'fixnum) "breaks".  On a systemwith 16-bit fixnums it returns NIL, but it returns T if fixnums are 32bits.    Programmers who add declarations to their programs will frequently    add  runtime type discriminations, expecting different consequences.    Your reasoning that no "conformal" programs are broken is based on    the preassumption that there are no portability guarantees for    the type SIMPLE-ARRAY.  I do not grant that presumption.  This is    a change -- even if the primary programmatic effect is seen only    when one calls TYPEP.  Of course, it has no effect whatsoever on    those who do not port their code form one so-called "conforming"     implementation to another so-called "conforming" implementation; but     from those who do such porting, we have heard numerous complaints on     precisely such variation.OK, by your definition, the proposal "breaks" SIMPLE-ARRAY.  But whatdifference does it make?Let's think about what types such as SIMPLE-ARRAY and FIXNUM are usefulfor.  They are used when the program knows (either a priori, or bytesting) that it has an object of the implementation-specific data type,so it can include declarations that enable the compiler to generatefaster code.  For instance, one might write:	(if (<= most-negative-fixnum x most-positive-fixnum)	    (locally (declare (fixnum x))	      ...)	    ...)or	(if (typep a 'simple-array)	    (locally (declare (simple-array a))	      <code that doesn't try to set the fill pointer,	       or adjust the array, and which should generate better	       code in implementations that care>	    )	    <code that makes no assumptions, and may run slower>)So, what happens if an implementation defines SIMPLE-ARRAY so that itincludes adjustable arrays?  I say nothing bad.  If the code inside theLOCALLY calls ADJUST-ARRAY, it must (to be portable) use it as	(setq a (adjust-array a ...))(unless it separately checked (adjustable-array-p a)).    Of course, it has no effect whatsoever on    those who do not port their code form one so-called "conforming"     implementation to another so-called "conforming" implementation; but     from those who do such porting, we have heard numerous complaints on     precisely such variation.JonL, I'm not a member of the group that wrote up the proposal, but Ithink they should be offended by your repeated implications, such as theone quoted above, that they totally ignore the needs of programmersporting applications and of conventional architecture implementations.I believe Pitman was among those who worked on the latest version ofthis proposal, and he is extremely sensitive to such needs; he has beeninvolved in Macsyma porting for years, recently porting it to CLOE,which is heavily dependent on declarations for performance.  And Gabrielwas also listed among the framers of this proposal, presumablyrepresenting Lucid's interests.  So let's keep the discussion technical,without the mud-slinging.                                                barmar*start*12494 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 23-Jun-89 11:09:16 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 JUN 89 11:09:13 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 23 Jun 89  10:49:01 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 616029; 23 Jun 89 13:50:43 EDTDate: Fri, 23 Jun 89 13:49 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ADJUST-ARRAY-NOT-ADJUSTABLE (version 11)To: X3J13@sail.stanford.eduMessage-ID: <19890623174903.2.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>Version 5 of this proposal passed with amendments at the January1989 X3J13 meeting.  However, the amendments were found to resultin an inconsistent proposal, and it was also pointed out that somerelated problems with simple-arrays were not addressed.  Since thenthere has been a great deal of private discussion, and review ofvarious versions of the proposal including ones earlier than 5.The result is this proposal, which is believed to be acceptable toeveryone and is being offered for a vote in June to replace theJanuary version that was already voted in.This version has been amended based on last minute discussion: thestatement that ADJUST-ARRAY, when it copies, can destroy the original hasbeen removed.  A remark about VECTOR-PUSH-EXTEND has been added.  Thesechanges are in points 4 and f.  In the discussion section I mentionedsuggestions to get rid of ADJUSTABLE-ARRAY-P.Issue:        ADJUST-ARRAY-NOT-ADJUSTABLEReferences:   ADJUST-ARRAY (p297), ADJUSTABLE-ARRAY-P (p293),              MAKE-ARRAY (pp286-289), simple arrays (p28, 289),              simple strings with fill pointers (p299),              VECTOR-PUSH-EXTEND (p296)Category:     CLARIFICATION and CHANGEEdit history: 22-Apr-87, Version 1 by Pitman              15-Nov-88, Versions 2a,2b,2c by Pitman              02-Dec-88, Version 3 by Pitman              11-Jan-89, Version 4 by Pitman              16-Jan-89, Version 5, by Gabriel.  Amended at the meeting to shorten.              23-Jan-89, Version 6, by Moon.  Shorten without the bug introduced                        by the amendment, add clarification of SIMPLE-ARRAY type.              15-Feb-89, Version 7, by Pitman. Minor changes per comments from                        RPG and Dalton.              11-Mar-89, Version 8, by Pitman. Change category, add endorsements.              17-Mar-89, Version 9, by Moon, fix wording and examples to make it                        clear that the semantics of simple-array is unchanged.               6-Jun-89, Version 10, by Moon and Gabriel, do over.              23-Jun-89, Version 11, by Moon, two little correctionsProblem Description:  There are a number of unclear passages in CLtL related to simple arrays  and adjustable arrays.  There is disagreement on precisely how these  passages are to be interpreted, and no one is happy with the fact that  ADJUST-ARRAY works only on an implementation-dependent subset of arrays.  The description of the :ADJUSTABLE option to MAKE-ARRAY on p288 says that  ``the argument, if specified and not NIL, indicates that it must be  possible to alter the array's size dynamically after it is created. This  argument defaults to NIL.''  The description of the :ADJUSTABLE option  does not say what MAKE-ARRAY will do if the argument is unsupplied or  explicitly NIL.  The description of ADJUSTABLE-ARRAY-P on p293 says that it is true ``if  the argument (which must be an array) is adjustable, and otherwise  false.'' However, the description of MAKE-ARRAY makes it clear that this  is not necessarily the same as asking if the array was created with  :ADJUSTABLE T.  If ADJUSTABLE-ARRAY-P returns NIL, you know that  :ADJUSTABLE NIL was supplied (or no :ADJUSTABLE option was supplied), but  if ADJUSTABLE-ARRAY-P returns T, then there is no information about  whether :ADJUSTABLE was used.  The description of ADJUST-ARRAY on pp297-298 says that it is ``not  permitted to call ADJUST-ARRAY on an array that was not created with the  :ADJUSTABLE option.'' This is inconsistent with ADJUSTABLE-ARRAY-P.  The definition of SIMPLE-ARRAY on p.28 says ``an array that is not  displaced to another array, has no fill pointer, and is not to have its  size adjusted dynamically after creation is called a simple array.''  It is left unclear whether this is an implication or an equivalence,  i.e. whether there can be other simple arrays as well.  CLtL p.299 appears to refer to simple strings with fill pointers,  suggesting that it is an implication, but similar language is used for  equivalences in other parts of CLtL.Proposal (ADJUST-ARRAY-NOT-ADJUSTABLE:IMPLICIT-COPY)  1. If MAKE-ARRAY is called with the :ADJUSTABLE, :FILL-POINTER,   and :DISPLACED-TO arguments each either unspecified or false, the  resulting array is a simple array.  (This just repeats what CLtL  says on page 289, it's here to aid in understanding the next point.)        2. If MAKE-ARRAY is called with one or more of the :ADJUSTABLE,  :FILL-POINTER, or :DISPLACED-TO arguments true, whether the  resulting array is simple is unspecified.  3. It is permitted to call ADJUST-ARRAY on any array.  (Remove the  restriction documented at the bottom of p.297.)  4. If ADJUST-ARRAY is applied to an array created with :ADJUSTABLE true,  the array returned is EQ to its first argument.  It is not specified  whether ADJUST-ARRAY returns an array EQ to its first argument for any  other arrays.  If the array returned by ADJUST-ARRAY is not EQ to its  first argument, the original array is unchanged and does not share  storage with the new array.  5. The predicate ADJUSTABLE-ARRAY-P is true if and only if ADJUST-ARRAY  will return a value EQ to this array when given this array as its first  argument.Clarifications and Logical Consequences:  a. There is no specified way to create an array for which ADJUSTABLE-ARRAY-P     definitely returns NIL.  b. There is no specified way to create an array that is non-simple.  c. The definition of SIMPLE-ARRAY on p.28 is taken to be an implication,     not an equivalence.  This is either a clarification or a change depending     on one's prior reading of that definition.  d. The meaning of ADJUSTABLE-ARRAY-P is changed.  e. As with such functions as DELETE and NCONC, textbooks should     instruct programmers to be careful to receive the value returned by     ADJUST-ARRAY, as it might not be EQ to the first argument.  f. VECTOR-PUSH-EXTEND still signals an error if given a non-adjustable     array.  ADJUST-ARRAY's new feature of making a copy cannot be used     by VECTOR-PUSH-EXTEND, since there is no way to return the copy to     the caller.Rationale:  Points 3 and 4 eliminate the problem of ADJUST-ARRAY only working on a  subset of arrays, by changing it to work on all arrays.  It remains  implementation-dependent whether the array is modified in place or  copied, i.e. whether the result is EQ to the argument, however many other  functions in Common Lisp have similar implementation-dependent behavior.  Implementation-dependent storage allocation or reuse is considered  more benign than implementation-dependent applicability of an operation.  Point 3 recognizes that ADJUST-ARRAY offers features that are offered by  no other function and which are useful in cases involving non-adjustable  arrays (for what amounts to copying).  This change would allow an  expression such as:    (SETQ X (ADJUST-ARRAY X ...))  to work reliably. Those desiring the old behavior could do:    (IF (OR (NOT (ADJUSTABLE-ARRAY-P X))            (NOT (EQUAL (ARRAY-RANK X) (LENGTH NEW-DIMENSIONS))))        (ERROR "Array cannot be adjusted."))    to get the old style error checking.  Point 5 recycles the name ADJUSTABLE-ARRAY-P as a test for whether an  array is adjusted in place or by copying.  Point 2 preserves the raison d'etre of simple arrays, which is to provide  a portable interface to implementation-dependent specialized arrays that  trade decreased functionality for faster access.  A proposed alternative  was to specify a way to create an array that is guaranteed not to be  simple.  This would have made (typep (make-array ...) 'simple-array)  return the same value in all implementations, but would have required  large changes to some implementations and would be of little benefit to  users.  Users need to know that certain arrays are simple, so they can  put in declarations and get higher performance, but users have no need to  be able to create arrays that are definitely non-simple (for lower  performance) or definitely non-adjustable.Examples:  1. The following program is conforming.      (defun double (a)      (adjust-array a (* (length a) 2)))      (double (make-array 30))  2. The following program is conforming.  In no implementation is the  type declaration violated.    (let ((a (make-array 100)))      (declare (simple-array a))      (frob a))  3. The following program is non-conforming.  The consequences of this  program are undefined because the type declaration is violated in some  implementations.    (let ((a (make-array 100 :adjustable t)))      (declare (simple-array a))      (frob a))Current Practice:  Every correct CLtL implementation conforms to points 1 and 2.  It is  unlikely that any implementation currently exists that conforms to points  3, 4, and 5.  Points 3 and 4 involve additions to an implementation to  support the copying form of ADJUST-ARRAY.  Point 5 may involve a change  to ADJUSTABLE-ARRAY-P or may be able to use the existing implementation  of the function.  Symbolics Genera makes :ADJUSTABLE NIL arrays adjustable in most cases,  and ignores adjustability in deciding whether an array is a SIMPLE-ARRAY.  The arrays that are internally simple in Symbolics Genera are a different  subset of arrays from the type SIMPLE-ARRAY, because simplicity in that  implementation depends on the rank and total-size as well as on the  fill-pointer and displacement, thus Genera does not use the type  SIMPLE-ARRAY for anything.  Lucid, IIM, Ibuki, and Symbolics Cloe make :ADJUSTABLE NIL arrays  non-adjustable in all cases, and make every array non-simple that CLTL  does not require to be simple.  Macintosh Allegro Common Lisp v1.2 makes :ADJUSTABLE NIL arrays  non-adjustable in all cases, makes all arrays of rank other than 1  non-simple (violating point 1), and makes every array non-simple that  CLTL does not require to be simple.Cost to Implementors:  The change to ADJUSTABLE-ARRAY-P is easy.  The change to ADJUST-ARRAY may  involve some complex coding but should not be a large task.  No changes  are required to anything connected with SIMPLE-ARRAY.Cost to Users:  None in code that does not call ADJUSTABLE-ARRAY-P.  This is a fully  upward-compatible change from the user's standpoint.Benefits:  Programs that use simple arrays and/or adjust arrays will be easier  to port, as the language specification for these features will be  clearer.  More programs will be able to call ADJUST-ARRAY, as its use  will not be restricted to a subset of arrays.Non-Benefits:  Users who expect adjusting arrays created with :ADJUSTABLE NIL to signal  an error would not get the desired signal.  A few programs might have  porting problems due to variation among implementations of whether the  result of ADJUST-ARRAY is EQ to the first argument.Aesthetics:  Most people believe the status quo is unaesthetic.  Having an aspect of  the language more clearly specified is an aesthetic improvement.  Allowing ADJUST-ARRAY on all arrays is an aesthetic improvement.Discussion:  There are at least 110 messages of discussion preceding this version of the  proposal.  It does not seem feasible to summarize them here.  Dick Gabriel, Dave Moon, and Guy Steele support this proposal.  Some commentors would like to get rid of ADJUSTABLE-ARRAY-P, since  ADJUST-ARRAY now works on all arrays.  Other commentors have said that  ADJUSTABLE-ARRAY-P is still needed in some applications, such as user  written functions that behave like VECTOR-PUSH-EXTEND, and hence should  be kept; the concept of "adjustable array" is still meaningful.