*start*19535 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 MAR 89 20:32:10 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Mar 89  20:31:31 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 551906; Mon 6-Mar-89 23:29:12 ESTDate: Mon, 6 Mar 89 23:29 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ERROR-CHECKING-IN-NUMBERS-CHAPTER (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890306232902.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Well, no one else beat me to it so I finally got around to writing up oneof the several needed proposals on what functions should signal what errors.Let me emphasize that even though this covers a subset of the functions inCLtL, it is still both meaningful and useful to vote on it separately. Ifwe had only proposals for handling of errors in numbers and files/streamsthat would cover a very large class of cases.This being a long proposal, please keep your comments focused. Preferrablyjust requests for specific changes in wording with a brief rationale for thechange. I am not firmly wedded to any of the positions I've taken here --I just felt it necessary to take -some- position.  I patterned this prettydirectly after a document I passed out several meetings ago, but I got verylittle feedback on that document, so I don't know if it was controversial. -kmp----Issue:        ERROR-CHECKING-IN-NUMBERS-CHAPTERForum:        CleanupReferences:   Numbers (pp193-232),	      S:>kmp>cl>conditions>revision-18-notes.text.34	      (formerly S:>kmp>cl-conditions.text.34),Category:     CHANGEEdit history: 06-Mar-89, Version 1 by PitmanStatus:       For Internal DiscussionProblem Description:  In many cases, CLtL specifies ``is an error'' situations for functions  in places that programmers would prefer to see an error signalled.  Reliably signalling an error accomplishes two things...   - It eases the development process by making it easier to notice errors     in a timely fashion.   - It makes it easier for code to reliably handle errors at runtime,     leading to greater robustness in delivered applications.Proposal (ERROR-CHECKING-IN-NUMBERS-CHAPTER:SCARECROW):        - a straw man... ABS should signal TYPE-ERROR if its argument is not type NUMBER. ACOS should signal TYPE-ERROR if its argument is not type NUMBER. ACOS might signal ARITHMETIC-ERROR. ACOSH should signal TYPE-ERROR if its argument is not type NUMBER. ACOSH might signal ARITHMETIC-ERROR. ASH should signal TYPE-ERROR if either argument is not type INTEGER. ASH might signal ARITHMETIC-ERROR. ASIN should signal TYPE-ERROR if its argument is not type NUMBER. ASIN might signal ARITHMETIC-ERROR. ASINH should signal TYPE-ERROR if its argument is not type NUMBER. ASINH might signal ARITHMETIC-ERROR. ATAN should signal TYPE-ERROR if exactly one argument is given and that      argument is not type NUMBER. ATAN should signal TYPE-ERROR if exactly two arguments are given and      either argument is not type (AND NUMBER (NOT COMPLEX)). ATAN might signal ARITHMETIC-ERROR. ATANH should signal TYPE-ERROR if its argument is not type NUMBER. ATANH might signal ARITHMETIC-ERROR. BOOLE should signal TYPE-ERROR if its first argument is not type       (MEMBER #.BOOLE-CLR   #.BOOLE-SET   #.BOOLE-1    #.BOOLE-2	       #.BOOLE-C1    #.BOOLE-C2    #.BOOLE-AND  #.BOOLE-IOR	       #.BOOLE-XOR   #.BOOLE-EQV   #.BOOLE-NAND #.BOOLE-NOR	       #.BOOLE-ANDC1 #.BOOLE-ANDC2 #.BOOLE-ORC1 #.BOOLE-ORC2) BOOLE should signal TYPE-ERROR if either its second or third       argument is not type INTEGER. BYTE should signal TYPE-ERROR if either argument is not type INTEGER. BYTE-POSITION might signal TYPE-ERROR if its argument is not a byte	       specifier (something that was returned by the BYTE	       function). Note that byte specifiers are not required	       to be disjoint from other types, so this error checking	       is only heuristic. BYTE-SIZE might signal TYPE-ERROR if its argument is not a byte	   specifier (something that was returned by the BYTE	   function). Note that byte specifiers are not required	   to be disjoint from other types, so this error checking	   is only heuristic. CEILING should signal TYPE-ERROR if its first argument is not type	 (AND NUMBER (NOT COMPLEX)). CEILING should signal TYPE-ERROR if its second argument is supplied	 but is not type (AND NUMBER (NOT COMPLEX)). CEILING should signal DIVISION-BY-ZERO if its second argument is	 supplied and is zero. CEILING might signal ARITHMETIC-ERROR. COMPLEX should signal TYPE-ERROR if its first argument is not type	 (AND NUMBER (NOT COMPLEX)). COMPLEX should signal TYPE-ERROR if its second argument is provided	 but is not type (AND NUMBER (NOT COMPLEX)). CONJUGATE should signal TYPE-ERROR if its argument is not type NUMBER. CIS should signal TYPE-ERROR if its argument is not type     (AND NUMBERP (NOT COMPLEX)). CIS might signal ARITHMETIC-ERROR. COS should signal TYPE-ERROR if its argument is not type NUMBER. COS might signal ARITHMETIC-ERROR. COSH should signal TYPE-ERROR if its argument is not type NUMBER. COSH might signal ARITHMETIC-ERROR. DECF might signal SYNTAX-ERROR at semantic processing time. DECF should signal TYPE-ERROR at runtime if the variable to be      incremented does not have a value of type NUMBER. DECF might signal ARITHMETIC-ERROR at runtime. DECODE-FLOAT should signal TYPE-ERROR if its argument is not type FLOAT. DENOMINATOR should signal TYPE-ERROR if its argument is not type RATIONAL. DEPOSIT-FIELD should signal TYPE-ERROR if its first argument is not type	       INTEGER. DEPOSIT-FIELD might signal TYPE-ERROR if its second argument is not a	       bytespec (something returned by BYTE). Note that byte	       specifiers are not required to be disjoint from other types,	       so this error checking is only heuristic. DEPOSIT-FIELD should signal TYPE-ERROR if its third argument is not type	       INTEGER. DPB should signal TYPE-ERROR if its first argument is not type INTEGER. DPB might signal TYPE-ERROR if its second argument is not a bytespec     (something returned by BYTE). Note that byte specifiers are not     required to be disjoint from other types, so this error checking     is only heuristic. DPB should signal TYPE-ERROR if its third argument is not type INTEGER. EVENP should signal TYPE-ERROR if its argument is not type INTEGER. FCEILING should signal TYPE-ERROR if its first argument is not type	  (AND NUMBER (NOT COMPLEX)). FCEILING should signal TYPE-ERROR if its second argument is supplied	  but is not type (AND NUMBER (NOT COMPLEX)). FCEILING should signal DIVISION-BY-ZERO if its second argument is	  supplied and is zero. FCEILING might signal ARITHMETIC-ERROR. FFLOOR should signal TYPE-ERROR if its first argument is not type	(AND NUMBER (NOT COMPLEX)). FFLOOR should signal TYPE-ERROR if its second argument is supplied	but is not type (AND NUMBER (NOT COMPLEX)). FFLOOR should signal DIVISION-BY-ZERO if its second argument is	supplied and is zero. FFLOOR might signal ARITHMETIC-ERROR. FLOOR should signal TYPE-ERROR if its first argument is not type       (AND NUMBER (NOT COMPLEX)). FLOOR should signal TYPE-ERROR if its second argument is supplied       but is not type (AND NUMBER (NOT COMPLEX)). FLOOR should signal DIVISION-BY-ZERO if its second argument is       supplied and is zero. FLOOR might signal ARITHMETIC-ERROR. FROUND should signal TYPE-ERROR if its first argument is not type	(AND NUMBER (NOT COMPLEX)). FROUND should signal TYPE-ERROR if its second argument is supplied	but is not type (AND NUMBER (NOT COMPLEX)). FROUND should signal DIVISION-BY-ZERO if its second argument is	supplied and is zero. FROUND might signal ARITHMETIC-ERROR. FTRUNCATE should signal TYPE-ERROR if its first argument is not type	   (AND NUMBER (NOT COMPLEX)). FTRUNCATE should signal TYPE-ERROR if its second argument is supplied	   but is not type (AND NUMBER (NOT COMPLEX)). FTRUNCATE should signal DIVISION-BY-ZERO if its second argument is	   supplied and is zero. FTRUNCATE might signal ARITHMETIC-ERROR. GCD should signal TYPE-ERROR if any argument is not type INTEGER. GCD might signal ARITHMETIC-ERROR. EXP should signal TYPE-ERROR if its argument is not type NUMBER. EXP might signal ARITHMETIC-ERROR. EXPT should signal TYPE-ERROR if either argument is not type NUMBER. EXPT might signal ARITHMETIC-ERROR. e.g., (EXPT 0 0.0) FLOAT should signal TYPE-ERROR if its first argument is not type       (AND NUMBER (NOT COMPLEX)). FLOAT should signal TYPE-ERROR if its second argument is supplied       but is not type FLOAT. FLOAT might signal ARITHMETIC-ERROR. FLOAT-DIGITS should signal TYPE-ERROR if its argument is not type FLOAT. FLOAT-PRECISION should signal TYPE-ERROR if its argument is not type FLOAT. FLOAT-RADIX should signal TYPE-ERROR if its argument is not type FLOAT. FLOAT-SIGN should signal TYPE-ERROR if its first argument is not type	    FLOAT. FLOAT-SIGN should signal TYPE-ERROR if its second argument is supplied	    but is not type FLOAT. INCF might signal SYNTAX-ERROR at semantic processing time. INCF should signal TYPE-ERROR at runtime if the variable to be      incremented does not have a value of type NUMBER. INCF might signal ARITHMETIC-ERROR at runtime. INTEGER-DECODE-FLOAT should signal TYPE-ERROR if its argument is not		      type FLOAT. INTEGER-LENGTH should signal TYPE-ERROR if its argument is not type INTEGER. IMAGPART should signal TYPE-ERROR if its argument is not type NUMBER. ISQRT should signal TYPE-ERROR if its argument is not type (INTEGER 0). ISQRT might signal ARITHMETIC-ERROR. LCM should signal TYPE-ERROR if any argument is not type INTEGER. LCM might signal ARITHMETIC-ERROR. LDB might signal TYPE-ERROR if its first argument is not a bytespec     (something returned by BYTE). Note that byte specifiers are not     required to be disjoint from other types, so this error checking     is only heuristic. LDB should signal TYPE-ERROR if its second argument is not type INTEGER. LDB-TEST might signal TYPE-ERROR if its first argument is not a bytespec	  (something returned by BYTE). Note that byte specifiers are not	  required to be disjoint from other types, so this error checking	  is only heuristic. LDB-TEST should signal TYPE-ERROR if its second argument is not type INTEGER. LOG should signal TYPE-ERROR if either argument is not type NUMBER. LOG might signal ARITHMETIC-ERROR. LOGAND should signal TYPE-ERROR if any argument is not type INTEGER. LOGANDC1 should signal TYPE-ERROR if either argument is not type INTEGER. LOGANDC2 should signal TYPE-ERROR if either argument is not type INTEGER. LOGBITP should signal TYPE-ERROR if its first argument is not type	 (INTEGER 0). LOGBITP should signal TYPE-ERROR if its second argument is not type	 INTEGER. LOGCOUNT should signal TYPE-ERROR error if its argument is not type INTEGER. LOGEQV should signal TYPE-ERROR if any argument is not type INTEGER. LOGIOR should signal TYPE-ERROR if any argument is not type INTEGER. LOGNAND should signal TYPE-ERROR if either argument is not type INTEGER. LOGNOR should signal TYPE-ERROR if either argument is not type INTEGER. LOGNOT should signal TYPE-ERROR error if its argument is not type INTEGER. LOGORC1 should signal TYPE-ERROR if either argument is not type INTEGER. LOGORC2 should signal TYPE-ERROR if either argument is not type INTEGER. LOGTEST should signal TYPE-ERROR if either argument is not type INTEGER. LOGXOR should signal TYPE-ERROR if any argument is not type INTEGER. MAKE-RANDOM-STATE should signal TYPE-ERROR if an argument is supplied 		   but is not type (OR (MEMBER NIL T) RANDOM-STATE). MASK-FIELD might signal TYPE-ERROR if its first argument is not a bytespec	    (something returned by BYTE). Note that byte specifiers are not	    required to be disjoint from other types, so this error checking	    is only heuristic. MASK-FIELD should signal TYPE-ERROR if its second argument is not type	    INTEGER. MAX should signal TYPE-ERROR if any argument is not type     (AND NUMBERP (NOT COMPLEX)). MAX might signal ARITHMETIC-ERROR. MIN should signal TYPE-ERROR if any argument is not type     (AND NUMBERP (NOT COMPLEX)). MIN might signal ARITHMETIC-ERROR. MINUSP should signal TYPE-ERROR if its argument is not type	(AND NUMBER (NOT COMPLEX)). MOD should signal TYPE-ERROR if its first argument is not type     (AND NUMBER (NOT COMPLEX)). MOD should signal TYPE-ERROR if its second argument is supplied     but is not type (AND NUMBER (NOT COMPLEX)). MOD should signal DIVISION-BY-ZERO if its second argument is     supplied and is zero. MOD might signal ARITHMETIC-ERROR. NUMERATOR should signal TYPE-ERROR if its argument is not type RATIONAL. ODDP should signal TYPE-ERROR if its argument is not type INTEGER. PHASE should signal TYPE-ERROR if its argument is not type NUMBER. PHASE might signal ARITHMETIC-ERROR. PLUSP should signal TYPE-ERROR if its argument is not type       (AND NUMBER (NOT COMPLEX)). RANDOM should signal TYPE-ERROR if its first argument is not	type (INTEGER 1). RANDOM should signal TYPE-ERROR if its second argument is supplied	but is not type RANDOM-STATE. RANDOM-STATE-P will never signal an error. RATIONAL should signal TYPE-ERROR if its argument is not type	  (AND NUMBER (NOT COMPLEX)). RATIONAL might signal ARITHMETIC-ERROR. RATIONALIZE should signal TYPE-ERROR if its argument is not type	     (AND NUMBER (NOT COMPLEX)). RATIONALIZE might signal ARITHMETIC-ERROR. REALPART should signal TYPE-ERROR if its argument is not type NUMBER. REM should signal TYPE-ERROR if its first argument is not type     (AND NUMBER (NOT COMPLEX)). REM should signal TYPE-ERROR if its second argument is supplied     but is not type (AND NUMBER (NOT COMPLEX)). REM should signal DIVISION-BY-ZERO if its second argument is     supplied and is zero. REM might signal ARITHMETIC-ERROR. ROUND should signal TYPE-ERROR if its first argument is not type       (AND NUMBER (NOT COMPLEX)). ROUND should signal TYPE-ERROR if its second argument is supplied       but is not type (AND NUMBER (NOT COMPLEX)). ROUND should signal DIVISION-BY-ZERO if its second argument is       supplied and is zero. ROUND might signal ARITHMETIC-ERROR. SCALE-FLOAT should signal TYPE-ERROR if its first argument is not	     type FLOAT. SCALE-FLOAT should signal TYPE-ERROR if its second argument is not	     type INTEGER. SIGNUM should signal TYPE-ERROR if its argument is not type NUMBER. SIN should signal TYPE-ERROR if its argument is not type NUMBER. SIN might signal ARITHMETIC-ERROR. SINH should signal TYPE-ERROR if its argument is not type NUMBER. SINH might signal ARITHMETIC-ERROR. SQRT should signal TYPE-ERROR if its argument is not type NUMBER. SQRT might signal ARITHMETIC-ERROR. TAN should signal TYPE-ERROR if its argument is not type NUMBER. TAN might signal ARITHMETIC-ERROR. TANH should signal TYPE-ERROR if its argument is not type NUMBER. TANH might signal ARITHMETIC-ERROR. TRUNCATE should signal TYPE-ERROR if its first argument is not type	  (AND NUMBER (NOT COMPLEX)). TRUNCATE should signal TYPE-ERROR if its second argument is supplied	  but is not type (AND NUMBER (NOT COMPLEX)). TRUNCATE should signal DIVISION-BY-ZERO if its second argument is	  supplied and is zero. TRUNCATE might signal ARITHMETIC-ERROR. ZEROP should signal TYPE-ERROR if its argument is not type NUMBER. * should signal TYPE-ERROR if any argument is not type NUMBER. * might signal ARITHMETIC-ERROR. + should signal TYPE-ERROR if any argument is not type NUMBER. + might signal ARITHMETIC-ERROR. - should signal TYPE-ERROR if any argument is not type NUMBER. - might signal ARITHMETIC-ERROR. / should signal TYPE-ERROR if any argument is not type NUMBER. / should signal DIVISION-BY-ZERO if any divisor argument is zero. / might signal ARITHMETIC-ERROR. /= should signal type-error if any argument is not type NUMBER. /= might signal ARITHMETIC-ERROR. 1+ should signal TYPE-ERROR if any argument is not type NUMBER. 1+ might signal ARITHMETIC-ERROR. 1- should signal TYPE-ERROR if any argument is not type NUMBER. 1- might signal ARITHMETIC-ERROR. < should signal TYPE-ERROR if any argument is not type   (AND NUMBER (NOT COMPLEX)). < might signal ARITHMETIC-ERROR. <= should signal TYPE-ERROR if any argument is not type    (AND NUMBER (NOT COMPLEX)). <= might signal ARITHMETIC-ERROR. = should signal TYPE-ERROR if any argument is not type NUMBER. = might signal ARITHMETIC-ERROR. > should signal TYPE-ERROR if any argument is not type   (AND NUMBER (NOT COMPLEX)). > might signal ARITHMETIC-ERROR. >= should signal TYPE-ERROR if any argument is not type    (AND NUMBER (NOT COMPLEX)). >= might signal ARITHMETIC-ERROR.Rationale:  This addresses the development and delivery concerns mentioned in the  Problem Description.Current Practice:  Most implementations probably do not reliably signal the indicated  errors in safe code.Cost to Implementors:  In implementations not providing the indicated error checking,  considerable work might need to be done.  The alternative is to identify the implementation as an "unsafe" subset.  However, while it is a "subset" in the sense that code that was developed  in it will run in the superset, it is important to understand that such  implementations are not simply "places you can run code that's been  thoroughly debugged in the full language" since such debugged code may  still depend on the reliable detection and handling of certain kinds of  errors.Cost to Users:  Technically none. These are supposedly already all `is an error'  cases that people can't depend on.  Some users might be relying on an implementation not to signal a particular  error in compiled code.  Such code is already not portable, however.  In some cases, where an implementation adds error checking that they  consider unnecessary, the user will need to add some OPTIMIZE proclamations.  Some users will see this as a bug fix.Cost of Non-Adoption:  The error handling facilities will be a lot less useful.  Code that uses error handling will not port well.Benefits:  Better development environments. More robust delivered applications.Aesthetics:  Hopefully improved.Discussion:  Pitman getting this level of detail is a good idea. He's ammenable to  specific changes if they improve the overall level of receptiveness to  the proposal.  Notes about how to proceed on this issue  (to be removed prior to final vote):  - Is anyone uncomfortable about the name ARITHMETIC-ERROR?    If so, can someone mathematically inclined suggest a better name?    `MATH-ERROR' or `NUMBER-ERROR' come to mind.  - In some of the cases of "might signal", it might be the case that    no signal should ever occur. Someone who's actually implemented these    functions might want to suggest that in some cases we can remove    this verbiage, or give examples of the circumstances under which the    condition might be signalled?*start*02005 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 MAR 89 14:46:01 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 10 Mar 89  14:46:24 PSTDate: Fri, 10 Mar 89 14:43:58 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue ERROR-CHECKING-IN-NUMBERS-CHAPTER, v1To: KMP@SCRC-STONY-BROOK.ARPAcc: cl-cleanup@SAIL.STANFORD.EDU, iim@ECLA.USC.EDUMessage-ID: <12476991984.30.IIM@ECLA.USC.EDU>Good work Kent.  A few comments now, with more to follow once I have time toreally look at this.  One thing I'm working on is a function by functioncomparison of your list with what we (IIM) currently do.Many (perhaps almost all) of these could potentially signal STORAGE-CONDITION.However, as a general rule I don't think we should document that possibility.ASH: I can't think of any reason for ASH to signal an ARITHMETIC-ERROR.DECF: might signal SYNTAX-ERROR?  Perhaps this should be PROGRAM-ERROR?GCD: I can't think of any reason for GCD to signal an ARITHMETIC-ERROR.INCF: might signal SYNTAX-ERROR?  Perhaps this should be PROGRAM-ERROR?LCM: I can't think of any reason for LCM to signal an ARITHMETIC-ERROR.MOD: the second argument is required, so drop the "is supplied and" from theDIVISION-BY-ZERO case.REM: the second argument is required, so drop the "is supplied and" from theDIVISION-BY-ZERO case.SCALE-FLOAT: might signal ARITHMETIC-ERROR (fp over/underflow).The possibility of ARITHMETIC-ERROR being signaled in the following functionsmay depend on what kind of error should be associated with operations on fpNaN's, infinities, and such.  MAX, MIN, SQRT, /=, <, <=, =, >, >=, RATIONAL, RATIONALIZEBecause of CONTAGION-ON-NUMERICAL-COMPARISONS:TRANSITIVE, none of MAX, MIN, /=,<, <=, =, >, and >= will signal fp over/underflow, and reduce to the questionof what ARITHMETIC-ERRORs are signaled by RATIONAL.kab-------*start*03581 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 MAR 89 15:29:37 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Mar 89  15:29:21 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 554863; Fri 10-Mar-89 18:26:21 ESTDate: Fri, 10 Mar 89 18:26 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue ERROR-CHECKING-IN-NUMBERS-CHAPTER, v1To: IIM%ECLA.USC.EDU@AI.AI.MIT.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <12476991984.30.IIM@ECLA.USC.EDU>Message-ID: <890310182606.4.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri 10 Mar 89 14:43:58-PST    From: Kim A. Barrett <IIM@ECLA.USC.EDU>    Many (perhaps almost all) of these could potentially signal STORAGE-CONDITION.    However, as a general rule I don't think we should document that possibility.Right. STORAGE-CONDITION is already described as not being an errorexactly because it addresses an implementation failure rather than asemantic error. I think this distinction is important. I think we shoulddeal with this by suggesting to Kathy that she mention somewhere thatfor this reason, no one should interpret any of the Conditions listsin the function descriptions as necessarily complete.  The whole pointof the condition system is to provide flexibility in this regard. If wewere being exhaustive, we might as well return integer error codes asthe n+1st value.    ASH: I can't think of any reason for ASH to signal an ARITHMETIC-ERROR.[Heh,heh... Yeah, normally neither could I. I remember in Macsyma I raninto some implementations where ASH wasn't implemented correctly (due to bugs)and I had to define it in terms of EXPT for some situations.]Ok, I'll remove this. It can still signal it of course. We just won'twaste users' time with expecting it.    DECF: might signal SYNTAX-ERROR?  Perhaps this should be PROGRAM-ERROR?Sorry, you're right.    GCD: I can't think of any reason for GCD to signal an ARITHMETIC-ERROR.Ok.    INCF: might signal SYNTAX-ERROR?  Perhaps this should be PROGRAM-ERROR?Right.    LCM: I can't think of any reason for LCM to signal an ARITHMETIC-ERROR.Ok.    MOD: the second argument is required, so drop the "is supplied and" from the    DIVISION-BY-ZERO case.Ok. Around here, we call that a control-Y error.    REM: the second argument is required, so drop the "is supplied and" from the    DIVISION-BY-ZERO case.Ok.    SCALE-FLOAT: might signal ARITHMETIC-ERROR (fp over/underflow).Ok.    The possibility of ARITHMETIC-ERROR being signaled in the following functions    may depend on what kind of error should be associated with operations on fp    NaN's, infinities, and such.NaN were specifically what I was thinking of. The main objection I was worriedabout was whether anyone thought that that wasn't the right error (e.g., that TYPE-ERROR was more appropriate).      MAX, MIN, SQRT, /=, <, <=, =, >, >=, RATIONAL, RATIONALIZE    Because of CONTAGION-ON-NUMERICAL-COMPARISONS:TRANSITIVE, none of MAX, MIN, /=,    <, <=, =, >, and >= will signal fp over/underflow, and reduce to the question    of what ARITHMETIC-ERRORs are signaled by RATIONAL.It's funny I started with numbers because numbers are not really mystrong point.  Can you (or someone) please translate this into aspecific suggestion? Thanks.*start*01052 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 15:00:11 PSTReceived: from ECLC.USC.EDU by SAIL.Stanford.EDU with TCP; 13 Mar 89  15:00:48 PSTDate: Sun, 12 Mar 89 16:01:13 PSTFrom: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>Subject: Issue ERROR-CHECKING-IN-NUMBERS-CHAPTERTo: kmp@SCRC-STONY-BROOK.ARPAcc: cl-cleanup@SAIL.STANFORD.EDU, iim%ECLA@ECLC.USC.EDUMessage-ID: <12477530332.30.IIM@ECLA.USC.EDU>The question of whether NaNs and such cause TYPE-ERROR or ARITHMETIC-ERROR iswhat I feel unsure about.  We currently signal ARITHMETIC-ERROR, but I don'tbelieve there was a lot of analysis that went into that decision.  I thinkthat any decision we make on this is likely to be pretty arbitrary.  I can'tthink of any strong first-principled arguments either way, so it may be amatter of which seems more convenient to the people who really care aboutan error being signaled for such things.kab-------*start*01473 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 07:19:27 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 07:19:27 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 15 Mar 89  07:19:00 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 15 MAR 89 07:03:16 PSTDate: 15 Mar 89 07:02 PSTFrom: masinter.paSubject: Re: Issue ERROR-CHECKING-IN-NUMBERS-CHAPTERIn-reply-to: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>'s message of Sun, 12 Mar 89 16:01:13 PSTTo: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>cc: kmp@symbolics.com, cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <890315-070316-3648@Xerox>I think NaNs should cause ARITHMETIC-ERROR, since "what's one man's NaN isanother man's number."To put it another way, TYPE-ERROR is generally a sign of a program errorand the cases in which it is signalled should usually not vary fromimplementation to implementation; however, which cases signalARITHMETIC-ERROR can vary depending on the implementation's floating numberrange.Should we define specific conditions to correspond to the IEEE conditionsas subtypes of ARITHMETIC-ERROR?I think that it is important to bring this issue to the X3J13 meeting, evenif it isn't quite ready for vote. If there's a new draft soon, we can have it available for discussion there,and maybe get an "endorse in principle".*start*19195 00024 US Date: 25 Mar 89 22:52 PSTSender: X3J13-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: **DRAFT** Issue: ERROR-CHECKING-IN-NUMBERS-CHAPTER (Version 1)To: X3J13%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: **DRAFT** Issue: ERROR-CHECKING-IN-NUMBERS-CHAPTER (Version 1)To: X3J13@SAIL.Stanford.EDUReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAR 89 22:52:43 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 25 Mar 89  22:38:54 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 565475; Sun 26-Mar-89 01:38:41 ESTOriginal-Date: Sun, 26 Mar 89 01:38 ESTMessage-ID: <890326013810.9.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV	>>> PLEASE DO -NOT- REPLY TO THIS ISSUE <<<It's too late for any discussion, but this is just for the informationof anyone still tracking mail at this late date.  If you have comments,just bring them to the meeting. Thanks. -kmp-----Issue:        ERROR-CHECKING-IN-NUMBERS-CHAPTERForum:        CleanupReferences:   Numbers (pp193-232),	      S:>kmp>cl>conditions>revision-18-notes.text.34	      (formerly S:>kmp>cl-conditions.text.34),Category:     CHANGEEdit history: 06-Mar-89, Version 1 by PitmanStatus:       For Internal DiscussionProblem Description:  In many cases, CLtL specifies ``is an error'' situations for functions  in places that programmers would prefer to see an error signalled.  Reliably signalling an error accomplishes two things...   - It eases the development process by making it easier to notice errors     in a timely fashion.   - It makes it easier for code to reliably handle errors at runtime,     leading to greater robustness in delivered applications.Proposal (ERROR-CHECKING-IN-NUMBERS-CHAPTER:SCARECROW):        - a straw man... ABS should signal TYPE-ERROR if its argument is not type NUMBER. ACOS should signal TYPE-ERROR if its argument is not type NUMBER. ACOS might signal ARITHMETIC-ERROR. ACOSH should signal TYPE-ERROR if its argument is not type NUMBER. ACOSH might signal ARITHMETIC-ERROR. ASH should signal TYPE-ERROR if either argument is not type INTEGER. ASH might signal ARITHMETIC-ERROR. ASIN should signal TYPE-ERROR if its argument is not type NUMBER. ASIN might signal ARITHMETIC-ERROR. ASINH should signal TYPE-ERROR if its argument is not type NUMBER. ASINH might signal ARITHMETIC-ERROR. ATAN should signal TYPE-ERROR if exactly one argument is given and that      argument is not type NUMBER. ATAN should signal TYPE-ERROR if exactly two arguments are given and      either argument is not type (AND NUMBER (NOT COMPLEX)). ATAN might signal ARITHMETIC-ERROR. ATANH should signal TYPE-ERROR if its argument is not type NUMBER. ATANH might signal ARITHMETIC-ERROR. BOOLE should signal TYPE-ERROR if its first argument is not type       (MEMBER #.BOOLE-CLR   #.BOOLE-SET   #.BOOLE-1    #.BOOLE-2	       #.BOOLE-C1    #.BOOLE-C2    #.BOOLE-AND  #.BOOLE-IOR	       #.BOOLE-XOR   #.BOOLE-EQV   #.BOOLE-NAND #.BOOLE-NOR	       #.BOOLE-ANDC1 #.BOOLE-ANDC2 #.BOOLE-ORC1 #.BOOLE-ORC2) BOOLE should signal TYPE-ERROR if either its second or third       argument is not type INTEGER. BYTE should signal TYPE-ERROR if either argument is not type INTEGER. BYTE-POSITION might signal TYPE-ERROR if its argument is not a byte	       specifier (something that was returned by the BYTE	       function). Note that byte specifiers are not required	       to be disjoint from other types, so this error checking	       is only heuristic. BYTE-SIZE might signal TYPE-ERROR if its argument is not a byte	   specifier (something that was returned by the BYTE	   function). Note that byte specifiers are not required	   to be disjoint from other types, so this error checking	   is only heuristic. CEILING should signal TYPE-ERROR if its first argument is not type	 (AND NUMBER (NOT COMPLEX)). CEILING should signal TYPE-ERROR if its second argument is supplied	 but is not type (AND NUMBER (NOT COMPLEX)). CEILING should signal DIVISION-BY-ZERO if its second argument is	 supplied and is zero. CEILING might signal ARITHMETIC-ERROR. COMPLEX should signal TYPE-ERROR if its first argument is not type	 (AND NUMBER (NOT COMPLEX)). COMPLEX should signal TYPE-ERROR if its second argument is provided	 but is not type (AND NUMBER (NOT COMPLEX)). CONJUGATE should signal TYPE-ERROR if its argument is not type NUMBER. CIS should signal TYPE-ERROR if its argument is not type     (AND NUMBERP (NOT COMPLEX)). CIS might signal ARITHMETIC-ERROR. COS should signal TYPE-ERROR if its argument is not type NUMBER. COS might signal ARITHMETIC-ERROR. COSH should signal TYPE-ERROR if its argument is not type NUMBER. COSH might signal ARITHMETIC-ERROR. DECF might signal SYNTAX-ERROR at semantic processing time. DECF should signal TYPE-ERROR at runtime if the variable to be      incremented does not have a value of type NUMBER. DECF might signal ARITHMETIC-ERROR at runtime. DECODE-FLOAT should signal TYPE-ERROR if its argument is not type FLOAT. DENOMINATOR should signal TYPE-ERROR if its argument is not type RATIONAL. DEPOSIT-FIELD should signal TYPE-ERROR if its first argument is not type	       INTEGER. DEPOSIT-FIELD might signal TYPE-ERROR if its second argument is not a	       bytespec (something returned by BYTE). Note that byte	       specifiers are not required to be disjoint from other types,	       so this error checking is only heuristic. DEPOSIT-FIELD should signal TYPE-ERROR if its third argument is not type	       INTEGER. DPB should signal TYPE-ERROR if its first argument is not type INTEGER. DPB might signal TYPE-ERROR if its second argument is not a bytespec     (something returned by BYTE). Note that byte specifiers are not     required to be disjoint from other types, so this error checking     is only heuristic. DPB should signal TYPE-ERROR if its third argument is not type INTEGER. EVENP should signal TYPE-ERROR if its argument is not type INTEGER. FCEILING should signal TYPE-ERROR if its first argument is not type	  (AND NUMBER (NOT COMPLEX)). FCEILING should signal TYPE-ERROR if its second argument is supplied	  but is not type (AND NUMBER (NOT COMPLEX)). FCEILING should signal DIVISION-BY-ZERO if its second argument is	  supplied and is zero. FCEILING might signal ARITHMETIC-ERROR. FFLOOR should signal TYPE-ERROR if its first argument is not type	(AND NUMBER (NOT COMPLEX)). FFLOOR should signal TYPE-ERROR if its second argument is supplied	but is not type (AND NUMBER (NOT COMPLEX)). FFLOOR should signal DIVISION-BY-ZERO if its second argument is	supplied and is zero. FFLOOR might signal ARITHMETIC-ERROR. FLOOR should signal TYPE-ERROR if its first argument is not type       (AND NUMBER (NOT COMPLEX)). FLOOR should signal TYPE-ERROR if its second argument is supplied       but is not type (AND NUMBER (NOT COMPLEX)). FLOOR should signal DIVISION-BY-ZERO if its second argument is       supplied and is zero. FLOOR might signal ARITHMETIC-ERROR. FROUND should signal TYPE-ERROR if its first argument is not type	(AND NUMBER (NOT COMPLEX)). FROUND should signal TYPE-ERROR if its second argument is supplied	but is not type (AND NUMBER (NOT COMPLEX)). FROUND should signal DIVISION-BY-ZERO if its second argument is	supplied and is zero. FROUND might signal ARITHMETIC-ERROR. FTRUNCATE should signal TYPE-ERROR if its first argument is not type	   (AND NUMBER (NOT COMPLEX)). FTRUNCATE should signal TYPE-ERROR if its second argument is supplied	   but is not type (AND NUMBER (NOT COMPLEX)). FTRUNCATE should signal DIVISION-BY-ZERO if its second argument is	   supplied and is zero. FTRUNCATE might signal ARITHMETIC-ERROR. GCD should signal TYPE-ERROR if any argument is not type INTEGER. GCD might signal ARITHMETIC-ERROR. EXP should signal TYPE-ERROR if its argument is not type NUMBER. EXP might signal ARITHMETIC-ERROR. EXPT should signal TYPE-ERROR if either argument is not type NUMBER. EXPT might signal ARITHMETIC-ERROR. e.g., (EXPT 0 0.0) FLOAT should signal TYPE-ERROR if its first argument is not type       (AND NUMBER (NOT COMPLEX)). FLOAT should signal TYPE-ERROR if its second argument is supplied       but is not type FLOAT. FLOAT might signal ARITHMETIC-ERROR. FLOAT-DIGITS should signal TYPE-ERROR if its argument is not type FLOAT. FLOAT-PRECISION should signal TYPE-ERROR if its argument is not type FLOAT. FLOAT-RADIX should signal TYPE-ERROR if its argument is not type FLOAT. FLOAT-SIGN should signal TYPE-ERROR if its first argument is not type	    FLOAT. FLOAT-SIGN should signal TYPE-ERROR if its second argument is supplied	    but is not type FLOAT. INCF might signal SYNTAX-ERROR at semantic processing time. INCF should signal TYPE-ERROR at runtime if the variable to be      incremented does not have a value of type NUMBER. INCF might signal ARITHMETIC-ERROR at runtime. INTEGER-DECODE-FLOAT should signal TYPE-ERROR if its argument is not		      type FLOAT. INTEGER-LENGTH should signal TYPE-ERROR if its argument is not type INTEGER. IMAGPART should signal TYPE-ERROR if its argument is not type NUMBER. ISQRT should signal TYPE-ERROR if its argument is not type (INTEGER 0). ISQRT might signal ARITHMETIC-ERROR. LCM should signal TYPE-ERROR if any argument is not type INTEGER. LCM might signal ARITHMETIC-ERROR. LDB might signal TYPE-ERROR if its first argument is not a bytespec     (something returned by BYTE). Note that byte specifiers are not     required to be disjoint from other types, so this error checking     is only heuristic. LDB should signal TYPE-ERROR if its second argument is not type INTEGER. LDB-TEST might signal TYPE-ERROR if its first argument is not a bytespec	  (something returned by BYTE). Note that byte specifiers are not	  required to be disjoint from other types, so this error checking	  is only heuristic. LDB-TEST should signal TYPE-ERROR if its second argument is not type INTEGER. LOG should signal TYPE-ERROR if either argument is not type NUMBER. LOG might signal ARITHMETIC-ERROR. LOGAND should signal TYPE-ERROR if any argument is not type INTEGER. LOGANDC1 should signal TYPE-ERROR if either argument is not type INTEGER. LOGANDC2 should signal TYPE-ERROR if either argument is not type INTEGER. LOGBITP should signal TYPE-ERROR if its first argument is not type	 (INTEGER 0). LOGBITP should signal TYPE-ERROR if its second argument is not type	 INTEGER. LOGCOUNT should signal TYPE-ERROR error if its argument is not type INTEGER. LOGEQV should signal TYPE-ERROR if any argument is not type INTEGER. LOGIOR should signal TYPE-ERROR if any argument is not type INTEGER. LOGNAND should signal TYPE-ERROR if either argument is not type INTEGER. LOGNOR should signal TYPE-ERROR if either argument is not type INTEGER. LOGNOT should signal TYPE-ERROR error if its argument is not type INTEGER. LOGORC1 should signal TYPE-ERROR if either argument is not type INTEGER. LOGORC2 should signal TYPE-ERROR if either argument is not type INTEGER. LOGTEST should signal TYPE-ERROR if either argument is not type INTEGER. LOGXOR should signal TYPE-ERROR if any argument is not type INTEGER. MAKE-RANDOM-STATE should signal TYPE-ERROR if an argument is supplied 		   but is not type (OR (MEMBER NIL T) RANDOM-STATE). MASK-FIELD might signal TYPE-ERROR if its first argument is not a bytespec	    (something returned by BYTE). Note that byte specifiers are not	    required to be disjoint from other types, so this error checking	    is only heuristic. MASK-FIELD should signal TYPE-ERROR if its second argument is not type	    INTEGER. MAX should signal TYPE-ERROR if any argument is not type     (AND NUMBERP (NOT COMPLEX)). MAX might signal ARITHMETIC-ERROR. MIN should signal TYPE-ERROR if any argument is not type     (AND NUMBERP (NOT COMPLEX)). MIN might signal ARITHMETIC-ERROR. MINUSP should signal TYPE-ERROR if its argument is not type	(AND NUMBER (NOT COMPLEX)). MOD should signal TYPE-ERROR if its first argument is not type     (AND NUMBER (NOT COMPLEX)). MOD should signal TYPE-ERROR if its second argument is supplied     but is not type (AND NUMBER (NOT COMPLEX)). MOD should signal DIVISION-BY-ZERO if its second argument is     supplied and is zero. MOD might signal ARITHMETIC-ERROR. NUMERATOR should signal TYPE-ERROR if its argument is not type RATIONAL. ODDP should signal TYPE-ERROR if its argument is not type INTEGER. PHASE should signal TYPE-ERROR if its argument is not type NUMBER. PHASE might signal ARITHMETIC-ERROR. PLUSP should signal TYPE-ERROR if its argument is not type       (AND NUMBER (NOT COMPLEX)). RANDOM should signal TYPE-ERROR if its first argument is not	type (INTEGER 1). RANDOM should signal TYPE-ERROR if its second argument is supplied	but is not type RANDOM-STATE. RANDOM-STATE-P will never signal an error. RATIONAL should signal TYPE-ERROR if its argument is not type	  (AND NUMBER (NOT COMPLEX)). RATIONAL might signal ARITHMETIC-ERROR. RATIONALIZE should signal TYPE-ERROR if its argument is not type	     (AND NUMBER (NOT COMPLEX)). RATIONALIZE might signal ARITHMETIC-ERROR. REALPART should signal TYPE-ERROR if its argument is not type NUMBER. REM should signal TYPE-ERROR if its first argument is not type     (AND NUMBER (NOT COMPLEX)). REM should signal TYPE-ERROR if its second argument is supplied     but is not type (AND NUMBER (NOT COMPLEX)). REM should signal DIVISION-BY-ZERO if its second argument is     supplied and is zero. REM might signal ARITHMETIC-ERROR. ROUND should signal TYPE-ERROR if its first argument is not type       (AND NUMBER (NOT COMPLEX)). ROUND should signal TYPE-ERROR if its second argument is supplied       but is not type (AND NUMBER (NOT COMPLEX)). ROUND should signal DIVISION-BY-ZERO if its second argument is       supplied and is zero. ROUND might signal ARITHMETIC-ERROR. SCALE-FLOAT should signal TYPE-ERROR if its first argument is not	     type FLOAT. SCALE-FLOAT should signal TYPE-ERROR if its second argument is not	     type INTEGER. SIGNUM should signal TYPE-ERROR if its argument is not type NUMBER. SIN should signal TYPE-ERROR if its argument is not type NUMBER. SIN might signal ARITHMETIC-ERROR. SINH should signal TYPE-ERROR if its argument is not type NUMBER. SINH might signal ARITHMETIC-ERROR. SQRT should signal TYPE-ERROR if its argument is not type NUMBER. SQRT might signal ARITHMETIC-ERROR. TAN should signal TYPE-ERROR if its argument is not type NUMBER. TAN might signal ARITHMETIC-ERROR. TANH should signal TYPE-ERROR if its argument is not type NUMBER. TANH might signal ARITHMETIC-ERROR. TRUNCATE should signal TYPE-ERROR if its first argument is not type	  (AND NUMBER (NOT COMPLEX)). TRUNCATE should signal TYPE-ERROR if its second argument is supplied	  but is not type (AND NUMBER (NOT COMPLEX)). TRUNCATE should signal DIVISION-BY-ZERO if its second argument is	  supplied and is zero. TRUNCATE might signal ARITHMETIC-ERROR. ZEROP should signal TYPE-ERROR if its argument is not type NUMBER. * should signal TYPE-ERROR if any argument is not type NUMBER. * might signal ARITHMETIC-ERROR. + should signal TYPE-ERROR if any argument is not type NUMBER. + might signal ARITHMETIC-ERROR. - should signal TYPE-ERROR if any argument is not type NUMBER. - might signal ARITHMETIC-ERROR. / should signal TYPE-ERROR if any argument is not type NUMBER. / should signal DIVISION-BY-ZERO if any divisor argument is zero. / might signal ARITHMETIC-ERROR. /= should signal type-error if any argument is not type NUMBER. /= might signal ARITHMETIC-ERROR. 1+ should signal TYPE-ERROR if any argument is not type NUMBER. 1+ might signal ARITHMETIC-ERROR. 1- should signal TYPE-ERROR if any argument is not type NUMBER. 1- might signal ARITHMETIC-ERROR. < should signal TYPE-ERROR if any argument is not type   (AND NUMBER (NOT COMPLEX)). < might signal ARITHMETIC-ERROR. <= should signal TYPE-ERROR if any argument is not type    (AND NUMBER (NOT COMPLEX)). <= might signal ARITHMETIC-ERROR. = should signal TYPE-ERROR if any argument is not type NUMBER. = might signal ARITHMETIC-ERROR. > should signal TYPE-ERROR if any argument is not type   (AND NUMBER (NOT COMPLEX)). > might signal ARITHMETIC-ERROR. >= should signal TYPE-ERROR if any argument is not type    (AND NUMBER (NOT COMPLEX)). >= might signal ARITHMETIC-ERROR.Rationale:  This addresses the development and delivery concerns mentioned in the  Problem Description.Current Practice:  Most implementations probably do not reliably signal the indicated  errors in safe code.Cost to Implementors:  In implementations not providing the indicated error checking,  considerable work might need to be done.  The alternative is to identify the implementation as an "unsafe" subset.  However, while it is a "subset" in the sense that code that was developed  in it will run in the superset, it is important to understand that such  implementations are not simply "places you can run code that's been  thoroughly debugged in the full language" since such debugged code may  still depend on the reliable detection and handling of certain kinds of  errors.Cost to Users:  Technically none. These are supposedly already all `is an error'  cases that people can't depend on.  Some users might be relying on an implementation not to signal a particular  error in compiled code.  Such code is already not portable, however.  In some cases, where an implementation adds error checking that they  consider unnecessary, the user will need to add some OPTIMIZE proclamations.  Some users will see this as a bug fix.Cost of Non-Adoption:  The error handling facilities will be a lot less useful.  Code that uses error handling will not port well.Benefits:  Better development environments. More robust delivered applications.Aesthetics:  Hopefully improved.Discussion:  Pitman getting this level of detail is a good idea. He's ammenable to  specific changes if they improve the overall level of receptiveness to  the proposal.  Notes about how to proceed on this issue  (to be removed prior to final vote):  - Is anyone uncomfortable about the name ARITHMETIC-ERROR?    If so, can someone mathematically inclined suggest a better name?    `MATH-ERROR' or `NUMBER-ERROR' come to mind.  - In some of the cases of "might signal", it might be the case that    no signal should ever occur. Someone who's actually implemented these    functions might want to suggest that in some cases we can remove    this verbiage, or give examples of the circumstances under which the    condition might be signalled? *start*02170 00024 US Date:  4 Apr 89 11:23 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: ERROR-CHECKING-IN-NUMBERS-CHAPTERTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ERROR-CHECKING-IN-NUMBERS-CHAPTERTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 11:17:55 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:14:07 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571087; Tue 4-Apr-89 14:13:58 EDTOriginal-Date: Tue, 4 Apr 89 14:13 EDTMessage-ID: <890404141334.6.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes show the following... The major roadblocks were that GZ (and a few others) were hung up on the presentation of ``should signal.'' GZ cited the example of (LOCALLY (DECLARE (OPTIMIZE (SAFETY 0))) #'+). She wanted to know if the resulting function could fail to do error checking. (RPG and KMP will pursue this.) JonL really hated the presentation of the boole arguments using #. RWK said we should definitely do this kind of stuff (error type identification) now if possible, and not wait for the next standard. Walter van Roggen was worried that some of this stuff might be controversial, but I assured him that we would back off to a more vague error type rather than dispute endlessly about controversial cases. He seemed happy with that. Haflich seemed to believe that this was especially important for numbers, so he was happy to see this chapter done. Masinter said that with his implementor's hat on, he thought this was a pain, but that with his user's hat on, he liked it.  He was letting his user side dominate and being very supportive.There was consensus that we should discuss this (and similar proposals) atthe next meeting.