*start*01310 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 MAR 88 13:28:01 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Mar 88  13:25:28 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 357784; Mon 7-Mar-88 16:25:54 ESTDate: Mon, 7 Mar 88 16:25 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EVAL-OTHER (Version 1)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880307155717.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19880307212550.8.MOON@EUPHRATES.SCRC.Symbolics.COM>I favor EVAL-OTHER:SELF-EVALUATE.Under rationale, the sentence beginning "By choosing not to make achange from things being useful to things being useful" is probablya typographical error.I remember this issue being discussed only a few months ago on eitherCommon-Lisp or CL-Cleanup.  I think somebody had some reasons to opposethis proposal, but I don't remember finding them convincing.  Sorry Idon't remember any of the details, I mention it because perhaps thiswill stimulate someone else's memory.*start*03754 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 MAR 88 13:00:36 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Mar 88  12:57:13 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 357740; Mon 7-Mar-88 15:57:37 ESTDate: Mon, 7 Mar 88 15:57 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EVAL-OTHER (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880307155717.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        EVAL-OTHERReferences:   5.1.1 Self-Evaluating Forms (p55)Category:     ADDITION/CLARIFICATIONEdit history: 07-Mar-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  CLtL does not specify what the evaluation behavior of some data types.Proposal (EVAL-OTHER:SELF-EVALUATE):  Standard data types (those mentioned by CLtL) other than those for which  a more explicit evaluation rule exists would be defined to self-evaluate.  Such data types include, for example, structures, arrays, vectors, and  pathnames.  Structure types defined by users using DEFSTRUCT should also self-evaluate  unless an explicit implementation type for the structure is given in the  DEFSTRUCT, in which case the rule for evaluation of that type should be  used. (This is important in the case of type LIST.)Test Case:  (LET ((TEMP (MAKE-PATHNAME)))  (EQ TEMP (EVAL TEMP))) => T  (LET ((TEMP (MAKE-ARRAY NIL))) (EQ TEMP (EVAL TEMP))) => TRationale:  There are numerous possible positions that could be taken, from  requiring that an error be signalled for all of these cases to  requiring that these all have some useful behavior.  By making implementations agree, code portability is enhanced.  By choosing not to make a change from things being useful to things  being useful (i.e., by biasing the decision away from the "signal  an error" end of the choice spectrum), the least interruption is  caused to implementations which already have working code.  There is still some chance that implementations will have some other  behavior than either signalling an error or self-evaluating, but there  are probably few if any.Current Practice:  In many implementations, the other data types besides those mentioned in  CLtL will self-evaluate.Cost to Implementors:  The cost is probably small. This is probably an "upward compatible"  change for most or all implementations -- a few lines of change in the  interpreter and/or compiler. Some code walkers may be affected as well.Cost to Users:  None, if they are not exploiting implementation-dependent features of  some implementation that is being forced to make an incompatible change.  There should be no performance impact since the evaluator's test for these  new data types can simply be made to follow other tests already in place,  so existing code will not be slowed.Cost of Non-Adoption:  Implementations will continue to differ in this relatively  user-visible way.Benefits:  Portability will be enhanced because implementations will tend to agree  in places where they have traditionally not always agreed.Aesthetics:  Some fans of 3LISP may find this invasive to their sense of distinction  between objects and the notation used to describe objects. In general,  however, this is a fairly picky detail that is not likely to trouble the  average programmer.Discussion:  This idea for this proposal was suggested by the Japanese community.  Pitman drafted the formal proposal and supports EVAL-OTHER:SELF-EVALUATE.*start*01273 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 MAR 88 17:22:06 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 7 Mar 88  17:19:34 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Mon 7 Mar 88 20:19:44-ESTDate: Mon, 7 Mar 88 20:19 ESTMessage-ID: <FAHLMAN.12380551338.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: CL-Cleanup@SAIL.STANFORD.EDUSubject: Issue: EVAL-OTHER (Version 1)In-reply-to: Msg of 7 Mar 1988  16:25-EST from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>    I favor EVAL-OTHER:SELF-EVALUATE. -- MoonMe too.  I don't remember any useful discussion of this recently, but Ido remember the original design discussions.  It was proposed thateverything but lists and symbols evaluate to themselves, but at the time(this was quite early in the process) some people felt that this mightclose out interesting parts of the design space that might turn out tobe useful for something.  This hasn't happened, and I think it would bereasonable to close this door now.  Some users do find it confusing thatyou have to quote vectors but not strings.-- Scott*start*01965 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 MAR 88 22:18:59 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 7 Mar 88  22:16:18 PSTReceived: by labrea.Stanford.EDU; Mon, 7 Mar 88 22:16:54 PSTReceived: from bhopal.lucid.com by edsel id AA06092g; Mon, 7 Mar 88 22:04:35 PSTReceived: by bhopal id AA05477g; Mon, 7 Mar 88 22:11:09 PSTDate: Mon, 7 Mar 88 22:11:09 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8803080611.AA05477@bhopal.lucid.com>To: Fahlman@c.cs.cmu.eduCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: "Scott E. Fahlman"'s message of Mon, 7 Mar 1988  20:19 EST <FAHLMAN.12380551338.BABYL@C.CS.CMU.EDU>Subject: Issue: EVAL-OTHER (Version 1)re:  . . . but I    do remember the original design discussions.  It was proposed that    everything but lists and symbols evaluate to themselves, but at the time    (this was quite early in the process) some people felt that this might    close out interesting parts of the design space that might turn out to    be useful for something.  . . . Another way of saying this, and justifying the decision now to be made,is that "Programs are encoded into lists and symbols; other data-types viewed as programs shall be interpreted as constant data".Thus the purpose of QUOTE is so that you can introduce, say, the particulardatum (CAR X) into the program described as  (DEFUN FOO (X) (LIST '(CAR X) '= (CAR X)))  ;who is data, and who is program?Lisp program syntax really hasn't changed much in 20 years.  Note that&OPTIONAL and :TEST-NOT are still symbols -- not some obscure internaldata structure invented for just this case of program syntax.Someone may still want to nit-pick about numbers as tags in a tagbody,but I don't think this is an important problem; it's merely a footnoteas to what a "program" is.-- JonL --*start*03748 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 10:34:17 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Mar 88  10:31:02 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 361116; 11 Mar 88 13:31:02 ESTDate: Fri, 11 Mar 88 13:30 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EVAL-OTHER (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19880307212550.8.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <19880307234416.7.MLY@Bullwinkle.Palladian.COM>,             <8712181940.AA22225@tekchips.TEK.COM>Message-ID: <19880311183058.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Here's the message I was thinking of (thanks, Richard).  By the way,I don't buy Will's argument...I don't think making evaluating afunction or a closure an error will detect a very large fractionof the errors typically made with backquote.  I know it would detectalmost none of the errors I make, which are usually to evaluatesomething at the wrong time rather than to evaluate something thatshould not have been evaluated at any time.  Just some input.Date: Mon, 7 Mar 88 18:44 ESTFrom: Richard Mlynarik <Mly@JASPER.Palladian.COM>    Date: Mon, 7 Mar 88 16:25 EST    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    I remember this issue being discussed only a few months ago on either    Common-Lisp or CL-Cleanup.  I think somebody had some reasons to oppose    this proposal, but I don't remember finding them convincing.  Sorry I    don't remember any of the details, I mention it because perhaps this    will stimulate someone else's memory.To: Fahlman@C.CS.CMU.EDUCc: Moon@SCRC-STONY-BROOK.ARPA, CL-CLEANUP@SAIL.STANFORD.EDU,     willc%tekchips.tek.com@RELAY.CS.NETSubject: whether random objects self-evaluate (was cleaup issues from Japan)In-Reply-To: Your message of Thu, 17 Dec 1987  21:12 EST.	     <FAHLMAN.12359327290.BABYL@C.CS.CMU.EDU>Date: 18 Dec 87 11:40:02 PST (Fri)From: willc%tekchips.tek.com@RELAY.CS.NETLet me report on the Scheme situation and my experience.  As in Common Lisp,it is "an error" to evaluate a random object, but most implementationsextend the language by allowing at least some random objects (notablythe empty list, since only a few implementations yet distinguish the emptylist from #f) to evaluate to themselves.  MacScheme allows all random objectsto evaluate to themselves, but unlike Symbolics I have found this to bea (minor) problem, and I recommend that implementors avoid my mistake.The problem: In writing a macro using backquote I sometimes leave out aquote mark, insert an extra comma, or put a comma in the wrong place.Then an expanded macro can look like     (... #<PROCEDURE> ...)when I wanted it to look like    (... '#<PROCEDURE foo> ...)or    (... (lambda (...) ...) ...).I would like to get an error message from the incremental compiler, becauseI never deliberately write code with unquoted procedures, but withself-evaluating procedures no error will occur until the expression isexecuted, and then the values seen in the debugger can seem very strange.In my code, this kind of macro bug almost always shows up as a procedurethat was closed in the wrong environment, but if I'm unlucky the incorrectprocedure will pass control to an altogether unfamiliar part of the systembefore trapping on some unrelated error such as taking the car of the emptylist.As better macro facilities become more universal, this is of coursebecoming less of a problem.Peace, Will*start*04343 00024 USfDate:  8 Jun 88 18:03 PDTFrom: Masinter.paSubject: Issue: EVAL-OTHER (Version 2)To: X3J13@SAIL.Stanford.EDUreply-to: CL-cleanup@Sail.stanford.educc: MasinterLine-fold: NOI have some notes about some possible additional opposition to this proposal. I hopewe can discuss it at the June X3J13 meeting.Issue:        EVAL-OTHERReferences:   5.1.1 Self-Evaluating Forms (p55)Category:     ADDITION/CLARIFICATIONEdit history: 07-Mar-88, Version 1 by Pitman		   8-Jun-88, Version 2 by Masinter (correct typo, add to discussion)Problem Description:  CLtL does not specify what the evaluation behavior of some data types.Proposal (EVAL-OTHER:SELF-EVALUATE):  Standard data types (those mentioned by CLtL) other than those for which  a more explicit evaluation rule exists would be defined to self-evaluate.  Such data types include, for example, structures, arrays, vectors, and  pathnames.  Structure types defined by users using DEFSTRUCT should also self-evaluate  unless an explicit implementation type for the structure is given in the  DEFSTRUCT, in which case the rule for evaluation of that type should be  used. (This is important in the case of type LIST.)Test Case:  (LET ((TEMP (MAKE-PATHNAME)))  (EQ TEMP (EVAL TEMP))) => T  (LET ((TEMP (MAKE-ARRAY NIL))) (EQ TEMP (EVAL TEMP))) => TRationale:  There are numerous possible positions that could be taken, from  requiring that an error be signalled for all of these cases to  requiring that these all have some useful behavior.  By making implementations agree, code portability is enhanced.  By biasing the decision away from the "signal  an error" end of the choice spectrum, the least interruption is  caused to implementations which already have working code.  There is still some chance that implementations will have some other  behavior than either signalling an error or self-evaluating, but there  are probably few if any.Current Practice:  In many implementations, the other data types besides those mentioned in  CLtL will self-evaluate.Cost to Implementors:  The cost is probably small. This is probably an "upward compatible"  change for most or all implementations -- a few lines of change in the  interpreter and/or compiler. Some code walkers may be affected as well.Cost to Users:  None, if they are not exploiting implementation-dependent features of  some implementation that is being forced to make an incompatible change.  There should be no performance impact since the evaluator's test for these  new data types can simply be made to follow other tests already in place,  so existing code will not be slowed.Cost of Non-Adoption:  Implementations will continue to differ in this relatively  user-visible way.Benefits:  Portability will be enhanced because implementations will tend to agree  in places where they have traditionally not always agreed.Aesthetics:  Some fans of 3LISP may find this invasive to their sense of distinction  between objects and the notation used to describe objects. In general,  however, this is a fairly picky detail that is not likely to trouble the  average programmer.Discussion:This idea for this proposal was suggested by the Japanese community.Pitman drafted the formal proposal and supports EVAL-OTHER:SELF-EVALUATE.Fahlman: "... I do remember the original design discussions.  It wasproposed that everything but lists and symbols evaluate to themselves,but at the time (this was quite early in the process) some people feltthat this might close out interesting parts of the design space thatmight turn out to be useful for something.  This hasn't happened, andI think it would be reasonable to close this door now.  Some users dofind it confusing that you have to quote vectors but not strings."There has been some additional discussion of this proposal (for example,an explaination of why a similar proposal in Scheme might be a bad design.)        TITAN 
         TITAN 
          
TIMESROMAN 
          7                            "                            g              K       %                    |             X              h              Û             V              S       
       ‰              ö                   z zº*start*02985 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 19:34:06 PDTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.Stanford.EDU with TCP; 5 Oct 88  19:34:00 PDTReceived: from DOUGHNUT.CS.ROCHESTER.EDU by ACORN.CS.ROCHESTER.EDU via INTERNET with SMTP id 59502; 5 Oct 88 22:21:29 EDTDate: Wed, 5 Oct 88 22:23 EDTFrom: Brad Miller <miller@ACORN.CS.ROCHESTER.EDU>Subject: Re: Issue: EVAL-OTHER (Version 2)To: common-lisp-object-system@SAIL.STANFORD.EDU, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <881005-152958-1624@Xerox>Message-ID: <19881006022307.0.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Sender: miller@CS.ROCHESTER.EDUReply-To: miller@CS.ROCHESTER.EDUOrganization: University of Rochester, Department of Computer SciencePostal-address: 610 CS Building, Comp Sci Dept., U. Rochester, Rochester NY 14627Phone: 716-275-1118I'd like to propose an alternative (or rather elaboration) toEVAL-OTHER:SELF-EVALUATE,  currently...    Proposal (EVAL-OTHER:SELF-EVALUATE):      Standard data types (those mentioned by CLtL) other than those for which      a more explicit evaluation rule exists would be defined to self-evaluate.      Such data types include, for example, structures, arrays, vectors, and      pathnames.      Structure types defined by users using DEFSTRUCT should also self-evaluate      unless an explicit implementation type for the structure is given in the      DEFSTRUCT, in which case the rule for evaluation of that type should be      used. (This is important in the case of type LIST.)I would suggest that the DEFSTRUCT (or DEFFLAVOR) have an option thatexplicitly specifies the eval behavior.Rational:When using lisp to build an embedded language, one can already define via aDEFSTRUCT option what the printer for the object should be. One can also,via character macros define a specific parse behavior. One cannot, however,currently define an EVAL behavior.  For example, I can define #\[ and #\] todenote the beginning and end of information for consing a structure FOO viacharacter macros which will print the same way.e.g. [A FOO] may really be internally #S(FOO SLOT1: A SLOT2: FOO SLOT3: NIL)what I may want to define is that (cons [A FOO] [B FOO]) return (A B)because the EVAL option on foo returned the value of SLOT1.In general, one could define that instances and structure objects (thelatter are probably instances given CLOS) all handle an EVAL message whichthe user can use to explicitly define the behavior. The default handlerreturns the object itself, which is compatible with theEVAL-OTHER:SELF-EVALUATE proposal already made.Similar arguments to the above can be made for APPLY. The ultimate idea isthat user created objects can be treated as first class objects, just likesymbols.Comments?----Brad Miller		U. Rochester Comp Sci Dept.miller@cs.rochester.edu {...allegra!rochester!miller}*start*01940 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 23:11:51 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 5 Oct 88  23:12:15 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 471537; Thu 6-Oct-88 02:10:54 EDTDate: Thu, 6 Oct 88 02:10 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: EVAL-OTHER (Version 2)To: miller@CS.Rochester.EDUcc: Common-Lisp-Object-System@SAIL.Stanford.EDU, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <19881006022307.0.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Message-ID: <881006021043.8.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Wed, 5 Oct 88 22:23 EDT    From: Brad Miller <miller@ACORN.CS.ROCHESTER.EDU>    ... I would suggest that the DEFSTRUCT (or DEFFLAVOR) have an option that    explicitly specifies the eval behavior. ...The problem to this is that it's the same as allowing fexprs.  This issomething we've worked hard to eliminate from CL because it is opaqueto compilation.You could argue that MACROEXPAND-1 should be a generic function I suppose.I have no strong feeling on that subject right now, but I'm biased againstit because we are very close to casting this stuff in concrete and I don'tfeel totally comfortable that I understand the consequences of doing so.One minor procedural matter: You're more likely to get this considered ifyou write up the proposal in full rather than just as a little fragment.I count 194 cleanup topics that have been raised, and it's getting harderand harder to `maintain' them. Some are destined to fall through the cracksfor lack of time and anything that people have a minor bias against can bevery easily pocket-veto'd if it doesn't come in in a form that we candirectly vote on...*start*03978 00024 USaReturn-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 10:47:12 PDTReceived: from hplms2.hpl.hp.com by SAIL.Stanford.EDU with TCP; 6 Oct 88  10:34:39 PDTReceived: from hplwhh.HPL.HP.COM (hplwhh.hpl.hp.com) by hplms2.hp.com; Thu, 6 Oct 88 10:30:30 pdtReceived: from loopback by hplwhh.HPL.HP.COM; Thu, 6 Oct 88 10:30:06 pdtFull-Name: Warren HarrisTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, miller@CS.Rochester.EDUCc: Common-Lisp-Object-System@SAIL.Stanford.EDU, CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: EVAL-OTHER (Version 2) In-Reply-To: Your message of "Thu, 06 Oct 88 02:10:00 EDT."             <881006021043.8.KMP@BOBOLINK.SCRC.Symbolics.COM> Date: Thu, 06 Oct 88 10:30:02 PDTMessage-Id: <8592.592162202@hplwhh>From: Warren Harris <harris%hplwhh@hplabs.hp.com>I don't know about making EVAL a generic function due to the ramificationsthis has on the compiler, but there are several other places in CL in whichfunctions should be required to be generic. One example might be in the equality area.  Common Lisp seems to have awealth of equality predicates, EQ, EQL, EQUAL, EQUALP, =, STRING=, CHAR=... and you kind of pick and choose based on what you know about theapplication.  It would be nice to have at least one version of equalitywhich did the right thing based on what it was comparing.  Perhaps this isEQUALP.  EQUALP already looks inside both cons cells and arrays, why notextend it to look inside objects too.  I suggest the following definitionof EQUALP:	(defmethod equalp ((x t) (y t))	  (eq x y))        (defmethod equalp ((x character) (y character))	  (char-equal x y))        (defmethod equalp ((x number) (y number))	  (= x y))        (defmethod equalp ((x cons) (y cons))	  (or (eq x y)	      (and (equalp (car x) (car y))		   (equalp (cdr x) (cdr y)))))        (defmethod equalp ((x object) (y object))	  (let ((cx (class-of x))		(cy (class-of y)))	    (or (eq x y)		(and (eq cx cy)		     (every #'(lambda (slotd)				(let ((name (slotd-name slotd)))				  (equalp (slot-value-using-class cx								  x								  name)					  (slot-value-using-class cx								  y								  name))))			    (class-slots cx))))))        (defmethod equalp ((x array) (y array))	  ...)COERCE is another good candidate for being made generic.  Like the printsystem which is required to go through the PRINT-OBJECT method, COERCEcould ultimately invoke a generic layer:	(defun coerce (thing type)	  (case type	    <old coerce code ...>	    (t	     (coerce-object thing (find-class type)))))	(defmethod coerce-object ((thing t) (c class))	  (error "~S cannot be coerced to type ~S."		 thing (class-name c)))This would allow the user to write class specific coercion routines.  Oneobjection has been raised to this proposal by Moon:> But it's meaningful for COERCE's second argument to be a type specifier that> does not name a class.  CLtL gives as an example (vector (complex short-float)).> It would be inconsistent to do some coercions with classes and others through> some other mechanism.  I don't think your idea will work without a larger> recasting of Common Lisp in object-oriented terms.  While that's an interesting> project for investigation, I suspect it would quickly go way beyond the> proper charter of a standardization effort.I think the above code demonstrates how this can indeed work given CL'snon-class type specifiers.  COERCE itself is not required to be generic, itis simplied required to ultimately call COERCE-OBJECT.  This is exactly therequirement placed on PRINT. > One minor procedural matter: You're more likely to get this considered if> you write up the proposal in full rather than just as a little fragment.How do I do this?  How does it look, and who do I send it to?Warren HarrisHP Labs*start*02627 00024 US Date:  8 Oct 88 16:40 PDTFrom: masinter.paSubject: Re: Issue: EVAL-OTHER (Version 2) In-reply-to: Warren Harris <harris%hplwhh@hplabs.hp.com>'s message of Thu, 06 Oct 88 10:30:02 PDTTo: Warren Harris <harris%hplwhh@hplabs.hp.com>cc: miller@CS.Rochester.EDU, masinterThe official procedure for participating in the Common Lisp Standardization effort is through your representitive to the X3J13 committee.Paul Beiser and Jerry Duggan are listed as being from HP and on the attendee list for the X3J13 meeting next week.While we're willing to acce                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                d: NOcc: MasinterI think it is unlikely that the cleanup committee willhave much more to say on the issue.Issue:         EXIT-EXTENTReferences:    CATCH, THROW,               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).               Cleanup issue UNWIND-PROTECT-NON-LOCAL-EXIT is superseded               by this one.Category:      CLARIFICATIONEdit history:  Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvementsProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends.There are three cases of interest:(1) Normal exit from a CATCH, BLOCK, or TAGBODY, or equivalent such asPROG.  A normal exit occurs when the last form in the body of one ofthese constructs completes its evaluation without performing a transferof control.  (According to CLtL p.125, there is no possibility of anormal exit from DO.)(2) Nonlocal exit from the target of a THROW or RETURN.  A nonlocal exitoccurs when control is transferred by THROW, RETURN, or RETURN-FROM.The CATCH or BLOCK named in the THROW, RETURN, or RETURN-FROM isref*start*00871 00024 US Date:  8 Oct 88 16:40 PDTFrom: masinter.paSubject: Re: Issue: EVAL-OTHER (Version 2) In-reply-to: Warren Harris <harris%hplwhh@hplabs.hp.com>'s message of Thu, 06 Oct 88 10:30:02 PDTTo: Warren Harris <harris%hplwhh@hplabs.hp.com>cc: miller@CS.Rochester.EDU, masinterThe official procedure for participating in the Common Lisp Standardization effort is through your representitive to the X3J13 committee.Paul Beiser and Jerry Duggan are listed as being from HP and on the attendee list for the X3J13 meeting next week.While we're willing to accept proposals from the community at large, there's a large amount of work involved in the actual creation of the standard, and a fair amount of context. I'm trying to get stuff together for next week's meeting; I'll probably not be able to get the back mail available until week after next.*start*00905 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:45:47 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:45:57 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475835; Thu 13-Oct-88 16:44:27 EDTDate: Thu, 13 Oct 88 16:44 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: EVAL-OTHER (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013164418.6.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...X3J13 meeting: Haflich thought this made the language less regular and harder to learn. Virtually everyone in the room disagreed pretty strongly. This issue was voted upon and ACCEPTED.*start*01923 00024 UU?Return-Path: <miller@ACORN.CS.ROCHESTER.EDU>Received: from ACORN.CS.ROCHESTER.EDU ([192.5.53.198]) by Xerox.COM ; 10 OCT 88 13:50:51 PDTReceived: from DOUGHNUT.CS.ROCHESTER.EDU by ACORN.CS.ROCHESTER.EDU via CHAOS with CHAOS-MAIL id 59923; Mon 10-Oct-88 16:41:37 EDTDate: Mon, 10 Oct 88 16:41 EDTFrom: Brad Miller <miller@CS.ROCHESTER.EDU>Subject: Re: Issue: EVAL-OTHER (Version 2) To: masinter.pa, common-lisp-object-system@SAIL.STANFORD.EDU, cl-cleanup@SAIL.STANFORD.EDUcc: Warren Harris <harris%hplwhh@HPLABS.HP.COM>In-Reply-To: <881008-164009-2324@Xerox>Message-ID: <19881010204134.1.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Sender: miller@CS.ROCHESTER.EDUReply-To: miller@CS.ROCHESTER.EDUOrganization: University of Rochester, Department of Computer SciencePostal-address: 610 CS Building, Comp Sci Dept., U. Rochester, Rochester NY 14627Phone: 716-275-1118    Date: 8 Oct 88 16:40 PDT    From: masinter.pa@Xerox.COM    The official procedure for participating in the Common Lisp Standardization    effort is through your representitive to the X3J13 committee.    While we're willing to accept proposals from the community at large,    there's a large amount of work involved in the actual creation of the    standard, and a fair amount of context. Well, I guess I'm part of the "community at large" but let me make oneinflammatory comment...w/o generic EVAL or APPLY, CLOS is just a bag on the side of CL. It seems tome the better approach is to make CLOS the language, and "traditional" CLthe subset. I know I would be a lot happier (as a heavy user of CL) thatway. I'd be happy to write this up as a formal proposal if that is what'sneeded, but I don't really know what to do... edit Issue: EVAL-OTHER andmake it version 3, or do something else?Asbestos suit on.----Brad Miller		U. Rochester Comp Sci Dept.miller@cs.rochester.edu {...allegra!rochester!miller}*start*02032 00024 UU?Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 OCT 88 13:53:18 PDTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.Stanford.EDU with TCP; 10 Oct 88  13:52:43 PDTReceived: from DOUGHNUT.CS.ROCHESTER.EDU by ACORN.CS.ROCHESTER.EDU via CHAOS with CHAOS-MAIL id 59923; Mon 10-Oct-88 16:41:37 EDTDate: Mon, 10 Oct 88 16:41 EDTFrom: Brad Miller <miller@CS.ROCHESTER.EDU>Subject: Re: Issue: EVAL-OTHER (Version 2) To: masinter.pa, common-lisp-object-system@SAIL.STANFORD.EDU, cl-cleanup@SAIL.STANFORD.EDUcc: Warren Harris <harris%hplwhh@HPLABS.HP.COM>In-Reply-To: <881008-164009-2324@Xerox>Message-ID: <19881010204134.1.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Sender: miller@CS.ROCHESTER.EDUReply-To: miller@CS.ROCHESTER.EDUOrganization: University of Rochester, Department of Computer SciencePostal-address: 610 CS Building, Comp Sci Dept., U. Rochester, Rochester NY 14627Phone: 716-275-1118    Date: 8 Oct 88 16:40 PDT    From: masinter.pa@Xerox.COM    The official procedure for participating in the Common Lisp Standardization    effort is through your representitive to the X3J13 committee.    While we're willing to accept proposals from the community at large,    there's a large amount of work involved in the actual creation of the    standard, and a fair amount of context. Well, I guess I'm part of the "community at large" but let me make oneinflammatory comment...w/o generic EVAL or APPLY, CLOS is just a bag on the side of CL. It seems tome the better approach is to make CLOS the language, and "traditional" CLthe subset. I know I would be a lot happier (as a heavy user of CL) thatway. I'd be happy to write this up as a formal proposal if that is what'sneeded, but I don't really know what to do... edit Issue: EVAL-OTHER andmake it version 3, or do something else?Asbestos suit on.----Brad Miller		U. Rochester Comp Sci Dept.miller@cs.rochester.edu {...allegra!rochester!miller}*start*02068 00024 UU?Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 OCT 88 14:15:37 PDTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.Stanford.EDU with TCP; 10 Oct 88  13:52:43 PDTReceived: from DOUGHNUT.CS.ROCHESTER.EDU by ACORN.CS.ROCHESTER.EDU via CHAOS with CHAOS-MAIL id 59923; Mon 10-Oct-88 16:41:37 EDTDate: Mon, 10 Oct 88 16:41 EDTFrom: Brad Miller <miller@CS.ROCHESTER.EDU>Subject: Re: Issue: EVAL-OTHER (Version 2) To: masinter.pa, common-lisp-object-system@SAIL.STANFORD.EDU, cl-cleanup@SAIL.STANFORD.EDUcc: Warren Harris <harris%hplwhh@HPLABS.HP.COM>In-Reply-To: <881008-164009-2324@Xerox>Message-ID: <19881010204134.1.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Sender: miller@CS.ROCHESTER.EDUReply-To: miller@CS.ROCHESTER.EDUOrganization: University of Rochester, Department of Computer SciencePostal-address: 610 CS Building, Comp Sci Dept., U. Rochester, Rochester NY 14627Phone: 716-275-1118    Date: 8 Oct 88 16:40 PDT    From: masinter.pa@Xerox.COM    The official procedure for participating in the Common Lisp Standardization    effort is through your representitive to the X3J13 committee.    While we're willing to accept proposals from the community at large,    there's a large amount of work involved in the actual creation of the    standard, and a fair amount of context. Well, I guess I'm part of the "community at large" but let me make oneinflammatory comment...w/o generic EVAL or APPLY, CLOS is just a bag on the side of CL. It seems tome the better approach is to make CLOS the language, and "traditional" CLthe subset. I know I would be a lot happier (as a heavy user of CL) thatway. I'd be happy to write this up as a formal proposal if that is what'sneeded, but I don't really know what to do... edit Issue: EVAL-OTHER andmake it version 3, or do something else?Asbestos suit on.----Brad Miller		U. Rochester Comp Sci Dept.miller@cs.rochester.edu {...allegra!rochester!miller}*start*01472 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 OCT 88 15:11:35 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Oct 88  15:10:23 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 14 OCT 88 14:50:43 PDTDate: 14 Oct 88 14:50 PDTFrom: masinter.paSubject: Re: Issue: EVAL-OTHER (Version 2) In-reply-to: Brad Miller <miller@CS.ROCHESTER.EDU>'s message of Mon, 10 Oct 88 16:41 EDTTo: miller@CS.ROCHESTER.EDUcc: common-lisp-object-system@SAIL.STANFORD.EDUMessage-ID: <881014-145043-7455@Xerox>My impression from hearing about current applications of CLOS is that yourassertion "w/o generic EVAL or APPLY, CLOS is just a bag on the side of CL"is not true.CLOS claim to integration in CL comes both from the integration of methodinvocation with function call and the integration of the class hierarchywith the previous Common Lisp type hierarchy. Both of those allow fortreating CLOS as the language and CLtL as the previous subset. CLOS and CLare consistent in treating the type hierarchy as the mechanism ofdispatching on varying forms of behavior, but not relying too heavily onthe function-as-object style which is popular in Scheme.The notion of making APPLY (or  FUNCALL) generic is possibly quiteinteresting, although it implies a different model of "object oriented"than the one currently embodied in Common Lisp and CLOS.*start*03510 00024 US Return-Path: <miller@PECAN.CS.ROCHESTER.EDU>Received: from PECAN.CS.ROCHESTER.EDU ([192.5.53.206]) by Xerox.COM ; 17 OCT 88 14:31:22 PDTReceived: from DOUGHNUT.CS.ROCHESTER.EDU by PECAN.CS.ROCHESTER.EDU via CHAOS with CHAOS-MAIL id 4616; Mon 17-Oct-88 17:21:51 EDTDate: Mon, 17 Oct 88 17:30 EDTFrom: Brad Miller <miller@CS.ROCHESTER.EDU>Subject: Re: Issue: EVAL-OTHER (Version 2) To: masinter.paIn-Reply-To: <881014-145043-7455@Xerox>Message-ID: <19881017213044.1.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Sender: miller@CS.ROCHESTER.EDUReply-To: miller@CS.ROCHESTER.EDUOrganization: University of Rochester, Department of Computer SciencePostal-address: 610 CS Building, Comp Sci Dept., U. Rochester, Rochester NY 14627Phone: 716-275-1118    Date: 14 Oct 88 14:50 PDT    From: masinter.pa@Xerox.COM[Just you and me]I don't mean to be obstinate, but currently the definition of EVAL dependson the type of the object being EVALed, that is, as a symbol it has one sortof definition, if a list, another, etc. It seems to me that the obvious andorthogonal extension vis. CLOS is to have user-defined objects (e.g.classes) define their own "value" in the two namespaces (thus orthogonalityw.r.t EVAL and APPLY is preserved). Not doing this makes EVAL and APPLY more "special" than they really need tobe; doing so does not immediately strike me as being costly; even minorsyntactic sugar is unneccessary, since EVAL or APPLY can be yet anothermethod on a class. If you insist, it could be defined not to have before andafter type daemon method combination, though I don't think such a limitationis necessary. It can certainly be insisted that one cannot extend theEVAL/APPLY behavior for lists or symbols which allows currentimplementations to continue to work with the expected behavior: one could*not*, for example, provide an :AFTER daemon method for EVAL on symbols.It would already be necessary for an implementation of CL/CLOS to determinethe type of the object being EVAL'd or APPLY'd, this is just a firmer andmore useful definition of what happens when that object is an instance of aCLASS. (vs. just defining it to SELF-EVAL: I certainly agree that *some*action must be standardized!).    CLOS claim to integration in CL comes both from the integration of method    invocation with function call and the integration of the class hierarchy    with the previous Common Lisp type hierarchy. Both of those allow for    treating CLOS as the language and CLtL as the previous subset. CLOS and CL    are consistent in treating the type hierarchy as the mechanism of    dispatching on varying forms of behavior, but not relying too heavily on    the function-as-object style which is popular in Scheme.I'm not arguing that two namespaces must be collapsed into one, if that iswhat you refer to as "the function-as-object style which is popular inScheme", I do argue that treating Symbols and Lists as the only EVALable orAPPLYable objects isn't particularly orthogonal, and doesn't seem to me tobe particularly necessary for some pragmatic reason, either. I don't saythat evaling an instance of a class need be FAST.I'd really like to see EVAL and APPLY on instances be made part of CLOS, andI'd really like to convince you of their good use, and relatively low costto implementors. What would you like to see from me to be so convinced?----Brad Miller		U. Rochester Comp Sci Dept.miller@cs.rochester.edu {...allegra!rochester!miller}*start*01260 00024 US Date: 17 Oct 88 15:09 PDTFrom: masinter.paSubject: Re: Issue: EVAL-OTHER (Version 2) In-reply-to: Brad Miller <miller@CS.ROCHESTER.EDU>'s message of Mon, 17 Oct 88 17:30 EDTTo: miller@CS.ROCHESTER.EDUcc: masinter.paSymbols and Lists are the only objects that do not evaluate to themselves. However, there is only one kind of data that can be APPLY'd: a FUNCTION. In a bow to backward compatibility, most functions that take functions will also take a SYMBOL and perform SYMBOL-FUNCTION on it, but there is an explicit coercion involved, which goes that level of indirection.EVAL is special because of compilation: you can't have user programmability at the EVAL level and still be able to compile -- maybe MACROEXPAND-1, but not EVAL. APPLY is significantly different, and yet it would make more sense to talk about FUNCALL rather than APPLY.I think in order to be convinced that this was more than just a neat idea I'd like to see a treatment of compilation -- how might it possibly work were EVAL to be a generic function? Or would this feature only be of use in programs that explicitly called EVAL? It also would be useful to see how this might fit in with current implementation techniques for EVAL and APPLY.Larry*start*04598 00024 US Return-Path: <@DOUGHNUT.CS.ROCHESTER.EDU:miller@CS.ROCHESTER.EDU>Received: from cayuga.cs.rochester.edu ([10.0.0.15]) by Xerox.COM ; 19 OCT 88 12:51:43 PDTReceived: from doughnut.cs.rochester.edu by cayuga.cs.rochester.edu (5.59/k) id AA09016; Wed, 19 Oct 88 15:51:23 EDTDate: Wed, 19 Oct 88 15:51 EDTFrom: Brad Miller <miller@CS.ROCHESTER.EDU>Subject: Re: Issue: EVAL-OTHER (Version 2) To: masinter.paIn-Reply-To: <881017-151058-3515@Xerox>,             The message of 17 Oct 88 18:09 EDT from masinter.pa@Xerox.COM,             <19881017213044.1.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>,             The message of 17 Oct 88 17:30 EDT from miller@CS.ROCHESTER.EDU,             The message of 17 Oct 88 17:30 EDT from Brad MillerMessage-Id: <19881019195104.3.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Sender: miller@CS.ROCHESTER.EDUReply-To: miller@CS.ROCHESTER.EDUOrganization: University of Rochester, Department of Computer SciencePostal-Address: 610 CS Building, Comp Sci Dept., U. Rochester, Rochester NY 14627Phone: 716-275-1118    Date: 17 Oct 88 15:09 PDT    From: masinter.pa@Xerox.COM    EVAL is special because of compilation: you can't have user programmability    at the EVAL level and still be able to compile -- maybe MACROEXPAND-1, but    not EVAL. I think you are overextending my argument; I'm not trying to have userprogrammability at the EVAL level on objects already defined by CLtL;consider these classes builtin, with an EVAL method specified that cannot bemodified by the user. I'm talking about new classes the user introduces only- I want more flexibility than just identity; I want the user to be able tospecify an eval method on these objects (the default most general evalmethod could indeed be identity), so the user can essentially embed newfirst class objects into CL.    APPLY is significantly different, and yet it would make more sense to talk    about FUNCALL rather than APPLY.OK, let's elim the 2lisp argument here then: in ((foo) ...) the expression(foo) better eval to a fn, so in ([mumble] ...), [mumble] better too.    I think in order to be convinced that this was more than just a neat idea    I'd like to see a treatment of compilation -- how might it possibly work    were EVAL to be a generic function? Or would this feature only be of use in    programs that explicitly called EVAL? It also would be useful to see how    this might fit in with current implementation techniques for EVAL and    APPLY.Again, ignore APPLY; I'm willing to sacrefice 2lispishness.Consider an object [mumble] which the parser understands as specifying aninstance of a class the user has defined. (we could write it as#,(make-instance ...) but I'm trying to be pretty: this is what I reallywant to be able to do in source code!evaling a list like (foo [mumble] bar) is then just evaluating a list like(foo (eval-yourself '[mumble]) bar); the compiler can indeed produce this asit's temporary output, whith eval-yourself being the generic eval method foruser defined objects. This eval method could indeed change at runtime sinceit is not a macro, and in this way is no different than any other lisp fnthat is on a symbol's function slot. I don't see anything conceptuallydifficult about this, so perhaps I'm missing something subtle here?I certainly concur that to make EVAL generic and allow the user to changeits meaning on objects like symbols and lists, or provide daemoncombinations for same would be a lot of hair (though a nice thing: stillit's just like allowing someone to change the symbol-function on EVAL nowand have the compiler know about it --- I don't think this has real meaningand while it is orthogonal, it isn't really "lisp" anymore!). But that's notwhat I'm after; I don't want to be able to change the semantics of CLtL asit is, I just want to be able to add new first class objects, and thissimple definition that user classes are sent EVAL-YOURSELF messages toimplement eval rather than just using identity gives me everything I wantand need... (unlike some, I don't usually use lisp as an implementationlanguage for a new language, but try to extend lisp to cover what I need inthe new language --- build lisp+ as it were:  implementation time isshortened, debugging is easier, and I'm not in the commercial developmentbusiness anyway --- more at rapid prototyping.)Anyway, if I'm missing something subtle about eval I don't know about,please enlighten me!----Brad Miller		U. Rochester Comp Sci Dept.miller@cs.rochester.edu {...allegra!rochester!miller}*start*01929 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 20 OCT 88 17:19:44 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA08318g; Thu, 20 Oct 88 17:19:26 PDTReceived: by bhopal id AA06100g; Thu, 20 Oct 88 17:17:51 PDTDate: Thu, 20 Oct 88 17:17:51 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810210017.AA06100@bhopal>To: miller@CS.ROCHESTER.EDUCc: masinter.pa, common-lisp-object-system@SAIL.STANFORD.EDU, cl-cleanup@SAIL.STANFORD.EDU, harris%hplwhh@HPLABS.HP.COMIn-Reply-To: Brad Miller's message of Mon, 10 Oct 88 16:41 EDT <19881010204134.1.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Subject: Issue: EVAL-OTHER (Version 2) re: w/o generic EVAL or APPLY, CLOS is just a bag on the side of CL. I can't agree with this at all.  CL is an extremely useful programminglanguage, and with CLOS added it is incredibly more  useful.  EVALis a boringly obscure operation to apply to any piece of data -- itmerely decodes the syntatic means by which programs are written.  Writingprograms encoded as strings rather than lists and symbols, or encoded in *any* other random datatype, is hardly a great step forward.While that last sentence might be open to continuing theoretical debate,there is the practical observation that MacLisp/NIL *did* make such anextension (using the object-oriented system called EXTEND), and therewere virtually no meaningful uses of it.  [I'm not 100% sure but I thinkGlenn Burke may have used it somehow in the Layered System Buildingproject.  Apologies, if that use was "meaningful".]In fact, the EVAL-related extension that really has some vocal supportersbehind it is to *increase* the level on standardization in the coding of EVAL, so that research projects into the likes of debuggers and window systems can put more "hooks" into the interpreter.  See Henry Lieberman's"Common Eval" proposal.-- JonL --*start*03942 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 10:35:16 PDTReceived: from hplms2.hpl.hp.com by SAIL.Stanford.EDU with TCP; 6 Oct 88  10:34:39 PDTReceived: from hplwhh.HPL.HP.COM (hplwhh.hpl.hp.com) by hplms2.hp.com; Thu, 6 Oct 88 10:30:30 pdtReceived: from loopback by hplwhh.HPL.HP.COM; Thu, 6 Oct 88 10:30:06 pdtFull-Name: Warren HarrisTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, miller@CS.Rochester.EDUCc: Common-Lisp-Object-System@SAIL.Stanford.EDU, CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: EVAL-OTHER (Version 2) In-Reply-To: Your message of "Thu, 06 Oct 88 02:10:00 EDT."             <881006021043.8.KMP@BOBOLINK.SCRC.Symbolics.COM> Date: Thu, 06 Oct 88 10:30:02 PDTMessage-Id: <8592.592162202@hplwhh>From: Warren Harris <harris%hplwhh@hplabs.hp.com>I don't know about making EVAL a generic function due to the ramificationsthis has on the compiler, but there are several other places in CL in whichfunctions should be required to be generic. One example might be in the equality area.  Common Lisp seems to have awealth of equality predicates, EQ, EQL, EQUAL, EQUALP, =, STRING=, CHAR=... and you kind of pick and choose based on what you know about theapplication.  It would be nice to have at least one version of equalitywhich did the right thing based on what it was comparing.  Perhaps this isEQUALP.  EQUALP already looks inside both cons cells and arrays, why notextend it to look inside objects too.  I suggest the following definitionof EQUALP:	(defmethod equalp ((x t) (y t))	  (eq x y))        (defmethod equalp ((x character) (y character))	  (char-equal x y))        (defmethod equalp ((x number) (y number))	  (= x y))        (defmethod equalp ((x cons) (y cons))	  (or (eq x y)	      (and (equalp (car x) (car y))		   (equalp (cdr x) (cdr y)))))        (defmethod equalp ((x object) (y object))	  (let ((cx (class-of x))		(cy (class-of y)))	    (or (eq x y)		(and (eq cx cy)		     (every #'(lambda (slotd)				(let ((name (slotd-name slotd)))				  (equalp (slot-value-using-class cx								  x								  name)					  (slot-value-using-class cx								  y								  name))))			    (class-slots cx))))))        (defmethod equalp ((x array) (y array))	  ...)COERCE is another good candidate for being made generic.  Like the printsystem which is required to go through the PRINT-OBJECT method, COERCEcould ultimately invoke a generic layer:	(defun coerce (thing type)	  (case type	    <old coerce code ...>	    (t	     (coerce-object thing (find-class type)))))	(defmethod coerce-object ((thing t) (c class))	  (error "~S cannot be coerced to type ~S."		 thing (class-name c)))This would allow the user to write class specific coercion routines.  Oneobjection has been raised to this proposal by Moon:> But it's meaningful for COERCE's second argument to be a type specifier that> does not name a class.  CLtL gives as an example (vector (complex short-float)).> It would be inconsistent to do some coercions with classes and others through> some other mechanism.  I don't think your idea will work without a larger> recasting of Common Lisp in object-oriented terms.  While that's an interesting> project for investigation, I suspect it would quickly go way beyond the> proper charter of a standardization effort.I think the above code demonstrates how this can indeed work given CL'snon-class type specifiers.  COERCE itself is not required to be generic, itis simplied required to ultimately call COERCE-OBJECT.  This is exactly therequirement placed on PRINT. > One minor procedural matter: You're more likely to get this considered if> you write up the proposal in full rather than just as a little fragment.How do I do this?  How does it look, and who do I send it to?Warren HarrisHP Labs*start*03277 00024 USaReturn-Path: <miller@PECAN.CS.ROCHESTER.EDU>Received: from PECAN.CS.ROCHESTER.EDU ([192.5.53.206]) by Xerox.COM ; 24 OCT 88 18:15:42 PDTReceived: from DOUGHNUT.CS.ROCHESTER.EDU by PECAN.CS.ROCHESTER.EDU via CHAOS with CHAOS-MAIL id 4702; Mon 24-Oct-88 21:07:30 EDTDate: Mon, 24 Oct 88 21:06 EDTFrom: Brad Miller <miller@CS.ROCHESTER.EDU>Subject: Re: Issue: EVAL-OTHER (Version 2) To: Jon L White <jonl@LUCID.COM>cc: masinter.pa, common-lisp-object-system@SAIL.STANFORD.EDU, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8810210017.AA06100@bhopal>Message-ID: <19881025010655.7.MILLER@DOUGHNUT.CS.ROCHESTER.EDU>Sender: miller@CS.ROCHESTER.EDUReply-To: miller@CS.ROCHESTER.EDUOrganization: University of Rochester, Department of Computer SciencePostal-address: 610 CS Building, Comp Sci Dept., U. Rochester, Rochester NY 14627Phone: 716-275-1118    Date: Thu, 20 Oct 88 17:17:51 PDT    From: Jon L White <jonl@lucid.com>    re: w/o generic EVAL or APPLY, CLOS is just a bag on the side of CL.     I can't agree with this at all.  CL is an extremely useful programming    language, and with CLOS added it is incredibly more  useful.  EVAL    is a boringly obscure operation to apply to any piece of data -- it    merely decodes the syntatic means by which programs are written.  Writing    programs encoded as strings rather than lists and symbols, or encoded in     *any* other random datatype, is hardly a great step forward.    While that last sentence might be open to continuing theoretical debate,    there is the practical observation that MacLisp/NIL *did* make such an    extension (using the object-oriented system called EXTEND), and there    were virtually no meaningful uses of it.  [I'm not 100% sure but I think    Glenn Burke may have used it somehow in the Layered System Building    project.  Apologies, if that use was "meaningful".]    In fact, the EVAL-related extension that really has some vocal supporters    behind it is to *increase* the level on standardization in the coding of     EVAL, so that research projects into the likes of debuggers and window     systems can put more "hooks" into the interpreter.  See Henry Lieberman's    "Common Eval" proposal.    -- JonL --I plan on writing you a response to this, but I'm currently swamped;just to let you know that my silence isn't agreement. I suspect thefault was mostly mine: I only gave a trivial example of such use, andI can give much better ones from my work on the RHET project.The short cleanup is that while theoretically a full-blown genericEVAL is "interesting", I certainly *don't* consider it practical. I'msimply trying to allow the user to specify an eval-function for usercreated types, rather than having them always self-eval. Generatingcode for these types as (EVAL-YOURSELF <instance>) rather than<instance> doesn't seem to be a particularly difficult implementationproblem, nor do I think it has a particular bad effect on debuggers.Appropriate method combination for EVAL-YOURSELF should allow for adebugger hook (though I've not thought this through carefully).Thanks for your response.More later,----Brad Miller		U. Rochester Comp Sci Dept.miller@cs.rochester.edu {...allegra!rochester!miller}