*start*03389 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU by Xerox.COM ; 22 JUN 88 14:49:10 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 22 Jun 88  14:46:14 PDTReceived: by decwrl.dec.com (5.54.4/4.7.34)	id AA21530; Wed, 22 Jun 88 14:46:01 PDTMessage-Id: <8806222146.AA21530@decwrl.dec.com>From: piazza%lisp.DEC@decwrl.dec.com (Jeffrey Piazza)Date: 22 Jun 88 17:38To: Common-Lisp-Object-System@sail.stanford.eduSubject: SYMBOL-MACROLET-UTILITYI'm getting to ready to submit this as a cleanup proposal; I thought I'd runit by here first.  My intent in submitting the proposal for cleanup is to openthe discussion of whether SYMBOL-MACROLET is really a desirable languagefeature.  If it is resolved that SYMBOL-MACROLET is worth keeping, I have afollow-up proposal to at least make it a special form./JEP===============================================================================Status:		DRAFTIssue:		SYMBOL-MACROLET-UTILITYReferences:	X3J13 document 88-002R, Chapter 2, pp. 2-81f., 2-88f., 2-92f.Category:	DELETIONEdit history:	21-Jun-88, Version 1 by PiazzaProblem Description:    Anything expressible with SYMBOL-MACROLET could also be written with    regular MACROLET, except that the macro symbol could not stand alone as an    expression; it would have to be enclosed in parentheses.  The cost    associated with implementing and maintaining the SYMBOL-MACROLET feature    exceeds this incremental utility.Proposal (SYMBOL-MACROLET:FLUSH):    Remove SYMBOL-MACROLET (and WITH-ACCESSORS and WITH-SLOTS) from 88-002R.Rationale:    Flushing SYMBOL-MACROLET eliminates the cost of implementing and    maintaining this feature, while MACROLET still provides most of    SYMBOL-MACROLET's expressive power.------------------------------------------------------------------------------Current Practice:    Portable Common Loops provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.Cost to Implementors:    Presumably few implementors have implemented SYMBOL-MACROLET, excepting    the implementation provided by PCL.  If it is flushed from the language,    no one will incur any implementation cost.Cost to Users:    Users will lose the expressive ability provided by SYMBOL-MACROLET,    WITH-ACCESSORS, and WITH-SLOTS, and will have to make do with MACROLET.Cost of Non-Adoption:    Implementors must implement significant new functionality, adding to    system size and language complexity.  (A separate proposal,    SYMBOL-MACROLET-SEMANTICS, addresses problems with the currently    specified semantics of SYMBOL-MACROLET.)Benefits:    SYMBOL-MACROLET:FLUSH reduces the implementation and maintenance costs for    a Common Lisp implementation.  It also simplifies the language by    eliminating the concept of a "symbol macro."Aesthetics:    There seem to be mixed feelings as to the desirability of SYMBOL-MACROLET    as a construct in the language.  Some feel it hairs up the language while    offering only trivial benefit beyond what is already provided through    normal macros.  Others herald it as a important new language feature.Discussion:    As it was adopted by X3J13 as part of CLOS, there has been no formal    discussion on the pros and cons SYMBOL-MACROLET on its own.*start*01713 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 29 JUN 88 11:17:48 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 29 Jun 88  11:16:27 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA12398; Wed, 29 Jun 88 14:14:06 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA11107; Wed, 29 Jun 88 14:18:05 EDTMessage-Id: <8806291818.AA11107@mist.UUCP>To: "piazza%lisp.DEC@decwrl.dec.com"@multimax.ARPA (Jeffrey Piazza)Cc: cl-cleanup%sail.stanford.edu@Multimax.ARPASubject: Re: Issue: SYMBOL-MACROLET-UTILITY (Version 1) In-Reply-To: Your message of Wed, 29 Jun 88 10:54:12 -0700.             <8806291754.AA11621@decwrl.dec.com> Date: Wed, 29 Jun 88 14:17:58 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>    I'll include a mention about "embedded languages."  Of course, embedded    languages are not Common Lisp.  If one favors SYMBOL-MACROLET because it    supports embedded languages, then one "should" also favor souping up    readmacros to make READ a fully-general parser, for how else can we support    an embedded language like FORTRAN?Embedding languages in Lisp is old and valuable tradition.  Thereforeit is reasonable to support a Lisp feature on the grounds that itmakes it easier to use Lisp in one of its traditional areas ofstrength.I would expect to support a language like FORTRAN or C by using READas a lexer and writing a separate parser.  For example, a Lisp versionof yacc *may* be appearing as free software soon (not from me).  Iassume that Kent was refering to custom embedded languages more on thelevel of CLISP.*start*04725 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 29 JUN 88 14:15:17 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 29 Jun 88  14:13:11 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 29 JUN 88 13:46:28 PDTDate: Wed, 29 Jun 88 13:44 PDTFrom: Gregor.paSubject: Re: Issue:  SYMBOL-MACROLET-UTILITYTo: Jeffrey Piazza <piazza%lisp.DEC@decwrl.dec.com>cc: cl-cleanup@sail.stanford.eduFcc: BD:>Gregor>mail>outgoing-mail-2.text.newestIn-Reply-To: <8806281758.AA10391@decwrl.dec.com>Message-ID: <19880629204455.4.GREGOR@PORTNOY.parc.xerox.com>Line-fold: no    Date: Tue, 28 Jun 88 10:58:00 PDT    From: piazza%lisp.DEC@decwrl.dec.com (Jeffrey Piazza)    Status:		DRAFT    Issue:		SYMBOL-MACROLET-UTILITY    References:	X3J13 document 88-002R, Chapter 2, pp. 2-81f., 2-88f., 2-92f.    Category:	DELETION    Edit history:	21-Jun-88, Version 1 by Piazza    Problem Description:	Anything expressible with SYMBOL-MACROLET could also be written with	regular MACROLET, except that the macro symbol could not stand alone as an	expression; it would have to be enclosed in parentheses.  The cost	associated with implementing and maintaining the SYMBOL-MACROLET feature	exceeds this incremental utility.This isn't a problem description, it is a statement of opinion.  Aproblem description would say something like:  The symbol-macrolet utitily introduced with CLOS has some semantic  problems.  <discussion of these problems here>.  These problems may  cause problems with some existing code <extension of previous  discussion here>.    Proposal (SYMBOL-MACROLET:FLUSH):	Remove SYMBOL-MACROLET (and WITH-ACCESSORS and WITH-SLOTS) from 88-002R.    Rationale:	Flushing SYMBOL-MACROLET eliminates the cost of implementing and	maintaining this feature, while MACROLET still provides most of	SYMBOL-MACROLET's expressive power.The explanation of the hack of using the symbol as what looks like ano arguments function should be presented here.  There needs to be adiscussion of the fact that this would work much better in a Lisp-1than a Lisp-2.    ------------------------------------------------------------------------------    Current Practice:	Portable Common Loops provides a code-walking implementation of	SYMBOL-MACROLET as specified in 88-002R.    Cost to Implementors:	Presumably few implementors have implemented SYMBOL-MACROLET, excepting	the implementation provided by PCL.  If it is flushed from the language,	no one will incur any implementation cost.    Cost to Users:	Users will lose the expressive ability provided by SYMBOL-MACROLET,	WITH-ACCESSORS, and WITH-SLOTS, and will have to make do with        MACROLET.Another cost is that they won't be able to overload names to mean botha real function and one of these hack macros.  For example:(defclass foo () (car cdr))(defun describe-foo (foo)  (macrolet ((car () (slot-value foo 'car))	     (cdr () (slot-value foo 'cdr)))    ...    Can't use normal car and cdr in here    ...))Of course this is something that Scheme programmers are used to dealingwith.  But Common Lisp programmers are not.  The potential for thisseriously aggravating the existing problem with macro expansionscapturing the wrong lexical context is huge.    Cost of Non-Adoption:	Implementors must implement significant new functionality, adding to	system size and language complexity.  (A separate proposal,	SYMBOL-MACROLET-SEMANTICS, addresses problems with the currently	specified semantics of SYMBOL-MACROLET.)I am not sure I buy this.  For one, there is already an implementationof it in PCL.  For another, any exiting compiler must already have theright stuff in it to do this.  If you insist on doing an entirely custom CLOS, the work required to dothis part of it is very small compared to the work required to do therest of it.    Benefits:	SYMBOL-MACROLET:FLUSH reduces the implementation and maintenance costs for	a Common Lisp implementation.  It also simplifies the language by	eliminating the concept of a "symbol macro."    Aesthetics:	There seem to be mixed feelings as to the desirability of SYMBOL-MACROLET	as a construct in the language.  Some feel it hairs up the language while	offering only trivial benefit beyond what is already provided through	normal macros.  Others herald it as a important new language feature.    Discussion:	As it was adopted by X3J13 as part of CLOS, there has been no formal	discussion on the pros and cons SYMBOL-MACROLET on its own.That discussion should appear in this part of the proposal.-------*start*02983 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 28 JUN 88 11:01:50 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 28 Jun 88  10:58:14 PDTReceived: by decwrl.dec.com (5.54.4/4.7.34)	id AA10391; Tue, 28 Jun 88 10:58:00 PDTDate: Tue, 28 Jun 88 10:58:00 PDTMessage-Id: <8806281758.AA10391@decwrl.dec.com>From: piazza%lisp.DEC@decwrl.dec.com (Jeffrey Piazza)To: cl-cleanup@sail.stanford.eduSubject: Issue:  SYMBOL-MACROLET-UTILITYStatus:		DRAFTIssue:		SYMBOL-MACROLET-UTILITYReferences:	X3J13 document 88-002R, Chapter 2, pp. 2-81f., 2-88f., 2-92f.Category:	DELETIONEdit history:	21-Jun-88, Version 1 by PiazzaProblem Description:    Anything expressible with SYMBOL-MACROLET could also be written with    regular MACROLET, except that the macro symbol could not stand alone as an    expression; it would have to be enclosed in parentheses.  The cost    associated with implementing and maintaining the SYMBOL-MACROLET feature    exceeds this incremental utility.Proposal (SYMBOL-MACROLET:FLUSH):    Remove SYMBOL-MACROLET (and WITH-ACCESSORS and WITH-SLOTS) from 88-002R.Rationale:    Flushing SYMBOL-MACROLET eliminates the cost of implementing and    maintaining this feature, while MACROLET still provides most of    SYMBOL-MACROLET's expressive power.------------------------------------------------------------------------------Current Practice:    Portable Common Loops provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.Cost to Implementors:    Presumably few implementors have implemented SYMBOL-MACROLET, excepting    the implementation provided by PCL.  If it is flushed from the language,    no one will incur any implementation cost.Cost to Users:    Users will lose the expressive ability provided by SYMBOL-MACROLET,    WITH-ACCESSORS, and WITH-SLOTS, and will have to make do with MACROLET.Cost of Non-Adoption:    Implementors must implement significant new functionality, adding to    system size and language complexity.  (A separate proposal,    SYMBOL-MACROLET-SEMANTICS, addresses problems with the currently    specified semantics of SYMBOL-MACROLET.)Benefits:    SYMBOL-MACROLET:FLUSH reduces the implementation and maintenance costs for    a Common Lisp implementation.  It also simplifies the language by    eliminating the concept of a "symbol macro."Aesthetics:    There seem to be mixed feelings as to the desirability of SYMBOL-MACROLET    as a construct in the language.  Some feel it hairs up the language while    offering only trivial benefit beyond what is already provided through    normal macros.  Others herald it as a important new language feature.Discussion:    As it was adopted by X3J13 as part of CLOS, there has been no formal    discussion on the pros and cons SYMBOL-MACROLET on its own.*start*03339 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 28 JUN 88 13:55:26 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Jun 88  13:53:52 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 426053; Tue 28-Jun-88 16:53:18 EDTDate: Tue, 28 Jun 88 16:53 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SYMBOL-MACROLET-UTILITY (Version 1)To: piazza%lisp.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8806281758.AA10391@decwrl.dec.com>Message-ID: <880628165306.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>You called the proposal SYMBOL-MACROLET:FLUSH rather thanSYMBOL-MACROLET-UTILITY:FLUSH.I personally oppose this proposal, but I of course have no opposition toit's being presented to X3J13 for a vote.This is a very complex issue, and I don't think it does it justiceto have such a terse presentation. I think both the specific reasonswhy people dislike it (I believe there to be interesting semantic arguments which go beyond a desire for a minimalist language)and the specific reasons why people think it's an important new languagefeature need to be brought out.Issues I'd like to see added at appropriate points (perhaps in thediscussion): * Current Practice   Symbolics Cloe has both a code-walking version of a SYMBOL-MACROLET   macro and compiler support for a SYMBOL-MACROLET special form. * Abstraction / Expressive Power   Symbolics Cloe originally started with the macro version of   SYMBOL-MACROLET, but found that the problem is that a code-walking   SYMBOL-MACROLET destroys important abstraction information (like the   fact that a particular TAGBODY/GO/BLOCK/RETURN configuration can be   viewed as a PROG/PROG*/DO/DO*/...). There's no loss of computational   power by doing the expansion, but there is a loss of perspicuity and   it is not always easy for a compiler to put that information back in. * ONCE-ONLY   If I recall correctly, some people have a worry about the relationship   between SYMBOL-MACROLET and ONCE-ONLY (an interesting macro which   occurs in several implementations). I haven't thought hard about this   issue, but maybe someone who has can comment on it.   Note that if users write their own code-walking SYMBOL-MACROLET, the   wrong interaction may happen with a ONCE-ONLY primitive and there's   no obvious way to work around the problem. * Need by users   I've wanted this feature on a number of occassions to help me implement   embedded languages. I bet others have, too. I think that wants to at    least get mentioned somewhere. When arbitrary users come up with the   need for this facility, it is unreasonable (both in terms of code   duplication and in terms of programmer expertise) to suppose that they   can or should just go out and write a code-walker. Having written one   myself, I must say I think that getting it right for even one    implementation is very hard and making it really portable is almost a   pipe dream.I think there other issues lurking here as well, but these should do asstarters to help flesh out this proposal.*start*03429 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 29 JUN 88 10:55:45 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 29 Jun 88  10:54:30 PDTReceived: by decwrl.dec.com (5.54.4/4.7.34)	id AA11621; Wed, 29 Jun 88 10:54:12 PDTDate: Wed, 29 Jun 88 10:54:12 PDTMessage-Id: <8806291754.AA11621@decwrl.dec.com>From: piazza%lisp.DEC@decwrl.dec.com (Jeffrey Piazza)To: DECWRL::KMP@stony-brook.scrc.symbolics.comSubject: RE: Issue: SYMBOL-MACROLET-UTILITY (Version 1)> You called the proposal SYMBOL-MACROLET:FLUSH rather than> SYMBOL-MACROLET-UTILITY:FLUSH.Oops. >    Symbolics Cloe has both a code-walking version of a SYMBOL-MACROLET>    macro and compiler support for a SYMBOL-MACROLET special form.I'll add this to current practice. >  * Abstraction / Expressive Power>  >    Symbolics Cloe originally started with the macro version of>    SYMBOL-MACROLET, but found that the problem is that a code-walking>    SYMBOL-MACROLET destroys important abstraction information (like the>    fact that a particular TAGBODY/GO/BLOCK/RETURN configuration can be>    viewed as a PROG/PROG*/DO/DO*/...). There's no loss of computational>    power by doing the expansion, but there is a loss of perspicuity and>    it is not always easy for a compiler to put that information back in.This seems to have to do with whether SYMBOL-MACROLET should be a macro or aspecial form.  I've written (but not yet distributed) a separate issue forthis, but I'd like to first see debate on the keep/flush question.  Note that,as voted, CLOS specifies SYMBOL-MACROLET to be a macro, which implies codewalking. >  * ONCE-ONLY>  >    If I recall correctly, some people have a worry about the relationship>    between SYMBOL-MACROLET and ONCE-ONLY (an interesting macro which>    occurs in several implementations). I haven't thought hard about this>    issue, but maybe someone who has can comment on it.>  >    Note that if users write their own code-walking SYMBOL-MACROLET, the>    wrong interaction may happen with a ONCE-ONLY primitive and there's>    no obvious way to work around the problem.Again, this is a code-walking-vs.-special-form issue.  I agree that, ifadmitted to the language, SYMBOL-MACROLET should be a special form, not amacro.  However, I also believe that that's a different question. >  * Need by users>>    I've wanted this feature on a number of occassions to help me implement>    embedded languages. I bet others have, too. I think that wants to at >    least get mentioned somewhere. When arbitrary users come up with the>    need for this facility, it is unreasonable (both in terms of code>    duplication and in terms of programmer expertise) to suppose that they>    can or should just go out and write a code-walker. Having written one>    myself, I must say I think that getting it right for even one >    implementation is very hard and making it really portable is almost a>    pipe dream. I'll include a mention about "embedded languages."  Of course, embeddedlanguages are not Common Lisp.  If one favors SYMBOL-MACROLET because itsupports embedded languages, then one "should" also favor souping upreadmacros to make READ a fully-general parser, for how else can we supportan embedded language like FORTRAN?/JEP*start*04154 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 JUL 88 09:09:14 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 7 Jul 88  09:08:04 PDTReceived: by decwrl.dec.com (5.54.4/4.7.34)	id AA02117; Thu, 7 Jul 88 09:07:29 PDTDate: Thu, 7 Jul 88 09:07:29 PDTMessage-Id: <8807071607.AA02117@decwrl.dec.com>From: piazza%lisp.DEC@decwrl.dec.com (Jeffrey Piazza)To: Gregor.paSubject: RE: Issue: SYMBOL-MACROLET-UTILITY> This isn't a problem description, it is a statement of opinion.  A> problem description would say something like:> >   The symbol-macrolet utitily introduced with CLOS has some semantic>   problems.  <discussion of these problems here>.  These problems may>   cause problems with some existing code <extension of previous>   discussion here>.I'm not completely happy with the problem description as it stands, either.  Isee the issue as essentially a choice between (a) fixing the semantics ofSYMBOL-MACROLET to match the semantics of MACROLET, or (b) doing withoutSYMBOL-MACROLET.  I had thought I could separate these into two issues(namely, keep-vs.-flush first, and fix the semantics only if flush fails), butnow I think I should combine them into one issue after all.  This will beforthcoming. >    Cost to Users:> >	Users will lose the expressive ability provided by SYMBOL-MACROLET,>	WITH-ACCESSORS, and WITH-SLOTS, and will have to make do with>        MACROLET.> >Another cost is that they won't be able to overload names to mean both>a real function and one of these hack macros.  For example:> >(defclass foo () (car cdr))> >(defun describe-foo (foo)>  (macrolet ((car () (slot-value foo 'car))>	     (cdr () (slot-value foo 'cdr)))>    ...>    Can't use normal car and cdr in here>    ...))> >Of course this is something that Scheme programmers are used to dealing>with.  But Common Lisp programmers are not.  The potential for this>seriously aggravating the existing problem with macro expansions>capturing the wrong lexical context is huge.The namespace argument is a valid one; I'll put that in "Cost to Users".  Thisis honestly the first pro-SYMBOL-MACROLET argument I've heard that has moresubstance than "But it'd be neat to have SYMBOL-MACROLET."Characterizing the namespace collision problem as "huge," based on the exampleyou give, assumes that (a) people have some proclivity toward using names thatconflict with function names like "car" and "cdr", (b) they'd use the samename for both the macro and the slot (cf. defstruct and the :conc-name prefixmechanism), and (c) someone writing		(macrolet ((car () ...)) ...)wouldn't see the name collision.  I might believe the first assumption(especially for names like "list"), I'm more dubious of the second, and Ireally have a hard time swallowing the third assumption.  Even in a Lisp-2,programmers are used to avoiding name conflicts.I tend to believe that changing WITH-SLOTS and WITH-ACCESSORS could eliminateCLOS' need for SYMBOL-MACROLET altogether, if they just generated MACROLETmacros with prefixes. >     Cost of Non-Adoption:>  > 	Implementors must implement significant new functionality, adding to> 	system size and language complexity.  (A separate proposal,> 	SYMBOL-MACROLET-SEMANTICS, addresses problems with the currently> 	specified semantics of SYMBOL-MACROLET.)>  > I am not sure I buy this.  For one, there is already an implementation> of it in PCL.  For another, any exiting compiler must already have the> right stuff in it to do this.  > > If you insist on doing an entirely custom CLOS, the work required to do> this part of it is very small compared to the work required to do the> rest of it. I guess I was getting ahead of myself here.  I'd been taking it as an almostforegone conclusion that, if SYMBOL-MACROLET is kept in the language, it wouldbe promoted to a special form, in which case the PCL implementation doesn'treally help anybody.  Another reason to combine this with thefix-the-semantics issue./JEP*start*07731 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 29 JUL 88 14:12:19 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 29 Jul 88  14:10:34 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA03546; Fri, 29 Jul 88 14:09:49 PDTDate: Fri, 29 Jul 88 14:09:49 PDTMessage-Id: <8807292109.AA03546@decwrl.dec.com>From: piazza%lisp.DEC@decwrl.dec.com (Jeffrey Piazza)To: cl-cleanup@sail.stanford.eduSubject: SYMBOL-MACROLET-SEMANTICSStatus:		For Internal DiscussionIssue:		SYMBOL-MACROLET-SEMANTICSReferences:	X3J13 document 88-002R, Chapter 2, pp. 2-81f.Category:	CHANGEEdit history:	29-July-88, Version 1 by PiazzaProblem Description:    The SYMBOL-MACROLET construct introduced with CLOS in X3J13 document    88-002R, because it is specified as a macro, cannot make use of the    &environment argument mechanism to communicate with complex macros    appearing within its body.  As a consequence, the behavior of    SYMBOL-MACROLET, when used in conjunction with side-effects and complex    macros, is inconsistent with that of MACROLET, and confusing to users.Test Case:    (let ((a (make-array 5))          (i 0))      (macrolet ((place () `(aref a (incf i))))        (push x (place)))      i)		==> 1    (let ((a (make-array 5))          (i 0))      (symbol-macrolet ((place  (aref a (incf i))))        (push x place))      i)		==> 2Proposal (SYMBOL-MACROLET-SEMANTICS:FLUSH):    Remove SYMBOL-MACROLET from 88-002R.  Remove WITH-ACCESSORS and    WITH-SLOTS, or modify them to use ordinary macros.Rationale:    For most uses of SYMBOL-MACROLET, ordinary MACROLET can provide equivalent    expressive/abstraction power.  E.g.,	(symbol-macrolet ((slot1 (slot-value foo 'slot1)))          (incf slot1))    becomes	(macrolet ((slot1 () (slot-value foo 'slot1)))	  (incf (slot1)))Proposal (SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM):    Change the definition of SYMBOL-MACROLET to specify that it is a special    form, which affects the evaluation environment for symbols.  Enhance    MACROEXPAND and MACROEXPAND-1 so that they can expand a symbol macro.    Modify SETF et al to use the new MACROEXPAND and MACROEXPAND-1 to examine    even symbol subforms.  Specify that the expansion of a symbol macro IS    subject to further macro expansion, and that ``recursive'' symbol macros    are an error.  Specify that it is an error to try to SETQ a symbol macro.Rationale:    The current specification of SYMBOL-MACROLET as a macro leads to    undesirable results if forms which produce side-effects are part of the    expansion of a symbol macro.      This potential for interaction between macros is exactly why &environment    arguments were originally added to macros.  Changing SYMBOL-MACROLET to be    a special form, which communicates through the &environment arguments to    macros with MACROEXPAND and MACROEXPAND-1, would allow PUSH and SETF    (among others) to work with SYMBOL-MACROLET in the same way they work with    MACROLET.    This change cannot (reasonably) support the currently specified semantics    that the expansion text is "outside" the scope of the symbol macro.  For    indeed, when the symbol macro is expanded, (a copy of) the expansion is    then within the scope of the SYMBOL-MACROLET, and should then be subject    to further scrutiny.  The issue of "infinite expansion" of symbol macros is    no more dangerous than that of normal macros.    Finally, the rule that SETQ of a symbol macro must be treated as a SETF of    the expansion seems to be a kludge which was introduced only to support a    code-walking version of SYMBOL-MACROLET.  If SYMBOL-MACROLET were changed    to be a special form, this rule would no longer be needed, and should be    eliminated in order to make the distinction between symbol macros and    variables cleaner.Current Practice:    Portable Common Loops provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.  Symbolics Cloe has both a    code-walking version of a SYMBOL-MACROLET macro and compiler support for    a SYMBOL-MACROLET special form.Cost to Implementors:    If SYMBOL-MACROLET is removed from the language, no one will bear any cost    of implementation.    If it is modified to be a special form, compilers and interpreters will    have to change, as well as MACROEXPAND, MACROEXPAND-1, and SETF (at    least).Cost to Users:    If SYMBOL-MACROLET is converted to a special form, code-walking programs    will have to be modified to handle SYMBOL-MACROLET correctly.  Those same    programs would have to be modified to handle the other special forms    specified in CLOS, anyway.    If SYMBOL-MACROLET is removed from the language, users will have to make    do with MACROLET.  Users will be unable to overload names which already    have definitions as functions.  E.g.,	(defclass foo () (car cdr))	(defun describe-foo (foo)	  (macrolet ((car () (slot-value foo 'car))		     (cdr () (slot-value foo 'cdr)))	    ...	    Can't use normal car and cdr in here	    ...))Cost of Non-Adoption:    SYMBOL-MACROLET will retain its confusing semantics, leading to bugs when    it interacts with complex macros and forms which produce side-effects.    Implementations which support ONCE-ONLY will break.  For that matter, any    mechanism which examines code and assumes that "variables" have no side    effects will break.Benefits:    SYMBOL-MACROLET-SEMANTICS:FLUSH reduces the implementation and maintenance    costs for a Common Lisp implementation.  It also simplifies the language    by eliminating the concept of a "symbol macro."    SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM avoids the hairiest problems    surrounding interaction of macros (like SETF) and side effects, and makes    SYMBOL-MACROLET consistent with MACROLET.Aesthetics:    There seem to be mixed feelings as to the desirability of SYMBOL-MACROLET    as a construct in the language.  Some feel it hairs up the language while    offering only trivial benefit beyond what is already provided through    normal macros.  Others herald it as a important new language feature.    If symbol macros are retained but SYMBOL-MACROLET made to be a special    form, aesthetics are improved by making symbol macros consistent with    normal macros.Discussion:    As it was adopted by X3J13 as part of CLOS, there has been no formal    discussion on the pros and cons of SYMBOL-MACROLET on its own.    In favor of SYMBOL-MACROLET are the following arguments:    * It allows access to a different namespace for defining macros.  That is,    it allows macros to be defined in the namespace previously used only by    variables.  This can avoid name conflicts in certain situations.    * Certain "embedded languages" may be more easily implemented if    SYMBOL-MACROLET is available.    Arguments against SYMBOL-MACROLET include:    * It makes variable references opaque.  That is, a symbol appearing as a    form is no longer necessarily a variable.  Programs become correspondingly    more difficult to read and understand.    * There are other solutions to the problems of name collisions which    don't add this complexity to the language.  Specifying prefixes for    WITH-SLOTS and WITH-ACCESSORS in the manner of DEFSTRUCT, for example,    would eliminate accidental name conflicts in practice.    * Symbol macros cannot accept arguments, and therefore cannot be used to    solve the name conflict problems in situations where macro arguments are    required.*start*04318 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 01 AUG 88 10:59:42 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Aug 88  10:58:48 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 440873; Mon 1-Aug-88 13:57:53 EDTDate: Mon, 1 Aug 88 13:57 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SYMBOL-MACROLET-SEMANTICS (Version 1)To: piazza%lisp.DEC@decwrl.dec.comcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8807292109.AA03546@decwrl.dec.com>Message-ID: <880801135717.1.KMP@PEWEE.SCRC.Symbolics.COM>I assume this is the SYMBOL-MACROLET-UTILITY issue in another guise,though the edit history does not reflect that. Can we please just pick atopic name and stick to it? I file these by topic and this kind ofmid-topic name shift (especially without clearly identifying the intent)leaves me with two files, each containing half of the relevant mail.Some comments on the writeup itself: - I find the tone of the writeup to use a kind of bias that made it   hard to read. I'd be happier if the tone were more objective. - Proposals should not talk about changing existing documents. 88-002R   is written, fixed, and basically cannot change. What you want to change   is the part of CL which was changed by its adoption. The convention in   cleanup proposals is to refer abstractly to changing the language, so   your proposal doesn't become obsolete as the names of reference documents   change. - The problem description does not adequately describe the problem.   I suspect this is related to the tone problem, which feels like it's   emerging out of the heat of a debate to be read by someone involved   in that debate rather than that it's something intended to be read   cold by the X3J13 members not following this discussion. The latter   should be the target audience. It should be possible to read the problem   description out of context and know something interesting about CL, and   I don't think you can do that with this writeup.   We have generally used the Test Case section to describe the   proposal, not the problem, so the problem description should at   least explicitly allude to the test case as being critical to the   problem description. In fact, though, I think you need more expository   text to make it really obvious what the issue was. The first three times   I read the problem description, I thought you were just griping about   the absence of &ENVIRONMENT information going into SYMBOL-MACROLET. - I think the stated issue is really orthogonal to the proposed solutions.   For example, flushing the feature because it has a problem is the trivial   solution to almost any problem, so it doesn't really show whether your   solution is going anywhere.    The Special Form solution -- even though I like the idea of it being a   special form -- is not a solution to the stated problem. It makes this be   a non-issue for system-supplied things that can inspect the environment   information, but you don't provide access to that information for user   programs.   In my mind, part of the solution must involve the introduction of a   SYMBOL-MACRO-FUNCTION function, which is like MACRO-FUNCTION but tells   you if something is a symbol macro. This might be implementable portably,   though it would certainly be easier if it were a special form. - I observe that the change to MACROEXPAND and MACROEXPAND-1 is probably   desirable, but that this isn't the only way to do it. For example, you   could have a separate function for expanding symbol-macros, or you could   funcall SYMBOL-MACRO-FUNCTION of the symbol. Probably changing MACROEXPAND   will be the most natural way to deal with it, but I wanted to note this   flexibility for the record. - I'm personally happy to see the FLUSH option removed and have this proposal   elaborated around the special form solution since I don't think it's going   to fly and I don't personally want to waste time on it. I guess if everyone   doesn't agree on that, though, it's gotta be retained for now, though.*start*02106 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 20:31:52 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Sep 88  20:04:15 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 456000; Wed 7-Sep-88 23:03:21 EDTDate: Wed, 7 Sep 88 23:03 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: symbol-macrolet-semantics, symbol-macrolet-utilityTo: Gregor.pa, Jeffrey Piazza <piazza%lisp.DEC@decwrl.dec.com>, Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Dan L. Pierson <pierson%mist@MULTIMAX.ARPA>, Barry Margolin <barmar@Think.COM>, cl-cleanup%sail.stanford.edu@MULTIMAX.ARPAcc: Common-Lisp-Object-System@SAIL.STANFORD.EDU, cl-cleanup@SAIL.STANFORD.EDU, Jeffrey Piazza <"piazza%lisp.DEC@decwrl.dec.com"@MULTIMAX.ARPA>In-Reply-To: <871123130424.8.GREGOR@SPIFF.parc.xerox.com>,             <8806222146.AA21530@decwrl.dec.com>,             <8806281758.AA10391@decwrl.dec.com>,             <880628165306.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>,             <8806291818.AA11107@mist.UUCP>,             <19880629204455.4.GREGOR@PORTNOY.parc.xerox.com>,             <19880729021542.8.BARMAR@OCCAM.THINK.COM>,             <8807292109.AA03546@decwrl.dec.com>,             <880801135717.1.KMP@PEWEE.SCRC.Symbolics.COM>Message-ID: <19880908030301.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI thought it was already well-established that symbol-macrolet has tobe a special form, not a macro, and has to affect the behavior ofmacroexpand.  10 months ago I argued that symbol-macrolet didn'thave to be a special form, but I was quite wrong.I favor the proposal SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM exceptfor the part about forbidding use of symbol macros with SETQ(and macros such as MULTIPLE-VALUE-SETQ and PSETQ that presumablyexpand into SETQ), which I think is an unnecessary incompatiblechange.*start*00911 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 18:17:53 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 20 Sep 88  18:17:17 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 20 SEP 88 18:10:29 PDTDate: 20 Sep 88 18:10 PDTFrom: masinter.paSubject: Re: Issue: SYMBOL-MACROLET-SEMANTICS (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 1 Aug 88 13:57 EDTTo: piazza%lisp.DEC@decwrl.dec.com, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880920-181029-5268@Xerox>I would be happy to see a new writeup which addressed Kent's concerns about thewriteup itself, which had only the SPECIAL-FORM proposal and a mention of the:FLUSH option in the discussion section. Any chance of you giving it a shot inthe next week?*start*05797 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 SEP 88 11:00:45 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 21 Sep 88  10:59:15 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA24142; Wed, 21 Sep 88 10:57:54 PDTMessage-Id: <8809211757.AA24142@decwrl.dec.com>From: piazza%lisp.DEC@decwrl.dec.com (Jeffrey Piazza)Date: 21 Sep 88 13:55To: cl-cleanup@sail.stanford.eduSubject: SYMBOL-MACROLET-SEMANTICS (Version 2)Status:		For Internal DiscussionIssue:		SYMBOL-MACROLET-SEMANTICSReferences:	X3J13 document 88-002R, Chapter 2, pp. 2-81f.Category:	CHANGEEdit history:	29-July-88, Version 1 by Piazza		21-September-88, Version 2 by PiazzaProblem Description:    The SYMBOL-MACROLET construct, introduced with CLOS in X3J13 document    88-002R, profoundly alters the interpretation of symbols appearing as    forms in a Common Lisp program--what previously was necessarily a variable    might now be a symbol macro instead.  Macros which appear in the body of a    SYMBOL-MACROLET form are currently unable to determine whether a symbol    form is a variable or a symbol macro, and, if the latter, what the    expansion of the symbol macro is.  Consequently, complex macros (such as    SETF or PUSH) which depend on the form of their argument(s), are unable to    produce their desired results in some cases, as in the following example:	    (let ((a (make-array 5))		  (i 0))	      (symbol-macrolet ((place  (aref a (incf i))))	        (push x place))	      i)		==> 2Proposal (SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM):    Change the definition of SYMBOL-MACROLET to specify that it is a special    form, which affects the evaluation environment for symbols.  Enhance    MACROEXPAND and MACROEXPAND-1 so that they can expand a symbol macro.    Modify SETF et al to use the new MACROEXPAND and MACROEXPAND-1 to examine    even symbol subforms.  Specify that the expansion of a symbol macro IS    subject to further macro expansion, and that ``recursive'' symbol macros    are an error.  Specify that it is an error to try to SETQ a symbol macro.Rationale:    The potential for interaction between macros is exactly why &environment    arguments were originally added to macros.  Changing SYMBOL-MACROLET to be    a special form, which communicates through the &environment arguments to    macros with MACROEXPAND and MACROEXPAND-1, would allow PUSH and SETF    (among others) to work with SYMBOL-MACROLET in the same way they work with    MACROLET.    This change cannot (reasonably) support the currently specified semantics    that the expansion text is "outside" the scope of the symbol macro.  For    indeed, when the symbol macro is expanded, (a copy of) the expansion is    then within the scope of the SYMBOL-MACROLET, and should then be subject    to further scrutiny.  The issue of "infinite expansion" of symbol macros is    no more dangerous than that of normal macros.    Finally, the rule that SETQ of a symbol macro must be treated as a SETF of    the expansion seems to be a kludge which was introduced only to support a    code-walking version of SYMBOL-MACROLET.  If SYMBOL-MACROLET were changed    to be a special form, this rule would no longer be needed, and should be    eliminated in order to make the distinction between symbol macros and    variables cleaner.Current Practice:    Portable Common Loops provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.  Symbolics Cloe has both a    code-walking version of a SYMBOL-MACROLET macro and compiler support for    a SYMBOL-MACROLET special form.Cost to Implementors:    If SYMBOL-MACROLET is modified to be a special form, compilers and    interpreters will have to change, as well as MACROEXPAND, MACROEXPAND-1,    PUSH, INCF, DECF, and others.Cost to Users:    If SYMBOL-MACROLET is converted to a special form, code-walking programs    will have to be modified to handle SYMBOL-MACROLET correctly.  Those same    programs would have to be modified to handle the other special forms    specified in CLOS, anyway.Cost of Non-Adoption:    SYMBOL-MACROLET will retain its confusing semantics, leading to bugs when    it interacts with complex macros and forms which produce side-effects.    Implementations which support ONCE-ONLY will break.  For that matter, any    mechanism which examines code and assumes that "variables" have no side    effects will break.Benefits:    SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM avoids the hairiest problems    surrounding interaction of macros (like SETF) and side effects, and makes    SYMBOL-MACROLET consistent with MACROLET.Aesthetics:    If SYMBOL-MACROLET is made to be a special form, aesthetics are improved    by making symbol macros consistent with normal macros.Discussion:    A case could be made for adding a new function, SYMBOL-MACRO-FUNCTION, as    a dual of MACRO-FUNCTION.  However, symbol macros are simpler than normal    macros: a symbol macro is associated with a single expansion form, rather    than an arbitrary function which computes the expansion.  For this reason,    the augmented MACROEXPAND-1 proposed here can also fill the role of    SYMBOL-MACRO-FUNCTION: the second value of (macroexpand-1 sym env) will be    T if and only if sym is a symbol macro, while the first value gives the    expansion of sym, if it has one.    Also, Pitman points out that, rather than extending the existing    MACROEXPAND and MACROEXPAND-1 functions, new functions could be introduced    to expand symbol macros.  However, there seems to be no particular reason    to do this.*start*01230 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 SEP 88 13:02:34 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Sep 88  13:02:27 PDTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA05757g; Wed, 21 Sep 88 12:00:43 PSTReceived: by blacksox id AA01195g; Wed, 21 Sep 88 12:58:25 pdtDate: Wed, 21 Sep 88 12:58:25 pdtFrom: Eric Benson <eb@lucid.com>Message-Id: <8809211958.AA01195@blacksox>To: piazza%lisp.DEC@decwrl.dec.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Jeffrey Piazza's message of 21 Sep 88 13:55 <8809211757.AA24142@decwrl.dec.com>Subject: SYMBOL-MACROLET-SEMANTICS (Version 2)Shouldn't SETQ of a symbol macro be permitted, and defined to be thesame as SETF?You should clarify the statement that ``recursive'' symbol macros arean error.  Certainly it is legal for one symbol macro to expand intoanother, or for a symbol macro to expand into a regular macro callwhich expands into a (different) symbol macro.  Perhaps``self-recursive'' would be better.Should there be a global version of SYMBOL-MACROLET, i.e.DEFINE-SYMBOL-MACRO?*start*01725 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 SEP 88 10:16:18 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Sep 88  10:15:39 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 464013; Thu 22-Sep-88 13:13:40 EDTDate: Thu, 22 Sep 88 13:13 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SYMBOL-MACROLET-SEMANTICS (Version 2)To: Jeffrey Piazza <piazza%lisp.DEC@decwrl.dec.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8809211757.AA24142@decwrl.dec.com>Message-ID: <19880922171345.1.MOON@EUPHRATES.SCRC.Symbolics.COM>I support SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM, with a coupleof important reservations, which are basically the same as EricBenson's comments:SETQ of a symbol macro must be allowed.  The reason given for removingit is wrong -- SETQ of symbol macros was allowed in order to avoidmaking any distinction between symbol macros and variables, which isthe only reason symbol macros are used by CLOS at all.The comment about "recursive symbol macros" doesn't make any sense tome.  I don't think it would hurt the proposal to take it out.  Sayingthat expansions of symbol macros are subject to further expansion inthe same lexical environment as the symbol macro invocation, exactlyanalogous to normal macros, is sufficient.  If and when Common Lispis changed to provide more careful control over the lexical environmentof macro expansions, the same mechanism should work for both normalmacros and symbol macros.*start*05580 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 SEP 88 10:48:04 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 22 Sep 88  10:47:19 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA27618; Thu, 22 Sep 88 10:45:55 PDTDate: Thu, 22 Sep 88 10:45:55 PDTMessage-Id: <8809221745.AA27618@decwrl.dec.com>From: piazza%lisp.DEC@decwrl.dec.com (Jeffrey Piazza)To: cl-cleanup@sail.stanford.eduSubject: Issue SYMBOL-MACROLET-SEMANTICS, Version 4[ Sorry-- I removed the language about SETQ from the proposal, but left it inthe Rationale by oversight. ]Status:		For Internal DiscussionIssue:		SYMBOL-MACROLET-SEMANTICSReferences:	X3J13 document 88-002R, Chapter 2, pp. 2-81f.Category:	CHANGEEdit history:	29-July-88, Version 1 by Piazza		21-September-88, Version 2 by Piazza		22-September-88, Version 3 by Piazza 		22-September-88, Version 4 by PiazzaProblem Description:    The SYMBOL-MACROLET construct, introduced with CLOS in X3J13 document    88-002R, profoundly alters the interpretation of symbols appearing as    forms in a Common Lisp program--what previously was necessarily a variable    might now be a symbol macro instead.  Macros which appear in the body of a    SYMBOL-MACROLET form are currently unable to determine whether a symbol    form is a variable or a symbol macro, and, if the latter, what the    expansion of the symbol macro is.  Consequently, complex macros (such as    SETF or PUSH) which depend on the form of their argument(s), are unable to    produce their desired results in some cases, as in the following example:	    (let ((a (make-array 5))		  (i 0))	      (symbol-macrolet ((place  (aref a (incf i))))	        (push x place))	      i)		==> 2Proposal (SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM):    Change the definition of SYMBOL-MACROLET to specify that it is a special    form, which affects the evaluation environment for symbols.  Enhance    MACROEXPAND and MACROEXPAND-1 so that they can expand a symbol macro.    Modify SETF et al to use the new MACROEXPAND and MACROEXPAND-1 to examine    even symbol subforms.  Specify that the expansion of a symbol macro IS    subject to further macro expansion in the same lexical environment as the    symbol macro invocation, exactly analogous to normal macros.Rationale:    The potential for interaction between macros is exactly why &environment    arguments were originally added to macros.  Changing SYMBOL-MACROLET to be    a special form, which communicates through the &environment arguments to    macros with MACROEXPAND and MACROEXPAND-1, would allow PUSH and SETF    (among others) to work with SYMBOL-MACROLET in the same way they work with    MACROLET.    This change cannot (reasonably) support the currently specified semantics    that the expansion text is "outside" the scope of the symbol macro.  For    indeed, when the symbol macro is expanded, (a copy of) the expansion is    then within the scope of the SYMBOL-MACROLET, and should then be subject    to further scrutiny.  The issue of "infinite expansion" of symbol macros is    no more dangerous than that of normal macros.Current Practice:    Portable Common Loops provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.  Symbolics Cloe has both a    code-walking version of a SYMBOL-MACROLET macro and compiler support for    a SYMBOL-MACROLET special form.Cost to Implementors:    If SYMBOL-MACROLET is modified to be a special form, compilers and    interpreters will have to change, as well as MACROEXPAND, MACROEXPAND-1,    PUSH, INCF, DECF, and others.Cost to Users:    If SYMBOL-MACROLET is converted to a special form, code-walking programs    will have to be modified to handle SYMBOL-MACROLET correctly.  Those same    programs would have to be modified to handle the other special forms    specified in CLOS, anyway.Cost of Non-Adoption:    SYMBOL-MACROLET will retain its confusing semantics, leading to bugs when    it interacts with complex macros and forms which produce side-effects.    Implementations which support ONCE-ONLY will break.  For that matter, any    mechanism which examines code and assumes that "variables" have no side    effects will break.Benefits:    SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM avoids the hairiest problems    surrounding interaction of macros (like SETF) and side effects, and makes    SYMBOL-MACROLET consistent with MACROLET.Aesthetics:    If SYMBOL-MACROLET is made to be a special form, aesthetics are improved    by making symbol macros consistent with normal macros.Discussion:    A case could be made for adding a new function, SYMBOL-MACRO-FUNCTION, as    a dual of MACRO-FUNCTION.  However, symbol macros are simpler than normal    macros: a symbol macro is associated with a single expansion form, rather    than an arbitrary function which computes the expansion.  For this reason,    the augmented MACROEXPAND-1 proposed here can also fill the role of    SYMBOL-MACRO-FUNCTION: the second value of (macroexpand-1 sym env) will be    T if and only if sym is a symbol macro, while the first value gives the    expansion of sym, if it has one.    Also, Pitman points out that, rather than extending the existing    MACROEXPAND and MACROEXPAND-1 functions, new functions could be introduced    to expand symbol macros.  However, there seems to be no particular reason    to do this.*start*01274 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 17:52:27 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  17:52:35 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472928; Fri 7-Oct-88 20:50:22 EDTDate: Fri, 7 Oct 88 20:50 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue SYMBOL-MACROLET-SEMANTICS, Version 4To: Jeffrey Piazza <piazza%lisp.DEC@decwrl.dec.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8809221745.AA27618@decwrl.dec.com>Message-ID: <19881008005004.1.MOON@EUPHRATES.SCRC.Symbolics.COM>I would strongly support SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM inversion 4, if the following comment had been taken into account.As it stands I have to oppose it.SETQ of a symbol macro must be allowed.  The reason given [only in olderversions of the proposal] for removing it is wrong -- SETQ of symbolmacros was allowed in order to avoid making any distinction betweensymbol macros and variables, which is the only reason symbol macros areused by CLOS at all.*start*05235 00024 USfDate:  8 Oct 88 22:00 PDTSender: masinter.paSubject: DRAFT Issue SYMBOL-MACROLET-SEMANTICS, Version 4From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterThis is DRAFT because of some confusion over the handlingof SETQ of symbol-macros.Issue:		SYMBOL-MACROLET-SEMANTICSReferences:	X3J13 document 88-002R, Chapter 2, pp. 2-81f.Category:	CHANGEEdit history:	29-July-88, Version 1 by Piazza		21-September-88, Version 2 by Piazza		22-September-88, Version 3 by Piazza 		22-September-88, Version 4 by PiazzaProblem Description:    The SYMBOL-MACROLET construct, introduced with CLOS in X3J13 document    88-002R, profoundly alters the interpretation of symbols appearing as    forms in a Common Lisp program--what previously was necessarily a variable    might now be a symbol macro instead.  Macros which appear in the body of a    SYMBOL-MACROLET form are currently unable to determine whether a symbol    form is a variable or a symbol macro, and, if the latter, what the    expansion of the symbol macro is.  Consequently, complex macros (such as    SETF or PUSH) which depend on the form of their argument(s), are unable to    produce their desired results in some cases, as in the following example:	    (let ((a (make-array 5))		  (i 0))	      (symbol-macrolet ((place  (aref a (incf i))))	        (push x place))	      i)		==> 2Proposal (SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM):    Change the definition of SYMBOL-MACROLET to specify that it is a special    form, which affects the evaluation environment for symbols.  Enhance    MACROEXPAND and MACROEXPAND-1 so that they can expand a symbol macro.    Modify SETF et al to use the new MACROEXPAND and MACROEXPAND-1 to examine    even symbol subforms.  Specify that the expansion of a symbol macro IS    subject to further macro expansion in the same lexical environment as the    symbol macro invocation, exactly analogous to normal macros.Rationale:    The potential for interaction between macros is exactly why &environment    arguments were originally added to macros.  Changing SYMBOL-MACROLET to be    a special form, which communicates through the &environment arguments to    macros with MACROEXPAND and MACROEXPAND-1, would allow PUSH and SETF    (among others) to work with SYMBOL-MACROLET in the same way they work with    MACROLET.    This change cannot (reasonably) support the currently specified semantics    that the expansion text is "outside" the scope of the symbol macro.  For    indeed, when the symbol macro is expanded, (a copy of) the expansion is    then within the scope of the SYMBOL-MACROLET, and should then be subject    to further scrutiny.  The issue of "infinite expansion" of symbol macros is    no more dangerous than that of normal macros.Current Practice:    Portable Common Loops provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.  Symbolics Cloe has both a    code-walking version of a SYMBOL-MACROLET macro and compiler support for    a SYMBOL-MACROLET special form.Cost to Implementors:    If SYMBOL-MACROLET is modified to be a special form, compilers and    interpreters will have to change, as well as MACROEXPAND, MACROEXPAND-1,    PUSH, INCF, DECF, and others.Cost to Users:    If SYMBOL-MACROLET is converted to a special form, code-walking programs    will have to be modified to handle SYMBOL-MACROLET correctly.  Those same    programs would have to be modified to handle the other special forms    specified in CLOS, anyway.Cost of Non-Adoption:    SYMBOL-MACROLET will retain its confusing semantics, leading to bugs when    it interacts with complex macros and forms which produce side-effects.    Implementations which support ONCE-ONLY will break.  For that matter, any    mechanism which examines code and assumes that "variables" have no side    effects will break.Benefits:    SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM avoids the hairiest problems    surrounding interaction of macros (like SETF) and side effects, and makes    SYMBOL-MACROLET consistent with MACROLET.Aesthetics:    If SYMBOL-MACROLET is made to be a special form, aesthetics are improved    by making symbol macros consistent with normal macros.Discussion:    A case could be made for adding a new function, SYMBOL-MACRO-FUNCTION, as    a dual of MACRO-FUNCTION.  However, symbol macros are simpler than normal    macros: a symbol macro is associated with a single expansion form, rather    than an arbitrary function which computes the expansion.  For this reason,    the augmented MACROEXPAND-1 proposed here can also fill the role of    SYMBOL-MACRO-FUNCTION: the second value of (macroexpand-1 sym env) will be    T if and only if sym is a symbol macro, while the first value gives the    expansion of sym, if it has one.    Also, Pitman points out that, rather than extending the existing    MACROEXPAND and MACROEXPAND-1 functions, new functions could be introduced    to expand symbol macros.  However, there seems to be no particular reason    to do this.     ----- End Forwarded Messages -----*start*01837 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 19:44:58 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  19:43:22 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA27682; Thu, 13 Oct 88 17:09:04 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19978; Thu, 13 Oct 88 17:08:59 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132308.AA19978@defun.utah.edu>Date: Thu, 13 Oct 88 17:08:55 MDTSubject: issue SYMBOL-MACROLET-SEMANTICSTo: cl-cleanup@sail.stanford.eduThis seems like a reasonable thing to do here.  The only seriousproblem I see is that the description of SYMBOL-MACROLET in the CLOSdocument says that it changes SETQ's of the symbols in the body toSETF's during macro expansion.  Now that you are proposing thatSYMBOL-MACROLET won't be a macro any more, I think you have to specifya change in the behavior of SETQ as well as SETF.  It seems like theywould have to be pretty much the same now, right?I am a bit concerned about how this proposal interacts with the SETFprocessing model specified in issue SETF-FUNCTION-VS-MACRO -- with thedescription of SETF being distributed in several places, somethingmight get overlooked in the final standards document. Another thing is that I really don't like the name SYMBOL-MACROLET andas long as you are proposing to make it a special form, you might aswell try to change the name to something nicer at the same time.  Forone thing, it might be confusing because the "bodies" of the macrosare substituted directly in one case and evaluated in another.  Ifcompatibility is a problem implementations could keep SYMBOL-MACROLETdefined as a macro.-Sandra-------*start*00843 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 OCT 88 08:01:33 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 10 Oct 88  08:00:41 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA16527; Mon, 10 Oct 88 07:58:18 PDTDate: Mon, 10 Oct 88 07:58:18 PDTMessage-Id: <8810101458.AA16527@decwrl.dec.com>From: piazza%lisp.DEC@decwrl.dec.com (Jeffrey Piazza)To: Moon@stony-brook.scrc.symbolics.comSubject: RE: Issue SYMBOL-MACROLET-SEMANTICS, Version 4Maybe I mailed out something other than the text I kept, but my copy has allreference to SETQ of a symbol macro removed.  Since 88-002R specifies that SETQof a symbol macro is OK, then it should remain OK.  Did I overlook something?/JEP*start*01019 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 15:42:41 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 18 Oct 88  15:41:45 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA06396g; Tue, 18 Oct 88 15:41:37 PDTReceived: by bhopal id AA02072g; Tue, 18 Oct 88 15:40:02 PDTDate: Tue, 18 Oct 88 15:40:02 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810182240.AA02072@bhopal>To: cl-cleanup@sail.stanford.eduIn-Reply-To: cl-cleanup@sail.stanford.edu's message of 8 Oct 88 21:58 PDT <881008-215806-2579@Xerox>Subject: DRAFT Issue: SYMBOL-MACROLET-DECLARE (version 1)This issue should be folded into SYMBOL-MACROLET-SEMANTICS; it would behardly one line in the descripton of SYMBOL-MACROLET as a special form.Since it looks like SYMBOL-MACROLET-SEMANTICS is not very controversialanymore, I see no reason to support separate proposals.-- JonL --*start*02379 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 21:03:52 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Oct 88  21:02:39 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 482776; Thu 27-Oct-88 00:02:49 EDTDate: Thu, 27 Oct 88 00:02 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue SYMBOL-MACROLET-SEMANTICSTo: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8810132308.AA19978@defun.utah.edu>Message-ID: <19881027040234.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 13 Oct 88 17:08:55 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    This seems like a reasonable thing to do here.  The only serious    problem I see is that the description of SYMBOL-MACROLET in the CLOS    document says that it changes SETQ's of the symbols in the body to    SETF's during macro expansion.  Now that you are proposing that    SYMBOL-MACROLET won't be a macro any more, I think you have to specify    a change in the behavior of SETQ as well as SETF.  It seems like they    would have to be pretty much the same now, right?Yes.    I am a bit concerned about how this proposal interacts with the SETF    processing model specified in issue SETF-FUNCTION-VS-MACRO -- with the    description of SETF being distributed in several places, something    might get overlooked in the final standards document. How could they interact, when SYMBOL-MACROLET-SEMANTICS applies when the<place> subform of SETF is a symbol, and SETF-FUNCTION-VS-MACRO applieswhen the <place> subform of SETF is a cons?  It's true that the numberof issues being addressed simultaneously is getting out of hand; theextremely long delay in resolving some issues is making this worse.    Another thing is that I really don't like the name SYMBOL-MACROLET and    as long as you are proposing to make it a special form, you might as    well try to change the name to something nicer at the same time.  I'm afraid I don't follow your syllogism here.  Also I think you'd haveto make a specific proposal of a new name to get anyone to pay attention.*start*05578 00024 USfDate: 30 Nov 88 18:45 PSTFrom: masinter.paSubject: Issue SYMBOL-MACROLET-SEMANTICS, Version 5To: cl-cleanup@sail.stanford.eduline-fold: NOcc: piazza%lisp.DEC@decwrl.dec.com, masinterI added a sentence clarifying that SYMBOL-MACROLET stillaffects SETQ within its body even though it is a special form.Issue:		SYMBOL-MACROLET-SEMANTICSReferences:	SYMBOL-MACROLET (88-002R page 2-81)Related Issues: SYMBOL-MACROLET-DECLARECategory:	CHANGEEdit history:	29-July-88, Version 1 by Piazza		21-September-88, Version 2 by Piazza		22-September-88, Version 3 by Piazza 		22-September-88, Version 4 by Piazza		30-Nov-88, Version 5 by MasinterProblem Description:    The SYMBOL-MACROLET construct, introduced with CLOS in X3J13 document    88-002R, profoundly alters the interpretation of symbols appearing as    forms in a Common Lisp program--what previously was necessarily a variable    might now be a symbol macro instead.  Macros which appear in the body of a    SYMBOL-MACROLET form are currently unable to determine whether a symbol    form is a variable or a symbol macro, and, if the latter, what the    expansion of the symbol macro is.  Consequently, complex macros (such as    SETF or PUSH) which depend on the form of their argument(s), are unable to    produce their desired results in some cases, as in the following example:	    (let ((a (make-array 5))		  (i 0))	      (symbol-macrolet ((place  (aref a (incf i))))	        (push x place))	      i)		==> 2    In addition, it would be both natural and nice to be able to write  (with-slots (rho theta) point    (declare (single-float rho theta))    ...computation...)    as well as DECLARE within SYMBOL-MACROLET forms.Proposal (SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM):    Change the definition of SYMBOL-MACROLET to specify that it is a special    form, which affects the evaluation environment for symbols.  Enhance    MACROEXPAND and MACROEXPAND-1 so that they can expand a symbol macro.    Modify SETF et al to use the new MACROEXPAND and MACROEXPAND-1 to examine    even symbol subforms.  Specify that the expansion of a symbol macro IS    subject to further macro expansion in the same lexical environment as the    symbol macro invocation, exactly analogous to normal macros. Clarify that    within the body of a SYMBOL-MACROLET, SETQ of a symbol defined as    a symbol macro will be treated as if it were a SETF.Rationale:    The potential for interaction between macros is exactly why &environment    arguments were originally added to macros.  Changing SYMBOL-MACROLET to be    a special form, which communicates through the &environment arguments to    macros with MACROEXPAND and MACROEXPAND-1, would allow PUSH and SETF    (among others) to work with SYMBOL-MACROLET in the same way they work with    MACROLET.    This change cannot (reasonably) support the currently specified semantics    that the expansion text is "outside" the scope of the symbol macro.  For    indeed, when the symbol macro is expanded, (a copy of) the expansion is    then within the scope of the SYMBOL-MACROLET, and should then be subject    to further scrutiny.  The issue of "infinite expansion" of symbol macros is    no more dangerous than that of normal macros.Current Practice:    Portable Common Loops provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.  Symbolics Cloe has both a    code-walking version of a SYMBOL-MACROLET macro and compiler support for    a SYMBOL-MACROLET special form.Cost to Implementors:    If SYMBOL-MACROLET is modified to be a special form, compilers and    interpreters will have to change, as well as MACROEXPAND, MACROEXPAND-1,    PUSH, INCF, DECF, and others.Cost to Users:    If SYMBOL-MACROLET is converted to a special form, code-walking programs    will have to be modified to handle SYMBOL-MACROLET correctly.  Those same    programs would have to be modified to handle the other special forms    specified in CLOS, anyway.Cost of Non-Adoption:    SYMBOL-MACROLET will retain its confusing semantics, leading to bugs when    it interacts with complex macros and forms which produce side-effects.    Implementations which support ONCE-ONLY will break.  For that matter, any    mechanism which examines code and assumes that "variables" have no side    effects will break.Benefits:    SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM avoids the hairiest problems    surrounding interaction of macros (like SETF) and side effects, and makes    SYMBOL-MACROLET consistent with MACROLET.Aesthetics:    If SYMBOL-MACROLET is made to be a special form, aesthetics are improved    by making symbol macros consistent with normal macros.Discussion:    A case could be made for adding a new function, SYMBOL-MACRO-FUNCTION, as    a dual of MACRO-FUNCTION.  However, symbol macros are simpler than normal    macros: a symbol macro is associated with a single expansion form, rather    than an arbitrary function which computes the expansion.  For this reason,    the augmented MACROEXPAND-1 proposed here can also fill the role of    SYMBOL-MACRO-FUNCTION: the second value of (macroexpand-1 sym env) will be    T if and only if sym is a symbol macro, while the first value gives the    expansion of sym, if it has one.    Rather than extending the existing MACROEXPAND and MACROEXPAND-1   functions, new functions could be introduced to expand symbol macros.    However, there seems to be no particular reason to do this.*start*05753 00024 US Date:  9 Dec 88 10:40 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: SYMBOL-MACROLET-SEMANTICS (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noIssue:          SYMBOL-MACROLET-SEMANTICSReferences:     SYMBOL-MACROLET (88-002R page 2-81)Related Issues: SYMBOL-MACROLET-DECLARECategory:       CHANGEEdit history:   29-July-88, Version 1 by Piazza                21-September-88, Version 2 by Piazza                22-September-88, Version 3 by Piazza                 22-September-88, Version 4 by Piazza                30-Nov-88, Version 5 by MasinterProblem Description:    The SYMBOL-MACROLET construct, introduced with CLOS in X3J13 document    88-002R, profoundly alters the interpretation of symbols appearing as    forms in a Common Lisp program--what previously was necessarily a variable    might now be a symbol macro instead.  Macros which appear in the body of a    SYMBOL-MACROLET form are currently unable to determine whether a symbol    form is a variable or a symbol macro, and, if the latter, what the    expansion of the symbol macro is.  Consequently, complex macros (such as    SETF or PUSH) which depend on the form of their argument(s), are unable to    produce their desired results in some cases, as in the following example:            (let ((a (make-array 5))                  (i 0))              (symbol-macrolet ((place  (aref a (incf i))))                (push x place))              i)                ==> 2Proposal (SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM):    Change the definition of SYMBOL-MACROLET to specify that it is a special    form, which affects the evaluation environment for symbols.  Enhance    MACROEXPAND and MACROEXPAND-1 so that they can expand a symbol macro.    Modify SETF et al to use the new MACROEXPAND and MACROEXPAND-1 to examine    even symbol subforms.  Specify that the expansion of a symbol macro IS    subject to further macro expansion in the same lexical environment as the    symbol macro invocation, exactly analogous to normal macros. Clarify that    within the body of a SYMBOL-MACROLET, SETQ of a symbol defined as    a symbol macro will be treated as if it were a SETF.Rationale:    The potential for interaction between macros is exactly why &environment    arguments were originally added to macros.  Changing SYMBOL-MACROLET to be    a special form, which communicates through the &environment arguments to    macros with MACROEXPAND and MACROEXPAND-1, would allow PUSH and SETF    (among others) to work with SYMBOL-MACROLET in the same way they work with    MACROLET.    This change cannot (reasonably) support the currently specified semantics    that the expansion text is "outside" the scope of the symbol macro.  For    indeed, when the symbol macro is expanded, (a copy of) the expansion is    then within the scope of the SYMBOL-MACROLET, and should then be subject    to further scrutiny.  The issue of "infinite expansion" of symbol macros is    no more dangerous than that of normal macros.Current Practice:    Portable CommonLoops (PCL) provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.  Symbolics Cloe has both a    code-walking version of a SYMBOL-MACROLET macro and compiler support for    a SYMBOL-MACROLET special form.Cost to Implementors:    If SYMBOL-MACROLET is modified to be a special form, compilers and    interpreters will have to change, as well as MACROEXPAND, MACROEXPAND-1,    PUSH, INCF, DECF, and others.Cost to Users:    If SYMBOL-MACROLET is converted to a special form, code-walking programs    will have to be modified to handle SYMBOL-MACROLET correctly.  Those same    programs would have to be modified to handle the other special forms    specified in CLOS, anyway.Cost of Non-Adoption:    SYMBOL-MACROLET will retain its confusing semantics, leading to bugs when    it interacts with complex macros and forms which produce side-effects.    Implementations which support ONCE-ONLY will break.  For that matter, any    mechanism which examines code and assumes that "variables" have no side    effects will break.Benefits:    SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM avoids the hairiest problems    surrounding interaction of macros (like SETF) and side effects, and makes    SYMBOL-MACROLET consistent with MACROLET.Aesthetics:    If SYMBOL-MACROLET is made to be a special form, aesthetics are improved    by making symbol macros consistent with normal macros.Discussion:    A case could be made for adding a new function, SYMBOL-MACRO-FUNCTION, as    a dual of MACRO-FUNCTION.  However, symbol macros are simpler than normal    macros: a symbol macro is associated with a single expansion form, rather    than an arbitrary function which computes the expansion.  For this reason,    the augmented MACROEXPAND-1 proposed here can also fill the role of    SYMBOL-MACRO-FUNCTION: the second value of (macroexpand-1 sym env) will be    T if and only if sym is a symbol macro, while the first value gives the    expansion of sym, if it has one.    Rather than extending the existing MACROEXPAND and MACROEXPAND-1    functions, new functions could be introduced to expand symbol macros.     However, there seems to be no particular reason to do this.        TITAN 
         TITAN 
           Z                                   $                                                       r       3                   H                                                     N       
                                          z*start*05735 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 11:01:34 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  10:47:26 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 10:40:52 PSTDate: 9 Dec 88 10:40 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: SYMBOL-MACROLET-SEMANTICS (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881209-104052-6470@Xerox>!Issue:          SYMBOL-MACROLET-SEMANTICSReferences:     SYMBOL-MACROLET (88-002R page 2-81)Related Issues: SYMBOL-MACROLET-DECLARECategory:       CHANGEEdit history:   29-July-88, Version 1 by Piazza                21-September-88, Version 2 by Piazza                22-September-88, Version 3 by Piazza                 22-September-88, Version 4 by Piazza                30-Nov-88, Version 5 by MasinterProblem Description:    The SYMBOL-MACROLET construct, introduced with CLOS in X3J13 document    88-002R, profoundly alters the interpretation of symbols appearing as    forms in a Common Lisp program--what previously was necessarily a variable    might now be a symbol macro instead.  Macros which appear in the body of a    SYMBOL-MACROLET form are currently unable to determine whether a symbol    form is a variable or a symbol macro, and, if the latter, what the    expansion of the symbol macro is.  Consequently, complex macros (such as    SETF or PUSH) which depend on the form of their argument(s), are unable to    produce their desired results in some cases, as in the following example:            (let ((a (make-array 5))                  (i 0))              (symbol-macrolet ((place  (aref a (incf i))))                (push x place))              i)                ==> 2Proposal (SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM):    Change the definition of SYMBOL-MACROLET to specify that it is a special    form, which affects the evaluation environment for symbols.  Enhance    MACROEXPAND and MACROEXPAND-1 so that they can expand a symbol macro.    Modify SETF et al to use the new MACROEXPAND and MACROEXPAND-1 to examine    even symbol subforms.  Specify that the expansion of a symbol macro IS    subject to further macro expansion in the same lexical environment as the    symbol macro invocation, exactly analogous to normal macros. Clarify that    within the body of a SYMBOL-MACROLET, SETQ of a symbol defined as    a symbol macro will be treated as if it were a SETF.Rationale:    The potential for interaction between macros is exactly why &environment    arguments were originally added to macros.  Changing SYMBOL-MACROLET to be    a special form, which communicates through the &environment arguments to    macros with MACROEXPAND and MACROEXPAND-1, would allow PUSH and SETF    (among others) to work with SYMBOL-MACROLET in the same way they work with    MACROLET.    This change cannot (reasonably) support the currently specified semantics    that the expansion text is "outside" the scope of the symbol macro.  For    indeed, when the symbol macro is expanded, (a copy of) the expansion is    then within the scope of the SYMBOL-MACROLET, and should then be subject    to further scrutiny.  The issue of "infinite expansion" of symbol macros is    no more dangerous than that of normal macros.Current Practice:    Portable CommonLoops (PCL) provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.  Symbolics Cloe has both a    code-walking version of a SYMBOL-MACROLET macro and compiler support for    a SYMBOL-MACROLET special form.Cost to Implementors:    If SYMBOL-MACROLET is modified to be a special form, compilers and    interpreters will have to change, as well as MACROEXPAND, MACROEXPAND-1,    PUSH, INCF, DECF, and others.Cost to Users:    If SYMBOL-MACROLET is converted to a special form, code-walking programs    will have to be modified to handle SYMBOL-MACROLET correctly.  Those same    programs would have to be modified to handle the other special forms    specified in CLOS, anyway.Cost of Non-Adoption:    SYMBOL-MACROLET will retain its confusing semantics, leading to bugs when    it interacts with complex macros and forms which produce side-effects.    Implementations which support ONCE-ONLY will break.  For that matter, any    mechanism which examines code and assumes that "variables" have no side    effects will break.Benefits:    SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM avoids the hairiest problems    surrounding interaction of macros (like SETF) and side effects, and makes    SYMBOL-MACROLET consistent with MACROLET.Aesthetics:    If SYMBOL-MACROLET is made to be a special form, aesthetics are improved    by making symbol macros consistent with normal macros.Discussion:    A case could be made for adding a new function, SYMBOL-MACRO-FUNCTION, as    a dual of MACRO-FUNCTION.  However, symbol macros are simpler than normal    macros: a symbol macro is associated with a single expansion form, rather    than an arbitrary function which computes the expansion.  For this reason,    the augmented MACROEXPAND-1 proposed here can also fill the role of    SYMBOL-MACRO-FUNCTION: the second value of (macroexpand-1 sym env) will be    T if and only if sym is a symbol macro, while the first value gives the    expansion of sym, if it has one.    Rather than extending the existing MACROEXPAND and MACROEXPAND-1    functions, new functions could be introduced to expand symbol macros.     However, there seems to be no particular reason to do this.*start*01050 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 13:07:07 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 6 Feb 89  13:07:28 PSTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA20453; Mon, 6 Feb 89 14:05:56 -0700Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA00450; Mon, 6 Feb 89 14:05:54 -0700From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8902062105.AA00450@defun.utah.edu>Date: Mon, 6 Feb 89 14:05:52 MSTSubject: issue SYMBOL-MACROLET-SEMANTICSTo: cl-cleanup@sail.stanford.edu, common-lisp-object-system@sail.stanford.eduThis proposal, which passed at the January meeting, contains thephrase: "Specify that the expansion of a symbol macro IS subject tofurther macro expansion in the same lexical environment as the symbolmacro invocation." Just to clarify this, does this mean that thesecond example from p 2-81 of 88-002R is now incorrect?-Sandra-------*start*01280 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 13:16:44 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Feb 89  13:16:12 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 534374; Mon 6-Feb-89 16:13:53 ESTDate: Mon, 6 Feb 89 16:14 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue SYMBOL-MACROLET-SEMANTICSTo: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: cl-cleanup@SAIL.STANFORD.EDU, common-lisp-object-system@SAIL.STANFORD.EDUIn-Reply-To: <8902062105.AA00450@defun.utah.edu>Message-ID: <19890206211426.9.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 6 Feb 89 14:05:52 MST    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    This proposal, which passed at the January meeting, contains the    phrase: "Specify that the expansion of a symbol macro IS subject to    further macro expansion in the same lexical environment as the symbol    macro invocation." Just to clarify this, does this mean that the    second example from p 2-81 of 88-002R is now incorrect?Yes.*start*07243 00024 USfGV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 14-Mar-89 16:12:59 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 16:12:44 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 14 Mar 89  16:12:48 PSTReceived: from fafnir.think.com by Think.COM; Tue, 14 Mar 89 16:42:18 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Tue, 14 Mar 89 16:43:40 ESTReceived: by verdi.think.com; Tue, 14 Mar 89 16:40:28 ESTDate: Tue, 14 Mar 89 16:40:28 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903142140.AA05308@verdi.think.com>To: cl-cleanup@sail.stanford.eduCc: gls@Think.COMSubject: SYMBOL-MACROLET-SEMANTICS, version 6This is a proposal to amend version 5, passed in January 1989 in Kauai.Version 6 amends version 5 to require PSETQ to behave like PSETF,to require MULTIPLE-VALUE-SETQ to accept symbol macros (but notgeneral SETF places), and to specify the interaction with the*MACROEXPAND-HOOK* function.Issue:		SYMBOL-MACROLET-SEMANTICSReferences:	SYMBOL-MACROLET (88-002R page 2-81)Related Issues: SYMBOL-MACROLET-DECLARECategory:	CHANGEEdit history:	29-July-88, Version 1 by Piazza		21-September-88, Version 2 by Piazza		22-September-88, Version 3 by Piazza 		22-September-88, Version 4 by Piazza		30-Nov-88, Version 5 by Masinter		14-Mar-89, Version 6 by SteeleProblem Description:    The SYMBOL-MACROLET construct, introduced with CLOS in X3J13 document    88-002R, profoundly alters the interpretation of symbols appearing as    forms in a Common Lisp program--what previously was necessarily a variable    might now be a symbol macro instead.  Macros which appear in the body of a    SYMBOL-MACROLET form are currently unable to determine whether a symbol    form is a variable or a symbol macro, and, if the latter, what the    expansion of the symbol macro is.  Consequently, complex macros (such as    SETF or PUSH) which depend on the form of their argument(s), are unable to    produce their desired results in some cases, as in the following example:	    (let ((a (make-array 5))		  (i 0))	      (symbol-macrolet ((place  (aref a (incf i))))	        (push x place))	      i)		==> 2    In addition, it would be both natural and nice to be able to write  (with-slots (rho theta) point    (declare (single-float rho theta))    ...computation...)    as well as DECLARE within SYMBOL-MACROLET forms.Proposal (SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM):    Change the definition of SYMBOL-MACROLET to specify that it is a special    form, which affects the evaluation environment for symbols.  Enhance    MACROEXPAND and MACROEXPAND-1 so that they can expand a symbol macro.    Modify SETF et al to use the new MACROEXPAND and MACROEXPAND-1 to examine    even symbol subforms.  Specify that the expansion of a symbol macro IS    subject to further macro expansion in the same lexical environment as the    symbol macro invocation, exactly analogous to normal macros. Clarify that    within the body of a SYMBOL-MACROLET, SETQ of a symbol defined as    a symbol macro will be treated as if it were a SETF.    Furthermore PSETQ of a symbol defined as a symbol macro will    behave as if it were a PSETF, and MULTIPLE-VALUE-SETQ will behave    as if SETQ were used on each variable to be set.    When MACROEXPAND or MACROEXPAND-1 sees a symbol macro, it calls    the value of *MACROEXPAND-HOOK* in the same manner as for an    ordinary macro.  The three values given to the hook function    in this case will be an expansion function, a form (in this case    the symbol naming the symbol macro), and an environment.  The    only guaranteed property of the expansion function is that when    it is applied to the form and the environment it will return the    correct expansion of the symbol macro.  (In particular, nothing    it said in this specification whether the expansion is conceptually    stored in the expansion function, the environment, or both.)Rationale:    The potential for interaction between macros is exactly why &environment    arguments were originally added to macros.  Changing SYMBOL-MACROLET to be    a special form, which communicates through the &environment arguments to    macros with MACROEXPAND and MACROEXPAND-1, would allow PUSH and SETF    (among others) to work with SYMBOL-MACROLET in the same way they work with    MACROLET.    This change cannot (reasonably) support the currently specified semantics    that the expansion text is "outside" the scope of the symbol macro.  For    indeed, when the symbol macro is expanded, (a copy of) the expansion is    then within the scope of the SYMBOL-MACROLET, and should then be subject    to further scrutiny.  The issue of "infinite expansion" of symbol macros is    no more dangerous than that of normal macros.Current Practice:    Portable Common Loops provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.  Symbolics Cloe has both a    code-walking version of a SYMBOL-MACROLET macro and compiler support for    a SYMBOL-MACROLET special form.Cost to Implementors:    If SYMBOL-MACROLET is modified to be a special form, compilers and    interpreters will have to change, as well as MACROEXPAND, MACROEXPAND-1,    PUSH, INCF, DECF, and others.Cost to Users:    If SYMBOL-MACROLET is converted to a special form, code-walking programs    will have to be modified to handle SYMBOL-MACROLET correctly.  Those same    programs would have to be modified to handle the other special forms    specified in CLOS, anyway.Cost of Non-Adoption:    SYMBOL-MACROLET will retain its confusing semantics, leading to bugs when    it interacts with complex macros and forms which produce side-effects.    Implementations which support ONCE-ONLY will break.  For that matter, any    mechanism which examines code and assumes that "variables" have no side    effects will break.Benefits:    SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM avoids the hairiest problems    surrounding interaction of macros (like SETF) and side effects, and makes    SYMBOL-MACROLET consistent with MACROLET.Aesthetics:    If SYMBOL-MACROLET is made to be a special form, aesthetics are improved    by making symbol macros consistent with normal macros.Discussion:    A case could be made for adding a new function, SYMBOL-MACRO-FUNCTION, as    a dual of MACRO-FUNCTION.  However, symbol macros are simpler than normal    macros: a symbol macro is associated with a single expansion form, rather    than an arbitrary function which computes the expansion.  For this reason,    the augmented MACROEXPAND-1 proposed here can also fill the role of    SYMBOL-MACRO-FUNCTION: the second value of (macroexpand-1 sym env) will be    T if and only if sym is a symbol macro, while the first value gives the    expansion of sym, if it has one.    Rather than extending the existing MACROEXPAND and MACROEXPAND-1   functions, new functions could be introduced to expand symbol macros.    However, there seems to be no particular reason to do this.*start*07059 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Mar-89 18:16:28 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 18:16:11 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  18:01:42 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 MAR 89 17:46:06 PSTDate: 16 Mar 89 17:44 PSTFrom: masinter.paTo: x3j13@sail.stanford.eduSubject: SYMBOL-MACROLET-SEMANTICS, version 6line-fold: NOMessage-ID: <890316-174606-6317@Xerox>This is a proposal to amend version 5, passed in January 1989 in Kauai.Version 6 amends version 5 to require PSETQ to behave like PSETF,to require MULTIPLE-VALUE-SETQ to accept symbol macros (but notgeneral SETF places), and to specify the interaction with the*MACROEXPAND-HOOK* function.We would like to have the proposal reconsidered, andaccepted as amended.!Issue:		SYMBOL-MACROLET-SEMANTICSReferences:	SYMBOL-MACROLET (88-002R page 2-81)Related Issues: SYMBOL-MACROLET-DECLARECategory:	CHANGEEdit history:	29-July-88, Version 1 by Piazza		21-September-88, Version 2 by Piazza		22-September-88, Version 3 by Piazza 		22-September-88, Version 4 by Piazza		30-Nov-88, Version 5 by Masinter		14-Mar-89, Version 6 by SteeleProblem Description:    The SYMBOL-MACROLET construct, introduced with CLOS in X3J13 document    88-002R, profoundly alters the interpretation of symbols appearing as    forms in a Common Lisp program--what previously was necessarily a variable    might now be a symbol macro instead.  Macros which appear in the body of a    SYMBOL-MACROLET form are currently unable to determine whether a symbol    form is a variable or a symbol macro, and, if the latter, what the    expansion of the symbol macro is.  Consequently, complex macros (such as    SETF or PUSH) which depend on the form of their argument(s), are unable to    produce their desired results in some cases, as in the following example:	    (let ((a (make-array 5))		  (i 0))	      (symbol-macrolet ((place  (aref a (incf i))))	        (push x place))	      i)		==> 2    In addition, it would be both natural and nice to be able to write  (with-slots (rho theta) point    (declare (single-float rho theta))    ...computation...)    as well as DECLARE within SYMBOL-MACROLET forms.Proposal (SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM):    Change the definition of SYMBOL-MACROLET to specify that it is a special    form, which affects the evaluation environment for symbols.  Enhance    MACROEXPAND and MACROEXPAND-1 so that they can expand a symbol macro.    Modify SETF et al to use the new MACROEXPAND and MACROEXPAND-1 to examine    even symbol subforms.  Specify that the expansion of a symbol macro IS    subject to further macro expansion in the same lexical environment as the    symbol macro invocation, exactly analogous to normal macros. Clarify that    within the body of a SYMBOL-MACROLET, SETQ of a symbol defined as    a symbol macro will be treated as if it were a SETF.    Furthermore PSETQ of a symbol defined as a symbol macro will    behave as if it were a PSETF, and MULTIPLE-VALUE-SETQ will behave    as if SETQ were used on each variable to be set.    When MACROEXPAND or MACROEXPAND-1 sees a symbol macro, it calls    the value of *MACROEXPAND-HOOK* in the same manner as for an    ordinary macro.  The three values given to the hook function    in this case will be an expansion function, a form (in this case    the symbol naming the symbol macro), and an environment.  The    only guaranteed property of the expansion function is that when    it is applied to the form and the environment it will return the    correct expansion of the symbol macro.  (In particular, nothing    it said in this specification whether the expansion is conceptually    stored in the expansion function, the environment, or both.)Rationale:    The potential for interaction between macros is exactly why &environment    arguments were originally added to macros.  Changing SYMBOL-MACROLET to be    a special form, which communicates through the &environment arguments to    macros with MACROEXPAND and MACROEXPAND-1, would allow PUSH and SETF    (among others) to work with SYMBOL-MACROLET in the same way they work with    MACROLET.    This change cannot (reasonably) support the currently specified semantics    that the expansion text is "outside" the scope of the symbol macro.  For    indeed, when the symbol macro is expanded, (a copy of) the expansion is    then within the scope of the SYMBOL-MACROLET, and should then be subject    to further scrutiny.  The issue of "infinite expansion" of symbol macros is    no more dangerous than that of normal macros.Current Practice:    Portable Common Loops provides a code-walking implementation of    SYMBOL-MACROLET as specified in 88-002R.  Symbolics Cloe has both a    code-walking version of a SYMBOL-MACROLET macro and compiler support for    a SYMBOL-MACROLET special form.Cost to Implementors:    If SYMBOL-MACROLET is modified to be a special form, compilers and    interpreters will have to change, as well as MACROEXPAND, MACROEXPAND-1,    PUSH, INCF, DECF, and others.Cost to Users:    If SYMBOL-MACROLET is converted to a special form, code-walking programs    will have to be modified to handle SYMBOL-MACROLET correctly.  Those same    programs would have to be modified to handle the other special forms    specified in CLOS, anyway.Cost of Non-Adoption:    SYMBOL-MACROLET will retain its confusing semantics, leading to bugs when    it interacts with complex macros and forms which produce side-effects.    Implementations which support ONCE-ONLY will break.  For that matter, any    mechanism which examines code and assumes that "variables" have no side    effects will break.Benefits:    SYMBOL-MACROLET-SEMANTICS:SPECIAL-FORM avoids the hairiest problems    surrounding interaction of macros (like SETF) and side effects, and makes    SYMBOL-MACROLET consistent with MACROLET.Aesthetics:    If SYMBOL-MACROLET is made to be a special form, aesthetics are improved    by making symbol macros consistent with normal macros.Discussion:    A case could be made for adding a new function, SYMBOL-MACRO-FUNCTION, as    a dual of MACRO-FUNCTION.  However, symbol macros are simpler than normal    macros: a symbol macro is associated with a single expansion form, rather    than an arbitrary function which computes the expansion.  For this reason,    the augmented MACROEXPAND-1 proposed here can also fill the role of    SYMBOL-MACRO-FUNCTION: the second value of (macroexpand-1 sym env) will be    T if and only if sym is a symbol macro, while the first value gives the    expansion of sym, if it has one.    Rather than extending the existing MACROEXPAND and MACROEXPAND-1   functions, new functions could be introduced to expand symbol macros.    However, there seems to be no particular reason to do this.*start*01794 00024 US Date:  4 Apr 89 13:02 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: SYMBOL-MACROLET-SEMANTICSTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SYMBOL-MACROLET-SEMANTICSTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:51:01 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:45:39 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 571287; 4 Apr 89 15:45:32 EDTOriginal-Date: Tue, 4 Apr 89 15:45 EDTMessage-ID: <890404154506.7.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say... People wanted PSETQ added with SETQ in the list of things SYMBOL-MACROLET hacks specially. RWK wants changes to deal with *MACRO-EXPANSION-HOOK* to clarify how it gets called when PSETQ and SETQ are used.  He seemed to want it called with the SETF expander and a consed-up SETF form. I'd rather it be called with a special magic expander and the actual SETQ form. RPG wants to flush SYMBOL-MACROLET altogether and have people just use  WITH-SLOTS. Many people didn't want to give up the flexibility of SYMBOL-MACROLET. A vote on Version 6 "as is" passed 16-2. A straw poll was taken on the question ``should we ask RPG to draft a proposal for flushing SYMBOL-MACROLET.''  On a 6-8 vote, we opted not to write such a proposal. [That doesn't preclude him from doing it anyway, of course.]