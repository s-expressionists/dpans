*start*06211 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 DEC 88 16:21:02 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Dec 88  12:58:49 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 512793; Wed 28-Dec-88 15:57:35 ESTDate: Wed, 28 Dec 88 15:57 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-EXTENSIONS (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <881228155709.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Issue:        PATHNAME-EXTENSIONSForum:	      CleanupReferences:   Pathnames (pp410-413)Category:     ADDITIONEdit history: 28-Dec-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  CLtL is quite strict about what may and may not be in any kind of  pathname, leaving implementors up against a brick wall when an  idiosyncratic extension is necessary to uniquely and usefully   represent all files in a particular file system which may not have  been completely anticipated by the Common Lisp designers.Proposal (PATHNAME-EXTENSIONS:NEW-PREDICATE):  Introduce a function COMMON-PATHNAME-P, described as follows:	COMMON-PATHNAME-P pathname			[Function]	Returns true if its argument satisfies the Common Lisp	pathname model, and false otherwise. If the argument is	not a pathname, an error of type TYPE-ERROR is signalled.  Clarify that COMMON-PATHNAME-P considers a pathname's host field  to fit the Common Lisp pathname model if the filler of the host  field is a string (naming a host), and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's device to fit  the Common Lisp pathname model if it is a string naming a device,  or NIL, or :WILD[, or, if issue PATHNAME-COMPONENT-UNSPECIFIC   passes, is :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's directory  field to fit the Common Lisp pathname model if the filler of the  directory field is NIL, or :WILD, or a string[, or, if issue  PATHNAME-SUBDIRECTORY-LIST passes, is a list described as valid  by that proposal][, or, if issue PATHNAME-COMPONENT-UNSPECIFIC   passes, is :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's name to   fit the Common Lisp pathname model if it is a string, or NIL,  or :WILD, and not otherwise.    Clarify that COMMON-PATHNAME-P considers a pathname's type to  fit the Common Lisp pathname model if it is a string, or :WILD,  or NIL[, or, if issue PATHNAME-COMPONENT-UNSPECIFIC passes, is  :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's version to  fit the Common Lisp pathname model if it is a positive integer,  :WILD, or NIL, or :NEWEST[, or, if issue PATHNAME-COMPONENT-UNSPECIFIC  passes, is :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname to be outside  the Common Lisp model if it contains special syntax or purpose   which is not readily apparent to Common Lisp programs. For example,  if a character like "*" or "~" has special meaning to the file   system, then strings like "F*X" or "~FOO" which exploit that syntax  are not considered to "fit the model". [Note that if issue  PATHNAME-WILD passes, WILD-PATHNAME-P might still be true of  some pathnames that were not COMMON-PATHNAME-P.]Test Case:  ;; On Unix...  (common-pathname-p (make-pathname :name "f*x"))  => nil  ;; On Tops-20...  (common-pathname-p (make-pathname :name "FOO" :version -1))  ;; On VMS...  (common-pathname-p (parse-namestring "x::y::z::w::[joe]a.b"))  => nil  ;; Normally  (common-pathname-p (make-pathname :name "FOO" :version :wild))  => t  (common-pathname-p (make-pathname :name "FOO" :version 17))  => tRationale:  The purpose of COMMON-PATHNAME-P is not to detect pathnames which  are not valid. Indeed, no Common Lisp function requires that its   argument satisfy this test; it is assumed that functions such as  OPEN and MERGE-PATHNAMES will recognize and deal appropriately with  whatever special pathname syntax is appropriate to the host operating  system. Rather, the purpose of COMMON-PATHNAME-P is to help Common   Lisp programs which try to pick apart a pathname and perform some  sort of simulated merging on the basis of the simple pathname model  put forth by Common Lisp, so that such programs can detect situations  which are beyond their capabilities.Current Practice:  Probably nobody implements this.Cost to Implementors:  Small. The program is fairly straightforward. It could almost be  written as a portable library if it weren't for detecting special  characters that have some special syntax.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Some idiosyncratic system syntax would be hard to detect.  Making extensions to the pathname system in a way that Common Lisp  users would not be forced to trip over would be more difficult.Benefits:  Some ad-hoc user code which tries to do the same thing could be  eliminated. Portable programs which must prompt for native pathname  syntax, and deal with the result of having parsed it could be more  robust.  Making idiosyncratic extensions to the pathname system would be much  less prone to cause problem for portable programs which used this   facility.  The presence of this operator could someday ease the transition  into a future, incompatible pathname system.Aesthetics:  Probably improves aesthetics slightly by giving people who want to  reject extended pathnames a more reliable way of weeding them out.Discussion:  The COMMON data type was probably intended to have this same purpose.  Unfortunately, since no one ever really said specifically enough what  was in COMMON or not, and why, it never really caught on. Hopefully  this proposal is definite enough on such issues to not be useless.  Pitman thinks this is probably a good idea.*start*01325 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 DEC 88 10:07:40 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Dec 88  10:06:22 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513117; Thu 29-Dec-88 13:05:13 ESTDate: Thu, 29 Dec 88 13:04 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-EXTENSIONS (Version 1)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <881228155709.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19881229180459.9.MOON@EUPHRATES.SCRC.Symbolics.COM>This sounds reasonable at first, but I was unable to think of anyway that a correct portable program could use it.  If there was ause for it, I couldn't convince myself that a single yes/no distinctionwas sufficient; some extensions to Common Lisp pathname semanticsmight be handled by a CL function that the user program was going tocall, thus they wouldn't interfere with use of an "extended" pathname.Indeed, why isn't this true of all such extensions?I think you need to supply a real example.*start*02801 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 DEC 88 11:20:39 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Dec 88  11:18:41 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513169; Thu 29-Dec-88 14:17:20 ESTDate: Thu, 29 Dec 88 14:16 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-EXTENSIONS (Version 1)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <19881229180459.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <881229141653.5.KMP@BOBOLINK.SCRC.Symbolics.COM>Here's a made-up example of the kind I was imagining:(DEFUN TRANSLATE-LOGICAL-PATHNAME (LPATHNAME)  (MULTIPLE-VALUE-BIND (LHOST LDEVICE LDIR LNAME LTYPE LVERSION)      (PARSE-LOGICAL-PATHNAME LPATHNAME)    (MULTIPLE-VALUE-BIND (PHOST PDEVICE PDIR PNAME PTYPE PVERSION)        (TRANSLATE-PATHNAME-COMPONENTS LHOST LDEVICE LDIR LNAME LTYPE LVERSION)      (LET ((PHYSICAL-PATHNAME (MAKE-PATHNAME :HOST PHOST ...)))        (UNLESS (COMMON-PATHNAME-P PHYSICAL-PATHNAME)          (CERROR "Use ~*~A anyway."		  "The result of translating pathname ~A to a physical pathname~		 ~%resulted in a valid physical pathname, ~A,~                 ~%but that pathname has special meaning to host ~A which may~		 ~%not have been what was intended."	          LPATHNAME PHYSICAL-PATHNAME PHOST))))))I don't think I have a specific example around, but I remember I used to worryabout this a lot in Macsyma, because LispM Macsyma does cross-host file searchesby mixing and matching file syntaxes gotten from here and there. I used to worryit would construct pathnames that were magic in some way and do something weird.If I could have put in an error check here and there, I'd have felt a bit more comfortable.Also, CLtL's spec gives so much leeway allowing "implementation-dependent" thingsall over the place in pathnames, that I just figured that it would be easier forusers who want to assume the "nice" values are present to just guard simple-mindedcode with (COND ((COMMON-PATHNAME-P PATHNAME)        ... code that assumes pathnames don't contain hairy junk ...)       (T        (ERROR "Pathname ~S was more complex than I expected." PATHNAME)))As clumsy as this error seems, it's probably more informative than theLENGTH got bad argument or whatever that you'd get instead if you wrote thesame code unguarded. Seems like that would provide at least the opportunityfor fault-tolerant code without giving up the ability to do fast prototyping.*start*01997 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 DEC 88 11:32:51 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Dec 88  11:32:17 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513176; Thu 29-Dec-88 14:31:07 ESTDate: Thu, 29 Dec 88 14:30 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-EXTENSIONS (Version 1)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881229141653.5.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19881229193043.6.MOON@EUPHRATES.SCRC.Symbolics.COM>The examples only shed negative illumination for me.  That is,I'm not sure what precisely "special meaning", "something weird",not "nice values", and "hairy junk" really mean.  I suspect part ofwhat you're worried about is wildcard pathnames; wasn't there alreadyproposed a PATHNAME-WILD-P (or was it WILD-PATHNAME-P?) function forthat?In one of your examples COMMON-PATHNAME-P seems to mean "this pathnameis acceptable to the host" and in the other example COMMON-PATHNAME-Pseems to mean "this pathname is acceptable to a particular user-writtenalgorithm".  To me those don't seem to be the same test.  I think theformer test makes sense to codify as a function (although when I tryto articulate precisely what "acceptable" means, I have trouble; can itbe dynamically varying depending on what files and directories currentlyexist?), but I don't see that your proposed function does this test.The latter test seems hard to specify without saying anything aboutthe user-written algorithm.I'm not really opposed to this, but I don't think it's definedspecifically enough yet.  I begin to fear that it is inherentlyimpossible to define it specifically enough.*start*02019 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 DEC 88 11:54:09 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 29 Dec 88  11:53:36 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01031g; Thu, 29 Dec 88 11:49:58 PSTReceived: by bhopal id AA11022g; Thu, 29 Dec 88 11:52:09 PSTDate: Thu, 29 Dec 88 11:52:09 PSTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8812291952.AA11022@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.STANFORD.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: Kent M Pitman's message of Wed, 28 Dec 88 15:57 EST <881228155709.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-EXTENSIONS (Version 1)Does this really need to be a part of the standard?  Why can't itjust be privately distributed (or re-invented) by the few sites thatwant it?  As far as I can see, it is merely a syntax checker whichsits entirely on top of the current language, and anyone who carescan implement it quickly after reading the standard.If one is to persue portability in this fashion, I think it would bemore elegant to seriously implement the COMMON data type and have apair of predicates that tested any given lisp form and said whether itwas data (or code) that adhered to the common lisp standard.  (Thedata predicate might itself be written portably.  The code predicatewould need to be ported to each vendor to detect supported butnon-standard features, since (TRICKY X) would be standard if TRICKYwere user-defined, but would not be if it implemented somevendor-specific magic.)  Given such predicates you could safelydescend through any lisp structure, using the predicates to warn youof pitfalls ahead.   Doing bits and pieces of syntax checking seems somewhat ad hoc, unlessthe claim is that pathnames are and will be the only "standard" datawhich have unpredictable format.  jlm*start*07178 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 DEC 88 12:29:28 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Dec 88  12:28:43 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513219; Thu 29-Dec-88 15:24:16 ESTDate: Thu, 29 Dec 88 15:23 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-EXTENSIONS (Version 1)To: jlm@lucid.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8812291952.AA11022@bhopal>Message-ID: <881229152348.9.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Thu, 29 Dec 88 11:52:09 PST    From: Jim McDonald <jlm@lucid.com>    Does this really need to be a part of the standard?  Why can't it    just be privately distributed (or re-invented) by the few sites that    want it?  As far as I can see, it is merely a syntax checker which    sits entirely on top of the current language, and anyone who cares    can implement it quickly after reading the standard.The answer to this is in the proposal (Cost to Implementors):  Small. The program is fairly straightforward. It could almost be  written as a portable library if it weren't for detecting special  characters that have some special syntax.A truly portable program cannot know that "*" or "~" or whateveris special to some file systems and not to others.    If one is to persue portability in this fashion, I think it would be    more elegant to seriously implement the COMMON data type I'd be really surprised if you could come up with a meaning for thisas a type. I could imagine you almost coming up with a meaning for COMMONwhich was representable as a predicate, but I don't think you could doit as a type. It's clear that some non-COMMON data types have to be subtypes of COMMON. For example, arrays with array leaders on the 3600.You might write a COMMON-P predicate which detected this, but you'd bemisled by subtypep relations if you really pursued this as part of thetype system.    and have a    pair of predicates that tested any given lisp form and said whether it    was data (or code) that adhered to the common lisp standard.If you want to write a description of such a predicate, I think we shouldhave it. But I don't think you could describe it adequately, so I was bitingoff a particular part of the problem that has some real world application.Pathnames are interestingly different from other CL data because they involvea syntax (namestrings) which are specified by an external agency (the filesystem) and which correspond to data structures (directories, links, files,...)which are also really beyond the scope of CL to legislate. As such, they aremore prone to legitimately deviate than other aspects of CL data. At leastin the case of other data, you can argue that the implementors could haveopted to not provide the extensions (eg, array leaders). You can't arguethat CL implementors should fail to support some kinds of files just becausethe CL model doesn't suppor them. They must support all files, or CL programmerswill be laughed at by their friends that use -real- programming languages.If they do support all files, then either we must have amazing foresight inchoosing just the right pathname model, or we must guard ourselves by providingways for CL implementors to legitimately deviate without screwing up normalprograms.    (The data predicate might itself be written portably.It cannot be written portably. Examples: - From Scheme: Scheme does not define a way to adjust the length of   a STRING. Unfortunately, some implementations do. The Scheme spec   did not define (EQL "" ""), but did define that operationally   equivalent data was EQL. Since the only side-effecting string    operations in Scheme set a string element (and don't change its   size), then "" can't be side-effected, and so by implication   (EQL "" "") should return T. However, some implementations extended   Scheme to provide operations to change a string's length. Those   operations (rightly, I think) interpreted the spec to say that   (EQL "" "") could return NIL. No portable predicate on "" can   detect that someone has added an operation that makes "" not fit   the model that Scheme had for strings. The issue here is that   sometimes it's the operators which cause the confusion, not the   data layout, so making a function just on data is not necessarily   helpful. - From Genera: What portable operation can detect that an array has   a leader (given that EQUAL ignores leaders). Answer: None. You have   to use implementation-dependent means to detect    implementation-dependent features! - From Star Trek: Spock: "Captain, I'm registering a kind of energy   never before encountered." Man, the guys who designed his scanner   were geniuses...    The code predicate would need to be ported to each vendor to     detect supported but non-standard features, Then what's the point of claiming it's portable?    since (TRICKY X) would be standard if TRICKY    were user-defined, but would not be if it implemented some    vendor-specific magic.)What is "it" in this sentence?    Given such predicates you could safely descend through any lisp    structure, using the predicates to warn you of pitfalls ahead.   Given the above, I think this is naive.    Doing bits and pieces of syntax checking seems somewhat ad hoc, unless    the claim is that pathnames are and will be the only "standard" data    which have unpredictable format.Well, as I mentioned above, there's a real empirical reason to believethat if not the only one in that `class,' they are at least part of anelite group. Streams might be another candidate, but I don't happen tobe interested in that.In any case, I have grown very weary of arguments of the form "Gosh, you thought up an interesting thing there, but before  I'll agree with it, I think you should generalize it a lot more  for no apparent reason."  Lots of things we've proposed as cleanupsare incidences of larger problems, but I think we ought to just considerwhat's proposed. If it's important to someone to solve the more generalcase, let them write the proposal and I (at least) will consider it forwhat it's worth. But in the absence of such a general proposal, I don'tagree that it's best to just admit defeat and do nothing. There is a lotto be gained by solving subsets of problems and gaining experience forthe next round. Maybe ten years from now we'll know if a primitive likethis had unforseen problems, we'll know if it got any (or a lot of) use,etc.  The COMMON type was an example. It was a noble experiment andprobably should be put to death now that it's been demonstrated to be aloser.  But it didn't cost users at all, and it didn't cost implementorsmuch (an evening each of lost sleep for a few implementors here and there)to have it there -- and we learned something in the process.*start*01620 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 10:21:30 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 3 Jan 89  10:20:28 PSTReceived: by ti.com id AA18762; Tue, 3 Jan 89 12:19:51 CSTReceived: from dsg by tilde id AA14868; Tue, 3 Jan 89 12:15:51 CSTReceived: From Kelvin By dsg Via CHAOS-NET With CHAOS-MAIL; Tue, 3 Jan 89  12:16:29 CSTMessage-Id: <2808843406-15267619@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 3 Jan 89 12:16:46 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PATHNAME-EXTENSIONS (Version 1)In-Reply-To: Msg of Wed, 28 Dec 88 15:57 EST from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>>   Clarify that COMMON-PATHNAME-P considers a pathname's host field>   to fit the Common Lisp pathname model if the filler of the host>   field is a string (naming a host), and not otherwise.... etc.Rather than talk about the "fields" of a pathname, I think it would bebetter to talk about the value returned by the standard accessorfunctions.  For example, in proposal PATHNAME-SUBDIRECTORY-LIST, yousuggested that an implementation could use a non-standard representationinternally so long as the function PATHNAME-DIRECTORY returned thestandard representation.  Thus, we could say:  Clarify that COMMON-PATHNAME-P returns true if PATHNAME-HOST will  return a string, and NIL if PATHNAME-HOST will return something else.etc.*start*08463 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 23-Mar-89 12:26:36 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 12:17:19 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Mar 89  11:47:13 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 563798; Thu 23-Mar-89 14:47:01 ESTDate: Thu, 23 Mar 89 14:46 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: **DRAFT** Issue: PATHNAME-EXTENSIONS (Version 1)To: X3J13@SAIL.Stanford.EDUMessage-ID: <890323144641.9.KMP@BOBOLINK.SCRC.Symbolics.COM>	>>> PLEASE DO -NOT- REPLY TO THIS MESSAGE <<<It's probably so late that no one will read what you have to sayanyway. Ponder it and bring your comments to the meeting.Summary of debate on CL-Cleanup follows at end. -kmp-----Issue:        PATHNAME-EXTENSIONSForum:	      CleanupReferences:   Pathnames (pp410-413)Category:     ADDITIONEdit history: 28-Dec-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  CLtL is quite strict about what may and may not be in any kind of  pathname, leaving implementors up against a brick wall when an  idiosyncratic extension is necessary to uniquely and usefully   represent all files in a particular file system which may not have  been completely anticipated by the Common Lisp designers.Proposal (PATHNAME-EXTENSIONS:NEW-PREDICATE):  Introduce a function COMMON-PATHNAME-P, described as follows:	COMMON-PATHNAME-P pathname			[Function]	Returns true if its argument satisfies the Common Lisp	pathname model, and false otherwise. If the argument is	not a pathname, an error of type TYPE-ERROR is signalled.  Clarify that COMMON-PATHNAME-P considers a pathname's host field  to fit the Common Lisp pathname model if the filler of the host  field is a string (naming a host), and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's device to fit  the Common Lisp pathname model if it is a string naming a device,  or NIL, or :WILD[, or, if issue PATHNAME-COMPONENT-UNSPECIFIC   passes, is :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's directory  field to fit the Common Lisp pathname model if the filler of the  directory field is NIL, or :WILD, or a string[, or, if issue  PATHNAME-SUBDIRECTORY-LIST passes, is a list described as valid  by that proposal][, or, if issue PATHNAME-COMPONENT-UNSPECIFIC   passes, is :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's name to   fit the Common Lisp pathname model if it is a string, or NIL,  or :WILD, and not otherwise.    Clarify that COMMON-PATHNAME-P considers a pathname's type to  fit the Common Lisp pathname model if it is a string, or :WILD,  or NIL[, or, if issue PATHNAME-COMPONENT-UNSPECIFIC passes, is  :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's version to  fit the Common Lisp pathname model if it is a positive integer,  :WILD, or NIL, or :NEWEST[, or, if issue PATHNAME-COMPONENT-UNSPECIFIC  passes, is :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname to be outside  the Common Lisp model if it contains special syntax or purpose   which is not readily apparent to Common Lisp programs. For example,  if a character like "*" or "~" has special meaning to the file   system, then strings like "F*X" or "~FOO" which exploit that syntax  are not considered to "fit the model". [Note that if issue  PATHNAME-WILD passes, WILD-PATHNAME-P might still be true of  some pathnames that were not COMMON-PATHNAME-P.]Test Case:  ;; On Unix...  (common-pathname-p (make-pathname :name "f*x"))  => nil  ;; On Tops-20...  (common-pathname-p (make-pathname :name "FOO" :version -1))  ;; On VMS...  (common-pathname-p (parse-namestring "x::y::z::w::[joe]a.b"))  => nil  ;; Normally  (common-pathname-p (make-pathname :name "FOO" :version :wild))  => t  (common-pathname-p (make-pathname :name "FOO" :version 17))  => tRationale:  The purpose of COMMON-PATHNAME-P is not to detect pathnames which  are not valid. Indeed, no Common Lisp function requires that its   argument satisfy this test; it is assumed that functions such as  OPEN and MERGE-PATHNAMES will recognize and deal appropriately with  whatever special pathname syntax is appropriate to the host operating  system. Rather, the purpose of COMMON-PATHNAME-P is to help Common   Lisp programs which try to pick apart a pathname and perform some  sort of simulated merging on the basis of the simple pathname model  put forth by Common Lisp, so that such programs can detect situations  which are beyond their capabilities.Current Practice:  Probably nobody implements this.Cost to Implementors:  Small. The program is fairly straightforward. It could almost be  written as a portable library if it weren't for detecting special  characters that have some special syntax.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Some idiosyncratic system syntax would be hard to detect.  Making extensions to the pathname system in a way that Common Lisp  users would not be forced to trip over would be more difficult.Benefits:  Some ad-hoc user code which tries to do the same thing could be  eliminated. Portable programs which must prompt for native pathname  syntax, and deal with the result of having parsed it could be more  robust.  Making idiosyncratic extensions to the pathname system would be much  less prone to cause problem for portable programs which used this   facility.  The presence of this operator could someday ease the transition  into a future, incompatible pathname system.Aesthetics:  Probably improves aesthetics slightly by giving people who want to  reject extended pathnames a more reliable way of weeding them out.Discussion:  The COMMON data type was probably intended to have this same purpose.  Unfortunately, since no one ever really said specifically enough what  was in COMMON or not, and why, it never really caught on. Hopefully  this proposal is definite enough on such issues to not be useless.  Pitman thinks this is probably a good idea.------- Summary of debate -------Discussion on CL-Cleanup centered around two issues: - Is this really needed?  What could it be used for?   I suggested following program as an illustration:   (DEFUN TRANSLATE-LOGICAL-PATHNAME (LPATHNAME)     (MULTIPLE-VALUE-BIND (LHOST LDEVICE LDIR LNAME LTYPE LVERSION)	 (PARSE-LOGICAL-PATHNAME LPATHNAME)       (MULTIPLE-VALUE-BIND (PHOST PDEVICE PDIR PNAME PTYPE PVERSION)	   (TRANSLATE-PATHNAME-COMPONENTS LHOST LDEVICE LDIR LNAME LTYPE LVERSION)	 (LET ((PHYSICAL-PATHNAME (MAKE-PATHNAME :HOST PHOST ...)))	   (UNLESS (COMMON-PATHNAME-P PHYSICAL-PATHNAME)	     (CERROR "Use ~*~A anyway."		     "The result of translating pathname ~A to a physical pathname~		    ~%resulted in a valid physical pathname, ~A,~		    ~%but that pathname has special meaning to host ~A which may~		    ~%not have been what was intended."		     LPATHNAME PHYSICAL-PATHNAME PHOST))))))   Also, recently there has been concern (e.g., in issue   PATHNAME-SUBDIRECTORY-LIST) about requirements for conformance   precluding interesting extensions that particular implementations   might want to experiment with.  This would provide a way for portable   programs to guard against such `creative' extensions. - Isn't this something users could write?   The answer is no.  What is a non-portable pathname cannot be portably   detected. e.g., the fact that "*" or "~" or "{" or whatever is magic   in some filename syntax and not in another is (almost by definition) not    something that is portably detectable.  Portable programs can just decide   to limit themselves to the least common denominator (e.g., refusing to let   you type in any pathname to a prompt for pathname if it has an `scary   looking' character in it), but this provides a way of being both a little   more robust and a little more tolerant.For those who are curious, I'm not adamant about this proposal. I justwant it to be available as an option in case it eases the discussion onother issues. -kmp*start*08463 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 23-Mar-89 15:20:08 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 15:18:45 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Mar 89  11:47:13 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 563798; Thu 23-Mar-89 14:47:01 ESTDate: Thu, 23 Mar 89 14:46 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: **DRAFT** Issue: PATHNAME-EXTENSIONS (Version 1)To: X3J13@SAIL.Stanford.EDUMessage-ID: <890323144641.9.KMP@BOBOLINK.SCRC.Symbolics.COM>	>>> PLEASE DO -NOT- REPLY TO THIS MESSAGE <<<It's probably so late that no one will read what you have to sayanyway. Ponder it and bring your comments to the meeting.Summary of debate on CL-Cleanup follows at end. -kmp-----Issue:        PATHNAME-EXTENSIONSForum:	      CleanupReferences:   Pathnames (pp410-413)Category:     ADDITIONEdit history: 28-Dec-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  CLtL is quite strict about what may and may not be in any kind of  pathname, leaving implementors up against a brick wall when an  idiosyncratic extension is necessary to uniquely and usefully   represent all files in a particular file system which may not have  been completely anticipated by the Common Lisp designers.Proposal (PATHNAME-EXTENSIONS:NEW-PREDICATE):  Introduce a function COMMON-PATHNAME-P, described as follows:	COMMON-PATHNAME-P pathname			[Function]	Returns true if its argument satisfies the Common Lisp	pathname model, and false otherwise. If the argument is	not a pathname, an error of type TYPE-ERROR is signalled.  Clarify that COMMON-PATHNAME-P considers a pathname's host field  to fit the Common Lisp pathname model if the filler of the host  field is a string (naming a host), and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's device to fit  the Common Lisp pathname model if it is a string naming a device,  or NIL, or :WILD[, or, if issue PATHNAME-COMPONENT-UNSPECIFIC   passes, is :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's directory  field to fit the Common Lisp pathname model if the filler of the  directory field is NIL, or :WILD, or a string[, or, if issue  PATHNAME-SUBDIRECTORY-LIST passes, is a list described as valid  by that proposal][, or, if issue PATHNAME-COMPONENT-UNSPECIFIC   passes, is :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's name to   fit the Common Lisp pathname model if it is a string, or NIL,  or :WILD, and not otherwise.    Clarify that COMMON-PATHNAME-P considers a pathname's type to  fit the Common Lisp pathname model if it is a string, or :WILD,  or NIL[, or, if issue PATHNAME-COMPONENT-UNSPECIFIC passes, is  :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname's version to  fit the Common Lisp pathname model if it is a positive integer,  :WILD, or NIL, or :NEWEST[, or, if issue PATHNAME-COMPONENT-UNSPECIFIC  passes, is :UNSPECIFIC], and not otherwise.  Clarify that COMMON-PATHNAME-P considers a pathname to be outside  the Common Lisp model if it contains special syntax or purpose   which is not readily apparent to Common Lisp programs. For example,  if a character like "*" or "~" has special meaning to the file   system, then strings like "F*X" or "~FOO" which exploit that syntax  are not considered to "fit the model". [Note that if issue  PATHNAME-WILD passes, WILD-PATHNAME-P might still be true of  some pathnames that were not COMMON-PATHNAME-P.]Test Case:  ;; On Unix...  (common-pathname-p (make-pathname :name "f*x"))  => nil  ;; On Tops-20...  (common-pathname-p (make-pathname :name "FOO" :version -1))  ;; On VMS...  (common-pathname-p (parse-namestring "x::y::z::w::[joe]a.b"))  => nil  ;; Normally  (common-pathname-p (make-pathname :name "FOO" :version :wild))  => t  (common-pathname-p (make-pathname :name "FOO" :version 17))  => tRationale:  The purpose of COMMON-PATHNAME-P is not to detect pathnames which  are not valid. Indeed, no Common Lisp function requires that its   argument satisfy this test; it is assumed that functions such as  OPEN and MERGE-PATHNAMES will recognize and deal appropriately with  whatever special pathname syntax is appropriate to the host operating  system. Rather, the purpose of COMMON-PATHNAME-P is to help Common   Lisp programs which try to pick apart a pathname and perform some  sort of simulated merging on the basis of the simple pathname model  put forth by Common Lisp, so that such programs can detect situations  which are beyond their capabilities.Current Practice:  Probably nobody implements this.Cost to Implementors:  Small. The program is fairly straightforward. It could almost be  written as a portable library if it weren't for detecting special  characters that have some special syntax.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Some idiosyncratic system syntax would be hard to detect.  Making extensions to the pathname system in a way that Common Lisp  users would not be forced to trip over would be more difficult.Benefits:  Some ad-hoc user code which tries to do the same thing could be  eliminated. Portable programs which must prompt for native pathname  syntax, and deal with the result of having parsed it could be more  robust.  Making idiosyncratic extensions to the pathname system would be much  less prone to cause problem for portable programs which used this   facility.  The presence of this operator could someday ease the transition  into a future, incompatible pathname system.Aesthetics:  Probably improves aesthetics slightly by giving people who want to  reject extended pathnames a more reliable way of weeding them out.Discussion:  The COMMON data type was probably intended to have this same purpose.  Unfortunately, since no one ever really said specifically enough what  was in COMMON or not, and why, it never really caught on. Hopefully  this proposal is definite enough on such issues to not be useless.  Pitman thinks this is probably a good idea.------- Summary of debate -------Discussion on CL-Cleanup centered around two issues: - Is this really needed?  What could it be used for?   I suggested following program as an illustration:   (DEFUN TRANSLATE-LOGICAL-PATHNAME (LPATHNAME)     (MULTIPLE-VALUE-BIND (LHOST LDEVICE LDIR LNAME LTYPE LVERSION)	 (PARSE-LOGICAL-PATHNAME LPATHNAME)       (MULTIPLE-VALUE-BIND (PHOST PDEVICE PDIR PNAME PTYPE PVERSION)	   (TRANSLATE-PATHNAME-COMPONENTS LHOST LDEVICE LDIR LNAME LTYPE LVERSION)	 (LET ((PHYSICAL-PATHNAME (MAKE-PATHNAME :HOST PHOST ...)))	   (UNLESS (COMMON-PATHNAME-P PHYSICAL-PATHNAME)	     (CERROR "Use ~*~A anyway."		     "The result of translating pathname ~A to a physical pathname~		    ~%resulted in a valid physical pathname, ~A,~		    ~%but that pathname has special meaning to host ~A which may~		    ~%not have been what was intended."		     LPATHNAME PHYSICAL-PATHNAME PHOST))))))   Also, recently there has been concern (e.g., in issue   PATHNAME-SUBDIRECTORY-LIST) about requirements for conformance   precluding interesting extensions that particular implementations   might want to experiment with.  This would provide a way for portable   programs to guard against such `creative' extensions. - Isn't this something users could write?   The answer is no.  What is a non-portable pathname cannot be portably   detected. e.g., the fact that "*" or "~" or "{" or whatever is magic   in some filename syntax and not in another is (almost by definition) not    something that is portably detectable.  Portable programs can just decide   to limit themselves to the least common denominator (e.g., refusing to let   you type in any pathname to a prompt for pathname if it has an `scary   looking' character in it), but this provides a way of being both a little   more robust and a little more tolerant.For those who are curious, I'm not adamant about this proposal. I justwant it to be available as an option in case it eases the discussion onother issues. -kmp