*start*02392 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 JUL 88 12:54:42 PDTReceived: from FRED.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 12 Jul 88  12:52:01 PDTReceived: from FRED.SLISP.CS.CMU.EDU by FRED.SLISP.CS.CMU.EDU; 12 Jul 88 15:50:38 EDTTo: Eric Benson <edsel!eb@labrea.stanford.edu>cc: sandra@cs.utah.edu, cl-cleanup@sail.stanford.eduSubject: Re: SUBTYPEP-TOO-VAGUE (initial draft) In-reply-to: Your message of Mon, 11 Jul 88 17:27:00 -0700.             <8807120027.AA00951@blacksox.lucid.com> Date: Tue, 12 Jul 88 15:50:23 EDTFrom: Rob.MacLachlan@WB1.CS.CMU.EDU    From: Eric Benson <edsel!eb@labrea.stanford.edu>    Message-Id: <8807120027.AA00951@blacksox.lucid.com>    To: sandra@cs.utah.edu    Subject: SUBTYPEP-TOO-VAGUE (initial draft)        AND, OR and NOT are only messy to deal with if any of the type    specifiers involved use SATISFIES.  Otherwise they are well defined.    I think you should remove AND, OR and NOT from the "exceptions list."    I would change that to say that AND OR and NOT are only *impossible* whenthey involve uses of SATISFIES.  They are plenty messy otherwise.  In acompiler I am working on, I have 1500 lines of hairy and reasonably densecode for a SUBTYPEP that only partially understands OR and AND, and doesn'thandle NOT at all.  I strongly recommend that SUBTYPEP not be made too firmuntil a public domain SUBTYPEP that implements the proposal is available.How about:    (subtypep 'integer	      '(or (rational * (6)) (member 6) (integer 7 *)))It is fairly easy to see that this is true, but not so easy to see how toto write a program to solve the general problem.  It might even be a HardProblem, given that we have the capability to describe infinite sets.Even Sandra's proposal may be more hairy than it is worth forcing on theCommon Lisp community.  The MEMBER specifier can also be pretty perverse,for example:     (subtypep '(integer 3 11) '(member 3 4 9 5 6 10 7 11 8 17 15)) => T, TAny how many SUBTYPEPs correctly recognize that float types are finite?    (subtypep `(short-float 0s0 (,(* short-float-epsilon 4)))	      `(member 0s0		       ,(* short-float-epsilon 1)		       ,(* short-float-epsilon 2)		       ,(* short-float-epsilon 3))) => T, T  Rob*start*01247 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 JUL 88 13:03:12 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 12 Jul 88  13:02:03 PDTReturn-Path: <gls@Think.COM>Received: from brigit.think.com by Think.COM; Tue, 12 Jul 88 15:04:50 EDTReceived: by brigit.think.com; Tue, 12 Jul 88 15:59:28 EDTDate: Tue, 12 Jul 88 15:59:28 EDTFrom: gls@Think.COMMessage-Id: <8807121959.AA13736@brigit.think.com>To: Rob.MacLachlan@wb1.cs.cmu.eduCc: edsel!eb@labrea.stanford.edu, sandra@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: Rob.MacLachlan@wb1.cs.cmu.edu's message of Tue, 12 Jul 88 15:50:23 EDT <8807121858.AA09947@Think.COM>Subject: SUBTYPEP-TOO-VAGUE (initial draft)    Date: Tue, 12 Jul 88 15:50:23 EDT   From: Rob.MacLachlan@wb1.cs.cmu.edu   ...   Any how many SUBTYPEPs correctly recognize that float types are finite?       (subtypep `(short-float 0s0 (,(* short-float-epsilon 4)))		 `(member 0s0			  ,(* short-float-epsilon 1)			  ,(* short-float-epsilon 2)			  ,(* short-float-epsilon 3))) => T, TI see your point, but SHORT-FLOAT-EPSILON is not the right quantity here.--Guy*start*00941 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 JUL 88 13:06:23 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 12 Jul 88  13:05:21 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA17539; Tue, 12 Jul 88 14:04:35 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA23562; Tue, 12 Jul 88 14:04:33 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807122004.AA23562@cdr.utah.edu>Date: Tue, 12 Jul 88 14:04:32 MDTSubject: Re: SUBTYPEP-TOO-VAGUE (initial draft) To: Rob.MacLachlan@wb1.cs.cmu.eduCc: Eric Benson <edsel!eb@labrea.stanford.edu>, sandra@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: Rob.MacLachlan@WB1.CS.CMU.EDU, Tue, 12 Jul 88 15:50:23 EDTHmmm, I think you've convinced me to add MEMBER to the list of messycases after all....-Sandra-------*start*01041 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 11 JUL 88 19:45:06 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 11 Jul 88  19:44:08 PDTReceived: by labrea.stanford.edu; Mon, 11 Jul 88 19:43:23 PDTReceived: from blacksox.lucid.com by edsel id AA19205g; Mon, 11 Jul 88 17:31:13 PDTReceived: by blacksox id AA00951g; Mon, 11 Jul 88 17:27:00 pdtDate: Mon, 11 Jul 88 17:27:00 pdtFrom: Eric Benson <edsel!eb@labrea.stanford.edu>Message-Id: <8807120027.AA00951@blacksox.lucid.com>To: sandra@cs.utah.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Mon, 11 Jul 88 14:12:47 MDT <8807112012.AA22808@cdr.utah.edu>Subject: SUBTYPEP-TOO-VAGUE (initial draft)AND, OR and NOT are only messy to deal with if any of the typespecifiers involved use SATISFIES.  Otherwise they are well defined.I think you should remove AND, OR and NOT from the "exceptions list."*start*03846 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 11 JUL 88 13:14:08 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 11 Jul 88  13:13:08 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA14917; Mon, 11 Jul 88 14:12:52 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA22808; Mon, 11 Jul 88 14:12:48 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807112012.AA22808@cdr.utah.edu>Date: Mon, 11 Jul 88 14:12:47 MDTSubject: SUBTYPEP-TOO-VAGUE (initial draft)To: cl-cleanup@sail.stanford.eduIssue:		SUBTYPEP-TOO-VAGUEReferences:	CLtL p. 72-73Category:	CLARIFICATIONEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)Problem Description:The description of SUBTYPEP allows it to return a second value of NILwhen the relationship between the two types cannot be determined.  Insome cases this is a reasonable thing to do because it is impossibleto tell (if the SATISFIES type specifier is involved), and in othercases the relationships between types are not well-defined (forexample, the VALUES type specifier or the list form of the FUNCTIONtype specifier). Some implementations, however, have apparently interpreted this tomean that it is permissible for SUBTYPEP to "give up" and return asecond value of NIL in some cases where it actually would be possibleto determine the relationship.  This makes it difficult to depend onsubtype relationships in portable code.Proposal: SUBTYPEP-TOO-VAGUE:CLARIFY(1) Clarify that SUBTYPEP is allowed to return a second value of NILonly when either of the type specifiers involves the SATISFIES, NOT,AND, OR, the list form of FUNCTION, or VALUES type specifiers.(2) If a type specifier defined with DEFTYPE is passed to SUBTYPEP,SUBTYPEP must treat it in the same way as if its expansion were passedinstead.(3) Clarify that the relationships between types reflected by SUBTYPEPare those specific to the particular implementation.  For example, ifan implementation supports only a single type of floating-point numbers,in that implementation (SUBTYPEP 'FLOAT 'LONG-FLOAT) would return T T(since the two types would be identical).Rationale:It is generally conceded that it is impossible to determine therelationships between types defined with the SATISFIES specifier.AND, OR, and NOT are messy to deal with. (MEMBER falls into the samesection but is easy to do).  I don't know how one would compareFUNCTION or VALUES type specifiers; some rules could be established toclarify how to compare them but I don't think it would would beparticularly useful to do so. Current Practice:The implementation of SUBTYPEP in (the original) HPCL does not try toexpand type specifiers defined with DEFTYPE.  Most other implementationsappear to be substantially in conformance with the proposal.Cost to implementors:Some implementations will have to rewrite and/or extend parts of SUBTYPEP.Cost to users:None.Benefits:An area of confusion in the language is cleared up.  Usages of SUBTYPEPwill be more portable.Discussion:Item (3) appeared to be the consensus from a discussion on thecommon-lisp mailing list some time ago.A related issue is clarifying what kinds of type specifiers must berecognized by functions such as MAKE-SEQUENCE and COERCE.  For example,HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a validsequence type when passed to MAKE-SEQUENCE, although SUBTYPEP doesrecognize it to be a subtype of SEQUENCE.  Should this proposal beextended to deal with these issues, or is another proposal in order?Do the rules for comparing the various type specifiers (such as ARRAY)need to be spelled out in detail, or are they obvious?-------*start*04225 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 19 JUL 88 13:43:51 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 19 Jul 88  13:42:20 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA27114; Tue, 19 Jul 88 14:41:47 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA00292; Tue, 19 Jul 88 14:41:39 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807192041.AA00292@cdr.utah.edu>Date: Tue, 19 Jul 88 14:41:32 MDTSubject: SUBTYPEP-TOO-VAGUE, version 2To: cl-cleanup@sail.stanford.eduHere is a revised version of SUBTYPEP-TOO-VAGUE.  I changed the statusof the MEMBER type specifier and added a requirement that EQUAL typespecifiers be recognized as equivalent.Issue:		SUBTYPEP-TOO-VAGUEReferences:	CLtL p. 72-73Category:	CLARIFICATIONEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)                Version 2, 19 Jul 1988 (Sandra Loosemore)Problem Description:The description of SUBTYPEP allows it to return a second value of NILwhen the relationship between the two types cannot be determined.  Insome cases this is a reasonable thing to do because it is impossibleto tell (if the SATISFIES type specifier is involved), and in othercases the relationships between types are not well-defined (forexample, the VALUES type specifier or the list form of the FUNCTIONtype specifier). Some implementations, however, have apparently interpreted this tomean that it is permissible for SUBTYPEP to "give up" and return asecond value of NIL in some cases where it actually would be possibleto determine the relationship.  This makes it difficult to depend onsubtype relationships in portable code.Proposal: SUBTYPEP-TOO-VAGUE:CLARIFY(1) Clarify that SUBTYPEP is allowed to return a second value of NILonly when either of the type specifiers involves the SATISFIES, MEMBER,NOT, AND, OR, the list form of FUNCTION, or VALUES type specifiers.(2) If a type specifier defined with DEFTYPE is passed to SUBTYPEP,SUBTYPEP must treat it in the same way as if its expansion were passedinstead.(3) SUBTYPEP must always return values T T in the case where the twotype specifiers (or their expansions) are EQUAL.(4) Clarify that the relationships between types reflected by SUBTYPEPare those specific to the particular implementation.  For example, ifan implementation supports only a single type of floating-point numbers,in that implementation (SUBTYPEP 'FLOAT 'LONG-FLOAT) would return T T(since the two types would be identical).Rationale:It is generally conceded that it is impossible to determine therelationships between types defined with the SATISFIES specifier.MEMBER, AND, OR, and NOT are messy to deal with.  I don't know how onewould compare FUNCTION or VALUES type specifiers; some rules could beestablished to clarify how to compare them but I don't think it wouldwould be particularly useful to do so. Current Practice:The implementation of SUBTYPEP in (the original) HPCL does not try toexpand type specifiers defined with DEFTYPE and does not recognizeEQUAL type specifiers as being equivalent.  Most other implementationsappear to be substantially in conformance with the proposal.Cost to implementors:Some implementations will have to rewrite and/or extend parts of SUBTYPEP.Cost to users:None.Benefits:An area of confusion in the language is cleared up.  Usages of SUBTYPEPwill be more portable.Discussion:Item (4) appeared to be the consensus from a discussion on thecommon-lisp mailing list some time ago.A related issue is clarifying what kinds of type specifiers must berecognized by functions such as MAKE-SEQUENCE and COERCE.  For example,HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a validsequence type when passed to MAKE-SEQUENCE, although SUBTYPEP doesrecognize it to be a subtype of SEQUENCE.  Should this proposal beextended to deal with these issues, or is another proposal in order?Do the rules for comparing the various type specifiers (such as ARRAY)need to be spelled out in detail, or are they obvious?-------*start*03789 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 20:32:00 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Sep 88  20:27:26 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 456024; Wed 7-Sep-88 23:26:17 EDTDate: Wed, 7 Sep 88 23:26 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SUBTYPEP-TOO-VAGUE, version 2To: Sandra J Loosemore <sandra%cdr@cs.utah.edu>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8807192041.AA00292@cdr.utah.edu>Message-ID: <19880908032600.2.MOON@EUPHRATES.SCRC.Symbolics.COM>I am mostly in favor of SUBTYPEP-TOO-VAGUE:CLARIFY, but have a fewsuggestions:    (1) Clarify that SUBTYPEP is allowed to return a second value of NIL    only when either of the type specifiers involves the SATISFIES, MEMBER,    NOT, AND, OR, the list form of FUNCTION, or VALUES type specifiers.VALUES and the list form of FUNCTION are not valid arguments to SUBTYPEP(p.72 says the arguments to SUBTYPEP have to be valid for TYPEP, p.47 saysthe list form of FUNCTION is invalid for TYPEP, p.48 says VALUES isn'treally a type-specifer [sic] at all).  So you can strike those two fromthe list.I'm a little unhappy about excluding MEMBER.  I think you should excludeMEMBER only when it's the second argument and the first argument is notMEMBER.  MEMBER as the first argument is a useful and easy to computecase: it's just the conjunction of a bunch of calls to TYPEP.I think if an implementation defines a new type with a name not in CLtL,the implementation should be permitted to add that type to the list oftypes that SUBTYPEP doesn't understand.The behavior of SUBTYPEP on types defined by DEFSTRUCT and DEFCLASSshould be fully specified.  Require it to be the obvious behavior.    A related issue is clarifying what kinds of type specifiers must be    recognized by functions such as MAKE-SEQUENCE and COERCE.  For example,    HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a valid    sequence type when passed to MAKE-SEQUENCE, although SUBTYPEP does    recognize it to be a subtype of SEQUENCE.  Should this proposal be    extended to deal with these issues, or is another proposal in order?I think it's likely to be complex enough that it needs to be anotherproposal.  Perhaps acceptance of this proposal will make that one easierto write, since you can define the behavior in terms of SUBTYPEP.    Do the rules for comparing the various type specifiers (such as ARRAY)    need to be spelled out in detail, or are they obvious?The former.  Fortunately the only difficult cases are COMPLEX, ARRAY andits subtypes, and numerical ranges.  Just to make matters worse, Ibelieve there is a proposal on the table to change the ARRAY rules.  Iforget the issue name.If you don't think numerical ranges are non-obvious, what is  (subtypep '(single-float 0.0 (1.0))	    `(single-float 0.0 ,(- 1.0 single-float-epsilon)))SCL returns NIL T, which is wrong since these two type specifiersdenote identical finite sets.  Once you think you know the answer to that,translate the example into rationals, replacing (- 1.0 single-float-epsilon)with a rational that is so close to 1 that any rational that wascloser could not be represented in the implementation because youwould run out of memory!  I think the answer to that is that for floatsthere is a concept of the next value, and hence a translation fromexclusive to inclusive ranges, but for non-integer rationals there is not.I can't predict the mathematical implications of this, though.*start*04211 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 16:42:08 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Oct 88  16:41:58 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 06 OCT 88 16:36:56 PDTDate: 6 Oct 88 16:36 PDTFrom: masinter.paSubject: SUBTYPEP-TOO-VAGUE, version 3To: cl-cleanup@sail.stanford.eduline-fold: NOMessage-ID: <881006-163656-1686@Xerox>Issue:		SUBTYPEP-TOO-VAGUEReferences:	CLtL p. 72-73Category:	CLARIFICATIONEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)                Version 2, 19 Jul 1988 (Sandra Loosemore)		Version 3,  6-Oct-88 (Masinter)Problem Description:The description of SUBTYPEP allows it to return a second value of NILwhen the relationship between the two types cannot be determined.  Insome cases this is a reasonable thing to do because it is impossibleto tell (if the SATISFIES type specifier is involved), and in othercases the relationships between types are not well-defined (forexample, the VALUES type specifier or the list form of the FUNCTIONtype specifier). Some implementations, however, have apparently interpreted this tomean that it is permissible for SUBTYPEP to "give up" and return asecond value of NIL in some cases where it actually would be possibleto determine the relationship.  This makes it difficult to depend onsubtype relationships in portable code.Proposal: SUBTYPEP-TOO-VAGUE:CLARIFYA type specifier "involves" a word like SATISFIES, MEMBER, NOT, etc.if it either contains it directly or as the result of expansion of a DEFTYPEdefined type specifier. * Clarify that SUBTYPEP will return a second value of NILonly when either of the type specifiers involves the SATISFIES, NOT, AND, OR, MEMBER. * SUBTYPEP should signal an error when handed (for either argument)a type specifier that involves VALUES or the list form of the FUNCTIONtype.* SUBTYPEP must always return values T T in the case where the twotype specifiers (or their expansions) are EQUAL.* Clarify that the relationships between types reflected by SUBTYPEPare those specific to the particular implementation.  For example, ifan implementation supports only a single type of floating-point numbers,in that implementation (SUBTYPEP 'FLOAT 'LONG-FLOAT) would return T T(since the two types would be identical).Rationale:It is generally conceded that it is impossible to determine therelationships between types defined with the SATISFIES specifier.MEMBER, AND, OR, and NOT are messy to deal with.   Current Practice:The implementation of SUBTYPEP in (the original) HPCL does not try toexpand type specifiers defined with DEFTYPE and does not recognizeEQUAL type specifiers as being equivalent.  Most other implementationsappear to be substantially in conformance with the proposal.Cost to implementors:Some implementations will have to rewrite and/or extend parts of SUBTYPEP.Cost to users:Its hard to imagine a portable program that depends heavilyon SUBTYPEP. This proposal does not require any implementationto "handle" fewer cases of SUBTYPEP.Benefits:An area of confusion in the language is cleared up.  Usages of SUBTYPEPwill be more portable.Discussion:The handling of FLOAT and SINGLE-FLOAT  appeared to be the consensus from a discussion on the common-lisp mailing list some time ago.It would not be too onerous to require implementations to handlethe cases where one but not the other type specifier involvesOR, AND, NOT or MEMBER, but the specification becomes cumbersome.A related issue is clarifying what kinds of type specifiers must berecognized by functions such as MAKE-SEQUENCE and COERCE.  For example,HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a validsequence type when passed to MAKE-SEQUENCE, although SUBTYPEP doesrecognize it to be a subtype of SEQUENCE.  Should this proposal beextended to deal with these issues, or is another proposal in order?Do the rules for comparing the various type specifiers (such as ARRAY)need to be spelled out in detail, or are they obvious?*start*01365 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 07 OCT 88 11:45:03 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472623; Fri 7-Oct-88 14:13:57 EDTDate: Fri, 7 Oct 88 14:13 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SUBTYPEP-TOO-VAGUE, version 3To: masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <881006-163656-1686@Xerox>Message-ID: <19881007181338.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoSUBTYPEP-TOO-VAGUE:CLARIFY looks good to me.Since some implementations might use the prohibited words internallyin implementation of built-in types, for example,  (deftype simple-array (&optional element-type dimensions)    `(and (array ,element-type ,dimensions)	  (satisfies simple-array-p)))I think you need to say explicitly that subtypep cannot return a secondvalue of nil when both arguments involve only the words in Table 4-1, ornames of defstruct- or defclass-defined types, or user-defined deftypesthat expand into only those words and/or names.I think you're right that the rules for comparing the various typespecifiers could usefully be spelled out in detail.  Maybe some ad hoccommittee to do just that should be set up?*start*04326 00024 USfDate:  7 Oct 88 23:15 PDTFrom: masinter.paSubject: Issue: SUBTYPEP-TOO-VAGUE (Version 4)To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:		SUBTYPEP-TOO-VAGUEReferences:	CLtL p. 72-73Category:	CLARIFICATIONEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)                Version 2, 19 Jul 1988 (Sandra Loosemore)                Version 3,  6-Oct-88 (Masinter)                Version 4,  7-Oct-88 (Masinter, per Moon's comments)Problem Description:The description of SUBTYPEP allows it to return a second value of NILwhen the relationship between the two types cannot be determined.  Insome cases this is a reasonable thing to do because it is impossibleto tell (if the SATISFIES type specifier is involved), and in othercases the relationships between types are not well-defined (forexample, the VALUES type specifier or the list form of the FUNCTIONtype specifier). Some implementations, however, have apparently interpreted this tomean that it is permissible for SUBTYPEP to "give up" and return asecond value of NIL in some cases where it actually would be possibleto determine the relationship.  This makes it difficult to depend onsubtype relationships in portable code.Proposal: SUBTYPEP-TOO-VAGUE:CLARIFYA type specifier "involves" a word like SATISFIES, MEMBER, NOT, etc.if it either contains it directly or as the result of expansion of a DEFTYPE  defined type specifier. * Clarify that SUBTYPEP will return a second value of NILonly when either of the type specifiers involves the SATISFIES, NOT, AND, OR, MEMBER. SUBTYPEP will not return a secondvalue of NIL when both arguments involve only the words in Table 4-1, ornames of DEFSTRUCT- or DEFCLASS-defined types, or user-defined deftypesthat expand into only those words and/or names.* SUBTYPEP should signal an error when handed (for either argument)a type specifier that involves VALUES or the list form of the FUNCTIONtype.* SUBTYPEP must always return values T T in the case where the twotype specifiers (or their expansions) are EQUAL.* Clarify that the relationships between types reflected by SUBTYPEPare those specific to the particular implementation.  For example, ifan implementation supports only a single type of floating-point numbers,in that implementation (SUBTYPEP 'FLOAT 'LONG-FLOAT) would return T T(since the two types would be identical).Rationale:Specifying the behavior of SUBTYPEP makes it more useful. Otherwise,programs cannot rely on any more than NIL NIL as return values.It is generally conceded that it is impossible to determine therelationships between types defined with the SATISFIES specifier.MEMBER, AND, OR, and NOT are messy to deal with.   Current Practice:The implementation of SUBTYPEP in (the original) HPCL does not try toexpand type specifiers defined with DEFTYPE and does not recognizeEQUAL type specifiers as being equivalent.  Most other implementationsappear to be substantially in conformance with the proposal.Cost to implementors:Some implementations will have to rewrite and/or extend parts of SUBTYPEP.Cost to users:Its hard to imagine a portable program that depends heavilyon SUBTYPEP. This proposal does not require any implementationto "handle" fewer cases of SUBTYPEP.Benefits:An area of confusion in the language is cleared up.  Usages of SUBTYPEPwill be more portable.Discussion:The handling of FLOAT and SINGLE-FLOAT  appeared to be the consensus from a discussion on the common-lisp mailing list some time ago.It would not be too onerous to require implementations to handlethe cases where one but not the other type specifier involvesOR, AND, NOT or MEMBER, but the specification becomes cumbersome.A related issue is clarifying what kinds of type specifiers must berecognized by functions such as MAKE-SEQUENCE and COERCE.  For example,HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a validsequence type when passed to MAKE-SEQUENCE, although SUBTYPEP doesrecognize it to be a subtype of SEQUENCE.  Should this proposal beextended to deal with these issues, or is another proposal in order?The rules for comparing the various type specifiers (such as ARRAY)need to be spelled out in detail.*start*01161 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:11:32 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  18:06:54 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476143; Thu 13-Oct-88 19:28:23 EDTDate: Thu, 13 Oct 88 19:28 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SUBTYPEP-TOO-VAGUE (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013192815.4.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: For as far as it goes, it was thought ready to vote. Some felt we might need further restrictions (other proposals) later.X3J13 meeting: JonL: Thinks EB can prove that only SATISFIES mucks things up and       that OR, AND, etc. are safe. RWK: It couldn't be. You'd need more type cleanups before it could be. People generally doubted JonL's claim but said he was of course welcome to submit the proof.*start*03254 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 NOV 88 13:34:54 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 3 Nov 88  13:33:31 PSTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA01552g; Thu, 3 Nov 88 13:32:39 PSTReceived: by bhopal id AA20559g; Thu, 3 Nov 88 13:31:15 PSTDate: Thu, 3 Nov 88 13:31:15 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811032131.AA20559@bhopal>To: cl-cleanup@sail.stanford.eduCc: eb@lucid.com, jlm@lucid.com, jeb@lucid.com, fy@lucid.comIn-Reply-To: KMP's message of  Thu, 13 Oct 88 19:28 EDTSubject: Issue: SUBTYPEP-TOO-VAGUE (Version 4)Kent's notes summarizing the discussion at Fairfax were:    X3J13 meeting:     JonL: Thinks EB can prove that only SATISFIES mucks things up and	   that OR, AND, etc. are safe.     RWK: It couldn't be. You'd need more type cleanups before it could be.     People generally doubted JonL's claim but said he was of course welcome     to submit the proof.Eric (EB) had intended to submit the "proof", but didn't send it outbefore leaving for vacation.  In recent discussion here at Lucid, he,Jim MacDonald, Jim Boyce, Frank Yellin and I were convinced of the "proof".Before hinting at how the "proof" goes, I'll remark that RWK's claim is only partly true -- in the current state, an algorithm can easily be devisedfor each implementation, once it is determined how that implementationtreats the disjointness of the primitive types on CLtL pp.33-35., and how it determines whether or not something is a defstruct name.  But in fact aportable algorithm can be adduced if we added STRUCTURE-TYPE-P to thelanguage and if we required every implementation to follow a reasonable set of disjointness constraints. [It might also be necessary to addUPGRADED-{ARRAY-ELEMENT,COMPLEX-PART}-TYPE.]The "thumbnail" sketch of the proof goes like this.  First, completelyexclude SATISFIES; also, temporarily ignore type compositions usingAND, OR, and NOT.  Then, there is only a finite number of basic primitive types (CLtL, p.43); and there are only a few very simple rules for constructing more primitive types from them -- namely, numeric subranges,array "specializations", and defstructs without the :type option.  Now,considering the truly primitive types as "literals" in a propositional calculus language with AND/OR/NOT, one can produce a disjunctive normal form; thus type-equivalence and subtypeing are completely determined.  It doesn't matter that there is a infinite pool of "literals" -- in any given subtypep query, there will only be finitely many present; exactly the same situation is covered in college-level logic courses that talk about the decidibility of the propositional calculus.Of course, an efficient implementation wouldn't follow such a "blind"course, which might be NP-complete; one could do a lot better in the average cases.Additionally, by my own previously set rules for such proposals, it would seem that Lucid (or somebody else) ought to go ahead and do the full non-satisfies SUBTYPEP first, before trying to impress it into the standard.-- JonL --*start*00974 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 NOV 88 15:09:50 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 3 Nov 88  15:08:09 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU;  3 Nov 88 18:04:12 ESTTo: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: SUBTYPEP-TOO-VAGUE (Version 4) In-reply-to: Your message of Thu, 03 Nov 88 13:31:15 -0800.             <8811032131.AA20559@bhopal> Date: Thu, 03 Nov 88 18:03:00 ESTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU    Additionally, by my own previously set rules for such proposals, it would     seem that Lucid (or somebody else) ought to go ahead and do the full     non-satisfies SUBTYPEP first, before trying to impress it into the standard.    Not only "do", but make available as public-domain code.-- Scott*start*04546 00024 US Date:  9 Dec 88 10:06 PSTFrom: masinter.paTo: masinterSubject: Issue: SUBTYPEP-TOO-VAGUE (Version 4)Issue:		SUBTYPEP-TOO-VAGUEReferences:       CLtL p. 72-73Category:         CLARIFICATIONEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)                Version 2, 19 Jul 1988 (Sandra Loosemore)                Version 3,  6-Oct-88 (Masinter)                Version 4,  7-Oct-88 (Masinter, per Moon's comments)Problem Description:The description of SUBTYPEP allows it to return a second value of NILwhen the relationship between the two types cannot be determined.  Insome cases this is a reasonable thing to do because it is impossibleto tell (if the SATISFIES type specifier is involved), and in othercases the relationships between types are not well-defined (forexample, the VALUES type specifier or the list form of the FUNCTIONtype specifier). Some implementations, however, have apparently interpreted this tomean that it is permissible for SUBTYPEP to "give up" and return asecond value of NIL in some cases where it actually would be possibleto determine the relationship.  This makes it difficult to depend onsubtype relationships in portable code.Proposal: SUBTYPEP-TOO-VAGUE:CLARIFYA type specifier "involves" a word like SATISFIES, MEMBER, NOT, etc.if it either contains it directly or as the result of expansion of a DEFTYPE  defined type specifier. * Clarify that SUBTYPEP will return a second value of NILonly when either of the type specifiers involves the SATISFIES, NOT, AND, OR, MEMBER. SUBTYPEP will not return a secondvalue of NIL when both arguments involve only the words in Table 4-1, ornames of DEFSTRUCT- or DEFCLASS-defined types, or user-defined deftypesthat expand into only those words and/or names.* SUBTYPEP should signal an error when handed (for either argument)a type specifier that involves VALUES or the list form of the FUNCTIONtype.* SUBTYPEP must always return values T T in the case where the twotype specifiers (or their expansions) are EQUAL.* Clarify that the relationships between types reflected by SUBTYPEPare those specific to the particular implementation.  For example, ifan implementation supports only a single type of floating-point numbers,in that implementation (SUBTYPEP 'FLOAT 'LONG-FLOAT) would return T T(since the two types would be identical).Rationale:Specifying the behavior of SUBTYPEP makes it more useful. Otherwise,programs cannot rely on any more than NIL NIL as return values.It is generally conceded that it is impossible to determine therelationships between types defined with the SATISFIES specifier.MEMBER, AND, OR, and NOT are messy to deal with.   Current Practice:The implementation of SUBTYPEP in (the original) HPCL does not try toexpand type specifiers defined with DEFTYPE and does not recognizeEQUAL type specifiers as being equivalent.  Most other implementationsappear to be substantially in conformance with the proposal.Cost to implementors:Some implementations will have to rewrite and/or extend parts of SUBTYPEP.Cost to users:Its hard to imagine a portable program that depends heavilyon SUBTYPEP. This proposal does not require any implementationto "handle" fewer cases of SUBTYPEP.Benefits:An area of confusion in the language is cleared up.  Usages of SUBTYPEPwill be more portable.Discussion:The handling of FLOAT and SINGLE-FLOAT  appeared to be the consensus from a discussion on the common-lisp mailing list some time ago.It would not be too onerous to require implementations to handlethe cases where one but not the other type specifier involvesOR, AND, NOT or MEMBER, but the specification becomes cumbersome.A related issue is clarifying what kinds of type specifiers must berecognized by functions such as MAKE-SEQUENCE and COERCE.  For example,HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a validsequence type when passed to MAKE-SEQUENCE, although SUBTYPEP doesrecognize it to be a subtype of SEQUENCE.  Should this proposal beextended to deal with these issues, or is another proposal in order?The rules for comparing the various type specifiers (such as ARRAY)need to be spelled out in detail.        TITAN 
         TITAN 
           I                                                               Ú             ç       %      p             >                           M              ¢       
       a             T      Š zº*start*00904 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 MAR 89 14:45:25 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 10 Mar 89  14:44:53 PSTDate: Fri, 10 Mar 89 14:42:41 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue SUBTYPEP-TOO-VAGUETo: cl-cleanup@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUMessage-ID: <12476991748.30.IIM@ECLA.USC.EDU>The proposal SUBTYPEP-TOO-VAGUE:CLARIFY, passed at the Hawaii meeting, says   "SUBTYPEP should signal an error when handed (for either argument) a type   specifier that involves VALUES or the list form of the FUNCTION type."This prevents a compiler from using such type declarations to do type checkingand such on functional arguments.We wish to ammend the proposal to strike that paragraph.kab-------*start*01550 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 MAR 89 01:27:10 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 11 Mar 89  01:24:35 PSTReceived: by ti.com id AA06075; Fri, 10 Mar 89 18:35:05 CSTReceived: from Kelvin by tilde id AA28022; Fri, 10 Mar 89 18:24:41 CSTMessage-Id: <2814567840-5079849@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 10 Mar 89 18:24:00 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "Kim A. Barrett" <IIM@ECLA.USC.EDU>Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue SUBTYPEP-TOO-VAGUEIn-Reply-To: Msg of Fri 10 Mar 89 14:42:41-PST from Kim A. Barrett <IIM@ECLA.USC.EDU>> Date: Fri 10 Mar 89 14:42:41-PST> From: Kim A. Barrett <IIM@ECLA.USC.EDU>> Subject: Issue SUBTYPEP-TOO-VAGUE> > The proposal SUBTYPEP-TOO-VAGUE:CLARIFY, passed at the Hawaii meeting, says> >    "SUBTYPEP should signal an error when handed (for either argument) a type>    specifier that involves VALUES or the list form of the FUNCTION type."> > This prevents a compiler from using such type declarations to do type checking> and such on functional arguments.I don't see any problem here.  My compiler has a type testing functionthat handles VALUES types itself and converts (FUNCTION ...) to justFUNCTION before calling SUBTYPEP, so it isn't prevented from doinganything that it wants to.  If if you want these cases to be permitted, then you will need to definewhat they mean.*start*01901 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 15:00:35 PSTReceived: from ECLC.USC.EDU by SAIL.Stanford.EDU with TCP; 13 Mar 89  15:01:01 PSTDate: Sun, 12 Mar 89 16:05:04 PSTFrom: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>Subject: Issue SUBTYPEP-TOO-VAGUETo: cl-cleanup@SAIL.STANFORD.EDUcc: iim%ECLA@ECLC.USC.EDUMessage-ID: <12477531034.30.IIM@ECLA.USC.EDU>> I don't see any problem here.  My compiler has a type testing function> that handles VALUES types itself and converts (FUNCTION ...) to just> FUNCTION before calling SUBTYPEP, so it isn't prevented from doing anything> that it wants.And what does it do with a deftype'ed type which expands into a list formFUNCTION type specifier or into a VALUES type specifier?  Did you remember tocall type-expand before doing the conversion?  Note that a user wouldn't beable to do that, since type-expand isn't part of the language.  And what aboutan OR of several FUNCTION or VALUES type specifiers?  Besides, it's wrong tohave to define the handling of the VALUES type yourself, even ignoring theseproblems, since you end up with each user who wants this capability having towrite his own, rather than having the facility built into SUBTYPEP where itbelongs.> If you want these cases to be permitted, then you will need to define what> they mean.Thats an ugly job.  One of us was working on it, but hasn't had much time todevote to the problem -- probably nobody here at IIM will be able to get toit any time soon.  Right now we mostly just don't want these to be requiredsignal error cases, with the intention of fully specifying them later.(Note: some of the ugliness involves questions about what to do when thetyped lambda-lists aren't congruent (in the CLOS sense)).kab-------*start*06656 00024 USfGV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 17:14:28 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 17:11:17 PSTMessage-ID: <Yvs6y@SAIL.Stanford.EDU>Date: 15 Mar 89 14:54 PSTFrom: System Files <SYS@SAIL.Stanford.EDU>Subject: [gls: Issue SUBTYPEP-TOO-VAGUE, version 5]    Received: from Think.COM by SAIL.Stanford.EDU with TCP; 15 Mar 89  14:50:43 PSTReceived: from fafnir.think.com by Think.COM; Wed, 15 Mar 89 17:46:14 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Wed, 15 Mar 89 17:47:25 ESTReceived: by verdi.think.com; Wed, 15 Mar 89 17:44:14 ESTDate: Wed, 15 Mar 89 17:44:14 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903152244.AA03741@verdi.think.com>To: cl-cleanup@sail.stanford.eduSubject: [gls: Issue SUBTYPEP-TOO-VAGUE, version 5][I forgot to update the edit history.  Here is corrected copy.]Date: Wed, 15 Mar 89 17:41:16 ESTFrom: Guy Steele <gls>To: cl-cleanup@sail.stanford.eduSubject: Issue SUBTYPEP-TOO-VAGUE, version 5Cc: glsThis is a proposed amendment to version 4 passed in January 1989 at Kauai.Issue:		SUBTYPEP-TOO-VAGUEReferences:	CLtL p. 72-73Category:	CLARIFICATIONEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)                Version 2, 19 Jul 1988 (Sandra Loosemore)                Version 3,  6-Oct-88 (Masinter)                Version 4,  7-Oct-88 (Masinter, per Moon's comments)		Version 5, 15-Mar-89 SteeleProblem Description:[From version 4]The description of SUBTYPEP allows it to return a second value of NILwhen the relationship between the two types cannot be determined.  Insome cases this is a reasonable thing to do because it is impossibleto tell (if the SATISFIES type specifier is involved), and in othercases the relationships between types are not well-defined (forexample, the VALUES type specifier or the list form of the FUNCTIONtype specifier). Some implementations, however, have apparently interpreted this tomean that it is permissible for SUBTYPEP to "give up" and return asecond value of NIL in some cases where it actually would be possibleto determine the relationship.  This makes it difficult to depend onsubtype relationships in portable code.[Addition for version 5]There are two problems with version 4.  First is that of the first threebulleted points in the version 4 proposal:    * Clarify that SUBTYPEP will return a second value of NIL    only when either of the type specifiers involves the SATISFIES, NOT,     AND, OR, MEMBER. SUBTYPEP will not return a second    value of NIL when both arguments involve only the words in Table 4-1, or    names of DEFSTRUCT- or DEFCLASS-defined types, or user-defined deftypes    that expand into only those words and/or names.    * SUBTYPEP should signal an error when handed (for either argument)    a type specifier that involves VALUES or the list form of the FUNCTION    type.    * SUBTYPEP must always return values T T in the case where the two    type specifiers (or their expansions) are EQUAL.any two have significant overlap, and indeed all three can overlap;version 4 contained no indication of how this conflict should be resolved.Second is that version 4 calls for SUBTYPEP to signal an error (at least athigh safety)even when the arguments are valid type specifiers, but this canmake it harder to use SUBTYPEP.  These are cases that returning NIL NILwas supposed to cover.This version replaces the three bulleted points above with a single pointand some observations about its consequences.  This version eliminatesthe requirement to signal an error.Proposal: SUBTYPEP-TOO-VAGUE:CLARIFY-MOREA type specifier "involves" a word like SATISFIES, MEMBER, NOT, etc.if it either contains it directly or as the result of expansion of a DEFTYPE  defined type specifier. * Clarify that SUBTYPEP is permitted to return NIL NIL only when  at least one argument involves SATISFIES, AND, OR, NOT, MEMBER,  VALUES, or the list form of FUNCTION.  Note that one consequence of this is that if neither argument  involves any of these type specifiers, then SUBTYPEP is obliged  to determine the relationship accurately.  In particular, SUBTYPEP  must return T T if the arguments are EQUAL and do not involve  any of the above-stated type specifiers.* Clarify that the relationships between types reflected by SUBTYPEPare those specific to the particular implementation.  For example, ifan implementation supports only a single type of floating-point numbers,in that implementation (SUBTYPEP 'FLOAT 'LONG-FLOAT) would return T T(since the two types would be identical).Rationale:Specifying the behavior of SUBTYPEP makes it more useful. Otherwise,programs cannot rely on any more than NIL NIL as return values.It is generally conceded that it is impossible to determine therelationships between types defined with the SATISFIES specifier.MEMBER, AND, OR, and NOT are messy to deal with.   Current Practice:The implementation of SUBTYPEP in (the original) HPCL does not try toexpand type specifiers defined with DEFTYPE and does not recognizeEQUAL type specifiers as being equivalent.  Most other implementationsappear to be substantially in conformance with the proposal.Cost to implementors:Some implementations will have to rewrite and/or extend parts of SUBTYPEP.Cost to users:Its hard to imagine a portable program that depends heavilyon SUBTYPEP. This proposal does not require any implementationto "handle" fewer cases of SUBTYPEP.Benefits:An area of confusion in the language is cleared up.  Usages of SUBTYPEPwill be more portable.Discussion:The handling of FLOAT and SINGLE-FLOAT  appeared to be the consensus from a discussion on the common-lisp mailing list some time ago.It would not be too onerous to require implementations to handlethe cases where one but not the other type specifier involvesOR, AND, NOT or MEMBER, but the specification becomes cumbersome.A related issue is clarifying what kinds of type specifiers must berecognized by functions such as MAKE-SEQUENCE and COERCE.  For example,HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a validsequence type when passed to MAKE-SEQUENCE, although SUBTYPEP doesrecognize it to be a subtype of SEQUENCE.  Should this proposal beextended to deal with these issues, or is another proposal in order?The rules for comparing the various type specifiers (such as ARRAY)need to be spelled out in detail.*start*06416 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 17:14:50 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 17:12:15 PSTMessage-ID: <1Evs1R@SAIL.Stanford.EDU>Date: 15 Mar 89 14:49 PSTFrom: System Files <SYS@SAIL.Stanford.EDU>Subject: Issue SUBTYPEP-TOO-VAGUE, version 5 Received: from Think.COM by SAIL.Stanford.EDU with TCP; 15 Mar 89  14:46:57 PSTReceived: from fafnir.think.com by Think.COM; Wed, 15 Mar 89 17:43:08 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Wed, 15 Mar 89 17:44:28 ESTReceived: by verdi.think.com; Wed, 15 Mar 89 17:41:16 ESTDate: Wed, 15 Mar 89 17:41:16 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903152241.AA03730@verdi.think.com>To: cl-cleanup@sail.stanford.eduSubject: Issue SUBTYPEP-TOO-VAGUE, version 5Cc: gls@Think.COMThis is a proposed amendment to version 4 passed in January 1989 at Kauai.Issue:		SUBTYPEP-TOO-VAGUEReferences:	CLtL p. 72-73Category:	CLARIFICATIONEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)                Version 2, 19 Jul 1988 (Sandra Loosemore)                Version 3,  6-Oct-88 (Masinter)                Version 4,  7-Oct-88 (Masinter, per Moon's comments)Problem Description:[From version 4]The description of SUBTYPEP allows it to return a second value of NILwhen the relationship between the two types cannot be determined.  Insome cases this is a reasonable thing to do because it is impossibleto tell (if the SATISFIES type specifier is involved), and in othercases the relationships between types are not well-defined (forexample, the VALUES type specifier or the list form of the FUNCTIONtype specifier). Some implementations, however, have apparently interpreted this tomean that it is permissible for SUBTYPEP to "give up" and return asecond value of NIL in some cases where it actually would be possibleto determine the relationship.  This makes it difficult to depend onsubtype relationships in portable code.[Addition for version 5]There are two problems with version 4.  First is that of the first threebulleted points in the version 4 proposal:    * Clarify that SUBTYPEP will return a second value of NIL    only when either of the type specifiers involves the SATISFIES, NOT,     AND, OR, MEMBER. SUBTYPEP will not return a second    value of NIL when both arguments involve only the words in Table 4-1, or    names of DEFSTRUCT- or DEFCLASS-defined types, or user-defined deftypes    that expand into only those words and/or names.    * SUBTYPEP should signal an error when handed (for either argument)    a type specifier that involves VALUES or the list form of the FUNCTION    type.    * SUBTYPEP must always return values T T in the case where the two    type specifiers (or their expansions) are EQUAL.any two have significant overlap, and indeed all three can overlap;version 4 contained no indication of how this conflict should be resolved.Second is that version 4 calls for SUBTYPEP to signal an error (at least athigh safety)even when the arguments are valid type specifiers, but this canmake it harder to use SUBTYPEP.  These are cases that returning NIL NILwas supposed to cover.This version replaces the three bulleted points above with a single pointand some observations about its consequences.  This version eliminatesthe requirement to signal an error.Proposal: SUBTYPEP-TOO-VAGUE:CLARIFY-MOREA type specifier "involves" a word like SATISFIES, MEMBER, NOT, etc.if it either contains it directly or as the result of expansion of a DEFTYPE  defined type specifier. * Clarify that SUBTYPEP is permitted to return NIL NIL only when  at least one argument involves SATISFIES, AND, OR, NOT, MEMBER,  VALUES, or the list form of FUNCTION.  Note that one consequence of this is that if neither argument  involves any of these type specifiers, then SUBTYPEP is obliged  to determine the relationship accurately.  In particular, SUBTYPEP  must return T T if the arguments are EQUAL and do not involve  any of the above-stated type specifiers.* Clarify that the relationships between types reflected by SUBTYPEPare those specific to the particular implementation.  For example, ifan implementation supports only a single type of floating-point numbers,in that implementation (SUBTYPEP 'FLOAT 'LONG-FLOAT) would return T T(since the two types would be identical).Rationale:Specifying the behavior of SUBTYPEP makes it more useful. Otherwise,programs cannot rely on any more than NIL NIL as return values.It is generally conceded that it is impossible to determine therelationships between types defined with the SATISFIES specifier.MEMBER, AND, OR, and NOT are messy to deal with.   Current Practice:The implementation of SUBTYPEP in (the original) HPCL does not try toexpand type specifiers defined with DEFTYPE and does not recognizeEQUAL type specifiers as being equivalent.  Most other implementationsappear to be substantially in conformance with the proposal.Cost to implementors:Some implementations will have to rewrite and/or extend parts of SUBTYPEP.Cost to users:Its hard to imagine a portable program that depends heavilyon SUBTYPEP. This proposal does not require any implementationto "handle" fewer cases of SUBTYPEP.Benefits:An area of confusion in the language is cleared up.  Usages of SUBTYPEPwill be more portable.Discussion:The handling of FLOAT and SINGLE-FLOAT  appeared to be the consensus from a discussion on the common-lisp mailing list some time ago.It would not be too onerous to require implementations to handlethe cases where one but not the other type specifier involvesOR, AND, NOT or MEMBER, but the specification becomes cumbersome.A related issue is clarifying what kinds of type specifiers must berecognized by functions such as MAKE-SEQUENCE and COERCE.  For example,HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a validsequence type when passed to MAKE-SEQUENCE, although SUBTYPEP doesrecognize it to be a subtype of SEQUENCE.  Should this proposal beextended to deal with these issues, or is another proposal in order?The rules for comparing the various type specifiers (such as ARRAY)need to be spelled out in detail.*start*01052 00024 USfGV-Info: chapman%aitg.DEC@decwrl.dec.com at  1-May-89 20:09:04 from AGReturn-Path: <chapman%aitg.DEC@decwrl.dec.com>Received: from decwrl.dec.com ([128.45.9.1]) by Xerox.COM ; 01 MAY 89 16:42:36 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA12738; Mon, 1 May 89 10:50:42 PDTMessage-Id: <8905011750.AA12738@decwrl.dec.com>Received: by decwrl.dec.com (5.54.5/4.7.34)	for masinter.pa@xerox.com; id AA12738; Mon, 1 May 89 10:50:42 PDTFrom: chapman%aitg.DEC@decwrl.dec.comDate: 1 May 89 13:08To: @masinter@decwrl.dec.comSubject: question @ SUBTYPEP-TOO-VAGUELM,The last version I got of SUBTYPEP-TOO-VAGUE reads like it isVersion 5, but doesn't have Version 5 in the header. That's nobig deal, but since it has some big changes from Version 4, I wondered if what I got was just a review copy or  a final draft?The reason you're getting this question (vs. KMP) is that yourname appeared twice and last in the revision list.Thanks, and how are you doing? How are sections 5.2-5.4 doing? Readyfor more?kc*start*01478 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at  3-May-89 16:54:52 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 MAY 89 16:54:56 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 3 May 89  16:53:46 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 03 MAY 89 16:51:25 PDTDate: 3 May 89 16:51 PDTFrom: masinter.paSubject: [chapman%aitg.DEC@decwrl.dec.com: question @ SUBTYPEP-TOO-VAGUE]To: cl-cleanup@sail.stanford.educc: masinter.paMessage-ID: <890503-165125-11110@Xerox>My record says that we passed version 4 at the January meeting, Guyproduced version 5 in March, but that we didn't discuss version 5, postponeversion 5, or otherwise deal with version 5 at the March meeting. I thinkthis one fell between the cracks... right?     ----- Begin Forwarded Messages -----From: chapman%aitg.DEC@decwrl.dec.comDate: 1 May 89 13:08To: @masinter@decwrl.dec.comSubject: question @ SUBTYPEP-TOO-VAGUELM,The last version I got of SUBTYPEP-TOO-VAGUE reads like it isVersion 5, but doesn't have Version 5 in the header. That's nobig deal, but since it has some big changes from Version 4, I wondered if what I got was just a review copy or  a final draft?The reason you're getting this question (vs. KMP) is that yourname appeared twice and last in the revision list.     ----- End Forwarded Messages -----*start*00926 00024 US GV-Info: chapman%aitg.DEC@decwrl.dec.com at  4-May-89 13:03:52 from AGReturn-Path: <chapman%aitg.DEC@decwrl.dec.com>Received: from decwrl.dec.com ([128.45.9.1]) by Xerox.COM ; 04 MAY 89 13:00:39 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA20114; Thu, 4 May 89 03:43:08 PDTDate: Thu, 4 May 89 03:43:08 PDTMessage-Id: <8905041043.AA20114@decwrl.dec.com>Received: by decwrl.dec.com (5.54.5/4.7.34)	for masinter.pa@xerox.com; id AA20114; Thu, 4 May 89 03:43:08 PDTFrom: chapman%aitg.DEC@decwrl.dec.comTo: masinter.paSubject: RE: [chapman%aitg.DEC@decwrl.dec.com: question @ SUBTYPEP-TOO-VAGUE]>My record says that we passed version 4 at the January meeting, Guy>produced version 5 in March, but that we didn't discuss version 5, postpone>version 5, or otherwise deal with version 5 at the March meeting. I think>this one fell between the cracks... right?So, uh, what should we do?*start*07868 00024 US GV-Info: Moon@STONY-BROOK.SCRC.Symbolics.COM at  4-May-89 12:44:58 from AGReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 04 MAY 89 12:44:26 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 589809; 4 May 89 13:49:40 EDTDate: Thu, 4 May 89 13:49 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: [chapman%aitg.DEC@decwrl.dec.com: question @ SUBTYPEP-TOO-VAGUE]To: masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <890503-165125-11110@Xerox>Message-ID: <19890504174937.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 3 May 89 16:51 PDT    From: masinter.pa@Xerox.COM    My record says that we passed version 4 at the January meeting, Guy    produced version 5 in March, but that we didn't discuss version 5, postpone    version 5, or otherwise deal with version 5 at the March meeting. I think    this one fell between the cracks... right?My records are consistent with that.  I never studied this issue reallycarefully but version 5 was okay with me, more or less.  It's still a bitbogus because an implementation could define all type specifiers asexpansions into SATISFIES, in which case SUBTYPEP could return NIL NILalways.  I suspect the proposal was intended to rule that out, but theactual words that it says fail to rule that out.    From: chapman%aitg.DEC@decwrl.dec.com    The last version I got of SUBTYPEP-TOO-VAGUE reads like it is    Version 5, but doesn't have Version 5 in the header. That's no    big deal, but since it has some big changes from Version 4, I     wondered if what I got was just a review copy or  a final draft?    The reason you're getting this question (vs. KMP) is that your    name appeared twice and last in the revision list.Here is a better version of version 5 that I found in our archives:Date: Wed, 15 Mar 89 17:44:14 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903152244.AA03741@verdi.think.com>To: cl-cleanup@sail.stanford.eduSubject: [gls: Issue SUBTYPEP-TOO-VAGUE, version 5][I forgot to update the edit history.  Here is corrected copy.]Date: Wed, 15 Mar 89 17:41:16 ESTFrom: Guy Steele <gls>To: cl-cleanup@sail.stanford.eduSubject: Issue SUBTYPEP-TOO-VAGUE, version 5Cc: glsThis is a proposed amendment to version 4 passed in January 1989 at Kauai.Issue:		SUBTYPEP-TOO-VAGUEReferences:	CLtL p. 72-73Category:	CLARIFICATIONEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)                Version 2, 19 Jul 1988 (Sandra Loosemore)                Version 3,  6-Oct-88 (Masinter)                Version 4,  7-Oct-88 (Masinter, per Moon's comments)		Version 5, 15-Mar-89 SteeleProblem Description:[From version 4]The description of SUBTYPEP allows it to return a second value of NILwhen the relationship between the two types cannot be determined.  Insome cases this is a reasonable thing to do because it is impossibleto tell (if the SATISFIES type specifier is involved), and in othercases the relationships between types are not well-defined (forexample, the VALUES type specifier or the list form of the FUNCTIONtype specifier). Some implementations, however, have apparently interpreted this tomean that it is permissible for SUBTYPEP to "give up" and return asecond value of NIL in some cases where it actually would be possibleto determine the relationship.  This makes it difficult to depend onsubtype relationships in portable code.[Addition for version 5]There are two problems with version 4.  First is that of the first threebulleted points in the version 4 proposal:    * Clarify that SUBTYPEP will return a second value of NIL    only when either of the type specifiers involves the SATISFIES, NOT,     AND, OR, MEMBER. SUBTYPEP will not return a second    value of NIL when both arguments involve only the words in Table 4-1, or    names of DEFSTRUCT- or DEFCLASS-defined types, or user-defined deftypes    that expand into only those words and/or names.    * SUBTYPEP should signal an error when handed (for either argument)    a type specifier that involves VALUES or the list form of the FUNCTION    type.    * SUBTYPEP must always return values T T in the case where the two    type specifiers (or their expansions) are EQUAL.any two have significant overlap, and indeed all three can overlap;version 4 contained no indication of how this conflict should be resolved.Second is that version 4 calls for SUBTYPEP to signal an error (at least athigh safety)even when the arguments are valid type specifiers, but this canmake it harder to use SUBTYPEP.  These are cases that returning NIL NILwas supposed to cover.This version replaces the three bulleted points above with a single pointand some observations about its consequences.  This version eliminatesthe requirement to signal an error.Proposal: SUBTYPEP-TOO-VAGUE:CLARIFY-MOREA type specifier "involves" a word like SATISFIES, MEMBER, NOT, etc.if it either contains it directly or as the result of expansion of a DEFTYPE  defined type specifier. * Clarify that SUBTYPEP is permitted to return NIL NIL only when  at least one argument involves SATISFIES, AND, OR, NOT, MEMBER,  VALUES, or the list form of FUNCTION.  Note that one consequence of this is that if neither argument  involves any of these type specifiers, then SUBTYPEP is obliged  to determine the relationship accurately.  In particular, SUBTYPEP  must return T T if the arguments are EQUAL and do not involve  any of the above-stated type specifiers.* Clarify that the relationships between types reflected by SUBTYPEPare those specific to the particular implementation.  For example, ifan implementation supports only a single type of floating-point numbers,in that implementation (SUBTYPEP 'FLOAT 'LONG-FLOAT) would return T T(since the two types would be identical).Rationale:Specifying the behavior of SUBTYPEP makes it more useful. Otherwise,programs cannot rely on any more than NIL NIL as return values.It is generally conceded that it is impossible to determine therelationships between types defined with the SATISFIES specifier.MEMBER, AND, OR, and NOT are messy to deal with.   Current Practice:The implementation of SUBTYPEP in (the original) HPCL does not try toexpand type specifiers defined with DEFTYPE and does not recognizeEQUAL type specifiers as being equivalent.  Most other implementationsappear to be substantially in conformance with the proposal.Cost to implementors:Some implementations will have to rewrite and/or extend parts of SUBTYPEP.Cost to users:Its hard to imagine a portable program that depends heavilyon SUBTYPEP. This proposal does not require any implementationto "handle" fewer cases of SUBTYPEP.Benefits:An area of confusion in the language is cleared up.  Usages of SUBTYPEPwill be more portable.Discussion:The handling of FLOAT and SINGLE-FLOAT  appeared to be the consensus from a discussion on the common-lisp mailing list some time ago.It would not be too onerous to require implementations to handlethe cases where one but not the other type specifier involvesOR, AND, NOT or MEMBER, but the specification becomes cumbersome.A related issue is clarifying what kinds of type specifiers must berecognized by functions such as MAKE-SEQUENCE and COERCE.  For example,HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a validsequence type when passed to MAKE-SEQUENCE, although SUBTYPEP doesrecognize it to be a subtype of SEQUENCE.  Should this proposal beextended to deal with these issues, or is another proposal in order?The rules for comparing the various type specifiers (such as ARRAY)need to be spelled out in detail.*start*00382 00024 US GV-Info: masinter.pa at  5-May-89 22:28:39 from massunterDate:  5 May 89 22:28 PDTFrom: masinter.paSubject: RE: [chapman%aitg.DEC@decwrl.dec.com: question @ SUBTYPEP-TOO-VAGUE]In-reply-to: your message of Thu, 4 May 89 03:43:08 PDTTo: chapman%aitg.DEC@decwrl.dec.comcc: masinter.paI think you should edit the standard presuming version 5 will pass.*start*06726 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 21-Jun-89 10:51:36 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 10:51:37 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Jun 89  10:35:19 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 21 JUN 89 10:30:47 PDTDate: 21 Jun 89 10:30 PDTFrom: masinter.paSubject: Issue SUBTYPEP-TOO-VAGUE, version 5to: x3J13@sail.stanford.eduMessage-ID: <890621-103047-17283@Xerox>I don't yet even have an estimate of how much cleanup materialthere is for this meeting.We passed version 4  of SUBTYPEP-TOO-VAGUE at the January meeting, Guyproduced version 5 in March, but that we didn't discuss version 5, postponeversion 5, or otherwise deal with version 5 at the March meeting. I thinkthis one fell between the cracks...David Moon says:"I never studied this issue reallycarefully but version 5 was okay with me, more or less.  It's still a bitbogus because an implementation could define all type specifiers asexpansions into SATISFIES, in which case SUBTYPEP could return NIL NILalways.  I suspect the proposal was intended to rule that out, but theactual words that it says fail to rule that out."!Issue:		SUBTYPEP-TOO-VAGUEReferences:	CLtL p. 72-73Category:	CLARIFICATIONEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)                Version 2, 19 Jul 1988 (Sandra Loosemore)                Version 3,  6-Oct-88 (Masinter)                Version 4,  7-Oct-88 (Masinter, per Moon's comments)		Version 5, 15-Mar-89 SteeleProblem Description:[From version 4]The description of SUBTYPEP allows it to return a second value of NILwhen the relationship between the two types cannot be determined.  Insome cases this is a reasonable thing to do because it is impossibleto tell (if the SATISFIES type specifier is involved), and in othercases the relationships between types are not well-defined (forexample, the VALUES type specifier or the list form of the FUNCTIONtype specifier). Some implementations, however, have apparently interpreted this tomean that it is permissible for SUBTYPEP to "give up" and return asecond value of NIL in some cases where it actually would be possibleto determine the relationship.  This makes it difficult to depend onsubtype relationships in portable code.[Addition for version 5]There are two problems with version 4.  First is that of the first threebulleted points in the version 4 proposal:    * Clarify that SUBTYPEP will return a second value of NIL    only when either of the type specifiers involves the SATISFIES, NOT,     AND, OR, MEMBER. SUBTYPEP will not return a second    value of NIL when both arguments involve only the words in Table 4-1, or    names of DEFSTRUCT- or DEFCLASS-defined types, or user-defined deftypes    that expand into only those words and/or names.    * SUBTYPEP should signal an error when handed (for either argument)    a type specifier that involves VALUES or the list form of the FUNCTION    type.    * SUBTYPEP must always return values T T in the case where the two    type specifiers (or their expansions) are EQUAL.any two have significant overlap, and indeed all three can overlap;version 4 contained no indication of how this conflict should be resolved.Second is that version 4 calls for SUBTYPEP to signal an error (at least athigh safety)even when the arguments are valid type specifiers, but this canmake it harder to use SUBTYPEP.  These are cases that returning NIL NILwas supposed to cover.This version replaces the three bulleted points above with a single pointand some observations about its consequences.  This version eliminatesthe requirement to signal an error.Proposal: SUBTYPEP-TOO-VAGUE:CLARIFY-MOREA type specifier "involves" a word like SATISFIES, MEMBER, NOT, etc.if it either contains it directly or as the result of expansion of a DEFTYPE  defined type specifier. * Clarify that SUBTYPEP is permitted to return NIL NIL only when  at least one argument involves SATISFIES, AND, OR, NOT, MEMBER,  VALUES, or the list form of FUNCTION.  Note that one consequence of this is that if neither argument  involves any of these type specifiers, then SUBTYPEP is obliged  to determine the relationship accurately.  In particular, SUBTYPEP  must return T T if the arguments are EQUAL and do not involve  any of the above-stated type specifiers.* Clarify that the relationships between types reflected by SUBTYPEPare those specific to the particular implementation.  For example, ifan implementation supports only a single type of floating-point numbers,in that implementation (SUBTYPEP 'FLOAT 'LONG-FLOAT) would return T T(since the two types would be identical).Rationale:Specifying the behavior of SUBTYPEP makes it more useful. Otherwise,programs cannot rely on any more than NIL NIL as return values.It is generally conceded that it is impossible to determine therelationships between types defined with the SATISFIES specifier.MEMBER, AND, OR, and NOT are messy to deal with.   Current Practice:The implementation of SUBTYPEP in (the original) HPCL does not try toexpand type specifiers defined with DEFTYPE and does not recognizeEQUAL type specifiers as being equivalent.  Most other implementationsappear to be substantially in conformance with the proposal.Cost to implementors:Some implementations will have to rewrite and/or extend parts of SUBTYPEP.Cost to users:Its hard to imagine a portable program that depends heavilyon SUBTYPEP. This proposal does not require any implementationto "handle" fewer cases of SUBTYPEP.Benefits:An area of confusion in the language is cleared up.  Usages of SUBTYPEPwill be more portable.Discussion:The handling of FLOAT and SINGLE-FLOAT  appeared to be the consensus from a discussion on the common-lisp mailing list some time ago.It would not be too onerous to require implementations to handlethe cases where one but not the other type specifier involvesOR, AND, NOT or MEMBER, but the specification becomes cumbersome.A related issue is clarifying what kinds of type specifiers must berecognized by functions such as MAKE-SEQUENCE and COERCE.  For example,HPCL complains that (SIMPLE-ARRAY (UNSIGNED-BYTE *) (*)) is not a validsequence type when passed to MAKE-SEQUENCE, although SUBTYPEP doesrecognize it to be a subtype of SEQUENCE.  Should this proposal beextended to deal with these issues, or is another proposal in order?The rules for comparing the various type specifiers (such as ARRAY)need to be spelled out in detail.     ----- End Forwarded Messages -----*start*00953 00024 US GV-Info: Moon@STONY-BROOK.SCRC.Symbolics.COM at 21-Jun-89 15:49:07 from AGReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 21 JUN 89 15:49:09 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 614830; 21 Jun 89 18:50:31 EDTDate: Wed, 21 Jun 89 18:51 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue SUBTYPEP-TOO-VAGUE, version 5To: masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <890621-103047-17283@Xerox>Message-ID: <19890621225112.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI overlooked this one because my database has it marked as accepted,even though the database does indicate informally that after it wasaccepted an amendment was proposed that has not yet been acted upon.I wonder how many others there are in that category?