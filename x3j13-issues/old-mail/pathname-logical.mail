*start*01776 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 20:31:16 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Oct 88  20:17:25 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 482752; Wed 26-Oct-88 23:17:19 EDTDate: Wed, 26 Oct 88 23:17 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: logical pathnamesTo: Eric Benson <eb@lucid.com>cc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8810212113.AA00256@blacksox>Message-ID: <19881027031707.3.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 21 Oct 88 14:13:50 pdt    From: Eric Benson <eb@lucid.com>    I wish someone would make a proposal    for generic pathnames.  I don't think they ever got the consideration    they deserved.  (I know they aren't really related to this issue,    except insofar as users would like to have portable pathnames in their    programs.)I deduce you mean "logical pathnames" (pathnames for an imaginary portablefile system, which get translated by site-dependent translations intophysical pathnames on an actual file system), rather than "genericpathnames" (pathnames that stand for a family of related files, such as asource file and its associated compiled file(s)).  I think this has beenproposed a couple of times, only to be shot down, either because it wasthought unnecessary or because the discussants didn't understand it.  Itoo would like to see it proposed and adopted, but I won't propose itmyself, as I am very tired of trying to swim up waterfalls.*start*01497 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 31 OCT 88 18:46:01 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 31 Oct 88  18:43:43 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 31 OCT 88 14:41:54 PSTDate: 31 Oct 88 14:41 PSTFrom: masinter.paSubject: Re: logical pathnamesIn-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 26 Oct 88 23:17 EDTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: Eric Benson <eb@lucid.com>, KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881031-144154-6391@Xerox>I think we need a set of coherent "pathname" proposals. They probably needto be examined in toto. The combiniation of -CANONICAL-TYPE,-COMPONENT-CASE, and a few others bother me because they don't necessarily"hang together". It would be very useful to have a writeup of "current practice" in thisarea. In the Common Lisp documentation I have (which includes recentdocumententation for Envos Medley, Procyon, Franx EXCL, and Vax Lisp, butno others) this information is sketchy. At least the Franx EXCLdocumentation describes how various Unix pathnames are parsed byPARSE-NAMESTRING. Since I don't have the symbolics documentation handy itsa little harder to figure out what Genera Logical Pathnames might do.EB: can you be convinced to put together a proposal?*start*01730 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 02 NOV 88 10:56:50 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 486049; Wed 2-Nov-88 13:32:25 ESTDate: Wed, 2 Nov 88 13:32 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: logical pathnamesTo: masinter.pacc: Eric Benson <eb@lucid.com>, KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881031-144154-6391@Xerox>Message-ID: <19881102183220.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 31 Oct 88 14:41 PST    From: masinter.pa@Xerox.COM    I think we need a set of coherent "pathname" proposals. They probably need    to be examined in toto. The combiniation of -CANONICAL-TYPE,    -COMPONENT-CASE, and a few others bother me because they don't necessarily    "hang together".     It would be very useful to have a writeup of "current practice" in this    area. In the Common Lisp documentation I have (which includes recent    documententation for Envos Medley, Procyon, Franx EXCL, and Vax Lisp, but    no others) this information is sketchy. At least the Franx EXCL    documentation describes how various Unix pathnames are parsed by    PARSE-NAMESTRING. Since I don't have the symbolics documentation handy its    a little harder to figure out what Genera Logical Pathnames might do.Larry, I mailed you the relevant Symbolics book today.    EB: can you be convinced to put together a proposal?I assume you can pass it along to Eric if you think he should have itinstead of you, since you're in adjoining towns.*start*01182 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 21:10:01 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  21:09:44 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 21:08:14 PSTDate: 2 Jan 89 21:07 PSTFrom: masinter.paSubject: Issue: PATHNAME-LOGICAL ?In-reply-to: Eric Benson <eb@lucid.com>'s message of Fri, 21 Oct 88 14:13:50 pdtTo: Eric Benson <eb@lucid.com>cc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890102-210814-1939@Xerox>Re: "I wish someone would make a proposalfor generic pathnames.  I don't think they ever got the considerationthey deserved."There are several issues waiting a "pathname" committee to study themfurther. They include: PATHNAME-COMPONENT-CASE, PATHNAME-LOGICAL, PATHNAME-SUBDIRECTORY-LIST,PATHNAME-SYNTAX-ERROR-TIME, PATHNAME-WILD, STREAM-CAPABILITIES,TRUENAME-SYNTAX-ONLYFrankly, I don't know what  "generic" pathnames are, so I don't know how Icould have considered them. Are they the same thing as "logical" pathnames?*start*01292 00024 US Return-Path: <eb@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 03 JAN 89 08:46:06 PSTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA03074g; Tue, 3 Jan 89 07:52:30 PSTSite: Received: by blacksox id AA00248g; Tue, 3 Jan 89 07:54:37 pstDate: Tue, 3 Jan 89 07:54:37 pstFrom: Eric Benson <eb@lucid.com>Message-Id: <8901031554.AA00248@blacksox>To: masinter.paCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: masinter.pa@Xerox.COM's message of 2 Jan 89 21:07 PST <890102-210814-1939@Xerox>Subject: Issue: PATHNAME-LOGICAL ?   Date: 2 Jan 89 21:07 PST   From: masinter.pa@Xerox.COM   Re: "I wish someone would make a proposal   for generic pathnames.  I don't think they ever got the consideration   they deserved."   There are several issues waiting a "pathname" committee to study them   further. They include:    PATHNAME-COMPONENT-CASE, PATHNAME-LOGICAL, PATHNAME-SUBDIRECTORY-LIST,   PATHNAME-SYNTAX-ERROR-TIME, PATHNAME-WILD, STREAM-CAPABILITIES,   TRUENAME-SYNTAX-ONLY   Frankly, I don't know what  "generic" pathnames are, so I don't know how I   could have considered them. Are they the same thing as "logical" pathnames?Yes, I meant to say logical pathnames.*start*01132 00024 US Date:  4 Apr 89 12:33 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: PATHNAME-LOGICALTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-LOGICALTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:28:07 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:25:09 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571228; Tue 4-Apr-89 15:25:06 EDTOriginal-Date: Tue, 4 Apr 89 15:24 EDTMessage-ID: <890404152441.1.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis was deferred to the next meeting.Moon says that Masinter "tried manfully" to encourage him to write up aproposal, but I doubt anyone really expects it to happen.*start*15385 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-May-89 10:17:52 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAY 89 10:17:53 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 23 May 89  10:15:38 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 599393; 23 May 89 13:17:22 EDTDate: Tue, 23 May 89 13:21 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-LOGICAL (version 2)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19890523172147.5.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This issue is on the agenda for the June X3J13 meeting.  This issue hasnot been written up before.  With KMP's help I have prepared a writeupwhich we think is ready for release.  I'd like to distribute this toX3J13 as soon as discussion, if any, in the cleanup subcommittee iscompleted.Issue:          PATHNAME-LOGICALReferences:     Pathnames (pp410-413)                OPEN (p.418), WITH-OPEN-FILE (p.422), RENAME-FILE (p.423),                DELETE-FILE (p.424), PROBE-FILE (p.424),                FILE-WRITE-DATE (p.424), FILE-AUTHOR (p.424), LOAD (p.426),                COMPILE-FILE (p.439), DIRECTORY (p.427), PATHNAME (p.413),                TRUENAME (p.413), MERGE-PATHNAMES (p.415),                 MAKE-PATHNAME (p.416), and PARSE-NAMESTRING (p.414).Related issues: PATHNAME-CANONICAL-TYPE, PATHNAME-COMPONENT-VALUES,                 PATHNAME-SUBDIRECTORY-LIST, and PATHNAME-WILDCategory:       ADDITIONEdit history:   Version 1, 11-May-89, by Moon                Version 2, 18-May-89, by MoonProblem description:  Pathname values are not portable, but they are sometimes part of a  program, for example the names of files containing the program and the  data used by the program.  Moving large programs between sites would  be easier if pathname values did not have to be translated.  Pathname values are nonportable because not all Common Lisp  implementations use the same operating system and file name syntax varies  widely among operating systems.  In addition, corresponding files at two  different sites may have different names even when the operating system  is the same; for example, they may be on different directories or  different devices.  The issue of portable pathname values is separate from the issues of  portable pathname operations.  See the related issues listed above.  For inter-issue interactions, see the discussion section below.Proposal (PATHNAME-LOGICAL:ADD):  Define a "logical" file system that looks the same at every site.  This  file system is implemented by translating each logical pathname into a  physical pathname on a real file system.  The logical pathnames are the  same at all sites, but the translation rules are different at each site,  thus the physical pathnames can be different at each site.  The syntax of a logical pathname namestring is as follows:     host ":" { directory ";" }* [ name ] [ "." type [ "." version ]]  Terminology:  A word consists of one to twelve uppercase letters, digits, and hyphens.  Lowercase letters are translated to uppercase.  The consequences of using  other characters, or more than twelve characters, are unspecified.  A  wildcard word is "*" (:WILD), which matches anything, or a word with one  or more asterisk characters inserted into it, with no two asterisks  adjacent; each asterisk matches a sequence of zero or more characters.  The maximum number of non-asterisk characters in a wildcard word is 12.  The host is a word that has been defined as a logical pathname host by  using DEFINE-LOGICAL-PATHNAME-TRANSLATIONS.  There is no device, so the device component of a logical pathname is  always :UNSPECIFIC.  No other component can be :UNSPECIFIC.  Each directory is a word, a wildcard word, or "**" (:WILD-INFERIORS).  There are no relative directories.  The name is a word or a wildcard word.  The type is a word or a wildcard word.  The version is a positive decimal integer of one to six digits or  "NEWEST" (:NEWEST) or "*" (:WILD).  The letters in "NEWEST" can be in  either alphabetic case.  The consequences of using anything else as a  version are unspecified.  Some real file systems do not have versions.  Logical pathname  translation to such a file system ignores the version.  This implies that  a program cannot rely on being able to store more than one version of a  file named by a logical pathname.  The type of a logical pathname for a Common Lisp source file is "LISP".  This should be translated into whatever type is appropriate in a physical  pathname.  The logical pathname host name "SYS" is reserved for the implementation.  The existence and meaning of SYS: logical pathnames is  implementation-defined.  The functions OPEN (and WITH-OPEN-FILE), RENAME-FILE, DELETE-FILE,  PROBE-FILE, FILE-WRITE-DATE, FILE-AUTHOR, LOAD, COMPILE-FILE, DIRECTORY,  and TRUENAME accept logical pathnames and translate them into physical  pathnames.  PATHNAME of a stream created by OPEN of a logical pathname is  a logical pathname.  TRUENAME, PROBE-FILE, and DIRECTORY never return  logical pathnames.  RENAME-FILE with a logical pathname as the second  argument returns a logical pathname as the first value.  MERGE-PATHNAMES  returns a logical pathname if and only if its first argument is a logical  pathname or its first argument does not specify a host and the default  host is logical.  MAKE-PATHNAME returns a logical pathname if and only if  the host is logical.  PARSE-NAMESTRING returns a logical pathname if and  only if the string begins with a logical pathname host name (defined by  using DEFINE-LOGICAL-PATHNAME-TRANSLATIONS) and a colon, or the string  does not specify a host and the default host is logical.  Add these defined names to Common Lisp in support of logical pathnames:  LOGICAL-PATHNAME                                              [Class]    LOGICAL-PATHNAME is a subclass of PATHNAME.  TRANSLATE-LOGICAL-PATHNAME pathname                           [Function]    Translate a logical pathname to the corresponding physical pathname.    The pathname argument is first coerced to a pathname.  If it is not a    pathname, string, or file stream an error of type TYPE-ERROR is    signalled.  If the coerced argument is a logical pathname, the first    matching translation (according to PATHNAME-MATCH-P) of the logical    pathname host is applied, using TRANSLATE-PATHNAME with the reversible    argument true, and three values are returned:      1. The physical pathname      2. The from-wildcard of the translation      3. The to-wildcard of the translation    If no translation matches, an error of type FILE-ERROR is signalled.    If the coerced argument is a physical pathname, it is returned as all    three values.  DEFINE-LOGICAL-PATHNAME-TRANSLATIONS host translations &key   [Function]    Define a logical pathname host named <host> (a string or a symbol which    is coerced to a string).  <translations> is a list of translations.    Each translation is a list of from-wildcard and to-wildcard.    From-wildcard must be a logical pathname or a string coercible to a    logical pathname.  To-wildcard must be a physical pathname or a string    coercible to a physical pathname.  Translations are searched in the    order listed, so more specific from-wildcards must precede more general    ones.    The specified translations might be modified or augmented in an    implementation-dependent fashion, typically to provide translation of    file types to local naming conventions, to accomodate physical file    systems with limited length names, or to deal with special character    requirements such as translating hyphens to underscores or uppercase    letters to lowercase.  These modifications are reflected in the second    and third values returned by TRANSLATE-LOGICAL-PATHNAME in such a way    that TRANSLATE-PATHNAME used with them produces the same translation.    If a logical pathname host named <host> already exists, its existing    translations are replaced.    There are no keyword arguments specified by this standard, but any    implementation extensions are provided as keyword arguments or as    translations with more than two elements.  LOAD-LOGICAL-PATHNAME-TRANSLATIONS host                       [Function]    If a logical pathname host named <host> (a string or a symbol which is    coerced to a string) is already defined, return NIL.  Otherwise, search    for a logical pathname host definition in an implementation defined    manner.  If none is found, signal an error.  If a definition is found,    install it and return T.    The search used by LOAD-LOGICAL-PATHNAME-TRANSLATIONS should be    documented, as logical pathname definitions will be created by users,    not only by Lisp implementors.  COMPILE-FILE-PATHNAME pathname &key :output-file              [Function]    Returns the pathname that COMPILE-FILE would write into, if given    the same arguments.Examples:  ;A simple, and typical, example  (define-logical-pathname-translations "FOO"     '(("FOO:**;*.*.*"              "MY-LISPM:>library>foo>**>")))  ;A more complex example  (define-logical-pathname-translations "PROG"     '(("PROG:RELEASED;*.*.*"       "MY-UNIX:/sys/bin/my-prog/")       ("PROG:RELEASED;*;*.*.*"     "MY-UNIX:/sys/bin/my-prog/*/")       ("PROG:EXPERIMENTAL;*.*.*"   "MY-UNIX:/usr/Joe/development/prog/")       ("PROG:EXPERIMENTAL;DOCUMENTATION;*.*.*"                                    "MY-VAX:SYS$DISK:[JOE.DOC]")       ("PROG:EXPERIMENTAL;*;*.*.*" "MY-UNIX:/usr/Joe/development/prog/*/")       ("PROG:MAIL;**;*.MAIL"       "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))  ;This function is like DIRECTORY, but if its argument is a logical  ;pathname it returns logical pathnames in the results.  If its  ;argument is a physical pathname, it is the same as DIRECTORY.  (defun logical-directory (pathname)    (multiple-value-bind (physical from-wildcard to-wildcard)        (translate-logical-pathname pathname)      (map 'list #'(lambda (truename)                     (translate-pathname truename to-wildcard                                         from-wildcard t))           (directory physical))))Rationale:  Large programs can be moved between sites without changing any pathnames,  provided all pathnames used are logical.  A portable system construction  tool can be created that operates on programs defined as sets of files.  Logical pathname syntax was chosen to be easily translated into most  popular file systems, while still being powerful enough for storing large  programs.  Logical pathnames have least-common-denominator capabilities.  Although they have hierarchical directories, versions, and a medium sized  maximum name length, they can be mapped onto a less capable real file  file system by translating each directory that is used into a flat  directory name, treating all versions as :newest, and/or using special  implementation-dependent translation rules to shorten long names.  More advanced capabilities such as relative pathnames and a name for the  root directory were not felt to be necessary in logical pathnames.  They  could be added later if a need emerges.  It is not a goal of logical pathnames to be able to represent all  possible file names.  Their goal is rather to represent just enough file  names to be useful for storing software.  Real pathnames, in contrast,  need to provide a uniform interface to all possible file names, including  names and naming conventions that are not under the control of Common  Lisp.  The choice of logical pathname syntax was guided by the goal of being  visually distinct from real file systems.  The numbers twelve and six are arbitrary but chosen to accomodate  both typical program file names and typical file system limitations.  File systems that are more limited can still be accomodated through  additional implementation-dependent translation as pointed out earlier.  The LOGICAL-PATHNAME class exists so that methods can distinguish  logical pathnames from regular pathnames.  The two extra values returned by TRANSLATE-LOGICAL-PATHNAME allow  for back-translation, as shown in the LOGICAL-DIRECTORY example.  Loading of logical pathname translations from a site-dependent file  allows software to be distributed using logical pathnames.  The software  is supplied with logical pathnames and a sample set of translations.  The  actual translations are defined by the user of the software, since the  supplier does not know the user's local file system conventions.  Loading  the software uses these translations via LOAD-LOGICAL-PATHNAME-TRANSLATIONS.  The COMPILE-FILE-PATHNAME function and the specification of "LISP" as the  type of a logical pathname for a Common Lisp source file together provide  enough information about compilation for a portable system construction  tool that uses logical pathnames to work.Current practice:  Symbolics Genera has had a similar facility for many years.  It is used  extensively for software distribution by Symbolics and its customers.  The Genera facility uses the same logical pathname syntax but different  function names, and is somewhat more complicated.  The extra complexity  is not necessary in the Common Lisp standard.  Symbolics Genera offers a function for translating from a physical  pathname back to a logical pathname.  There are a number of problems with  this, and so it has not been proposed here.  Instead  TRANSLATE-LOGICAL-PATHNAME returns enough information to allow the user  program to perform the backtranslation itself.  The Genera equivalent of LOAD-LOGICAL-PATHNAME-TRANSLATIONS looks for  a file named SYS:SITE;hostname.TRANSLATIONS.Cost to Implementors:  This is a fairly complex facility, but its performance is unimportant  so a straightforward implementation should suffice.  Most of the  complexity comes in dealing with unusual file systems, such as ones  that don't allow file names longer than eight characters.Cost to Users:  None.Cost of non-adoption:  Portable software construction and distribution will have to rely on  implementation-dependent kludges.  Lisp software will continue to be  difficult to install.Performance impact:  None.Benefits:  Avoid cost of non-adoption.Esthetics:  Improved portability of large programs.Discussion:  Issue PATHNAME-LOGICAL fundamentally depends on issue PATHNAME-WILD.  If PATHNAME-CANONICAL-TYPE:NEW-CONCEPT passes, it will affect the  behavior of the function TRANSLATE-PATHNAME and therefore the behavior of  the function TRANSLATE-LOGICAL-PATHNAME.  When a logical pathname  translation has from and to type fields that are * or omitted,  translation of the type will be guided by canonical types.  If  PATHNAME-CANONICAL-TYPE:NEW-CONCEPT fails to pass, it will either have to  be done behind the scenes by TRANSLATE-PATHNAME or users will have to  write more verbose translations that individually specify the handling of  each file type.*start*01463 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 24-May-89 11:29:13 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAY 89 11:14:37 PDTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 24 May 89  11:12:38 PDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA25230@EDDIE.MIT.EDU>; Wed, 24 May 89 14:12:33 EDTReceived: by spt.entity.com (smail2.5); 24 May 89 12:52:13 EDT (Wed)Date: Wed, 24 May 89 12:52:12 EDTFrom: Gail Zacharias <gz@spt.entity.com>To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: PATHNAME-LOGICAL (version 2) In-Reply-To: Your message of Tue, 23 May 89 13:21 EDT Message-Id: <CMM.0.88.612031932.gz@spt.entity.com>I really like this, except that I have a problem with the syntax - it lookstoo much like the Macintosh pathname syntax.  A name like "pcl:foo.lisp" canbe parsed as either a physical Macintosh pathname or a logical pathname.  Irealize that the proposal is unambiguous on this point, resolving it in favorof a logical pathname.  But this means that a program defining a logical "pcl"host thereby makes impossible for the user to access files on his physical"pcl" disk.  Note that TOPS-20, VMS and (I think) MSDOS have a similarproblem.How about using "!" as the host separator?*start*04026 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 24-May-89 13:36:26 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAY 89 13:36:13 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 24 May 89  13:34:49 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 600216; 24 May 89 16:36:42 EDTDate: Wed, 24 May 89 16:40 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-LOGICAL (version 2) To: Gail Zacharias <gz@spt.entity.com>cc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <CMM.0.88.612031932.gz@spt.entity.com>Message-ID: <19890524204040.0.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>    Date: Wed, 24 May 1989 12:52:12 EDT    From: Gail Zacharias <gz@spt.entity.com>I noticed Coral (Macintosh Allegro Common Lisp) has a logical pathnamefeature which is somewhat simpler but aimed at solving the same problems.In particular your feature only affects the directory component and doesnot allow wildcard mapping, only one-to-one mapping.  Should we saysomething about this in the current practice section?    I really like this, except that I have a problem with the syntax - it looks    too much like the Macintosh pathname syntax.  A name like "pcl:foo.lisp" can    be parsed as either a physical Macintosh pathname or a logical pathname.  I    realize that the proposal is unambiguous on this point, resolving it in favor    of a logical pathname.  But this means that a program defining a logical "pcl"    host thereby makes impossible for the user to access files on his physical    "pcl" disk.  Note that TOPS-20, VMS and (I think) MSDOS have a similar    problem.The use of colon affects Symbolics more than anybody, since logicalpathname host names conflict with network host names, whereas on theMacintosh and those DEC and IBM systems they only conflict with devicenames, usually a much smaller set and often chosen with names that aredistinctive enough that conflict is unlikely.  We thought about this butno matter what syntax we choose it's going to be a conflict forsomebody.  We can't even use double colon without conflict since DEC isalready using it.I could make the alternate argument that the use of colon fits reallynicely into the Macintosh environment, where hd: means the hard disk,carry: means the floppy disk used for taking stuff between machines, andpcl: means the logical disk with PCL on it.  Does that make sense toyou?  I could also point out that the Macintosh already allows you tohave two volumes with the same name and (usually!) provides mechanisms(such as the Drive button in the Standard File dialog) to allow youto disambiguate.    How about using "!" as the host separator?That's current practice in Coral (except I gather you currently throwaway the host and don't do anything with it), but might be consideredpoor in the standard since ! is one of the characters that Common Lisphas been careful not to use for anything and leave for the users.Another thing we could do is to make logical pathname namestringsmore distinctive; instead of starting with a word that has been definedas a logical pathname host name, they could start with some character.However, I have been unable to think of any character that would notconflict with existing use in some file system.I'm amenable to alternative syntax suggestions.  I'll be surprised ifanyone comes up with a good one, though, since this has been exploredbefore without success.  I think we just have to grab some syntacticspace for logical pathnames.The other thing we could do is not standardize logical pathnamenamestrings at all, but require some other construct to be used, perhapsa make-pathname call or a new function (logical-pathname "string").  Ithink that would be very ugly and I'd like to avoid it.*start*06119 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 26-May-89 09:08:59 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 MAY 89 09:09:00 PDTReceived: from REAGAN.AI.MIT.EDU by SAIL.Stanford.EDU with TCP; 26 May 89  09:04:47 PDTReceived: from ANNA-MAGDALENA-BACH.AI.MIT.EDU by REAGAN.AI.MIT.EDU via CHAOS with CHAOS-MAIL id 214133; Fri 26-May-89 12:03:53 EDTDate: Thu, 25 May 89 13:12 EDTFrom: "David A. Moon" <Moon@stony-brook.scrc.symbolics.com>Subject: Issue: PATHNAME-LOGICAL (version 2)To: Mly-lisp%mc.lcs.mit.edu@lcs.mit.eduIn-Reply-To: <19890525163809.5.MLY@JACKIE-O.AI.MIT.EDU>Message-ID: <19890525171242.5.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>Resent-To: CL-Cleanup@sail.stanford.eduResent-From: Richard Mlynarik <Mly@AI.AI.MIT.EDU>Resent-Date: Fri, 26 May 89 12:03 EDTResent-Message-ID: <19890526160304.1.MLY@ANNA-MAGDALENA-BACH.AI.MIT.EDU>Resent-Comments: My comments on PATHNAME-LOGICAL (Version 2)I might not agree with all of your points here, but I think theyare well-taken.  Do you mind if I forward this message toCL-Cleanup or do you want to keep it private?    Date: Thu, 25 May 89 12:38 EDT    From: Richard Mlynarik <Mly@AI.AI.MIT.EDU>    1 I believe that mixing in the issue of parsing out host components from      pathname namestrings is a real mistake -- I hope it it grave enough to      kill this proposal (of the spirit of which I am otherwise extremely      supportive.)      To my thinking, a much better idea would be to define a new function, say,      (LOGICAL-PATHNAME <host-name> <namestring>) which would return a logical      pathname.      This has the advantage of not requiring that CL get into the business      of deciding whether hosts in general are found by      "HOST:" or "HOST::" or "/../HOST/" or whatever, and I think that this is      necessary in order to avoid huge confusion.      It has the disadvantage of not -specifying- a way for users to type      a logical pathname on a specific when being prompted by the system      (ie it doesn't specify the format of the string one must feed into the      PATHNAME function in order to get out a specific logical pathname.      It should be noted that CLtL is silent in general on what strings      produce what results from PATHNAME and I suspect it would be a mistake      to attempt to change this at this stage -- my extremely positive      experiences with symbolics' integrated and largely-consistent pathname      system notwithstanding.)      Note that -implementations- are free to specify some way of specifying      logical pathnames -- Symbolics' specification would be that one      specifies a string with a prefix of "Logical-Host-Name:"    2 My second problem is with the syntax of the pathnames.      I really think that this pseudo-ITSism has gone on long enough.      It has pissed me off for years that bolix logical pathnames don't      have the same basic syntax as LMFS and FEP pathnames (which after all      have the best of all possible syntaxes.  I'm not joking!)      I note the rationale	``The choice of logical pathname syntax was guided by the goal of being	  visually distinct from real file systems.''      but have never bought this argument and never will.  By the same reasoning,      shouldn't FEP filesystem pathnames be visually distinct from their LMFS      counterparts?      The present logical pathname syntax is just too complicated -- it's like      C code (do I have a use a #\; or a #\. here?) -- and more importantly,      makes it unnecessarily hard to express `the root directory' and      `up one directory level' and suchlike.      Another bug with the existing syntax is that it requires at least one level      of directory;  this has often annoyed me with lispm logical directories.      One can't say "PCL:>*.*.*", one must instead use "PCL:>PCL>*.*.*" or somesuch.	  DEFINE-LOGICAL-PATHNAME-TRANSLATIONS host translations &key   [Function]	    Define a logical pathname host named <host> (a string or a symbol which	    is coerced to a string).  <translations> is a list of translations.	    Each translation is a list of from-wildcard and to-wildcard.	    From-wildcard must be a logical pathname or a string coercible to a	    logical pathname.  To-wildcard must be a physical pathname or a string	    coercible to a physical pathname.  Translations are searched in the	    order listed, so more specific from-wildcards must precede more general	    ones.    3 Because of my point (1) above, I believe that the `left-hand' side of the      translation must be a string which is coerce to a logical pathname by the      [proposed] function (LOGICAL-PATHNAME <host-specified-by-first-arg-to-def-l-p-t> <the-string>)      There are problems with allowing `from-wildcard' to be a logical pathname object:      firstly, it is an error for it to be a logical pathname with a different logical      pathname host and secondly there are conceivable circularity problems with      actually defining or redefining such a form (the pathnames themselves depend      on the result of evaluating the whole form in some sense.)      So I'd require your examples to be written as	  ;A simple, and typical, example	  (define-logical-pathname-translations "FOO"	     '((">**>*.*.*" "MY-LISPM:>library>foo>**>")))	  ;A more complex example	  (define-logical-pathname-translations "PROG"	     '((">RELEASED>*.*.*"       "MY-UNIX:/sys/bin/my-prog/")	       (">RELEASED>*>*.*.*"     "MY-UNIX:/sys/bin/my-prog/*/")	       (">EXPERIMENTAL>*.*.*"   "MY-UNIX:/usr/Joe/development/prog/")	       (">EXPERIMENTAL>DOCUMENTATION>*.*.*"					"MY-VAX:SYS$DISK:[JOE.DOC]")	       (">EXPERIMENTAL>*>*.*.*" "MY-UNIX:/usr/Joe/development/prog/*/")	       (">MAIL>**>*.MAIL"       "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))      with the explicit proviso that the "MY-LISPM:" "MY-UNIX:" etc syntax on the      right-hand sides is implementation-specific*start*02911 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 25-May-89 12:41:43 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAY 89 12:41:44 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 25 May 89  12:39:37 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA19949; Thu, 25 May 89 13:39:57 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA09185; Thu, 25 May 89 13:39:54 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8905251939.AA09185@defun.utah.edu>Date: Thu, 25 May 89 13:39:52 MDTSubject: Re: Issue: PATHNAME-LOGICAL (version 2)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@sail.stanford.edu, sandra%defun@cs.utah.edu, gray@dsg.csc.ti.comIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Tue, 23 May 89 13:21 EDTI have a number of problems with this proposal...I don't understand why there's any need for magic numbers (12 and 6)and restrictions on what characters may appear in a logical pathnamecomponent.  The rationale says this is an arbitrary decision, butdoesn't address the question of why restrictions are necessary at all. The proposal mentions that not all filesystems support versions andthat versions in logical pathnames can't be used portably.  Moregenerally, not all filesystems have notions of hosts, devices,directories, and file types either.  (In other words, about the onlything you can depend on a filename always having is a name.) Why treatversions as a special case, but ignore all the other problems?How are functions like OPEN supposed to map a logical pathname onto a realpathname?  (Does it do it in the same way as TRANSLATE-LOGICAL-PATHNAME or can it use some other mapping?)The dependence on issue PATHNAME-WILD (the functions PATHNAME-MATCH-Pand TRANSLATE-PATHNAME that are referenced in the description ofTRANSLATE-LOGICAL-PATHNAME) ought to be made more explicit.  Whathappens if PATHNAME-WILD fails?LOAD-LOGICAL-PATHNAME-TRANSLATIONS sounds suspiciously like REQUIRE --I'm sure that's a bad sign... COMPILE-FILE-PATHNAME doesn't seem to have anything to do with therest of this proposal. In general, I don't really see what this proposal buys the user thatcan't already be achieved using other mechanisms that are already partof the language.  For example, when I have some files that live indifferent places on different hosts, I usually put a pathnamecontaining the appropriate pathname for that place in a variable andcall MERGE-PATHNAMES to get the full pathnames of the individualfiles.  Logical pathnames don't eliminate the necessity of havingliteral, host-specific pathnames in a program; you still have tosupply them to DEFINE-LOGICAL-PATHNAME-TRANSLATIONS.-Sandra-------*start*04611 00024 USaGV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 26-May-89 10:00:20 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 MAY 89 10:00:15 PDTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 26 May 89  09:52:18 PDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA12802@EDDIE.MIT.EDU>; Fri, 26 May 89 12:51:56 EDTReceived: by spt.entity.com (smail2.5); 26 May 89 12:43:48 EDT (Fri)Date: Fri, 26 May 89 12:43:48 EDTFrom: Gail Zacharias <gz@spt.entity.com>To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: PATHNAME-LOGICAL (version 2) In-Reply-To: Your message of Wed, 24 May 89 16:40 EDT Message-Id: <CMM.0.88.612204228.gz@spt.entity.com>    Date: Wed, 24 May 89 16:40 EDT    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    I noticed Coral (Macintosh Allegro Common Lisp) has a logical pathname    feature which is somewhat simpler but aimed at solving the same problems.    In particular your feature only affects the directory component and does    not allow wildcard mapping, only one-to-one mapping.  Should we say    something about this in the current practice section?Right, we have logical directory names, to simplify access to sets of files indifferently named directories (an especially severe problem on micros whereeverybody just has to have a different pet name for their hard disk).  Thisisn't really the same as simplifying access to different file systems,although of course solving the latter automatically solves the former.						   We thought about this but    no matter what syntax we choose it's going to be a conflict for    somebody.Well, it seems like this particular choice conflicts with just about everybody(except unix), so maybe it's worth considering alternatives...    I could make the alternate argument that the use of colon fits really    nicely into the Macintosh environment, where hd: means the hard disk,    carry: means the floppy disk used for taking stuff between machines, and    pcl: means the logical disk with PCL on it.  Does that make sense to    you?Unfortunately, another very common convention (among the better-organizedtypes, I guess) is for the floppy used to carry pcl-related stuff betweenmachines to be called pcl:.What I'm really concerned about is users finding that loading up pcl "breaksthe file system" because they can no longer open files on their pcl: floppy.This sort of thing might be less of an issue for lisp machines, where userstend to live entirely in the lisp machine world and so are more willing togrant first-class status to lisp-defined conventions.  I think on a Mac userswould expect "real" file names to take precedence over any logical namesinternal to Lisp.						      might be considered    poor in the standard since ! is one of the characters that Common Lisp    has been careful not to use for anything and leave for the users.But users don't get to do anything with the pathname syntax - they moreor less have to take what the implementation/OS gives them.  So thisisn't really taking anything away from users.But be that as it may, how about '|'?  Or '\' (a.k.a. '\\')?What I think is needed here is a character which is not special in any (ormost) file systems.  I.e. it should either be unused (i.e. illegal) or be alegal (but unusual) filename constituent.  The problem with ":" is that it isa special character in far too many file systems, so it results in anunresolvable conflict between the logical and physical interpretation.  Whenthe character is a constituent, users can state their intent by either quotingor not quoting it.  Of course "quoting" is implementation dependent, butthat's ok, because the only time you need to quote it is when specifying animplementation-depend namestring.  I'd rather give up a single character(which can be easily documented) than have this vague situation where whathappens depends entirely on the current set of logical hosts, and there is noway to specify a physical filename.    The other thing we could do is not standardize logical pathname    namestrings at all, but require some other construct to be used, perhaps    a make-pathname call or a new function (logical-pathname "string").  I    think that would be very ugly and I'd like to avoid it.Why would it be ugly?  Would it still be ugly if there was a reader macrothat called LOGICAL-PATHNAME?*start*01319 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 30-May-89 09:09:42 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 MAY 89 09:09:24 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 May 89  09:07:16 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 30 MAY 89 09:07:36 PDTDate: 30 May 89 09:07 PDTFrom: masinter.paSubject: Re: Issue: PATHNAME-LOGICAL (version 2) In-reply-to: Gail Zacharias <gz@spt.entity.com>'s message of Fri, 26 May 89 12:43:48 EDTTo: CL-Cleanup@sail.stanford.eduMessage-ID: <890530-090736-7241@Xerox>I think this discussion is leading in a productive direction. Standardizingon a funny syntax for namestrings on the grounds that it is  "differentenough" from the file systems we know about seems like we're going in thewrong direction; it presumes that we know about all possible file systemsto which the Standard might need to be connected.If we want to do anything about logical pathnames at all, building Lispconstructors for them (either as a new function, MAKE-LOGICAL-PATHNAME, orpossibly a just new keyword for MAKE-PATHNAME which can be used instead ofhost+device+directory) sounds less likely to lead us into trouble. *start*02390 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at  8-Jun-89 17:25:11 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JUN 89 17:25:05 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 8 Jun 89  17:23:45 PDTReceived: by ti.com id AA05020; Thu, 8 Jun 89 18:40:14 CDTReceived: from Kelvin by tilde id AA24737; Tue, 6 Jun 89 17:15:26 CDTMessage-Id: <2822163312-14997875@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 6 Jun 89 17:15:12 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Gail Zacharias <gz@spt.entity.com>Cc: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>, CL-Cleanup@sail.stanford.eduSubject: Re: Issue: PATHNAME-LOGICAL (version 2) In-Reply-To: Msg of Fri, 26 May 1989 12:43:48 EDT from Gail Zacharias <gz@spt.entity.com>> 						   We thought about this but>     no matter what syntax we choose it's going to be a conflict for>     somebody.> > Well, it seems like this particular choice conflicts with just about everybody> (except unix), so maybe it's worth considering alternatives...On the Explorer, we use the colon as the host delimiter for allpathnames, which includes support for files on Symbolics, VAX-VMS,MS-DOS, Multics, and Macintosh as well as Unix, the local Explorerfiles, and logical pathnames.  This has not been seen to be a problem.True, for MS-DOS and Macintosh pathnames, a host must always be suppliedsince the first colon is taken to be a host delimiter.  Even this hasn'tbeen considered to be a problem, but that is probably just because weare in the habit of always specifying the host anyway because thepathname defaulting facilities in our environment are too unpredictableto be of much use.I can see, though, that if you are on a non-networked Macintosh, itcould be annoying to have to specify the host even though there is onlyone host that you are using.I wonder, since neither MS-DOS or Macintosh pathnames use the semicolon[the proposed logical pathname directory delimiter], if it would bereasonable in such an environment to consider the first colon to be ahost delimiter only if the namestring contains a semicolon?  Since itwould be unusual to want to use a namestring consisting of only a hostname, that could be a useful way of avoiding the ambiguity.*start*03818 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at  8-Jun-89 17:24:21 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JUN 89 17:24:19 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 8 Jun 89  17:23:07 PDTReceived: by ti.com id AA05043; Thu, 8 Jun 89 18:40:46 CDTReceived: from Kelvin by tilde id AA25501; Tue, 6 Jun 89 18:08:51 CDTMessage-Id: <2822166522-15190737@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 6 Jun 89 18:08:42 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: PATHNAME-LOGICAL (version 2)In-Reply-To: Msg of Tue, 23 May 89 13:21 EDT from David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>> Proposal (PATHNAME-LOGICAL:ADD):Basically I like this proposal.  We use logical pathnames a lot, andthis proposal would make them even better without appearing to requireany incompatible change for us.>   The syntax of a logical pathname namestring is as follows:> >      host ":" { directory ";" }* [ name ] [ "." type [ "." version ]]I would prefer to use "#" as the version prefix.  More than once I'vebeen annoyed when using Symbolics pathnames to not be able to specify aversion without also specifying the type.>   A word consists of one to twelve uppercase letters, digits, and hyphens.>   Lowercase letters are translated to uppercase.  The consequences of using>   other characters, or more than twelve characters, are unspecified.The 12-character limit doesn't seem to have any clear significance.Since it is common for older file systems to have an 8-character limitfor file names, maybe it would be more meaningful to say that names canbe any length, but only the first 8 characters are guaranteed to besignificant on all implementations.>   There is no device, so the device component of a logical pathname is>   always :UNSPECIFIC.  No other component can be :UNSPECIFIC.I presume you mean that the standard doesn't specify any portablemeaning for an :UNSPECIFIC component, and don't intend to rule out itsuse in generic pathnames as an extension?>   DEFINE-LOGICAL-PATHNAME-TRANSLATIONS host translations &key   [Function]> >     Define a logical pathname host named <host> (a string or a symbol which>     is coerced to a string).  <translations> is a list of translations.>     Each translation is a list of from-wildcard and to-wildcard.>     From-wildcard must be a logical pathname or a string coercible to a>     logical pathname. Could we say  ...  coercible to a logical pathname using "<host>:" as the  default pathname.so that the host doesn't have to be explicitly supplied every time?> 	...	To-wildcard must be a physical pathname or a >     coercible to a physical pathname. Is there any reason to not permit this to be another logical pathname?>     There are no keyword arguments specified by this standard, but any>     implementation extensions are provided as keyword arguments or as>     translations with more than two elements.An extension I would like to have is the ability to specify what syntaxwill be used for parsing the name strings.  If I'm using logicalpathnames for my own convenience, rather than portability, then I wouldlike to be able to use whatever pathname syntax I like the most.> Current practice:The Explorer also has a comparable logical pathname facility, althoughthe translation mechanism is unfortunately less general than proposedhere.  The namestring syntax used is slightly different:  host ":" [{directory "."}* directory ";"] [name] ["." type] ["#" version]The newest version is indicated by ">" instead of "newest".*start*03818 00024 USmGV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at  8-Jun-89 17:24:21 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JUN 89 17:24:19 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 8 Jun 89  17:23:07 PDTReceived: by ti.com id AA05043; Thu, 8 Jun 89 18:40:46 CDTReceived: from Kelvin by tilde id AA25501; Tue, 6 Jun 89 18:08:51 CDTMessage-Id: <2822166522-15190737@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 6 Jun 89 18:08:42 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: PATHNAME-LOGICAL (version 2)In-Reply-To: Msg of Tue, 23 May 89 13:21 EDT from David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>> Proposal (PATHNAME-LOGICAL:ADD):Basically I like this proposal.  We use logical pathnames a lot, andthis proposal would make them even better without appearing to requireany incompatible change for us.>   The syntax of a logical pathname namestring is as follows:> >      host ":" { directory ";" }* [ name ] [ "." type [ "." version ]]I would prefer to use "#" as the version prefix.  More than once I'vebeen annoyed when using Symbolics pathnames to not be able to specify aversion without also specifying the type.>   A word consists of one to twelve uppercase letters, digits, and hyphens.>   Lowercase letters are translated to uppercase.  The consequences of using>   other characters, or more than twelve characters, are unspecified.The 12-character limit doesn't seem to have any clear significance.Since it is common for older file systems to have an 8-character limitfor file names, maybe it would be more meaningful to say that names canbe any length, but only the first 8 characters are guaranteed to besignificant on all implementations.>   There is no device, so the device component of a logical pathname is>   always :UNSPECIFIC.  No other component can be :UNSPECIFIC.I presume you mean that the standard doesn't specify any portablemeaning for an :UNSPECIFIC component, and don't intend to rule out itsuse in generic pathnames as an extension?>   DEFINE-LOGICAL-PATHNAME-TRANSLATIONS host translations &key   [Function]> >     Define a logical pathname host named <host> (a string or a symbol which>     is coerced to a string).  <translations> is a list of translations.>     Each translation is a list of from-wildcard and to-wildcard.>     From-wildcard must be a logical pathname or a string coercible to a>     logical pathname. Could we say  ...  coercible to a logical pathname using "<host>:" as the  default pathname.so that the host doesn't have to be explicitly supplied every time?> 	...	To-wildcard must be a physical pathname or a >     coercible to a physical pathname. Is there any reason to not permit this to be another logical pathname?>     There are no keyword arguments specified by this standard, but any>     implementation extensions are provided as keyword arguments or as>     translations with more than two elements.An extension I would like to have is the ability to specify what syntaxwill be used for parsing the name strings.  If I'm using logicalpathnames for my own convenience, rather than portability, then I wouldlike to be able to use whatever pathname syntax I like the most.> Current practice:The Explorer also has a comparable logical pathname facility, althoughthe translation mechanism is unfortunately less general than proposedhere.  The namestring syntax used is slightly different:  host ":" [{directory "."}* directory ";"] [name] ["." type] ["#" version]The newest version is indicated by ">" instead of "newest".*start*15874 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 12-Jun-89 16:03:14 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JUN 89 16:03:07 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 12 Jun 89  16:01:23 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 610027; 12 Jun 89 19:02:25 EDTDate: Mon, 12 Jun 89 19:02 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-LOGICAL (version 2)To: Richard Mlynarik <Mly@AI.AI.MIT.EDU>, Sandra J Loosemore <sandra%defun@cs.utah.edu>, Gail Zacharias <gz@spt.entity.com>, masinter.pa, David N Gray <Gray@DSG.csc.ti.com>cc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890526160304.1.MLY@ANNA-MAGDALENA-BACH.AI.MIT.EDU>,             <8905251939.AA09185@defun.utah.edu>,             <CMM.0.88.612204228.gz@spt.entity.com>,             <890530-090736-7241@Xerox>,             <2822163312-14997875@Kelvin>,             <2822166522-15190737@Kelvin>Message-ID: <19890612230247.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI'm having trouble finding the time to write up revised versions ofthese issues, based on your comments, but here is an acknowledgement ofyour comments (including the ones not copied in this reply!) and someresponses to some of the comments.    Date: Thu, 25 May 89 12:38 EDT    From: Richard Mlynarik <Mly@AI.AI.MIT.EDU>    1 I believe that mixing in the issue of parsing out host components from      pathname namestrings is a real mistake....      To my thinking, a much better idea would be to define a new function, say,      (LOGICAL-PATHNAME <host-name> <namestring>) which would return a logical      pathname.See comments below after GZ's message.  I don't think I can write up arevised version of the proposal until this is resolved, so far I'm stillmulling it over in my own mind and don't have a firm opinion yet.    2 My second problem is with the syntax of the pathnames.I'll mull over these comments too, although I'd like to point out thatI don't think logical pathnames should be asked to represent all featuresof all (or even most) real file systems.    Date: Thu, 25 May 89 13:39:52 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    I don't understand why there's any need for magic numbers (12 and 6)    and restrictions on what characters may appear in a logical pathname    component.  The rationale says this is an arbitrary decision, but    doesn't address the question of why restrictions are necessary at all. I think these length limits were a mistake, and I propose to remove themin version 3 of the proposal.  It is always up to the person who writesthe translation rules for a particular logical pathname host to aparticular physical file system to make sure that the pathnames that aregoing to be used translate to valid pathnames for the particular filesystem.  The length limits were supposed to make that easier to do, butthey didn't.  I'll put in an example showing how to do this for yourfavorite (!) file system, the Cray with 6 character names and nodirectories, types, or versions.    The proposal mentions that not all filesystems support versions and    that versions in logical pathnames can't be used portably.  More    generally, not all filesystems have notions of hosts, devices,    directories, and file types either.  (In other words, about the only    thing you can depend on a filename always having is a name.) Why treat    versions as a special case, but ignore all the other problems?Because the other fields can be addressed by translation, but it doesn'treally make sense to do that for versions.  Actually, this is not anabsolute, versions could be done by translation.  However, the typicaluse of versions is such that on a file system without versions, peoplewould rather just store one version, and not specify translations thatwill preserve the version information by encoding it in the name.  Thisis different from the typical use of types or directories, where thefiles with different values in those components are truly distinct andeverything would break if you only kept one of them.At least, that's what I thought.  Perhaps I was wrong and we wouldrather mandate that versions always work in logical pathnames,translating into whatever is necessary to preserve the information.Another possibility that might bear thinking about is to say thatlogical pathnames never have versions, but I know that some developmentsystems make very effective use of file version numbers, so I'm reluctantto just rule them out entirely.    How are functions like OPEN supposed to map a logical pathname onto a real    pathname?  (Does it do it in the same way as TRANSLATE-LOGICAL-PATHNAME or     can it use some other mapping?)They don't have to actually call the function TRANSLATE-LOGICAL-PATHNAME, butthey have to produce the same result.  This should have been explicit in theproposal.    The dependence on issue PATHNAME-WILD (the functions PATHNAME-MATCH-P    and TRANSLATE-PATHNAME that are referenced in the description of    TRANSLATE-LOGICAL-PATHNAME) ought to be made more explicit.  What    happens if PATHNAME-WILD fails?I thought it said somewhere that PATHNAME-LOGICAL cannot pass ifPATHNAME-WILD fails.    LOAD-LOGICAL-PATHNAME-TRANSLATIONS sounds suspiciously like REQUIRE --    I'm sure that's a bad sign... It does, but I hope that being much more task-specific, it doesn't reallyhave the same problems.    COMPILE-FILE-PATHNAME doesn't seem to have anything to do with the    rest of this proposal. It's another part of what you need to actually use logical pathnames forstoring programs.  Suppose you want to call COMPILE-FILE only if the sourcefile is newer than the compiled file.  To do that, you have to have a wayto know the name of the compiled file without actually calling COMPILE-FILE.I could have proposed that logical pathnames always use a specific namingconvention for compiled files, as I did for source files, but for compiledfiles it seemed better to let the implementation control the name.  Doyou think a different approach should have been taken, or did you justwant to see this proposal split into parts?    In general, I don't really see what this proposal buys the user that    can't already be achieved using other mechanisms that are already part    of the language.  For example, when I have some files that live in    different places on different hosts, I usually put a pathname    containing the appropriate pathname for that place in a variable and    call MERGE-PATHNAMES to get the full pathnames of the individual    files.  Logical pathnames don't eliminate the necessity of having    literal, host-specific pathnames in a program; you still have to    supply them to DEFINE-LOGICAL-PATHNAME-TRANSLATIONS.Then you've missed the point, which should have been described moreclearly in the issue writeup.The call to DEFINE-LOGICAL-PATHNAME-TRANSLATIONS isn't part of theprogram, it's separate.  That separation, and a uniform conventionfor how to do the separation, are the key aspects of logical pathnames.I agree that Common Lisp is Turing-machine-equivalent with or withoutlogical pathnames, or, more seriously, that each user could implementsomething like logical pathnames for himself.  The reason to standardizeit is so everyone will do it the same and so individual users can spendtheir time writing applications instead of doing this kind of systemprogramming.  Note that your way sounds simple, but it doesn't staysimple when you get into more complicated situations such as programgenerated file names or porting a program developed on a system withlong file names onto a system with a very restrictive limit on thelength of file names.    Date: Fri, 26 May 1989 12:43:48 EDT    From: Gail Zacharias <gz@spt.entity.com>    .... [discussion of various logical namestring syntax ideas]I don't know what I think yet about whether logical pathnames shouldhave a namestring syntax that is specified to be distinguishable fromall physical pathname namestrings, or whether there should be aLOGICAL-PATHNAME function distinct from the PATHNAME function.  I'msuspicious of the latter idea because I know that in current practice itis very common to have strings that are sometimes one kind of pathnameand sometimes the other kind; thus it seems desirable to have all theoperations, including parsing, be generic for both kinds of pathnames.What if you have a string that is just "FOO", i.e. just a namecomponent?  However, I haven't had time to think out the fullimplications of this issue yet.  The suggestion to have two distinctspaces of namestrings was not something I had anticipated and theimplications require substantial thought.  Current practice in Symbolics,Explorer, and Coral has one namespace for both logical and physicalnamestrings.    Date: 30 May 89 09:07 PDT    From: masinter.pa@Xerox.COM    I think this discussion is leading in a productive direction. Standardizing    on a funny syntax for namestrings on the grounds that it is  "different    enough" from the file systems we know about seems like we're going in the    wrong direction; it presumes that we know about all possible file systems    to which the Standard might need to be connected.    If we want to do anything about logical pathnames at all, building Lisp    constructors for them (either as a new function, MAKE-LOGICAL-PATHNAME, or    possibly a just new keyword for MAKE-PATHNAME which can be used instead of    host+device+directory) sounds less likely to lead us into trouble. Maybe, or maybe more likely to lead us into trouble; see above.  I'm stillthinking this one over.    Date: Tue, 6 Jun 89  17:15:12 CDT    From: David N Gray <Gray@DSG.csc.ti.com>    > Well, it seems like this particular choice conflicts with just about everybody    > (except unix), so maybe it's worth considering alternatives...    On the Explorer, we use the colon as the host delimiter for all    pathnames, which includes support for files on Symbolics, VAX-VMS,    MS-DOS, Multics, and Macintosh as well as Unix, the local Explorer    files, and logical pathnames.  This has not been seen to be a problem.Same in Genera.    True, for MS-DOS and Macintosh pathnames, a host must always be supplied    since the first colon is taken to be a host delimiter.  Even this hasn't    been considered to be a problem, but that is probably just because we    are in the habit of always specifying the host anyway because the    pathname defaulting facilities in our environment are too unpredictable    to be of much use.    I can see, though, that if you are on a non-networked Macintosh, it    could be annoying to have to specify the host even though there is only    one host that you are using.    I wonder, since neither MS-DOS or Macintosh pathnames use the semicolon    [the proposed logical pathname directory delimiter], if it would be    reasonable in such an environment to consider the first colon to be a    host delimiter only if the namestring contains a semicolon?  Since it    would be unusual to want to use a namestring consisting of only a host    name, that could be a useful way of avoiding the ambiguity.On first blush I like this idea.  Maybe we can work out something alongthese lines.  I'd be worried about making the rules too complicated tounderstand, though.    Date: Tue, 6 Jun 89  18:08:42 CDT    From: David N Gray <Gray@DSG.csc.ti.com>    I would prefer to use "#" as the version prefix.  More than once I've    been annoyed when using Symbolics pathnames to not be able to specify a    version without also specifying the type.My preference is to minimize the use of special characters.  I'm notsure the syntax matters very much so long as we all agree on it so ourprograms can interchange logical pathnames, but I don't want the syntaxto appear too complicated and intimidating.  I don't think the abilityto specify a version by itself in a namestring is needed for theintended uses of logical pathnames.    The 12-character limit doesn't seem to have any clear significance.    Since it is common for older file systems to have an 8-character limit    for file names, maybe it would be more meaningful to say that names can    be any length, but only the first 8 characters are guaranteed to be    significant on all implementations.The particular numbers came from consideration of the 14-character-maxversion of Unix, I believe.I think these length limits were a mistake, and I propose to remove them inversion 3 of the proposal.  It is always up to the person who writes thetranslation rules for a particular logical pathname host to a particularphysical file system to make sure that the pathnames that are going to beused translate to valid pathnames for the particular file system.    >   There is no device, so the device component of a logical pathname is    >   always :UNSPECIFIC.  No other component can be :UNSPECIFIC.    I presume you mean that the standard doesn't specify any portable    meaning for an :UNSPECIFIC component, and don't intend to rule out its    use in generic pathnames as an extension?What's a generic pathname?I think I meant what I said, which is that no component of a logical pathnameother than the device can ever be :UNSPECIFIC.  If that's the wrong thing,okay, but let's hear an argument why it's wrong.  Remember that logical pathnames don't have to be able to represent all features of all file systems,they just have to do what's needed for portable naming of program and datafiles within a program.    >   DEFINE-LOGICAL-PATHNAME-TRANSLATIONS host translations &key   [Function]    >     >     Define a logical pathname host named <host> (a string or a symbol which    >     is coerced to a string).  <translations> is a list of translations.    >     Each translation is a list of from-wildcard and to-wildcard.    >     From-wildcard must be a logical pathname or a string coercible to a    >     logical pathname.     Could we say      ...  coercible to a logical pathname using "<host>:" as the      default pathname.    so that the host doesn't have to be explicitly supplied every time?That seems like probably a good idea, let me think it over.    > 	...	To-wildcard must be a physical pathname or a     >     coercible to a physical pathname.     Is there any reason to not permit this to be another logical pathname?Yes, it's too complicated to define what it means and not obviously usefulfor anything (as far as I can see).    >     There are no keyword arguments specified by this standard, but any    >     implementation extensions are provided as keyword arguments or as    >     translations with more than two elements.    An extension I would like to have is the ability to specify what syntax    will be used for parsing the name strings.  If I'm using logical    pathnames for my own convenience, rather than portability, then I would    like to be able to use whatever pathname syntax I like the most.I don't understand, could you be more specific?    > Current practice:    The Explorer also has a comparable logical pathname facility, although    the translation mechanism is unfortunately less general than proposed    here.  The namestring syntax used is slightly different:      host ":" [{directory "."}* directory ";"] [name] ["." type] ["#" version]    The newest version is indicated by ">" instead of "newest".I'd like to minimize the use of special characters.*start*06204 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 12-Jun-89 19:23:35 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JUN 89 19:23:32 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 12 Jun 89  19:22:05 PDTReceived: by ti.com id AA06805; Mon, 12 Jun 89 21:22:13 CDTReceived: from Kelvin by tilde id AA24410; Mon, 12 Jun 89 21:01:51 CDTMessage-Id: <2822695273-6261691@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 12 Jun 89 21:01:13 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: Sandra J Loosemore <sandra%defun@cs.utah.edu>, CL-Cleanup@sail.stanford.eduSubject: Re: Issue: PATHNAME-LOGICAL (version 2)In-Reply-To: Msg of Mon, 12 Jun 89 19:02 EDT from David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>> I think these length limits were a mistake, and I propose to remove them in> version 3 of the proposal.  It is always up to the person who writes the> translation rules for a particular logical pathname host to a particular> physical file system to make sure that the pathnames that are going to be> used translate to valid pathnames for the particular file system.That's true for logical directory names, but typically you would want tospecify translations just for the host and directory, and pass the filenames through.  If I'm trying to install a software package that came fromsomewhere else, I wouldn't want to have to write a translation for everyindividual file just because the author used abnormally long file namesand thought they were being portable.  Besides, I might not even know thenames of all the files that the program might generate internally.>     >   There is no device, so the device component of a logical pathname is>     >   always :UNSPECIFIC.  No other component can be :UNSPECIFIC.> >     I presume you mean that the standard doesn't specify any portable>     meaning for an :UNSPECIFIC component, and don't intend to rule out its>     use in generic pathnames as an extension?> > What's a generic pathname?As returned by:   (SEND (PATHNAME ...) :GENERIC-PATHNAME)[I don't expect that to be meaningful to anyone other than Lisp Machineprogrammers.]  We use :UNSPECIFIC in the type and version slots of genericpathnames; I see now that Symbolics uses NIL there instead.> I think I meant what I said, which is that no component of a logical pathname> other than the device can ever be :UNSPECIFIC.  If that's the wrong thing,> okay, but let's hear an argument why it's wrong.My concern is that the Explorer does have a use for :UNSPECIFIC type andversion in pathnames, including logical pathnames.  I won't argue that itwas a good idea to do it that way; it probably wasn't, but it would bedifficult to change now.  If the standard were to be interpretedto mean that we can't do that, then we would need to have an internallogical pathname type in addition to the standard one, which would be sureto keep everyone confused.All I'm asking for is to not put that restriction in language too strong;I think we will be OK with anything less than "signals an error".>     > 	...	To-wildcard must be a physical pathname or a >     >     coercible to a physical pathname. > >     Is there any reason to not permit this to be another logical pathname?> > Yes, it's too complicated to define what it means	...I just expected that TRANSLATE-LOGICAL-PATHNAME would repeat until itproduces a non-logical pathname.  I see now, though, that the second andthird values returned would be a problem.  Suppose we said thatDEFINE-LOGICAL-PATHNAME-TRANSLATIONS calls TRANSLATE-LOGICAL-PATHNAME oneach of the <to-wildcard> values to force them to be physical pathnames?>	...	 and not obviously useful> for anything (as far as I can see).The point is that I should be able to use a pathname for nearly anything Iwant without needing to know whether it is physical or logical.  If youwant an example, suppose the site administrator tells me that he hascreated a directory "USERS:GRAY;" for me to use on some central nameserver, and I then want to create a logical directory for some largeprogram of mine so that I can type "GIZMO:DATA;FOO" instead of"USERS:GRAY;GIZMO;DATA;FOO".  Why should should I need to know or carewhether "USERS:" is a physical or logical host?  If you are thinking "butlogical pathnames have a different namestring syntax", that is notnecessarily true; on the Explorer, the local file system and logicalpathnames use the same syntax, which we find to be very convenient.>     >     There are no keyword arguments specified by this standard, but any>     >     implementation extensions are provided as keyword arguments or as>     >     translations with more than two elements.> >     An extension I would like to have is the ability to specify what syntax>     will be used for parsing the name strings.  If I'm using logical>     pathnames for my own convenience, rather than portability, then I would>     like to be able to use whatever pathname syntax I like the most.> > I don't understand, could you be more specific?[This point is just an aside, not pertinent to the standard.  I mention itbecause it is the only capability that I have wished to have in logicalpathnames that isn't covered by your proposal, so I'm pleased that itcould still be done as an extension.]A logical host defines two things:  1. How to parse a namestring into a pathname object. 2. How to translate a pathname into a physical pathname.Why not be able to specify both parts instead of being stuck with a fixednamestring syntax?  For example, I use a logical host to access my fileson the VAX just because I like the Explorer pathname syntax better thanthe VMS syntax.  If someone else was a Unix fan, they might want to beable to use Unix syntax for their logical namestrings.  Thus I wouldenvision being able to do something like   (define-logical-pathname-translations "mine"     '(("mine:/data/*.*"  "vax:sys$user:[who.data]*.*"))     :parser #'parse-unix-namestring)*start*03696 00024 US GV-Info: sandra%defun@cs.utah.edu at 13-Jun-89 11:55:50 from AGReturn-Path: <sandra%defun@cs.utah.edu>Received: from cs.utah.edu ([128.110.4.21]) by Xerox.COM ; 13 JUN 89 11:55:42 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA24397; Tue, 13 Jun 89 12:54:13 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA22473; Tue, 13 Jun 89 12:54:08 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8906131854.AA22473@defun.utah.edu>Date: Tue, 13 Jun 89 12:54:06 MDTSubject: Re: Issue: PATHNAME-LOGICAL (version 2)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: Richard Mlynarik <Mly@AI.AI.MIT.EDU>, Sandra J Loosemore <sandra%defun@cs.utah.edu>, Gail Zacharias <gz@spt.entity.com>, masinter.pa, David N Gray <Gray@DSG.csc.ti.com>, CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Mon, 12 Jun 89 19:02 EDTJust a few short comments:> I think these length limits were a mistake, and I propose to remove them> in version 3 of the proposal.Sounds good.  Actually, I think that a logical pathname should permit anyvalues that are hypothetically valid (under PATHNAME-COMPONENT-VALUE) ascomponents.> However, the typical> use of versions is such that on a file system without versions, people> would rather just store one version, and not specify translations that> will preserve the version information by encoding it in the name.  This> is different from the typical use of types or directories, where the> files with different values in those components are truly distinct and> everything would break if you only kept one of them.This makes sense to me, but probably ought to be included somewhere inthe proposal as a rationale.> I thought it said somewhere that PATHNAME-LOGICAL cannot pass if> PATHNAME-WILD fails.It does, but it's way down in the discussion section.  (It happenedthat I originally read this writeup before the one for PATHNAME-WILDand I was very confused by the references to TRANSLATE-PATHNAME andPATHNAME-MATCH-P until I recognized that they were from another issueI hadn't seen yet.)  As you've noted yourself in connection with someother issues, a lot of people don't make it to the end of the writeup. > I could have proposed that logical pathnames always use a specific naming> convention for compiled files, as I did for source files, but for compiled> files it seemed better to let the implementation control the name.  Do> you think a different approach should have been taken, or did you just> want to see this proposal split into parts?If there is going to be a convention for the name of source files, Iwould rather see a similar convention adopted for the name of compiledfiles.Perhaps I should add a little here about how we handled pathnameswhile working on porting PSL to various machines, including theinfamous Cray.  First, we used variables as I outlined in my previousmessage to keep track of "places" and "file types" to look for libraryfiles, instead of using literal namestrings all over the place.  Thevariables were initialized in a separate configuration file.  Second,we had the file open function do its own translation to take care ofmapping pathnames onto namestrings that were recognizable to the hostfile system; this is where the namestring got mangled to account forcase canonicalization and truncation appropriate to that host, ifthere wasn't a specific mapping for that filename known.  In effect,we treated all pathnames as logical pathnames!  Over time, PSL hasgravitated towards using Unix filename syntax for "logical"namestrings.-Sandra-------*start*05259 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 13-Jun-89 15:27:28 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JUN 89 15:27:12 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 13 Jun 89  15:21:35 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 610818; 13 Jun 89 18:23:22 EDTDate: Tue, 13 Jun 89 18:23 EDTFrom: Kim Barrett <IIM@ECLA.USC.EDU>Sender: KMP@STONY-BROOK.SCRC.Symbolics.COMSubject: Issue: PATHNAME-LOGICAL (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUComments: Received from Kim Barrett by KMP on MSDOS floppy disk via US MailMessage-ID: <19890613222312.8.KMP@BOBOLINK.SCRC.Symbolics.COM>Is there really any need to allow integers for version numbers here?  Myexperience has been that anytime I've used logical pathnames in a place where Iactually needed them (as opposed to just typing, so I don't have to keepworrying about different syntaxes), using explicit version numbers was a badidea even when dealing with a file system that supported them.Re: LOGICAL-PATHNAME type.  Why?  I think there may be a hidden assumptionabout implementation technique here, namely that pathnames for different filesystem types will be different subtypes of PATHNAME.  I don't see anything elsein the proposal that needs this, since a "logical pathname" could also bedefined as a pathname whose host is a logical pathname host.I'm somewhat concerned about mapping logical pathnames into real file systemswhich don't support some or all of the capabilities of logical pathnames.  I'mnot too concerned about file systems which don't support heirarchicaldirectories, having not had the misfortune to encounter such a beast in a longtime.  Just out of curiosity, are there any such in common use above the microlevel (I've heard rumors of old IBM mainframe OS'es)?  As far as versionnumbers, see above.The main point I'm concerned about is the definition of a word.1. Hyphens: I think hyphens can be dealt with fairly easily by translating theminto some non-alphanumeric supported by the file system, underscore being alikely candidate.  Basically, the solution here is documentation.2. Wild cards: Some file systems don't have very general support for wildcards.  For example, MS-DOS effectively ignores anything following the first"*" in a file name, limiting matches to a prefix plus wild-card suffix.  Ofcourse, a Common Lisp implementation could add a layer of filtering on top ofthis, so I don't think this is so bad.3. 12 character names: This is the main point I have trouble with.  There are alot of file systems out there which don't support 12 character names.  MS-DOShas a limit of 8, except the type which is limited to 3.  I believe ITS islimited to 6.The problem is that the translation algorithm must be easy to use by people,not just computers (specifically the Lisp implementation).Part of the solution here may again be documentation.  As a suggestion, foreach of the system types described under PATHNAME-SYSTEM-TYPE (see that issue)in the standard, the logical pathname mapping algorithm could also bespecified.  (Of course, this requires that people be able to agree to such).Alternatively, add some verbiage to the description of logical pathnames sayingthat some file systems are limited in the actual length of their logicalpathname words, and names should be chosen appropriately.  It may be safe to"require" that at least 6 characters will be used, and treat these likefunction and variable names in some languages which allow you to have longnames but which ignore all but the first n characters.  I'm actually somewhatinclined toward the latter solution, since people seem to be able to live withit in programming languages (though perhaps not being ecstatic about it) and itfrequently avoids the need to have to count characters, and if the number issmall (like 6) it is easier to "eyeball" whether you are over the limit than ifit is a larger number (like 12) (see the note on the examples below).I suppose if you have PATHNAME-SYSTEM-TYPE you can always conditionalize yourpathnames somewhat depending on the file system type (ugly, and somewhatdefeats the point of this proposal).There may be an ambiguity in the logical pathname description, namely is ".5" apathname with version == 5 and everything else unspecified, or is the type =="5" and everything else is unspecified.I was wondering why add a function like COMPILE-FILE-PATHNAME, rather than justdefining another canonical type analogous to "LISP", like "BIN" or "FASL" orsome other name.  I suppose it avoids arguments about what the 'right' name is,although I personally don't care about the precise name used.  The only reasonI can think of is to allow COMPILE-FILE to generate a name that isn't just theresult of something like  (merge-pathnames output-file (make-pathname :type *compiled-file-type*					      :defaults input-file))As a note, "A more complex example" contains a violation of the 12 characterlimit:  "DOCUMENTATION" is 13 characters long.*start*03707 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 14-Jun-89 12:08:04 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 JUN 89 12:06:43 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 14 Jun 89  12:05:27 PDTReceived: by ti.com id AA23250; Wed, 14 Jun 89 14:04:58 CDTReceived: from dsg by tilde id AA19193; Wed, 14 Jun 89 13:53:16 CDTReceived: From Kelvin By dsg Via CHAOS-NET With CHAOS-MAIL; Wed, 14 Jun 89  12:26:18 CDTMessage-Id: <2822837265-14792772@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 14 Jun 89 12:27:45 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kim Barrett <IIM@ECLA.USC.EDU>Cc: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>, CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: PATHNAME-LOGICAL (Version 2)In-Reply-To: Msg of Tue, 13 Jun 89 18:23 EDT from Kim Barrett <IIM@ECLA.USC.EDU>> Is there really any need to allow integers for version numbers here?  My> experience has been that anytime I've used logical pathnames in a place where I> actually needed them (as opposed to just typing, so I don't have to keep> worrying about different syntaxes), using explicit version numbers was a bad> idea even when dealing with a file system that supported them.So what's wrong with using logical pathnames for "just typing"?  I thinkthat inappropriate use of version numbers is an issue of good programmingpractice that is no more related to logical pathnames than it is tophysical pathnames.> Re: LOGICAL-PATHNAME type.  Why?  I think there may be a hidden assumption> about implementation technique here, namely that pathnames for different file> system types will be different subtypes of PATHNAME.  I don't see anything else> in the proposal that needs this, since a "logical pathname" could also be> defined as a pathname whose host is a logical pathname host.It would permit methods specialized on LOGICAL-PATHNAME and PATHNAME todistinguish whether a translation is needed, although I'm not sure that isreally useful since asking for a translation on a physical pathnamedoesn't hurt.  You may be right that the standard doesn't need to specifythis. > There may be an ambiguity in the logical pathname description, namely is ".5" a> pathname with version == 5 and everything else unspecified, or is the type ==> "5" and everything else is unspecified.I think that the way the brackets are nested in the syntax makes itunambiguous that if there is only one dot, it is the type.  This could,however, be confusing for humans.> I was wondering why add a function like COMPILE-FILE-PATHNAME, rather than just> defining another canonical type analogous to "LISP", like "BIN" or "FASL" or> some other name.  I suppose it avoids arguments about what the 'right' name is,> although I personally don't care about the precise name used.  The only reason> I can think of is to allow COMPILE-FILE to generate a name that isn't just the> result of something like> >   (merge-pathnames output-file (make-pathname :type *compiled-file-type*> 					      :defaults input-file))You also need to be able to merge with an explicit :OUTPUT-FILE argument.Then there is the question of version number:  is it always :NEWEST, orthe same as specified for the input, or the same as the truename of theinput file?  What if the input and output are on different hosts and onesupports versions and the other doesn't?  On the Explorer, there is aspecial variable to control how versions are handled, and the code tocompute the output pathname for COMPILE-FILE is some 60 lines long.  So itis not trivial.*start*34771 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 21-Jun-89 15:33:23 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 15:33:19 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 21 Jun 89  15:06:31 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 614486; 21 Jun 89 12:20:55 EDTDate: Wed, 21 Jun 89 12:19 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Reply-To: CL-Cleanup@sail.stanford.eduSubject: Issue: PATHNAME-LOGICAL (version 3)To: X3J13@sail.stanford.eduMessage-ID: <19890621161905.6.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This is an old issue but it has not been written up before.  I'm sorry thisis coming out so late, but it's been quite a struggle to cast it into clearand easily understood form.  It is rather a long proposal in order to bevery clear about exactly what it's proposing, and I apologize for thelength.Issue:          PATHNAME-LOGICALForum:          CleanupReferences:     Pathnames (pp410-413)                OPEN (p.418), WITH-OPEN-FILE (p.422), RENAME-FILE (p.423),                DELETE-FILE (p.424), PROBE-FILE (p.424),                FILE-WRITE-DATE (p.424), FILE-AUTHOR (p.424), LOAD (p.426),                COMPILE-FILE (p.439), DIRECTORY (p.427), PATHNAME (p.413),                TRUENAME (p.413), MERGE-PATHNAMES (p.415),                 MAKE-PATHNAME (p.416), and PARSE-NAMESTRING (p.414).Related issues: PATHNAME-CANONICAL-TYPE, PATHNAME-COMPONENT-VALUES,                 PATHNAME-SUBDIRECTORY-LIST, and PATHNAME-WILDCategory:       ADDITIONEdit history:   Version 1, 11-May-89, by Moon                Version 2, 18-May-89, by Moon                Version 3, 21-Jun-89, by Moon (revise based on discussion                        in the cleanup committee)Problem description:  Pathname values are not portable, but they are sometimes part of a  program, for example the names of files containing the program and the  data used by the program.  Moving large programs between sites would  be easier if pathname values did not have to be translated.  Pathname values are nonportable because not all Common Lisp  implementations use the same operating system and file name syntax varies  widely among operating systems.  In addition, corresponding files at two  different sites may have different names even when the operating system  is the same; for example, they may be on different directories or  different devices.  The issue of portable pathname values is separate from the issues of  portable pathname operations.  See the related issues listed above.  For inter-issue interactions, see the discussion section below.  Note that issue PATHNAME-LOGICAL fundamentally depends on issue  PATHNAME-WILD.  If PATHNAME-WILD:NEW-FUNCTIONS does not pass,  PATHNAME-LOGICAL cannot pass.Proposal (PATHNAME-LOGICAL:ADD):  1. Define a "logical" file system that looks the same at every site.  This file system is implemented by translating each logical pathname into  a physical pathname on a real file system.  The logical pathnames are the  same at all sites, but the translations are different at each site, thus  the physical pathnames can be different at each site.  2a. The syntax of a logical pathname namestring is as follows:  [ host ":" ] [ ";" ] { directory ";" }* [ name ] [ "." type [ "." version ]]  2b. Terminology:  A <word> consists of one or more uppercase letters, digits, and hyphens.  A <wildcard word> consists of one or more asterisks, uppercase letters,  digits, and hyphens, including at least one asterisk, with no two  asterisks adjacent.  Each asterisk matches a sequence of zero or more  characters.  The <wildcard word> "*" parses into :WILD, the others parse  into strings.  In <words> and <wildcard words> lowercase letters are translated to  uppercase.  The consequences of using other characters are unspecified.  2c. Logical pathname components:  The host is a <word> that has been defined as a logical pathname host by  using SETF of LOGICAL-PATHNAME-TRANSLATIONS.  There is no device, so the device component of a logical pathname is  always :UNSPECIFIC.  No other component can be :UNSPECIFIC.  Each directory is a <word>, a <wildcard word>, or "**" (:WILD-INFERIORS).  If a semicolon precedes the directories, the directory component is  relative, otherwise it is absolute.  The name is a <word> or a <wildcard word>.  The type is a <word> or a <wildcard word>.  The version is a positive decimal integer or "NEWEST" (:NEWEST) or "*"  (:WILD).  The letters in "NEWEST" can be in either alphabetic case.  The consequences of using any value not specified here as a logical  pathname component are unspecified.  The null string "" is not a valid value for any component of a logical  pathname, since "" is not a <word> and not a <wildcard word>.  3. Parsing of logical pathname namestrings into logical pathnames  operates as follows:  3a. Logical pathname namestrings are recognized by the LOGICAL-PATHNAME  and TRANSLATE-LOGICAL-PATHNAME functions.  In this case the host portion  of the logical pathname namestring and its following colon are required.  3b. The PARSE-NAMESTRING function recognizes a logical pathname  namestring when the host argument is logical or the defaults argument is  a logical pathname.  In this case the host portion of the logical  pathname namestring and its following colon are optional.  If the host  portion of the namestring and the host argument are both present and do  not match, an error is signalled.  The host argument is logical if it is supplied and came from  PATHNAME-HOST of a logical pathname.  Whether a host argument is logical  if it is a string equal to a logical pathname host name is  implementation-defined.  3c. The MERGE-PATHNAMES function recognizes a logical pathname namestring  when the defaults argument is a logical pathname.  In this case the host  portion of the logical pathname namestring and its following colon are  optional.  3d. Whether the other functions that coerce strings to pathnames  (PATHNAME, TRUENAME, PARSE-NAMESTRING in other circumstances than those  described in point 3b, MERGE-PATHNAMES in other circumstances than those  described in point 3c, the :DEFAULTS argument to MAKE-PATHNAME,  PATHNAME-HOST, PATHNAME-DEVICE, PATHNAME-DIRECTORY, PATHNAME-NAME,  PATHNAME-TYPE, PATHNAME-VERSION, NAMESTRING, FILE-NAMESTRING,  DIRECTORY-NAMESTRING, HOST-NAMESTRING, ENOUGH-NAMESTRING, OPEN,  WITH-OPEN-FILE, RENAME-FILE, DELETE-FILE, PROBE-FILE, FILE-WRITE-DATE,  FILE-AUTHOR, LOAD, DIRECTORY, COMPILE-FILE, ED, DRIBBLE, WILD-PATHNAME-P,  PATHNAME-MATCH-P, TRANSLATE-PATHNAME, and COMPILE-FILE-PATHNAME)  recognize logical pathname namestrings is implementation defined.  4. Some real file systems do not have versions.  Logical pathname  translation to such a file system ignores the version.  This implies that  a program cannot rely on being able to store more than one version of a  file named by a logical pathname.  5. The type of a logical pathname for a Common Lisp source file is "LISP".  This should be translated into whatever type is appropriate in a physical  pathname.  6. The logical pathname host name "SYS" is reserved for the implementation.  The existence and meaning of SYS: logical pathnames is  implementation-defined.  7. File manipulation functions operate with logical pathnames as follows:  7a. The functions OPEN (and WITH-OPEN-FILE), RENAME-FILE, DELETE-FILE,  PROBE-FILE, FILE-WRITE-DATE, FILE-AUTHOR, LOAD, DIRECTORY, COMPILE-FILE,  ED, DRIBBLE, COMPILE-FILE-PATHNAME, and TRUENAME accept logical pathnames  and translate them into physical pathnames, as if by calling the  TRANSLATE-LOGICAL-PATHNAME function.  7b. PATHNAME of a stream created by OPEN (or WITH-OPEN-FILE) of a logical  pathname is a logical pathname.  7c. TRUENAME, PROBE-FILE, and DIRECTORY never return logical pathnames.  7d. RENAME-FILE with a logical pathname as the second argument returns a  logical pathname as the first value.  7e. MERGE-PATHNAMES returns a logical pathname if and only if its first  argument is a logical pathname or its first argument does not specify a  host and the default is a logical pathname.  7f. MAKE-PATHNAME returns a logical pathname if and only if the host is  logical.  If the :host argument to MAKE-PATHNAME is supplied, the host is  logical if it came from PATHNAME-HOST of a logical pathname.  Whether a  :host argument is logical if it is a string equal to a logical pathname  host name is implementation-defined.  7g. PARSE-NAMESTRING returns a logical pathname according to points 3b  and 3d.  Add these defined names to Common Lisp in support of logical pathnames:  8. LOGICAL-PATHNAME                                            [Class]    LOGICAL-PATHNAME is a subclass of PATHNAME.  9. LOGICAL-PATHNAME pathname                                   [Function]    Converts the argument to a logical pathname and returns it.  The    argument can be a logical pathname, a logical pathname namestring    containing a host component, or a stream for which the PATHNAME    function returns a logical pathname.  For any other argument,    LOGICAL-PATHNAME signals an error of type TYPE-ERROR.  10. TRANSLATE-LOGICAL-PATHNAME pathname                        [Function]    Translates a logical pathname to the corresponding physical pathname.    The pathname argument is first coerced to a pathname.  If it is not a    pathname, string, or file stream an error of type TYPE-ERROR is    signalled.    If the coerced argument is a logical pathname, the first matching    translation (according to PATHNAME-MATCH-P) of the logical pathname    host is applied, using TRANSLATE-PATHNAME with the reversible argument    true.  If the result is a logical pathname, this process is repeated.    Three values are returned:      1. The physical pathname      2. The from-wildcard of the translation      3. The to-wildcard of the translation    If no translation matches, an error of type FILE-ERROR is signalled.    If the coerced argument is a physical pathname, it is returned as all    three values.    All three values are pathnames.  The second and third values might not    come directly from a logical pathname translation list; they might be    modified to reflect multiple levels of translation and/or additional    translations, typically to provide translation of file types to local    naming conventions, to accomodate physical file systems with limited    length names, or to deal with special character requirements such as    translating hyphens to underscores or uppercase letters to lowercase.    Any such additional translations are implementation defined.  Some    implementations do no additional translations.    Except when an error is signalled, TRANSLATE-LOGICAL-PATHNAME satisfies    this identity:    (MULTIPLE-VALUE-BIND (PHYSICAL FROM-WILDCARD TO-WILDCARD)        (TRANSLATE-LOGICAL-PATHNAME LOGICAL)      (AND (EQUAL (TRANSLATE-PATHNAME LOGICAL FROM-WILDCARD TO-WILDCARD T)                  PHYSICAL)           (EQUAL (TRANSLATE-PATHNAME PHYSICAL TO-WILDCARD FROM-WILDCARD T)                  LOGICAL)))    The above is written assuming the LOGICAL argument has already been    coerced to a pathname.  11. LOGICAL-PATHNAME-TRANSLATIONS host                         [Function]    If <host> is not the host component of a logical pathname and not a    string that has been defined as a logical pathname host name by SETF of    LOGICAL-PATHNAME-TRANSLATIONS, signals an error of type TYPE-ERROR.    Otherwise returns the host's list of translations.  Each translation is    a list of at least two elements: from-wildcard and to-wildcard.  Any    additional elements are implementation defined.  From-wildcard is a    logical pathname whose host is <host>.  To-wildcard is a pathname.    Translations are searched in the order listed, so more specific    from-wildcards must precede more general ones.    (SETF (LOGICAL-PATHNAME-TRANSLATIONS host) translations) sets a logical    pathname host's list of translations.  If <host> is a string that has    not been previously used as logical pathname host, a new logical    pathname host is defined, otherwise an existing host's translations are    replaced.  Logical pathname host names are compared with STRING-EQUAL.    When setting the translations list, each from-wildcard can be a logical    pathname whose host is <host> or a logical pathname namestring    parseable by (PARSE-NAMESTRING string host).  Each to-wildcard can be    anything coercible to a pathname by (PATHNAME to-wildcard).  If    to-wildcard coerces to a logical pathname, TRANSLATE-LOGICAL-PATHNAME    will perform repeated translation steps when it uses it.  There can    be implementation-defined restrictions against logical to-wildcards    that would produce non-reversible translations.    Implementations can define additional functions that operate on    logical pathname hosts.  12. LOAD-LOGICAL-PATHNAME-TRANSLATIONS host                    [Function]    If a logical pathname host named <host> (a string) is already defined,    return NIL.  Otherwise, search for a logical pathname host definition    in an implementation defined manner.  If none is found, signal an    error.  If a definition is found, install it and return T.    The search used by LOAD-LOGICAL-PATHNAME-TRANSLATIONS should be    documented, as logical pathname definitions will be created by users,    not only by Lisp implementors.  A typical search technique is to    look in a certain directory for a file whose name is derived from    the host name in an implementation-defined fashion.  13. COMPILE-FILE-PATHNAME pathname &key :output-file           [Function]    Returns the pathname that COMPILE-FILE would write into, if given the    same arguments.  If the pathname argument is a logical pathname and the    :output-file argument is unspecified, the result is a logical pathname.    If an implementation supports additional keyword arguments to    COMPILE-FILE, COMPILE-FILE-PATHNAME must accept the same arguments.Examples:  ;This function is like DIRECTORY, but if its argument is a logical  ;pathname it returns logical pathnames in the results.  If its  ;argument is a physical pathname, it is the same as DIRECTORY.  (defun logical-directory (pathname)    (multiple-value-bind (physical from-wildcard to-wildcard)        (translate-logical-pathname pathname)      (map 'list #'(lambda (truename)                     (translate-pathname truename to-wildcard                                         from-wildcard t))           (directory physical))))  ;A very simple example of setting up a logical pathname host.  No  ;translations are necessary to get around file system restrictions, so  ;all that is necessary is to specify the root of the physical directory  ;tree that contains the logical file system.  ;The namestring syntax on the right-hand side is implementation-specific.  (setf (logical-pathname-translations "foo")        '(("**;*.*.*"              "MY-LISPM:>library>foo>**>")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "foo:bar;baz;mum.quux.3")  => MY-LISPM:>library>foo>bar>baz>mum.quux.3,     foo:**;*.*.*,     MY-LISPM:>library>foo>**>*.*.*  ;A more complex example, dividing the files among two file servers  ;and several different directories.  This Unix doesn't support  ;:WILD-INFERIORS in the directory, so each directory level must  ;be translated individually.  No file name or type translations  ;are required except for .MAIL to .MBX.  ;The namestring syntax on the right-hand side is implementation-specific.  (setf (logical-pathname-translations "prog")        '(("RELEASED;*.*.*"        "MY-UNIX:/sys/bin/my-prog/")          ("RELEASED;*;*.*.*"      "MY-UNIX:/sys/bin/my-prog/*/")          ("EXPERIMENTAL;*.*.*"    "MY-UNIX:/usr/Joe/development/prog/")          ("EXPERIMENTAL;DOCUMENTATION;*.*.*"                                   "MY-VAX:SYS$DISK:[JOE.DOC]")          ("EXPERIMENTAL;*;*.*.*"  "MY-UNIX:/usr/Joe/development/prog/*/")          ("MAIL;**;*.MAIL"        "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:mail;save;ideas.mail.3")  => MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3,     PROG:MAIL;**;*.MAIL.*,     MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX.*  ;Example translations for a program that uses three files main.lisp,  ;auxiliary.lisp, and documentation.lisp.  These translations might be  ;supplied by a software supplier as examples.  ;For Unix with long file names  (setf (logical-pathname-translations "prog")        '(("CODE;*.*.*"             "/lib/prog/")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => /lib/prog/documentation.lisp,     PROG:CODE;*.*.*,     /lib/prog/*  ;For Unix with 14-character file names, using .lisp as the type  (setf (logical-pathname-translations "prog")        '(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*")          ("CODE;*.*.*"             "/lib/prog/")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => /lib/prog/docum.lisp,     PROG:CODE;DOCUMENTATION.*.*,     /lib/prog/docum.*  ;For Unix with 14-character file names, using .l as the type  ;The second translation shortens the compiled file type to .b  (setf (logical-pathname-translations "prog")        `(("**;*.LISP.*"            ,(logical-pathname "PROG:**;*.L.*"))          (,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*"))                                    ,(logical-pathname "PROG:**;*.B.*"))          ("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*")          ("CODE;*.*.*"             "/lib/prog/")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => /lib/prog/documentatio.l,     PROG:CODE;DOCUMENTATION.LISP.*,     /lib/prog/documentatio.l  ;For a Cray with 6 character names and no directories, types, or versions.  (setf (logical-pathname-translations "prog")        (let ((l '(("MAIN" "PGMN")                   ("AUXILIARY" "PGAUX")                   ("DOCUMENTATION" "PGDOC")))              (logpath (logical-pathname "prog:code;"))              (phypath (pathname "XXX")))          (append            ;; Translations for source files            (mapcar #'(lambda (x)                        (let ((log (first x))                              (phy (second x)))                          (list (make-pathname :name log                                               :type "LISP"                                               :version :wild                                               :defaults logpath)                                (make-pathname :name phy                                               :defaults phypath))))                    l)            ;; Translations for compiled files            (mapcar #'(lambda (x)                        (let* ((log (first x))                               (phy (second x))                               (com (compile-file-pathname                                      (make-pathname :name log                                                     :type "LISP"                                                     :version :wild                                                     :defaults logpath))))                          (setq phy (concatenate 'string phy "B"))                          (list com                                (make-pathname :name phy                                               :defaults phypath))))                    l))))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => PGDOC,     PROG:CODE;DOCUMENTATION.LISP.*,     PGDOCRationale:  1. Large programs can be moved between sites without changing any  pathnames, provided all pathnames used are logical.  A portable system  construction tool can be created that operates on programs defined as  sets of files named by logical pathnames.  2. Logical pathname syntax was chosen to be easily translated into most  popular file systems, while still being powerful enough for storing large  programs.  Although they have hierarchical directories, extended wildcard  matching, versions, and no limit on the length of names, they can be  mapped onto a less capable real file file system by translating each  directory that is used into a flat directory name, doing wildcards in  Lisp rather than in the file system, treating all versions as :newest,  and/or using translations to shorten long names.  Logical pathname words are restricted to non-case-sensitive letters,  digits, and hyphens to avoid creating problems with real file systems  that support limited character sets for file naming.  Other characters  could have been mapped onto such file systems through translations, but  that didn't seem worth the trouble.  Logical pathnames have to be  non-case-sensitive or it would be very difficult to map them onto a  non-case-sensitive file system.  Features such as :UP and :BACK relative directories and a namestring  syntax for the root directory were not felt to be necessary in logical  pathnames.  They could be added later if a need emerges.  It is not a goal of logical pathnames to be able to represent all  possible file names.  Their goal is rather to represent just enough file  names to be useful for storing software.  Real pathnames, in contrast,  need to provide a uniform interface to all possible file names, including  names and naming conventions that are not under the control of Common  Lisp.  The choice of logical pathname syntax, using colon, semicolon, and  period, was guided by the goals of being visually distinct from real file  systems and minimizing the use of special characters.  The consequences of using any value not specified here as a logical  pathname component are unspecified, for the benefit of the Explorer.  3. The LOGICAL-PATHNAME function is separate from the PATHNAME function  so that the syntax of logical pathname namestrings does not constrain the  syntax of physical pathname namestrings in any way.  Logical pathname  syntax must be defined by Common Lisp so that logical pathnames can be  conveniently exchanged between implementations, but physical pathname  syntax is dictated by forces outside our control.  3b,c. Allowing PARSE-NAMESTRING and MERGE-PATHNAMES to recognize logical  pathname namestrings in these situations provides for natural operations  on logical pathnames.  Frequently a string containing just a name, or a  name and a type, will be recognized as a logical pathname by merging it  against a default containing a logical pathname host and directory.  3d. Recognition of logical pathname namestrings by PATHNAME and related  functions is left up to each implementation because some implementations  definitely require this, other implementations don't want to do this, and  nobody wants to change.  In any case, Common Lisp historically has avoided  saying anything about the syntax of the strings accepted by the PATHNAME  function, and point 3d preserves that position.  3b,7f. Leaving it implementation defined whether a string, used as the  host argument to PARSE-NAMESTRING or the :host argument to MAKE-PATHNAME,  can be recognized as logical pathname host name is for the same reason as  point 3d.  It allows each implementation to decide whether there is one  namespace or two.  The correct way to write this is:    (MAKE-PATHNAME :HOST (PATHNAME-HOST (LOGICAL-PATHNAME "hostname:"))                   ...)  4. Logical pathname versions could have been supported on real file  systems that do not have versions by defining a kind of translation to  encode the version number in the name.  However, the typical use of  versions is such that on a file system without versions, people would  rather just store one version of a file, and not preserve the version  information by encoding it somehow in the name.  This is different from  the typical use of types or directories, where the files with different  values in those components are truly distinct and everything would break  if you only kept one file.  5,13. The COMPILE-FILE-PATHNAME function and the specification of "LISP"  as the type of a logical pathname for a Common Lisp source file together  provide enough information about compilation for a portable system  construction tool that uses logical pathnames to work.  Suppose you want  to call COMPILE-FILE only if the source file is newer than the compiled  file.  To do that, you have to have a way to know the name of the  compiled file without actually calling COMPILE-FILE.  No standard file type for compiler output is proposed, because in some  implementations the compiler produces one of several file types,  depending on a variety of implementation-dependent circumstances.  COMPILE-FILE-PATHNAME provides access to the "default[ing] in a manner  appropriate to the implementation's file system conventions" mentioned in  the CLtL documentation of COMPILE-FILE.  6. The use of the logical pathname host name "SYS" for the implementation  is current practice.  Standardizing on this name helps users choose  logical pathname host names that avoid conflicting with  implementation-defined names.  7. Accepting logical pathnames for file access is a natural extension  of the file access functions and makes it easier to program using only  logical pathnames in situations where that is appropriate.  8. The LOGICAL-PATHNAME class exists so that methods can distinguish  logical pathnames from regular pathnames.  9. See point 3 above.  10. TRANSLATE-LOGICAL-PATHNAME is the heart of the logical pathname  feature.  The two extra values returned by TRANSLATE-LOGICAL-PATHNAME  allow for back-translation, as shown in the LOGICAL-DIRECTORY example.  Allowing TRANSLATE-LOGICAL-PATHNAME on a physical pathname, simply  returning the argument, makes some programs easier to write.  Additional  implementation defined translations make it possible for implementations  with unusual file systems to offer some help to the user in setting up  the translations for a logical pathname host, by handling some of the  work automatically.  Logical pathnames that translate to other logical  pathnames are a feature that several people have requested.  11. SETF of LOGICAL-PATHNAME-TRANSLATIONS is a simple way for a user to  define a new logical pathname host.  Using SETF makes it possible to add  to or modify the translations of an existing logical pathname host.  The  restriction against non-reversible translations is necessary because many  logical pathname using programs depend on reversibility, for instance to  translate a truename back into a logical pathname.  If logical pathname  translation was not reversible, two different logical pathnames might  translate into the same physical pathname, which could scramble files.  It is always up to the person who writes the translation rules for a  particular logical pathname host to a particular physical file system to  make sure that the logical pathnames that are actually going to be used  translate to valid pathnames for the particular file system.  12. Loading of logical pathname translations from a site-dependent file  allows software to be distributed using logical pathnames.  The assumed  model of software distribution is a division of labor between the  supplier of the software and the user installing it.  The supplier  chooses logical pathnames to name all the files used or created by the  software, and supplies examples of logical pathname translations for a  few popular file systems.  Each example uses an assumed directory and/or  device name, assumes local file naming conventions, and provides  translations that will translate all the logical pathnames used or  generated by the particular software into valid physical pathnames.  For a powerful file system these translations can be quite simple.  For  a more restricted file system, it may be necessary to list an explicit  translation for every logical pathname used, for example when dealing  with restrictions on the maximum length of a file name.  The user installing the software decides on which device and/or directory  to store the files and edits the example logical pathname translations  accordingly.  If necessary, the user also adjusts the translations for  local file naming conventions and any other special aspects of the user's  local file system policy and local Common Lisp implementation.  For  example, the files might be divided among several file server hosts to  share the load.  The process of defining site-customized logical pathname  translations is quite easy for a user of a popular file system for which  the software supplier has provided an example.  A user of a more unusual  file system might have to take more time; the supplier can help by  providing a list of all the logical pathnames used or generated by the  software.  Once the user has created a suitable SETF of LOGICAL-PATHNAME-TRANSLATIONS  form, he can evaluate that form and then load and run the software.  It  may be necessary to use the translations again, or on another workstation  at the same site, so it is best to save the SETF form in the standard  place where it can be found later by LOAD-LOGICAL-PATHNAME-TRANSLATIONS.  Often a software supplier will include a program for restoring software  from the distribution medium to the file system, and a program for loading  the software from the file system into a Common Lisp, and these programs  will start by calling LOAD-LOGICAL-PATHNAME-TRANSLATIONS to make sure that  the logical pathname host is defined.  Note that the SETF of LOGICAL-PATHNAME-TRANSLATIONS form isn't part of  the program, it's separate.  It's written by the user, not by the  software supplier.  That separation, and a uniform convention for how to  do the separation, are the key aspects of logical pathnames.  For small  programs involving only a handful of files, it doesn't matter much.  The  real benefits come with large programs with hundreds or thousands of  files and more complicated situations such as program-generated file  names or porting a program developed on a system with long file names  onto a system with a very restrictive limit on the length of file names.Current practice:  Symbolics Genera has had a similar facility for many years.  It is used  extensively for software distribution by Symbolics and its customers.  The Genera facility uses the same logical pathname syntax but different  function names, and is somewhat more complicated.  The extra complexity  is not necessary in the Common Lisp standard.  The T.I. Explorer also has a comparable logical pathname facility,  although the translation mechanism is unfortunately less general than  proposed here.  The namestring syntax used is slightly different:      host ":" [{directory "."}* directory ";"] [name] ["." type] ["#" version]    The newest version is indicated by ">" instead of "newest".  Macintosh Allegro Common Lisp) has a logical pathname feature which is  somewhat simpler but aimed at solving the same problems.  It has logical  directory names, to simplify access to sets of files in differently named  directories (an especially severe problem on micros where everybody just  has to have a different pet name for their hard disk).  This isn't really  the same as simplifying access to different file systems, although of  course solving the latter automatically solves the former.  In general,  access to different file systems requires translating names and types,  not just translating directories.  Symbolics Genera offers a function for translating from a physical  pathname back to a logical pathname.  There are a number of problems with  this, and so it has not been proposed here.  Instead  TRANSLATE-LOGICAL-PATHNAME returns enough information to allow the user  program to perform the backtranslation itself.  The Genera equivalent of LOAD-LOGICAL-PATHNAME-TRANSLATIONS looks for  a file named SYS:SITE;hostname.TRANSLATIONS.  Current practice in Genera, Explorer, and Macintosh has one namespace for  both logical and physical namestrings.  This proposal allows an  implementation to choose to have one namespace or to have two separate  namespaces for namestrings.Cost to Implementors:  This is a fairly complex facility, but its performance is unimportant  so a straightforward implementation should suffice.  Most of the  complexity comes in dealing with unusual file systems, such as ones  that don't allow long file names.Cost to Users:  None.Cost of non-adoption:  Portable software construction and distribution will have to rely on  implementation-dependent kludges.  Lisp software will continue to be  difficult to install.Performance impact:  None.Benefits:  Avoid cost of non-adoption.Esthetics:  Improved portability of large programs.Discussion:  Issue PATHNAME-LOGICAL fundamentally depends on issue PATHNAME-WILD.  If  PATHNAME-WILD:NEW-FUNCTIONS does not pass, PATHNAME-LOGICAL cannot pass.  If PATHNAME-CANONICAL-TYPE:NEW-CONCEPT passes, it will affect the  behavior of the function TRANSLATE-PATHNAME and therefore the behavior of  the function TRANSLATE-LOGICAL-PATHNAME.  When a logical pathname  translation has from-wildcard and to-wildcard type components that are  :WILD or omitted, translation of the type will be guided by canonical  types.  If PATHNAME-CANONICAL-TYPE:NEW-CONCEPT fails to pass, it will  either have to be done behind the scenes by TRANSLATE-PATHNAME or users  will have to write more verbose translations that individually specify  the handling of each file type.*start*34771 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 21-Jun-89 15:33:23 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 15:33:19 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 21 Jun 89  15:06:31 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 614486; 21 Jun 89 12:20:55 EDTDate: Wed, 21 Jun 89 12:19 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Reply-To: CL-Cleanup@sail.stanford.eduSubject: Issue: PATHNAME-LOGICAL (version 3)To: X3J13@sail.stanford.eduMessage-ID: <19890621161905.6.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This is an old issue but it has not been written up before.  I'm sorry thisis coming out so late, but it's been quite a struggle to cast it into clearand easily understood form.  It is rather a long proposal in order to bevery clear about exactly what it's proposing, and I apologize for thelength.Issue:          PATHNAME-LOGICALForum:          CleanupReferences:     Pathnames (pp410-413)                OPEN (p.418), WITH-OPEN-FILE (p.422), RENAME-FILE (p.423),                DELETE-FILE (p.424), PROBE-FILE (p.424),                FILE-WRITE-DATE (p.424), FILE-AUTHOR (p.424), LOAD (p.426),                COMPILE-FILE (p.439), DIRECTORY (p.427), PATHNAME (p.413),                TRUENAME (p.413), MERGE-PATHNAMES (p.415),                 MAKE-PATHNAME (p.416), and PARSE-NAMESTRING (p.414).Related issues: PATHNAME-CANONICAL-TYPE, PATHNAME-COMPONENT-VALUES,                 PATHNAME-SUBDIRECTORY-LIST, and PATHNAME-WILDCategory:       ADDITIONEdit history:   Version 1, 11-May-89, by Moon                Version 2, 18-May-89, by Moon                Version 3, 21-Jun-89, by Moon (revise based on discussion                        in the cleanup committee)Problem description:  Pathname values are not portable, but they are sometimes part of a  program, for example the names of files containing the program and the  data used by the program.  Moving large programs between sites would  be easier if pathname values did not have to be translated.  Pathname values are nonportable because not all Common Lisp  implementations use the same operating system and file name syntax varies  widely among operating systems.  In addition, corresponding files at two  different sites may have different names even when the operating system  is the same; for example, they may be on different directories or  different devices.  The issue of portable pathname values is separate from the issues of  portable pathname operations.  See the related issues listed above.  For inter-issue interactions, see the discussion section below.  Note that issue PATHNAME-LOGICAL fundamentally depends on issue  PATHNAME-WILD.  If PATHNAME-WILD:NEW-FUNCTIONS does not pass,  PATHNAME-LOGICAL cannot pass.Proposal (PATHNAME-LOGICAL:ADD):  1. Define a "logical" file system that looks the same at every site.  This file system is implemented by translating each logical pathname into  a physical pathname on a real file system.  The logical pathnames are the  same at all sites, but the translations are different at each site, thus  the physical pathnames can be different at each site.  2a. The syntax of a logical pathname namestring is as follows:  [ host ":" ] [ ";" ] { directory ";" }* [ name ] [ "." type [ "." version ]]  2b. Terminology:  A <word> consists of one or more uppercase letters, digits, and hyphens.  A <wildcard word> consists of one or more asterisks, uppercase letters,  digits, and hyphens, including at least one asterisk, with no two  asterisks adjacent.  Each asterisk matches a sequence of zero or more  characters.  The <wildcard word> "*" parses into :WILD, the others parse  into strings.  In <words> and <wildcard words> lowercase letters are translated to  uppercase.  The consequences of using other characters are unspecified.  2c. Logical pathname components:  The host is a <word> that has been defined as a logical pathname host by  using SETF of LOGICAL-PATHNAME-TRANSLATIONS.  There is no device, so the device component of a logical pathname is  always :UNSPECIFIC.  No other component can be :UNSPECIFIC.  Each directory is a <word>, a <wildcard word>, or "**" (:WILD-INFERIORS).  If a semicolon precedes the directories, the directory component is  relative, otherwise it is absolute.  The name is a <word> or a <wildcard word>.  The type is a <word> or a <wildcard word>.  The version is a positive decimal integer or "NEWEST" (:NEWEST) or "*"  (:WILD).  The letters in "NEWEST" can be in either alphabetic case.  The consequences of using any value not specified here as a logical  pathname component are unspecified.  The null string "" is not a valid value for any component of a logical  pathname, since "" is not a <word> and not a <wildcard word>.  3. Parsing of logical pathname namestrings into logical pathnames  operates as follows:  3a. Logical pathname namestrings are recognized by the LOGICAL-PATHNAME  and TRANSLATE-LOGICAL-PATHNAME functions.  In this case the host portion  of the logical pathname namestring and its following colon are required.  3b. The PARSE-NAMESTRING function recognizes a logical pathname  namestring when the host argument is logical or the defaults argument is  a logical pathname.  In this case the host portion of the logical  pathname namestring and its following colon are optional.  If the host  portion of the namestring and the host argument are both present and do  not match, an error is signalled.  The host argument is logical if it is supplied and came from  PATHNAME-HOST of a logical pathname.  Whether a host argument is logical  if it is a string equal to a logical pathname host name is  implementation-defined.  3c. The MERGE-PATHNAMES function recognizes a logical pathname namestring  when the defaults argument is a logical pathname.  In this case the host  portion of the logical pathname namestring and its following colon are  optional.  3d. Whether the other functions that coerce strings to pathnames  (PATHNAME, TRUENAME, PARSE-NAMESTRING in other circumstances than those  described in point 3b, MERGE-PATHNAMES in other circumstances than those  described in point 3c, the :DEFAULTS argument to MAKE-PATHNAME,  PATHNAME-HOST, PATHNAME-DEVICE, PATHNAME-DIRECTORY, PATHNAME-NAME,  PATHNAME-TYPE, PATHNAME-VERSION, NAMESTRING, FILE-NAMESTRING,  DIRECTORY-NAMESTRING, HOST-NAMESTRING, ENOUGH-NAMESTRING, OPEN,  WITH-OPEN-FILE, RENAME-FILE, DELETE-FILE, PROBE-FILE, FILE-WRITE-DATE,  FILE-AUTHOR, LOAD, DIRECTORY, COMPILE-FILE, ED, DRIBBLE, WILD-PATHNAME-P,  PATHNAME-MATCH-P, TRANSLATE-PATHNAME, and COMPILE-FILE-PATHNAME)  recognize logical pathname namestrings is implementation defined.  4. Some real file systems do not have versions.  Logical pathname  translation to such a file system ignores the version.  This implies that  a program cannot rely on being able to store more than one version of a  file named by a logical pathname.  5. The type of a logical pathname for a Common Lisp source file is "LISP".  This should be translated into whatever type is appropriate in a physical  pathname.  6. The logical pathname host name "SYS" is reserved for the implementation.  The existence and meaning of SYS: logical pathnames is  implementation-defined.  7. File manipulation functions operate with logical pathnames as follows:  7a. The functions OPEN (and WITH-OPEN-FILE), RENAME-FILE, DELETE-FILE,  PROBE-FILE, FILE-WRITE-DATE, FILE-AUTHOR, LOAD, DIRECTORY, COMPILE-FILE,  ED, DRIBBLE, COMPILE-FILE-PATHNAME, and TRUENAME accept logical pathnames  and translate them into physical pathnames, as if by calling the  TRANSLATE-LOGICAL-PATHNAME function.  7b. PATHNAME of a stream created by OPEN (or WITH-OPEN-FILE) of a logical  pathname is a logical pathname.  7c. TRUENAME, PROBE-FILE, and DIRECTORY never return logical pathnames.  7d. RENAME-FILE with a logical pathname as the second argument returns a  logical pathname as the first value.  7e. MERGE-PATHNAMES returns a logical pathname if and only if its first  argument is a logical pathname or its first argument does not specify a  host and the default is a logical pathname.  7f. MAKE-PATHNAME returns a logical pathname if and only if the host is  logical.  If the :host argument to MAKE-PATHNAME is supplied, the host is  logical if it came from PATHNAME-HOST of a logical pathname.  Whether a  :host argument is logical if it is a string equal to a logical pathname  host name is implementation-defined.  7g. PARSE-NAMESTRING returns a logical pathname according to points 3b  and 3d.  Add these defined names to Common Lisp in support of logical pathnames:  8. LOGICAL-PATHNAME                                            [Class]    LOGICAL-PATHNAME is a subclass of PATHNAME.  9. LOGICAL-PATHNAME pathname                                   [Function]    Converts the argument to a logical pathname and returns it.  The    argument can be a logical pathname, a logical pathname namestring    containing a host component, or a stream for which the PATHNAME    function returns a logical pathname.  For any other argument,    LOGICAL-PATHNAME signals an error of type TYPE-ERROR.  10. TRANSLATE-LOGICAL-PATHNAME pathname                        [Function]    Translates a logical pathname to the corresponding physical pathname.    The pathname argument is first coerced to a pathname.  If it is not a    pathname, string, or file stream an error of type TYPE-ERROR is    signalled.    If the coerced argument is a logical pathname, the first matching    translation (according to PATHNAME-MATCH-P) of the logical pathname    host is applied, using TRANSLATE-PATHNAME with the reversible argument    true.  If the result is a logical pathname, this process is repeated.    Three values are returned:      1. The physical pathname      2. The from-wildcard of the translation      3. The to-wildcard of the translation    If no translation matches, an error of type FILE-ERROR is signalled.    If the coerced argument is a physical pathname, it is returned as all    three values.    All three values are pathnames.  The second and third values might not    come directly from a logical pathname translation list; they might be    modified to reflect multiple levels of translation and/or additional    translations, typically to provide translation of file types to local    naming conventions, to accomodate physical file systems with limited    length names, or to deal with special character requirements such as    translating hyphens to underscores or uppercase letters to lowercase.    Any such additional translations are implementation defined.  Some    implementations do no additional translations.    Except when an error is signalled, TRANSLATE-LOGICAL-PATHNAME satisfies    this identity:    (MULTIPLE-VALUE-BIND (PHYSICAL FROM-WILDCARD TO-WILDCARD)        (TRANSLATE-LOGICAL-PATHNAME LOGICAL)      (AND (EQUAL (TRANSLATE-PATHNAME LOGICAL FROM-WILDCARD TO-WILDCARD T)                  PHYSICAL)           (EQUAL (TRANSLATE-PATHNAME PHYSICAL TO-WILDCARD FROM-WILDCARD T)                  LOGICAL)))    The above is written assuming the LOGICAL argument has already been    coerced to a pathname.  11. LOGICAL-PATHNAME-TRANSLATIONS host                         [Function]    If <host> is not the host component of a logical pathname and not a    string that has been defined as a logical pathname host name by SETF of    LOGICAL-PATHNAME-TRANSLATIONS, signals an error of type TYPE-ERROR.    Otherwise returns the host's list of translations.  Each translation is    a list of at least two elements: from-wildcard and to-wildcard.  Any    additional elements are implementation defined.  From-wildcard is a    logical pathname whose host is <host>.  To-wildcard is a pathname.    Translations are searched in the order listed, so more specific    from-wildcards must precede more general ones.    (SETF (LOGICAL-PATHNAME-TRANSLATIONS host) translations) sets a logical    pathname host's list of translations.  If <host> is a string that has    not been previously used as logical pathname host, a new logical    pathname host is defined, otherwise an existing host's translations are    replaced.  Logical pathname host names are compared with STRING-EQUAL.    When setting the translations list, each from-wildcard can be a logical    pathname whose host is <host> or a logical pathname namestring    parseable by (PARSE-NAMESTRING string host).  Each to-wildcard can be    anything coercible to a pathname by (PATHNAME to-wildcard).  If    to-wildcard coerces to a logical pathname, TRANSLATE-LOGICAL-PATHNAME    will perform repeated translation steps when it uses it.  There can    be implementation-defined restrictions against logical to-wildcards    that would produce non-reversible translations.    Implementations can define additional functions that operate on    logical pathname hosts.  12. LOAD-LOGICAL-PATHNAME-TRANSLATIONS host                    [Function]    If a logical pathname host named <host> (a string) is already defined,    return NIL.  Otherwise, search for a logical pathname host definition    in an implementation defined manner.  If none is found, signal an    error.  If a definition is found, install it and return T.    The search used by LOAD-LOGICAL-PATHNAME-TRANSLATIONS should be    documented, as logical pathname definitions will be created by users,    not only by Lisp implementors.  A typical search technique is to    look in a certain directory for a file whose name is derived from    the host name in an implementation-defined fashion.  13. COMPILE-FILE-PATHNAME pathname &key :output-file           [Function]    Returns the pathname that COMPILE-FILE would write into, if given the    same arguments.  If the pathname argument is a logical pathname and the    :output-file argument is unspecified, the result is a logical pathname.    If an implementation supports additional keyword arguments to    COMPILE-FILE, COMPILE-FILE-PATHNAME must accept the same arguments.Examples:  ;This function is like DIRECTORY, but if its argument is a logical  ;pathname it returns logical pathnames in the results.  If its  ;argument is a physical pathname, it is the same as DIRECTORY.  (defun logical-directory (pathname)    (multiple-value-bind (physical from-wildcard to-wildcard)        (translate-logical-pathname pathname)      (map 'list #'(lambda (truename)                     (translate-pathname truename to-wildcard                                         from-wildcard t))           (directory physical))))  ;A very simple example of setting up a logical pathname host.  No  ;translations are necessary to get around file system restrictions, so  ;all that is necessary is to specify the root of the physical directory  ;tree that contains the logical file system.  ;The namestring syntax on the right-hand side is implementation-specific.  (setf (logical-pathname-translations "foo")        '(("**;*.*.*"              "MY-LISPM:>library>foo>**>")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "foo:bar;baz;mum.quux.3")  => MY-LISPM:>library>foo>bar>baz>mum.quux.3,     foo:**;*.*.*,     MY-LISPM:>library>foo>**>*.*.*  ;A more complex example, dividing the files among two file servers  ;and several different directories.  This Unix doesn't support  ;:WILD-INFERIORS in the directory, so each directory level must  ;be translated individually.  No file name or type translations  ;are required except for .MAIL to .MBX.  ;The namestring syntax on the right-hand side is implementation-specific.  (setf (logical-pathname-translations "prog")        '(("RELEASED;*.*.*"        "MY-UNIX:/sys/bin/my-prog/")          ("RELEASED;*;*.*.*"      "MY-UNIX:/sys/bin/my-prog/*/")          ("EXPERIMENTAL;*.*.*"    "MY-UNIX:/usr/Joe/development/prog/")          ("EXPERIMENTAL;DOCUMENTATION;*.*.*"                                   "MY-VAX:SYS$DISK:[JOE.DOC]")          ("EXPERIMENTAL;*;*.*.*"  "MY-UNIX:/usr/Joe/development/prog/*/")          ("MAIL;**;*.MAIL"        "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:mail;save;ideas.mail.3")  => MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3,     PROG:MAIL;**;*.MAIL.*,     MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX.*  ;Example translations for a program that uses three files main.lisp,  ;auxiliary.lisp, and documentation.lisp.  These translations might be  ;supplied by a software supplier as examples.  ;For Unix with long file names  (setf (logical-pathname-translations "prog")        '(("CODE;*.*.*"             "/lib/prog/")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => /lib/prog/documentation.lisp,     PROG:CODE;*.*.*,     /lib/prog/*  ;For Unix with 14-character file names, using .lisp as the type  (setf (logical-pathname-translations "prog")        '(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*")          ("CODE;*.*.*"             "/lib/prog/")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => /lib/prog/docum.lisp,     PROG:CODE;DOCUMENTATION.*.*,     /lib/prog/docum.*  ;For Unix with 14-character file names, using .l as the type  ;The second translation shortens the compiled file type to .b  (setf (logical-pathname-translations "prog")        `(("**;*.LISP.*"            ,(logical-pathname "PROG:**;*.L.*"))          (,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*"))                                    ,(logical-pathname "PROG:**;*.B.*"))          ("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*")          ("CODE;*.*.*"             "/lib/prog/")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => /lib/prog/documentatio.l,     PROG:CODE;DOCUMENTATION.LISP.*,     /lib/prog/documentatio.l  ;For a Cray with 6 character names and no directories, types, or versions.  (setf (logical-pathname-translations "prog")        (let ((l '(("MAIN" "PGMN")                   ("AUXILIARY" "PGAUX")                   ("DOCUMENTATION" "PGDOC")))              (logpath (logical-pathname "prog:code;"))              (phypath (pathname "XXX")))          (append            ;; Translations for source files            (mapcar #'(lambda (x)                        (let ((log (first x))                              (phy (second x)))                          (list (make-pathname :name log                                               :type "LISP"                                               :version :wild                                               :defaults logpath)                                (make-pathname :name phy                                               :defaults phypath))))                    l)            ;; Translations for compiled files            (mapcar #'(lambda (x)                        (let* ((log (first x))                               (phy (second x))                               (com (compile-file-pathname                                      (make-pathname :name log                                                     :type "LISP"                                                     :version :wild                                                     :defaults logpath))))                          (setq phy (concatenate 'string phy "B"))                          (list com                                (make-pathname :name phy                                               :defaults phypath))))                    l))))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => PGDOC,     PROG:CODE;DOCUMENTATION.LISP.*,     PGDOCRationale:  1. Large programs can be moved between sites without changing any  pathnames, provided all pathnames used are logical.  A portable system  construction tool can be created that operates on programs defined as  sets of files named by logical pathnames.  2. Logical pathname syntax was chosen to be easily translated into most  popular file systems, while still being powerful enough for storing large  programs.  Although they have hierarchical directories, extended wildcard  matching, versions, and no limit on the length of names, they can be  mapped onto a less capable real file file system by translating each  directory that is used into a flat directory name, doing wildcards in  Lisp rather than in the file system, treating all versions as :newest,  and/or using translations to shorten long names.  Logical pathname words are restricted to non-case-sensitive letters,  digits, and hyphens to avoid creating problems with real file systems  that support limited character sets for file naming.  Other characters  could have been mapped onto such file systems through translations, but  that didn't seem worth the trouble.  Logical pathnames have to be  non-case-sensitive or it would be very difficult to map them onto a  non-case-sensitive file system.  Features such as :UP and :BACK relative directories and a namestring  syntax for the root directory were not felt to be necessary in logical  pathnames.  They could be added later if a need emerges.  It is not a goal of logical pathnames to be able to represent all  possible file names.  Their goal is rather to represent just enough file  names to be useful for storing software.  Real pathnames, in contrast,  need to provide a uniform interface to all possible file names, including  names and naming conventions that are not under the control of Common  Lisp.  The choice of logical pathname syntax, using colon, semicolon, and  period, was guided by the goals of being visually distinct from real file  systems and minimizing the use of special characters.  The consequences of using any value not specified here as a logical  pathname component are unspecified, for the benefit of the Explorer.  3. The LOGICAL-PATHNAME function is separate from the PATHNAME function  so that the syntax of logical pathname namestrings does not constrain the  syntax of physical pathname namestrings in any way.  Logical pathname  syntax must be defined by Common Lisp so that logical pathnames can be  conveniently exchanged between implementations, but physical pathname  syntax is dictated by forces outside our control.  3b,c. Allowing PARSE-NAMESTRING and MERGE-PATHNAMES to recognize logical  pathname namestrings in these situations provides for natural operations  on logical pathnames.  Frequently a string containing just a name, or a  name and a type, will be recognized as a logical pathname by merging it  against a default containing a logical pathname host and directory.  3d. Recognition of logical pathname namestrings by PATHNAME and related  functions is left up to each implementation because some implementations  definitely require this, other implementations don't want to do this, and  nobody wants to change.  In any case, Common Lisp historically has avoided  saying anything about the syntax of the strings accepted by the PATHNAME  function, and point 3d preserves that position.  3b,7f. Leaving it implementation defined whether a string, used as the  host argument to PARSE-NAMESTRING or the :host argument to MAKE-PATHNAME,  can be recognized as logical pathname host name is for the same reason as  point 3d.  It allows each implementation to decide whether there is one  namespace or two.  The correct way to write this is:    (MAKE-PATHNAME :HOST (PATHNAME-HOST (LOGICAL-PATHNAME "hostname:"))                   ...)  4. Logical pathname versions could have been supported on real file  systems that do not have versions by defining a kind of translation to  encode the version number in the name.  However, the typical use of  versions is such that on a file system without versions, people would  rather just store one version of a file, and not preserve the version  information by encoding it somehow in the name.  This is different from  the typical use of types or directories, where the files with different  values in those components are truly distinct and everything would break  if you only kept one file.  5,13. The COMPILE-FILE-PATHNAME function and the specification of "LISP"  as the type of a logical pathname for a Common Lisp source file together  provide enough information about compilation for a portable system  construction tool that uses logical pathnames to work.  Suppose you want  to call COMPILE-FILE only if the source file is newer than the compiled  file.  To do that, you have to have a way to know the name of the  compiled file without actually calling COMPILE-FILE.  No standard file type for compiler output is proposed, because in some  implementations the compiler produces one of several file types,  depending on a variety of implementation-dependent circumstances.  COMPILE-FILE-PATHNAME provides access to the "default[ing] in a manner  appropriate to the implementation's file system conventions" mentioned in  the CLtL documentation of COMPILE-FILE.  6. The use of the logical pathname host name "SYS" for the implementation  is current practice.  Standardizing on this name helps users choose  logical pathname host names that avoid conflicting with  implementation-defined names.  7. Accepting logical pathnames for file access is a natural extension  of the file access functions and makes it easier to program using only  logical pathnames in situations where that is appropriate.  8. The LOGICAL-PATHNAME class exists so that methods can distinguish  logical pathnames from regular pathnames.  9. See point 3 above.  10. TRANSLATE-LOGICAL-PATHNAME is the heart of the logical pathname  feature.  The two extra values returned by TRANSLATE-LOGICAL-PATHNAME  allow for back-translation, as shown in the LOGICAL-DIRECTORY example.  Allowing TRANSLATE-LOGICAL-PATHNAME on a physical pathname, simply  returning the argument, makes some programs easier to write.  Additional  implementation defined translations make it possible for implementations  with unusual file systems to offer some help to the user in setting up  the translations for a logical pathname host, by handling some of the  work automatically.  Logical pathnames that translate to other logical  pathnames are a feature that several people have requested.  11. SETF of LOGICAL-PATHNAME-TRANSLATIONS is a simple way for a user to  define a new logical pathname host.  Using SETF makes it possible to add  to or modify the translations of an existing logical pathname host.  The  restriction against non-reversible translations is necessary because many  logical pathname using programs depend on reversibility, for instance to  translate a truename back into a logical pathname.  If logical pathname  translation was not reversible, two different logical pathnames might  translate into the same physical pathname, which could scramble files.  It is always up to the person who writes the translation rules for a  particular logical pathname host to a particular physical file system to  make sure that the logical pathnames that are actually going to be used  translate to valid pathnames for the particular file system.  12. Loading of logical pathname translations from a site-dependent file  allows software to be distributed using logical pathnames.  The assumed  model of software distribution is a division of labor between the  supplier of the software and the user installing it.  The supplier  chooses logical pathnames to name all the files used or created by the  software, and supplies examples of logical pathname translations for a  few popular file systems.  Each example uses an assumed directory and/or  device name, assumes local file naming conventions, and provides  translations that will translate all the logical pathnames used or  generated by the particular software into valid physical pathnames.  For a powerful file system these translations can be quite simple.  For  a more restricted file system, it may be necessary to list an explicit  translation for every logical pathname used, for example when dealing  with restrictions on the maximum length of a file name.  The user installing the software decides on which device and/or directory  to store the files and edits the example logical pathname translations  accordingly.  If necessary, the user also adjusts the translations for  local file naming conventions and any other special aspects of the user's  local file system policy and local Common Lisp implementation.  For  example, the files might be divided among several file server hosts to  share the load.  The process of defining site-customized logical pathname  translations is quite easy for a user of a popular file system for which  the software supplier has provided an example.  A user of a more unusual  file system might have to take more time; the supplier can help by  providing a list of all the logical pathnames used or generated by the  software.  Once the user has created a suitable SETF of LOGICAL-PATHNAME-TRANSLATIONS  form, he can evaluate that form and then load and run the software.  It  may be necessary to use the translations again, or on another workstation  at the same site, so it is best to save the SETF form in the standard  place where it can be found later by LOAD-LOGICAL-PATHNAME-TRANSLATIONS.  Often a software supplier will include a program for restoring software  from the distribution medium to the file system, and a program for loading  the software from the file system into a Common Lisp, and these programs  will start by calling LOAD-LOGICAL-PATHNAME-TRANSLATIONS to make sure that  the logical pathname host is defined.  Note that the SETF of LOGICAL-PATHNAME-TRANSLATIONS form isn't part of  the program, it's separate.  It's written by the user, not by the  software supplier.  That separation, and a uniform convention for how to  do the separation, are the key aspects of logical pathnames.  For small  programs involving only a handful of files, it doesn't matter much.  The  real benefits come with large programs with hundreds or thousands of  files and more complicated situations such as program-generated file  names or porting a program developed on a system with long file names  onto a system with a very restrictive limit on the length of file names.Current practice:  Symbolics Genera has had a similar facility for many years.  It is used  extensively for software distribution by Symbolics and its customers.  The Genera facility uses the same logical pathname syntax but different  function names, and is somewhat more complicated.  The extra complexity  is not necessary in the Common Lisp standard.  The T.I. Explorer also has a comparable logical pathname facility,  although the translation mechanism is unfortunately less general than  proposed here.  The namestring syntax used is slightly different:      host ":" [{directory "."}* directory ";"] [name] ["." type] ["#" version]    The newest version is indicated by ">" instead of "newest".  Macintosh Allegro Common Lisp) has a logical pathname feature which is  somewhat simpler but aimed at solving the same problems.  It has logical  directory names, to simplify access to sets of files in differently named  directories (an especially severe problem on micros where everybody just  has to have a different pet name for their hard disk).  This isn't really  the same as simplifying access to different file systems, although of  course solving the latter automatically solves the former.  In general,  access to different file systems requires translating names and types,  not just translating directories.  Symbolics Genera offers a function for translating from a physical  pathname back to a logical pathname.  There are a number of problems with  this, and so it has not been proposed here.  Instead  TRANSLATE-LOGICAL-PATHNAME returns enough information to allow the user  program to perform the backtranslation itself.  The Genera equivalent of LOAD-LOGICAL-PATHNAME-TRANSLATIONS looks for  a file named SYS:SITE;hostname.TRANSLATIONS.  Current practice in Genera, Explorer, and Macintosh has one namespace for  both logical and physical namestrings.  This proposal allows an  implementation to choose to have one namespace or to have two separate  namespaces for namestrings.Cost to Implementors:  This is a fairly complex facility, but its performance is unimportant  so a straightforward implementation should suffice.  Most of the  complexity comes in dealing with unusual file systems, such as ones  that don't allow long file names.Cost to Users:  None.Cost of non-adoption:  Portable software construction and distribution will have to rely on  implementation-dependent kludges.  Lisp software will continue to be  difficult to install.Performance impact:  None.Benefits:  Avoid cost of non-adoption.Esthetics:  Improved portability of large programs.Discussion:  Issue PATHNAME-LOGICAL fundamentally depends on issue PATHNAME-WILD.  If  PATHNAME-WILD:NEW-FUNCTIONS does not pass, PATHNAME-LOGICAL cannot pass.  If PATHNAME-CANONICAL-TYPE:NEW-CONCEPT passes, it will affect the  behavior of the function TRANSLATE-PATHNAME and therefore the behavior of  the function TRANSLATE-LOGICAL-PATHNAME.  When a logical pathname  translation has from-wildcard and to-wildcard type components that are  :WILD or omitted, translation of the type will be guided by canonical  types.  If PATHNAME-CANONICAL-TYPE:NEW-CONCEPT fails to pass, it will  either have to be done behind the scenes by TRANSLATE-PATHNAME or users  will have to write more verbose translations that individually specify  the handling of each file type.*start*02974 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 21-Jun-89 18:36:48 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 18:36:56 PDTReceived: from Think.COM (Gateway.Think.COM) by SAIL.Stanford.EDU with TCP; 21 Jun 89  18:35:27 PDTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Wed, 21 Jun 89 21:36:17 EDTDate: Wed, 21 Jun 89 21:34 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: PATHNAME-LOGICAL (version 3)To: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890621161905.6.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>Message-Id: <19890622013420.6.BARMAR@OCCAM.THINK.COM>  10. TRANSLATE-LOGICAL-PATHNAME pathname                        [Function]    If the coerced argument is a logical pathname, the first matching    translation (according to PATHNAME-MATCH-P) of the logical pathname    host is applied, using TRANSLATE-PATHNAME with the reversible argument    true.  If the result is a logical pathname, this process is repeated.    Three values are returned:      1. The physical pathname      2. The from-wildcard of the translation      3. The to-wildcard of the translationIf the translation process has to be repeated, which wildcards arereturned as values 2 and 3, the first or the last?  It seems to me thatin order to be useful, this must return the entire sequence of wildcardpairs that were used.  The description later says:    they might be    modified to reflect multiple levels of translation and/or additional    translationsMaybe this is answering my question, but I'm unsure whether a singlepair of wildcards can represent a sequence of translations; I guess thequestion is whether wildcard translations form a group, or somethinglike that (my math theory is a bit rusty).Also, I expect that there are some translations that simply can't berepresented as wildcard translations.  For instance, Genera translates	SYS:<system>;PATCH;<system>-<version#>-<patch#>.<type>to	SYS:<system>;PATCH;<system>-<version>;<system>-<version#>-<patch#>.<type>which requires at least something as powerful as regular expressionswith variables.  I'm not saying that the portable logical pathnamefacility must allow the programmer to implement the above translation;I'm wondering what Genera will return as values 2 and 3 in the casewhere a patch file pathname is given to TRANSLATE-LOGICAL-PATHNAME.I suppose this can be done using wildcards, since there's no restrictionon how complex an implementation's wildcard facility may be (it couldinclude variables, for instance).  But current practice is to performsome complex translations outside the wildcard translation mechanism(and in Genera, one could define a subclass of FS:LOGICAL-HOST thatincorporates arbitrary translation rules).                                                barmar*start*03848 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 22-Jun-89 10:45:15 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 JUN 89 10:44:55 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 22 Jun 89  10:43:14 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 615296; 22 Jun 89 13:44:50 EDTDate: Thu, 22 Jun 89 13:45 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-LOGICAL (version 3)To: Barry Margolin <barmar@Think.COM>cc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890622013420.6.BARMAR@OCCAM.THINK.COM>Message-ID: <19890622174528.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Wed, 21 Jun 89 21:34 EDT    From: Barry Margolin <barmar@Think.COM>      10. TRANSLATE-LOGICAL-PATHNAME pathname                        [Function]	If the coerced argument is a logical pathname, the first matching	translation (according to PATHNAME-MATCH-P) of the logical pathname	host is applied, using TRANSLATE-PATHNAME with the reversible argument	true.  If the result is a logical pathname, this process is repeated.	Three values are returned:	  1. The physical pathname	  2. The from-wildcard of the translation	  3. The to-wildcard of the translation    If the translation process has to be repeated, which wildcards are    returned as values 2 and 3, the first or the last?  Neither.							It seems to me that    in order to be useful, this must return the entire sequence of wildcard    pairs that were used.  The description later says:	they might be	modified to reflect multiple levels of translation and/or additional	translations    Maybe this is answering my question, but I'm unsure whether a single    pair of wildcards can represent a sequence of translations; I guess the    question is whether wildcard translations form a group, or something    like that (my math theory is a bit rusty).That text was supposed to answer your question, as was the example thatbegins ";For Unix with 14-character file names, using .l as the type".In retrospect it wasn't nearly as clear as it should have been.The fact that I think you are overlooking is that the -only- requirementon the second and third values from TRANSLATE-LOGICAL-PATHNAME is theidentity given in point 10 of the proposal.  They do not have to begeneral wildcards that can translate -anything- back to a logical pathname,the proposal only requires them to work for the particular physicalpathname that was returned.  Thus to-wildcard could be equal to thephysical pathname and from-wildcard could be equal to the logical pathname.This would translate that one physical pathname back to that one logicalpathname.Of course it's better if an implementation returns more generally usefulwildcard pathnames; I wanted to formulate a stronger constraint on theimplementation but couldn't think of one.  The best I've been able to doso far is that if component X has a value of :WILD (or NIL) in everylevel of translation, then component X in the result should be :WILD;apply this rule separately to from and to.  Should this be put in tothe proposal by amendment, or am I trying to overspecify here?The other possibility would be to eliminate all support for backtranslation by eliminating the extra return values from TRANSLATE-PATHNAMEand TRANSLATE-LOGICAL-PATHNAME (we would add these functions to the listthat implementations are allowed to extend by adding extra values).This would certainly simplify things and might be for the best.The more I think about it the more I like this idea, perhaps I'll cometo the meeting prepared with amendments to these two proposals.*start*33610 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 23-Jun-89 11:19:55 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 JUN 89 11:19:38 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 23 Jun 89  10:51:11 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 616034; 23 Jun 89 13:53:02 EDTDate: Fri, 23 Jun 89 13:51 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-LOGICAL (version 4)To: X3J13@sail.stanford.eduMessage-ID: <19890623175120.5.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This is an old issue but it has not been written up before.  I'm sorry thisis coming out so late, but it's been quite a struggle to cast it into clearand easily understood form.  It is rather a long proposal in order to bevery clear about exactly what it's proposing, and I apologize for thelength.This version has been amended and simplified based on last-minutediscussion: Support for back-translation has been removed.TRANSLATE-LOGICAL-PATHNAME now returns only value, but has added abilityfor implementations to add keyword arguments and extra return values.I also made a minor clarification under LOGICAL-PATHNAME-TRANSLATIONS.The LOGICAL-DIRECTORY example has been removed, as it is no longerpossible for a user to implement that functionality.Issue:          PATHNAME-LOGICALForum:          CleanupReferences:     Pathnames (pp410-413)                OPEN (p.418), WITH-OPEN-FILE (p.422), RENAME-FILE (p.423),                DELETE-FILE (p.424), PROBE-FILE (p.424),                FILE-WRITE-DATE (p.424), FILE-AUTHOR (p.424), LOAD (p.426),                COMPILE-FILE (p.439), DIRECTORY (p.427), PATHNAME (p.413),                TRUENAME (p.413), MERGE-PATHNAMES (p.415),                 MAKE-PATHNAME (p.416), and PARSE-NAMESTRING (p.414).Related issues: PATHNAME-CANONICAL-TYPE, PATHNAME-COMPONENT-VALUES,                 PATHNAME-SUBDIRECTORY-LIST, and PATHNAME-WILDCategory:       ADDITIONEdit history:   Version 1, 11-May-89, by Moon                Version 2, 18-May-89, by Moon                Version 3, 21-Jun-89, by Moon (revise based on discussion                        in the cleanup committee)                Version 4, 23-Jun-89, by Moon (remove backtranslation)Problem description:  Pathname values are not portable, but they are sometimes part of a  program, for example the names of files containing the program and the  data used by the program.  Moving large programs between sites would  be easier if pathname values did not have to be translated.  Pathname values are nonportable because not all Common Lisp  implementations use the same operating system and file name syntax varies  widely among operating systems.  In addition, corresponding files at two  different sites may have different names even when the operating system  is the same; for example, they may be on different directories or  different devices.  The issue of portable pathname values is separate from the issues of  portable pathname operations.  See the related issues listed above.  For inter-issue interactions, see the discussion section below.  Note that issue PATHNAME-LOGICAL fundamentally depends on issue  PATHNAME-WILD.  If PATHNAME-WILD:NEW-FUNCTIONS does not pass,  PATHNAME-LOGICAL cannot pass.Proposal (PATHNAME-LOGICAL:ADD):  1. Define a "logical" file system that looks the same at every site.  This file system is implemented by translating each logical pathname into  a physical pathname on a real file system.  The logical pathnames are the  same at all sites, but the translations are different at each site, thus  the physical pathnames can be different at each site.  2a. The syntax of a logical pathname namestring is as follows:  [ host ":" ] [ ";" ] { directory ";" }* [ name ] [ "." type [ "." version ]]  2b. Terminology:  A <word> consists of one or more uppercase letters, digits, and hyphens.  A <wildcard word> consists of one or more asterisks, uppercase letters,  digits, and hyphens, including at least one asterisk, with no two  asterisks adjacent.  Each asterisk matches a sequence of zero or more  characters.  The <wildcard word> "*" parses into :WILD, the others parse  into strings.  In <words> and <wildcard words> lowercase letters are translated to  uppercase.  The consequences of using other characters are unspecified.  2c. Logical pathname components:  The host is a <word> that has been defined as a logical pathname host by  using SETF of LOGICAL-PATHNAME-TRANSLATIONS.  There is no device, so the device component of a logical pathname is  always :UNSPECIFIC.  No other component can be :UNSPECIFIC.  Each directory is a <word>, a <wildcard word>, or "**" (:WILD-INFERIORS).  If a semicolon precedes the directories, the directory component is  relative, otherwise it is absolute.  The name is a <word> or a <wildcard word>.  The type is a <word> or a <wildcard word>.  The version is a positive decimal integer or "NEWEST" (:NEWEST) or "*"  (:WILD).  The letters in "NEWEST" can be in either alphabetic case.  The consequences of using any value not specified here as a logical  pathname component are unspecified.  The null string "" is not a valid value for any component of a logical  pathname, since "" is not a <word> and not a <wildcard word>.  3. Parsing of logical pathname namestrings into logical pathnames  operates as follows:  3a. Logical pathname namestrings are recognized by the LOGICAL-PATHNAME  and TRANSLATE-LOGICAL-PATHNAME functions.  In this case the host portion  of the logical pathname namestring and its following colon are required.  3b. The PARSE-NAMESTRING function recognizes a logical pathname  namestring when the host argument is logical or the defaults argument is  a logical pathname.  In this case the host portion of the logical  pathname namestring and its following colon are optional.  If the host  portion of the namestring and the host argument are both present and do  not match, an error is signalled.  The host argument is logical if it is supplied and came from  PATHNAME-HOST of a logical pathname.  Whether a host argument is logical  if it is a string equal to a logical pathname host name is  implementation-defined.  3c. The MERGE-PATHNAMES function recognizes a logical pathname namestring  when the defaults argument is a logical pathname.  In this case the host  portion of the logical pathname namestring and its following colon are  optional.  3d. Whether the other functions that coerce strings to pathnames  (PATHNAME, TRUENAME, PARSE-NAMESTRING in other circumstances than those  described in point 3b, MERGE-PATHNAMES in other circumstances than those  described in point 3c, the :DEFAULTS argument to MAKE-PATHNAME,  PATHNAME-HOST, PATHNAME-DEVICE, PATHNAME-DIRECTORY, PATHNAME-NAME,  PATHNAME-TYPE, PATHNAME-VERSION, NAMESTRING, FILE-NAMESTRING,  DIRECTORY-NAMESTRING, HOST-NAMESTRING, ENOUGH-NAMESTRING, OPEN,  WITH-OPEN-FILE, RENAME-FILE, DELETE-FILE, PROBE-FILE, FILE-WRITE-DATE,  FILE-AUTHOR, LOAD, DIRECTORY, COMPILE-FILE, ED, DRIBBLE, WILD-PATHNAME-P,  PATHNAME-MATCH-P, TRANSLATE-PATHNAME, and COMPILE-FILE-PATHNAME)  recognize logical pathname namestrings is implementation defined.  4. Some real file systems do not have versions.  Logical pathname  translation to such a file system ignores the version.  This implies that  a program cannot rely on being able to store more than one version of a  file named by a logical pathname.  5. The type of a logical pathname for a Common Lisp source file is "LISP".  This should be translated into whatever type is appropriate in a physical  pathname.  6. The logical pathname host name "SYS" is reserved for the implementation.  The existence and meaning of SYS: logical pathnames is  implementation-defined.  7. File manipulation functions operate with logical pathnames as follows:  7a. The functions OPEN (and WITH-OPEN-FILE), RENAME-FILE, DELETE-FILE,  PROBE-FILE, FILE-WRITE-DATE, FILE-AUTHOR, LOAD, DIRECTORY, COMPILE-FILE,  ED, DRIBBLE, COMPILE-FILE-PATHNAME, and TRUENAME accept logical pathnames  and translate them into physical pathnames, as if by calling the  TRANSLATE-LOGICAL-PATHNAME function.  7b. PATHNAME of a stream created by OPEN (or WITH-OPEN-FILE) of a logical  pathname is a logical pathname.  7c. TRUENAME, PROBE-FILE, and DIRECTORY never return logical pathnames.  7d. RENAME-FILE with a logical pathname as the second argument returns a  logical pathname as the first value.  7e. MERGE-PATHNAMES returns a logical pathname if and only if its first  argument is a logical pathname or its first argument does not specify a  host and the default is a logical pathname.  7f. MAKE-PATHNAME returns a logical pathname if and only if the host is  logical.  If the :host argument to MAKE-PATHNAME is supplied, the host is  logical if it came from PATHNAME-HOST of a logical pathname.  Whether a  :host argument is logical if it is a string equal to a logical pathname  host name is implementation-defined.  7g. PARSE-NAMESTRING returns a logical pathname according to points 3b  and 3d.  Add these defined names to Common Lisp in support of logical pathnames:  8. LOGICAL-PATHNAME                                            [Class]    LOGICAL-PATHNAME is a subclass of PATHNAME.  9. LOGICAL-PATHNAME pathname                                   [Function]    Converts the argument to a logical pathname and returns it.  The    argument can be a logical pathname, a logical pathname namestring    containing a host component, or a stream for which the PATHNAME    function returns a logical pathname.  For any other argument,    LOGICAL-PATHNAME signals an error of type TYPE-ERROR.  10. TRANSLATE-LOGICAL-PATHNAME pathname &key                   [Function]    Translates a logical pathname to the corresponding physical pathname.    The pathname argument is first coerced to a pathname.  If it is not a    pathname, string, or file stream an error of type TYPE-ERROR is    signalled.    If the coerced argument is a physical pathname, it is returned.    If the coerced argument is a logical pathname, the first matching    translation (according to PATHNAME-MATCH-P) of the logical pathname    host is applied, as if by calling TRANSLATE-PATHNAME.  If the result is    a logical pathname, this process is repeated.  When the result is    finally a physical pathname, it is returned.    If no translation matches, an error of type FILE-ERROR is signalled.    TRANSLATE-LOGICAL-PATHNAME might perform additional translations,    typically to provide translation of file types to local naming    conventions, to accomodate physical file systems with limited length    names, or to deal with special character requirements such as    translating hyphens to underscores or uppercase letters to lowercase.    Any such additional translations are implementation defined.  Some    implementations do no additional translations.    There are no specified keyword arguments for    TRANSLATE-LOGICAL-PATHNAME, but implementations are permitted to extend    it by adding keyword arguments.  There is one specified return value    from TRANSLATE-LOGICAL-PATHNAME; implementations are permitted to    extend it by returning additional values.  11. LOGICAL-PATHNAME-TRANSLATIONS host                         [Function]    If <host> is not the host component of a logical pathname and not a    string that has been defined as a logical pathname host name by SETF of    LOGICAL-PATHNAME-TRANSLATIONS, signals an error of type TYPE-ERROR.    Otherwise returns the host's list of translations.  Each translation is    a list of at least two elements: from-wildcard and to-wildcard.  Any    additional elements are implementation defined.  From-wildcard is a    logical pathname whose host is <host>.  To-wildcard is a pathname.    Translations are searched in the order listed, so more specific    from-wildcards must precede more general ones.    (SETF (LOGICAL-PATHNAME-TRANSLATIONS host) translations) sets a logical    pathname host's list of translations.  If <host> is a string that has    not been previously used as logical pathname host, a new logical    pathname host is defined, otherwise an existing host's translations are    replaced.  Logical pathname host names are compared with STRING-EQUAL.    When setting the translations list, each from-wildcard can be a logical    pathname whose host is <host> or a logical pathname namestring    parseable by (PARSE-NAMESTRING string <<host>>), where <<host>>    represents the appropriate object as defined in point 3b.  Each    to-wildcard can be anything coercible to a pathname by    (PATHNAME to-wildcard).  If to-wildcard coerces to a logical pathname,    TRANSLATE-LOGICAL-PATHNAME will perform repeated translation steps when    it uses it.    Implementations can define additional functions that operate on    logical pathname hosts, for example to specify additional translation    rules or options.  12. LOAD-LOGICAL-PATHNAME-TRANSLATIONS host                    [Function]    If a logical pathname host named <host> (a string) is already defined,    return NIL.  Otherwise, search for a logical pathname host definition    in an implementation defined manner.  If none is found, signal an    error.  If a definition is found, install it and return T.    The search used by LOAD-LOGICAL-PATHNAME-TRANSLATIONS should be    documented, as logical pathname definitions will be created by users,    not only by Lisp implementors.  A typical search technique is to    look in a certain directory for a file whose name is derived from    the host name in an implementation-defined fashion.  13. COMPILE-FILE-PATHNAME pathname &key :output-file           [Function]    Returns the pathname that COMPILE-FILE would write into, if given the    same arguments.  If the pathname argument is a logical pathname and the    :output-file argument is unspecified, the result is a logical pathname.    If an implementation supports additional keyword arguments to    COMPILE-FILE, COMPILE-FILE-PATHNAME must accept the same arguments.Examples:  ;A very simple example of setting up a logical pathname host.  No  ;translations are necessary to get around file system restrictions, so  ;all that is necessary is to specify the root of the physical directory  ;tree that contains the logical file system.  ;The namestring syntax on the right-hand side is implementation-specific.  (setf (logical-pathname-translations "foo")        '(("**;*.*.*"              "MY-LISPM:>library>foo>**>")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "foo:bar;baz;mum.quux.3")  => MY-LISPM:>library>foo>bar>baz>mum.quux.3  ;A more complex example, dividing the files among two file servers  ;and several different directories.  This Unix doesn't support  ;:WILD-INFERIORS in the directory, so each directory level must  ;be translated individually.  No file name or type translations  ;are required except for .MAIL to .MBX.  ;The namestring syntax on the right-hand side is implementation-specific.  (setf (logical-pathname-translations "prog")        '(("RELEASED;*.*.*"        "MY-UNIX:/sys/bin/my-prog/")          ("RELEASED;*;*.*.*"      "MY-UNIX:/sys/bin/my-prog/*/")          ("EXPERIMENTAL;*.*.*"    "MY-UNIX:/usr/Joe/development/prog/")          ("EXPERIMENTAL;DOCUMENTATION;*.*.*"                                   "MY-VAX:SYS$DISK:[JOE.DOC]")          ("EXPERIMENTAL;*;*.*.*"  "MY-UNIX:/usr/Joe/development/prog/*/")          ("MAIL;**;*.MAIL"        "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:mail;save;ideas.mail.3")  => MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3  ;Example translations for a program that uses three files main.lisp,  ;auxiliary.lisp, and documentation.lisp.  These translations might be  ;supplied by a software supplier as examples.  ;For Unix with long file names  (setf (logical-pathname-translations "prog")        '(("CODE;*.*.*"             "/lib/prog/")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => /lib/prog/documentation.lisp  ;For Unix with 14-character file names, using .lisp as the type  (setf (logical-pathname-translations "prog")        '(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*")          ("CODE;*.*.*"             "/lib/prog/")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => /lib/prog/docum.lisp  ;For Unix with 14-character file names, using .l as the type  ;The second translation shortens the compiled file type to .b  (setf (logical-pathname-translations "prog")        `(("**;*.LISP.*"            ,(logical-pathname "PROG:**;*.L.*"))          (,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*"))                                    ,(logical-pathname "PROG:**;*.B.*"))          ("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*")          ("CODE;*.*.*"             "/lib/prog/")))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => /lib/prog/documentatio.l  ;For a Cray with 6 character names and no directories, types, or versions.  (setf (logical-pathname-translations "prog")        (let ((l '(("MAIN" "PGMN")                   ("AUXILIARY" "PGAUX")                   ("DOCUMENTATION" "PGDOC")))              (logpath (logical-pathname "prog:code;"))              (phypath (pathname "XXX")))          (append            ;; Translations for source files            (mapcar #'(lambda (x)                        (let ((log (first x))                              (phy (second x)))                          (list (make-pathname :name log                                               :type "LISP"                                               :version :wild                                               :defaults logpath)                                (make-pathname :name phy                                               :defaults phypath))))                    l)            ;; Translations for compiled files            (mapcar #'(lambda (x)                        (let* ((log (first x))                               (phy (second x))                               (com (compile-file-pathname                                      (make-pathname :name log                                                     :type "LISP"                                                     :version :wild                                                     :defaults logpath))))                          (setq phy (concatenate 'string phy "B"))                          (list com                                (make-pathname :name phy                                               :defaults phypath))))                    l))))  ;Sample use of that logical pathname.  All return values  ;are of course implementation-specific.  (translate-logical-pathname "prog:code;documentation.lisp")  => PGDOCRationale:  1. Large programs can be moved between sites without changing any  pathnames, provided all pathnames used are logical.  A portable system  construction tool can be created that operates on programs defined as  sets of files named by logical pathnames.  2. Logical pathname syntax was chosen to be easily translated into most  popular file systems, while still being powerful enough for storing large  programs.  Although they have hierarchical directories, extended wildcard  matching, versions, and no limit on the length of names, they can be  mapped onto a less capable real file file system by translating each  directory that is used into a flat directory name, doing wildcards in  Lisp rather than in the file system, treating all versions as :newest,  and/or using translations to shorten long names.  Logical pathname words are restricted to non-case-sensitive letters,  digits, and hyphens to avoid creating problems with real file systems  that support limited character sets for file naming.  Other characters  could have been mapped onto such file systems through translations, but  that didn't seem worth the trouble.  Logical pathnames have to be  non-case-sensitive or it would be very difficult to map them onto a  non-case-sensitive file system.  Features such as :UP and :BACK relative directories and a namestring  syntax for the root directory were not felt to be necessary in logical  pathnames.  They could be added later if a need emerges.  It is not a goal of logical pathnames to be able to represent all  possible file names.  Their goal is rather to represent just enough file  names to be useful for storing software.  Real pathnames, in contrast,  need to provide a uniform interface to all possible file names, including  names and naming conventions that are not under the control of Common  Lisp.  The choice of logical pathname syntax, using colon, semicolon, and  period, was guided by the goals of being visually distinct from real file  systems and minimizing the use of special characters.  The consequences of using any value not specified here as a logical  pathname component are unspecified, for the benefit of the Explorer.  3. The LOGICAL-PATHNAME function is separate from the PATHNAME function  so that the syntax of logical pathname namestrings does not constrain the  syntax of physical pathname namestrings in any way.  Logical pathname  syntax must be defined by Common Lisp so that logical pathnames can be  conveniently exchanged between implementations, but physical pathname  syntax is dictated by forces outside our control.  3b,c. Allowing PARSE-NAMESTRING and MERGE-PATHNAMES to recognize logical  pathname namestrings in these situations provides for natural operations  on logical pathnames.  Frequently a string containing just a name, or a  name and a type, will be recognized as a logical pathname by merging it  against a default containing a logical pathname host and directory.  3d. Recognition of logical pathname namestrings by PATHNAME and related  functions is left up to each implementation because some implementations  definitely require this, other implementations don't want to do this, and  nobody wants to change.  In any case, Common Lisp historically has avoided  saying anything about the syntax of the strings accepted by the PATHNAME  function, and point 3d preserves that position.  3b,7f. Leaving it implementation defined whether a string, used as the  host argument to PARSE-NAMESTRING or the :host argument to MAKE-PATHNAME,  can be recognized as logical pathname host name is for the same reason as  point 3d.  It allows each implementation to decide whether there is one  namespace or two.  The correct way to write this is:    (MAKE-PATHNAME :HOST (PATHNAME-HOST (LOGICAL-PATHNAME "hostname:"))                   ...)  4. Logical pathname versions could have been supported on real file  systems that do not have versions by defining a kind of translation to  encode the version number in the name.  However, the typical use of  versions is such that on a file system without versions, people would  rather just store one version of a file, and not preserve the version  information by encoding it somehow in the name.  This is different from  the typical use of types or directories, where the files with different  values in those components are truly distinct and everything would break  if you only kept one file.  5,13. The COMPILE-FILE-PATHNAME function and the specification of "LISP"  as the type of a logical pathname for a Common Lisp source file together  provide enough information about compilation for a portable system  construction tool that uses logical pathnames to work.  Suppose you want  to call COMPILE-FILE only if the source file is newer than the compiled  file.  To do that, you have to have a way to know the name of the  compiled file without actually calling COMPILE-FILE.  No standard file type for compiler output is proposed, because in some  implementations the compiler produces one of several file types,  depending on a variety of implementation-dependent circumstances.  COMPILE-FILE-PATHNAME provides access to the "default[ing] in a manner  appropriate to the implementation's file system conventions" mentioned in  the CLtL documentation of COMPILE-FILE.  6. The use of the logical pathname host name "SYS" for the implementation  is current practice.  Standardizing on this name helps users choose  logical pathname host names that avoid conflicting with  implementation-defined names.  7. Accepting logical pathnames for file access is a natural extension  of the file access functions and makes it easier to program using only  logical pathnames in situations where that is appropriate.  8. The LOGICAL-PATHNAME class exists so that methods can distinguish  logical pathnames from regular pathnames.  9. See point 3 above.  10. TRANSLATE-LOGICAL-PATHNAME is the heart of the logical pathname  feature.  Allowing TRANSLATE-LOGICAL-PATHNAME on a physical pathname,  simply returning the argument, makes some programs easier to write.  Additional implementation defined translations make it possible for  implementations with unusual file systems to offer some help to the user  in setting up the translations for a logical pathname host, by handling  some of the work automatically.  Logical pathnames that translate to  other logical pathnames are a feature that several people have requested.  11. SETF of LOGICAL-PATHNAME-TRANSLATIONS is a simple way for a user to  define a new logical pathname host.  Using SETF makes it possible to add  to or modify the translations of an existing logical pathname host.  It is always up to the person who writes the translation rules for a  particular logical pathname host to a particular physical file system to  make sure that the logical pathnames that are actually going to be used  translate to valid pathnames for the particular file system, and that  no two logical pathnames that are supposed to be distinct translate to  the same physical pathname.  12. Loading of logical pathname translations from a site-dependent file  allows software to be distributed using logical pathnames.  The assumed  model of software distribution is a division of labor between the  supplier of the software and the user installing it.  The supplier  chooses logical pathnames to name all the files used or created by the  software, and supplies examples of logical pathname translations for a  few popular file systems.  Each example uses an assumed directory and/or  device name, assumes local file naming conventions, and provides  translations that will translate all the logical pathnames used or  generated by the particular software into valid physical pathnames.  For a powerful file system these translations can be quite simple.  For  a more restricted file system, it may be necessary to list an explicit  translation for every logical pathname used, for example when dealing  with restrictions on the maximum length of a file name.  The user installing the software decides on which device and/or directory  to store the files and edits the example logical pathname translations  accordingly.  If necessary, the user also adjusts the translations for  local file naming conventions and any other special aspects of the user's  local file system policy and local Common Lisp implementation.  For  example, the files might be divided among several file server hosts to  share the load.  The process of defining site-customized logical pathname  translations is quite easy for a user of a popular file system for which  the software supplier has provided an example.  A user of a more unusual  file system might have to take more time; the supplier can help by  providing a list of all the logical pathnames used or generated by the  software.  Once the user has created a suitable SETF of LOGICAL-PATHNAME-TRANSLATIONS  form, he can evaluate that form and then load and run the software.  It  may be necessary to use the translations again, or on another workstation  at the same site, so it is best to save the SETF form in the standard  place where it can be found later by LOAD-LOGICAL-PATHNAME-TRANSLATIONS.  Often a software supplier will include a program for restoring software  from the distribution medium to the file system, and a program for loading  the software from the file system into a Common Lisp, and these programs  will start by calling LOAD-LOGICAL-PATHNAME-TRANSLATIONS to make sure that  the logical pathname host is defined.  Note that the SETF of LOGICAL-PATHNAME-TRANSLATIONS form isn't part of  the program, it's separate.  It's written by the user, not by the  software supplier.  That separation, and a uniform convention for how to  do the separation, are the key aspects of logical pathnames.  For small  programs involving only a handful of files, it doesn't matter much.  The  real benefits come with large programs with hundreds or thousands of  files and more complicated situations such as program-generated file  names or porting a program developed on a system with long file names  onto a system with a very restrictive limit on the length of file names.Current practice:  Symbolics Genera has had a similar facility for many years.  It is used  extensively for software distribution by Symbolics and its customers.  The Genera facility uses the same logical pathname syntax but different  function names, and is somewhat more complicated.  The extra complexity  is not necessary in the Common Lisp standard.  The T.I. Explorer also has a comparable logical pathname facility,  although the translation mechanism is unfortunately less general than  proposed here.  The namestring syntax used is slightly different:      host ":" [{directory "."}* directory ";"] [name] ["." type] ["#" version]    The newest version is indicated by ">" instead of "newest".  Macintosh Allegro Common Lisp) has a logical pathname feature which is  somewhat simpler but aimed at solving the same problems.  It has logical  directory names, to simplify access to sets of files in differently named  directories (an especially severe problem on micros where everybody just  has to have a different pet name for their hard disk).  This isn't really  the same as simplifying access to different file systems, although of  course solving the latter automatically solves the former.  In general,  access to different file systems requires translating names and types,  not just translating directories.  Symbolics Genera offers a function for translating from a physical  pathname back to a logical pathname.  There are a number of problems with  this, and so it has not been proposed here.  An earlier version specified  TRANSLATE-LOGICAL-PATHNAME to return enough information to allow the user  program to perform the backtranslation itself, but that hsd problems  so it was removed.  The Genera equivalent of LOAD-LOGICAL-PATHNAME-TRANSLATIONS looks for  a file named SYS:SITE;hostname.TRANSLATIONS.  Current practice in Genera, Explorer, and Macintosh has one namespace for  both logical and physical namestrings.  This proposal allows an  implementation to choose to have one namespace or to have two separate  namespaces for namestrings.Cost to Implementors:  This is a fairly complex facility, but its performance is unimportant  so a straightforward implementation should suffice.  Most of the  complexity comes in dealing with unusual file systems, such as ones  that don't allow long file names.Cost to Users:  None.Cost of non-adoption:  Portable software construction and distribution will have to rely on  implementation-dependent kludges.  Lisp software will continue to be  difficult to install.Performance impact:  None.Benefits:  Avoid cost of non-adoption.Esthetics:  Improved portability of large programs.Discussion:  Issue PATHNAME-LOGICAL fundamentally depends on issue PATHNAME-WILD.  If  PATHNAME-WILD:NEW-FUNCTIONS does not pass, PATHNAME-LOGICAL cannot pass.  If PATHNAME-CANONICAL-TYPE:NEW-CONCEPT passes, it will affect the  behavior of the function TRANSLATE-PATHNAME and therefore the behavior of  the function TRANSLATE-LOGICAL-PATHNAME.  When a logical pathname  translation has from-wildcard and to-wildcard type components that are  :WILD or omitted, translation of the type will be guided by canonical  types.  If PATHNAME-CANONICAL-TYPE:NEW-CONCEPT fails to pass, it will  either have to be done behind the scenes by TRANSLATE-PATHNAME or users  will have to write more verbose translations that individually specify  the handling of each file type (as shown in some of the examples here).