*start*01119 00024 USfOriginator: @SAIL.STANFORD.EDU:RpK%acorn%LIVE-OAK.LCS.MIT.EDU%XX.LCS.MIT:EDU:XeroxDate:  3 Aug 87 11:17From: RpK%acorn%LIVE-OAK.LCS.MIT:EDU:XeroxSubject: Question on function type spec and lambda-list keywordsTo: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.STANFORD.EDU:RpK%acorn%LIVE-OAK.LCS.MIT.EDU@XX.LCS.MIT.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 03 AUG 87 11:17:14 PDTReceived: from XX.LCS.MIT.EDU by SAIL.STANFORD.EDU with TCP; 3 Aug 87  10:40:53 PDTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 3 Aug 87 13:40-EDTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 54193; 3 Aug 87 13:35:58-EDTOriginal-Date: Mon, 3 Aug 87 12:39 EDTMessage-ID: <870803123923.1.RPK@ACORN.Gold-Hill.DialNet.Symbolics.COM>Is the ftype of +  (function (&rest number) number)or  (function (&rest list) number)  ?I would assume the former (since &rest args are always of type list), butthere aren't any examples in CLtL that make this clear.*start*02060 00024 USfOriginator: SenderNameTooLong%SAIL.STANFORD:EDU:XeroxDate: 18 Aug 87 09:41From: mike%acorn%LIVE-OAK.LCS.MIT:EDU:XeroxSubject: Question on function type spec and lambda-list keywordsTo: RpK%acorn%LIVE-OAK.LCS.MIT:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.STANFORD.EDU:mike%acorn%LIVE-OAK.LCS.MIT.EDU@XX.LCS.MIT.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 18 AUG 87 09:41:57 PDTReceived: from XX.LCS.MIT.EDU by SAIL.STANFORD.EDU with TCP; 18 Aug 87  09:02:15 PDTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 18 Aug 87 12:02-EDTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 55991; 18 Aug 87 11:56:15-EDTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 78425; Tue 18-Aug-87 11:39:11-EDTOriginal-Date: Tue, 18 Aug 87 11:44 est    Date: Mon, 3 Aug 87 12:39 EDT    From: RpK%acorn@oak.lcs.mit.edu        Is the ftype of +          (function (&rest number) number)        or          (function (&rest list) number)          ?        I would assume the former (since &rest args are always of type list), but    there aren't any examples in CLtL that make this clear.    This seems a bit wierd, but I'd assume the latter, since(function (&rest (list-of number)) number)seems right.  Unfortunately, common lisp's type language doens'tallow parameterized types of this sort, so you can't really express this.Other programming languages allow this sort of type construction.You could do:(deftype list-of-number ()  `(satisfies list-of-number-p))(defun list-of-number-p (x)  (or (null x)      (and (consp x)           (numberp (car x))           (list-of-number-p (cdr x))))Then, (proclaim '(ftype + (function (&rest list-of-number) number)))since we're using "satisfies" here, I don't see how this couldbe useful tho. ...mike beckerleGold Hill      *start*07253 00024 USaDate: 20 Nov 87 13:26 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENTTo:  sandra%orion@cs.utah.educc: MasinterA reminder that you volunteered to write this issue up.   One question is whether the LIST type should be extended to include types of the form (LIST NUMBER). (This would have to be in the standard since users could not redefine the LIST type. ) If you discard that option, mention it in the discussion...Send the proposal to cl-cleanup@Sail.stanford.edu.JonL may have volunteered to help. Do you have his net address?  Format for proposals to the cleanup committee (Version 13)                    November 20, 1987Replace the text below in >> double inverted angle-brackets <<. Bebrief; leave testimonials and personal opinions to the discussion at theend. Be complete; do not expect someone else to fix or redesign parts.Spell out names (e.g., Masinter rather than LMM) and upper-case all Lispsymbols (DEFUN rather than Defun). I like it better if you write in thethird person rather than first.Issue:         >>A short descriptive label, which starts with a name               which occurs in the index of CLtL, and be a suitable               symbol in the Common Lisp style, e.g., CDR-TERMINATION.<<References:    >>The pages of CLtL which describe the feature being               discussed, and other references, including other               related issues.<<Category:      >>One or more of:               CLARIFICATION -- proposal to resolve an ambiguity or case               of under-specified situation in CLtL, where this               ambiguity interferes with portability of code.               CHANGE -- proposal for an incompatible change.               ADDITION -- proposal for a compatible extension<<Edit history:  >>Author and date of submission (version 1), and author               and date of subsequent versions.<<Problem description:>>Describe the problem being addressed -- why is the current situationunclear or unsatisfactory? Avoid describing the proposal here or arguingfor its adoption. <<Proposal (>>issue-label:proposal-label<<): >> Describe as precisely aspossible what you are proposing.  Ideally, this should take the form oftext that could be dropped into the new specification document.Proposals should be for changes to Common Lisp, rather than changes toCLtL.  If necessary, propose a set of labelled alternatives here, ratherthan a single proposal. Each proposal must be a complete design; do notleave out details.  Avoid arguing for the proposal here, just describeit.<<Test Cases/Examples:>> Examples are samples of Common Lisp code that illustrates the issue.along with explanatory text.Test Cases are simple stand-alone expressions which are valid anddo not signal an error if the proposal is adhered to. (Use ASSERTif you need.)<<Rationale:>> A one or two sentence summary of the arguments that follow. <<Current practice:>>Do some/many/no Common Lisp implementations already work this way?Survey independent Common Lisp implementations - preferably three ormore.<<Cost to Implementors:>>What is the cost to implementors of adopting the proposal?  How muchimplementation effort is required?  Is public-domain code available? Forpervasive changes, can the conversion be automated?<<Cost to Users:>>For incompatible changes, what is the cost to users of convertingexisting user code?  To what extent can the process be automated? How?<<Cost of non-adoption:>>How serious is it if nothing is done? <<Benefits:>>What is better if the proposal is adopted? How serious is the problemif just left as it is? <<Esthetics:>>How does this proposal affect the simplicity of the language, ease oflearning, etc. You can spell it aesthetics if you like. <<Discussion:>> Additional arguments, discussions, endorsements, testimonials, etc.should go here. A blow-by-blow account of debates is not necessary. <<     ----- Begin Forwarded Messages -----Originator: @SAIL.STANFORD.EDU:RpK%acorn%LIVE-OAK.LCS.MIT.EDU%XX.LCS.MIT:EDU:XeroxDate:  3 Aug 87 11:17From: RpK%acorn%LIVE-OAK.LCS.MIT:EDU:XeroxSubject: Question on function type spec and lambda-list keywordsTo: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.STANFORD.EDU:RpK%acorn%LIVE-OAK.LCS.MIT.EDU@XX.LCS.MIT.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 03 AUG 87 11:17:14 PDTReceived: from XX.LCS.MIT.EDU by SAIL.STANFORD.EDU with TCP; 3 Aug 87  10:40:53 PDTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 3 Aug 87 13:40-EDTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 54193; 3 Aug 87 13:35:58-EDTOriginal-Date: Mon, 3 Aug 87 12:39 EDTMessage-ID: <870803123923.1.RPK@ACORN.Gold-Hill.DialNet.Symbolics.COM>Is the ftype of +  (function (&rest number) number)or  (function (&rest list) number)  ?I would assume the former (since &rest args are always of type list), butthere aren't any examples in CLtL that make this clear.     ----- Next Message -----Originator: SenderNameTooLong%SAIL.STANFORD:EDU:XeroxDate: 18 Aug 87 09:41From: mike%acorn%LIVE-OAK.LCS.MIT:EDU:XeroxSubject: Question on function type spec and lambda-list keywordsTo: RpK%acorn%LIVE-OAK.LCS.MIT:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.STANFORD.EDU:mike%acorn%LIVE-OAK.LCS.MIT.EDU@XX.LCS.MIT.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 18 AUG 87 09:41:57 PDTReceived: from XX.LCS.MIT.EDU by SAIL.STANFORD.EDU with TCP; 18 Aug 87  09:02:15 PDTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 18 Aug 87 12:02-EDTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 55991; 18 Aug 87 11:56:15-EDTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 78425; Tue 18-Aug-87 11:39:11-EDTOriginal-Date: Tue, 18 Aug 87 11:44 est    Date: Mon, 3 Aug 87 12:39 EDT    From: RpK%acorn@oak.lcs.mit.edu        Is the ftype of +          (function (&rest number) number)        or          (function (&rest list) number)          ?        I would assume the former (since &rest args are always of type list), but    there aren't any examples in CLtL that make this clear.    This seems a bit wierd, but I'd assume the latter, since(function (&rest (list-of number)) number)seems right.  Unfortunately, common lisp's type language doens'tallow parameterized types of this sort, so you can't really express this.Other programming languages allow this sort of type construction.You could do:(deftype list-of-number ()  `(satisfies list-of-number-p))(defun list-of-number-p (x)  (or (null x)      (and (consp x)           (numberp (car x))           (list-of-number-p (cdr x))))Then, (proclaim '(ftype + (function (&rest list-of-number) number)))since we're using "satisfies" here, I don't see how this couldbe useful tho. ...mike beckerleGold Hill           ----- End Forwarded Messages -----*start*01871 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 01 DEC 87 08:48:42 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 291565; Tue 1-Dec-87 11:46:33 ESTDate: Tue, 1 Dec 87 11:46 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENTTo: Masinter.pacc: sandra%orion@cs.utah.edu, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871130-152931-1269@Xerox>Message-ID: <19871201164614.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 30 Nov 87 15:29 PST    From: Masinter.pa@Xerox.COM    Charniak, Riesbeck, McDermott and Meehan's "Artificial Intelligence Programming", says:    "Also as recommended in Steele, if &REST is given in a FUNCTION type form, the    type that follows &REST refers to the type of each argument that &REST collects,    not to the type of the &REST variable (which is always a list). The definition    of + might begin	(DEFUN + (&REST NUMBERS) ...)     Its type is	(FUNCTION (&REST NUMBER) NUMBER)."    Unfortunately, I've never found the place in CLtL where such a recommendation is    made. That's because there isn't one.  Note that the reference was to "Steele", notto CLtL.  It can be found in document X3J13 / 86-003, a many-times photocopied5 page document that is apparently entitled "A:>GLS>clarifications.text.4".A scribble on my copy says "be explicit about &optional, colons; remandedto declarations committee."  I suppose the declarations committee is one ofthose vapor committees that never produces anything?  This seems like areasonable thing for the Cleanup committee to address, expanded to coverall lambda-list keywords in FUNCTION type-specifiers, not just &REST.*start*01057 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 DEC 87 09:25:19 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 1 Dec 87  00:25:44 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 30 NOV 87 15:29:31 PSTDate: 30 Nov 87 15:29 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENTTo: sandra%orion@cs.utah.educc: cl-cleanup@Sail.stanford.eduMessage-ID: <871130-152931-1269@Xerox>Charniak, Riesbeck, McDermott and Meehan's "Artificial Intelligence Programming", says:"Also as recommended in Steele, if &REST is given in a FUNCTION type form, thetype that follows &REST refers to the type of each argument that &REST collects,not to the type of the &REST variable (which is always a list). The definitionof + might begin    (DEFUN + (&REST NUMBERS) ...) Its type is    (FUNCTION (&REST NUMBER) NUMBER)."Unfortunately, I've never found the place in CLtL where such a recommendation ismade. *start*06412 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 DEC 87 12:34:18 PSTReceived: from CS.UTAH.EDU by SAIL.STANFORD.EDU with TCP; 1 Dec 87  11:02:44 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA12488; Tue, 1 Dec 87 12:02:15 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA15709; Tue, 1 Dec 87 12:02:09 MSTDate: Tue, 1 Dec 87 12:02:09 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8712011902.AA15709@orion.utah.edu>Subject: Issue:  FUNCTION-TYPE-REST-LIST-ELEMENTTo: cl-cleanup@sail.stanford.eduIssue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p.47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra LoosemoreRelated issues: FUNCTION-TYPE-KEY-NAMEProblem description:The FUNCTION type specifier list is provided to allow declaration offunction argument types and return value types.  This type specifier uses asyntax similar to the usual lambda list syntax to specify which types gowith which lambda list variables.  However, this is actually of limitedusefulness in the context of a declaration, where one normally wants typeinformation about the actual arguments which can be passed to the functionrather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are alwaysbound to a value of type LIST.  For the sake of consistency, it would seemthat the corresponding type given in the FUNCTION declaration must also beLIST, but since this provides no information about the actual arguments,some users/implementors have instead adopted the convention of supplyingthe type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in thetype specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier providedwith &REST is the type of each actual argument, not the type of the corresponding lambda variable.Test Case:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter mustbe LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Many Common Lispimplementations currently ignore FUNCTION type declarations.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to doso.  Probably only a small amount of code would have to be written/changedin implementations that currently think that the type of the &REST parametermust be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter mustbe LIST will have to change their code.  However, because this issue is sounclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be oflimited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the languagedesign.Esthetics:Ugly.  Since the argument type syntax used by the FUNCTION type specifiermirrors normal lambda-list syntax, it is confusing to make the &REST typeto refer to the types of the actual arguments rather than the type of thematching lambda variable.Discussion:Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:EXTEND-LIST-TYPE):(1) Clarify that, in the FUNCTION type specifier, the type specifier providedwith &REST refers to the type of the corresponding lambda variable and mustbe LIST or a subtype of LIST.(2) Introduce a list form of the LIST type specifier, (LIST <type>), tospecify a list where the value of each successive CAR of the list is a member of type <type>.(3) Introduce a list form of the SEQUENCE type specifier, (SEQUENCE <type>),to specify a sequence where the value of each successive element is amember of type <type>.Test Case:The type of the function + would be specified as:(FUNCTION (&REST (LIST NUMBER)) NUMBER)Rationale:(1) It is clear that a &REST lambda variable must be bound to a list.Since the FUNCTION type syntax follows lambda-list syntax rather thanfunction call syntax, it is more consistent to make the type correspond tothe type of the lambda variable rather than that of the actual arguments.(2) Introducing a list LIST type specifier would allow the FUNCTION typespecifier to be more useful for its intended purpose.  It would also beuseful on its own.  For example, a compiler may be able to optimizecalls to functions such as MAPCAR that operate on successive elements ofa list if information is available about the type of items in the list.The motivation for making this part of the standard is that the syntaxof the LIST type cannot cannot be extended by user code.(3) This is an obvious extension of (2).Current practice:There does not appear to be any concensus on this issue.  Many Common Lispimplementations currently ignore FUNCTION type declarations.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue todo so.  It should be a fairly straightforward to implement the list forms of the LIST and SEQUENCE type specifiers.Cost to Users:Users who have been using the convention that the &REST type parameterspecifies the type of the actual arguments will have to change their code.However, because this issue is so unclear, the FUNCTION type specifier isprobably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be oflimited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the languagedesign.Esthetics:Since the argument type syntax used by the FUNCTION type specifier mirrorsnormal lambda-list syntax, it would be cleaner and less confusing to providethe type of the lambda variable rather than the type of the actual arguments.Discussion:-------*start*01535 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 DEC 87 19:42:42 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 2 Dec 87  19:41:22 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Wed 2 Dec 87 22:40:45-ESTDate: Wed, 2 Dec 87 22:40 ESTMessage-ID: <FAHLMAN.12355411187.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUCc: sandra%orion@CS.UTAH.EDUSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENTIn-reply-to: Msg of 1 Dec 1987  11:46-EST from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>Rather than introduce some godawful kludge for declaring the type of&rest lists (only), we should probably try to clean up the inadequaciesof the LIST data-type specification.  There should be some long-formdeclaration for LIST that allows you to declare the element-type andlength, similar to the declarations for vectors.We might or might not want to add a "true list" data type at the sametime.  A "true list" is finite in the CDR direction and terminates inNIL.  I can forsee some arguments about whether LIST in a declarationshould mean "true list", or whetehr we should give a new name to truelists.This is just a trial balloon -- if there is some enthusiasm for thisidea, I'll turn it into a real proposal.  If not, we can go back todiscussing kludges for indicating the element-type in an &REST list.-- Scott*start*02921 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 DEC 87 07:30:56 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 9 Dec 87  07:29:24 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Wed 9 Dec 87 10:28:51-ESTDate: Wed, 9 Dec 87 10:28 ESTMessage-ID: <FAHLMAN.12357112955.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-DECLARATION issuesIn-reply-to: Msg of 9 Dec 1987  05:59-EST from Masinter.pa at Xerox.COMSeems to me that we're trying to overload the type definition forFUNCTION in ways that are not altogether consistent.  I'd suggest thefollowing:1. Leave the FUNCTION type specifier alone.  It's not terribly useful inits non-restrictive form, but it is harmless and it does fit in with therest of the type system.  (Of course, we would make it a full-fledgedtype-specifier as discussed in the FUNCTION-TYPE proposal.)2. Add an extended form for the LIST type specifier so that one canindicate element type and, perhaps, length.  This can be used to saysomething useful about rest-args, without having to put in ugly specialsyntax for this.3. Add a new declaration/proclamation, distinct from TYPE, by whichusers can tell the compiler restrictive things about what a givenfunction will accept and what it will return.  This notation can be setup so that you can say things like "if all args are integer, the resultwill be" and "if the second arg is spaceship, the result will beMartian".  Obviously this bit will require some careful design so thatwe can make it maximally expressive and minimally confusing.  I don'thave a proposal ready; maybe Rob does.4. Let me toss in here a related idea by Dave Touretzky that I've beenwaiting to introduce whenever the time is right for a new batch ofissues: the RESTRICT declaration/proclamation.  Basically, (DECLARE(RESTRICT type1 type2)) says that, within the extent covered by thisdeclaration, anything that is of type1 is guaranteed to be of type2 aswell, where type2 is generally more restrictive.  One could say(RESTRICT NUMBER (INTEGER -1024 1024)), which tells the compiler thatany time it can prove something is a number, it can assume it is afixnum.  In some contexts, this can replace about six dozen THEforms.  Users find it very awkward to say things like(the (integer -1024 1024) (+ (the (integer -1024 1024) x)                             (the (integer -1024 1024) y))..yet often that is the only portable way to assure the compiler that itcan generate fixnum-only code on most machines.The reson I bring up RESTRICT at this time is that I think the functionrestriction mentioned in point 3 is related to this.  Maybe it should becalled RESTRICT-CALL or something.-- Scott*start*02666 00024 USmDate: 10 Dec 87 23:40 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-DECLARATION issuesIn-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Wed, 9 Dec 87 10:28 ESTTo: Fahlman@C.CS.CMU.EDUcc: MasinterI found myself disagreeing with most of your points. I thought maybe we should try working out some of them one-on-one. I do think we have some responsibility to remove useless features, even those that are harmless, while resisting adding new ones of dubious semantics and value."1. Leave the FUNCTION type specifier alone.  It's not terribly useful inits non-restrictive form, but it is harmless and it does fit in with therest of the type system.  (Of course, we would make it a full-fledgedtype-specifier as discussed in the FUNCTION-TYPE proposal.)"I'm turning 'not terribly useful' into 'useless'. I guess except as documentation, but the intent of the documentation is the restrictive form anyway, isn't it? "2. Add an extended form for the LIST type specifier so that one canindicate element type and, perhaps, length.  This can be used to saysomething useful about rest-args, without having to put in ugly specialsyntax for this."There's a problem in the interpretation of the type (LIST TYPE), in that it is different from (VECTOR TYPE), can't be tested in unit time (must go down the list, if you want to do TYPEP), can be dynamicly affected (by a (SETF (CAR ..) ..) etc. No other non-SATISFIES built-in type has this problem."3. Add a new declaration/proclamation, distinct from TYPE, by whichusers can tell the compiler restrictive things about what a givenfunction will accept and what it will return.  This notation can be setup so that you can say things like "if all args are integer, the resultwill be" and "if the second arg is spaceship, the result will beMartian".  Obviously this bit will require some careful design so thatwe can make it maximally expressive and minimally confusing.  I don'thave a proposal ready; maybe Rob does."If it isn't a TYPE you can't use DEFTYPE and you can't define things like BINARY-ARITHMETIC like you can now with DEFTYPE, etc. A whole new mechanism? "4. Let me toss in here a related idea by Dave Touretzky that I've beenwaiting to introduce whenever the time . . . . "This seems like something that ought to be tried out first. I think these kinds of global proclaimations affecting system types have the same sorts of problems that FLETing special forms do, e.g., (RESTRICT NUMBER (INTEGER -1024 1024))and yet under some WITH-OPEN-FILE there's an INCF that's incrementing the open-file-count which happens to exceed 1024.*start*01831 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Dec 87 09:24Subject: Re: Question about declarationIn-Reply-to: Your message of 11 Dec 87 11:01:00 -0500.             <[G.BBN.COM]11-Dec-87 11:01:23.NGALL>From: quiroz%cs.rochester:EDU:XeroxTo: common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 DEC 87 09:23:28 PSTReceived: from CS.ROCHESTER.EDU by SAIL.STANFORD.EDU with TCP; 11 Dec 87  08:50:51 PSTReceived: by cayuga.cs.rochester.edu (5.52/h) id AA24809; Fri, 11 Dec 87 11:50:29 ESTReceived: from loopback by furud.cs.rochester.edu (3.2/h) id AA00350; Fri, 11 Dec 87 11:50:24 ESTMessage-Id: <8712111650.AA00350@furud.cs.rochester.edu>Original-Date: Fri, 11 Dec 87 11:50:20 -0500| I think the type specifier for the function FOO is supposed to be| (PROCLAIM '(FUNCTION FOO (LIST) (VALUES &REST T))| This is because the type specifier following &REST is supposed to declare| the type of all the remaining arguments/values.  You won't find this in CLtL,| but I have it marked in my copy as a proposed clarification in Guy Steele's| list.The clarification would be most valuable.  As it stands now, I readyour declaration as saying `... and the type of the &REST argumentis T', when we probably want to say `... list of T', although thelatter cannot be uttered in the type calculus of Common Lisp.I remember there used to be a file ftpable from somewhere, whichcontained authoritative errata and clarifications.  Does it stillexist?=Cesar--------Cesar Augusto  Quiroz GonzalezDepartment of Computer Science     ...allegra!rochester!quirozUniversity of Rochester            orRochester,  NY 14627               quiroz@cs.rochester.edu*start*02375 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Dec 87 11:17From: mincy%Think:COM:XeroxSubject: 1Question about declaration0In-Reply-to: <19871211155410.7.RWK@WHITE-BIRD.SCRC.Symbolics.COM>To: RWK%yukon.scrc.symbolics:COM:Xerox, miller%cs.rochester:EDU:Xeroxcc: CL%acorn.cs.rochester:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Mincy <mincy@Think.COM>Subject: 1Question about declaration0To: RWK@yukon.scrc.symbolics.com, miller@cs.rochester.eduCc: CL@acorn.cs.rochester.eduIn-Reply-To: <19871211155410.7.RWK@WHITE-BIRD.SCRC.Symbolics.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 DEC 87 10:16:14 PSTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.STANFORD.EDU with TCP; 13 Dec 87  13:52:33 PSTReceived: from Think.COM (THINK.COM) by ACORN.CS.ROCHESTER.EDU via INTERNET with SMTP id 25807; 13 Dec 87 16:53:04 ESTReturn-Path: <mincy@Aquinas.Think.COM>Received: from sauron.think.com by Think.COM; Sun, 13 Dec 87 16:06:07 ESTReceived: from ZENO.THINK.COM by sauron.think.com; Sun, 13 Dec 87 16:06:01 ESTOriginal-Date: Sun, 13 Dec 87 16:07 ESTMessage-Id: <871213160754.1.MINCY@ZENO.THINK.COM>Character-Type-Mappings: (1 0 (NIL 0) (NIL :CONDENSED NIL) "CPTFONTC")Fonts: CPTFONT, CPTFONTCGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 11 Dec 87 10:54 EST    From: Robert W. Kerns <RWK@yukon.scrc.symbolics.com>	Date: Fri, 11 Dec 87 01:16 EST	From: Brad Miller <miller@ACORN.CS.ROCHESTER.EDU>       1How would you write a function declaration for the following?0       1(defun foo (bar)0	       1(declare (type list bar))0	       1(values-list bar)0       1(proclaim '(function foo (list) ????))0    I wouldn't.  CL doesn't have any syntax for declaring    a variable number of values, period.The &optional, &rest, and &key markers may appear in the value-type listfor the values type-specifier.  p 48, CLtL.The value-type for the function type-specifier may be a values type specifier.p 47 CLtLThereforeOne can say (function (number) (values number &optional float)), to specify that a function returns a variable number of values.But, It doesnt mean that anyone will listen to the declaration, just because you can say it.-jeff*start*01445 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 DEC 87 11:29:30 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 15 Dec 87  11:28:26 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 15 DEC 87 11:26:03 PSTDate: 15 Dec 87 11:26 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesIn-reply-to: sandra%orion@cs.utah.edu (Sandra J Loosemore)'s message of Tue, 15 Dec 87 11:45:06 MSTTo: sandra%orion@cs.utah.educc: cl-cleanup@sail.stanford.eduMessage-ID: <871215-112603-1532@Xerox>I apologize for sidetracking your original proposal with the related one ofwhether function argument declarations have semantics at all.  It did seem to methat deciding whether one writes (function + (&rest number) number)or(function + (&rest (list number)) number)might wait for some resolution of whether there is any conceivable utility,other than documentation, for making either declaration, lest the issue beemoot.However, we probably should  go forward with the discussion of the form of thedeclaration independent of its semantics, and separate out, say,FUNCTION-ARGUMENT-TYPE-SEMANTICS, from FUNCTION-TYPE-REST-LIST-ELEMENT.If there's no objection to doing so, I'll open up another issue name, andattempt to write up a FUNCTION-ARGUMENT-TYPE-SEMANTICS. *start*00890 00024 USaReturn-Path: <sandra%orion@cs.utah.edu>Received: from cs.utah.edu by Xerox.COM ; 15 DEC 87 10:50:36 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA18399; Tue, 15 Dec 87 11:45:11 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA02778; Tue, 15 Dec 87 11:45:06 MSTDate: Tue, 15 Dec 87 11:45:06 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8712151845.AA02778@orion.utah.edu>Subject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Masinter.paCc: cl-cleanup@sail.stanford.edu, sandra%orion@cs.utah.eduIn-Reply-To: Masinter.pa@Xerox.COM, 9 Dec 87 02:59 PSTI'm confused as to what the current status is here.  Should I revise myearlier proposals that deal primarily with syntax, or work on a new onethat tries to address the question of function declaration semantics aswell?-Sandra-------*start*01799 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 18:08:12 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 17 Dec 87  18:05:08 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 306504; Thu 17-Dec-87 21:05:03 ESTDate: Thu, 17 Dec 87 21:05 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-DECLARATION issuesTo: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12357112955.BABYL@C.CS.CMU.EDU>Message-ID: <19871218020501.4.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Wed, 9 Dec 1987  10:28 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    2. Add an extended form for the LIST type specifier so that one can    indicate element type and, perhaps, length.  This can be used to say    something useful about rest-args, without having to put in ugly special    syntax for this.I very strongly prefer having the thing after the &rest in a functiontype-specifier refer to each remaining argument, as Steele suggested twoyears ago, rather than having it refer to the value of the &rest parameter,as you seem to be assuming.  This is partly because I very strongly preferhaving the function type-specifier be a description of arguments ratherthan a description of parameters.Thus I prefer(function + (&rest number) number)over(function + (&rest (list number)) number)I really have no opinion on the other features being discussed in thisconversation, including the very existence of the list form of thefunction type-specifier.  All this stuff seems both overcomplicated anduseless to me, but that's not an informed opinion.*start*01746 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 DEC 87 18:26:06 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 17 Dec 87  18:22:55 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Thu 17 Dec 87 21:22:49-ESTDate: Thu, 17 Dec 87 21:22 ESTMessage-ID: <FAHLMAN.12359329156.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-DECLARATION issuesIn-reply-to: Msg of 17 Dec 1987  21:05-EST from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>    I very strongly prefer having the thing after the &rest in a function    type-specifier refer to each remaining argument, as Steele suggested two    years ago, rather than having it refer to the value of the &rest parameter,    as you seem to be assuming.  This is partly because I very strongly prefer    having the function type-specifier be a description of arguments rather    than a description of parameters.    Thus I prefer    (function + (&rest number) number)    over    (function + (&rest (list number)) number)Hmmm...I never thought about it this way.  If we look at the syntax youprefer as a special case for talking about the elements in the restlist, then this is a hideous kludge.  On the other hand, if we look atthis as a way of talking about the type of each of the rest arguments,then it has a certain elegance.  I wouldn't object, as long as it'sexplained this way.We may still want to adopt a better type specifier for LIST, but that isa separable issue.-- Scott*start*01288 00024 US Return-Path: <mike%acorn%LIVE-OAK.LCS.MIT.EDU.#Chaos@XX.LCS.MIT.EDU>Received: from XX.LCS.MIT.EDU by Xerox.COM ; 21 DEC 87 12:52:25 PSTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 21 Dec 87 15:46-ESTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 73279; 21 Dec 87 15:43:40-ESTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 90717; Mon 21-Dec-87 14:13:39-ESTDate: Mon, 21 Dec 87 14:20 estFrom: mike%acorn@LIVE-OAK.LCS.MIT.EDUTo: norvig%cogsci.Berkeley.EDU@ucbvax.Berkeley.EDU (Peter Norvig)Subject: Re: Current practice:argument types in function declarationsCc: masinter.pa    Date: Wed, 16 Dec 87 11:26:04 PST    From: norvig%cogsci.Berkeley.EDU@ucbvax.Berkeley.EDU (Peter Norvig)            Sure, you can define LIST-OF:        (deftype list-of (element-type)      `(and list (satisfies (lambda (l)     			   (every #'(lambda (x) (typep x ',element-type)) l)))))       CLtL explicitly forbids use of lambda expressions in the(satisfies ...) specifier. Pg 43. The reason given is to avoid scopingproblems. I think they should be allowed too, by the way....mike beckerle*start*02889 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  4 Jan 88 10:07:25 PST (Monday)Subject: Question about declarationFrom: mike%acorn%LIVE-OAK.LCS.MITTo: RWK%YUKON.SCRC.Symbolics:COMcc: mike%acorn%LIVE-OAK.LCS.MIT, miller%cs.rochester, CL%ACORN.CS.ROCHESTERReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 04 JAN 88 10:05:58 PSTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.STANFORD.EDU with TCP; 4 Jan 88  09:29:08 PSTReceived: from XX.LCS.MIT.EDU (XX.LCS.MIT.EDU) by ACORN.CS.ROCHESTER.EDU via INTERNET with SMTP id 27125; 4 Jan 88 12:29:22 ESTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 4 Jan 88 12:26-ESTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 74460; 4 Jan 88 12:25:54-ESTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 91173; Mon 4-Jan-88 11:20:45-ESTOriginal-Date: Mon, 4 Jan 88 11:27 est        Yes, but you haven't really declared those values, have you?    All you've done is declare that you can have a "list of them".        Now, if there was a "sequence-enumerated" type (as we have    in our UIMS), this would be a different matter.  I.e.    (function foo ((and list (sequence-enumerated                                       symbol integer symbol integer)))     	      (values &rest (and list (sequence-enumerated                                         symbol integer symbol integer))))        But what you'd *like* to know here is that the individual elements are     integers;    i.e.    (function foo ((list integer))    	      (values &rest (list integer)))        where the new argument to LIST does *NOT* work like ARRAY (meaning "a kind of    list specialized to contain only integers"), but rather means "a list whose    elements are all INTEGER's".        There is a big gap between being able to declare the existence of    a variable number of arguments or values and being able to declare    their type.    It is possible to define (deftype LIST-OF (ty) ...)  such that(function foo (&rest (list-of integer)) (values &rest (list-of fixnum)))) makes sense. This can't be done in the normal way withSATISFIES, but can be done by consing up a gensym and attaching thelist-of predicate to it. This is one of the uglier kludges in CommonLisp, since it is a workaround for the lack of parameterized types.The unresolved and truly ambiguous problem is whether &REST LIST meansthat the rest arg is a list (as usual) or that the elements of the&REST arg are lists. Another ambiguity is whether returning type T allows the returningof any number of values, i.e., is T > (values T T), orT > (values &rest T). ...mike beckerle*start*01237 00024 USaReturn-Path: <sandra%orion@cs.utah.edu>Received: from cs.utah.edu by Xerox.COM ; 15 JAN 88 07:45:02 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA06031; Fri, 15 Jan 88 08:43:14 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA11351; Fri, 15 Jan 88 08:43:09 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8801151543.AA11351@orion.utah.edu>Date: Fri, 15 Jan 88 08:43:07 MSTSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT, FUNCTION-DECLARATION issuesTo: Masinter.paIn-Reply-To: Masinter.pa@Xerox.COM, 14 Jan 88 20:33 PSTSorry about the delay.  I'll try to get around to these in the next day ortwo.I've actually got a couple of things to send out to the compilercommittee as well, but apparently Steve Haflich has never gotten themailing list set up.  (He said Real Soon Now the first time I asked, butmy last two messages about it have apparently dropped into a bottomlesshole.)  Should I send this stuff to the cleanup committee instead?  It'sa slightly revised version of my original proposal about compile-time effects of various top-level forms, and also a short manual (in LaTeXformat) for the simplified DEFSYSTEM I put together.-Sandra-------*start*07611 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 JAN 88 13:30:25 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 15 Jan 88  13:27:24 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA22350; Fri, 15 Jan 88 14:26:23 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA12191; Fri, 15 Jan 88 14:26:17 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8801152126.AA12191@orion.utah.edu>Date: Fri, 15 Jan 88 14:26:15 MSTSubject: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposalTo: cl-cleanup@sail.stanford.eduIssue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore	       Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)Related issues: FUNCTION-TYPE-KEY-NAMEProblem description:The FUNCTION type specifier list is provided to allow declaration offunction argument types and return value types.  This type specifier uses asyntax similar to the usual lambda list syntax to specify which types gowith which lambda list variables.  However, this is actually of limitedusefulness in the context of a declaration, where one normally wants typeinformation about the actual arguments which can be passed to the functionrather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are alwaysbound to a value of type LIST.  For the sake of consistency, it would seemthat the corresponding type given in the FUNCTION declaration must also beLIST, but since this provides no information about the actual arguments,some users/implementors have instead adopted the convention of supplyingthe type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in thetype specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier providedwith &REST is the type of each actual argument, not the type of the corresponding lambda variable.Test Case:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter mustbe LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Many Common Lispimplementations currently ignore FUNCTION type declarations.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to doso.  Probably only a small amount of code would have to be written/changedin implementations that currently think that the type of the &REST parametermust be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter mustbe LIST will have to change their code.  However, because this issue is sounclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be oflimited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the languagedesign.Esthetics:Ugly.  Since the argument type syntax used by the FUNCTION type specifiermirrors normal lambda-list syntax, it is confusing to make the &REST typeto refer to the types of the actual arguments rather than the type of thematching lambda variable.  Discussion:Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:EXTEND-LIST-TYPE):(1) Clarify that, in the FUNCTION type specifier, the type specifier providedwith &REST refers to the type of the corresponding lambda variable and mustbe LIST or a subtype of LIST.(2) Introduce a list form of the LIST type specifier, (LIST <type>).  Ifthe type is specified, then it indicates that the list is a true list(that is, finite and null-terminated), and that the value of eachsuccessive CAR of the list is a member of type <type>.Test Case:The type of the function + would be specified as:(FUNCTION (&REST (LIST NUMBER)) NUMBER)Rationale:(1) It is clear that a &REST lambda variable must be bound to a list.Since the FUNCTION type syntax follows lambda-list syntax rather thanfunction call syntax, it is more consistent to make the type correspond tothe type of the lambda variable rather than that of the actual arguments.(2) Introducing a list LIST type specifier would allow the FUNCTION typespecifier to be more useful for its intended purpose.  It would also beuseful on its own.  For example, a compiler may be able to optimizecalls to functions such as MAPCAR that operate on successive elements ofa list if information is available about the type of items in the list.The motivation for making this part of the standard is that the syntaxof the LIST type cannot cannot be extended by user code.  The motivationfor making (LIST <type>) specify a true list is that leaving the issueunresolved would probably introduce more problems than it solves; seealso the discussion under "esthetics" below.Current practice:There does not appear to be any concensus on this issue.  Many Common Lispimplementations currently ignore FUNCTION type declarations.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue todo so.  It should be a fairly straightforward to implement the list form of the LIST type specifiers.Cost to Users:Users who have been using the convention that the &REST type parameterspecifies the type of the actual arguments will have to change their code.However, because this issue is so unclear, the FUNCTION type specifier isprobably not used very much.Since there is no list form of the LIST type specifier defined now, addingit should not affect user code.  The semantics of the non-list form remainunchanged.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be oflimited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the languagedesign.Esthetics:Since the argument type syntax used by the FUNCTION type specifier mirrorsnormal lambda-list syntax, it would be cleaner and less confusing to providethe type of the lambda variable rather than the type of the actual arguments.On the issue of why (LIST <type>) should imply a true list, the notionof a list of <type> implies a certain bias or asymmetry in the liststructure: the CARs of each cons contain an element of type <type> andthe CDRs contain a link to the next cons.  Moreover, in mostapplications of the extended form of the LIST type specifier, one wouldalmost certainly want to use it to specify a true list.  (For example,CLtL routinely uses the term ``list'' to mean ``true list'', and statesthat it is an error to pass a dotted list to a function where thecorresponding argument is described as a list.)If there is a need to specify the component types of lists being used astrees, it would probably make more sense to define a list form of theCONS type specifier that allows the types of both the CAR and CDR to besupplied.Discussion:-------*start*01065 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 JAN 88 15:14:13 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 15 Jan 88  14:49:59 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 15 JAN 88 14:48:47 PSTDate: 15 Jan 88 14:48 PSTFrom: Masinter.paSubject: Re: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposalIn-reply-to: sandra%orion@cs.utah.edu (Sandra J Loosemore)'s message of Fri, 15 Jan 88 14:26:15 MSTTo: sandra%orion@cs.utah.educc: cl-cleanup@sail.stanford.eduMessage-ID: <880115-144847-6100@Xerox>I don't think we can release a proposal with two choices. This issue is notimportant enough for us to debate two choices before X3J13. I propose a majority vote of the individuals who care to vote in response tothis message. For the record, my vote is USE-ACTUAL-ARGUMENT-TYPE; the simplicity of thedeclarations and the ugliness of the alternative, as well as the weight ofcurrent practice, argue for it. *start*01370 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 JAN 88 15:18:20 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 15 Jan 88  15:15:52 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Fri 15 Jan 88 18:15:45-ESTDate: Fri, 15 Jan 88 18:15 ESTMessage-ID: <FAHLMAN.12366897279.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To:   sandra%orion@cs.utah.edu (Sandra J Loosemore)Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposalIn-reply-to: Msg of 15 Jan 1988  16:26-EST from sandra%orion at cs.utah.edu (Sandra J Loosemore)I think we should go with USE-ACTUAL-ARGUMENT-TYPE as the sole proposedoption.  Earlier I argued against this, but as I said in a previousmessage, I found Moon's arguments on this issue to be persuasive: we canconsider the types specified in the FUNCTION specifier to be the typesof the arguments rather than the types of the parameters as seen on thereceiving end.  In fact, given this shift in viewpoint, I no longerconsider this option to be ugly.  I'd change the comment in theaesthetics section from "Ugly." to "Some may consider this ugly." andpoint out the alternative way of looking at this.-- Scott*start*01370 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 JAN 88 17:41:24 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 15 Jan 88  15:15:52 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Fri 15 Jan 88 18:15:45-ESTDate: Fri, 15 Jan 88 18:15 ESTMessage-ID: <FAHLMAN.12366897279.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To:   sandra%orion@cs.utah.edu (Sandra J Loosemore)Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposalIn-reply-to: Msg of 15 Jan 1988  16:26-EST from sandra%orion at cs.utah.edu (Sandra J Loosemore)I think we should go with USE-ACTUAL-ARGUMENT-TYPE as the sole proposedoption.  Earlier I argued against this, but as I said in a previousmessage, I found Moon's arguments on this issue to be persuasive: we canconsider the types specified in the FUNCTION specifier to be the typesof the arguments rather than the types of the parameters as seen on thereceiving end.  In fact, given this shift in viewpoint, I no longerconsider this option to be ugly.  I'd change the comment in theaesthetics section from "Ugly." to "Some may consider this ugly." andpoint out the alternative way of looking at this.-- Scott*start*01065 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 JAN 88 17:41:27 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 15 Jan 88  14:49:59 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 15 JAN 88 14:48:47 PSTDate: 15 Jan 88 14:48 PSTFrom: Masinter.paSubject: Re: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposalIn-reply-to: sandra%orion@cs.utah.edu (Sandra J Loosemore)'s message of Fri, 15 Jan 88 14:26:15 MSTTo: sandra%orion@cs.utah.educc: cl-cleanup@sail.stanford.eduMessage-ID: <880115-144847-6100@Xerox>I don't think we can release a proposal with two choices. This issue is notimportant enough for us to debate two choices before X3J13. I propose a majority vote of the individuals who care to vote in response tothis message. For the record, my vote is USE-ACTUAL-ARGUMENT-TYPE; the simplicity of thedeclarations and the ugliness of the alternative, as well as the weight ofcurrent practice, argue for it. *start*01516 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 JAN 88 17:43:13 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 15 Jan 88  17:41:01 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA27567; Fri, 15 Jan 88 16:57:17 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA12554; Fri, 15 Jan 88 16:57:12 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8801152357.AA12554@orion.utah.edu>Date: Fri, 15 Jan 88 16:57:09 MSTSubject: Re: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposalTo: "Scott E. Fahlman" <Fahlman@c.cs.cmu.edu>Cc: cl-cleanup@sail.stanford.eduIn-Reply-To: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>, Fri, 15 Jan 1988  18:15 ESTAs I'm not on the cl-cleanup mailing list, I think I may have missed outon some of the discussion relating to FUNCTION declaration semantics.If there is now a concensus that FUNCTION declarations describe calls tothe function and not the function itself, I agree that theUSE-ACTUAL-ARGUMENT-TYPE option is not really as "ugly" as it would beotherwise, and it's certainly simpler than the alternative.  Perhaps someone who is actually on the cleanup committee should "adopt"this proposal at this point, and do whatever needs to be done to it toget it to the point where you all think it's ready to be voted on?  Ivolunteered to write it up, not make it into a life-long crusade....-Sandra-------*start*01098 00024 US Return-Path: <@multimax.ARPA:pierson@mist>Received: from multimax.ARPA by Xerox.COM ; 21 JAN 88 08:04:16 PSTReceived:  by multimax.ARPA (5.51/25-eef)	id AA24101; Thu, 21 Jan 88 11:02:59 ESTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA26178; Thu, 21 Jan 88 11:04:05 ESTMessage-Id: <8801211604.AA26178@mist.UUCP>To: Masinter.pa%Xerox.COM@multimax.ARPACc: sandra%orion%cs.utah.edu@multimax.ARPA, cl-cleanup%sail.stanford.edu@multimax.ARPASubject: Re: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposal In-Reply-To: Your message of 15 Jan 88 14:48:00 -0800.             <880115-144847-6100@Xerox> Date: Thu, 21 Jan 88 11:04:02 ESTFrom: Dan L. Pierson <pierson@mist.ARPA>My vote is for USE-ACTUAL-ARGUMENT-TYPE for &rest args in functionspecs.  It may or may not damage the pure aesthetics of the language,but, since the resulting code is easier to read and write, it seemslike an aesthetic improvement to me.I would like to see a separate proposal for a parameterized LIST typespecifier; I think that it would be useful outside function specs.*start*01231 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 FEB 88 07:59:34 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 3 Feb 88  07:56:51 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 334275; Tue 2-Feb-88 20:47:21 ESTDate: Tue, 2 Feb 88 20:47 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposal (Version 2)To: Sandra J Loosemore <sandra%orion@cs.utah.edu>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8801152126.AA12191@orion.utah.edu>,             <880115-144847-6100@Xerox>,             <8801152357.AA12554@orion.utah.edu>Message-ID: <19880203014708.7.MOON@EUPHRATES.SCRC.Symbolics.COM>I strongly favor FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE,for the same reasons that Masinter gave.    Date: Fri, 15 Jan 88 16:57:09 MST    From: sandra%orion@cs.utah.edu (Sandra J Loosemore)    I volunteered to write it up, not make it into a life-long crusade....I know very, very well how you feel. :-)*start*01305 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 FEB 88 09:03:10 PSTReceived: from VALLECITO.SCRC.Symbolics.COM (SCRC-VALLECITO.ARPA) by SAIL.Stanford.EDU with TCP; 8 Feb 88  09:01:27 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by VALLECITO.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 202361; Mon 8-Feb-88 12:01:38 ESTDate: Mon, 8 Feb 88 12:00 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposalTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: sandra%orion@cs.utah.edu, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880207150705.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19880208170043.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sun, 7 Feb 88 15:07 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    My preference is for EXTEND-LIST-TYPE because....Does this mean you have a solution in mind for the well-known problemswith the element-type argument to the ARRAY type specifier?  If so, I'dlike to hear it.  If not, I think you would be heading towards making theLIST and SEQUENCE type specifiers either have the same problem or beinconsistent with ARRAY.*start*01803 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 FEB 88 12:09:32 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Feb 88  12:07:19 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 338018; Sun 7-Feb-88 15:07:23 ESTDate: Sun, 7 Feb 88 15:07 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: New version of FUNCTION-TYPE-REST-LIST-ELEMENT proposalTo: sandra%orion@cs.utah.educc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8801152126.AA12191@orion.utah.edu>Message-ID: <880207150705.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>My preference is for EXTEND-LIST-TYPE because: * I'm afraid USE-ACTUAL-ARGUMENT-TYPE will get us into trouble somehow. * I find it bothersome that the same argument declarations which are   used internally in the function would not be be usable externally. * I think it's unfair to provide only this special-purpose way of   declaring a sequence type when in fact there are numerous other places   in the language where it might be useful to declare a sequence type.If we did go with USE-ACTUAL-ARGUMENT-TYPE, it should be stated explicitly(if it is not already in CLtL somewhere) that the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)since there will be no way to type-declare this. Even though this is anobscure case (that doesn't even work in some implementations), it's thesort of thing that makes me queasy about USE-ACTUAL-ARGUMENT-TYPE.I'm content to have the proposal presented as USE-ACTUAL-ARGUMENT-TYPEand I expect that will pass, but I want to be listed as dissenting.*start*05129 00024 US Date: 13 Feb 88 14:28 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 3)To: cl-cleanup@sail.stanford.educc: MasinterIssue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore	       Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)	       Version 3, 13-Feb-88 MasinterRelated issues: FUNCTION-TYPE-KEY-NAME, 	FUNCTION-ARGUMENT-TYPE-SEMANTICSProblem description:The FUNCTION type specifier list is provided to allow declaration offunction argument types and return value types.  This type specifier uses asyntax similar to the usual lambda list syntax to specify which types gowith which lambda list variables.  However, this is actually of limitedusefulness in the context of a declaration, where one normally wants typeinformation about the actual arguments which can be passed to the functionrather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are alwaysbound to a value of type LIST.  For the sake of consistency, it would seemthat the corresponding type given in the FUNCTION declaration must also beLIST, but since this provides no information about the actual arguments,some users/implementors have instead adopted the convention of supplyingthe type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in thetype specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier provided with &REST is the type of each actual argument, not the type of the corresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter must be LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lisp implementations currently ignore FUNCTION type declarations. The only examples found so far are in a text book on Common Lisp, which follows the proposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to do so.  Probably only a small amount of code would have to be written/changed in implementations that currently think that the  &REST argument should be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter must be LIST will have to change their code.  However, because this issue is so unclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be of limited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the language design.Esthetics:Debatable.  One the one hand, since the argument type syntax used by the FUNCTION type specifier mirrorsnormal lambda-list syntax, it would be cleaner and less confusing to provide the type of the lambda variable rather than the type of the actual arguments. However, considering the types specified in the FUNCTION specifier to be the types of the actual arguments rather than the types of the parameters as seen on the receiving end makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee. There was some support for an alternative proposal to require that the &REST argument declaration, if any, always be LIST or a subtype of LIST, and to extend the LIST type to allow declarations of the form, e.g., (LIST NUMBER). Those who favor USE-ACTUAL-ARGUMENT-TYPE (including David Moon and Larry Masinter) argue that the simplicity of the declarations and the ugliness of the alternative, as well as the weight of current practice, argue for it. Kent Pitman has argued against this proposal on the following grounds:* It is bothersome that the same argument declarations which are   used internally in the function would not be be usable externally. * It is unfair to provide only this special-purpose way of   declaring a sequence type when in fact there are numerous other places   in the language where it might be useful to declare a sequence type.If we did go with USE-ACTUAL-ARGUMENT-TYPE, it should be stated explicitly(if it is not already in CLtL somewhere) that the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)since there will be no way to type-declare this. Even though this is anobscure case (that doesn't even work in some implementations), it's thesort of thing that makes me queasy about USE-ACTUAL-ARGUMENT-TYPE.*start*05478 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 FEB 88 14:30:12 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Feb 88  14:28:00 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 13 FEB 88 14:28:43 PSTDate: 13 Feb 88 14:28 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 3)To: cl-cleanup@sail.stanford.educc: Masinter.paMessage-ID: <880213-142843-10387@Xerox>!Issue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore	       Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)	       Version 3, 13-Feb-88 MasinterRelated issues: FUNCTION-TYPE-KEY-NAME, 	FUNCTION-ARGUMENT-TYPE-SEMANTICSProblem description:The FUNCTION type specifier list is provided to allow declaration offunction argument types and return value types.  This type specifier uses asyntax similar to the usual lambda list syntax to specify which types gowith which lambda list variables.  However, this is actually of limitedusefulness in the context of a declaration, where one normally wants typeinformation about the actual arguments which can be passed to the functionrather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are alwaysbound to a value of type LIST.  For the sake of consistency, it would seemthat the corresponding type given in the FUNCTION declaration must also beLIST, but since this provides no information about the actual arguments,some users/implementors have instead adopted the convention of supplyingthe type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in thetype specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier provided with&REST is the type of each actual argument, not the type of the correspondinglambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter must beLIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lispimplementations currently ignore FUNCTION type declarations. The only examplesfound so far are in a text book on Common Lisp, which follows the proposedsyntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to do so.Probably only a small amount of code would have to be written/changed inimplementations that currently think that the  &REST argument should be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter must beLIST will have to change their code.  However, because this issue is so unclear,the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be of limiteduse for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the language design.Esthetics:Debatable.  One the one hand, since the argument type syntax used by theFUNCTION type specifier mirrorsnormal lambda-list syntax, it would be cleaner and less confusing to provide thetype of the lambda variable rather than the type of the actual arguments.However, considering the types specified in the FUNCTION specifier to be thetypes of the actual arguments rather than the types of the parameters as seen onthe receiving end makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee. There was somesupport for an alternative proposal to require that the &REST argumentdeclaration, if any, always be LIST or a subtype of LIST, and to extend the LISTtype to allow declarations of the form, e.g., (LIST NUMBER). Those who favor USE-ACTUAL-ARGUMENT-TYPE (including David Moon and LarryMasinter) argue that the simplicity of the declarations and the ugliness of thealternative, as well as the weight of current practie, argue for it. Kent Pitman has argued against this proposal on the following grounds:* It is bothersome that the same argument declarations which are   used internally in the function would not be be usable externally. * It is unfair to provide only this special-purpose way of   declaring a sequence type when in fact there are numerous other places   in the language where it might be useful to declare a sequence type.If we did go with USE-ACTUAL-ARGUMENT-TYPE, it should be stated explicitly(if it is not already in CLtL somewhere) that the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)since there will be no way to type-declare this. Even though this is anobscure case (that doesn't even work in some implementations), it's thesort of thing that makes me queasy about USE-ACTUAL-ARGUMENT-TYPE.*start*05615 00024 US Date: 14 Feb 88 12:29 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 3)To: X3J13@Sail.stanford.educc: Masinterreply-to: CL-CLEANUP@Sail.Stanford.EDUThis issue is new.Issue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 MasinterRelated issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-ARGUMENT-TYPE-SEMANTICSProblem description:The FUNCTION type specifier list is provided to allow declaration of function argument types and return value types.  This type specifier uses a syntax similar to the usual lambda list syntax to specify which types go with which lambda list variables.  However, this is actually of limited usefulness in the context of a declaration, where one normally wants type information about the actual arguments which can be passed to the function rather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are always bound to a value of type LIST.  For the sake of consistency, it would seem that the corresponding type given in the FUNCTION declaration must also be LIST, but since this provides no information about the actual arguments, some users/implementors have instead adopted the convention of supplying the type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in the type specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier provided with &REST is the type of each actual argument, not the type of the corresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter must be LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lisp implementations currently ignore FUNCTION type declarations. The only examples found so far are in a text book on Common Lisp, which follows the proposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to do so.  Probably only a small amount of code would have to be written/changed in implementations that currently think that the  &REST argument should be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter must be LIST will have to change their code.  However, because this issue is so unclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be of limited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the language design.Esthetics:Debatable.  One the one hand, since the argument type syntax used by the FUNCTION type specifier mirrorsnormal lambda-list syntax, it would be cleaner and less confusing to provide the type of the lambda variable rather than the type of the actual arguments. However, considering the types specified in the FUNCTION specifier to be the types of the actual arguments rather than the types of the parameters as seen on the receiving end makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee. There was some support for an alternative proposal to require that the &REST argument declaration, if any, always be LIST or a subtype of LIST, and to extend the LIST type to allow declarations of the form, e.g., (LIST NUMBER). Those who favor USE-ACTUAL-ARGUMENT-TYPE (including David Moon and Larry Masinter) argue that the simplicity of the declarations and the ugliness of the alternative, as well as the weight of current practice, argue for it. Kent Pitman has argued against this proposal on the following grounds:``* It is bothersome that the same argument declarations which are used internally in the function would not be be usable externally.``* It is unfair to provide only this special-purpose way of declaring a sequence type when in fact there are numerous other places in the language where it might be useful to declare a sequence type.``If we did go with USE-ACTUAL-ARGUMENT-TYPE, it should be stated explicitly (if it is not already in CLtL somewhere) that the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)since there will be no way to type-declare this. Even though this is an obscure case (that doesn't even work in some implementations), it's the sort of thing that makes me queasy about USE-ACTUAL-ARGUMENT-TYPE.''        TITAN 
         TITAN 
          
TIMESROMAN 
          
TIMESROMAN 
           h       d                                                                              L             0       E              	       V                                                                      o       
       S                          9      6 #z*start*02225 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 FEB 88 15:01:31 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 24 Feb 88  14:57:43 PSTReceived: by labrea.Stanford.EDU; Wed, 24 Feb 88 14:19:23 PSTReceived: from bhopal.lucid.com by edsel id AA22851g; Wed, 24 Feb 88 13:38:35 PSTReceived: by bhopal id AA01988g; Wed, 24 Feb 88 13:44:20 PSTDate: Wed, 24 Feb 88 13:44:20 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8802242144.AA01988@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: vanroggen%aitg.decnet@hudson.dec.com, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 23 Feb 88 17:12 EST <19880223221249.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: function-type-rest-list-elementre: Here's an interesting thought experiment that might shed some light on    what the FUNCTION declaration, and the &REST type specifier nested    within in, might be for.  Suppose you had an implementation ... [with]    lambda-list keyword &REST2, which is just like &REST except that the    value to which the parameter variable is bound is a stack-allocated    object of some implementation-dependent type, and the only legal    operations on it are LENGTH2, NTH2, DOLIST2, and APPLY2 (all just like    the standard functions with similar names except that they take one    of these funny objects as an argument where the standard functions    take a list).    The caller of a function doesn't need to know or care whether the    function accepts its arguments with &REST or with &REST2.  This "gedanken experiment" isn't hypothetical at all.  VAX/NIL, one ofthe predecessors of Common Lisp, actually had &RESTV and &RESTL in addition to &REST.   &RESTV guaranteed a stack-allocated VECTOR and,&RESTL guaranteed a heap-allocated list.  &REST was left ambiguous just so that the user couldn't know which of the two kinds of structureswas being worked upon, and thus couldn't depend upon any accidentalproperties.But at "flag day", few other CL participants saw any value to clutteringup &rest *lists*.-- JonL --*start*08273 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 29 FEB 88 14:01:11 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Feb 88  13:57:40 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 353104; Mon 29-Feb-88 16:54:04 ESTDate: Mon, 29 Feb 88 16:53 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: function-type-rest-list-elementTo: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>, Jon L White <edsel!jonl@labrea.Stanford.EDU>, Ram@C.CS.CMU.EDUcc: cl-cleanup <cl-cleanup@SAIL.STANFORD.EDU>In-Reply-To: The message of 24 Feb 88 09:06 EST from "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>,             <8802242144.AA01988@bhopal.lucid.com>,             <8802251719.AA05861@bhopal.lucid.com>,             <RAM.12378202550.BABYL@>Message-ID: <19880229215350.3.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 24 Feb 88 10:06:00 EDT    From: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>      From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>      But the analogy to VECTOR is false!  (VECTOR element-type) does not      mean a vector all of whose current elements are of type element-type.      Nor does it mean a vector constrained such that that all elements      that can be stored into it are of type element-type.  The ambiguous      language on CLtL p.47 might lead you to think that's what it means,      but CLtL p.45 makes it clear.  For declaration, (VECTOR element-type)      [via (ARRAY element-type (*))] means a one-dimensional array      of the most specialized type that is capable of holding objects of      type element-type.  Therefore, unless element-type is STRING-CHAR      or BIT, or a subtype of one of them, this guarantees exactly nothing      about the types of the elements of the vector.        Maybe the element-type argument to these type-specifiers should mean      something else, but that's what it means in Common Lisp as currently      defined.    The discussion of ARRAY type specifiers on p.45 is talking about the    permissible and expected representations of arrays, not of the possible    types of the elements of such arrays.  So what's on p.45 doesn't make    anything clear here.    What would you expect to be the type of the result of the following code:     (let ((a ...))       (declare (type (vector foo) a))       (aref a 3))I don't see anything in CLtL that addresses this question.    I believe that in every implementation, the result should be of type FOO,    for any type FOO.  What is discussed on p.45 says that A might not be of    type (VECTOR FOO).  But this is unrelated to the question of whether    the elements of the array have any particular type.    Setting an element of A to be something that's not of type FOO is    an error.  The representation might allow it, because the new value    might be (TYPEP x (ARRAY-ELEMENT-TYPE A)), but that doesn't make it    correct.  It's just a matter of whether the array happened to    remember the precise type it was created with.I agree that this is a reasonable approach.  I don't think CLtL saysthis, but I don't think it says anything that contradicts it, either.  Ithink this is not too relevant to my point that the (VECTOR FOO)type-specifier does not mean a vector all of whose elements are of typeFOO.  As you point out, it means that a portable program "should" (inCLtL "is an error" sense) assume that it can only store elements of typeFOO into that vector.  But I think your proposed meaning for (LIST FOO)was rather stronger.  Perhaps I should make my point a different way:I don't think that Common Lisp's current type system for compound typesis well enough specified for this kind of extension to work obviouslyand naturally without exposing problems.    I haven't read any clean-up mail, so if you've talked about this    issue and resolved it somehow, please tell me.It's been discussed periodically but I don't think it's ever come closeto resolution.  It's perhaps too large an issue for the Cleanup committee.    The problem here is in trying to use lambda-list syntax for describing    function calls.  Already there's a slight contortion by having the    actual keywords be included in the function type for &KEY arguments.    So it isn't quite as simple as just taking the real lambda-list,    deleting all the init forms and &AUXen, and replacing parameter names    with their types.  But I think this way of looking at how function    type specifiers are derived is easier than starting with just a    positional approach (i.e., the second arg, if supplied, has to be of    type X, etc.) and then modifying it to also convey number-of-args and    keyword information.  Thus one would prefer having the type specifier    for the &REST argument be the real type specifier for the &REST argument.I agree with you, up to the last sentence, which I can't understand.There isn't such a thing as an "&REST argument" in Common Lisp, unlessyou mean the last argument to APPLY.  If where you said "argument" youmeant "parameter", then I understand what you're saying but don't agreewith it.  One could equally well conclude from the preceding paragraphthat the type specifier for the &REST arguments (note the plural)should be the type specifier for each actual argument.  Since there isn'ta one to one correspondence of arguments to parameters in this one case,the analogy of function type specifiers to lambda-lists doesn't reallygive us any guidance.I'm being too long-winded here, since I don't even know what theseFUNCTION type specifiers are useful for, anyway.  My main reason forjumping in was to point out a possible misconception about how strongthe VECTOR type specifier is in current Common Lisp.    Date: Thu, 25 Feb 88 09:19:28 PST    From: Jon L White <edsel!jonl@labrea.Stanford.EDU>    re: The discussion of ARRAY type specifiers on p.45 is talking about the	permissible and expected representations of arrays, not of the possible	types of the elements of such arrays.  So what's on p.45 doesn't make	anything clear here.    Well, it's true that CLtL pp45-47 are anything but "clear".  But what    Dave is saying (I think) is that a number of wizards have groveled over     those pages and all agree that there is only one interpretation of them    consistent with the rest of CLtL.  And that interpretaton is at variance     with your comments:	Setting an element of A to be something that's not of type FOO is	an error.  The representation might allow it, because the new value	might be (TYPEP x (ARRAY-ELEMENT-TYPE A)), but that doesn't make it	correct.  It's just a matter of whether the array happened to	remember the precise type it was created with.    Perhaps the clearest indicator that CLtL really isn't saying this is    found on p291, under the description of ARRAY-ELEMENT-TYPE.  Note how    this section really is "clear" that an array made by	    (make-array 5 :element-type '(mod 5))    may legitimately have an element stored into it that is of type (mod 8)    but not necessarily of type (mod 5).Well, this is simply another way of stating the root problem here.  CLtLisn't sure whether its data types are portable, fairly abstract types orare ways to find out about implementation details.    Date: Sat, 27 Feb 1988  21:17 EST    From: Ram@C.CS.CMU.EDU    Well, I don't agree with VanRoggen's stand on the &rest type issue,    but I think he is pretty close to the mark about array types.  This    isn't inconsistent, since the desirability or feasilibility of a typed    list specifier is pretty unrelated to the &rest issue.Not really, since VanRoggen's proposal was to employ a typed listspecifier in the resolution of the &rest issue.By the way, I'm not arguing in favor of the way array types currentlyare defined, I'm just pointing out the facts.  If we're now going toredesign array types, I think that's a good idea, or at least aninteresting one, but I'll probably limit my contr*start*01781 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 FEB 88 11:36:37 PSTReceived: from hudson.dec.com by SAIL.Stanford.EDU with TCP; 23 Feb 88  11:14:22 PSTDate: 23 Feb 88 14:07:00 EDTFrom: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>Subject: function-type-rest-list-elementTo: "cl-cleanup" <cl-cleanup@sail.stanford.edu>cc: vanroggen@hudson.dec.com Reply-To: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>We oppose the proposal FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-LIST.We feel that although specifying the element type in a functiontype specifier is slightly more convenient, it is outweighed byits inconsistency and lack of expressiveness.If specifying the element type of lists is an important issue,and we think it is, then we should extend the LIST type to bea list type:  (LIST [<element-type> [<length>]])just like for VECTOR.  In fact, it would also be wise toextend SEQUENCE in the same way.VAX LISP has always made use of FUNCTION type specifiers, althoughit has ignored the &REST and &KEY type information.There's no reason why someone might not write a function typespecifier with &REST being a supertype of LIST.  It just can'tconflict with LIST.The statement in the discussion favoring USE-ACTUAL-ARGUMENT-TYPEreferring to ``the weight of current practice'' itself doesn't haveany weight when previous statements say that function type specifiersare in limited use and that most implementations ignore them--thereis no ``current practice''.We agree with Kent Pitman's first two comments (at the end of theDiscussion section), but don't understand his last one.			---Walter------*start*04054 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 FEB 88 14:17:23 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Feb 88  14:14:01 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 349602; Tue 23-Feb-88 17:13:00 ESTDate: Tue, 23 Feb 88 17:12 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: function-type-rest-list-elementTo: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: The message of 23 Feb 88 13:07 EST from "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>Message-ID: <19880223221249.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 23 Feb 88 14:07:00 EDT    From: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>    We oppose the proposal FUNCTION-TYPE-REST-LIST-ELEMENT:    USE-ACTUAL-ARGUMENT-LIST.    We feel that although specifying the element type in a function    type specifier is slightly more convenient, it is outweighed by    its inconsistency and lack of expressiveness.    If specifying the element type of lists is an important issue,    and we think it is, then we should extend the LIST type to be    a list type:      (LIST [<element-type> [<length>]])    just like for VECTOR.  In fact, it would also be wise to    extend SEQUENCE in the same way.But the analogy to VECTOR is false!  (VECTOR element-type) does notmean a vector all of whose current elements are of type element-type.Nor does it mean a vector constrained such that that all elementsthat can be stored into it are of type element-type.  The ambiguouslanguage on CLtL p.47 might lead you to think that's what it means,but CLtL p.45 makes it clear.  For declaration, (VECTOR element-type)[via (ARRAY element-type (*))] means a one-dimensional arrayof the most specialized type that is capable of holding objects oftype element-type.  Therefore, unless element-type is STRING-CHARor BIT, or a subtype of one of them, this guarantees exactly nothingabout the types of the elements of the vector.Maybe the element-type argument to these type-specifiers should meansomething else, but that's what it means in Common Lisp as currentlydefined.    VAX LISP has always made use of FUNCTION type specifiers, although    it has ignored the &REST and &KEY type information.    There's no reason why someone might not write a function type    specifier with &REST being a supertype of LIST.  It just can't    conflict with LIST.Yes, but I don't see what that could be useful for.Here's an interesting thought experiment that might shed some light onwhat the FUNCTION declaration, and the &REST type specifier nestedwithin in, might be for.  Suppose you had an implementation that thoughtmaterializing &REST arguments as lists was too inefficient, especiallyif you didn't bother to do the (fairly simple) flow analysis needed tofigure out that the list has dynamic extent and doesn't have to beconsed in the heap.  So in your implementation, you made a newlambda-list keyword &REST2, which is just like &REST except that thevalue to which the parameter variable is bound is a stack-allocatedobject of some implementation-dependent type, and the only legaloperations on it are LENGTH2, NTH2, DOLIST2, and APPLY2 (all just likethe standard functions with similar names except that they take oneof these funny objects as an argument where the standard functionstake a list).The caller of a function doesn't need to know or care whether thefunction accepts its arguments with &REST or with &REST2.  If theFUNCTION declaration is for the benefit of callers, then the FUNCTIONdeclaration should be independent of whether the callee is written with&REST or with &REST2.From this I conclude that the &REST type specifier nested within aFUNCTION declaration shouldn't say anything about lists.*start*05768 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 FEB 88 07:18:30 PSTReceived: from hudson.dec.com by SAIL.Stanford.EDU with TCP; 24 Feb 88  07:15:01 PSTDate: 24 Feb 88 10:06:00 EDTFrom: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>Subject: RE: function-type-rest-list-elementTo: "cl-cleanup" <cl-cleanup@sail.stanford.edu>cc: vanroggen@hudson.dec.com Reply-To: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>  From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>  But the analogy to VECTOR is false!  (VECTOR element-type) does not  mean a vector all of whose current elements are of type element-type.  Nor does it mean a vector constrained such that that all elements  that can be stored into it are of type element-type.  The ambiguous  language on CLtL p.47 might lead you to think that's what it means,  but CLtL p.45 makes it clear.  For declaration, (VECTOR element-type)  [via (ARRAY element-type (*))] means a one-dimensional array  of the most specialized type that is capable of holding objects of  type element-type.  Therefore, unless element-type is STRING-CHAR  or BIT, or a subtype of one of them, this guarantees exactly nothing  about the types of the elements of the vector.    Maybe the element-type argument to these type-specifiers should mean  something else, but that's what it means in Common Lisp as currently  defined.The discussion of ARRAY type specifiers on p.45 is talking about thepermissible and expected representations of arrays, not of the possibletypes of the elements of such arrays.  So what's on p.45 doesn't makeanything clear here.What would you expect to be the type of the result of the following code: (let ((a ...))   (declare (type (vector foo) a))   (aref a 3))I believe that in every implementation, the result should be of type FOO,for any type FOO.  What is discussed on p.45 says that A might not be oftype (VECTOR FOO).  But this is unrelated to the question of whetherthe elements of the array have any particular type.Setting an element of A to be something that's not of type FOO isan error.  The representation might allow it, because the new valuemight be (TYPEP x (ARRAY-ELEMENT-TYPE A)), but that doesn't make itcorrect.  It's just a matter of whether the array happened toremember the precise type it was created with.I haven't read any clean-up mail, so if you've talked about thisissue and resolved it somehow, please tell me.    There's no reason why someone might not write a function type    specifier with &REST being a supertype of LIST.  It just can't    conflict with LIST.  Yes, but I don't see what that could be useful for.I was just referring to the statement in the first paragraph of theDiscussion: "the &REST argument declaration, if any, always be LISTor a subtype of LIST..."  Here's an interesting thought experiment that might shed some light on  what the FUNCTION declaration, and the &REST type specifier nested  within in, might be for.  Suppose you had an implementation that thought  materializing &REST arguments as lists was too inefficient, especially  if you didn't bother to do the (fairly simple) flow analysis needed to  figure out that the list has dynamic extent and doesn't have to be  consed in the heap.  So in your implementation, you made a new  lambda-list keyword &REST2, which is just like &REST except that the  value to which the parameter variable is bound is a stack-allocated  object of some implementation-dependent type, and the only legal  operations on it are LENGTH2, NTH2, DOLIST2, and APPLY2 (all just like  the standard functions with similar names except that they take one  of these funny objects as an argument where the standard functions  take a list).    The caller of a function doesn't need to know or care whether the  function accepts its arguments with &REST or with &REST2.  If the  FUNCTION declaration is for the benefit of callers, then the FUNCTION  declaration should be independent of whether the callee is written with  &REST or with &REST2.    From this I conclude that the &REST type specifier nested within a  FUNCTION declaration shouldn't say anything about lists.One can't expect people to write function type specifiers in CommonLisp with knowledge about the particular implementation's lambda-list-keywords.  So I agree with you there.  But it's the only thing onecould write.Indeed, there might not be any relationship between the lambda-listin a function type specifier and the real lambda-list. (proclaim '(ftype (function (&key (:key1 integer :key2 string)) ...) f)) (defun f (&optional k1 v1 k2 v2) ...)should be OK if F is always called (F :KEY2 x) and the like.Presumably the reason for having lambda-list-keywords in function typespecifiers is to indicate the range of number of arguments permissible.The problem here is in trying to use lambda-list syntax for describingfunction calls.  Already there's a slight contortion by having theactual keywords be included in the function type for &KEY arguments.So it isn't quite as simple as just taking the real lambda-list,deleting all the init forms and &AUXen, and replacing parameter nameswith their types.  But I think this way of looking at how functiontype specifiers are derived is easier than starting with just apositional approach (i.e., the second arg, if supplied, has to be oftype X, etc.) and then modifying it to also convey number-of-args andkeyword information.  Thus one would prefer having the type specifierfor the &REST argument be the real type specifier for the &REST argument.			---Walter------*start*02678 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 FEB 88 10:48:48 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 25 Feb 88  10:46:56 PSTReceived: by labrea.Stanford.EDU; Thu, 25 Feb 88 10:08:28 PSTReceived: from bhopal.lucid.com by edsel id AA26191g; Thu, 25 Feb 88 09:13:40 PSTReceived: by bhopal id AA05861g; Thu, 25 Feb 88 09:19:28 PSTDate: Thu, 25 Feb 88 09:19:28 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8802251719.AA05861@bhopal.lucid.com>To: vanroggen%aitg.decnet@hudson.dec.comCc: Moon@stony-brook.scrc.symbolics.com, cl-cleanup@sail.stanford.eduIn-Reply-To: Walter van Roggen's message of Wed 24 Feb 88 10:06:00 EDTSubject: function-type-rest-list-elementre: The discussion of ARRAY type specifiers on p.45 is talking about the    permissible and expected representations of arrays, not of the possible    types of the elements of such arrays.  So what's on p.45 doesn't make    anything clear here.Well, it's true that CLtL pp45-47 are anything but "clear".  But whatDave is saying (I think) is that a number of wizards have groveled over those pages and all agree that there is only one interpretation of themconsistent with the rest of CLtL.  And that interpretaton is at variance with your comments:    Setting an element of A to be something that's not of type FOO is    an error.  The representation might allow it, because the new value    might be (TYPEP x (ARRAY-ELEMENT-TYPE A)), but that doesn't make it    correct.  It's just a matter of whether the array happened to    remember the precise type it was created with.Perhaps the clearest indicator that CLtL really isn't saying this isfound on p291, under the description of ARRAY-ELEMENT-TYPE.  Note howthis section really is "clear" that an array made by	(make-array 5 :element-type '(mod 5))may legitimately have an element stored into it that is of type (mod 8)but not necessarily of type (mod 5).There was a rather lengthy interchange on this whole topic (about twomonths ago?) on the Common-Lisp@SU-AI list.  One proposal was to requireimplementations to conform with your comments quoted above, but it certainly didn't seem to have unanimous approval.  Someone pointed outthat all current implementations do a form of element-type "upgrading" on at least some :element-type specifiers.  Try it in VAXLISP, for example,with (SIGNED-BYTE 5) instead of (MOD 5) and see what you get.If you don't have archives of that mail interchange, I'll can arrange to send you a copy personally.-- JonL --*start*03270 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 27 FEB 88 18:21:05 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 27 Feb 88  18:18:33 PSTReceived: ID <RAM@C.CS.CMU.EDU.#Internet>; Sat 27 Feb 88 21:17:29-ESTDate: Sat, 27 Feb 88 21:17 ESTMessage-ID: <RAM.12378202550.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: Jon L White <edsel!jonl@LABREA.STANFORD.EDU>Cc: cl-cleanup@SAIL.STANFORD.EDU, Moon@SCRC-STONY-BROOK.ARPA, vanroggen%aitg.decnet@HUDSON.DEC.COMSubject: function-type-rest-list-elementIn-reply-to: Msg of 25 Feb 1988  12:19-EST from Jon L White <edsel!jonl at labrea.Stanford.EDU>Well, I don't agree with VanRoggen's stand on the &rest type issue,but I think he is pretty close to the mark about array types.  Thisisn't inconsistent, since the desirability or feasilibility of a typedlist specifier is pretty unrelated to the &rest issue.    Date: Thursday, 25 February 1988  12:19-EST    From: Jon L White <edsel!jonl at labrea.Stanford.EDU>    To:   vanroggen%aitg.decnet at hudson.dec.com    [...]        Setting an element of A to be something that's not of type FOO is        an error.  The representation might allow it, because the new value        might be (TYPEP x (ARRAY-ELEMENT-TYPE A)), but that doesn't make it        correct.  It's just a matter of whether the array happened to        remember the precise type it was created with.    Perhaps the clearest indicator that CLtL really isn't saying this is    found on p291, under the description of ARRAY-ELEMENT-TYPE.  Note how    this section really is "clear" that an array made by    	(make-array 5 :element-type '(mod 5))    may legitimately have an element stored into it that is of type (mod 8)    but not necessarily of type (mod 5).No, this example doesn't make it clear.  If you make an array:element-type (mod 5), then it is an error to ever store anything inthat array that isn't (mod 5).  What the example make clear is thatimplementation has discretion to upgrade the element type.  Acorollary is that it has discretion to not upgrade the element type.Since a Common Lisp implementation is free to implement whateverspecialized array types it pleases, Common Lisp programs must assumethat every type potentially has an exact specialization.The only rationale under which one could store something not (mod 5)into that array would be that they could make the array, then callARRAY-ELEMENT-TYPE to find out that element types it can actuallyhold, and then store randomness into it.  I don't believe that this isa reasonable thing to do.This basically amounts to bogotifying the language in order to makeARRAY-ELEMENT-TYPE work.  This is a bad idea, since I think that thesemantics of ARRAY-ELEMENT-TYPE are just as seriously flawed as thesemantics of TYPE-OF. (which is another flame)It is much easier to give types a clean semantics in Common Lisp ifARRAY-ELEMENT-TYPE and TYPE-OF are ignored.  For example, withoutthese functions, there would be no way for users to even know that"array element type upgrading" exists.  (Assuming the array TYPEP"feature" mentioned in the manual is fixed.)  Rob*start*09745 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 29 FEB 88 14:01:11 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Feb 88  13:57:40 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 353104; Mon 29-Feb-88 16:54:04 ESTDate: Mon, 29 Feb 88 16:53 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: function-type-rest-list-elementTo: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>, Jon L White <edsel!jonl@labrea.Stanford.EDU>, Ram@C.CS.CMU.EDUcc: cl-cleanup <cl-cleanup@SAIL.STANFORD.EDU>In-Reply-To: The message of 24 Feb 88 09:06 EST from "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>,             <8802242144.AA01988@bhopal.lucid.com>,             <8802251719.AA05861@bhopal.lucid.com>,             <RAM.12378202550.BABYL@>Message-ID: <19880229215350.3.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 24 Feb 88 10:06:00 EDT    From: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>      From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>      But the analogy to VECTOR is false!  (VECTOR element-type) does not      mean a vector all of whose current elements are of type element-type.      Nor does it mean a vector constrained such that that all elements      that can be stored into it are of type element-type.  The ambiguous      language on CLtL p.47 might lead you to think that's what it means,      but CLtL p.45 makes it clear.  For declaration, (VECTOR element-type)      [via (ARRAY element-type (*))] means a one-dimensional array      of the most specialized type that is capable of holding objects of      type element-type.  Therefore, unless element-type is STRING-CHAR      or BIT, or a subtype of one of them, this guarantees exactly nothing      about the types of the elements of the vector.        Maybe the element-type argument to these type-specifiers should mean      something else, but that's what it means in Common Lisp as currently      defined.    The discussion of ARRAY type specifiers on p.45 is talking about the    permissible and expected representations of arrays, not of the possible    types of the elements of such arrays.  So what's on p.45 doesn't make    anything clear here.    What would you expect to be the type of the result of the following code:     (let ((a ...))       (declare (type (vector foo) a))       (aref a 3))I don't see anything in CLtL that addresses this question.    I believe that in every implementation, the result should be of type FOO,    for any type FOO.  What is discussed on p.45 says that A might not be of    type (VECTOR FOO).  But this is unrelated to the question of whether    the elements of the array have any particular type.    Setting an element of A to be something that's not of type FOO is    an error.  The representation might allow it, because the new value    might be (TYPEP x (ARRAY-ELEMENT-TYPE A)), but that doesn't make it    correct.  It's just a matter of whether the array happened to    remember the precise type it was created with.I agree that this is a reasonable approach.  I don't think CLtL saysthis, but I don't think it says anything that contradicts it, either.  Ithink this is not too relevant to my point that the (VECTOR FOO)type-specifier does not mean a vector all of whose elements are of typeFOO.  As you point out, it means that a portable program "should" (inCLtL "is an error" sense) assume that it can only store elements of typeFOO into that vector.  But I think your proposed meaning for (LIST FOO)was rather stronger.  Perhaps I should make my point a different way:I don't think that Common Lisp's current type system for compound typesis well enough specified for this kind of extension to work obviouslyand naturally without exposing problems.    I haven't read any clean-up mail, so if you've talked about this    issue and resolved it somehow, please tell me.It's been discussed periodically but I don't think it's ever come closeto resolution.  It's perhaps too large an issue for the Cleanup committee.    The problem here is in trying to use lambda-list syntax for describing    function calls.  Already there's a slight contortion by having the    actual keywords be included in the function type for &KEY arguments.    So it isn't quite as simple as just taking the real lambda-list,    deleting all the init forms and &AUXen, and replacing parameter names    with their types.  But I think this way of looking at how function    type specifiers are derived is easier than starting with just a    positional approach (i.e., the second arg, if supplied, has to be of    type X, etc.) and then modifying it to also convey number-of-args and    keyword information.  Thus one would prefer having the type specifier    for the &REST argument be the real type specifier for the &REST argument.I agree with you, up to the last sentence, which I can't understand.There isn't such a thing as an "&REST argument" in Common Lisp, unlessyou mean the last argument to APPLY.  If where you said "argument" youmeant "parameter", then I understand what you're saying but don't agreewith it.  One could equally well conclude from the preceding paragraphthat the type specifier for the &REST arguments (note the plural)should be the type specifier for each actual argument.  Since there isn'ta one to one correspondence of arguments to parameters in this one case,the analogy of function type specifiers to lambda-lists doesn't reallygive us any guidance.I'm being too long-winded here, since I don't even know what theseFUNCTION type specifiers are useful for, anyway.  My main reason forjumping in was to point out a possible misconception about how strongthe VECTOR type specifier is in current Common Lisp.    Date: Thu, 25 Feb 88 09:19:28 PST    From: Jon L White <edsel!jonl@labrea.Stanford.EDU>    re: The discussion of ARRAY type specifiers on p.45 is talking about the	permissible and expected representations of arrays, not of the possible	types of the elements of such arrays.  So what's on p.45 doesn't make	anything clear here.    Well, it's true that CLtL pp45-47 are anything but "clear".  But what    Dave is saying (I think) is that a number of wizards have groveled over     those pages and all agree that there is only one interpretation of them    consistent with the rest of CLtL.  And that interpretaton is at variance     with your comments:	Setting an element of A to be something that's not of type FOO is	an error.  The representation might allow it, because the new value	might be (TYPEP x (ARRAY-ELEMENT-TYPE A)), but that doesn't make it	correct.  It's just a matter of whether the array happened to	remember the precise type it was created with.    Perhaps the clearest indicator that CLtL really isn't saying this is    found on p291, under the description of ARRAY-ELEMENT-TYPE.  Note how    this section really is "clear" that an array made by	    (make-array 5 :element-type '(mod 5))    may legitimately have an element stored into it that is of type (mod 8)    but not necessarily of type (mod 5).Well, this is simply another way of stating the root problem here.  CLtLisn't sure whether its data types are portable, fairly abstract types orare ways to find out about implementation details.    Date: Sat, 27 Feb 1988  21:17 EST    From: Ram@C.CS.CMU.EDU    Well, I don't agree with VanRoggen's stand on the &rest type issue,    but I think he is pretty close to the mark about array types.  This    isn't inconsistent, since the desirability or feasilibility of a typed    list specifier is pretty unrelated to the &rest issue.Not really, since VanRoggen's proposal was to employ a typed listspecifier in the resolution of the &rest issue.By the way, I'm not arguing in favor of the way array types currentlyare defined, I'm just pointing out the facts.  If we're now going toredesign array types, I think that's a good idea, or at least aninteresting one, but I'll probably limit my contribution to pointing outthat it isn't easy, i.e. the obvious trivial fixes don't completelywork.    The only rationale under which one could store something not (mod 5)    into that array would be that they could make the array, then call    ARRAY-ELEMENT-TYPE to find out that element types it can actually    hold, and then store randomness into it.  I don't believe that this is    a reasonable thing to do.But someone else might believe that it is.  See my comment above thatCLtL isn't sure what the goal of the type system is.    This basically amounts to bogotifying the language in order to make    ARRAY-ELEMENT-TYPE work.  This is a bad idea, since I think that the    semantics of ARRAY-ELEMENT-TYPE are just as seriously flawed as the    semantics of TYPE-OF. (which is another flame)    It is much easier to give types a clean semantics in Common Lisp if    ARRAY-ELEMENT-TYPE and TYPE-OF are ignored.  For example, without    these functions, there would be no way for users to even know that    "array element type upgrading" exists.  (Assuming the array TYPEP    "feature" mentioned in the manual is fixed.)Yes, the semantics would be cleaner if there weren't compound objects,or if there weren't implementation dependencies.  No argument about that.I think removing those primitives from the language may be just sweepingthe problem under a rug, not solving it, though.  Admittedly that wouldbe in the tradition of Common Lisp.*start*02488 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 29 FEB 88 20:03:36 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 29 Feb 88  19:59:55 PSTReceived: by labrea.Stanford.EDU; Mon, 29 Feb 88 19:21:33 PSTReceived: from bhopal.lucid.com by edsel id AA04105g; Mon, 29 Feb 88 19:48:13 PSTReceived: by bhopal id AA04652g; Mon, 29 Feb 88 19:54:18 PSTDate: Mon, 29 Feb 88 19:54:18 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8803010354.AA04652@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.edu, vanroggen%aitg.decnet@hudson.dec.com, Ram@c.cs.cmu.eduIn-Reply-To: David A. Moon's message of Mon, 29 Feb 88 16:53 EST <19880229215350.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: function-type-rest-list-elementre:  . . . CLtL isn't sure whether its data types are portable, fairly     abstract types or are ways to find out about implementation details.Good point.  In that series of messages a couple of months ago (?) on this issue, there were basically two camps of opinions:  (1) array types should be completely portable -- hence the exact      equivalence class of the :element-type specifier must be "remembered"  (2) "Upgrading" is reasonable, albeit a source of non-portability akin to       the fixnum/bignum split;  to do otherwise isn't worth it.Both Rob and Walter are espousing position (1), and may not have fullynoticed that it isn't mandated by CLtL.  I myself forget the horribleintricacies of array types from time to time.  Worse yet, I waffle betweenpreferring (1) and (2) depending on the latest "arguments" for one orthe other.  To me, this indicates that an easy solution isn't at hand.While there seemed to be no clear consensus on saying that types "must be" portable, almost everyone agreed that the schizophrenia induced by CLtL p45 is a bad idea, and could easily be dropped.  This is the part that says "Types can therefore be used for two different purposes: declaration and discrimination. ...", and implies as a consquence that the result of:	(make-array <n> :element-type '<type-spec>)will probably not be of typep  (array <type-spec>).Not only is this very counterintuitive, but it really doesn't satisfyany need that I'm aware of.  At first blush, it might seem to be acorollary of "upgrading"; but it isn't at all.  -- JonL --*start*02771 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 MAR 88 10:12:30 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Mar 88  10:07:38 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 353704; Tue 1-Mar-88 13:07:13 ESTDate: Tue, 1 Mar 88 13:07 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: function-type-rest-list-elementTo: Jon L White <edsel!jonl@labrea.Stanford.EDU>cc: cl-cleanup@SAIL.STANFORD.EDU, vanroggen%aitg.decnet@hudson.dec.com, Ram@c.cs.cmu.eduIn-Reply-To: <8803010354.AA04652@bhopal.lucid.com>Message-ID: <19880301180711.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 29 Feb 88 19:54:18 PST    From: Jon L White <edsel!jonl@labrea.Stanford.EDU>    While there seemed to be no clear consensus on saying that types "must be"     portable, almost everyone agreed that the schizophrenia induced by CLtL p45     is a bad idea, and could easily be dropped.  This is the part that says     "Types can therefore be used for two different purposes: declaration and     discrimination. ...", and implies as a consquence that the result of:	    (make-array <n> :element-type '<type-spec>)    will probably not be of typep  (array <type-spec>).    Not only is this very counterintuitive, but it really doesn't satisfy    any need that I'm aware of.  At first blush, it might seem to be a    corollary of "upgrading"; but it isn't at all.I don't know why the declaration vs discrimination thing was done.  Theonly thing I can guess at is that the idea was that if (typep a '(arrayfoo)), then it's -guaranteed- that (typep (aref a n) 'foo) is true,because a is implemented with a representation that only holds objectsof type foo.  Before speculating further I should of course leaf throughCLtL to see if it already contains somewhere an explanation of why thedeclaration vs discrimination distinction was drawn.Offhand getting rid of this distinction into two kinds of types seemslike a good idea.  However, I'm a bit leery of changing things in thelanguage when I don't understand why they are there.  At first thought,removing the distinction seems like an upward-compatible change in thesense that all it does is make some types that currently have nomembers, in a particular implementation, have some members.  Howeverthere might be subtle incompatibilities with existing programs, sincethe subtype rules would be changed, and in a way that depends on whatarray representations a particular implementation has.  I don't claim tounderstand the implications right now.*start*03666 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 MAR 88 13:12:42 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 1 Mar 88  13:09:54 PSTReceived: ID <RAM@C.CS.CMU.EDU.#Internet>; Tue 1 Mar 88 16:08:28-ESTDate: Tue, 1 Mar 88 16:08 ESTMessage-ID: <RAM.12378932724.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: Jon L White <edsel!jonl@LABREA.STANFORD.EDU>Cc: cl-cleanup@SAIL.STANFORD.EDU, Moon@SCRC-STONY-BROOK.ARPA, vanroggen%aitg.decnet@HUDSON.DEC.COMSubject: function-type-rest-list-element (really array types)In-reply-to: Msg of 29 Feb 1988  22:54-EST from Jon L White <edsel!jonl at labrea.Stanford.EDU>    Date: Monday, 29 February 1988  22:54-EST    From: Jon L White <edsel!jonl at labrea.Stanford.EDU>    To:   Moon at stony-brook.scrc.symbolics.com    Re:   function-type-rest-list-element    re:  . . . CLtL isn't sure whether its data types are portable, fairly         abstract types or are ways to find out about implementation details.    Good point.  In that series of messages a couple of months ago (?) on this     issue, there were basically two camps of opinions:      (1) array types should be completely portable -- hence the exact          equivalence class of the :element-type specifier must be "remembered"      (2) "Upgrading" is reasonable, albeit a source of non-portability akin to           the fixnum/bignum split;  to do otherwise isn't worth it.    Both Rob and Walter are espousing position (1), and may not have fully    noticed that it isn't mandated by CLtL.Actually I'm not proposing 1, at least as I understand what you aresaying.  My idea is that TYPEP automatically "upgrade" its typeargument to the corresponding "implementation type", i.e. a typeactually supported by the implementation.  This basically amounts torequiring the programmer (as opposed to the array) the remember thearray element type, but in the absence of a hard semantics forARRAY-ELEMENT-TYPE/TYPE-OF, this is the same as requiring that arrays"remember their element-type".I think that analogies with the FIXNUM/INTEGER are flawed: FIXNUM hasis a precisely defined concept within the language:    `(integer ,most-negative-fixnum ,most-positive-fixnum)Given this definition, a Common Lisp program can have a portableunderstanding of what it means to be a FIXNUM.  For example, it isclear that    (typep most-negative-fixnum 'fixnum)is true in any Common Lisp implementation.With arrays, TYPEP is simply broken.  Unless you use one of thespecial element types, BIT, STRING-CHAR or T, TYPEP doesn't meananything on arrays.It seems to me that the FIXNUM issue is kind of like a resourcerestriction:    "This program will only run when a fixnum is at least 16 bits."is similar to    "This program will only run when you can have 1e6 element bit-vectors."In constrast, there is no way to characterize the set ofimplementations in which TYPEP will work on arrays.  In fact, thereprobably are no such implementations.    [...] almost everyone agreed that the schizophrenia induced by    CLtL p45 is a bad idea, and could easily be dropped.  This is the    part that says "Types can therefore be used for two different    purposes: declaration and discrimination. ...", and implies as a    consquence that the result of:    	(make-array <n> :element-type '<type-spec>)    will probably not be of typep  (array <type-spec>).    Not only is this very counterintuitive, but it really doesn't satisfy    any need that I'm aware of.Yes, I agree with this.  Rob*start*01888 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 MAR 88 14:49:22 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 1 Mar 88  14:45:22 PSTReceived: by labrea.Stanford.EDU; Tue, 1 Mar 88 14:07:04 PSTReceived: from bhopal.lucid.com by edsel id AA06877g; Tue, 1 Mar 88 13:59:18 PSTReceived: by bhopal id AA06724g; Tue, 1 Mar 88 14:05:25 PSTDate: Tue, 1 Mar 88 14:05:25 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8803012205.AA06724@bhopal.lucid.com>To: Ram@c.cs.cmu.eduCc: cl-cleanup@sail.stanford.edu, Moon@scrc-stony-brook.arpa, vanroggen%aitg.decnet@hudson.dec.comIn-Reply-To: Ram@C.CS.CMU.EDU's message of Tue, 1 Mar 1988  16:08 EST <RAM.12378932724.BABYL@>Subject: function-type-rest-list-element (really array types)re:  My idea is that TYPEP automatically "upgrade" its type    argument to the corresponding "implementation type", i.e. a type    actually supported by the implementation.  . . . There are two problems with respect to typep.  Consider arrays made by	(MAKE-ARRAY <n> :element-type '<foo>)then:  1.  (TYPEP <array> '(ARRAY <foo>))   frequently fails for such arrays        2.  (TYPEP (AREF <array> <n>) '<foo>) frequently fails for such arrays These are two separate problems, and as I read your comments about havingTYPEP do the "upgrading", I think they apply only to case (1), right?This may be another way of trying to say that	`(ARRAY FOO)is type equivalent to	`(ARRAY ,(upgrade array-element-type 'foo))re: I think that analogies with the FIXNUM/INTEGER are flawed: FIXNUM has    is a precisely defined concept within the language:        `(integer ,most-negative-fixnum ,most-positive-fixnum)See my comments in the previous note about a "pyrrhic success".-- JonL --*start*03421 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 26 Dec 87 20:03From: RWK%YUKON.SCRC.Symbolics:COM:XeroxSubject: Question about declarationIn-Reply-to: The message of 16 Dec 87 13:19 EST from mike%acorn@oak.lcs.mit.eduTo: mike%acorn%LIVE-OAK.LCS.MIT:EDU:Xeroxcc: RWK%YUKON.SCRC.Symbolics:COM:Xerox, miller%cs.rochester:EDU:Xerox, CL%ACORN.CS.ROCHESTER:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Subject: Question about declarationTo: mike%acorn@LIVE-OAK.LCS.MIT.EDUCc: RWK@YUKON.SCRC.Symbolics.COM, miller@cs.rochester.edu, CL@ACORN.CS.ROCHESTER.EDUIn-Reply-To: The message of 16 Dec 87 13:19 EST from mike%acorn@oak.lcs.mit.eduReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 DEC 87 20:05:00 PSTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.STANFORD.EDU with TCP; 26 Dec 87  19:33:48 PSTReceived: from cayuga.cs.rochester.edu (CS.ROCHESTER.EDU) by ACORN.CS.ROCHESTER.EDU via INTERNET with SMTP id 26527; 26 Dec 87 22:34:12 ESTReceived: by cayuga.cs.rochester.edu (5.52/h) id AA17008; Sat, 26 Dec 87 22:32:26 ESTReceived: from WHITE-BIRD.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 311778; Sat 26-Dec-87 17:46:14 ESTOriginal-Date: Sat, 26 Dec 87 22:32 ESTMessage-Id: <19871227033217.8.RWK@WHITE-BIRD.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Wed, 16 Dec 87 13:19 est    From: mike%acorn@oak.lcs.mit.edu	Date: Fri, 11 Dec 87 10:54 EST	From: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>    	    Date: Fri, 11 Dec 87 01:16 EST	    From: Brad Miller <miller@ACORN.CS.ROCHESTER.EDU>    	    How would you write a function declaration for the following?    	    (defun foo (bar)		(declare (type list bar))		(values-list bar)    	    (proclaim '(function foo (list) ????))    	I wouldn't.  CL doesn't have any syntax for declaring	a variable number of values, period.        I think you can do this in CL:    (function foo (list) (values &rest list))    see CLtL pg 48 under the values type specifier. The explaination for    this "feature" is motivated by multiple-value-call.Yes, but you haven't really declared those values, have you?All you've done is declare that you can have a "list of them".Now, if there was a "sequence-enumerated" type (as we havein our UIMS), this would be a different matter.  I.e.(function foo ((and list (sequence-enumerated symbol integer symbol integer)))	      (values &rest (and list (sequence-enumerated symbol integer symbol integer))))    So presumably with this declaration, you can do    (multiple-value-call '+ (foo 1 2 3))    and get some kind of optimized call since it knows it's getting back    a variable number of values when FOO returns.    ...mike beckerle    But what you'd *like* to know here is that the individual elements are integers;i.e.(function foo ((list integer))	      (values &rest (list integer)))where the new argument to LIST does *NOT* work like ARRAY (meaning "a kind oflist specialized to contain only integers"), but rather means "a list whoseelements are all INTEGER's".There is a big gap between being able to declare the existence ofa variable number of arguments or values and being able to declaretheir type.*start*05615 00024 USmDate: 14 Feb 88 12:29 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 3)To: X3J13@Sail.stanford.educc: Masinterreply-to: CL-CLEANUP@Sail.Stanford.EDUThis issue is new.Issue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 MasinterRelated issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-ARGUMENT-TYPE-SEMANTICSProblem description:The FUNCTION type specifier list is provided to allow declaration of function argument types and return value types.  This type specifier uses a syntax similar to the usual lambda list syntax to specify which types go with which lambda list variables.  However, this is actually of limited usefulness in the context of a declaration, where one normally wants type information about the actual arguments which can be passed to the function rather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are always bound to a value of type LIST.  For the sake of consistency, it would seem that the corresponding type given in the FUNCTION declaration must also be LIST, but since this provides no information about the actual arguments, some users/implementors have instead adopted the convention of supplying the type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in the type specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier provided with &REST is the type of each actual argument, not the type of the corresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter must be LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lisp implementations currently ignore FUNCTION type declarations. The only examples found so far are in a text book on Common Lisp, which follows the proposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to do so.  Probably only a small amount of code would have to be written/changed in implementations that currently think that the  &REST argument should be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter must be LIST will have to change their code.  However, because this issue is so unclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be of limited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the language design.Esthetics:Debatable.  One the one hand, since the argument type syntax used by the FUNCTION type specifier mirrorsnormal lambda-list syntax, it would be cleaner and less confusing to provide the type of the lambda variable rather than the type of the actual arguments. However, considering the types specified in the FUNCTION specifier to be the types of the actual arguments rather than the types of the parameters as seen on the receiving end makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee. There was some support for an alternative proposal to require that the &REST argument declaration, if any, always be LIST or a subtype of LIST, and to extend the LIST type to allow declarations of the form, e.g., (LIST NUMBER). Those who favor USE-ACTUAL-ARGUMENT-TYPE (including David Moon and Larry Masinter) argue that the simplicity of the declarations and the ugliness of the alternative, as well as the weight of current practice, argue for it. Kent Pitman has argued against this proposal on the following grounds:``* It is bothersome that the same argument declarations which are used internally in the function would not be be usable externally.``* It is unfair to provide only this special-purpose way of declaring a sequence type when in fact there are numerous other places in the language where it might be useful to declare a sequence type.``If we did go with USE-ACTUAL-ARGUMENT-TYPE, it should be stated explicitly (if it is not already in CLtL somewhere) that the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)since there will be no way to type-declare this. Even though this is an obscure case (that doesn't even work in some implementations), it's the sort of thing that makes me queasy about USE-ACTUAL-ARGUMENT-TYPE.''        TITAN 
         TITAN 
          
TIMESROMAN 
          
TIMESROMAN 
           h       d                                                                              L             0       E              	       V                                                                      o       
       S                          9      6 #z*start*00778 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 JUN 88 16:16:13 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Jun 88  16:13:56 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 07 JUN 88 16:11:01 PDTDate: 7 Jun 88 16:04 PDTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 3)In-reply-to: Masinter.pa's message of 14 Feb 88 12:29 PSTTo: CL-CLEANUP@Sail.Stanford.EDUcc: Masinter.paMessage-ID: <880607-161101-1303@Xerox>My records about this issue are unclear, and I can't figure it out from theminutes of the last meeting. What happened with this one? Was it passed?Rejected? Tabled?I'll bring it again...*start*06049 00024 USfDate:  2 Oct 88 16:16 PDTFrom: masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 4)To:  CL-CLEANUP@Sail.Stanford.EDUcc: masinterThis issue was apparently argued at the last two meetings. I don't think it is very important. People are hung up in the LIST-TYPE-SPECIFIER issue, and I think I should this should be voted on second, after we get done with LIST-TYPE-SPECIFIER. (I'll make sure LIST-TYPE-SPECIFIER includes a forward reference.)Issue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 Masinter               Version 4,  2-Oct-88 Masinter (update references, discussion)Related issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS                REST-LIST-ALLOCATIONProblem description:The FUNCTION type specifier list is provided to allow declaration of function argument types and return value types.  This type specifier uses a syntax similar to the usual lambda list syntax to specify which types go with which lambda list variables.  However, this is actually of limited usefulness in the context of a declaration, where one normally wants type information about the actual arguments which can be passed to the function rather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are always bound to a value of type LIST.  For the sake of consistency, it would seem that the corresponding type given in the FUNCTION declaration must also be LIST, but since this provides no information about the actual arguments, some users/implementors have instead adopted the convention of supplying the type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in the type specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier provided with &REST is the type of each actual argument, not the type of the corresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter must be LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lisp implementations currently ignore FUNCTION type declarations. The only examples found so far are in a text book on Common Lisp, which follows the proposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to do so.  Probably only a small amount of code would have to be written/changed in implementations that currently think that the  &REST argument should be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter must be LIST will have to change their code.  However, because this issue is so unclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be of limited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the language design.Esthetics:Debatable.  One the one hand, since the argument type syntax used by the FUNCTION type specifier mirrors normal lambda-list syntax, it would be cleaner and less confusing to provide the type of the lambda variable rather than the type of the actual arguments. However, considering the types specified in the FUNCTION specifier to be the types of the actual arguments rather than the types of the parameters as seen on the receiving end makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee and at X3J13. It seems like a vote on LIST-TYPE-SPECIFIER would help clarify some of the issues; if there is a LIST type specifier, there would be more support for the alternative proposal to require that the &REST argument declaration, if any, always be LIST or a subtype of LIST, and to extend the LIST type to allow declarations of the form, e.g., (LIST NUMBER). Those who favor USE-ACTUAL-ARGUMENT-TYPE argue that the simplicity of the declarations and the ugliness of the alternative, as well as the weight of current practice, argue for it. Kent Pitman has argued against this proposal on the following grounds:``* It is bothersome that the same argument declarations which are used internally in the function would not be be usable externally.``* It is unfair to provide only this special-purpose way of declaring a sequence type when in fact there are numerous other places in the language where it might be useful to declare a sequence type.``If we did go with USE-ACTUAL-ARGUMENT-TYPE, it should be stated explicitly (if it is not already in CLtL somewhere) that the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)since there will be no way to type-declare this. Even though this is an obscure case (that doesn't even work in some implementations), it's the sort of thing that makes me queasy about USE-ACTUAL-ARGUMENT-TYPE.''        TITAN 
          TITAN 
         
TIMESROMAN 
                                                                                v             0       E              	       V                                                                      o       
       S                                 !z*start*05786 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 22:05:27 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Oct 88  21:50:36 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 06 OCT 88 21:47:56 PDTDate: 6 Oct 88 21:48 PDTFrom: masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 4)To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881006-214756-2172@Xerox>Version 2 was distributed at a previous X3J13 meeting.!Issue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 Masinter               Version 4,  2-Oct-88 Masinter (update references, discussion)Related issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS                REST-LIST-ALLOCATIONProblem description:The FUNCTION type specifier list is provided to allow declaration of function argument types and return value types.  This type specifier uses a syntax similar to the usual lambda list syntax to specify which types go with which lambda list variables.  However, this is actually of limited usefulness in the context of a declaration, where one normally wants type information about the actual arguments which can be passed to the function rather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are always bound to a value of type LIST.  For the sake of consistency, it would seem that the corresponding type given in the FUNCTION declaration must also be LIST, but since this provides no information about the actual arguments, some users/implementors have instead adopted the convention of supplying the type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in the type specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier provided with &REST is the type of each actual argument, not the type of the corresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter must be LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lisp implementations currently ignore FUNCTION type declarations. The only examples found so far are in a text book on Common Lisp, which follows the proposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to do so.  Probably only a small amount of code would have to be written/changed in implementations that currently think that the  &REST argument should be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter must be LIST will have to change their code.  However, because this issue is so unclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be of limited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the language design.Esthetics:Debatable.  One the one hand, since the argument type syntax used by the FUNCTION type specifier mirrors normal lambda-list syntax, it would be cleaner and less confusing to provide the type of the lambda variable rather than the type of the actual arguments. However, considering the types specified in the FUNCTION specifier to be the types of the actual arguments rather than the types of the parameters as seen on the receiving end makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee and at X3J13. It seems like a vote on LIST-TYPE-SPECIFIER would help clarify some of the issues; if there is a LIST type specifier, there would be more support for the alternative proposal to require that the &REST argument declaration, if any, always be LIST or a subtype of LIST, and to extend the LIST type to allow declarations of the form, e.g., (LIST NUMBER). Those who favor USE-ACTUAL-ARGUMENT-TYPE argue that the simplicity of the declarations and the ugliness of the alternative, as well as the weight of current practice, argue for it. Kent Pitman has argued against this proposal on the following grounds:``* It is bothersome that the same argument declarations which are used internally in the function would not be be usable externally.``* It is unfair to provide only this special-purpose way of declaring a sequence type when in fact there are numerous other places in the language where it might be useful to declare a sequence type.``If we did go with USE-ACTUAL-ARGUMENT-TYPE, it should be stated explicitly (if it is not already in CLtL somewhere) that the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)since there will be no way to type-declare this. Even though this is an obscure case (that doesn't even work in some implementations), it's the sort of thing that makes me queasy about USE-ACTUAL-ARGUMENT-TYPE.''*start*05874 00024 USfDate:  6 Oct 88 21:48 PDTFrom: masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 4)To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterVersion 2 was distributed at a previous X3J13 meeting.Issue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 Masinter               Version 4,  2-Oct-88 Masinter (update references, discussion)Related issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS                REST-LIST-ALLOCATIONProblem description:The FUNCTION type specifier list is provided to allow declaration of function argument types and return value types.  This type specifier uses a syntax similar to the usual lambda list syntax to specify which types go with which lambda list variables.  However, this is actually of limited usefulness in the context of a declaration, where one normally wants type information about the actual arguments which can be passed to the function rather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are always bound to a value of type LIST.  For the sake of consistency, it would seem that the corresponding type given in the FUNCTION declaration must also be LIST, but since this provides no information about the actual arguments, some users/implementors have instead adopted the convention of supplying the type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in the type specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier provided with &REST is the type of each actual argument, not the type of the corresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter must be LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lisp implementations currently ignore FUNCTION type declarations. The only examples found so far are in a text book on Common Lisp, which follows the proposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to do so.  Probably only a small amount of code would have to be written/changed in implementations that currently think that the  &REST argument should be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter must be LIST will have to change their code.  However, because this issue is so unclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be of limited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the language design.Esthetics:Debatable.  One the one hand, since the argument type syntax used by the FUNCTION type specifier mirrors normal lambda-list syntax, it would be cleaner and less confusing to provide the type of the lambda variable rather than the type of the actual arguments. However, considering the types specified in the FUNCTION specifier to be the types of the actual arguments rather than the types of the parameters as seen on the receiving end makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee and at X3J13. It seems like a vote on LIST-TYPE-SPECIFIER would help clarify some of the issues; if there is a LIST type specifier, there would be more support for the alternative proposal to require that the &REST argument declaration, if any, always be LIST or a subtype of LIST, and to extend the LIST type to allow declarations of the form, e.g., (LIST NUMBER). Those who favor USE-ACTUAL-ARGUMENT-TYPE argue that the simplicity of the declarations and the ugliness of the alternative, as well as the weight of current practice, argue for it. Kent Pitman has argued against this proposal on the following grounds:``* It is bothersome that the same argument declarations which are used internally in the function would not be be usable externally.``* It is unfair to provide only this special-purpose way of declaring a sequence type when in fact there are numerous other places in the language where it might be useful to declare a sequence type.``If we did go with USE-ACTUAL-ARGUMENT-TYPE, it should be stated explicitly (if it is not already in CLtL somewhere) that the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)since there will be no way to type-declare this. Even though this is an obscure case (that doesn't even work in some implementations), it's the sort of thing that makes me queasy about USE-ACTUAL-ARGUMENT-TYPE.''        TITAN 
          TITAN 
         
TIMESROMAN 
          TITAN 
           h       ^       ;                                                                      v             0       E              	       V                                                                      o       
       S                                > #z*start*01038 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:50:20 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:50:03 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 475960; 13 Oct 88 17:48:26 EDTDate: Thu, 13 Oct 88 17:48 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013174817.9.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...X3J13 meeting: RWK objects. Wants to see LIST-TYPE-SPECIFIER fleshed out. He was particularly interested in being able to type-declare things like &REST {keyword integer}*, but we realized later that the LIST-TYPE-SPECIFIER issue doesn't even pretend to get involved in repetition issues. Hmm...*start*05502 00024 US Date: 14 Nov 88 14:35 PSTFrom: masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 5)To: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterI attempted to shorten the discussion section while at the same time be more explicit that there were some serious objections to it. I wound up cutting a lot of it out. Do you think I should put it back in?Issue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 Masinter               Version 4,  2-Oct-88 Masinter (update references, discussion)               Version 5, 14-Nov-88 Masinter (add to discussion)Related issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS                REST-LIST-ALLOCATIONProblem description:The FUNCTION type specifier list is provided to allow declaration of function argument types and return value types.  This type specifier uses a syntax similar to the usual lambda list syntax to specify which types go with which lambda list variables.  However, this is actually of limited usefulness in the context of a declaration, where one normally wants type information about the actual arguments which can be passed to the function rather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are always bound to a value of type LIST.  For the sake of consistency, it would seem that the corresponding type given in the FUNCTION declaration must also be LIST, but since this provides no information about the actual arguments, some users/implementors have instead adopted the convention of supplying the type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in the type specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier provided with &REST is the type of each actual argument, not the type of the corresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter must be LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lisp implementations currently ignore FUNCTION type declarations. The only examples found so far are in a text book on Common Lisp, which follows the proposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to do so.  Probably only a small amount of code would have to be written/changed in implementations that currently think that the  &REST argument should be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter must be LIST will have to change their code.  However, because this issue is so unclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be of limited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the language design.Esthetics:Debatable.  One the one hand, since the argument type syntax used by the FUNCTION type specifier mirrors normal lambda-list syntax, it would be cleaner and less confusing to provide the type of the lambda variable rather than the type of the actual arguments. However, considering the types specified in the FUNCTION specifier to be the types of the actual arguments rather than the types of the parameters as seen on the receiving end makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee and at X3J13. Many people objected to this proposal, and would prefer the alternative that the type given after a &REST in a function declaration apply to the value of the formal parameter rather than the actual arguments. This would be even more useful if complex LIST type specifiers were part of Common Lisp (as the proposal in issue LIST-TYPE-SPECIFIER might add) or if it were possible to declare, for example, &REST {keyword integer}*.Some additional arguments against this proposal are the apparent mismatch between the external declarations of type and the internal ones. It might be that this proposals presumes that rest lists are always lists, and the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)which is not otherwise explicitly forbidden, but for which there is no legitimate declaration.        TITAN 
         TITAN 
          
TIMESROMAN 
           h       <                                                               Y              v             0       E              	       V                                                                      o       
       S                                 #z*start*05475 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 14:50:14 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Nov 88  14:47:56 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 14 NOV 88 14:35:26 PSTDate: 14 Nov 88 14:35 PSTFrom: masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 5)To: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881114-143526-2232@Xerox>I attempted to shorten the discussion section while at the same time be more explicit that there were some serious objections to it. I wound up cutting a lot of it out. Do you think I should put it back in?!Issue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 Masinter               Version 4,  2-Oct-88 Masinter (update references, discussion)               Version 5, 14-Nov-88 Masinter (add to discussion)Related issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS                REST-LIST-ALLOCATIONProblem description:The FUNCTION type specifier list is provided to allow declaration of function argument types and return value types.  This type specifier uses a syntax similar to the usual lambda list syntax to specify which types go with which lambda list variables.  However, this is actually of limited usefulness in the context of a declaration, where one normally wants type information about the actual arguments which can be passed to the function rather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are always bound to a value of type LIST.  For the sake of consistency, it would seem that the corresponding type given in the FUNCTION declaration must also be LIST, but since this provides no information about the actual arguments, some users/implementors have instead adopted the convention of supplying the type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in the type specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier provided with &REST is the type of each actual argument, not the type of the corresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter must be LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lisp implementations currently ignore FUNCTION type declarations. The only examples found so far are in a text book on Common Lisp, which follows the proposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to do so.  Probably only a small amount of code would have to be written/changed in implementations that currently think that the  &REST argument should be LIST.Cost to Users:Users who have been using the convention that the &REST type parameter must be LIST will have to change their code.  However, because this issue is so unclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be of limited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the language design.Esthetics:Debatable.  One the one hand, since the argument type syntax used by the FUNCTION type specifier mirrors normal lambda-list syntax, it would be cleaner and less confusing to provide the type of the lambda variable rather than the type of the actual arguments. However, considering the types specified in the FUNCTION specifier to be the types of the actual arguments rather than the types of the parameters as seen on the receiving end makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee and at X3J13. Many people objected to this proposal, and would prefer the alternative that the type given after a &REST in a function declaration apply to the value of the formal parameter rather than the actual arguments. This would be even more useful if complex LIST type specifiers were part of Common Lisp (as the proposal in issue LIST-TYPE-SPECIFIER might add) or if it were possible to declare, for example, &REST {keyword integer}*.Some additional arguments against this proposal are the apparent mismatch between the external declarations of type and the internal ones. It might be that this proposals presumes that rest lists are always lists, and the following is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)which is not otherwise explicitly forbidden, but for which there is no legitimate declaration.*start*00638 00024 USaReturn-Path: <jlm@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 14 NOV 88 15:38:38 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00605g; Mon, 14 Nov 88 15:37:43 PSTReceived: by bhopal id AA21895g; Mon, 14 Nov 88 15:36:25 PSTDate: Mon, 14 Nov 88 15:36:25 PSTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8811142336.AA21895@bhopal>To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 14 Nov 88 14:35 PST <881114-143526-2232@Xerox>Subject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 5)Maybe you could put the <newline>'s back in?  (:-)  jlm*start*00255 00024 US Date: 14 Nov 88 15:45 PSTFrom: masinter.paSubject: Re: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 5)In-reply-to: your message of Mon, 14 Nov 88 15:36:25 PSTTo: Jim McDonald <jlm@lucid.com>cc: masinter.paSorry. I will. *start*05283 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 16:04:25 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Nov 88  16:01:14 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 NOV 88 15:45:43 PSTDate: 14 Nov 88 15:45 PSTFrom: masinter.paSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 5)To: cl-cleanup@sail.stanford.eduMessage-ID: <881114-154543-2415@Xerox>This version should arrive with line breaks.!Issue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 Masinter               Version 4,  2-Oct-88 Masinter (update references,discussion)               Version 5, 14-Nov-88 Masinter (add to discussion)Related issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS                REST-LIST-ALLOCATIONProblem description:The FUNCTION type specifier list is provided to allow declaration offunction argument types and return value types.  This type specifier uses asyntax similar to the usual lambda list syntax to specify which types gowith which lambda list variables.  However, this is actually of limitedusefulness in the context of a declaration, where one normally wants typeinformation about the actual arguments which can be passed to the functionrather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are alwaysbound to a value of type LIST.  For the sake of consistency, it would seemthat the corresponding type given in the FUNCTION declaration must also beLIST, but since this provides no information about the actual arguments,some users/implementors have instead adopted the convention of supplyingthe type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in thetype specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier providedwith &REST is the type of each actual argument, not the type of thecorresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter mustbe LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lispimplementations currently ignore FUNCTION type declarations. The onlyexamples found so far are in a text book on Common Lisp, which follows theproposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to doso.  Probably only a small amount of code would have to be written/changedin implementations that currently think that the  &REST argument should beLIST.Cost to Users:Users who have been using the convention that the &REST type parameter mustbe LIST will have to change their code.  However, because this issue is sounclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be oflimited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the languagedesign.Esthetics:Debatable.  One the one hand, since the argument type syntax used by theFUNCTION type specifier mirrors normal lambda-list syntax, it would becleaner and less confusing to provide the type of the lambda variablerather than the type of the actual arguments. However, considering thetypes specified in the FUNCTION specifier to be the types of the actualarguments rather than the types of the parameters as seen on the receivingend makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee and atX3J13. Many people objected to this proposal, and would prefer the alternativethat the type given after a &REST in a function declaration apply to thevalue of the formal parameter rather than the actual arguments. This wouldbe even more useful if complex LIST type specifiers were part of CommonLisp (as the proposal in issue LIST-TYPE-SPECIFIER might add) or if it werepossible to declare, for example, &REST {keyword integer}*.Some additional arguments against this proposal are the apparent mismatchbetween the external declarations of type and the internal ones. It mightbe that this proposals presumes that rest lists are always lists, and thefollowing is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)which is not otherwise explicitly forbidden, but for which there is nolegitimate declaration.*start*05426 00024 US Date:  8 Dec 88 10:38 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noForum:         CleanupIssue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 Masinter               Version 4,  2-Oct-88 Masinter (update references,								discussion)               Version 5, 14-Nov-88 Masinter (add to discussion)Related issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS                REST-LIST-ALLOCATIONProblem description:The FUNCTION type specifier list is provided to allow declaration offunction argument types and return value types.  This type specifier uses asyntax similar to the usual lambda list syntax to specify which types gowith which lambda list variables.  However, this is actually of limitedusefulness in the context of a declaration, where one normally wants typeinformation about the actual arguments which can be passed to the functionrather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are alwaysbound to a value of type LIST.  For the sake of consistency, it would seemthat the corresponding type given in the FUNCTION declaration must also beLIST, but since this provides no information about the actual arguments,some users/implementors have instead adopted the convention of supplyingthe type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in thetype specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier providedwith &REST is the type of each actual argument, not the type of thecorresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter mustbe LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lispimplementations currently ignore FUNCTION type declarations. The onlyexamples found so far are in a text book on Common Lisp, which follows theproposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to doso.  Probably only a small amount of code would have to be written/changedin implementations that currently think that the  &REST argument should beLIST.Cost to Users:Users who have been using the convention that the &REST type parameter mustbe LIST will have to change their code.  However, because this issue is sounclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be oflimited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the languagedesign.Esthetics:Debatable.  One the one hand, since the argument type syntax used by theFUNCTION type specifier mirrors normal lambda-list syntax, it would becleaner and less confusing to provide the type of the lambda variablerather than the type of the actual arguments. However, considering thetypes specified in the FUNCTION specifier to be the types of the actualarguments rather than the types of the parameters as seen on the receivingend makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee and atX3J13. Many people objected to this proposal, and would prefer the alternativethat the type given after a &REST in a function declaration apply to thevalue of the formal parameter rather than the actual arguments. This wouldbe even more useful if complex LIST type specifiers were part of CommonLisp (as the proposal in issue LIST-TYPE-SPECIFIER might add) or if it werepossible to declare, for example, &REST {keyword integer}*.Some additional arguments against this proposal are the apparent mismatchbetween the external declarations of type and the internal ones. It mightbe that this proposals presumes that rest lists are always lists, and thefollowing is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)which is not otherwise explicitly forbidden, but for which there is nolegitimate declaration.        GACHA           TITAN 
         TITAN 
           Z              
              k                                                  	                    a              v             0       E              	       V                                                                      o       
       S                          ~      r 'z*start*05326 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 11:09:08 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  10:56:00 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 DEC 88 10:39:12 PSTDate: 8 Dec 88 10:38 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: FUNCTION-TYPE-REST-LIST-ELEMENT (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881208-103912-3821@Xerox>!Forum:         CleanupIssue:         FUNCTION-TYPE-REST-LIST-ELEMENTReferences:    CLtL p. 27, 47-48, 61               "Artifical Intelligence Programming", Charniak et. al.               X3J13/86-003 (A:>GLS>clarifications.text.4)Category:      CLARIFICATION, ADDITIONEdit history:  Version 1, 23-Nov-1987 Sandra Loosemore               Version 2, 15-Jan-1988 Sandra Loosemore	           (incorporate comments from Scott Fahlman & others)               Version 3, 13-Feb-88 Masinter               Version 4,  2-Oct-88 Masinter (update references,								discussion)               Version 5, 14-Nov-88 Masinter (add to discussion)Related issues: FUNCTION-TYPE-KEY-NAME,                 FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS                REST-LIST-ALLOCATIONProblem description:The FUNCTION type specifier list is provided to allow declaration offunction argument types and return value types.  This type specifier uses asyntax similar to the usual lambda list syntax to specify which types gowith which lambda list variables.  However, this is actually of limitedusefulness in the context of a declaration, where one normally wants typeinformation about the actual arguments which can be passed to the functionrather than the lambda variables to which they are bound.There is a particular problem with &REST lambda variables, which are alwaysbound to a value of type LIST.  For the sake of consistency, it would seemthat the corresponding type given in the FUNCTION declaration must also beLIST, but since this provides no information about the actual arguments,some users/implementors have instead adopted the convention of supplyingthe type of the actual arguments which are gathered into the list.  CLtL is vague on the issue, mentioning only that &REST may appear in thetype specifier without touching upon its interpretation.Proposal (FUNCTION-TYPE-REST-LIST-ELEMENT:USE-ACTUAL-ARGUMENT-TYPE):Clarify that, in the FUNCTION type specifier, the type specifier providedwith &REST is the type of each actual argument, not the type of thecorresponding lambda variable.Example:The type of the function + would be specified as:(FUNCTION (&REST NUMBER) NUMBER)Rationale:This is more useful than specifying that the type of a &REST parameter mustbe LIST, since it provides information about the actual arguments.Current practice:There does not appear to be any concensus on this issue.  Most Common Lispimplementations currently ignore FUNCTION type declarations. The onlyexamples found so far are in a text book on Common Lisp, which follows theproposed syntax.Cost to Implementors:Implementations that ignore the FUNCTION type specifier may continue to doso.  Probably only a small amount of code would have to be written/changedin implementations that currently think that the  &REST argument should beLIST.Cost to Users:Users who have been using the convention that the &REST type parameter mustbe LIST will have to change their code.  However, because this issue is sounclear, the FUNCTION type specifier is probably not used very much.Cost of non-adoption:If nothing is done, the FUNCTION type specifier will continue to be oflimited use for its intended purpose.Benefits:Adopting the proposal will clear up an area of confusion in the languagedesign.Esthetics:Debatable.  One the one hand, since the argument type syntax used by theFUNCTION type specifier mirrors normal lambda-list syntax, it would becleaner and less confusing to provide the type of the lambda variablerather than the type of the actual arguments. However, considering thetypes specified in the FUNCTION specifier to be the types of the actualarguments rather than the types of the parameters as seen on the receivingend makes the proposed semantics more palatable.Discussion:This issue provoked considerable debate in the cleanup committee and atX3J13. Many people objected to this proposal, and would prefer the alternativethat the type given after a &REST in a function declaration apply to thevalue of the formal parameter rather than the actual arguments. This wouldbe even more useful if complex LIST type specifiers were part of CommonLisp (as the proposal in issue LIST-TYPE-SPECIFIER might add) or if it werepossible to declare, for example, &REST {keyword integer}*.Some additional arguments against this proposal are the apparent mismatchbetween the external declarations of type and the internal ones. It mightbe that this proposals presumes that rest lists are always lists, and thefollowing is illegal: (DEFUN FOO (&REST X) X) (APPLY #'FOO T)which is not otherwise explicitly forbidden, but for which there is nolegitimate declaration.