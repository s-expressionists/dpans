*start*07769 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 DEC 88 16:21:26 PSTReceived: from YUKON.SCRC.Symbolics.COM (SCRC-YUKON.ARPA) by SAIL.Stanford.EDU with TCP; 27 Dec 88  17:16:34 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 414776; Tue 27-Dec-88 11:27:49 ESTDate: Tue, 27 Dec 88 11:26 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-UNSPECIFIC-COMPONENT (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881227112629.4.KMP@BOBOLINK.SCRC.Symbolics.COM>To my knowledge, this was discussed (well, ok, one message was sent onthe subject) but never formally written up.Actually, I took the writeup of PATHNAME-TYPE-UNSPECIFIC and expanded it slightly to accomodate other fields. I wrote it up and included theissue PATHNAME-TYPE-UNSPECIFIC with it. If people seem happy with thiswriteup, Larry can consider PATHNAME-TYPE-UNSPECIFIC withdrawn.If this one runs into some hidden snag, I'll reactivate PATHNAME-TYPE-UNSPECIFIC.Note that Larry's original message on PATHNAME-UNSPECIFIC-COMPONENTdeals with some things unrelated to the issue of unspecific components.I haven't lost that information; it will appear in a different proposal,soon to follow. -kmp-----Issue:        PATHNAME-UNSPECIFIC-COMPONENTForum:        CleanupReferences:   File System Interface (pp409-427)Category:     CHANGEEdit history: 27-Dec-88, Version 1 by PitmanStatus:       For Internal DiscussionSubsumes:     Issue PATHNAME-TYPE-UNSPECIFICProblem Description:  In some file systems, it is inappropriate to represent particular  pathname components, either all the time or in some specialized   circumstance.   - Unix pathnames never have a version field.   - In some file systems, specifying a device and a directory means     something very different than specifying the device alone,      particularly when the device is a "logical device" that may     already imply a directory.   - Some Unix pathnames have types and others do not. For example,     it is possible to make files named "foo." and "foo" which are     distinct. CLtL (p412) specifies that the type is ``always a     string, NIL, or :WILD.'' This description is too restrictive     to be practical in this case. One of these (usually the former)     can get a type of "" but it is not clear how to represent the     other. If NIL is used, merging primitives cannot detect that the     field is filled and should not be merged against.    - ITS pathnames have either a version or a type, but never both.     "JOE;FILE 32" has a directory, a name, and a version.     "JOE;FILE TEXT" has a directory, a name, and a type.     "JOE;FILE TEXT 32" is not a possible ITS filename.Proposal (PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN):  Permit :UNSPECIFIC as a value of the DEVICE, DIRECTORY, TYPE, or  VERSION field of a pathname for file systems in which it makes sense.  When a pathname is converted to a namestring, NIL and :UNSPECIFIC  are treated as if the field were empty. That is, they both cause the  component not to appear in the string.  When merging, however, only a NIL value for a component will be  replaced with the default for that component, while :UNSPECIFIC  will be left alone as if the field were filled.  Portable programs should expect to find :UNSPECIFIC in the device,  directory, type, or version field in some implementations.  Portable programs should not explicitly place :UNSPECIFIC in any  field, since that it might not be permitted in some situations,  but portable programs may sometimes do so implicitly.Test Case:  ;; #1: Non-portable code. This may signal an error in some  ;;     implementations where an unspecific type makes no sense.  (MAKE-PATHNAME :TYPE :UNSPECIFIC)	;not portable  ;; #2: In this example, assume a Unix file system.  (PATHNAME-TYPE (PARSE-NAMESTRING "foo."))  => ""  (PATHNAME-TYPE (PARSE-NAMESTRING "foo"))  => :UNSPECIFIC  (PATHNAME-TYPE (MERGE-PATHNAMES (PARSE-NAMESTRING "foo")				  (MAKE-PATHNAME :TYPE "BAR")))  => :UNSPECIFIC  ;; #3: In this example, assume an ITS file system.  (LET ((P (PARSE-NAMESTRING "FOO 32")))    (LIST (PATHNAME-TYPE P) (PATHNAME-VERSION P)))  => (:UNSPECIFIC 32)  (LET ((P (PARSE-NAMESTRING "FOO TEXT")))    (LIST (PATHNAME-TYPE P) (PATHNAME-VERSION P)))  => ("TEXT" :UNSPECIFIC)  (LET ((P (MERGE-PATHNAMES (PARSE-NAMESTRING "FOO 32")			    (PARSE-NAMESTRING "FOO TEXT"))))    (LIST (PATHNAME-TYPE P) (PATHNAME-VERSION P)))  => (:UNSPECIFIC 32)  ;; Note: It is not the intent of this proposal to actually legislate  ;; the canonical representation of Unix pathnames "foo." and "foo",  ;; nor of ITS pathnames "FOO 32" and "FOO TEXT". That should probably  ;; be done, but under separate cover. The above examples are intended  ;; only to demonstrate how this proposal will permit the representation  ;; of pathnames not usefully representable under CLtL.Rationale:  This is, by necessity, current practice in some implementations  already.Current Practice:  Symbolics Genera uses a file types and versions of :UNSPECIFIC on  Unix and ITS file systems, for example.Cost to Implementors:  None. No change to any implementation is forced.  Some implementations which already do this are legitimized.  Some implementations which use a non-standard token other than   :UNSPECIFIC to implement this functionality would want to switch  to use :UNSPECIFIC so that portable programs could expect it.Cost to Users:  Some programs which manipulate pathnames should be updated to expect  :UNSPECIFIC in the type fields in some situations.  Any program which doesn't already expect :UNSPECIFIC is already not really  portable, however, given that some implementations have been forced to  go beyond the standard in order to represent all possible pathnames.Cost of Non-Adoption:  Some implementations would be unable to both represent all possible   pathnames in a rational way and at the same time to conform to the  standard. Such an inability would seriously jeopardize the usefulness  of Common Lisp in the design of serious programs.Benefits:  Some programs involving pathnames would be more portable.Aesthetics:  Sweeping a hairy situation under the rug doesn't make it go away.  This change makes things appear less simple, but since in reality  they were less simple, it is effectively a simplification of the  correspondence between the CL model and reality.Discussion:  Pitman and Moon support PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN.  This feature existed (for types) in the Colander draft edition of  CLtL, but was removed for the Laser edition. The following text is  excerpted from the Colander edition, p259:   ``??? Query: Is :unspecific really needed over and above nil?   ``A component of a pathname can also be the keyword     :UNSPECIFIC. This means that the component has been explicitly     determined not to be there, as opposed to be missing. One way     this can occur is with generic pathnames, which refer not to     a file but to a whole family of files. The version, and usually     the type, of a generic pathname are :unspecific. Another way     :unspecific is used to represent components that are not simply     supported by a file system. When a pathname is converted to a     namestring, nil and :unspecific both cause the component not to     appear in the string. When merging, however, a nil value for     a component will be replaced with the default for that     component, while :unspecific will be left alone.''*start*01499 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 DEC 88 10:40:38 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Dec 88  10:39:32 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513139; Thu 29-Dec-88 13:38:15 ESTDate: Thu, 29 Dec 88 13:38 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-UNSPECIFIC-COMPONENT (Version 1)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881227112629.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Supersedes: <19881229183701.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Comments: Added comment about misspelled proposal nameMessage-ID: <19881229183800.2.MOON@EUPHRATES.SCRC.Symbolics.COM>I approve PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN (of course).Uh, the proposal name is really spelled that way in the bodyof the writeup.  It should be PATHNAME-UNSPECIFIC-COMPONENT:NEW-TOKEN.Where you note that Unix pathnames don't have versions, youcould also note that they don't have devices either.The stuff about generic pathnames in the discussion sectionwas brain damage and may have lead to the confusion that caused:unspecific to be dropped from Common Lisp.  Only the stuff aboutcomponents not supported by a file system makes sense.*start*00918 00024 USaReturn-Path: <Gray@DSG.csc.ti.com>Received: from ti.com ([10.7.0.46]) by Xerox.COM ; 03 JAN 89 08:48:49 PSTReceived: by ti.com id AA18265; Tue, 3 Jan 89 10:49:12 CSTReceived: from dsg by tilde id AA12567; Tue, 3 Jan 89 10:45:51 CSTReceived: From Kelvin By dsg Via CHAOS-NET With CHAOS-MAIL; Tue, 3 Jan 89  10:46:28 CSTMessage-Id: <2808837989-14942113@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 3 Jan 89 10:46:29 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: masinter.paSubject: Re: Issue: PATHNAME-UNSPECIFIC-COMPONENT (Version 1)In-Reply-To: Msg of Tue, 27 Dec 88 11:26 EST from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>> Current Practice:> >   Symbolics Genera uses a file types and versions of :UNSPECIFIC on>   Unix and ITS file systems, for example.You can add the TI Explorer and LMI Lambda to that.*start*01003 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 22:22:52 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  22:22:27 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 11 JAN 89 22:21:18 PSTDate: 11 Jan 89 22:20 PSTFrom: masinter.paSubject: Re: Issue: PATHNAME-UNSPECIFIC-COMPONENT (Version 1)In-reply-to: David N Gray <Gray@DSG.csc.ti.com>'s message of Tue, 3 Jan 89 10:46:29 CSTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: cl-cleanup@sail.stanford.eduMessage-ID: <890111-222118-11592@Xerox>I hadn't given much thought to this issue before. In Medley, we represented"unspecific" components by the empty string. I.e., "foo." => (host nil device nil directory nil name "foo" type ""version nil), while "foo" => (host nil device nil directory nil name "foo" type nilversion nil).Why do you need a separate keyword?*start*02192 00024 USaReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 12 JAN 89 10:36:52 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 520273; Thu 12-Jan-89 13:36:09 ESTDate: Thu, 12 Jan 89 13:35 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-UNSPECIFIC-COMPONENT (Version 1)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890111-222118-11592@Xerox>Message-ID: <890112133559.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Ah, I thought I'd dropped my pointer to this message. Even though I answeredit in mail to Jeff a bit ago, I want to make sure it's filed where the answercan be found, since it's important:    Date: 11 Jan 89 22:20 PST    From: masinter.pa@Xerox.COM    I hadn't given much thought to this issue before. In Medley, we represented    "unspecific" components by the empty string. The null type is not what we call an unspecific component.    I.e., "foo." => (host nil device nil directory nil name "foo" type ""    version nil), This is a null type.    while "foo" => (host nil device nil directory nil name "foo" type nil    version nil).This is an unspecific type, but it cannot be represented this way because ofreasons outlined in the problem description of this proposal.    Why do you need a separate keyword?It doesn't merge right. If I have two Unix files "stuff" and "stuff.l" and I do(OPEN "stuff") from within Lisp while the file defaults are for "/joe/foo.l"then, you will open "stuff.l" rather than "stuff" if you have represented theunspecific type as NIL because of the way Lisp pathname merging is defined towork.Since Unix allows you to create files which deliberately have no type (and sodo not want to have a type merged into them), there must be a way to distinguish "This pathname has no type but wants one." (type = NIL)from "This pathname has not type for a reason." (type = :UNSPECIFIC)from "This pathname has a type which is null." (type = "")I hope this helps clarify things.*start*00372 00024 US Date: 12 Jan 89 10:49 PSTFrom: masinter.paSubject: Re: Issue: PATHNAME-UNSPECIFIC-COMPONENT (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 12 Jan 89 13:35 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, CL-Cleanup@SAIL.Stanford.EDUYes, I remember this now, sorry. *start*07316 00024 US Date: 12 Jan 89 17:04 PSTSender: masinter.paSubject: Issue: PATHNAME-UNSPECIFIC-COMPONENT (Version 1)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinterline-fold: NoThis issue is a generalization of PATHNAME-TYPE-UNSPECIFIC,which it subsumes.Forum:       CleanupIssue:        PATHNAME-UNSPECIFIC-COMPONENTForum:        CleanupReferences:   File System Interface (pp409-427)Category:     CHANGEEdit history: 27-Dec-88, Version 1 by PitmanSubsumes:     Issue PATHNAME-TYPE-UNSPECIFICProblem Description:  In some file systems, it is inappropriate to represent particular  pathname components, either all the time or in some specialized   circumstance.   - Unix pathnames never have a version field.   - In some file systems, specifying a device and a directory means     something very different than specifying the device alone,      particularly when the device is a "logical device" that may     already imply a directory.   - Some Unix pathnames have types and others do not. For example,     it is possible to make files named "foo." and "foo" which are     distinct. CLtL (p412) specifies that the type is ``always a     string, NIL, or :WILD.'' This description is too restrictive     to be practical in this case. One of these (usually the former)     can get a type of "" but it is not clear how to represent the     other. If NIL is used, merging primitives cannot detect that the     field is filled and should not be merged against.    - ITS pathnames have either a version or a type, but never both.     "JOE;FILE 32" has a directory, a name, and a version.     "JOE;FILE TEXT" has a directory, a name, and a type.     "JOE;FILE TEXT 32" is not a possible ITS filename.Proposal (PATHNAME-UNSPECIFIC-COMPONENT:NEW-TOKEN):  Permit :UNSPECIFIC as a value of the DEVICE, DIRECTORY, TYPE, or  VERSION field of a pathname for file systems in which it makes sense.  When a pathname is converted to a namestring, NIL and :UNSPECIFIC  are treated as if the field were empty. That is, they both cause the  component not to appear in the string.  When merging, however, only a NIL value for a component will be  replaced with the default for that component, while :UNSPECIFIC  will be left alone as if the field were filled.  Portable programs should expect to find :UNSPECIFIC in the device,  directory, type, or version field in some implementations.  Portable programs should not explicitly place :UNSPECIFIC in any  field, since that it might not be permitted in some situations,  but portable programs may sometimes do so implicitly.Test Case:  ;; #1: Non-portable code. This may signal an error in some  ;;     implementations where an unspecific type makes no sense.  (MAKE-PATHNAME :TYPE :UNSPECIFIC)	;not portable  ;; #2: In this example, assume a Unix file system.  (PATHNAME-TYPE (PARSE-NAMESTRING "foo."))  => ""  (PATHNAME-TYPE (PARSE-NAMESTRING "foo"))  => :UNSPECIFIC  (PATHNAME-TYPE (MERGE-PATHNAMES (PARSE-NAMESTRING "foo")				  (MAKE-PATHNAME :TYPE "BAR")))  => :UNSPECIFIC  ;; #3: In this example, assume an ITS file system.  (LET ((P (PARSE-NAMESTRING "FOO 32")))    (LIST (PATHNAME-TYPE P) (PATHNAME-VERSION P)))  => (:UNSPECIFIC 32)  (LET ((P (PARSE-NAMESTRING "FOO TEXT")))    (LIST (PATHNAME-TYPE P) (PATHNAME-VERSION P)))  => ("TEXT" :UNSPECIFIC)  (LET ((P (MERGE-PATHNAMES (PARSE-NAMESTRING "FOO 32")			    (PARSE-NAMESTRING "FOO TEXT"))))    (LIST (PATHNAME-TYPE P) (PATHNAME-VERSION P)))  => (:UNSPECIFIC 32)  ;; Note: It is not the intent of this proposal to actually legislate  ;; the canonical representation of Unix pathnames "foo." and "foo",  ;; nor of ITS pathnames "FOO 32" and "FOO TEXT". That should probably  ;; be done, but under separate cover. The above examples are intended  ;; only to demonstrate how this proposal will permit the representation  ;; of pathnames not usefully representable under CLtL.Rationale:  This is, by necessity, current practice in some implementations  already.Current Practice:  Symbolics Genera uses a file types and versions of :UNSPECIFIC on  Unix and ITS file systems, for example.Cost to Implementors:  None. No change to any implementation is forced.  Some implementations which already do this are legitimized.  Some implementations which use a non-standard token other than   :UNSPECIFIC to implement this functionality would want to switch  to use :UNSPECIFIC so that portable programs could expect it.Cost to Users:  Some programs which manipulate pathnames should be updated to expect  :UNSPECIFIC in the type fields in some situations.  Any program which doesn't already expect :UNSPECIFIC is already not really  portable, however, given that some implementations have been forced to  go beyond the standard in order to represent all possible pathnames.Cost of Non-Adoption:  Some implementations would be unable to both represent all possible   pathnames in a rational way and at the same time to conform to the  standard. Such an inability would seriously jeopardize the usefulness  of Common Lisp in the design of serious programs.Benefits:  Some programs involving pathnames would be more portable.Aesthetics:  Sweeping a hairy situation under the rug doesn't make it go away.  This change makes things appear less simple, but since in reality  they were less simple, it is effectively a simplification of the  correspondence between the CL model and reality.Discussion:  Pitman and Moon support PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN.  This feature existed (for types) in the Colander draft edition of  CLtL, but was removed for the Laser edition. The following text is  excerpted from the Colander edition, p259:   ``??? Query: Is :unspecific really needed over and above nil?   ``A component of a pathname can also be the keyword     :UNSPECIFIC. This means that the component has been explicitly     determined not to be there, as opposed to be missing. One way     this can occur is with generic pathnames, which refer not to     a file but to a whole family of files. The version, and usually     the type, of a generic pathname are :unspecific. Another way     :unspecific is used to represent components that are not simply     supported by a file system. When a pathname is converted to a     namestring, nil and :unspecific both cause the component not to     appear in the string. When merging, however, a nil value for     a component will be replaced with the default for that     component, while :unspecific will be left alone.''"The stuff about generic pathnames in the discussion sectionwas brain damage and may have lead to the confusion that caused:unspecific to be dropped from Common Lisp.  Only the stuff aboutcomponents not supported by a file system makes sense."        TITAN 
         TITAN 
          I                                                 "                                   -                    µ       4      :             :              O              p             :             \             
       
       >                           ;       $zº*start*07264 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 17:25:26 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Jan 89  17:11:34 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 JAN 89 17:04:55 PSTDate: 12 Jan 89 17:04 PSTSender: masinter.paSubject: Issue: PATHNAME-UNSPECIFIC-COMPONENT (Version 1)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinter.paline-fold: NoMessage-ID: <890112-170455-1498@Xerox>This issue is a generalization of PATHNAME-TYPE-UNSPECIFIC,which it subsumes.!Forum:       CleanupIssue:        PATHNAME-UNSPECIFIC-COMPONENTForum:        CleanupReferences:   File System Interface (pp409-427)Category:     CHANGEEdit history: 27-Dec-88, Version 1 by PitmanSubsumes:     Issue PATHNAME-TYPE-UNSPECIFICProblem Description:  In some file systems, it is inappropriate to represent particular  pathname components, either all the time or in some specialized   circumstance.   - Unix pathnames never have a version field.   - In some file systems, specifying a device and a directory means     something very different than specifying the device alone,      particularly when the device is a "logical device" that may     already imply a directory.   - Some Unix pathnames have types and others do not. For example,     it is possible to make files named "foo." and "foo" which are     distinct. CLtL (p412) specifies that the type is ``always a     string, NIL, or :WILD.'' This description is too restrictive     to be practical in this case. One of these (usually the former)     can get a type of "" but it is not clear how to represent the     other. If NIL is used, merging primitives cannot detect that the     field is filled and should not be merged against.    - ITS pathnames have either a version or a type, but never both.     "JOE;FILE 32" has a directory, a name, and a version.     "JOE;FILE TEXT" has a directory, a name, and a type.     "JOE;FILE TEXT 32" is not a possible ITS filename.Proposal (PATHNAME-UNSPECIFIC-COMPONENT:NEW-TOKEN):  Permit :UNSPECIFIC as a value of the DEVICE, DIRECTORY, TYPE, or  VERSION field of a pathname for file systems in which it makes sense.  When a pathname is converted to a namestring, NIL and :UNSPECIFIC  are treated as if the field were empty. That is, they both cause the  component not to appear in the string.  When merging, however, only a NIL value for a component will be  replaced with the default for that component, while :UNSPECIFIC  will be left alone as if the field were filled.  Portable programs should expect to find :UNSPECIFIC in the device,  directory, type, or version field in some implementations.  Portable programs should not explicitly place :UNSPECIFIC in any  field, since that it might not be permitted in some situations,  but portable programs may sometimes do so implicitly.Test Case:  ;; #1: Non-portable code. This may signal an error in some  ;;     implementations where an unspecific type makes no sense.  (MAKE-PATHNAME :TYPE :UNSPECIFIC)	;not portable  ;; #2: In this example, assume a Unix file system.  (PATHNAME-TYPE (PARSE-NAMESTRING "foo."))  => ""  (PATHNAME-TYPE (PARSE-NAMESTRING "foo"))  => :UNSPECIFIC  (PATHNAME-TYPE (MERGE-PATHNAMES (PARSE-NAMESTRING "foo")				  (MAKE-PATHNAME :TYPE "BAR")))  => :UNSPECIFIC  ;; #3: In this example, assume an ITS file system.  (LET ((P (PARSE-NAMESTRING "FOO 32")))    (LIST (PATHNAME-TYPE P) (PATHNAME-VERSION P)))  => (:UNSPECIFIC 32)  (LET ((P (PARSE-NAMESTRING "FOO TEXT")))    (LIST (PATHNAME-TYPE P) (PATHNAME-VERSION P)))  => ("TEXT" :UNSPECIFIC)  (LET ((P (MERGE-PATHNAMES (PARSE-NAMESTRING "FOO 32")			    (PARSE-NAMESTRING "FOO TEXT"))))    (LIST (PATHNAME-TYPE P) (PATHNAME-VERSION P)))  => (:UNSPECIFIC 32)  ;; Note: It is not the intent of this proposal to actually legislate  ;; the canonical representation of Unix pathnames "foo." and "foo",  ;; nor of ITS pathnames "FOO 32" and "FOO TEXT". That should probably  ;; be done, but under separate cover. The above examples are intended  ;; only to demonstrate how this proposal will permit the representation  ;; of pathnames not usefully representable under CLtL.Rationale:  This is, by necessity, current practice in some implementations  already.Current Practice:  Symbolics Genera uses a file types and versions of :UNSPECIFIC on  Unix and ITS file systems, for example.Cost to Implementors:  None. No change to any implementation is forced.  Some implementations which already do this are legitimized.  Some implementations which use a non-standard token other than   :UNSPECIFIC to implement this functionality would want to switch  to use :UNSPECIFIC so that portable programs could expect it.Cost to Users:  Some programs which manipulate pathnames should be updated to expect  :UNSPECIFIC in the type fields in some situations.  Any program which doesn't already expect :UNSPECIFIC is already not really  portable, however, given that some implementations have been forced to  go beyond the standard in order to represent all possible pathnames.Cost of Non-Adoption:  Some implementations would be unable to both represent all possible   pathnames in a rational way and at the same time to conform to the  standard. Such an inability would seriously jeopardize the usefulness  of Common Lisp in the design of serious programs.Benefits:  Some programs involving pathnames would be more portable.Aesthetics:  Sweeping a hairy situation under the rug doesn't make it go away.  This change makes things appear less simple, but since in reality  they were less simple, it is effectively a simplification of the  correspondence between the CL model and reality.Discussion:  Pitman and Moon support PATHNAME-TYPE-UNSPECIFIC:NEW-TOKEN.  This feature existed (for types) in the Colander draft edition of  CLtL, but was removed for the Laser edition. The following text is  excerpted from the Colander edition, p259:   ``??? Query: Is :unspecific really needed over and above nil?   ``A component of a pathname can also be the keyword     :UNSPECIFIC. This means that the component has been explicitly     determined not to be there, as opposed to be missing. One way     this can occur is with generic pathnames, which refer not to     a file but to a whole family of files. The version, and usually     the type, of a generic pathname are :unspecific. Another way     :unspecific is used to represent components that are not simply     supported by a file system. When a pathname is converted to a     namestring, nil and :unspecific both cause the component not to     appear in the string. When merging, however, a nil value for     a component will be replaced with the default for that     component, while :unspecific will be left alone.''"The stuff about generic pathnames in the discussion sectionwas brain damage and may have lead to the confusion that caused:unspecific to be dropped from Common Lisp.  Only the stuff aboutcomponents not supported by a file system makes sense."