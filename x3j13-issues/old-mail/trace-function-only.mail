*start*05600 00024 USfReturn-Path: <kempf%hplabsz@hplabs.HP.COM>Received: from hplabs.HP.COM ([15.255.16.7]) by Xerox.COM ; 21 OCT 87 10:00:05 PDTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Wed, 21 Oct 87 09:59:19 PDTReceived: from hplabsz.hpl.hp.com by hplms2; Wed, 21 Oct 87 09:58:43 pdtReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Wed, 21 Oct 87 10:58:12 pdtTo: Masinter.paCc: Common-Lisp-Object-System@sail.stanford.eduSubject: TRACE ProposalX-Mailer: mh6.5Date: Wed, 21 Oct 87 09:58:09 PDTMessage-Id: <24566.561833889@hplabsz>From: kempf%hplabsz@hplabs.HP.COMLarry:	Here is a copy of the proposed modifications to TRACE, whichwere discussed at the September CLOS committee meeting. I have notincluded the TRACE-EXECUTION proposal, since it is a generic function,similar to PRINT-OBJECT, and its disposition was not clear at themeeting.	I hope this gets to you in time for the November meeting. Ifnot, apologies: OOPSLA and recovery took longer than expected.		Jim Kempf-------------------------------------------------------------------------------Issue:         TRACE-CLOSReferences:    trace macro pp. 440-441Category:      MODIFICATIONEdit history:  Version 1, 21-Oct-87 KempfProblem description:With the addition of the Common Lisp Object System, there is nocommand language level way to trace individual method execution.The TRACE macro, as currently specified in Common Lisp, allowsonly tracing of globally defined functions through their names.Since a generic function name may have several executable methods,users need some way to specify that they would like invocation of particularmethods to be traced, rather than invocation of the entire genericfunction.In addition, the current specification of TRACE does not allow tracingof functions associated with SETF "methods", of macro functions, nor of lexically defined functions or functions invoked via. theirfunction definition objects.  While this proposal does not attempt to address the latter problems, since identification and/or tracing of theseis likely to be implementation dependent, it does leave open the option for those implementations which can arrange it. Finally, some implementations of Common Lisp have extended TRACE to take an option which puts the system into a break loop after the trace information has beenprinted. This proposal adds that capability to the standard.Proposal (TRACE-CLOS::TRACE-FUNCTION-SPECIFICATION)(Font Note: UPPERCASE indicates bold, _this_ indicates italic)TRACE _function-spec_ &KEY (:BREAK NIL) _[Macro]_TRACEUNTRACE _function-spec_	_[Macro]_UNTRACEInvoking TRACE with a function specification causes the function specifiedto be traced. Henceforth, whenever the specified function is invoked,information about the call, the arguments passed, and the returnedvalues, if any, will be printed to the stream that is the value of*TRACE-OUTPUT*. If the keyword argument :BREAK is T, then the BREAKfunction will be called after the trace information is printed. UNTRACE undoes any tracing. Calling TRACE without any argumentsprints a list of currently traced executable entities, callingUNTRACE without any arguments causes tracing to be undone forall currently traced entities.A _function_spec_ is either a symbol naming a function (i.e. asymbol whose global function cell is bound to a function definitionobject, or to which the application of MACRO-FUNCTION will returna function definition object) or a list whose first element indicateswhat kind of funcallable object is to be traced and whose tail indicateswhich particular function should be traced. The complete set offunction specifications will necessarily be implementation dependent; however,every implementation is required to support the following:	_symbol_-Invocations of the function or macrofunction named by	         _symbol_ via. _symbol_ as a global name are traced.	(METHOD _generic-function-name-specification_                _{method-qualifiers}_* 	        _parameter-specializer-name-list_        )	If the method whose parameter specializer list, generic function	name specification, and method qualifiers are listed is tracable,	then invocations through the generic function name specification 	will be traced.	(SETF _symbol_)-If the SETF function having the name specification	is tracable, it will be traced (see proposal SETF-CLOS for	more information on SETF name specifications).Implementations are encouraged to provide for tracing of as manyfuncallable objects as possible.Rationale:Adoption of the Common Lisp Object System will require the availabilityof debugging information on individual methods. Current practice:Some Common Lisp implementations have extended TRACE syntax toallow specification of breaks. Currently, the TRACE macro isspecified to take any number of symbols.Adoption Cost:The syntax of the TRACE macro will take only one function specificationin order to accomodate the :BREAK key. But, since TRACE tends tobe used interactively at the command langauge level, the impacton existing code should be slight.Cost of non-adoption:Without this, implementation dependent ways of specifying the:BREAK option would continue to be used. In addition, mostimplementors would probably add their own syntax for allowingprogrammers to obtain information on individual method invocation.Benefits:Allow programmers to obtain information on individual methodinvocations.Conversion Cost:Minor re-write of the TRACE and UNTRACE macros.*start*06272 00024 US Return-Path: <@SAIL.Stanford.EDU:Masinter.pa@Xerox.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 21 OCT 87 14:47:09 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 21 Oct 87  14:41:38 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 21 OCT 87 14:41:29 PDTDate: 21 Oct 87 14:40 PDTFrom: Masinter.paSubject: Issue: TRACE-FUNCTION-ONLYTo: cl-cleanup@Sail.stanford.eduMessage-ID: <871021-144129-3988@Xerox>I took the liberty of renaming this issue since the "problem" is broaderthan CLOS, but this is otherwise as submitted.     ----- Begin Forwarded Messages -----Return-Path: <kempf%hplabsz@hplabs.HP.COM>Received: from hplabs.HP.COM ([15.255.16.7]) by Xerox.COM ; 21 OCT 8710:00:05 PDTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Wed, 21 Oct 8709:59:19 PDTReceived: from hplabsz.hpl.hp.com by hplms2; Wed, 21 Oct 87 09:58:43 pdtReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Wed, 21 Oct 87 10:58:12 pdtTo: Masinter.paCc: Common-Lisp-Object-System@sail.stanford.eduSubject: TRACE ProposalX-Mailer: mh6.5Date: Wed, 21 Oct 87 09:58:09 PDTMessage-Id: <24566.561833889@hplabsz>From: kempf%hplabsz@hplabs.HP.COMLarry:	Here is a copy of the proposed modifications to TRACE, whichwere discussed at the September CLOS committee meeting. I have notincluded the TRACE-EXECUTION proposal, since it is a generic function,similar to PRINT-OBJECT, and its disposition was not clear at themeeting.	I hope this gets to you in time for the November meeting. Ifnot, apologies: OOPSLA and recovery took longer than expected.		Jim Kempf-------------------------------------------------------------------------------Issue:         TRACE-CLOSReferences:    trace macro pp. 440-441Category:      MODIFICATIONEdit history:  Version 1, 21-Oct-87 KempfProblem description:With the addition of the Common Lisp Object System, there is nocommand language level way to trace individual method execution.The TRACE macro, as currently specified in Common Lisp, allowsonly tracing of globally defined functions through their names.Since a generic function name may have several executable methods,users need some way to specify that they would like invocation ofparticularmethods to be traced, rather than invocation of the entire genericfunction.In addition, the current specification of TRACE does not allow tracingof functions associated with SETF "methods", of macro functions, nor of lexically defined functions or functions invoked via. theirfunction definition objects.  While this proposal does not attempt to address the latter problems, since identification and/or tracing oftheseis likely to be implementation dependent, it does leave open the option for those implementations which can arrange it. Finally,some implementations of Common Lisp have extended TRACE to take anoption which puts the system into a break loop after the trace information hasbeenprinted. This proposal adds that capability to the standard.Proposal (TRACE-CLOS::TRACE-FUNCTION-SPECIFICATION)(Font Note: UPPERCASE indicates bold, _this_ indicates italic)TRACE _function-spec_ &KEY (:BREAK NIL) _[Macro]_TRACEUNTRACE _function-spec_	_[Macro]_UNTRACEInvoking TRACE with a function specification causes the functionspecifiedto be traced. Henceforth, whenever the specified function is invoked,information about the call, the arguments passed, and the returnedvalues, if any, will be printed to the stream that is the value of*TRACE-OUTPUT*. If the keyword argument :BREAK is T, then the BREAKfunction will be called after the trace information is printed. UNTRACE undoes any tracing. Calling TRACE without any argumentsprints a list of currently traced executable entities, callingUNTRACE without any arguments causes tracing to be undone forall currently traced entities.A _function_spec_ is either a symbol naming a function (i.e. asymbol whose global function cell is bound to a function definitionobject, or to which the application of MACRO-FUNCTION will returna function definition object) or a list whose first element indicateswhat kind of funcallable object is to be traced and whose tail indicateswhich particular function should be traced. The complete set offunction specifications will necessarily be implementation dependent;however,every implementation is required to support the following:	_symbol_-Invocations of the function or macrofunction named by	         _symbol_ via. _symbol_ as a global name are traced.	(METHOD _generic-function-name-specification_                _{method-qualifiers}_* 	        _parameter-specializer-name-list_        )	If the method whose parameter specializer list, generic function	name specification, and method qualifiers are listed is tracable,	then invocations through the generic function name specification 	will be traced.	(SETF _symbol_)-If the SETF function having the name specification	is tracable, it will be traced (see proposal SETF-CLOS for	more information on SETF name specifications).Implementations are encouraged to provide for tracing of as manyfuncallable objects as possible.Rationale:Adoption of the Common Lisp Object System will require the availabilityof debugging information on individual methods. Current practice:Some Common Lisp implementations have extended TRACE syntax toallow specification of breaks. Currently, the TRACE macro isspecified to take any number of symbols.Adoption Cost:The syntax of the TRACE macro will take only one function specificationin order to accomodate the :BREAK key. But, since TRACE tends tobe used interactively at the command langauge level, the impacton existing code should be slight.Cost of non-adoption:Without this, implementation dependent ways of specifying the:BREAK option would continue to be used. In addition, mostimplementors would probably add their own syntax for allowingprogrammers to obtain information on individual method invocation.Benefits:Allow programmers to obtain information on individual methodinvocations.Conversion Cost:Minor re-write of the TRACE and UNTRACE macros.     ----- End Forwarded Messages -----*start*02996 00024 US Return-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 21 OCT 87 17:42:01 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Wed 21 Oct 87 20:41:32-EDTDate: Wed, 21 Oct 87 20:41 EDTMessage-ID: <FAHLMAN.12344368508.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: TRACE-FUNCTION-ONLYIn-reply-to: Msg of 21 Oct 1987  17:40-EDT from Masinter.pa at Xerox.COM(Kempf should probably be in on his discussion, but I don't have ausable return address for him.)My first reaction to this proposal was that TRACE is part of eachimplementation's environment, and that since it does not affect portablecode, it should not be part of the spec.  OK, we put TRACE into themanual, and this has the benficial effect that in a new implementationyou know that the thing called TRACE is what you want to find out aboutwhen you need this facility.  But we should not try to constrain it anyfurther.My second reaction was that I'd really like any implementaiton I use tosupport tracing of generic functions, methods, and (if we adopt theSETF-function proposal) these new function-spec forms.  For that matter,if we get deeper into the function-spec game, TRACE should follow.  Somaybe putting this requirement into the standard is not so bad after all-- it's one way of goading companies that might be slow to reactotherwise because their own people aren't deeply into CLOS yet.So I'd be willing to go along with that part of the proposal.  However,I think that the :BREAK stuff does not belong here.  If you want topropose that as a required extension, you should do it in a separateproposal and try to provide a better justification than "someimplementations do this, so I've randomly tossed it in with the otherstuff".If you add :BREAK in the way you propose, you are introducing agratuitous incompatibility with the syntax in CLtL, since now TRACE onlytakes a single symbol or function-spec.  An alternative is the schemeused in CMU Common Lisp:(trace [trace-form]*)where the trace form is either a symbol naming a function or a listwhose car is a function-name symbol and whose CDR contains the optionsto be used in tracing that function: :BREAK, :BREAK-AFTER, :WHEREIN,etc. I think that we got this extended syntax from Maclisp and that lots ofother Common Lisp implementations follow it as well.  I would like anyproposal for extensions to TRACE to be compatible with this extendedsyntax, which I think is better than requiring a separate call to TRACEfor each named function.  It might be ambiguous to allow arbitraryfunction-specs to appear as trace forms -- do you want to trace the SETFfunction of some symbol or SETF itself? -- but it would not be a problemto allow an arbitrary function spec to appear in the car of atrace-form, with implementation-specific keyword options allowed in theCDR.-- Scott*start*03480 00024 USaReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 21 OCT 87 18:22:25 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 260521; Wed 21-Oct-87 20:52:29 EDTDate: Wed, 21 Oct 87 20:41 EDTFrom: Fahlman@C.CS.CMU.EDUSender: FAHLMAN@C.CS.CMU.EDUSubject: Issue: TRACE-FUNCTION-ONLYTo: Masinter.pa, kempf%hplabsz@hplabs.hp.comcc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: The message of 21 Oct 87 17:40 EDT from Masinter.pa@Xerox.COMMessage-ID: <19871022005229.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Supersedes: <FAHLMAN.12344368508.BABYL@C.CS.CMU.EDU>Redirected-Date: Wed, 21 Oct 87 20:52 EDTRedirected-by: Moon@STONY-BROOK.SCRC.Symbolics.COM[This message has been redirected:  kempf%hplabsz@hplabs.hp.com should be a usable address for sending to Jim Kempf from CMU-C.    kempf%hplabsz@hplabs.hp.com has been added.](Kempf should probably be in on his discussion, but I don't have ausable return address for him.)My first reaction to this proposal was that TRACE is part of eachimplementation's environment, and that since it does not affect portablecode, it should not be part of the spec.  OK, we put TRACE into themanual, and this has the benficial effect that in a new implementationyou know that the thing called TRACE is what you want to find out aboutwhen you need this facility.  But we should not try to constrain it anyfurther.My second reaction was that I'd really like any implementaiton I use tosupport tracing of generic functions, methods, and (if we adopt theSETF-function proposal) these new function-spec forms.  For that matter,if we get deeper into the function-spec game, TRACE should follow.  Somaybe putting this requirement into the standard is not so bad after all-- it's one way of goading companies that might be slow to reactotherwise because their own people aren't deeply into CLOS yet.So I'd be willing to go along with that part of the proposal.  However,I think that the :BREAK stuff does not belong here.  If you want topropose that as a required extension, you should do it in a separateproposal and try to provide a better justification than "someimplementations do this, so I've randomly tossed it in with the otherstuff".If you add :BREAK in the way you propose, you are introducing agratuitous incompatibility with the syntax in CLtL, since now TRACE onlytakes a single symbol or function-spec.  An alternative is the schemeused in CMU Common Lisp:(trace [trace-form]*)where the trace form is either a symbol naming a function or a listwhose car is a function-name symbol and whose CDR contains the optionsto be used in tracing that function: :BREAK, :BREAK-AFTER, :WHEREIN,etc. I think that we got this extended syntax from Maclisp and that lots ofother Common Lisp implementations follow it as well.  I would like anyproposal for extensions to TRACE to be compatible with this extendedsyntax, which I think is better than requiring a separate call to TRACEfor each named function.  It might be ambiguous to allow arbitraryfunction-specs to appear as trace forms -- do you want to trace the SETFfunction of some symbol or SETF itself? -- but it would not be a problemto allow an arbitrary function spec to appear in the car of atrace-form, with implementation-specific keyword options allowed in theCDR.-- Scott*start*02081 00024 US Return-Path: <@SAIL.Stanford.EDU:Masinter.pa@Xerox.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 OCT 87 17:18:32 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 22 Oct 87  17:15:56 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 22 OCT 87 17:11:39 PDTDate: 22 Oct 87 17:11 PDTFrom: Masinter.paSubject: Re: Issue: TRACE-FUNCTION-ONLYIn-reply-to: Fahlman@C.CS.CMU.EDU's message of Wed, 21 Oct 87 20:41 EDTTo: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <871022-171139-5785@Xerox>I have frequently felt a need to define a layer between Common Lisp theLanguage and Common Lisp the Environment. It would probably make thosewho are pushing for a "layered defintion" in ISO happy if we made thedivision more explicit. Certainly, in such a situation, TRACE, STEP, ***, and many other friendswould fit in the Environment rather than the Language portion. I imaginethat there might be different levels of conformance testing availablefor Language and Environment -- it is notably difficult to generateautomatic testing code for environment features, implementations forembedded systems might well not have environment features, etc.The layering of the definition of CL is something not addressed byX3J13, although the ISO groups seem to be pushing at it from the bottomup. I'd hate to stall this proposal waiting on something as vague asthat. I have no opinion on the various ways of expressing :BREAK except thatI'd like to see it in the language. Right now, I have to type  (IL:BREAKX) in Xerox Common Lisp.By the way, XCL implements (trace (a :in b)) as a way of tracing thecalls to A which occur from B. This might fit into this proposal too,although I don't know if it is something that is always implementable.The form also admits (trace ((a b c) :in (d e f))) where lists aremultiplexed.I don't have enough other Common Lisp environment manuals to do anexhaustive Current Practice section, although I think that properconsideration of this issue requires it. *start*04585 00024 US Return-Path: <kempf%hplabsz@hplabs.HP.COM>Received: from hplabs.HP.COM (hplabs.hpl.hp.com) by Xerox.COM ; 23 OCT 87 08:28:54 PDTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Fri, 23 Oct 87 08:26:40 PDTReceived: from hplabsz.hpl.hp.com by hplms2; Fri, 23 Oct 87 08:25:58 pdtReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Fri, 23 Oct 87 09:25:29 pdtTo: Fahlman@C.CS.CMU.EDUCc: Masinter.pa, kempf%hplabsz@hplabs.hp.com, cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: TRACE-FUNCTION-ONLY X-Mailer: mh6.5In-Reply-To: Your message of Wed, 21 Oct 87 20:41:00 -0400.             <19871022005229.8.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Fri, 23 Oct 87 08:25:25 PDTMessage-Id: <21096.562001125@hplabsz>From: kempf%hplabsz@hplabs.HP.COMScott:	Larry forwarded your message. My address is: kempf@hplabs.hp.com.> My first reaction to this proposal was that TRACE is part of each> implementation's environment, and that since it does not affect portable> code, it should not be part of the spec.  This was my first reaction also.> However,> I think that the :BREAK stuff does not belong here.  If you want to> propose that as a required extension, you should do it in a separate> proposal and try to provide a better justification than "some> implementations do this, so I've randomly tossed it in with the other> stuff".I've found being able to introduce a break after the printing of tracinginformation in our Lisp to be an invaluable debugging tool, as haveother developers here. At the moment, they are beating my door downfor the same capability (along with simple tracing) for individualmethods, in the portable CLOS implementation. I can add this justificationto the proposal.> If you add :BREAK in the way you propose, you are introducing a> gratuitous incompatibility with the syntax in CLtL, since now TRACE only> takes a single symbol or function-spec.  An alternative is the scheme> used in CMU Common Lisp:> (trace [trace-form]*)> where the trace form is either a symbol naming a function or a list> whose car is a function-name symbol and whose CDR contains the options> to be used in tracing that function: :BREAK, :BREAK-AFTER, :WHEREIN,> etc. I originally proposed something like this and the concensus of the objectscommittee seemed to be that a cleaner syntax would be to limit TRACEto a single function specification, and add the keyword as a keywordargument. The committee seemed to feel that including the keyword aspart of a list containing a function specification could become confusingwhen the function specification was more than just a symbol.As to the incompatibility with current Common Lisp, as you pointed outin your note, TRACE is, to a large extent, part of the environment,Changing the interface would probably have less effect than changing something like, say, MAKE-ARRAY, since people tend to use TRACE interactively.> I think that we got this extended syntax from Maclisp and that lots of> other Common Lisp implementations follow it as well.  I would like any> proposal for extensions to TRACE to be compatible with this extended> syntax, which I think is better than requiring a separate call to TRACE> for each named function.  It might be ambiguous to allow arbitrary> function-specs to appear as trace forms -- do you want to trace the SETF> function of some symbol or SETF itself? -- but it would not be a problem> to allow an arbitrary function spec to appear in the car of a> trace-form, with implementation-specific keyword options allowed in the> CDR.If you feel strongly about it (and nobody else feels strongly in the otherdirection), I can resubmit the proposal with the interface as you'verequested.While we're discussing this issue, another part of the proposal was toinclude a generic function, called TRACE-EXECUTION, which took as anargument an object representing an executable entity, like a method object,generic function, function, symbol, etc. An implementation specific methodwould run to arrange for tracing code to be inserted. Similar toPRINT-OBJECT, all implementations would have to implement tracing usingthis generic function. The advantage of this is that if someone extendsCLOS/CL by including a new funcallable object, like, for example, aremote procedure call, debugging becomes extensible as well.I originally did not submit this to the Cleanup-committee because itseemed to be a CLOS exclusive issue (being a generic function) but maybeI should have?		Jim Kempf	kempf@hplabs.hp.com*start*03512 00024 USaReturn-Path: <@SAIL.Stanford.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 14:33:22 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 25 Oct 87  14:30:40 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 25 Oct 87 17:31:07-ESTDate: Sun, 25 Oct 87 17:31 ESTMessage-ID: <FAHLMAN.12345393345.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: kempf%hplabsz@HPLABS.HP.COMCc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: TRACE-FUNCTION-ONLY In-reply-to: Msg of 23 Oct 1987  11:25-EDT from kempf%hplabsz at hplabs.HP.COM    > However,    > I think that the :BREAK stuff does not belong here.  If you want to    > propose that as a required extension, you should do it in a separate    > proposal and try to provide a better justification than "some    > implementations do this, so I've randomly tossed it in with the other    > stuff".    I've found being able to introduce a break after the printing of tracing    information in our Lisp to be an invaluable debugging tool, as have    other developers here. At the moment, they are beating my door down    for the same capability (along with simple tracing) for individual    methods, in the portable CLOS implementation. I can add this justification    to the proposal.This doesn't really respond to the objection I raised.  I didn't suggestthat :BREAK was not worthwhile.  I said that there are two distinctissues here: whether to extend TRACE to work for methods and setffunctions, and whether to extend trace to do all sorts of other neatthings.  The former is probably not controversial, and I couldsupport a proposal that contains just this.If you insist upon extending the standard to include :BREAK, we ought togo all the way and specify exactly what an extended-form trace ought tohandle.  In addition to :BREAK, we probably want :BREAK-AFTER, :WHEREIN,:PRINT, :PRINT-AFTER, and maybe some other things.  We want a syntaxthat will handle all this, plus function specs, and that still will allowyou to say (TRACE A B C) when you have a bunch of functions you want tolook at in the usual way.So I oppose the current proposal that includes only :BREAK and thatadopts a more restrictive syntax for TRACE for no good reason.It might make sense to propose a comprehensive package of TRACEextensions that we would all follow, though getting agreement at thislate date might take some negotiation among the N divergentimplementations.     While we're discussing this issue, another part of the proposal was to    include a generic function, called TRACE-EXECUTION, which took as an    argument an object representing an executable entity, like a method object,    generic function, function, symbol, etc. An implementation specific method    would run to arrange for tracing code to be inserted. Similar to    PRINT-OBJECT, all implementations would have to implement tracing using    this generic function. The advantage of this is that if someone extends    CLOS/CL by including a new funcallable object, like, for example, a    remote procedure call, debugging becomes extensible as well.This is going to be a fairly hairy proposal, I think, since you have totrace function names and not functions (unless you want to forceimplementors to do surgery on compiled function objects).  I'd beinterested in seeing the details of this proposal.-- Scott*start*01267 00024 US Return-Path: <@SAIL.Stanford.EDU:Masinter.pa@Xerox.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 15:01:24 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 26 Oct 87  14:58:56 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 26 OCT 87 14:53:55 PSTDate: 26 Oct 87 14:53 PSTFrom: Masinter.paSubject: Re: Issue: TRACE-FUNCTION-ONLY In-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Sun, 25 Oct 87 17:31 ESTTo: Fahlman@C.CS.CMU.EDUcc: kempf%hplabsz@HPLABS.HP.COM, cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <871026-145355-2156@Xerox>I agree that it will be easier to get the issues passed if we separatethem. The notion that the features of TRACE as described in CLtL mightbe applicable to (SETF fn) and other callable locations seems easy toseparate from trying to standardize what the "additionalimplementation-dependent argument formats" are. The latter should probably include a fairly complete Current Practicesection, for example.  I'll allocate the nameTRACE-ARGUMENT-FORMAT-OPTIONS.Jim: can you write up a version that doesn't include the :BREAK stuff? Across reference to TRACE-ARGUMENT-FORMAT-OPTIONS should probably beincluded.*start*05431 00024 US Return-Path: <@SAIL.Stanford.EDU,@Score.Stanford.EDU:kempf%hplabsz@hplabs.HP.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 17:44:51 PSTReceived: from SCORE.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 26 Oct 87  17:42:06 PSTReceived: from hplabs.HP.COM (hplabs.hpl.hp.com.#Internet) by SCORE.STANFORD.EDU with TCP; Mon 26 Oct 87 17:38:44-PSTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Mon, 26 Oct 87 13:18:48 PSTReceived: from hplabsz.hpl.hp.com by hplms2; Mon, 26 Oct 87 13:18:14 pstReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Mon, 26 Oct 87 14:17:43 pstTo: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>Cc: kempf%hplabsz@HPLABS.HP.COM, cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: TRACE-FUNCTION-ONLY X-Mailer: mh6.5In-Reply-To: Your message of Sun, 25 Oct 87 17:31:00 -0500.             <FAHLMAN.12345393345.BABYL@C.CS.CMU.EDU> Date: Mon, 26 Oct 87 13:17:39 PSTMessage-Id: <2540.562281459@hplabsz>From: kempf%hplabsz@hplabs.HP.COMSF> This doesn't really respond to the objection I raised.  I didn't suggestSF> that :BREAK was not worthwhile.  I said that there are two distinctSF> issues here: whether to extend TRACE to work for methods and setfSF> functions, and whether to extend trace to do all sorts of other neatSF> things.  The former is probably not controversial, and I couldSF> support a proposal that contains just this.I understand. I was trying to address both issues, but, as you've pointedout, the :BREAK issue is somewhat more complex. I will rewrite the traceproposal to remove the reference to :BREAK, redo the syntax to conformto that currently in CLtL, and leave it up to someone else (who couldpossibly be me at a later date) to deal with the break issue.JK> While we're discussing this issue, another part of the proposal was toJK> include a generic function, called TRACE-EXECUTION, which took as anJK> argument an object representing an executable entity, like a method object,JK> generic function, function, symbol, etc. An implementation specific methodJK> would run to arrange for tracing code to be inserted. Similar toJK> PRINT-OBJECT, all implementations would have to implement tracing usingJK> this generic function. The advantage of this is that if someone extendsJK> CLOS/CL by including a new funcallable object, like, for example, aJK> remote procedure call, debugging becomes extensible as well.SF> This is going to be a fairly hairy proposal, I think, since you have toSF> trace function names and not functions (unless you want to forceSF> implementors to do surgery on compiled function objects).  I'd beSF> interested in seeing the details of this proposal.The intent of the proposal was to provide a system level interface forextending debugging capability and for supporting current debuggingtechnology. Thus, since most current debuggers go through function names,the method for implementing debugging on ordinary functions woulddiscriminate on symbols and would use the function wrapping techniquewhich most Lisps currently use for tracing. For tracing methods, thedebugging method would discriminate on a method object, and would wrapthe method function itself, since one way of implementing method dispatch is to have the generic function use the method function directly(in fact, this is how the PCL implementation works). More advanced Lisp implementation technologies might make it possible to debug the invocation of a function through the function definition object (fundef object), asyou've pointed out. By using a generic function, the usual advantages of object oriented programming, in terms of system extensibility, would be available, since the generic function would provide a portable interfacewhich each implementation could customize with the particular capibilitiesthat it can support.Below is a copy of the proposal I submitted to the objects committee inSeptember. Note that it does not appear in the current draft of the ObjectSystem specification, pending disposition of where, precisely, it belongs.I'd appreciate hearing what you think of it.		jak-------------------------------------------------------------------------------Font note: UPPERCASE indicates bold, _this_ indicates italic.TRACE-EXECUTION _object_ &KEY :ENVIRONMENT   _[Generic Function]_TRACE-EXECUTION discriminates on _object_ to select an implementationspecific method that arranges for the executable entity associatedwith _object_ to be traced. The :ENVIRONMENT keyword parameter is for those implementations which require environmental information toarrange for tracing to occur. Implementations are required to provideTRACE-EXECUTION as the system level entry point for implementing TRACEfunctionality.The exact nature and number of methods associated with TRACE-EXECUTIONwill differ, depending on what executable entities can be specifiedby TRACE, but every implementation needs to support methods which dispatch on objects having the following classes:SYMBOL-The function indicated by the symbol will be traced when invokedin the environment. METHOD-The method function is traced when invoked.GENERIC-FUNCTION-The generic function is traced when the discriminatorcode is invoked.Implementations are encouraged to provide as many methods as theimplementation technology can support.*start*06229 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 27 OCT 87 12:43:47 PSTReceived: from SCORE.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 27 Oct 87  09:33:28 PSTReceived: from hplabs.HP.COM (hplabs.hpl.hp.com.#Internet) by SCORE.STANFORD.EDU with TCP; Tue 27 Oct 87 09:22:49-PSTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Tue, 27 Oct 87 09:25:26 PSTReceived: from hplabsz.hpl.hp.com by hplms2; Tue, 27 Oct 87 09:24:51 pstReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Tue, 27 Oct 87 10:24:21 pstTo: Masinter.paCc: fahlman@c.cs.cmu.edu, cl-cleanup@sail.stanford.edu, kempf%hplabs@hplabs.HP.COMSubject: TRACE Proposal (Version 2)X-Mailer: mh6.5In-Reply-To: Your message of Wed, 21 Oct 87 09:58:09 -0700.             <24566.561833889@hplabsz> Date: Tue, 27 Oct 87 09:24:16 PSTMessage-Id: <15332.562353856@hplabsz>From: kempf%hplabsz@hplabs.HP.COM  Larry:	As requested, this version makes no mention of a break optionand cross references the format note you mentioned. I've also addeda reference to Moon's SETF-CLOS proposal, since fixing TRACE willalso be needed for it.	Is there any sense of where/whether the TRACE-EXECUTION genericfunction as a system entry point for extensible debugging is appropriate?		jak(Font Note: UPPERCASE indicates bold, _this_ indicates italic)-------------------------------------------------------------------------------Issue:         TRACE-CLOSReferences:    trace macro pp. 440-441	       TRACE-ARGUMENT-FORMAT-OPTIONS	       SETF-CLOSCategory:      MODIFICATIONEdit history:  Version 1, 21-Oct-87 Kempf	       Version 2, 27-Oct-87 KempfProblem description:With the addition of the Common Lisp Object System, there is nocommand language level way to trace individual method execution.The TRACE macro, as currently specified in Common Lisp, allowsonly tracing of globally defined functions through their names.Since a generic function name may have several executable methods,users need some way to specify that they would like invocation of particularmethods to be traced, rather than invocation of the entire genericfunction.  In addition, the current specification of TRACE does not allow tracing of functions associated with SETF "methods", of macro functions,  nor of lexically defined functions or functions invoked via. theirfunction definition objects.  While this proposal does not attempt to address the latter two problems, since identification and/or tracing of theseis likely to be implementation dependent, it does leave open the option for those implementations which can arrange it. Proposal (TRACE-CLOS::TRACE-FUNCTION-SPECIFICATION)TRACE _{function-spec}*_  _[Macro]_UNTRACE _{function-spec}*_	_[Macro]_Invoking TRACE with a function specification causes the function specifiedto be traced. Henceforth, whenever the specified function is invoked,information about the call, the arguments passed, and the returnedvalues, if any, will be printed to the stream that is the value of*TRACE-OUTPUT*. UNTRACE undoes any tracing. Calling TRACE without any arguments prints a list of currently traced executable entities, callingUNTRACE without any arguments causes tracing to be undone forall currently traced entities.A _function_spec_ is either a symbol naming a function (i.e. asymbol whose global function cell is bound to a function definitionobject, or to which the application of MACRO-FUNCTION will returna function definition object) or a list whose first element indicateswhat kind of funcallable object is to be traced and whose tail indicateswhich particular function should be traced. The complete set offunction specifications will necessarily be implementation dependent; however,every implementation is required to support the following: 	_symbol_-Invocations of the function or macrofunction named by 	         _symbol_ via. _symbol_ as a global name are traced. 	(METHOD _generic-function-name-specification_                 _{method-qualifiers}_*  	        _parameter-specializer-name-list_         ) 	If the method whose parameter specializer list, generic function 	name specification, and method qualifiers are listed is tracable, 	then invocations through the generic function name specification  	will be traced. 	(SETF _symbol_)-If the SETF function having the name specification 	is tracable, it will be traced (see proposal SETF-CLOS for 	more information on SETF name specifications).Implementations are encouraged to provide for tracing of as manyfuncallable objects as possible.Rationale:Adoption of the Common Lisp Object System will require the availabilityof debugging information on individual methods. Adoption of theSETF-CLOS proposal will require means of tracing SETF functions. It isalso not possible to easily trace either SETF functions or macrofunctionstoday.Current practice:There is currently no way to trace SETF functions, aside frommacroexpanding a SETF form and using the resulting name in aTRACE macro invocation. There is currently no way to trace macroexpansionfunctions when they are invoked through their global names, except throughcomplicated use of *MACROEXPAND-HOOK*.Adoption Cost:The proposed syntax is upwardly compatible with the current Common Lispsyntax. It will require the addition of function specification parsingand wrapper code to trace SETF function executions and macrofunctionexecutions. When the Common Lisp Object System is fully implemented,wrapper code for tracing method execution will also be required.Cost of non-adoption:Programmers will have to continue using a complicated set of Lispcommands to arrange for SETF function and macrofunction tracing.When the Common Lisp Object System is fully implemented, programmerswill have to use metaobject protocol functions to arrange for tracing.Benefits:Allow programmers to obtain information on individual methodinvocations, and on SETF function and macrofunction invocations.Conversion Cost:Minor re-write of the TRACE and UNTRACE macros, and supporting wrappergenerating functions.*start*03970 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 27 OCT 87 13:12:07 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 27 Oct 87  13:07:31 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 27 Oct 87 16:06:49-ESTDate: Tue, 27 Oct 87 16:06 ESTMessage-ID: <FAHLMAN.12345902265.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: kempf%hplabsz@HPLABS.HP.COMCc: cl-cleanup@SAIL.STANFORD.EDUSubject: TRACE Proposal (Version 2)In-reply-to: Msg of 27 Oct 1987  12:24-EST from kempf%hplabsz at hplabs.HP.COMSeveral questions and comments:1. Common Lisp does not currently require implementations to perform atrace if the function in question has been "open coded", which categorymay include compiled self-calls that do not go through thesymbol-function cell, etc.  It should be made clear that thismodificaiton does not alter that provision.2. It should be made clear that what is being traced in the case of amacro is the call to the macro-expansion function, and not the executionof the resulting code.  Trace would print the calling form going in andthe expanded form being returned.  I found the wording in the proposal abit confusing on this point.  An example would help.  Also make clearthat if macro-memoizing is going on, subsequent execution of the sameexpansion code will not be traced.    Current practice:    There is currently no way to trace SETF functions, aside from    macroexpanding a SETF form and using the resulting name in a    TRACE macro invocation. There is currently no way to trace macroexpansion    functions when they are invoked through their global names, except through    complicated use of *MACROEXPAND-HOOK*.Make that "no way that is standard across all implementations".  Someimplementations do provide some of these services.    Adoption Cost:    The proposed syntax is upwardly compatible with the current Common Lisp    syntax. It will require the addition of function specification parsing    and wrapper code to trace SETF function executions and macrofunction    executions. When the Common Lisp Object System is fully implemented,    wrapper code for tracing method execution will also be required.Can we assume that the Xerox people will put the necessary hooks intothe method-dispatching machinery?  This would considerably reduce theimplementation cost for those of us who are using PCL as the basis forour CLOS implementations.    Cost of non-adoption:    Programmers will have to continue using a complicated set of Lisp    commands to arrange for SETF function and macrofunction tracing.    When the Common Lisp Object System is fully implemented, programmers    will have to use metaobject protocol functions to arrange for tracing.This is wrong, I think.  The real cost is that implementations willprovide this functionality in varying forms and to varying degress, thusmaking it harder for users to move between one Common Lisp system andanother.  A few implementations may blow this off altogether, in whichcase their users will be screwed as described above.    Benefits:    Allow programmers to obtain information on individual method    invocations, and on SETF function and macrofunction invocations.... in a uniform way across all implemenations.    Conversion Cost:    Minor re-write of the TRACE and UNTRACE macros, and supporting wrapper    generating functions.It is possible that some implementations have made extensions to TRACEthat are incompatible with this proposal.  The only problem I can seefor those of us who currently allow a list of a function name andoptions in place of simple symbols is that now it would be ambiguous ifsomeone wanted to trace invocations fo the SETF macro.  We'll justdeclare that illegal, since it would probably blow up on you anyway.*start*06965 00024 USfReturn-Path: <kempf%hplabsz@hplabs.HP.COM>Received: from hplabs.HP.COM (hplabs.hpl.hp.com) by Xerox.COM ; 28 OCT 87 09:24:35 PSTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Wed, 28 Oct 87 09:22:10 PSTReceived: from hplabsz.hpl.hp.com by hplms2; Wed, 28 Oct 87 09:21:33 pstReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Wed, 28 Oct 87 10:21:01 pstTo: masinter.paCc: cl-cleanup@sail.stanford.edu, fahlman@c.cs.cmu.eduSubject: TRACE Proposal (Version 3)X-Mailer: mh6.5Date: Wed, 28 Oct 87 09:20:59 PSTMessage-Id: <988.562440059@hplabsz>From: kempf%hplabsz@hplabs.HP.COM(Font Note: UPPERCASE indicates bold, _this_ indicates italic)--------------------------------------------------------------------------------Issue:         TRACE-CLOSReferences:    trace macro pp. 440-441	       TRACE-ARGUMENT-FORMAT-OPTIONS	       SETF-CLOSCategory:      MODIFICATIONEdit history:  Version 1, 21-Oct-87 Kempf	       Version 2, 27-Oct-87 Kempf	       Version 3, 28-Oct-87 KempfProblem description:With the addition of the Common Lisp Object System, there is nocommand language level way to trace individual method execution.The TRACE macro, as currently specified in Common Lisp, allowsonly tracing of globally defined functions through their names.Since a generic function name may have several executable methods,users need some way to specify that they would like invocation of particularmethods to be traced, rather than invocation of the entire genericfunction.  In addition, the current specification of TRACE does not allow tracing of functions associated with SETF "methods", of macro functions,  nor of lexically defined functions or functions invoked via. theirfunction definition objects.  While this proposal does not attempt to address the latter two problems, since identification and/or tracing of theseis likely to be implementation dependent, it does leave open the option for those implementations which can arrange it. Proposal (TRACE-CLOS::TRACE-FUNCTION-SPECIFICATION)TRACE _{function-spec}*_  _[Macro]_UNTRACE _{function-spec}*_	_[Macro]_Invoking TRACE with a function specification causes the function specifiedto be traced. Henceforth, whenever the specified function is invoked,information about the call, the arguments passed, and the returnedvalues, if any, will be printed to the stream that is the value of*TRACE-OUTPUT*. UNTRACE undoes any tracing. Calling TRACE without any arguments prints a list of currently traced executable entities, callingUNTRACE without any arguments causes tracing to be undone forall currently traced entities.A _function_spec_ is either a symbol naming a function (i.e. asymbol whose global function cell is bound to a function definitionobject, or to which the application of MACRO-FUNCTION will returna function definition object) or a list whose first element indicateswhat kind of funcallable object is to be traced and whose tail indicateswhich particular function should be traced. The complete set offunction specifications will necessarily be implementation dependent; however,every implementation is required to support the following: 	_symbol_-Invocations of the function or macrofunction named by 	         _symbol_ via. _symbol_ as a global name are traced. 	(METHOD _generic-function-name-specification_                 _{method-qualifiers}_*  	        _parameter-specializer-name-list_         ) 	If the method whose parameter specializer list, generic function 	name specification, and method qualifiers are listed is tracable, 	then invocations through the generic function name specification  	will be traced. 	(SETF _symbol_)-If the SETF function having the name specification 	is tracable, it will be traced (see proposal SETF-CLOS for 	more information on SETF name specifications).Implementations are encouraged to provide for tracing of as manyfuncallable objects as possible.Note that this proposal does not change the current Common Lispspecification in the area of "open-coded" functions. In particular,implementations need not arrange for tracing of "open-coded" functions,including compiled self calls which do not go through the symbol-functioncell. In the case of tracing macro expansions, the trace is of the call tothe macroexpansion funtion and not of executing the return code. Thus thetrace function need only print the calling form arguments and theexpanded form being returned. As with "open-coded" functions, implementations which memoize the expansion code are under no obligation to report trace information once the macro code has been memoized. The example section provides an example of an interactive session tracing a macro expansion.Example: 1 [LISP] >    (defmacro test-trace (arg)1 [LISP] >      `(format T "~S~%" ,arg)1 [LISP] >    )TEST-TRACE2 [LISP] >    (trace test-trace)((MACROFUNCTION TEST-TRACE))3 [LISP] >  (test-trace 'foo)Entering macrofunction TEST-TRACE with arguments:   (QUOTE FOO)Leaving macrofunction TEST-TRACE with return values:   (FORMAT T "~S~%" (QUOTE FOO))FOO4 [LISP] >Rationale:Adoption of the Common Lisp Object System will require the availabilityof debugging information on individual methods. Adoption of theSETF-CLOS proposal will require means of tracing SETF functions. It isalso not possible to easily trace either SETF functions or macrofunctionstoday.Current practice:There is currently no way which is standard across all implementations to trace SETF functions, aside from macroexpanding a SETF form and using the resulting name in a TRACE macro invocation. There is currently no way which is standardized across all implementations to trace macroexpansionfunctions when they are invoked through their global names, except throughcomplicated use of *MACROEXPAND-HOOK*.Adoption Cost:The proposed syntax is upwardly compatible with the current Common Lispsyntax. It will require the addition of function specification parsingand wrapper code to trace SETF function executions and macrofunctionexecutions. When the Common Lisp Object System is fully implemented,wrapper code for tracing method execution will also be required.Cost of non-adoption:Implementations will provide this functionality in varying forms andto varying degrees, thus making it harder for users to move betweenone Common Lisp system and another. Some implementations may choosenot to provide the functionality, in which case users will suffer.Benefits:Allow programmers to obtain information on individual methodinvocations, and on SETF function and macrofunction invocationsin a uniform way across all implementations.Conversion Cost:Minor re-write of the TRACE and UNTRACE macros, and supporting wrappergenerating functions. Some implementations which have made extensionsto TRACE will need to accommodate those extensions with the additionalsyntax.*start*01810 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 28 OCT 87 13:09:53 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 28 Oct 87  13:04:32 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 28 OCT 87 13:05:07 PSTDate: 28 Oct 87 13:04 PSTFrom: Masinter.paSubject: Issue: TRACE-FUNCTION-ONLYIn-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Tue, 27 Oct 87 16:06 ESTTo: kempf%hplabsz@HPLABS.HP.COMcc: cl-cleanup@Sail.stanford.eduMessage-ID: <871028-130507-3318@Xerox>I'd like to see added to the discussion section that there areadditional features of TRACE not being discussed at this time but beingincluded in other proposals. I think we also need to say that weunderstand that TRACE is part of the environment rather than thelanguage and as such there are different criteria for evaluatingcompliance. (E.g.,  we might want to define a level of acceptability forembedded systems which includes all of the language but none of theenvironment, e.g.,  system intended to be imbedded in an officemachines.)I'd called this issue TRACE-FUNCTION-ONLY; the SETF proposal was calledSETF-FUNCTION-VS-MACRO in the tradition of naming issues after theproblems they solve rather than after one of the proposed solutions. I'dlike to see a few minor modifications to put this in the standard formatof cleanup proposals.Finally, maybe I'm feeling grumpy today, but I've little enthusiasm forthis. Frankly, all of the programming environment features one mightstandardize, TRACE is one of the most useless; I don't think I've TRACEdanything for the last 6 months. Adding breakpoints, yes, TRACE, no; theinformation printed is either too much or not enough.*start*01665 00024 US Return-Path: <kempf%hplabsz@hplabs.HP.COM>Received: from hplabs.HP.COM (hplabs.hpl.hp.com) by Xerox.COM ; 28 OCT 87 13:19:38 PSTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Wed, 28 Oct 87 13:19:26 PSTReceived: from hplabsz.hpl.hp.com by hplms2; Wed, 28 Oct 87 13:19:08 pstReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Wed, 28 Oct 87 14:18:41 pstTo: Masinter.paSubject: Re: Issue: TRACE-FUNCTION-ONLY X-Mailer: mh6.5In-Reply-To: Your message of 28 Oct 87 13:04:00 -0800.             <871028-130507-3318@Xerox> Date: Wed, 28 Oct 87 13:18:38 PSTMessage-Id: <4203.562454318@hplabsz>From: kempf%hplabsz@hplabs.HP.COM> Finally, maybe I'm feeling grumpy today, but I've little enthusiasm for> this. Frankly, all of the programming environment features one might> standardize, TRACE is one of the most useless; I don't think I've TRACEd> anything for the last 6 months. Adding breakpoints, yes, TRACE, no; the> information printed is either too much or not enough.Must be the rain or the stock market, Larry. :-) Frankly, I half agree withyou, but changing TRACE seems the least likely to cause major disagreement.Personally, I think adding the TRACE-EXECUTION generic function and lettingpeople put their own debugging interface on top of that (which shouldbe more visually oriented anyway) is probably a better idea. Barringthat, breakpoints would be more useful.Anyway, I'll go ahead with Version 4, putting in your comments.		jakPS: I haven't forgotten about the book outline. Maybe we can discuss itmore at X3J13, presuming you're going. I'll try to get you a revised version by then.*start*01196 00024 US Return-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 28 OCT 87 18:11:36 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Wed 28 Oct 87 21:12:59-ESTDate: Wed, 28 Oct 87 21:12 ESTMessage-ID: <FAHLMAN.12346220162.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Masinter.paSubject: Issue: TRACE-FUNCTION-ONLYIn-reply-to: Msg of 28 Oct 1987  16:04-EST from Masinter.pa at Xerox.COM    Finally, maybe I'm feeling grumpy today, but I've little enthusiasm for    this. Frankly, all of the programming environment features one might    standardize, TRACE is one of the most useless; I don't think I've TRACEd    anything for the last 6 months. Adding breakpoints, yes, TRACE, no; the    information printed is either too much or not enough.I'm just sending this to you, since others are being snowed under bymail.  Just thought I'd say that Trace is the debugging aid I use mostoften -- except for the compiler, which I use to catch all my syntaxerrors.  I can usually spot the problem right away once I see a traceand seldom have to single-step or add breaks.  Different strokes...-- Scott*start*03239 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 29 OCT 87 08:17:30 PSTReceived: from SCORE.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 29 Oct 87  08:14:17 PSTReceived: from hplabs.HP.COM (hplabs.hpl.hp.com.#Internet) by SCORE.STANFORD.EDU with TCP; Thu 29 Oct 87 08:10:36-PSTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Thu, 29 Oct 87 08:13:36 PSTReceived: from hplabsz.hpl.hp.com by hplms2; Thu, 29 Oct 87 08:13:13 pstReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Thu, 29 Oct 87 09:12:46 pstTo: Masinter.paCc: kempf%hplabsz@HPLABS.HP.COM, cl-cleanup@Sail.stanford.eduSubject: Re: Issue: TRACE-FUNCTION-ONLY X-Mailer: mh6.5In-Reply-To: Your message of 28 Oct 87 13:04:00 -0800.             <871028-130507-3318@Xerox> Date: Thu, 29 Oct 87 08:12:43 PSTMessage-Id: <17103.562522363@hplabsz>From: kempf%hplabsz@hplabs.HP.COM> I'd like to see added to the discussion section that there are> additional features of TRACE not being discussed at this time but being> included in other proposals. I think we also need to say that we> understand that TRACE is part of the environment rather than the> language and as such there are different criteria for evaluating> compliance. (E.g.,  we might want to define a level of acceptability for> embedded systems which includes all of>  the language but none of the> environment, e.g.,  system intended to be imbedded in an office> machines.)I can't seem to find the draft of Version 3 which I sent off yesterday,probably because I posted it to cl-cleanup only and didn't include myself.Since I'm not on the cl-cleanup list, I didn't get a copy. Larry, couldyou either send me a copy back, or fold these commments into Version 4 yourself? Thanks in advance.> Finally, maybe I'm feeling grumpy today, but I've little enthusiasm for> this. Frankly, all of the programming environment features one might> standardize, TRACE is one of the most useless; I don't think I've TRACEd> anything for the last 6 months. Adding breakpoints, yes, TRACE, no; the> information printed is either too much or not enough.I pretty much agree with these sentiments, however, I think that, sincemost implementors have already extended TRACE to include breakpoints,they will probably fold those extensions into the extended TRACE. Thiswill, of course, mean that the break extensions will remain nonstandard,but until everyone can agree on what extensions are correct, I think that'sthe best we can hope for.I'm more concerned about a lack of an extensible interface at the systemlevel. This is what TRACE-EXECUTION is supposed to be, along with ageneric function like PRINT-TRACE. The read-eval-print loop debuggingwhich the TRACE macro was designed for is becoming obsolete rapidly,as people move to more sophisticated environments. It would be nice tohave a set of portable interface "plugs", into which people could plugtheir experimental debugging interfaces. Without plug-compatible systemlevel interfaces, porting debugging extensions will require extensivesource access, which some implementors have been reluctant to give.		jak*start*07984 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 30 OCT 87 08:23:56 PSTReceived: from SCORE.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 30 Oct 87  08:20:43 PSTReceived: from hplabs.HP.COM (hplabs.hpl.hp.com.#Internet) by SCORE.STANFORD.EDU with TCP; Fri 30 Oct 87 08:17:14-PSTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Fri, 30 Oct 87 08:19:03 PSTReceived: from hplabsz.hpl.hp.com by hplms2; Fri, 30 Oct 87 08:18:25 pstReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Fri, 30 Oct 87 09:17:54 pstTo: masinter.paCc: fahlman@c.cs.cmu.edu, cl-cleanup@sail.stanford.edu, kempf%hplabs@hplabs.HP.COMSubject: Issue: TRACE-FUNCTION-ONLY (Version 4)X-Mailer: mh6.5Date: Fri, 30 Oct 87 08:17:51 PSTMessage-Id: <3685.562609071@hplabsz>From: kempf%hplabsz@hplabs.HP.COM(Font Note: UPPERCASE indicates bold, _this_ indicates italic)--------------------------------------------------------------------------------Issue:         TRACE-CLOSReferences:    trace macro pp. 440-441	       TRACE-ARGUMENT-FORMAT-OPTIONS	       SETF-CLOSCategory:      MODIFICATIONEdit history:  Version 1, 21-Oct-87 Kempf	       Version 2, 27-Oct-87 Kempf	       Version 3, 28-Oct-87 Kempf	       Version 4, 30-Oct-87 KempfProblem description:With the addition of the Common Lisp Object System, there is nocommand language level way to trace individual method execution.The TRACE macro, as currently specified in Common Lisp, allowsonly tracing of globally defined functions through their names.Since a generic function name may have several executable methods,users need some way to specify that they would like invocation of particularmethods to be traced, rather than invocation of the entire genericfunction.  In addition, the current specification of TRACE does not allow tracing of functions associated with SETF "methods", of macro functions,  nor of lexically defined functions or functions invoked via. theirfunction definition objects.  While this proposal does not attempt to address the latter two problems, since identification and/or tracing of theseis likely to be implementation dependent, it does leave open the option for those implementations which can arrange it. Proposal (TRACE-CLOS::TRACE-FUNCTION-SPECIFICATION)TRACE _{function-spec}*_  _[Macro]_UNTRACE _{function-spec}*_	_[Macro]_Invoking TRACE with a function specification causes the function specifiedto be traced. Henceforth, whenever the specified function is invoked,information about the call, the arguments passed, and the returnedvalues, if any, will be printed to the stream that is the value of*TRACE-OUTPUT*. UNTRACE undoes any tracing. Calling TRACE without any arguments prints a list of currently traced executable entities, callingUNTRACE without any arguments causes tracing to be undone forall currently traced entities.A _function_spec_ is either a symbol naming a function (i.e. asymbol whose global function cell is bound to a function definitionobject, or to which the application of MACRO-FUNCTION will returna function definition object) or a list whose first element indicateswhat kind of funcallable object is to be traced and whose tail indicateswhich particular function should be traced. The complete set offunction specifications will necessarily be implementation dependent; however,every implementation is required to support the following: 	_symbol_-Invocations of the function or macrofunction named by 	         _symbol_ via. _symbol_ as a global name are traced. 	(METHOD _generic-function-name-specification_                 _{method-qualifiers}_*  	        _parameter-specializer-name-list_         ) 	If the method whose parameter specializer list, generic function 	name specification, and method qualifiers are listed is tracable, 	then invocations through the generic function name specification  	will be traced. 	(SETF _symbol_)-If the SETF function having the name specification 	is tracable, it will be traced (see proposal SETF-CLOS for 	more information on SETF name specifications).Implementations are encouraged to provide for tracing of as manyfuncallable objects as possible.Note that this proposal does not change the current Common Lispspecification in the area of "open-coded" functions. In particular,implementations need not arrange for tracing of "open-coded" functions,including compiled self calls which do not go through the symbol-functioncell. In the case of tracing macro expansions, the trace is of the call tothe macroexpansion funtion and not of executing the return code. Thus thetrace function need only print the calling form arguments and theexpanded form being returned. As with "open-coded" functions, implementations which memoize the expansion code are under no obligation to report trace information once the macro code has been memoized. The example section provides an example of an interactive session tracing a macro expansion.Example: 1 [LISP] >    (defmacro test-trace (arg)1 [LISP] >      `(format T "~S~%" ,arg)1 [LISP] >    )TEST-TRACE2 [LISP] >    (trace test-trace)((MACROFUNCTION TEST-TRACE))3 [LISP] >  (test-trace 'foo)Entering macrofunction TEST-TRACE with arguments:   (QUOTE FOO)Leaving macrofunction TEST-TRACE with return values:   (FORMAT T "~S~%" (QUOTE FOO))FOO4 [LISP] >Rationale:Adoption of the Common Lisp Object System will require the availabilityof debugging information on individual methods. Adoption of theSETF-CLOS proposal will require means of tracing SETF functions. It isalso not possible to easily trace either SETF functions or macrofunctionstoday.This proposal does not address a number of additional features of TRACE(adding breakpoints, system hooks for extensible debugging, etc.) whichmay be included in other proposals. In addition, the proposal recongnizesthat TRACE is part of the enviroment, and that future versions of theCommon Lisp standard may want to specify it as such. Different criteria may therefore apply for evaluating compliance, for example, stand aloneCommon Lisp applications may not require environmental features likeTRACE which are primarily included for program development, and theircompliance to the standard should therefore not be judged on the basisof whether or not they implement such environmental features.Current practice:There is currently no way which is standard across all implementations to trace SETF functions, aside from macroexpanding a SETF form and using the resulting name in a TRACE macro invocation. There is currently no way which is standardized across all implementations to trace macroexpansionfunctions when they are invoked through their global names, except throughcomplicated use of *MACROEXPAND-HOOK*.Adoption Cost:The proposed syntax is upwardly compatible with the current Common Lispsyntax. It will require the addition of function specification parsingand wrapper code to trace SETF function executions and macrofunctionexecutions. When the Common Lisp Object System is fully implemented,wrapper code for tracing method execution will also be required.Cost of non-adoption:Implementations will provide this functionality in varying forms andto varying degrees, thus making it harder for users to move betweenone Common Lisp system and another. Some implementations may choosenot to provide the functionality, in which case users will suffer.Benefits:Allow programmers to obtain information on individual methodinvocations, and on SETF function and macrofunction invocationsin a uniform way across all implementations.Conversion Cost:Minor re-write of the TRACE and UNTRACE macros, and supporting wrappergenerating functions. Some implementations which have made extensionsto TRACE will need to accommodate those extensions with the additionalsyntax.*start*00757 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 30 OCT 87 18:56:52 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 30 Oct 87  18:54:10 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Fri 30 Oct 87 21:56:08-ESTDate: Fri, 30 Oct 87 21:56 ESTMessage-ID: <FAHLMAN.12346752309.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDU, kempf%hplabs@HPLABS.HP.COMSubject: Issue: TRACE-FUNCTION-ONLY (Version 4)In-reply-to: Msg of 30 Oct 1987  11:17-EST from kempf%hplabsz at hplabs.HP.COMOK, I can support this now.  Thanks for putting in those changes.-- Scott*start*01647 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 11:34:22 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 8 Nov 87  11:33:39 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 274773; Sun 8-Nov-87 14:33:26 ESTDate: Sun, 8 Nov 87 14:33 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TRACE-FUNCTION-ONLY (Version 4)To: kempf%hplabsz@hplabs.HP.COM, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <3685.562609071@hplabsz>Message-ID: <19871108193338.2.MOON@EUPHRATES.SCRC.Symbolics.COM>I favor version 4 of this discussion, and I favor the proposal namedTRACE-CLOS::TRACE-FUNCTION-SPECIFICATION (it's really supposed to benamed TRACE-FUNCTION-ONLY:FUNCTION-SPECIFICATION, isn't it?), providedthe Adoption Cost section is edited to point out that this is anincompatible change for several implementations that already extendCommon Lisp by defining the meaning of a non-symbol as a subform ofTRACE.  In particular, at least Symbolics Common Lisp, Xerox CommonLisp, and CMU Common Lisp define a list as a subform of TRACE tobe something other than a function-spec, and probably a lot of otherimplementations do something like this.I favor the change even though it's incompatible, because TRACE is partof the environment rather than part of the programming language, meaningthat compatibility is less of an issue, and because all of the existingextended syntaxes of TRACE that I am aware of are horrible.*start*08188 00024 US Return-Path: <kempf%hplabsz@hplabs.HP.COM>Received: from hplabs.HP.COM by Xerox.COM ; 09 NOV 87 14:43:18 PSTReceived: from hplms2 by hplabs.HP.COM with SMTP ; Mon, 9 Nov 87 14:42:54 PSTReceived: from hplabsz.hpl.hp.com by hplms2; Mon, 9 Nov 87 14:42:05 pstReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Mon, 9 Nov 87 15:41:30 pstTo: masinter.paCc: fahlman@c.cs.cmu.edu, cl-cleanup@sail.stanford.edu, kempf%hplabs@hplabs.HP.COM, Moon@STONY-BROOK.SCRC.Symbolics.COMSubject: Issue: TRACE-FUNCTION-ONLY (Version 5)X-Mailer: mh6.5Date: Mon, 09 Nov 87 15:41:27 MSTMessage-Id: <2214.563496087@hplabsz>From: kempf%hplabsz@hplabs.HP.COM(Font Note: UPPERCASE indicates bold, _this_ indicates italic)--------------------------------------------------------------------------------Issue:         TRACE-CLOSReferences:    trace macro pp. 440-441	       TRACE-ARGUMENT-FORMAT-OPTIONS	       SETF-CLOSCategory:      MODIFICATIONEdit history:  Version 1, 21-Oct-87 Kempf	       Version 2, 27-Oct-87 Kempf	       Version 3, 28-Oct-87 Kempf	       Version 4, 30-Oct-87 Kempf	       Version 5, 9-Nov-87 KempfProblem description:With the addition of the Common Lisp Object System, there is nocommand language level way to trace individual method execution.The TRACE macro, as currently specified in Common Lisp, allowsonly tracing of globally defined functions through their names.Since a generic function name may have several executable methods,users need some way to specify that they would like invocation of particularmethods to be traced, rather than invocation of the entire genericfunction.  In addition, the current specification of TRACE does not allow tracing of functions associated with SETF "methods", of macro functions,  nor of lexically defined functions or functions invoked via. theirfunction definition objects.  While this proposal does not attempt to address the latter two problems, since identification and/or tracing of theseis likely to be implementation dependent, it does leave open the option for those implementations which can arrange it. Proposal (TRACE-CLOS::TRACE-FUNCTION-SPECIFICATION)TRACE _{function-spec}*_  _[Macro]_UNTRACE _{function-spec}*_	_[Macro]_Invoking TRACE with a function specification causes the function specifiedto be traced. Henceforth, whenever the specified function is invoked,information about the call, the arguments passed, and the returnedvalues, if any, will be printed to the stream that is the value of*TRACE-OUTPUT*. UNTRACE undoes any tracing. Calling TRACE without any arguments prints a list of currently traced executable entities, callingUNTRACE without any arguments causes tracing to be undone forall currently traced entities.A _function_spec_ is either a symbol naming a function (i.e. asymbol whose global function cell is bound to a function definitionobject, or to which the application of MACRO-FUNCTION will returna function definition object) or a list whose first element indicateswhat kind of funcallable object is to be traced and whose tail indicateswhich particular function should be traced. The complete set offunction specifications will necessarily be implementation dependent; however,every implementation is required to support the following: 	_symbol_-Invocations of the function or macrofunction named by 	         _symbol_ via. _symbol_ as a global name are traced. 	(METHOD _generic-function-name-specification_                 _{method-qualifiers}_*  	        _parameter-specializer-name-list_         ) 	If the method whose parameter specializer list, generic function 	name specification, and method qualifiers are listed is tracable, 	then invocations through the generic function name specification  	will be traced. 	(SETF _symbol_)-If the SETF function having the name specification 	is tracable, it will be traced (see proposal SETF-CLOS for 	more information on SETF name specifications).Implementations are encouraged to provide for tracing of as manyfuncallable objects as possible.Note that this proposal does not change the current Common Lispspecification in the area of "open-coded" functions. In particular,implementations need not arrange for tracing of "open-coded" functions,including compiled self calls which do not go through the symbol-functioncell. In the case of tracing macro expansions, the trace is of the call tothe macroexpansion funtion and not of executing the return code. Thus thetrace function need only print the calling form arguments and theexpanded form being returned. As with "open-coded" functions, implementations which memoize the expansion code are under no obligation to report trace information once the macro code has been memoized. The example section provides an example of an interactive session tracing a macro expansion.Example: 1 [LISP] >    (defmacro test-trace (arg)1 [LISP] >      `(format T "~S~%" ,arg)1 [LISP] >    )TEST-TRACE2 [LISP] >    (trace test-trace)((MACROFUNCTION TEST-TRACE))3 [LISP] >  (test-trace 'foo)Entering macrofunction TEST-TRACE with arguments:   (QUOTE FOO)Leaving macrofunction TEST-TRACE with return values:   (FORMAT T "~S~%" (QUOTE FOO))FOO4 [LISP] >Rationale:Adoption of the Common Lisp Object System will require the availabilityof debugging information on individual methods. Adoption of theSETF-CLOS proposal will require means of tracing SETF functions. It isalso not possible to easily trace either SETF functions or macrofunctionstoday.This proposal does not address a number of additional features of TRACE(adding breakpoints, system hooks for extensible debugging, etc.) whichmay be included in other proposals. In addition, the proposal recongnizesthat TRACE is part of the enviroment, and that future versions of theCommon Lisp standard may want to specify it as such. Different criteria may therefore apply for evaluating compliance, for example, stand aloneCommon Lisp applications may not require environmental features likeTRACE which are primarily included for program development, and theircompliance to the standard should therefore not be judged on the basisof whether or not they implement such environmental features.Current practice:There is currently no way which is standard across all implementations to trace SETF functions, aside from macroexpanding a SETF form and using the resulting name in a TRACE macro invocation. There is currently no way which is standardized across all implementations to trace macroexpansionfunctions when they are invoked through their global names, except throughcomplicated use of *MACROEXPAND-HOOK*.Adoption Cost:The proposed syntax is upwardly compatible with the current Common Lispsyntax. It will require the addition of function specification parsingand wrapper code to trace SETF function executions and macrofunctionexecutions. When the Common Lisp Object System is fully implemented,wrapper code for tracing method execution will also be required.The proposed syntax may be incompatible for several implementationsthat already extend TRACE. In particular, at least Symbolics Common Lisp,Xerox Common Lisp, and CMU Common Lisp define a list as a subform ofTRACE to be something other than a function-spec. However, compatibility with existing implementations seems less of an issue here, since TRACEis more a part of the environment.Cost of non-adoption:Implementations will provide this functionality in varying forms andto varying degrees, thus making it harder for users to move betweenone Common Lisp system and another. Some implementations may choosenot to provide the functionality, in which case users will suffer.Benefits:Allow programmers to obtain information on individual methodinvocations, and on SETF function and macrofunction invocationsin a uniform way across all implementations.Conversion Cost:Minor re-write of the TRACE and UNTRACE macros, and supporting wrappergenerating functions. Some implementations which have made extensionsto TRACE will need to accommodate those extensions with the additionalsyntax.*start*01944 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 NOV 87 13:24:02 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 10 Nov 87  13:20:39 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 10 NOV 87 13:20:16 PSTDate: 10 Nov 87 13:20 PSTFrom: Masinter.paSubject: Re: Issue: TRACE-FUNCTION-ONLY (Version 5)In-reply-to: kempf%hplabsz@hplabs.HP.COM's message of Mon, 09 Nov 87 15:41:27 MSTTo: kempf%hplabsz@hplabs.HP.COMcc: cl-cleanup@sail.stanford.edu, kempf%hplabs@hplabs.HP.COMMessage-ID: <871110-132016-5562@Xerox>Proposal form:We need to decide on the name of this proposal. The mail messages havehad subject lines "TRACE Proposal" or "Issue: TRACE-FUNCTION-ONLY", butthe body of the proposal has said TRACE-CLOS. Since I've been filing itunder TRACE-FUNCTION-ONLY, I vote for changing the body to sayTRACE-FUNCTION-ONLY. (The proposal for dealing with SETF functions iscalled SETF-FUNCTION-VS-MACRO, not SETF-CLOS.)I'm a bit uneasy that some things appear under different categories thanI would have placed them (most of the discussion under Rationale is notproperly part of the rationale of this proposal but rather someadditional considerations). The discussion of Conversion Cost seems tobe a discussion of Adoption Cost instead. Conversion Cost is supposed toaddress the cost to users of converting their code to deal with aproposal, rather than to the Lisp system implementors. I think thecurrent practice and extensions to TRACE employed by variousimplementations should at least be alluded to under Current Practice.I don't know why the fact that this is a part of the environment ratherthan the language makes the burden of adoption cost any less.("However, compatibility  with existing implementations seems less of anissue here, since TRACE is more a part of the environment.")*start*02579 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 NOV 87 10:23:34 PSTReceived: from SCORE.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 11 Nov 87  10:20:30 PSTReceived: from hplabs.HP.COM (hplabs.hpl.hp.com.#Internet) by SCORE.STANFORD.EDU with TCP; Wed 11 Nov 87 10:16:31-PSTReceived: from hplms2.HP.COM (hplms2) by hplabs.HP.COM with SMTP ; Wed, 11 Nov 87 08:37:58 PSTReceived: from hplabsz.hpl.hp.com by hplms2.HP.COM; Wed, 11 Nov 87 08:37:34 pstReturn-Path: <kempf@hplabsz>Received: from hplabsz by hplabsz; Wed, 11 Nov 87 09:37:09 pstTo: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDU, kempf%hplabs@hplabs.hp.comSubject: Re: Issue: TRACE-FUNCTION-ONLY (Version 5) X-Mailer: mh6.5In-Reply-To: Your message of 10 Nov 87 13:20:00 -0800.             <871110-132016-5562@Xerox> Date: Wed, 11 Nov 87 09:37:06 MSTMessage-Id: <7575.563647026@hplabsz>From: kempf%hplabsz@hplabs.HP.COM> Proposal form:> We need to decide on the name of this proposal. The mail messages have> had subject lines "TRACE Proposal" or "Issue: TRACE-FUNCTION-ONLY", but> the body of the proposal has said TRACE-CLOS. Since I've been filing it> under TRACE-FUNCTION-ONLY, I vote for changing the body to say> TRACE-FUNCTION-ONLY. > (The proposal for dealing with SETF functions is> called SETF-FUNCTION-VS-MACRO, not SETF-CLOS.)This change sounds fine.> I'm a bit uneasy that some things appear under different categories than> I would have placed them (most of the discussion under Rationale is not> properly part of the rationale of this proposal but rather some> additional considerations). The discussion of Conversion Cost seems to> be a discussion of Adoption Cost instead. Conversion Cost is supposed to> address the cost to users of converting their code to deal with a> proposal, rather than to the Lisp system implementors. I think the> current practice and extensions to TRACE employed by various> implementations should at least be alluded to under Current Practice.I have no problem with this.> I don't know why the fact that this is a part of the environment rather> than the language makes the burden of adoption cost any less.> ("However, compatibility  with existing implementations seems less of an> issue here, since TRACE is more a part of the environment.")This was in response to a suggestion by Dave Moon, but I have no objectionif it is removed.To save time, could you fold these changes into the final document? Thanks.		jak*start*01563 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 NOV 87 18:17:12 PSTReceived: from SCRC-RIVERSIDE.ARPA by SAIL.STANFORD.EDU with TCP; 12 Nov 87  17:05:00 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 187819; Thu 12-Nov-87 18:42:39 ESTDate: Thu, 12 Nov 87 18:42 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: TRACE-FUNCTION-ONLY (Version 5) To: kempf%hplabsz@hplabs.HP.COMcc: Masinter.pa, cl-cleanup@SAIL.STANFORD.EDU, kempf%hplabs@hplabs.hp.comIn-Reply-To: <7575.563647026@hplabsz>Message-ID: <19871112234202.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Wed, 11 Nov 87 09:37:06 MST    From: kempf%hplabsz@hplabs.HP.COM    > I don't know why the fact that this is a part of the environment rather    > than the language makes the burden of adoption cost any less.    > ("However, compatibility  with existing implementations seems less of an    > issue here, since TRACE is more a part of the environment.")    This was in response to a suggestion by Dave Moon, but I have no objection    if it is removed.That's conversion cost.  There is less burden on users when we incompatiblychange something that they (relatively rarely) type in by hand, than when weincompatibly change something that appears in their programs.  I hope everyoneagrees with this, once they understand what it says, it's not a profound point.*start*03664 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 06 AUG 87 11:44:14 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 208071; Thu 6-Aug-87 14:09:57 EDTDate: Thu, 6 Aug 87 14:10 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: TRACE Proposal (Version 1)To: kempf%hplabsz@hplabs.HP.COMcc: common-lisp-object-system@SAIL.STANFORD.EDU, Masinter.paIn-Reply-To: <8707311807.AA10361@hplabsz.hpl.hp.com>Message-ID: <870806141000.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Fri, 31 Jul 87 12:07:37 MST    From: kempf%hplabsz@hplabs.HP.COM    As promised, here is an initial draft of a proposal for modifying the    TRACE macro (CLtL, pp. 440-441) to better support object-oriented    programming....This looks interesting.  I have a couple of comments to offer right now.    A function-spec is either a symbol naming a function (i.e. a symbol    whose global function cell is bound to a function definition object)    or a list whose first element is a function specification type, and     whose tail indicates which particular function of that type should     be traced. The Cleanup subcommittee of X3J13 were discussing something similara while back, starting from a different point.  The DOCUMENTATION functionof Common Lisp introduces the concept of "definition types", and thisconcept could be useful in other operations.  For instance, it would benice to be able to remove any definition (function, variable, type, setf)through a uniform interface.  "Definition type" and "function spec type"are not the same concept, however there seems to be enough overlap herethat some coordination is probably called for.I don't remember for sure, but I think Larry Masinter volunteered to makea proposal for "definition types" when he got time.    ....    Note: Another useful enhancement would be to support a :BREAK flag, like    this:	    (:METHOD <spec>  :BREAK)    indicating that a break loop should be entered before and after the    function executes.Here you see a conflict between lists as function-specs and lists aslists of options, in the arguments to TRACE.  Because of this your proposalfor TRACE is not compatible with what Symbolics currently does, but I don'tthink that's too important for us.  We say that a list is a list of options,and if you want to trace a function whose name is a list, you have to do(TRACE (:function <function-spec> <options>...)).  But all this reallyshows is that the syntax of TRACE is ridiculous.  I usually ignore the TRACEfunction and trace things through a command interface.  Anyway, for yourproposal you have to decide between lists as function specs and lists asoptions; I don't think you can mix them freely as you proposed.  Of courseit would be a lot easier if TRACE only traced one function at a time,then the rest of the form could be used for options.  That would be a bitincompatible with CLtL.    TRACE-EXECUTION object &OPTIONAL env		[Generic Function]I didn't completely understand this.  It looks like there is someincoherence about whether TRACE is an operation on functions or onplaces in which you can store a function definition.  In other words,does tracing a function redefine the function or alter the object thatis the function's definition?  In other words, does  (defun foo () ...)  (setq f #'foo)  (trace foo)  (funcall f)generate trace-output or not?  We have to decide one way or the other.CLtL is obscure on this point.*start*01073 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAY 88 13:48:17 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 May 88  13:46:42 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 MAY 88 13:43:39 PDTDate: 23 May 88 13:43 PDTFrom: masinter.paSubject: Issue: TRACE-FUNCTION-ONLY to: CL-CLEANUP@Sail.stanford.educc: Kempf@sun.comMessage-ID: <880523-134339-5261@Xerox>My notes from our subcommittee meeting was that we wanted to handle this issueas a "make it undefined".  However, in re-reading CLtL, I find that the languagethere is perfectly adequate for handling the situation ("trace and untrace mayalso accept additional implementation-dependent argument formats. The format ofthe trace output is implementation-dependent.") I no longer have any enthusiasm for pushing on this issue. If anyone wants to pursue the issue in its current form, I would like to see adiscussion section saying that I think it is unnecessary.