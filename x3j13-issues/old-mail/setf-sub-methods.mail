*start*03755 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 21 SEP 87 14:39:10 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 21 Sep 87  14:36:39 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 238094; Mon 21-Sep-87 17:37:55 EDTDate: Mon, 21 Sep 87 17:36 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-METHOD-FOR-SYMBOLS (version 1)To: CL-Cleanup@sail.stanford.eduSupersedes: <870921172903.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <870921173659.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Issue:         SETF-METHOD-FOR-SYMBOLSReferences:    CLtL pp. 105, 99Category:      CHANGEEdit history:  Version 1   Moon 21 Sep 87Problem description:The description of SETF in CLtL is inconsistent in that page 99requires side-effects to be elaborated in left-to-right order,while page 105 specifies a setf-method for symbols that makesit impossible to implement this in some cases, such as the testcase given below (provided by Timothy Daly of IBM).Proposal: SETF-METHOD-FOR-SYMBOLS:TEMPORARY-VARIABLEChange the result of (get-setf-method 'foo) fromNIL NIL (#:G1174) (SETQ FOO #:G1174) FOOto(#:G1175) (FOO) (#:G1174) (SETQ FOO #:G1174) #:G1175Test Case:Given (setq r '(a 1 b 2 c 3)) (setq s r) (setf (getf r 'b) (progn (setq r nil) 6))what is the value of R and S?If side-effects are elaborated in left-to-right order,the setq of R to NIL should not affect the result, sinceit occurs after R is read and before R is written, andtherefore the value of both R and S should be (A 1 B 6 C 3).A typical result in an implementation that believes CLtL p.105more than CLtL p.99 is R = (B 6) and S = (A 1 B 2 C 3).Rationale:The general principle mentioned on p.99 should override thespecific example on p.105.  The latter is probably just a mistake.Current practice:Symbolics and Lucid return the incorrect result mentioned in the testcase above.  Franz returns something else: r = nil and s = (a 1 b 6 c 3).Symbolics plans to fix this in the next release.Adoption Cost:SETF is an intricate part of Common Lisp, and the fact that not allimplementations currently return the same thing indicates that somecare might be required in updating implementations.  However, insome implementations changing what get-setf-method returns when itsargument is a symbol is the only change required.It's been pointed out that this change might cause less efficient codeto be produced in some cases, since setf methods will involve moretemporary variables, however Moon believes that the optimizations arenot difficult and probably are already done by most implementations.Cost of non-adoption:Users will think SETF is complicated and hard to understand, becauseimplementations won't conform to a simple general principle thatside-effects are elaborated in left-to-right order.Benefits:The opposite of what I just said.Conversion Cost:This change is incompatible because it changes the result of some formsthat are not erroneous.  However, it's unlikely that very many users areintentionally depending on the current behavior.  In addition, thecurrent behavior is not consistent across implementations, which makeschanging it less problematic.Esthetics:See "cost of non-adoption".Discussion:I wish CLtL did a much better job of explaining the philosophy of SETF,and included some better examples of precisely what is meant by the"`obvious' semantics" mentioned on page 99.  I will accept some of theblame for this lack in the documentation. --Moon*start*02152 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 21 SEP 87 19:59:12 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 21 Sep 87  19:56:53 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Mon 21 Sep 87 22:57:14-EDTDate: Mon, 21 Sep 87 22:57 EDTMessage-ID: <FAHLMAN.12336528894.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Issue: SETF-METHOD-FOR-SYMBOLS (version 1)In-reply-to: Msg of 21 Sep 1987  17:36-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>I tried Daly's example in Spice Lisp, and it gave what Moon proposes asthe intuitive answer: both R and S end up with (A 1 B 6 C 3).  And inthe same Lisp, (get-setf-method 'foo) returns the values prescribed inCLtL: nil nil (#:G1) (setq foo #:G1) foo.  So the statement in Moon'sproposal that Daly's example is impossible to implement with with thisset of values is false.  There might be other examples which dictate thechange in get-setf-method that Moon proposes, but this particularcase does not force the issue.The trick here is that the get-setf-method value-set for Getf sets upall of the necessary bindings, rather than doing this in the method fora symbol:(get-setf-method '(getf a b)) =>(#:G1 #:G2)(A B)(#:G3)(progn (setq #:G1 (%putf #:G1 #:G2 #:G3))       (setq A #:G1)       #:G3)(getf #:G1 #:G2)Is there some problem here I don't see?For what it's worth, I get the following:(setf (getf (nthcdr 2 r) 'b) (progn (setq r nil) 6))r = nil, s = (a 1 b 6 c 3)(setf (nthcdr 2 r) (progn (setq r nil) 6))r= nil, s = (a 1 . 6)I think that these values are right, since changing the tail of the oldvalue of R can't set anything back into R to override the explict SETQ.Anyone disagree?  Our code gets no failures trying to setq the nthcdr ofnil, or whatever.Unless I'm missing something, I would say that these examples shoot downMoon's proposal in its current form.-- Scott*start*01348 00024 US Return-Path: <@SAIL.STANFORD.EDU:dcm%hpfclp@hplabs.HP.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 22 SEP 87 13:02:25 PDTReceived: from HPLABS.HP.COM by SAIL.STANFORD.EDU with TCP; 22 Sep 87  13:00:11 PDTReceived: from hpfcdcm.HP.COM by hpfclp.HP.COM; Tue, 22 Sep 87 10:59:27 mdtReceived: from hpfcdcm by hpfcdcm.HP.COM; Tue, 22 Sep 87 10:58:59 mdtReturn-Path: <dcm@hpfcdcm>To: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: SETF-METHOD-FOR-SYMBOLS (version 1) X-Mailer: mh6.5In-Reply-To: Your message of Mon, 21 Sep 87 17:36:00 -0400.             <870921173659.3.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Tue, 22 Sep 87 10:58:55 MSTMessage-Id: <3760.559328335@hpfcdcm>From: Dave Matthews <dcm%hpfclp@hplabs.HP.COM>HP's Common Lisp produced the desired results, namely r and s havingidentical values.  I agree that this change would be beneficial to thelanguage and should not adversely impact the performance of mostimplementations.1 LISP [USER:] > (setq r '(a 1 b 2 c 3))(A 1 B 2 C 3)2 LISP [USER:] > (setq s r)(A 1 B 2 C 3)3 LISP [USER:] > (setf (getf r 'b) (progn (setq r nil) 6))64 LISP [USER:] > r(A 1 B 6 C 3)5 LISP [USER:] > s(A 1 B 6 C 3)6 LISP [USER:] > (eq r s)TDave Matthews*start*03941 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 22 SEP 87 07:57:30 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 22 Sep 87  07:55:55 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 238559; Tue 22-Sep-87 10:57:35 EDTDate: Tue, 22 Sep 87 10:56 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-METHOD-FOR-SYMBOLS (version 1)To: Scott E. Fahlman <Fahlman@C.CS.CMU.EDU>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12336528894.BABYL@C.CS.CMU.EDU>Message-ID: <870922105646.9.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 21 Sep 1987  22:57 EDT    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    I tried Daly's example in Spice Lisp, and it gave what Moon proposes as    the intuitive answer: both R and S end up with (A 1 B 6 C 3).  And in    the same Lisp, (get-setf-method 'foo) returns the values prescribed in    CLtL: nil nil (#:G1) (setq foo #:G1) foo.  So the statement in Moon's    proposal that Daly's example is impossible to implement with with this    set of values is false.  There might be other examples which dictate the    change in get-setf-method that Moon proposes, but this particular    case does not force the issue.    The trick here is that the get-setf-method value-set for Getf sets up    all of the necessary bindings, rather than doing this in the method for    a symbol:    (get-setf-method '(getf a b)) =>    (#:G1 #:G2)    (A B)    (#:G3)    (progn (setq #:G1 (%putf #:G1 #:G2 #:G3))	   (setq A #:G1)	   #:G3)    (getf #:G1 #:G2)    Is there some problem here I don't see?Doesn't this only show that getf's setf-method is calling a privatecopy of get-setf-method for the first argument, rather than recursivelycalling the regular get-setf-method?  If not, how did it know that atemporary variable needed to be bound to a?  Perhaps it just alwaysbinds a temporary variable to any first argument; but then the differencebetween the CLtL setf-method for variables and my proposed new oneis ignored by Spice Lisp in this case.It's true that I shouldn't have said it was impossible to implement setfcorrectly in the face of the setf-method prescribed by CLtL.  I shouldhave realized that an implementation was free to introduce moretemporary variables than the ones implied by the setf-method.  However,consider this example, using the setf-method for ldb prescribed by CLtLpage 106:(setq a 0)(incf (ldb (byte 2 2) a) (setq a 2))Does this leave a=8, a=10, or a=2?  I believe 8 is what is intended bypage 99's statement about order of evaluation of subforms.Note that no arguments about an implementation having its own setf methodfor ldb are relevant here.  If users are to be able to write hairy setfmethods in portable code, which I assume is a goal otherwise why did wedocument all this stuff, then setf-methods written in the style of theone CLtL gives for LDB have to work portably and produce equivalent effectsin all implementations.    For what it's worth, I get the following:    (setf (getf (nthcdr 2 r) 'b) (progn (setq r nil) 6))    r = nil, s = (a 1 b 6 c 3)    (setf (nthcdr 2 r) (progn (setq r nil) 6))    r= nil, s = (a 1 . 6)    I think that these values are right, since changing the tail of the old    value of R can't set anything back into R to override the explict SETQ.I agree.    Anyone disagree?  Our code gets no failures trying to setq the nthcdr of    nil, or whatever.    Unless I'm missing something, I would say that these examples shoot down    Moon's proposal in its current form.Do you still think that after seeing my reaction above?  If so, I think weneed to back off and consider precisely what CLtL p.99 was supposed to besaying.*start*02017 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 22 SEP 87 08:57:04 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 22 Sep 87  08:54:34 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 22 Sep 87 11:54:13-EDTDate: Tue, 22 Sep 87 11:54 EDTMessage-ID: <FAHLMAN.12336670332.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Issue: SETF-METHOD-FOR-SYMBOLS (version 1)In-reply-to: Msg of 22 Sep 1987  10:56-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>Well, here's our setf method for Getf.  It clearly is not using someprivate method to get symbols right, but is using the standard setfmethod for whatever the first form is.  It seems to me that the way itis using the store variable from the first subform is fairlystraightforward, and doesn't introduce more temporaries than would beneeded under your scheme, but I could be wrong.Can you show me the Getf method that would result from your proposed wayof handling the symbol values?  Is it significantly simpler or moreefficient?  When it comes to efficiency, I'd rather have a little extravariable shuffling in Getf and places like that than in all setf'sinvolving a symbol destination.(define-setf-method getf (place prop &optional default &environment env)  (multiple-value-bind (temps values stores set get)		       (get-setf-method place env)    (let ((newval (gensym))	  (ptemp (gensym))	  (def-temp (gensym)))      (values `(,@temps ,(car stores) ,ptemp ,@(if default `(,def-temp)))	      `(,@values ,get ,prop ,@(if default `(,default)))	      `(,newval)	      `(progn (setq ,(car stores)			    (%primitive putf ,(car stores) ,ptemp ,newval))		      ,set		      ,newval)	      `(getf ,(car stores) ,ptemp ,@(if default `(,def-temp)))))))-- Scott*start*00985 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 22 SEP 87 09:07:10 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 22 Sep 87  09:05:07 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 22 Sep 87 12:05:27-EDTDate: Tue, 22 Sep 87 12:05 EDTMessage-ID: <FAHLMAN.12336672387.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Issue: SETF-METHOD-FOR-SYMBOLS (version 1)In-reply-to: Msg of 22 Sep 1987  10:56-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>Maybe we should fix the manual's definition for setf of ldb rather thanthe values returned for symbol?  Or if fixing ldb is really too hairyunder the current setf definition, maybe this shold be the example weuse in the cleanup proposal.-- Scott*start*01227 00024 US Originator: @SAIL.STANFORD.EDU:DALY%IBM:COM:XeroxDate:  9 Sep 87 08:29From: DALY%ibm:COM:XeroxSubject: setf order of evaluationTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Timothy Daly <DALY@ibm.com>To: common-lisp@sail.stanford.eduSubject: setf order of evaluationReturn-Path: <@SAIL.STANFORD.EDU:DALY@IBM.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 09 SEP 87 08:29:08 PDTReceived: from IBM.COM by SAIL.STANFORD.EDU with TCP; 9 Sep 87  08:03:05 PDTOriginal-Date: 9 September 1987, 10:31:51 EDTMessage-Id: <090987.103153.daly@ibm.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGiven (setq r '(a 1 b 2 c 3)) (setq s r) (setf (getf r 'b) (progn (setq r nil) 6))what is the value of R and S?Note that P97 of CLtL states that SETF guarantees theleft-to-right order of evaluation of its arguments.(yes, i know it is crufty to change R).Both Symbolics and Lucid seem to generate R = (B 8) and S = (A 1 B 2 C 3)which implies that the second argument of setfis evaluated first. What did I miss?timDALY@IBM.COMIBM T.J. Watson Research CenterYorktown Heights, N.Y. 10598*start*02606 00024 US Originator: @SAIL.STANFORD.EDU:Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxDate:  9 Sep 87 12:16From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: setf order of evaluationIn-Reply-to: <090987.103153.daly@ibm.com>To: DALY%ibm:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: setf order of evaluationTo: Timothy Daly <DALY@ibm.com>cc: common-lisp@sail.stanford.eduIn-Reply-To: <090987.103153.daly@ibm.com>Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 09 SEP 87 12:15:16 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 9 Sep 87  11:39:43 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 230463; Wed 9-Sep-87 14:40:44 EDTOriginal-Date: Wed, 9 Sep 87 14:40 EDTMessage-ID: <870909144023.7.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: 9 September 1987, 10:31:51 EDT    From: Timothy Daly <DALY@ibm.com>    Given     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6))    what is the value of R and S?    Note that P97 of CLtL states that SETF guarantees the    left-to-right order of evaluation of its arguments.    (yes, i know it is crufty to change R).    Both Symbolics and Lucid seem to generate     R = (B 8) and S = (A 1 B 2 C 3)    which implies that the second argument of setf    is evaluated first. What did I miss?It's not a good idea to speak of "arguments" when dealing withforms that aren't function calls.  It's less confusing to speakof subforms.  The subforms of that setf that get evaluated are  r  'b  (progn (setq r nil) 6)so I think the behavior you describe is a bug (although the descriptionin CLtL is so ambiguous that the implementors of the respective systemscould easily disagree with me.)I didn't look inside the Lucid implementation, but in the Symbolics implementation the source of the bug is that (get-setf-method 'r)returns NIL, NIL, (#:G6411), (SETQ R #:G6411), R, whereas it shouldreturn (#:G6410), (R), (#:G6411), (SETQ R #:G6411), #:G6410.  SeeCLtL page 104 for the description of the meaning of these values.Changing it to return the latter makes your SETF example behave as youexpected, evaluating R -before- bashing it, and setq'ing it to the updatedproperty list -after- setq'ing it to nil.*start*03023 00024 US Originator: @SAIL.STANFORD.EDU:Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxDate: 11 Sep 87 12:23From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: setf order of evaluationIn-Reply-to: <870910231312.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>To: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: setf order of evaluationTo: common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <870910231312.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 11 SEP 87 12:23:14 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 11 Sep 87  11:43:53 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 232057; Fri 11-Sep-87 14:44:54 EDTOriginal-Date: Fri, 11 Sep 87 14:44 EDTMessage-ID: <870911144430.9.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 10 Sep 87 23:13 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>[philosophy for future languages deleted]    As food for thought, consider the following examples...     ;; #1: The case in question (using a variable as a place)     (PROGN (SETQ R '(A 1 B 2 C 3))	    (SETQ S R)	    (SETF (GETF R 'B) (PROGN (SETQ R NIL) 6))	    (VALUES R S))     ;; #2: The case in question (using a non-variable as a place)     (PROGN (SETQ R '(A 1 B 2 C 3))	    (SETQ S R)	    (SETF (GETF (NTHCDR 2 R) 'B) (PROGN (SETQ R NIL) 6))	    (VALUES R S))Definitely an illuminating case.  This blows up trying to RPLACD NILwith the get-setf-method of variables prescribed by CLtL, but doeswhat one would expect with the get-setf-method of variables I suggestedthe other day.  Also illuminating:;; #2a: doesn't use GETF at all(PROGN (SETQ R '(A 1 B 2 C 3))       (SETQ S R)       (SETF (NTHCDR 2 R) (PROGN (SETQ R NIL) 6))       (VALUES R S))which again blows up with CLtL's setf-method for variables, but doeswhat one would expect with the one I suggested.  These two exampleschanged my mind; now I think the one I suggested is obviously right,and the one in CLtL, evidently used by Symbolics and Lucid (and nodoubt other implementations) is obviously wrong.     ;; #3: This can't work, but think hard about why not.Works fine for me, and returns the same values as #1.     ;;     There's a sense in which it feels like it ought to be identical     ;;     to #1 above.     (PROGN (SETQ R '(A 1 B 2 C 3))	    (SETQ S R)	    (SETF (GETF (NTHCDR 0 R) 'B) (PROGN (SETQ R NIL) 6))	    (VALUES R S))     ;; #4: This is not as much like the others, but I found its return     ;;     value to be instructive anyway.     (PROGN (SETQ R '(A 1 B 2 C 3))	    (SETQ S R)	    (SETF (CAR R) (PROGN (SETQ R NIL) 6))	    (VALUES R S))Nothing surprising here.*start*02983 00024 US Originator: @SAIL.STANFORD.EDU,@RELAY.CS.NET:HELLER@cs.umass.edu%Xerox:COM:XeroxDate: 11 Sep 87 23:11From: "HELLER%cs.umass.edu%RELAY.CS.NET":GV:XeroxSubject: RE: setf order of evaluationTo: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Stride 440 User <HELLER%cs.umass.edu@RELAY.CS.NET>Subject: RE: setf order of evaluationTo: common-lisp@SAIL.STANFORD.EDUReturn-Path: <@SAIL.STANFORD.EDU,@RELAY.CS.NET:HELLER@cs.umass.edu>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 11 SEP 87 23:11:14 PDTReceived: from RELAY.CS.NET by SAIL.STANFORD.EDU with TCP; 11 Sep 87  22:40:27 PDTReceived: from relay2.cs.net by RELAY.CS.NET id ag06485; 12 Sep 87 1:40 EDTReceived: from cs.umass.edu by RELAY.CS.NET id an18149; 12 Sep 87 1:31 EDTOriginal-Date: Fri, 11 Sep 87 09:45 EDTX-VMS-To: IN%"common-lisp@sail.stanford.edu"GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> From: Timothy Daly <DALY@ibm.com>> To: common-lisp@SAIL.STANFORD.EDU> > Given> >  (setq r '(a 1 b 2 c 3))>  (setq s r)>  (setf (getf r 'b) (progn (setq r nil) 6))> > what is the value of R and S?> > Note that P97 of CLtL states that SETF guarantees the> left-to-right order of evaluation of its arguments.> > (yes, i know it is crufty to change R).> > Both Symbolics and Lucid seem to generate>  R = (B 8) and S = (A 1 B 2 C 3)VAXLISP Version U2.2 does the same thing:LLVS (ll)> (setq r '(a 1 b 2 c 3)) ...(a 1 b 2 c 3)LLVS (ll)> (setq s r) ...(a 1 b 2 c 3)LLVS (ll)> (setf (getf r 'b) (progn (setq r nil) 6)) ...6LLVS (ll)> s ...(a 1 b 2 c 3)LLVS (ll)> r ...(b 6)LLVS (ll)> (get-setf-method '(getf r b)) ...(#:g430)(b)(#:g429)(do* ((#:g431 r)       (#:g432 #:g431 (cddr #:g432)))     ((atom #:g432)      (let ((#:g428 (list* #:g430 #:g429 #:g431))) (setq r #:g428))      #:g429)  (cond ((atom (cdr #:g432))         (error "Odd length property list in SETF of GETF."))        ((eq (car #:g432) #:g430)         (rplaca (cdr #:g432) #:g429)         (return #:g429))))(getf r #:g430 nil)LLVS (ll)> (setq r '(a 1 b 2 c 3)) ...(a 1 b 2 c 3)LLVS (ll)> (setq s r) ...(a 1 b 2 c 3)LLVS (ll)> (macroexpand '(setf (getf r 'b) (progn (setq r nil) 6))) ...(let* ((#:g446 'b)        (#:g445 (progn                 (setq r nil)                  6)))  (do* ((#:g447 r)         (#:g448 #:g447 (cddr #:g448)))       ((atom #:g448)        (let ((#:g444 (list* #:g446 #:g445 #:g447))) (setq r #:g444))        #:g445)    (cond ((atom (cdr #:g448))           (error "Odd length property list in SETF of GETF."))          ((eq (car #:g448) #:g446)           (rplaca (cdr #:g448) #:g445)           (return #:g445)))))t		Robert HellerARPANet:	Heller@CS.UMass.EDUBITNET:		Heller@UMass.BITNETBIX:		HellerGEnie:		RHellerFidoNet:	321/148 (Locks Hill BBS, Wendell, MA)CompuServe	71450,3432Local PV VAXen:	COINS::HELLERUCC Cyber/DG:	Heller@CS*start*03309 00024 US Originator: @SAIL.STANFORD.EDU:franz!ficl!drb%ucbarpa.Berkeley:EDU:XeroxDate: 10 Sep 87 19:55From: franz!ficl!drb%ucbarpa.Berkeley:EDU:XeroxIn-Reply-to: David A. Moon's message of Wed, 9 Sep 87 14:40 EDT <870909144023.7.MOON@EUPHRATES.SCRC.Symbolics.COMSubject: setf order of evaluationTo: Moon%stony-brook.scrc.symbolics:COM:Xeroxcc: DALY%ibm:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: franz!ficl!drb@ucbarpa.Berkeley.EDU (David Barton)To: Moon@stony-brook.scrc.symbolics.comCc: DALY@ibm.com, common-lisp@sail.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 9 Sep 87 14:40 EDT <870909144023.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: setf order of evaluationReturn-Path: <@SAIL.STANFORD.EDU:franz!ficl!drb@ucbarpa.Berkeley.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 10 SEP 87 19:54:43 PDTReceived: from UCBARPA.Berkeley.EDU by SAIL.STANFORD.EDU with TCP; 10 Sep 87  19:19:50 PDTReceived: by ucbarpa.Berkeley.EDU (5.58/1.25)	id AA20402; Thu, 10 Sep 87 19:20:51 PDTReceived: from ficl by franz (5.5/3.14)	id AA00482; Thu, 10 Sep 87 18:29:10 PDTReceived: by ficl (5.5/3.14)	id AA02338; Wed, 9 Sep 87 14:39:55 PDTOriginal-Date: Wed, 9 Sep 87 14:39:55 PDTReturn-Path: <drb>Message-Id: <8709092139.AA02338@ficl>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV   Date: Wed, 9 Sep 87 14:40 EDT   From: David A. Moon <franz!STONY-BROOK.SCRC.Symbolics.COM!Moon>       Date: 9 September 1987, 10:31:51 EDT       From: Timothy Daly <DALY@ibm.com>       Given	(setq r '(a 1 b 2 c 3))	(setq s r)	(setf (getf r 'b) (progn (setq r nil) 6))       what is the value of R and S?       Note that P97 of CLtL states that SETF guarantees the       left-to-right order of evaluation of its arguments.       (yes, i know it is crufty to change R).       Both Symbolics and Lucid seem to generate	R = (B 8) and S = (A 1 B 2 C 3)       which implies that the second argument of setf       is evaluated first. What did I miss?   It's not a good idea to speak of "arguments" when dealing with   forms that aren't function calls.  It's less confusing to speak   of subforms.  The subforms of that setf that get evaluated are     r     'b     (progn (setq r nil) 6)   so I think the behavior you describe is a bug (although the description   in CLtL is so ambiguous that the implementors of the respective systems   could easily disagree with me.)   I didn't look inside the Lucid implementation, but in the Symbolics    implementation the source of the bug is that (get-setf-method 'r)   returns NIL, NIL, (#:G6411), (SETQ R #:G6411), R, whereas it should   return (#:G6410), (R), (#:G6411), (SETQ R #:G6411), #:G6410.  See   CLtL page 104 for the description of the meaning of these values.   Changing it to return the latter makes your SETF example behave as you   expected, evaluating R -before- bashing it, and setq'ing it to the updated   property list -after- setq'ing it to nil.Franz Inc.'s Common Lisp ("Allegro CL") ends up with r = nil ands = (a 1 b 6 c 3).  However, it returns the same 5 forms for(get-setf-method 'r) that Symbolics does, and in fact these 5 formsare given as an example on p. 105 of CLtL.*start*03944 00024 US Originator: @SAIL.STANFORD.EDU:KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxDate: 10 Sep 87 20:53From: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: setf order of evaluationIn-Reply-to: <8709092139.AA02338@ficl>To: franz!ficl!drb%ucbarpa.Berkeley:EDU:Xerox, Moon%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: DALY%ibm:COM:Xerox, common-lisp%sail.stanford:EDU:Xerox, KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: setf order of evaluationTo: franz!ficl!drb@ucbarpa.Berkeley.EDU, Moon@STONY-BROOK.SCRC.Symbolics.COMcc: DALY@ibm.com, common-lisp@sail.stanford.edu, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <8709092139.AA02338@ficl>Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 10 SEP 87 20:53:38 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 10 Sep 87  20:13:18 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 231604; Thu 10-Sep-87 23:13:39 EDTOriginal-Date: Thu, 10 Sep 87 23:13 EDTMessage-ID: <870910231312.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI believe the root of this problem is bad interplay between thefollowing two design issues: * I think it was a big mistake to make (SETF var val) work.   Anyone who's ever implemented SETF knows there's something   strange about variables that they have to be handled so   differently than structure accessors. The sense in which   SETQ makes a side-effect (to a structure which is effectively   not user-accessible as a first-class object (in dialects not   having a LOCF extension)) is different than the sense in   which RPLACA makes a side-effect.   The fact that    (DEFUN F (X Y) (PUSH X Y) Y)   is so radically different in its I/O behavior than    (DEFUN F (X Y) (PUSH X (CDR Y)) Y)   is symptomatic of the problem I'm citing. * I think there's something odd about GETF in that it takes   a place as an argument, but nothing can enforce that. eg,   (GETF '(A B C D) 'C) works, even though (QUOTE ...) is not   a place. If you try to SETF it, you see the error of your   ways. The fact that SETF has to reach through the GETF to   get its first argument and fool with it is what leads to a   problem like the one I was mentioning above. I don't think there's much we can do about this (short of documentingclearly how this particular special case (and others like it) should bedealt with). I think it's doomed to be somewhat of an embarrassmentbecause we've chosen to create a system of rules which I thinkinherently cannot generalize in a completely satisfying way.I'm not advocating that we change SETF at this late date, but if I weredesigning a new language, I'd sure advocate doing things differently.As food for thought, consider the following examples... ;; #1: The case in question (using a variable as a place) (PROGN (SETQ R '(A 1 B 2 C 3))        (SETQ S R)        (SETF (GETF R 'B) (PROGN (SETQ R NIL) 6))        (VALUES R S)) ;; #2: The case in question (using a non-variable as a place) (PROGN (SETQ R '(A 1 B 2 C 3))        (SETQ S R)        (SETF (GETF (NTHCDR 2 R) 'B) (PROGN (SETQ R NIL) 6))        (VALUES R S)) ;; #3: This can't work, but think hard about why not. ;;     There's a sense in which it feels like it ought to be identical ;;     to #1 above. (PROGN (SETQ R '(A 1 B 2 C 3))        (SETQ S R)        (SETF (GETF (NTHCDR 0 R) 'B) (PROGN (SETQ R NIL) 6))        (VALUES R S)) ;; #4: This is not as much like the others, but I found its return ;;     value to be instructive anyway. (PROGN (SETQ R '(A 1 B 2 C 3))        (SETQ S R)        (SETF (CAR R) (PROGN (SETQ R NIL) 6))        (VALUES R S))*start*02537 00024 US Originator: @SAIL.STANFORD.EDU:Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxDate: 21 Sep 87 14:51From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Re: setf order of evaluationIn-Reply-to: <[G.BBN.COM]10-Sep-87 10:40:24.NGALL>To: NGALL%G.BBN:COM:Xeroxcc: DALY%IBM:COM:Xerox, common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: setf order of evaluationTo: NGALL@G.BBN.COMcc: DALY@IBM.COM, common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <[G.BBN.COM]10-Sep-87 10:40:24.NGALL>Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 21 SEP 87 14:51:52 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 21 Sep 87  14:10:39 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 238035; Mon 21-Sep-87 17:11:32 EDTOriginal-Date: Mon, 21 Sep 87 17:10 EDTMessage-ID: <870921171049.0.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: 10 Sep 1987 10:40-EDT    From: NGALL@G.BBN.COM		Date: Wed, 9 Sep 87 14:40 EDT	From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>	I didn't look inside the Lucid implementation, but in the Symbolics 	implementation the source of the bug is that (get-setf-method 'r)	returns NIL, NIL, (#:G6411), (SETQ R #:G6411), R, whereas it should	return (#:G6410), (R), (#:G6411), (SETQ R #:G6411), #:G6410.  See	CLtL page 104 for the description of the meaning of these values.    	Changing it to return the latter makes your SETF example behave as you	expected, evaluating R -before- bashing it, and setq'ing it to the updated	property list -after- setq'ing it to nil.    Unfortunately, on pg 105 the setf method for the variable X is defined    to be () () (#:g0001) (setq X #:g0001) X.  So if this is the right    place to fix things, then CLtL must be fixed too.  This is fine with    me, but it would make SETF methods less efficient (or require them to    be more intelligent about optimizing).I'm told Symbolics will be fixing our next release to do what I said Ithought was right, rather than what CLtL says.  I guess that obligates meto write this up and submit it to the cleanup committee, which I will do.I don't take the efficiency issue very seriously; it's very easy tooptimize the cases in question, in my opinion.*start*03345 00024 US Originator: @SAIL.STANFORD.EDU:NGALL%G.BBN:COM:XeroxDate: 23 Sep 87 22:49Subject: Re: setf order of evaluationFrom: NGALL%G.BBN:COM:XeroxIn-Reply-to: <870911144430.9.MOON@EUPHRATES.SCRC.Symbolics.COM>To: Moon%SCRC-STONY-BROOK:ARPA:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <@SAIL.STANFORD.EDU:NGALL@G.BBN.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 23 SEP 87 22:49:41 PDTReceived: from G.BBN.COM by SAIL.STANFORD.EDU with TCP; 23 Sep 87  22:06:51 PDTOriginal-Date: 24 Sep 87 01:04 EDTMessage-ID: <[G.BBN.COM]24-Sep-87 01:04:44.NGALL>	    Date: Fri, 11 Sep 87 14:44 EDT    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    	Date: Thu, 10 Sep 87 23:13 EDT	From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>             ... 	 ;; #2: The case in question (using a non-variable as a place)	 (PROGN (SETQ R '(A 1 B 2 C 3))		(SETQ S R)		(SETF (GETF (NTHCDR 2 R) 'B) (PROGN (SETQ R NIL) 6))		(VALUES R S))        ...    ;; #2a: doesn't use GETF at all    (PROGN (SETQ R '(A 1 B 2 C 3))	   (SETQ S R)	   (SETF (NTHCDR 2 R) (PROGN (SETQ R NIL) 6))	   (VALUES R S))    which again blows up with CLtL's setf-method for variables, but does    what one would expect with the one I suggested.  These two examples    changed my mind; now I think the one I suggested is obviously right,    and the one in CLtL, evidently used by Symbolics and Lucid (and no    doubt other implementations) is obviously wrong.    Minor point: NTHCDR is not a standard generalized variable in CLtL.Major point: Does the following example change your mind back?(PROGN (SETQ R (LIST (LIST A 1 B 2 C 3)))       (SETQ S (CAR R))       (SETF (GETF (CAR R) 'B) (PROGN (SETF (CAR R) NIL) 6))       (VALUES R S))I'll bet that SCL currently returns(A 1 B 2 C 3) ; ((B 6))regardless of variable setf-method used.  But it should return(A 1 B 6 C 3) ; (NIL)As JonL (I think) implicitly pointed out, it is the responsibility of GETF toevaluate the access-form of the sub-setf-method (e.g., (CAR G0001)).It is NOT the responsibility of the sub-setf-method.  Otherwise thesetf-method for (CAR exp) would have to look like(G0001 G0002)(exp (CAR G0001))(G0003)(PROGN (RPLACA G0001 G0003) G0003)G0002Here's another GETF puzzle (only for implementations that did theright thing above):(PROGN (SETF S (LIST (LIST A 1 B 2 C 3)))       (SETF R (CAR S))       (SETF (GETF (CAR S) 'D) (PROG1 4 (SETF (CAR S) NIL)))       (VALUES R S))could legally return:#1=(A 1 B 2 C 3) ; (D 4 . #1#) {if new pairs are added to the front}(A 1 B 2 C 3 D 4) ; NIL {if new pairs are added not at the front, and   the sub-update-form is not used}#1=(A 1 B 2 C 3 D 4) ; #1# {if new pairs are added not at the front,and the sub-update-form is used}One final SETF puzzle:(PROGN (SETF S (LIST (LIST 1)))       (SETF R (CAR S))       (SETF (CAAR S) (PROG1 2 (SETF (CAR S) (LIST NIL))))       (VALUES R S))Is this valid?(1) ; ((2)) {I think: Yes definitely.}Is this?(2) ; ((NIL)) {I think: Probably not.}Try it in your implementation.Hint:  The big issue here is when the setf-method gets a handle onthe object whose cell is being stored into.  The definition of DEFSETFstrongly implies that the first choice is the correct one.-- Nick*start*05688 00024 USfDate: 23 Oct 87 15:22 PDTFrom: Masinter.paSubject: Issue: SETF-METHOD-FOR-SYMBOLS (version 2)To: cl-cleanup@Sail.stanford.educc: Masinterline-fold: 80This is not for release. I think I tend to agree with Scott that I'd rather see a little more shuffling in GETF and LDB and less in SETF of symbols. Hopefully, SETF-FUNCTION-VS-MACRO would reduce the amount of hair that was involved for users of setf, anyway. Issue:         SETF-METHOD-FOR-SYMBOLSReferences:    CLtL pp. 105, 99. Issue: PUSH-EVALUATION-ORDER.Category:      CHANGEEdit history:  Version 1   Moon 21 Sep 87               Version 2 Masinter 23-Oct-87Problem description:The description of SETF in CLtL is inconsistent in that page 99requires side-effects to be elaborated in left-to-right order,while page 105 specifies a setf-method for symbols that makesit impossible to implement this in some cases, such as the testcase given below (provided by Timothy Daly of IBM).Proposal: SETF-METHOD-FOR-SYMBOLS:TEMPORARY-VARIABLEChange the example of the result of(GET-SETF-METHOD 'FOO) fromNIL NIL (#:G1174) (SETQ FOO #:G1174) FOOto return, for example,(#:G1175) (FOO) (#:G1174) (SETQ FOO #:G1174) #:G1175Test Case:Test Case (A): Given(LET* ((R (LIST 'A 1 'B 2 'C 3))       (S R))  (SETF (GETF R 'B) (PROGN (SETQ R NIL) 6))  (VALUES R S))If side-effects are elaborated in left-to-right order,the setq of R to NIL should not affect the result, sinceit occurs after R is read and before R is written, andtherefore the value of both R and S should be (A 1 B 6 C 3).A typical result in an implementation that believes CLtL p.105more than CLtL p.99 is R = (B 6) and S = (A 1 B 2 C 3).Test Case B:(LET((A 0))   (INCF (LDB (BYTE 2 2) A) (SETQ A 2))   A)Does this return 8, 10, or 2? If p. 99's description of order of evaluation is correct, this should return 8.Rationale:The general principle mentioned on p.99 should override thespecific example on p.105.  The latter is probably just a mistake.Current practice:Symbolics and Lucid return the incorrect result mentioned in the testcase A. (Symbolics plans to fix this in the next release.) Franz and Xerox returns something else: R = nil and S = (a 1 b 6 c 3). HP Common Lisp produces the recommended value. Xerox Common Lisp returns A=10 in Test Case B.Spice Lisp returns the recommended value for the test case A, even though it uses the suggested value for the setf-method for symbols, because the get-setf-method for GETF introduces additional temporary bindings.Adoption Cost:SETF is an intricate part of Common Lisp, and the fact that not allimplementations currently return the same thing indicates that somecare might be required in updating implementations.  However, insome implementations changing what get-setf-method returns when itsargument is a symbol is the only change required.It's been pointed out that this change might cause less efficient codeto be produced in some cases, since setf methods will involve moretemporary variables, however Moon believes that the optimizations arenot difficult and probably are already done by most implementations.Cost of non-adoption:Users will think SETF is complicated and hard to understand, becauseimplementations won't conform to a simple general principle thatside-effects are elaborated in left-to-right order.Benefits:Improved portability of Common Lisp programs.Conversion Cost:This change is incompatible because it changes the result of some formsthat are not erroneous.  However, it's unlikely that very many users areintentionally depending on the current behavior.  In addition, thecurrent behavior is not consistent across implementations, which makeschanging it less problematic.Esthetics:See "cost of non-adoption".Discussion:I wish CLtL did a much better job of explaining the philosophy of SETF,and included some better examples of precisely what is meant by the"`obvious' semantics" mentioned on page 99.  I will accept some of theblame for this lack in the documentation. --MoonThis proposal is consistent with PUSH-EVALUATION-ORDER:ITEM in affirming the left-right order of evaluation of subforms of generalized variable access forms. It was pointed out that it is possible to get the required result for the test case by modifying the get-setf-method for GETF (and other setf-able items) to set up the bindings when the modified form is a symbol, as is done in Spice Lisp.The discussion seemed to be moving toward considering an alternative, which is to require the setf method for GETF and LDB to bind temporary values, e.g., "When it comes to efficiency, I'd rather have a little extra variable shuffling in Getf and places like that than in all setf's involving a symbol destination."(define-setf-method getf (place prop &optional default &environment env)  (multiple-value-bind (temps values stores set get)		       (get-setf-method place env)    (let ((newval (gensym))	  (ptemp (gensym))	  (def-temp (gensym)))      (values `(,@temps ,(car stores) ,ptemp ,@(if default `(,def-temp)))	      `(,@values ,get ,prop ,@(if default `(,default)))	      `(,newval)	      `(progn (setq ,(car stores)			    (%primitive putf ,(car stores) ,ptemp ,newval))		      ,set		      ,newval)	      `(getf ,(car stores) ,ptemp ,@(if default `(,def-temp)))))))        TITAN          TITAN           
TIMESROMAN 
          •       ÿ             3       5       ª             ò              Å             ˇ             W              º       
       0             ;                                 ˙ z∫*start*01954 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 04 NOV 87 20:48:29 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 4 Nov 87  20:45:43 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 272393; Wed 4-Nov-87 21:17:56 ESTDate: Wed, 4 Nov 87 21:18 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-METHOD-FOR-SYMBOLS (version 2)To: Masinter.pa, Fahlman@c.cs.cmu.educc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871023-152308-1515@Xerox>Message-ID: <19871105021803.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 23 Oct 87 15:22 PDT    From: Masinter.pa@Xerox.COM    I think I tend to agree with Scott that I'd    rather see a little more shuffling in GETF and LDB and less in SETF of    symbols.It seems to me that the issue is whether we believe what CLtL says onp.105 or what it says on p.106.  They contradict each other, because ifyou combine that setf method for LDB with that setf method for symbols,you get a Common Lisp that doesn't work.I claim that user programs are much more likely to have copied the setfmethod for LDB given on p.106 than the setf method for symbolsschematized on p.105, and therefore if we disbelieve p.106 the change ismore incompatible.  I withdraw the mistaken claim I made originallythat it is impossible to make a valid Common Lisp while believingp.105.    Hopefully, SETF-FUNCTION-VS-MACRO would reduce the amount of    hair that was involved for users of setf, anyway. In general yes, but not in the cases at issue here; SETF of GETFand of LDB cannot be implemented as setf functions, for reasons thatare obvious as soon as you think about it.I might have further comments later, but I thought I'd fire this oneoff now since I'm on my way home.*start*01864 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 05 NOV 87 00:17:16 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 272393; Wed 4-Nov-87 21:17:56 ESTDate: Wed, 4 Nov 87 21:18 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-METHOD-FOR-SYMBOLS (version 2)To: Masinter.pa, Fahlman@c.cs.cmu.educc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871023-152308-1515@Xerox>Message-ID: <19871105021803.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 23 Oct 87 15:22 PDT    From: Masinter.pa@Xerox.COM    I think I tend to agree with Scott that I'd    rather see a little more shuffling in GETF and LDB and less in SETF of    symbols.It seems to me that the issue is whether we believe what CLtL says onp.105 or what it says on p.106.  They contradict each other, because ifyou combine that setf method for LDB with that setf method for symbols,you get a Common Lisp that doesn't work.I claim that user programs are much more likely to have copied the setfmethod for LDB given on p.106 than the setf method for symbolsschematized on p.105, and therefore if we disbelieve p.106 the change ismore incompatible.  I withdraw the mistaken claim I made originallythat it is impossible to make a valid Common Lisp while believingp.105.    Hopefully, SETF-FUNCTION-VS-MACRO would reduce the amount of    hair that was involved for users of setf, anyway. In general yes, but not in the cases at issue here; SETF of GETFand of LDB cannot be implemented as setf functions, for reasons thatare obvious as soon as you think about it.I might have further comments later, but I thought I'd fire this oneoff now since I'm on my way home.*start*05053 00024 UShDate: 11 Nov 87 01:11 PSTFrom: Masinter.paSubject: Issue: SETF-METHOD-FOR-SYMBOLS (version 3)To: cl-cleanup@Sail.stanford.educc: MasinterI tried to tighten the discussion section and respond to Moon's comments. I rewrote the problem description to remove the claim that it was impossible given the specified setf method for symbols. I'm happy with Moon's arguments about the likelihood of user programs "copying" LDB instead of the symbol method.Issue:         SETF-METHOD-FOR-SYMBOLSReferences:    CLtL pp. 105, 99. Issue: PUSH-EVALUATION-ORDER.Category:      CHANGEEdit history:  Version 1 Moon 21 Sep 87               Version 2 Masinter 23-Oct-87               Version 3 Masinter 11-Nov-87Problem description:The description of SETF in CLtL and various SETF methods are inconsistent. The description on page 99 clearly requires side-effects to be elaborated in left-to-right order; however, the combination of the sample setf-method for LDB on p.106 and the sample setf-method for symbols given on p. 105 results in incorrect order of evaluation. Test Case A: Given(LET* ((R (LIST 'A 1 'B 2 'C 3))       (S R))  (SETF (GETF R 'B) (PROGN (SETQ R NIL) 6))  (VALUES R S))If side-effects are elaborated in left-to-right order, the setq of R to NIL should not affect the result, since it occurs after R is read and before R is written, and therefore the value of both R and S should be (A 1 B 6 C 3).A typical result in an implementation that believes CLtL p.105 more than CLtL p.99 is R = (B 6) and S = (A 1 B 2 C 3).Test Case B: Given:(LET((A 0))   (INCF (LDB (BYTE 2 2) A) (SETQ A 2))   A)Does this return 8, 10, or 2? If p. 99's description of order of evaluation is correct, this should return 8.Proposal: SETF-METHOD-FOR-SYMBOLS:TEMPORARY-VARIABLEChange the example of the result of(GET-SETF-METHOD 'FOO) fromNIL NIL (#:G1174) (SETQ FOO #:G1174) FOO(as currently described in CLtL) to return, for example,(#:G1175) (FOO) (#:G1174) (SETQ FOO #:G1174) #:G1175Rationale:The general principle mentioned on p.99 should override the specific example on p.105.  The latter is probably just a mistake.Current practice:Symbolics and Lucid return the incorrect result mentioned in the test case A. (Symbolics plans to fix this in the next release.) Franz and Xerox returns something else: R = nil and S = (a 1 b 6 c 3); Xerox returns A=10 in Test Case B.   HP Common Lisp produces the recommended value. Spice Lisp returns the recommended value for the test case A, even though it uses the suggested value for the setf-method for symbols, because the get-setf-method for GETF introduces additional temporary bindings.Adoption Cost:SETF is an intricate part of Common Lisp, and the fact that not all implementations currently return the same thing indicates that some care might be required in updating implementations.  However, in some implementations changing what get-setf-method returns when its argument is a symbol is the only change required.It's been pointed out that this change might cause less efficient code to be produced in some cases, since setf methods will involve more temporary variables, however Moon believes that the optimizations are not difficult and probably are already done by most implementations.Cost of non-adoption:Users will think SETF is complicated and hard to understand, because implementations won't conform to a simple general principle that side-effects are elaborated in left-to-right order.Benefits:Improved portability of Common Lisp programs.Conversion Cost:This change is incompatible because it changes the result of some forms that are not erroneous.  However, it's unlikely that very many users are intentionally depending on the current behavior.  In addition, the current behavior is not consistent across implementations, which makes changing it less problematic.Esthetics:See "cost of non-adoption".Discussion:A specification of Common Lisp would do well to included some better examples of precisely what is meant by the "`obvious' semantics" mentioned on page 99.This proposal is consistent with PUSH-EVALUATION-ORDER:ITEM in affirming the left-right order of evaluation of subforms of generalized variable access forms. It was pointed out that it is possible to get the required result for the test case by modifying the get-setf-method for GETF (and other setf-able items) to set up the bindings when the modified form is a symbol, as is done in Spice Lisp. However, we believe that user programs are much more likely to have copied the setf method for LDB given on p.106 than the setf method for symbols schematized on p.105, and this is the simplest change to achieve compatibility and correct behavior.        TITAN          TITAN           
TIMESROMAN 
          …                   Ú       5       ‹              Å             ˆ             W              º       
       0             ;                           '      ë z∫*start*00724 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 NOV 87 18:47:21 PSTReceived: from SCRC-RIVERSIDE.ARPA by SAIL.STANFORD.EDU with TCP; 12 Nov 87  18:45:07 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 187828; Thu 12-Nov-87 19:26:21 ESTDate: Thu, 12 Nov 87 19:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-METHOD-FOR-SYMBOLS (version 3)To: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871111-011148-6438@Xerox>Message-ID: <19871113002609.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Good enough, let's release it.*start*02398 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 NOV 87 12:40:25 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 17 Nov 87  12:37:45 PSTReceived: by labrea.stanford.edu; Tue, 17 Nov 87 12:36:20 PSTReceived: from kent-state.lucid.com by edsel id AA02947g; Tue, 17 Nov 87 12:31:28 PSTReceived: by kent-state id AA02216g; Tue, 17 Nov 87 12:31:28 PSTDate: Tue, 17 Nov 87 12:31:28 PSTFrom: Eric Benson <edsel!eb@labrea.stanford.edu>Message-Id: <8711172031.AA02216@kent-state.lucid.com>To: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Thu, 12 Nov 87 19:26 EST <19871113002609.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: SETF-METHOD-FOR-SYMBOLS (version 3)There's a problem with this SETF method for symbols.  Consider thefollowing simplified version of SETF from p.107 of CLtL:(DEFMACRO SETF (REFERENCE VALUE)  (MULTIPLE-VALUE-BIND (VARS VALS STORES STORE-FORM ACCESS-FORM)      (GET-SETF-METHOD REFERENCE)    (DECLARE (IGNORE ACCESS-FORM))    `(LET* ,(MAPCAR #'LIST (APPEND VARS STORES) (APPEND VALS (LIST VALUE)))       ,STORE-FORM)))This results in the following macrexpansion for (SETF X 1), using thenew SETF method for symbols:(LET* ((G0002 X)       (G0001 1))  (SETQ X G0001))The value of G0002 is never used.  The problem is that X might beunbound, so even just binding it to a local variable will fail.  Idon't think we want to require implementations to eliminateunnecessary bindings in SETF expansions, just to get correctsemantics.  Nor should each SETF-like macro need a special case whenthe location being stored is a symbol.Unfortunately, I think special handling for symbols is necessary.  Ifwe keep the SETF method for symbols the way it is in CLtL then we needto make a special case for symbols in the SETF methods for GETF, LDBand the like.  If we change the SETF method as proposed here, we needto make a special case for symbols in SETF and PSETF and any userdefined SETF-like macro that doesn't use the fifth value (ACCESS-FORM)from GET-SETF-METHOD.My feeling is that we should go with the new SETF method for symbols,but describe this problem and point out to implementors that SETF andPSETF must handle symbols specially, effectively resorting to the oldSETF method.*start*02777 00024 US Return-Path: <edsel!eb@labrea.stanford.edu>Received: from labrea.stanford.edu ([36.8.0.47]) by Xerox.COM ; 28 NOV 87 17:13:43 PSTReceived: by labrea.stanford.edu; Sat, 28 Nov 87 11:04:02 PSTReceived: from kent-state.lucid.com by edsel id AA29214g; Sat, 28 Nov 87 10:57:29 PSTReceived: by kent-state id AA05304g; Sat, 28 Nov 87 10:58:08 PSTDate: Sat, 28 Nov 87 10:58:08 PSTFrom: Eric Benson <edsel!eb@labrea.stanford.edu>Message-Id: <8711281858.AA05304@kent-state.lucid.com>To: Masinter.paCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: Masinter.pa@Xerox.COM's message of 25 Nov 87 17:49 PST <871125-174935-2663@Xerox>Subject: Issue status   Date: 25 Nov 87 17:49 PST   From: Masinter.pa@Xerox.COM   This isn't quite up to date as I've missed a few, but I thought I should   go ahead and send it out if you're keeping a score card... I think we   have some new members of the distribution list as of the last week or   so...    - SETF-METHOD-FOR-SYMBOL (Version 3, 11-Nov-87)      (Change recommendation for (get-setf-method symbol)?)      Ready for releasePerhaps you missed my message about this issue, since I sent it duringthe meeting.  Here it is again:There's a problem with this SETF method for symbols.  Consider thefollowing simplified version of SETF from p.107 of CLtL:(DEFMACRO SETF (REFERENCE VALUE)  (MULTIPLE-VALUE-BIND (VARS VALS STORES STORE-FORM ACCESS-FORM)      (GET-SETF-METHOD REFERENCE)    (DECLARE (IGNORE ACCESS-FORM))    `(LET* ,(MAPCAR #'LIST (APPEND VARS STORES) (APPEND VALS (LIST VALUE)))       ,STORE-FORM)))This results in the following macrexpansion for (SETF X 1), using thenew SETF method for symbols:(LET* ((G0002 X)       (G0001 1))  (SETQ X G0001))The value of G0002 is never used.  The problem is that X might beunbound, so even just binding it to a local variable will fail.  Idon't think we want to require implementations to eliminateunnecessary bindings in SETF expansions, just to get correctsemantics.  Nor should each SETF-like macro need a special case whenthe location being stored is a symbol.Unfortunately, I think special handling for symbols is necessary.  Ifwe keep the SETF method for symbols the way it is in CLtL then we needto make a special case for symbols in the SETF methods for GETF, LDBand the like.  If we change the SETF method as proposed here, we needto make a special case for symbols in SETF and PSETF and any userdefined SETF-like macro that doesn't use the fifth value (ACCESS-FORM)from GET-SETF-METHOD.My feeling is that we should go with the new SETF method for symbols,but describe this problem and point out to implementors that SETF andPSETF must handle symbols specially, effectively resorting to the oldSETF method.*start*07963 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 DEC 87 15:39:49 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 16 Dec 87  15:38:43 PSTReceived: by labrea.stanford.edu; Wed, 16 Dec 87 15:27:56 PSTReceived: from gypsy-moth.lucid.com by edsel id AA09557g; Wed, 16 Dec 87 14:25:00 PSTReceived: by gypsy-moth id AA01336g; Wed, 16 Dec 87 14:25:56 PSTDate: Wed, 16 Dec 87 14:25:56 PSTFrom: Ken Olum <edsel!kdo@labrea.stanford.edu>Message-Id: <8712162225.AA01336@gypsy-moth.lucid.com>To: cl-cleanup@sail.stanford.eduIn-Reply-To: Masinter.pa@Xerox.COM's message of 23 Oct 87 15:22 PDT <871023-152308-1515@Xerox>Subject: Issue: SETF-METHOD-FOR-SYMBOLS (alternate proposal)I don't think this issue has anything to do with symbols.  For example,consider the form(setf (ldb (byte 8 0) x) (prog1 1 (setf (ldb (byte 8 8) x) 2)))Suppose that X is 0.  This form now sets X to 1.  However, if X isreplaced with (CAR X), then the form will set (CAR X) to #x201.  Inorder to have constant behavior, GETF and LDB must ALWAYS completelyevaluate their subform, whether it is a symbol or not.   If we do thiswith all setf-methods then we might as well flush the idea of anaccess-form since this must always be no more than a local variablereference.   Furthermore the access-form must always be defined evenif the case is just SETF, because you will always access it as EBpoints out in a previous message.Furthermore, I think this behavior is unnatural.  Many applicationsset up flag-words and the like, and a side-effect of computing a valuefor one flag might well be the setting of another flag in the sameword.  In this case the same sub-place is being used to store variousobjects, and there should be as little interaction between the settingof the different objects as possible.Therefore, I propose that we change the definition of a subform forthis order-of-evaluation issue and keep the methods on both pages 105and 106.  See SETF-METHOD-FOR-SYMBOLS:CHANGE-MEANING-OF-SUBFORM below.!ISSUE:         SETF-METHOD-FOR-SYMBOLSReferences:    CLtL pp. 105, 106, 99. Issue: PUSH-EVALUATION-ORDER.Category:      CHANGEEdit history:  Version 1 Moon 21 Sep 87               Version 2 Masinter 23-Oct-87               Version 3 Masinter 11-Nov-87	       Version 4 KDO 4-Dec-87Problem description:The description of SETF in CLtL and various SETF methods areinconsistent. The description on page 99 clearly requires side-effectsto be elaborated in left-to-right order; however, the combination of thesample setf-method for LDB on p.106 and the sample setf-method forsymbols given on p. 105 results in incorrect order of evaluation. Test Case A: Given(LET* ((R (LIST 'A 1 'B 2 'C 3))       (S R))  (SETF (GETF R 'B) (PROGN (SETQ R NIL) 6))  (VALUES R S))If side-effects are elaborated in left-to-right order, the setq of R toNIL should not affect the result, since it occurs after R is read andbefore R is written, and therefore the value of both R and S should be(A 1 B 6 C 3).A typical result in an implementation that believes CLtL p.105 more thanCLtL p.99 is R = (B 6) and S = (A 1 B 2 C 3).Test Case B: Given:(LET((A 0))   (INCF (LDB (BYTE 2 2) A) (SETQ A 2))   A)Does this return 8, 10, or 2? If p. 99's description of order ofevaluation is correct, this should return 8.It was pointed out that it is possible to get the required result forthe test case by modifying the get-setf-method for GETF (and othersetf-able items) to set up the bindings when the modified form is asymbol, as is done in Spice Lisp. However, we believe that user programs are much more likely to havecopied the setf method for LDB given on p.106 than the setf method forsymbols schematized on p.105, and this is the simplest change to achievecompatibility and correct behavior.Proposal: SETF-METHOD-FOR-SYMBOLS:TEMPORARY-VARIABLEChange the example of the result of(GET-SETF-METHOD 'FOO) fromNIL NIL (#:G1174) (SETQ FOO #:G1174) FOO(as currently described in CLtL) to return, for example,(#:G1175) (FOO) (#:G1174) (SETQ FOO #:G1174) #:G1175Rationale:The general principle mentioned on p.99 should override the specificexample on p.105.  The latter is probably just a mistake.Current practice:Symbolics and Lucid return the incorrect result mentioned in the testcase A. (Symbolics plans to fix this in the next release.) Franz andXerox returns something else: R = nil and S = (a 1 b 6 c 3); Xeroxreturns A=10 in Test Case B.   HP Common Lisp produces the recommendedvalue. Spice Lisp returns the recommended value for the test case A, eventhough it uses the suggested value for the setf-method for symbols,because the get-setf-method for GETF introduces additional temporarybindings.Adoption Cost:SETF is an intricate part of Common Lisp, and the fact that not allimplementations currently return the same thing indicates that some caremight be required in updating implementations.  However, in someimplementations changing what get-setf-method returns when its argumentis a symbol is the only change required.It's been pointed out that this change might cause less efficient codeto be produced in some cases, since setf methods will involve moretemporary variables, however Moon believes that the optimizations arenot difficult and probably are already done by most implementations.Cost of non-adoption:Users will think SETF is complicated and hard to understand, becauseimplementations won't conform to a simple general principle thatside-effects are elaborated in left-to-right order.Benefits:Improved portability of Common Lisp programs.Conversion Cost:This change is incompatible because it changes the result of some formsthat are not erroneous.  However, it's unlikely that very many users areintentionally depending on the current behavior.  In addition, thecurrent behavior is not consistent across implementations, which makeschanging it less problematic.Esthetics:See "cost of non-adoption".Discussion:A specification of Common Lisp would do well to included some betterexamples of precisely what is meant by the "`obvious' semantics"mentioned on page 99.This proposal is consistent with PUSH-EVALUATION-ORDER:ITEM in affirmingthe left-right order of evaluation of subforms of generalized variableaccess forms. It was pointed out that it is possible to get the required result forthe test case by modifying the get-setf-method for GETF (and othersetf-able items) to set up the bindings when the modified form is asymbol, as is done in Spice Lisp. However, we believe that user programs are much more likely to havecopied the setf method for LDB given on p.106 than the setf method forsymbols schematized on p.105, and this is the simplest change to achievecompatibility and correct behavior.Proposal: SETF-METHOD-FOR-SYMBOLS:CHANGE-MEANING-OF-SUBFORMKeep the old definition for symbols as examplified on p. 105 and thedefinition for LDB on p. 106.  Specify that "subforms ofgeneralized-variable references" on p. 99 does not includes subformswhich will be stored into, but only those necessary to specify theplace to store.  In other words if the setf-method for a form mustrecusively make use of the setf-method for a subform, that thatsubform (but not any sub-subforms) is permitted to be evaluted at thetime of the store instead of in its lexical position.Benefits:Anyone who has copied examples from p.105 and p.106 will continue tobe able to use them.Setf of (LDB ... X) will be consistant with (LDB ... (CAR X)) and allother subplaces.It is very unlikely that anyone is depending on the left-to-rightevaluation in this case, but quite possible that someone is dependingon the non-left-to-right evaluation for maintaining several bit-fieldsin a symbol value.*start*01263 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 DEC 87 13:07:13 PSTReceived: from DECWRL.DEC.COM by SAIL.STANFORD.EDU with TCP; 21 Dec 87  19:22:17 PSTReceived: by decwrl.dec.com (5.54.4/4.7.34)	id AA16788; Mon, 21 Dec 87 15:10:11 PSTDate: Mon, 21 Dec 87 15:10:11 PSTMessage-Id: <8712212310.AA16788@decwrl.dec.com>From: greek%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: SETF-METHOD-FOR-SYMBOLS IssueI spent some time reading the issue entitled SETF-METHOD-FOR-SYMBOLS.Seems to me it avoids the real question.Consider Test Case A.  Once the (GETF ...) and (PROGN ...) are evaluated, what happens.  We notice that the key B already appears in the list, so we replace its value with 6.  Then do we store the list back in R?  If so, R will be (A 1 B 6 C 3).  If not, it will be NIL.Now if the key does not appear in the list, we must cons it on the front and then are forced to store it back in B.  So perhaps for consistency we should always store it back.So I guess my question is:  is the place in (SETF (GETF R ...) ...)R or is it the list in R or is the pair in the list in R?  - Paul Anagnostopoulos*start*11496 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 FEB 88 23:41:05 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 12 Feb 88  23:37:24 PSTReceived: by labrea.Stanford.EDU; Fri, 12 Feb 88 23:37:47 PSTReceived: from bhopal.lucid.com by edsel id AA19656g; Fri, 12 Feb 88 23:26:38 PSTReceived: by bhopal id AA13404g; Fri, 12 Feb 88 23:31:35 PSTDate: Fri, 12 Feb 88 23:31:35 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8802130731.AA13404@bhopal.lucid.com>To: labrea!CL-Cleanup%SAIL@labrea.Stanford.EDUSubject: Issue: SETF-SUB-METHODSKen Olum and I [JonL White] have given some thought to the problem that spurred the issue SETF-METHOD-FOR-SYMBOLS, and feel that the issue as stated attacks a small manifestation of the problem rather than the rootunderlying case.  Worse yet, the TEMPORARY-VARIABLE proposal requires a change which creates a bug in another area of SETF usage [see below].We propose that the problem lies in understanding of how SETF works when the SETF expansion for a form like 	(<access-fun> <place> ...) involves the sub-recursive SETF expansion of <place>, or in other words,when the accessing technique isn't fully specified just by looking at the get-setf-method of <access-fun>.   The class of such <access-fun>'s is enumerated in CLtL, at the top of p96, except that GETF is missing from that list [we propose that it be added there in the next manual].This message will propose a clarification the issues of left-to-rightevaluation in such cases, and will also detail the actions that shouldbe taken by SETF methods on each of these place-types.!ISSUE: 		SETF-SUB-METHODSReferences: 	CLtL pp. 95-96, 99, 105-106, 166		Issue: PUSH-EVALUATION-ORDER		Issue: SETF-METHOD-FOR-SYMBOLSCategory: 	ClarificationEdit history:  Version 1 JonL & KDO 12-Feb-88Problem description:Tim Daly of IBM noticed that several implementations do not observeleft-to-right order of evaluation in the following form:     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6))In these implementations, the side-effect of the setq happens before the evaluation of the "subforms" necessary to fetch the list being updated. A typical result is that 'r' = (B 6), 's' = (A 1 B 2 C 3) after the operation.  Surely, it should at least be the case that 's' = (A 1 B 6 C 3), since the expectation is that the B property in this list is being (destructively) changed.Similar problems exist with LDB and CHAR-BIT.It is not necessary to clarify that left-to-right order of evaluationsemantics should be observed; CLtL p99 is quite explicit about that.Rather, a distinction needs to be made between the computations involvedin "evaluation" of the subforms, and other computations that are implicitin the notion of "doing an access" or "doing a store".Proposal:	SETF-SUB-METHODS:DELAYED-ACCESS-STORESElaborate the documentation of SETF, especially in the case of accessforms whose sub-forms are permitted to be generalized variable references[and thus which need to call GET-SETF-METHOD during setf macro expansion].We remember that GET-SETF-METHOD returns the following:  Some temporary variables  A list of value-producing forms  A list of store-variables (normally one).  A storing form.  An accessing form.Then we want to say that:  Code generated using GET-SETF-METHOD does 2 or 3 of the following  things:  It evaluates the value-producting forms, and binds the temporary  variables to them.  This will be called "binding the temporaries."  It evaluates the accessing form to get the old value of the place.  This will be called "doing the access."  It binds the store-variable to a new value and calls the storing form  to install it in the place.  This will be called "doing the store."  The forms listed at the top of CLtL p96 permit recursive <place>  specifiers; for each one, we will describe how the sub-recursive   information from GET-SETF-METHOD is used.  LDB:     In a form such as    (SETF (LDB <byte-spec> <place-form>) <value-form>)    the place referred to by the <place-form> must always be both    accessed and updated.  Even if the <place-form> refers to a    bignum, the bignum itself will not be modified but rather a new    bignum stored in the <place-form>.  Thus this SETF should generate    code to do the following:    1. Evaluate <byte-spec>    2. Bind the temporaries for <place-form>    3. Evaluate <value-form>    4. Do the access to <place-form>    5. Do the store into <place-form> with the given bit-field    replaced with the value from step 3.    If the evaluation of <value-form> in step 3 sets a different    bit-field in the given place then since the access is done later    at step 4 this change will be preserved.  See ROTATEF example in    discussion below.  Nevertheless the evaluations required for    binding the temporaries are done in step 2, and thus the expected    left-to-right evaluation order is seen.  GETF:    The case of GETF is complicated by the fact that two different    "place" locators are involved: one to use if the specified    indicator is present in the property list, and another if not.    For example, in (SETF (GETF (AREF ... I) 'B) 6), if the I'th slot    of the array is NIL, then that slot must be changed, but if it    contains a list with the property B then only the cons cell with    that property value needs to be changed.  This decision cannot be    made at macro-expansion time.  It depends entirely on the contents    of the list in question, and so must be delayed until the last    possible moment.    In the first place, GETF should be listed among the other place    forms that admit place forms as one of their arguments.  See CLtL    at the bottom of p95 and the top of p96.    More specifically, the expansion of     (SETF (GETF <place-form> <ind-form>) <value-form>)    should generate code to do the following:    1. Bind the temporaries for <place-form>     2. Do the access to <place-form>       [Binding the temporaries and then doing the access is equivalent to        evaluating the <place-form>.]    3. Evaluate <ind-form> [and save the result in a temporary variable].    4. Check whether the value from 2 has the indicator from 3.    If so:	5A. Find cons-cell after indicator from above	6A. Evaluate <value-form>	7A. RPLACA cons-cell from 5A with value from 6A	    [In this case, we do not do a store into <place-form>.  When 	     the indicator is already present then the location specifed 	    by <place-form> doesn't need a new value.]    If not:	5B. Evaluate <value-form>	6B. Do the access to <place-form>, using the temporaries saved from 	    step 1 [this is not another evaluation -- but it may involve	    some non trivial computation, depending on how complex the	    access method really is.].	7B. Do the store into <place-form>, again using the temporaries saved	    from step 1, setting it to a list with indicator from 3, new value	    from 5B, and old list from 6B.Test Cases:      (setq integer #x69)      (rotatef (ldb (byte 4 4) integer) (ldb (byte 4 0) integer))Rationale: As a principle,    (setf (foo-a x) (setf (foo-b x) ...)) should always set both of the "slots" of X, even if these slots are  implemented as bit-fields, getf-properties, and so on. However,    (setf (foo-a x) (setf (foo-a x) ...))  is an error [that is, what happens is undefined.]Current Practice: -- Xerox and Franz already operate on GETF according to this perscription. -- Symbolics and Lucid differ by always doing a setf on the variable    rather than updating the appropriate cons cell of the property list;     additionally, they fail to connect the new value put into 'r' to the    original property list which was 'r's value initially. -- HP and VAX  Common Lisps update the cons cell, but then set the variable    'r' again, nullifying the effect of the "(setq r nil)" in the <value-form>    computation.Adoption cost: Several implementations would require several hours of programmer and documentation time.Cost of non-adoption: Users will think SETF is unnatural in that left-to-right order of evaluation isn't always observed.Benefits: Uniform semantics and portability in the face of recursive "place specifiers" for SETF.  Setf of (LDB ... <place>) and of (GETF <place> ...) will behave uniformly no matter the nature of the <place>. Anyone who has copied examples from p105 and p106 will continue to be able to use them.Conversion Cost: This is a clarification of a point not sufficiently elaborated in CLtL. Symbolics and Lucid are already modifying their interpretation of this code -- in some way or other.Esthetics: See "Cost of non-adoption"Discussion: In the case that spurred this discussion,     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6)) the consequent update is a RPLACA to some list cell -- not a setf of the variable 'r' -- and thus 'r' should be NIL and 's' should now be (A 1 B 6 C 3). There is an interesting parallel between this case for GETF and the very common mistake made by Lisp programmers with respect to the  function DELETE.  How often the complaint is filed that DELETE didn't do anything when it should have; but in fact the filer simply forgot that delete can either update some CAR slot of the list originally  given it, or return some tail of the list originally give it, but not both!  E.g.      (setq l '(a a b c d)) ==> (a a b c d)      (delete 'a l)         ==> (b c d)      l 		      ==> (a a b c d) The unwary user thinks that because 'l' is still eq to the original value that "DELETE didn't do anything".  The variability of action at runtime here parallels the variable choice of location specifier for (SETF (GETF ...) ...) A previous proposal to fix this problem was misdirected.  It was phrased as follows:      Proposal: SETF-METHOD-FOR-SYMBOLS:TEMPORARY-VARIABLE      Change the result of (get-setf-method 'foo) from      NIL NIL (#:G1174) (SETQ FOO #:G1174) FOO      to      (#:G1175) (FOO) (#:G1174) (SETQ FOO #:G1174) #:G1175 The problem with this is that it breaks a relatively simple client of  setf technology:      (setq integer #x69)      (rotatef (ldb (byte 4 4) integer) (ldb (byte 4 0) integer)) no longer does the "right thing".  Using the prescription for setf methods on symbols from  CLtL p105, the result of this 'rotatef' is that integer = #x96; using that given by the TEMPORARY-VARIABLE proposal leads to either #x99 [or #x66 depending on which order the implementation chooses to do the actual stores in]. In addition, if 'integer' is replaced by '(car x)' here, then the  behavior is different under the TEMPORARY-VARIABLE proposal because  that only applies to symbols. Implicitly, two "places" are being specified here to be updated; but in fact the two places are not independent -- they both involve setq'ing the variable 'integer'.  Furthermore, each store operation implicitly requires fetching the value from that place in order to combine it with DPB.  It is necessary to delay the accesses until the last moment before combining with DPB in order to see the side-effects of the earlier store operations.*start*04652 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 MAY 88 16:20:31 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 25 May 88  16:18:40 PDTReceived: by labrea.stanford.edu; Wed, 25 May 88 16:19:04 PDTReceived: from bhopal.lucid.com by edsel id AA13379g; Wed, 25 May 88 16:01:32 PDTReceived: by bhopal id AA02123g; Wed, 25 May 88 16:05:30 PDTDate: Wed, 25 May 88 16:05:30 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805252305.AA02123@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 24 May 88 15:01 EDT <19880524190108.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: SETF-SUB-METHODS (Version 2)re: You left out MASK-FIELD and CHAR-BIT.  We certainly didn't mean to.  We intended to cover these cases with the words:    Elaborate the documentation of SETF, especially in the case of access    forms whose sub-forms are permitted to be generalized variable references    [and thus which need to call GET-SETF-METHOD during setf macro expansion].as indicated in the  preamble:    "... when the accessing technique isn't fully specified just by looking at     the get-setf-method of <access-fun>.   The class of such <access-fun>'s     is enumerated in CLtL, at the top of p96, except that GETF is missing     from that list [we propose that it be added there in the next manual].but, yes, it looks like they need to be mentioned explicitly.re:  ... test cases ...Glaaag, I can't believe we left out the result value of the LDB test case!(maybe it just looked so obvious!).  All of your additions to the testcase part for LDB, MASK-FIELD and CHAR-BITS seem ok to me.   re:  	    The case of GETF is complicated by the fact that two different	    "place" locators are involved: one to use if the specified	    indicator is present in the property list, and another if not.	    For example, in (SETF (GETF (AREF ... I) 'B) 6), if the I'th slot	    of the array is NIL, then that slot must be changed, but if it	    contains a list with the property B then only the cons cell with	    that property value needs to be changed.    I strongly disagree with this.  I think it's wrong to specify that    SETF of GETF does not store into the <place> if the value that would    be stored there happens to be EQ to what is already there.  Common Lisp    should either leave it unspecified, or require that the store always    take place (I prefer the latter). It doesn't specify that the store into <place> *can't* take place; rather it only specifies which steps *must* happen, and it purposesly omits saying anything about the situation where stores aren't required to maintainthe property-list semantics.  However, your objection:      "[disagree about] not store into the <place> if the value that would       be stored there happens to be EQ to what is already there ..." isn't an interesting one; rather the crux of the matter is, I believe, theone you imply about always storing into the <place> form regardless of whether or not the indicator is found on the property list.  I hope I'm not mis-paraphrasing your objections, but I think "... EQ to what is already there..." is a red herring and the relevant issue is "regardless of whether or not the indicator is found on the property list."What you want is for the <place-form> to be updated as the ultimate and last step in a setf-of-getf, precisely because the evaluation of <value-form> may itself have altered <place-form> during the in-between steps.  This suggestion would permit setf-of-getf to have side-effecting behaviourparallel to setf-of-ldb; and based on that similarity as a simplification, then we agree with your change to the proposal [after all, we can't find anyone who really cares what the test case values for setf-of-getf return -- only that all CL implementations present the same order of evaluation].In fact, that is how Lucid's implementation currently works, so we also havesome selfish motivation in altering the proposal accordingly.re:     ... DELETE ...    Not true.  For example, (delete 'a '(a a b a d)) does both (assuming    I correctly understand what you meant by the typo "update some CAR slot").    I agree that there is a parallel.I see.  We'll try fix the wording so as not to be misleading.Version 3 of this proposal will be forthcoming, but I fear that we'vemissed the USMailing-out deadline.  It'll be up to Larry.-- JonL --*start*10860 00024 US Return-Path: <edsel!jonl@labrea.stanford.edu>Received: from labrea.stanford.edu by Xerox.COM ; 24 MAY 88 01:46:02 PDTReceived: by labrea.stanford.edu; Tue, 24 May 88 01:45:52 PDTReceived: from bhopal.lucid.com by edsel id AA04591g; Tue, 24 May 88 01:32:20 PDTReceived: by bhopal id AA04754g; Tue, 24 May 88 01:36:12 PDTDate: Tue, 24 May 88 01:36:12 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805240836.AA04754@bhopal.lucid.com>To: masinter.paCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 23 May 88 17:56 PDT <880523-175658-5823@Xerox>Subject: Issue: SETF-SUB-METHODS (Version 2)--text follows this line--Issue: 		SETF-SUB-METHODSReferences: 	CLtL pp. 95-96, 99, 105-106, 166		Issue: PUSH-EVALUATION-ORDERCategory: 	ClarificationEdit history:  Version 1 JonL White & Ken Olum 12-Feb-88		(based on problem originally called SETF-METHOD-FOR-SYMBOLS)               Version 2 JonL White 23-May-88 (fix references and spellings).Problem description:Tim Daly of IBM noticed that several implementations do not observeleft-to-right order of evaluation in the following form:     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6))In these implementations, the side-effect of the setq happens before the evaluation of the "subforms" necessary to fetch the list being updated. A typical result is that 'r' = (B 6), 's' = (A 1 B 2 C 3) after the operation.  Surely, it should at least be the case that 's' = (A 1 B 6 C 3), since the expectation is that the B property in this list is being (destructively) changed.Similar problems exist with LDB and CHAR-BIT.It is not necessary to clarify that left-to-right order of evaluationsemantics should be observed; CLtL p99 is quite explicit about that.Rather, a distinction needs to be made between the computations involvedin "evaluation" of the subforms, and other computations that are implicitin the notion of "doing an access" or "doing a store".The issue PUSH-EVALUATION-ORDER is a clarification about just the pointof the evaluation order for the various subforms to a PUSH;  thus thereis a similarity to this issue, but the current one has a much deeperproblem because of the need to call GET-SETF-METHOD during setf macroexpansion.Proposal:	SETF-SUB-METHODS:DELAYED-ACCESS-STORESElaborate the documentation of SETF, especially in the case of accessforms whose sub-forms are permitted to be generalized variable references[and thus which need to call GET-SETF-METHOD during setf macro expansion].We remember that GET-SETF-METHOD returns the following:  Some temporary variables  A list of value-producing forms  A list of store-variables (normally one).  A storing form.  An accessing form.Then we want to say that:  Code generated using GET-SETF-METHOD does 2 or 3 of the following  things:  It evaluates the value-producting forms, and binds the temporary  variables to them.  This will be called "binding the temporaries."  It evaluates the accessing form to get the old value of the place.  This will be called "doing the access."  It binds the store-variable to a new value and calls the storing form  to install it in the place.  This will be called "doing the store."  The forms listed at the top of CLtL p96 permit recursive <place>  specifiers; for each one, we will describe how the sub-recursive   information from GET-SETF-METHOD is used.  LDB:     In a form such as    (SETF (LDB <byte-spec> <place-form>) <value-form>)    the place referred to by the <place-form> must always be both    accessed and updated.  Even if the <place-form> refers to a    bignum, the bignum itself will not be modified but rather a new    bignum stored in the <place-form>.  Thus this SETF should generate    code to do the following:    1. Evaluate <byte-spec>    2. Bind the temporaries for <place-form>    3. Evaluate <value-form>    4. Do the access to <place-form>    5. Do the store into <place-form> with the given bit-field    replaced with the value from step 3.    If the evaluation of <value-form> in step 3 sets a different    bit-field in the given place then since the access is done later    at step 4 this change will be preserved.  See ROTATEF example in    discussion below.  Nevertheless the evaluations required for    binding the temporaries are done in step 2, and thus the expected    left-to-right evaluation order is seen.  GETF:    The case of GETF is complicated by the fact that two different    "place" locators are involved: one to use if the specified    indicator is present in the property list, and another if not.    For example, in (SETF (GETF (AREF ... I) 'B) 6), if the I'th slot    of the array is NIL, then that slot must be changed, but if it    contains a list with the property B then only the cons cell with    that property value needs to be changed.  This decision cannot be    made at macro-expansion time.  It depends entirely on the contents    of the list in question, and so must be delayed until the last    possible moment.    In the first place, GETF should be listed among the other place    forms that admit place forms as one of their arguments.  See CLtL    at the bottom of p95 and the top of p96.    More specifically, the expansion of     (SETF (GETF <place-form> <ind-form>) <value-form>)    should generate code to do the following:    1. Bind the temporaries for <place-form>     2. Do the access to <place-form>       [Binding the temporaries and then doing the access is equivalent to        evaluating the <place-form>.]    3. Evaluate <ind-form> [and save the result in a temporary variable].    4. Check whether the value from 2 has the indicator from 3.    If so:	5A. Find cons-cell after indicator from above	6A. Evaluate <value-form>	7A. RPLACA cons-cell from 5A with value from 6A	    [In this case, we do not do a store into <place-form>.  When 	     the indicator is already present then the location specifed 	    by <place-form> doesn't need a new value.]    If not:	5B. Evaluate <value-form>	6B. Do the access to <place-form>, using the temporaries saved from 	    step 1 [this is not another evaluation -- but it may involve	    some non trivial computation, depending on how complex the	    access method really is.].	7B. Do the store into <place-form>, again using the temporaries saved	    from step 1, setting it to a list with indicator from 3, new value	    from 5B, and old list from 6B.Test Cases:      (setq integer #x69)      (rotatef (ldb (byte 4 4) integer) (ldb (byte 4 0) integer))Rationale: As a principle,    (setf (foo-a x) (setf (foo-b x) ...)) should always set both of the "slots" of X, even if these slots are  implemented as bit-fields, getf-properties, and so on. However,    (setf (foo-a x) (setf (foo-a x) ...))  is an error [that is, what happens is undefined.]Current Practice: -- Xerox and Franz already operate on GETF according to this perscription. -- Symbolics and Lucid differ by always doing a setf on the variable    rather than updating the appropriate cons cell of the property list;     additionally, they fail to connect the new value put into 'r' to the    original property list which was 'r's value initially. -- HP and VAX  Common Lisps update the cons cell, but then set the variable    'r' again, nullifying the effect of the "(setq r nil)" in the <value-form>    computation.Adoption cost: Several implementations would require several hours of programmer and documentation time.Cost of non-adoption: Users will think SETF is unnatural in that left-to-right order of evaluation isn't always observed.Benefits: Uniform semantics and portability in the face of recursive "place specifiers" for SETF.  Setf of (LDB ... <place>) and of (GETF <place> ...) will behave uniformly no matter the nature of the <place>. Anyone who has copied examples from p105 and p106 will continue to be able to use them.Conversion Cost: This is a clarification of a point not sufficiently elaborated in CLtL. Symbolics and Lucid are already modifying their interpretation of this code -- in some way or other.Esthetics: See "Cost of non-adoption"Discussion: In the case that spurred this discussion,     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6)) the consequent update is a RPLACA to some list cell -- not a setf of the variable 'r' -- and thus 'r' should be NIL and 's' should now be (A 1 B 6 C 3). There is an interesting parallel between this case for GETF and the very common mistake made by Lisp programmers with respect to the  function DELETE.  How often the complaint is filed that DELETE didn't do anything when it should have; but in fact the filer simply forgot that delete can either update some CAR slot of the list originally  given it, or return some tail of the list originally give it, but not both!  E.g.      (setq l '(a a b c d)) ==> (a a b c d)      (delete 'a l)         ==> (b c d)      l 		      ==> (a a b c d) The unwary user thinks that because 'l' is still eq to the original value that "DELETE didn't do anything".  The variability of action at runtime here parallels the variable choice of location specifier for (SETF (GETF ...) ...) A previous proposal to fix this problem was misdirected.  It was phrased as follows:      Proposal: SETF-METHOD-FOR-SYMBOLS:TEMPORARY-VARIABLE      Change the result of (get-setf-method 'foo) from      NIL NIL (#:G1174) (SETQ FOO #:G1174) FOO      to      (#:G1175) (FOO) (#:G1174) (SETQ FOO #:G1174) #:G1175 The problem with this is that it breaks a relatively simple client of  setf technology:      (setq integer #x69)      (rotatef (ldb (byte 4 4) integer) (ldb (byte 4 0) integer)) no longer does the "right thing".  Using the prescription for setf methods on symbols from  CLtL p105, the result of this 'rotatef' is that integer = #x96; using that given by the TEMPORARY-VARIABLE proposal leads to either #x99 [or #x66 depending on which order the implementation chooses to do the actual stores in]. In addition, if 'integer' is replaced by '(car x)' here, then the  behavior is different under the TEMPORARY-VARIABLE proposal because  that only applies to symbols. Implicitly, two "places" are being specified here to be updated; but in fact the two places are not independent -- they both involve setq'ing the variable 'integer'.  Furthermore, each store operation implicitly requires fetching the value from that place in order to combine it with DPB.  It is necessary to delay the accesses until the last moment before combining with DPB in order to see the side-effects of the earlier store operations.*start*10989 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 01:46:24 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 24 May 88  01:45:20 PDTReceived: by labrea.stanford.edu; Tue, 24 May 88 01:45:34 PDTReceived: from bhopal.lucid.com by edsel id AA04591g; Tue, 24 May 88 01:32:20 PDTReceived: by bhopal id AA04754g; Tue, 24 May 88 01:36:12 PDTDate: Tue, 24 May 88 01:36:12 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805240836.AA04754@bhopal.lucid.com>To: masinter.paCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 23 May 88 17:56 PDT <880523-175658-5823@Xerox>Subject: Issue: SETF-SUB-METHODS (Version 2)--text follows this line--Issue: 		SETF-SUB-METHODSReferences: 	CLtL pp. 95-96, 99, 105-106, 166		Issue: PUSH-EVALUATION-ORDERCategory: 	ClarificationEdit history:  Version 1 JonL White & Ken Olum 12-Feb-88		(based on problem originally called SETF-METHOD-FOR-SYMBOLS)               Version 2 JonL White 23-May-88 (fix references and spellings).Problem description:Tim Daly of IBM noticed that several implementations do not observeleft-to-right order of evaluation in the following form:     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6))In these implementations, the side-effect of the setq happens before the evaluation of the "subforms" necessary to fetch the list being updated. A typical result is that 'r' = (B 6), 's' = (A 1 B 2 C 3) after the operation.  Surely, it should at least be the case that 's' = (A 1 B 6 C 3), since the expectation is that the B property in this list is being (destructively) changed.Similar problems exist with LDB and CHAR-BIT.It is not necessary to clarify that left-to-right order of evaluationsemantics should be observed; CLtL p99 is quite explicit about that.Rather, a distinction needs to be made between the computations involvedin "evaluation" of the subforms, and other computations that are implicitin the notion of "doing an access" or "doing a store".The issue PUSH-EVALUATION-ORDER is a clarification about just the pointof the evaluation order for the various subforms to a PUSH;  thus thereis a similarity to this issue, but the current one has a much deeperproblem because of the need to call GET-SETF-METHOD during setf macroexpansion.Proposal:	SETF-SUB-METHODS:DELAYED-ACCESS-STORESElaborate the documentation of SETF, especially in the case of accessforms whose sub-forms are permitted to be generalized variable references[and thus which need to call GET-SETF-METHOD during setf macro expansion].We remember that GET-SETF-METHOD returns the following:  Some temporary variables  A list of value-producing forms  A list of store-variables (normally one).  A storing form.  An accessing form.Then we want to say that:  Code generated using GET-SETF-METHOD does 2 or 3 of the following  things:  It evaluates the value-producting forms, and binds the temporary  variables to them.  This will be called "binding the temporaries."  It evaluates the accessing form to get the old value of the place.  This will be called "doing the access."  It binds the store-variable to a new value and calls the storing form  to install it in the place.  This will be called "doing the store."  The forms listed at the top of CLtL p96 permit recursive <place>  specifiers; for each one, we will describe how the sub-recursive   information from GET-SETF-METHOD is used.  LDB:     In a form such as    (SETF (LDB <byte-spec> <place-form>) <value-form>)    the place referred to by the <place-form> must always be both    accessed and updated.  Even if the <place-form> refers to a    bignum, the bignum itself will not be modified but rather a new    bignum stored in the <place-form>.  Thus this SETF should generate    code to do the following:    1. Evaluate <byte-spec>    2. Bind the temporaries for <place-form>    3. Evaluate <value-form>    4. Do the access to <place-form>    5. Do the store into <place-form> with the given bit-field    replaced with the value from step 3.    If the evaluation of <value-form> in step 3 sets a different    bit-field in the given place then since the access is done later    at step 4 this change will be preserved.  See ROTATEF example in    discussion below.  Nevertheless the evaluations required for    binding the temporaries are done in step 2, and thus the expected    left-to-right evaluation order is seen.  GETF:    The case of GETF is complicated by the fact that two different    "place" locators are involved: one to use if the specified    indicator is present in the property list, and another if not.    For example, in (SETF (GETF (AREF ... I) 'B) 6), if the I'th slot    of the array is NIL, then that slot must be changed, but if it    contains a list with the property B then only the cons cell with    that property value needs to be changed.  This decision cannot be    made at macro-expansion time.  It depends entirely on the contents    of the list in question, and so must be delayed until the last    possible moment.    In the first place, GETF should be listed among the other place    forms that admit place forms as one of their arguments.  See CLtL    at the bottom of p95 and the top of p96.    More specifically, the expansion of     (SETF (GETF <place-form> <ind-form>) <value-form>)    should generate code to do the following:    1. Bind the temporaries for <place-form>     2. Do the access to <place-form>       [Binding the temporaries and then doing the access is equivalent to        evaluating the <place-form>.]    3. Evaluate <ind-form> [and save the result in a temporary variable].    4. Check whether the value from 2 has the indicator from 3.    If so:	5A. Find cons-cell after indicator from above	6A. Evaluate <value-form>	7A. RPLACA cons-cell from 5A with value from 6A	    [In this case, we do not do a store into <place-form>.  When 	     the indicator is already present then the location specifed 	    by <place-form> doesn't need a new value.]    If not:	5B. Evaluate <value-form>	6B. Do the access to <place-form>, using the temporaries saved from 	    step 1 [this is not another evaluation -- but it may involve	    some non trivial computation, depending on how complex the	    access method really is.].	7B. Do the store into <place-form>, again using the temporaries saved	    from step 1, setting it to a list with indicator from 3, new value	    from 5B, and old list from 6B.Test Cases:      (setq integer #x69)      (rotatef (ldb (byte 4 4) integer) (ldb (byte 4 0) integer))Rationale: As a principle,    (setf (foo-a x) (setf (foo-b x) ...)) should always set both of the "slots" of X, even if these slots are  implemented as bit-fields, getf-properties, and so on. However,    (setf (foo-a x) (setf (foo-a x) ...))  is an error [that is, what happens is undefined.]Current Practice: -- Xerox and Franz already operate on GETF according to this perscription. -- Symbolics and Lucid differ by always doing a setf on the variable    rather than updating the appropriate cons cell of the property list;     additionally, they fail to connect the new value put into 'r' to the    original property list which was 'r's value initially. -- HP and VAX  Common Lisps update the cons cell, but then set the variable    'r' again, nullifying the effect of the "(setq r nil)" in the <value-form>    computation.Adoption cost: Several implementations would require several hours of programmer and documentation time.Cost of non-adoption: Users will think SETF is unnatural in that left-to-right order of evaluation isn't always observed.Benefits: Uniform semantics and portability in the face of recursive "place specifiers" for SETF.  Setf of (LDB ... <place>) and of (GETF <place> ...) will behave uniformly no matter the nature of the <place>. Anyone who has copied examples from p105 and p106 will continue to be able to use them.Conversion Cost: This is a clarification of a point not sufficiently elaborated in CLtL. Symbolics and Lucid are already modifying their interpretation of this code -- in some way or other.Esthetics: See "Cost of non-adoption"Discussion: In the case that spurred this discussion,     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6)) the consequent update is a RPLACA to some list cell -- not a setf of the variable 'r' -- and thus 'r' should be NIL and 's' should now be (A 1 B 6 C 3). There is an interesting parallel between this case for GETF and the very common mistake made by Lisp programmers with respect to the  function DELETE.  How often the complaint is filed that DELETE didn't do anything when it should have; but in fact the filer simply forgot that delete can either update some CAR slot of the list originally  given it, or return some tail of the list originally give it, but not both!  E.g.      (setq l '(a a b c d)) ==> (a a b c d)      (delete 'a l)         ==> (b c d)      l 		      ==> (a a b c d) The unwary user thinks that because 'l' is still eq to the original value that "DELETE didn't do anything".  The variability of action at runtime here parallels the variable choice of location specifier for (SETF (GETF ...) ...) A previous proposal to fix this problem was misdirected.  It was phrased as follows:      Proposal: SETF-METHOD-FOR-SYMBOLS:TEMPORARY-VARIABLE      Change the result of (get-setf-method 'foo) from      NIL NIL (#:G1174) (SETQ FOO #:G1174) FOO      to      (#:G1175) (FOO) (#:G1174) (SETQ FOO #:G1174) #:G1175 The problem with this is that it breaks a relatively simple client of  setf technology:      (setq integer #x69)      (rotatef (ldb (byte 4 4) integer) (ldb (byte 4 0) integer)) no longer does the "right thing".  Using the prescription for setf methods on symbols from  CLtL p105, the result of this 'rotatef' is that integer = #x96; using that given by the TEMPORARY-VARIABLE proposal leads to either #x99 [or #x66 depending on which order the implementation chooses to do the actual stores in]. In addition, if 'integer' is replaced by '(car x)' here, then the  behavior is different under the TEMPORARY-VARIABLE proposal because  that only applies to symbols. Implicitly, two "places" are being specified here to be updated; but in fact the two places are not independent -- they both involve setq'ing the variable 'integer'.  Furthermore, each store operation implicitly requires fetching the value from that place in order to combine it with DPB.  It is necessary to delay the accesses until the last moment before combining with DPB in order to see the side-effects of the earlier store operations.*start*01326 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAY 88 18:02:50 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 May 88  18:01:02 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 MAY 88 17:56:58 PDTDate: 23 May 88 17:56 PDTFrom: masinter.paSubject: Re: Issue: SETF-SUB-METHODSIn-reply-to: Jon L White <edsel!jonl@labrea.Stanford.EDU>'s message of Fri, 12 Feb 88 23:31:35 PSTTo: edsel!jonl@labrea.Stanford.EDUcc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880523-175658-5823@Xerox>The issue SETF-METHOD-FOR-SYMBOLS is withdrawn, and it is probably confusing toleave it in the references section.  PUSH-EVALUATION-ORDER, however, is relevantand in fact addresses many of the same issues; however PUSH-EVALUATION-ORDERdoes not put any constraints on the GET-SETF-METHOD for functions like LDB andGETF.My notes from the last meeting was that this was "in discussion", but nosubsequent discussion has been held. I'd like to see this updated if only tomake it clear that the issues, while related, are not the same asPUSH-EVALUATION-ORDER.Nit: spell out names in Edit History, e.g.,Edit history:  Version 1 JonL White & Ken Olum 12-Feb-88		(based on SETF-METHOD-FOR-SYMBOLS)*start*09046 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 12:03:25 PDTReceived: from JASPER.SCRC.Symbolics.COM ([128.81.41.58]) by SAIL.Stanford.EDU with TCP; 24 May 88  12:01:15 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by JASPER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 191861; Tue 24-May-88 15:01:03 EDTDate: Tue, 24 May 88 15:01 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-SUB-METHODS (Version 2)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8805240836.AA04754@bhopal.lucid.com>Message-ID: <19880524190108.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 24 May 88 01:36:12 PDT    From: Jon L White <edsel!jonl@labrea.stanford.edu>I have read this proposal carefully and I generally approve the approachof SETF-SUB-METHODS:DELAYED-ACCESS-STORES, however it needs some more work.The test cases are inadequate (easily corrected), and the proposal isincoherent in the sense that what it proposes for LDB and what itproposes for GETF are not consistent, I think.  Also modify-macrossuch as INCF are involved with this issue as well.  Comments follow.      The forms listed at the top of CLtL p96 permit recursive <place>      specifiers; for each one, we will describe how the sub-recursive       information from GET-SETF-METHOD is used.You left out MASK-FIELD and CHAR-BIT.  I assume you mean for MASK-FIELDto do the same as LDB; you should say so explicitly.  The steps forCHAR-BIT should be written out explicitly since the arguments are notthe same as for LDB.	In a form such as	(SETF (LDB <byte-spec> <place-form>) <value-form>)	the place referred to by the <place-form> must always be both	accessed and updated.  This assumes that zero-bit bytes may not be optimized out.  We couldeither say that, or say that it is unspecified whether the <place-form>is updated if the value is not changed.  The value could be unchangedbecause the byte has zero width or because the value being stored isequal to the current value.  I mildly prefer the former (see analogousissue with GETF below).I agree with your step by step explication of SETF of LDB (omittedfrom this reply).	The case of GETF is complicated by the fact that two different	"place" locators are involved: one to use if the specified	indicator is present in the property list, and another if not.	For example, in (SETF (GETF (AREF ... I) 'B) 6), if the I'th slot	of the array is NIL, then that slot must be changed, but if it	contains a list with the property B then only the cons cell with	that property value needs to be changed.I strongly disagree with this.  I think it's wrong to specify thatSETF of GETF does not store into the <place> if the value that wouldbe stored there happens to be EQ to what is already there.  Common Lispshould either leave it unspecified, or require that the store alwaystake place (I prefer the latter).  Some might argue that requiring thestore always to take place eliminates a potential performance optimization,but I suspect that it is more efficient to do the store than to checkwhether it needs to be done.The reasons it matters whether the store happens when the value isn'tchanging are twofold.  First, there is the example in the problem statementfor this issue, which leaves a different value in the variable R ifthe store is optimized out when the property is already present.  Second,the store can involve calling a user-defined function which might haveother side-effects.  This can happen with DEFSETF and is even more likelywith CLOS use of SETF that invokes methods.  I think it's better to saythat a SETF always stores into <place>, even if the value being stored isEQ to what is already there, and even if SETF also does other side-effects.The general rules that I would propose to appear in the documentationfor SETF of a function whose argument is a <place> would be either:  Evaluations are performed left to right.  The <place> is not read until all evaluations have been performed.  The <place> is always written.or:  Evaluations are performed left to right.  The <place> is read at the time it would be read if   the <place-form> were evaluated.  The <place> is always written.For choosing between these two possible sets of rules, see discussion below.	More specifically, the expansion of 	(SETF (GETF <place-form> <ind-form>) <value-form>)	should generate code....Instead of what JonL proposed, I prefer the following:	1. Bind the temporaries for <place-form> 	2. Evaluate <ind-form>	3. Evaluate <value-form>	4. Do the access to <place-form>	5. Use the results from 2, 3, and 4 to modify the property list        6. Do the store into <place-form> of the updated property listDeferring the access to <place-form> until after all the evaluations isconsistent with what JonL proposed for LDB.  So is only accessing<place-form> once.  However, is the behavior this produces intuitive?See test case below.    Test Cases:	  (setq integer #x69)	  (rotatef (ldb (byte 4 4) integer) (ldb (byte 4 0) integer))This test case is inadequate, since it does not specify what theintended result is.  May I suggest adding:          integer => #x96assuming that that is the result you intend to propose as correct.This test case is also inadequate since no test cases for the otheraffected functions were included.  May I suggest:          (setq integer #x69)	  (setf (mask-field (byte 4 4) integer) (incf integer)) => #x6A          integer => #x6A	  (setf (mask-field (byte 4 4) integer) (ash (incf integer) 4)) => #x6B0          integer => #xBB          (setq l (list #x69))          (rotatef (ldb (byte 4 4) (car l)) (ldb (byte 4 0) (car l)))          l => (#x96))          (setq char (make-char #\A 1)) => #\c-A	  (rotatef (char-bit char :control) (char-bit char :meta))	  char => #\m-A	  (setq r '(a 1 b 2 c 3))	  (setq s r)	  (setf (getf r 'b) (progn (setq r nil) 6)) => 6          r => (b 6)		;result from what I proposed above          s => (a 1 b 2 c 3)	  r => nil		;JonL's result	  s => (a 1 b 6 c 3)          r => (a 1 b 6 c 3)	;result from always storing, but doing          s => (a 1 b 6 c 3)	;the access in the usual order	  (setq a (vector 1))          (incf (aref a 0) (incf (aref a 0)))          (aref a 0) => 4	;result if access happens after eval          (aref a 0) => 3	;result if access happens in usual orderI guess the char-bit test case won't run in implementations that don'thave both of those char bits.For the getf test case I have shown three possible results, and forthe incf test case I have shown two.  We have to decide which we want.    Current Practice:     -- Xerox and Franz already operate on GETF according to this perscription.     -- Symbolics and Lucid differ by always doing a setf on the variable	rather than updating the appropriate cons cell of the property list; 	additionally, they fail to connect the new value put into 'r' to the	original property list which was 'r's value initially.I can't figure out what you mean by the above.  Symbolics Genera 7.2certainly does update the appropriate cons cell of the property list andcertainly does modify s's value; it produces the third of the threeresults I've listed for the test case.     -- HP and VAX  Common Lisps update the cons cell, but then set the variable	'r' again, nullifying the effect of the "(setq r nil)" in the <value-form>	computation.    Discussion:     There is an interesting parallel between this case for GETF and the     very common mistake made by Lisp programmers with respect to the      function DELETE.  How often the complaint is filed that DELETE didn't     do anything when it should have; but in fact the filer simply forgot     that delete can either update some CAR slot of the list originally      given it, or return some tail of the list originally give it, but     not both!Not true.  For example, (delete 'a '(a a b a d)) does both (assumingI correctly understand what you meant by the typo "update some CAR slot").I agree that there is a parallel.     A previous proposal to fix this problem was misdirected.  It was     phrased as follows:	  Proposal: SETF-METHOD-FOR-SYMBOLS:TEMPORARY-VARIABLEAgreed.     Implicitly, two "places" are being specified here to be updated; but     in fact the two places are not independent -- they both involve setq'ing     the variable 'integer'.  Furthermore, each store operation implicitly     requires fetching the value from that place in order to combine it     with DPB.  It is necessary to delay the accesses until the last moment     before combining with DPB in order to see the side-effects of the     earlier store operations.Agreed, except that the test cases above show that it's not so clear-cutthat we want to delay the accesses.Anyone have any ideas of the direction out of this morass?*start*17581 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 MAY 88 19:42:19 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 26 May 88  19:39:32 PDTReceived: by labrea.stanford.edu; Thu, 26 May 88 19:39:48 PDTReceived: from bhopal.lucid.com by edsel id AA19962g; Thu, 26 May 88 19:25:45 PDTReceived: by bhopal id AA06629g; Thu, 26 May 88 19:29:49 PDTDate: Thu, 26 May 88 19:29:49 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805270229.AA06629@bhopal.lucid.com>To: cl-cleanup@sail.stanford.eduSubject: Issue:	SETF-SUB-METHODS (Version 4)Issue: 		SETF-SUB-METHODSReferences: 	CLtL pp. 95-96, 99, 105-106, 166		Issue: PUSH-EVALUATION-ORDERCategory: 	CLARIFICATIONEdit history:  Version 1: JonL White & Ken D. Olum 12-Feb-88		(based on problem originally called SETF-METHOD-FOR-SYMBOLS)               Version 2: JonL White 23-May-88 (fix references and spellings).               Version 3: JonL White 25-May-88                 (Incorporate suggestions of moon:                    Add explicit details for CHAR-BIT and MASK-FIELD.                    Alter proposed semantics for setf-of-getf to accord with                      current practice, rather than as suggested by original                      correspondent; add defense for this interpretaton.		 Delete references to the misleading, retracted proposal 			[SETF-METHOD-FOR-SYMBOLS:TEMPORARY-VARIABLE]                 Retracted misleading references about DELETE.                 Clarify and unify overall presentation.)               Version 4: JonL White & Ken D. Olum 26-May-88 (final insights!)Problem description:Tim Daly of IBM noticed an anomaly in that several implementations do not appear to observe left-to-right order of evaluation in the following form:     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6))In these implementations, the side-effect of the setq appears to happen beforethe evaluation of the place form (getf r 'b) which is necessary to fetch the list being updated.   A typical result is 'r' = (B 6), 's' = (A 1 B 2 C 3)after the operation.  There is a similar problem with SETF's over LDB, MASK-FIELD, and CHAR-BIT.It is not necessary to clarify that left-to-right order of evaluationsemantics should be observed; CLtL p99 is quite explicit about that.Rather, a distinction needs to be made between the computations involvedin "evaluation" of the subforms, and other computations that are implicitin the notion of "doing an access" or "doing a store".There are implications in this issue for the "read-modify-write" macrossuch as INCF, DECF, PUSH, POP, and REMF, as well as for PSETF, SHIFTF, andROTATEF.  However, a good underpinning for SETF over the basic accessorsis all that is necessary in order to assure correct treatement for themore compound forms.The issue PUSH-EVALUATION-ORDER is a clarification about just the pointof the evaluation order for the various subforms to a PUSH;  thus thereis a similarity to this issue, but the present issue has a much deeperproblem because of the need to call GET-SETF-METHOD during setf macroexpansion.Proposal:	SETF-SUB-METHODS:DELAYED-ACCESS-STORESWe propose to elaborate the documentation of SETF, specifically in the case of access forms whose sub-forms are permitted to be generalized variable references [and which thus need to call GET-SETF-METHOD during setf macro expansion] in the ways described below.Here are the specific steps for interpreting a SETF of an access function which itself admits a generalized variable as an argument.  Remember, first,that GET-SETF-METHOD returns the following:   -- Some temporary variables   -- A list of value-producing forms   -- A list of store-variables (normally one).   -- A storing form.   -- An accessing form.The code produced as the macro expansion of such a SETF form must essentiallydo the following major steps:  ** It evaluates the value-producing sub-forms, in left-to-right order, and      binds the temporary variables to them.  This will be called "binding the      temporaries."  ** It "reads the value" from the generalized variable using the supplied      accessing form, to get the "old value";  this will be called "doing the     access."  [Note that this is done after all the evaluations of the      preceeding step, including any side-effects they may have.]  ** It binds the store-variable to a new value, and then installs this     new value into the generalized variable using the supplied "storing      form".   This will be called "doing the store."In particular, we must emphasize the fact that "reading the value" of a generalized variable reference is not part of the series of evaluations that must be done in left-to-right order.  Compare this with the statement of CLtL p99, third from last paragraph, "... the generalized variables areboth read and written in the same reference.  Preserving the sourceprogram order of evaluation and the number of evaluations is equally important." Note carefully that in the (degenerate?) case when a generalized variable is in fact simply a program variable, then there are no sub-forms to beconsidered "value-producing" forms; in fact, "doing the access" for sucha generalized variable (i.e. a program variable) is functionally thesame as evaluating it.  This explains why the behaviour that Tim Daly observed is at first perplexing -- the "do the access" step has the samesemantics as an evaluation step, even though it is done after all theprescribed evaluations.The place-specifier forms listed at the top of CLtL p96 permit admit (other)place-specifiers as arguments; during the SETF expansion of these forms, it is necessary to call GET-SETF-METHOD in order to figure out how the inner, nested generalized variable must be treated.   We require that GETF be listed among these forms, since it must have a sub-recursive <place> specifier [however, there is no Common Lisp function serving as a pseudo-update functionfor it, the way DPB serves for LDB].  See CLtL at the bottom of p95 and the top of p96.For each place-specifier form with a sub-recursive place specifier, we will now describe how the information from GET-SETF-METHOD is used.  CHAR-BIT:    In a form such as:        (SETF (CHAR-BIT <place-form> <bit-name>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated; note that the update is to the generalized variable     specified by <place-form> -- not to a character object itself.    Thus this SETF should generate code to do the following:    1. Bind the temporaries for <place-form>    2. Evaluate <bit-name> (and bind into a temporary)    3. Evaluate <value-form> (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form>, with the given bit-name of the        character fetched in step 4 changed to reflect the value from step 3.    If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different "bit" of the character --    then the change of the bit denoted by <bit-name> will be to that altered    character, because the "access" step is done after the <value-form>    evaluation.  See example 1 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2, and thus the expected left-to-right evaluation order is seen.  LDB:     In a form such as:        (SETF (LDB <byte-spec> <place-form>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated;  note that the update is to the generalized variable     specified by <place-form> -- not to any object of type integer.    Thus this SETF should generate code to do the following:    1. Evaluate <byte-spec> (and bind into a temporary)    2. Bind the temporaries for <place-form>    3. Evaluate <value-form>  (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form> with the given bit-field of the integer       fetched in step 4 replaced with the value from step 3.    If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different bit-field of the integer --    then the change of the bit-field denoted by <byte-spec> will be to that     altered integer, because the "access" step is done after the <value-form>    evaluation.  See example 2 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2, and thus the expected left-to-right evaluation order is seen.  MASK-FIELD:   This case is the same as LDB in all essential aspects.  GETF:    In a form such as:        (SETF (GETF <place-form> <ind-form>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated;  note that the update is to the generalized variable     specified by <place-form> -- not necessarily to the particular list    which is the property list in question.    Thus this SETF should generate code to do the following:    1. Bind the temporaries for <place-form>     2. Evaluate <ind-form> (and bind into a temporary)    3. Evaluate the <value-form> (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form> with a possibly-new property list       obtained by combining the values from steps 2, 3, and 4.      If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different named property in the list,    then the change of the property denoted by <ind-form> will be to that     altered list, because the "access" step is done after the <value-form>    evaluation.  See example 7 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2,  and thus the expected left-to-right evaluation order is seen.    Note that this phrase "possibly-new property list" treats the     implementation of property lists as a "black box"  -- it can mean that     the former property list is somehow destructively re-used, or it can     mean partial or full copying of it.  This is like the question of REMOVE    or DELETE -- do you copy or do you destructively alter.  Since the answer    could go either way, the treatment of the resultant value for the     "possibly-new property list" must proceed as if it were a different copy    needing to be stored back into the generalized variable.Test Cases:  1. (setq char (make-char #\A 1))         ==>  #\Control-A     (rotatef (char-bit char :control)               (char-bit char :meta))       ==>  <dont care>     char  ==>  #\Meta-A     ;; It's as if you start with #\Control-A, and then first turn the     ;;  :control bit off, because the :meta bit was originally off; and     ;;  then to the resulting #\A,  you add the :meta bit since the     ;;  :control bit was originally on.     Note, however, that if an implementation doesn't support both of these     character 'bits', then this test case would have to be re-written to     reference two independent bits actually supported.  If an implementation     supports fewer than two independent character bits, then this test case     is entirely moot.  2. (setq integer #x69)                   ==>  #x69     (rotatef (ldb (byte 4 4) integer)               (ldb (byte 4 0) integer))    ==>  <dont care>     integer  ==>  #x96     ;; This very-realistic example is simply trying to swap two     ;;  independent bit fields in an integer.  Note that the generalized     ;;  variable of interest here is just the (possibly local) program     ;;  variable 'integer'.  3a.(setq l1 (setq l2 (list #x69)))                ==>  (#x69)     (setf (ldb (byte 4 4) (car l1))	   (ldb (byte 4 0) (car (prog1 l1                                   (setq l1 nil))))) ==>  <dont care>     l1 ==> nil     l2 ==> (#x99)     ;; Note that the (setq l1 nil) didn't affect the actions of the setf     ;;  at all, since l1 was evaluated and its value was saved away in a     ;;  temporary variable as part of the step "2. Bind the temporaries      ;;  for <place-form>", and this was done before the evaluation of the     ;;  <value-form> which contains the (setq l1 nil).  Note also that the     ;;  step "4. Do the access to <place-form>" means fetching the CAR of     ;;  the saved (temporary) value of 'l1'; it does not mean doing a LDB     ;;  on anything like that.  3b.(setq l1 (setq l2 (list #x69)))                ==>  (#x69)     (setf (ldb (byte 4 4) (car l1))	   (ldb (byte 4 0) (car (rplaca l1 #x17)))) ==>  <dont care>     l1 ==> (#x77)     l2 ==> (#x77)     ;; Note that the (rplaca l1 #x17) altered the contents of what l1     ;;  was pointing to.  Thus even though l1 was evaluated and its       ;;  value was saved away in a temporary variable as part of the step      ;;  "2. Bind the temporaries for <place-form>", and even though this      ;;  was done before the evaluation of the <value-form> which contains      ;;  the rplaca, still the side-effect changes things because it alters     ;;  what will be fetched during the "do the access" step.  4. (setq integer #x69)     (setf (mask-field (byte 4 4) integer) (incf integer)) => #x6A     integer ==> #x6A  5. (setq integer #x6A)     (setf (mask-field (byte 4 4) integer) (ash (incf integer) 4)) => #x6B0     integer => #xBB  6. (setq s (setq r (list 'a 1 'b 2 'c 3)))         ==>  (a 1 b 2 c 3)     (setf (getf r 'b)            (progn (setq r nil) 6))                   ==>  6     r ==> (b 6)     s ==> (a 1 b 2 c 3)     ;; Note that the generalized variable of concern here is the (degenerate?)     ;;  one of simply the program variable 'r'; it is not a property-list      ;;  slot denoted by (getf r 'b).   At the time the step "4. Do the access     ;;  to <place-form>" is performed, the evaluation of the <value-form>     ;;  has already altered the generalized variable 'r', and thus a nil is     ;;  returned for this access; that is why a fresh property-list (B 6) is     ;;  created an stored back into 'r'.  7. (setq s (setq r (list (list 'a 1 'b 2 'c 3))))  ==>  ((a 1 b 2 c 3))     (setf (getf (car r) 'b)            (progn (setq r nil) 6))                   ==>  6     r ==> nil     s ==> ((A 1 B 6 C 3))     ;; Note that the (setq r nil) does not affect the actions of the setf      ;;  because the value of R had already been saved in a temporary variable     ;;  as part of the step "1. Bind the temporaries for <place-form>".  Only     ;;  the CAR of this value will be accessed, and subsequently modified      ;;  after the value computation.Rationale:As a principle,    (setf (foo-a x) (progn (setf (foo-b x) ...)                           new-a-value))should always set both of the "slots" of 'x', even if these slots are implemented as bit-fields, getf-properties, and so on.  Only by separating out evaluation from "generalized variable access", and by specifying thatthe access is done after all the evaluations, can this correctly be done.Current Practice:Symbolics and Lucid already operate pretty much according to this proposal.Cost to Implementors:Several implementations would require several hours of programmer anddocumentation time.Cost to Users:None; this is a clarification of a point not sufficiently elaborated in CLtL.Cost of non-adoption:Users will think SETF is unnatural in that left-to-right order ofevaluation isn't well specified.Benefits:Uniform semantics and portability in the face of recursive "place specifiers"for SETF.  Setf of (LDB ... <place>) and of (GETF <place> ...) will behaveuniformly no matter the nature of the <place>.Anyone who has copied examples from p105 and p106 will continue tobe able to use them.Esthetics:See "Cost of non-adoption"Discussion:In the detailed descriptions for each access form, the phrase    "the place referred to by the <place-form> must always be both      accessed and updated; note that the update is to the generalized      variable specified by <place-form>"is not intended to prevent optimizations that could occur when thecode "knows" that the new value will be EQ to the old one.  The onlyrequirements is that the results be semantically equivalent.There is an interesting parallel between this case for GETF and thevery common mistake made by Lisp programmers with respect to the function DELETE.  How often the complaint is filed that DELETE didn'tdo anything when it should have; but in fact the filer simply forgotthat delete, although permitted to destructively modify the originallist, may also return some tail of the list originally give it, whether or not an alteration occurs.      (setq l '(a a b c d)) ==> (a a b c d)      (delete 'a l)         ==> (b c d)      l 		    ==> (a a b c d)The unwary user thinks that because 'l' is still EQ to the original value that "DELETE didn't do anything".  The temptation to ignore the resultant value of DELETE parallels the temptation to forget about a need to performa final update to <place-form> in the setf-of-getf case.*start*00983 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 MAY 88 19:46:34 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 26 May 88  19:40:04 PDTReceived: by labrea.stanford.edu; Thu, 26 May 88 19:40:23 PDTReceived: from bhopal.lucid.com by edsel id AA19997g; Thu, 26 May 88 19:28:24 PDTReceived: by bhopal id AA06641g; Thu, 26 May 88 19:32:27 PDTDate: Thu, 26 May 88 19:32:27 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805270232.AA06641@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 24 May 88 15:01 EDT <19880524190108.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: SETF-SUB-METHODS I think Version 4 is finally worth reading.  I'm not sure about the currentpractice of Symbolics -- maybe you can comment upon it?-- JonL --*start*02517 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 JUN 88 14:32:02 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Jun 88  14:28:45 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 416043; Tue 7-Jun-88 17:28:49 EDTDate: Tue, 7 Jun 88 17:28 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue:	SETF-SUB-METHODS (Version 4)To: Jon L White <edsel!jonl@labrea.stanford.edu>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8805270229.AA06629@bhopal.lucid.com>Message-ID: <19880607212838.1.MOON@EUPHRATES.SCRC.Symbolics.COM>The writeup is much improved.  I favor SETF-SUB-METHODS:DELAYED-ACCESS-STORES.I don't think it's accurate to say there is no cost to users.  Forexample, the original setf of getf example, which was proposed by auser, will behave differently under this proposal than it behaved inseveral implementations.  Users of those implementations might have beendepending on the old behavior.  You can say there is no effect onportable programs, but you can't say that no users will be affected.Even users who had ported programs among several implementationsand mistakenly concluded that their programs were portable mightbe affected.I think the <dont care>s in the test cases should be removed.  CLtLspecifies specific values to be returned by all these forms; while those values are irrelevant to the current issue, I think it isbetter practice to include them in the test cases.  Otherwisesomeone might think you were proposing to stop specifying specificvalues to be returned, and allow the values to becomeimplementation-dependent.I was asked to provide Current Practice information for Symbolics:Symbolics Genera 7.2 foolishly adopted an earlier proposal(SETF-METHOD-FOR-SYMBOLS) before it was officially approved by X3J13 andits parent standards organization.  This proposal is incompatible withthat one, so Genera 7.2 does not implement the behavior described here,and fails test cases 1, 2, 4, 5, and 6.  I believe Symbolics Genera 7.1is closer to this proposal, however I don't have access to it so I didn'ttest it.I didn't test Symbolics CLOE, perhaps Kent can provide information on it.An earlier version of the proposal had Current Practice informationfor Xerox, Franz, HP, and DEC.  Where did it go?*start*00999 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 JUN 88 00:56:50 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 10 Jun 88  00:56:15 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 10 JUN 88 00:45:32 PDTDate: 10 Jun 88 00:45 PDTFrom: Masinter.paSubject: Re: Issue:	SETF-SUB-METHODS (Version 4)In-reply-to: Jon L White <edsel!jonl@labrea.stanford.edu>'s message of Thu, 26 May 88 19:29:49 PDTTo: edsel!jonl@labrea.stanford.educc: cl-cleanup@sail.stanford.eduMessage-ID: <880610-004532-6175@Xerox>My original take on this was that it was close to release status, but I think itdeserves to have Moon's comments incorporated. My personal preference would tocast it in imperative mode rather than first person plural but I wouldn't holdit up for that.My reading on this issue is that, once cl-cleanup gets it sorted out, there willbe no controversy in X3J13.*start*01291 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 JUN 88 15:30:27 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 10 Jun 88  15:13:08 PDTReceived: by labrea.stanford.edu; Fri, 10 Jun 88 15:12:05 PDTReceived: from bhopal.lucid.com by edsel id AA21973g; Fri, 10 Jun 88 15:08:21 PDTReceived: by bhopal id AA01830g; Fri, 10 Jun 88 15:07:04 PDTDate: Fri, 10 Jun 88 15:07:04 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8806102207.AA01830@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 7 Jun 88 17:28 EDT <19880607212838.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue:	SETF-SUB-METHODS (Version 4)re: An earlier version of the proposal had Current Practice information    for Xerox, Franz, HP, and DEC.  Where did it go?By modifying the part about (setf (getf ...) ...), the semantics were changed enough that I couldn't be sure what to say about these implementations.  Ithink the before-modification proposal was trying to defend the status quo; its likely that almost nobody fits the current description exactly now.-- JonL --*start*17213 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 15:33:49 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Oct 88  15:31:58 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 06 OCT 88 15:30:03 PDTDate: 6 Oct 88 15:29 PDTFrom: masinter.paTo: cl-cleanup@sail.stanford.eduSubject: Issue:	SETF-SUB-METHODS (Version 5)Message-ID: <881006-153004-1550@Xerox>This issue was last discussed on 10 June. I apparently passed over itmy last tour through the issues.I rewrote the problem description and proposal in third person.I added a "Performance Impact" section and made something up for it.I moved some of the text from "Problem" and "Proposal" to "Discussion" in an attempt to streamline it.!Issue: 		SETF-SUB-METHODSReferences: 	CLtL pp. 95-96, 99, 105-106, 166		Issue: PUSH-EVALUATION-ORDERCategory: 	CLARIFICATIONEdit history:  Version 1: JonL White & Ken D. Olum 12-Feb-88		(based on problem originally called SETF-METHOD-FOR-SYMBOLS)               Version 2: JonL White 23-May-88 (fix references and spellings).               Version 3: JonL White 25-May-88                Version 4: JonL White & Ken D. Olum 26-May-88 (final insights!)		Version 5: Masinter (respond to comments)Problem description:Implementations differ in the left-to-right orderof evaluation in the following form:     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6))In some implementations, the side-effect of the setq appears to happen beforethe evaluation of the place form (getf r 'b) which is necessary to fetch the list being updated.   A typical result is 'r' = (B 6), 's' = (A 1 B 2 C 3)after the operation. There is a similar problem with SETF's over LDB, MASK-FIELD, and CHAR-BIT.CLtL p99 is explicit about left-to-right order of evaluation.However, the specification is less clear about computations involvedin "evaluation" of the subforms, and other computations that are implicitin the notion of "doing an access" or "doing a store".Proposal:	SETF-SUB-METHODS:DELAYED-ACCESS-STORESThis proposal specifies more explicilty the behavior of SETF in the case  of access forms whose sub-forms are permitted to be generalized variable references [and which thus need to call GET-SETF-METHOD during setf macro expansion].Remember, first, that GET-SETF-METHOD returns the following:   -- Some temporary variables   -- A list of value-producing forms   -- A list of store-variables (normally one).   -- A storing form.   -- An accessing form.The code produced as the macro expansion of a SETF form thatitself admits a generalized variable as an argument must essentiallydo the following major steps:  ** It evaluates the value-producing sub-forms, in left-to-right order, and      binds the temporary variables to them.  This will be called "binding the      temporaries."  ** It "reads the value" from the generalized variable using the supplied      accessing form, to get the "old value";  this will be called "doing the     access."  [Note that this is done after all the evaluations of the      preceeding step, including any side-effects they may have.]  ** It binds the store-variable to a new value, and then installs this     new value into the generalized variable using the supplied "storing      form".   This will be called "doing the store.""Reading the value" of a generalized variable reference is not part ofthe series of evaluations  that must be done in left-to-right order. The place-specifier forms listed at the top of CLtL p96 permit admit (other)place-specifiers as arguments; during the SETF expansion of these forms, it is necessary to call GET-SETF-METHOD in order to figure out how the inner, nested generalized variable must be treated.  This proposal requires GETF be listed among these forms, since it must have a sub-recursive <place> specifier [however, there is no Common Lisp function serving as a pseudo-update functionfor it, the way DPB serves for LDB].  For each place-specifier form with a sub-recursive place specifier,  the information from GET-SETF-METHOD is used as follows.  CHAR-BIT:    In a form such as:        (SETF (CHAR-BIT <place-form> <bit-name>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated; note that the update is to the generalized variable     specified by <place-form> -- not to a character object itself.    Thus this SETF should generate code to do the following:    1. Bind the temporaries for <place-form>    2. Evaluate <bit-name> (and bind into a temporary)    3. Evaluate <value-form> (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form>, with the given bit-name of the        character fetched in step 4 changed to reflect the value from step 3.    If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different "bit" of the character --    then the change of the bit denoted by <bit-name> will be to that altered    character, because the "access" step is done after the <value-form>    evaluation.  See example 1 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2, and thus the expected left-to-right evaluation order is seen.  LDB:     In a form such as:        (SETF (LDB <byte-spec> <place-form>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated;  note that the update is to the generalized variable     specified by <place-form> -- not to any object of type integer.    Thus this SETF should generate code to do the following:    1. Evaluate <byte-spec> (and bind into a temporary)    2. Bind the temporaries for <place-form>    3. Evaluate <value-form>  (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form> with the given bit-field of the integer       fetched in step 4 replaced with the value from step 3.    If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different bit-field of the integer --    then the change of the bit-field denoted by <byte-spec> will be to that     altered integer, because the "access" step is done after the <value-form>    evaluation.  See example 2 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2, and thus the expected left-to-right evaluation order is seen.  MASK-FIELD:   This case is the same as LDB in all essential aspects.  GETF:    In a form such as:        (SETF (GETF <place-form> <ind-form>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated;  note that the update is to the generalized variable     specified by <place-form> -- not necessarily to the particular list    which is the property list in question.    Thus this SETF should generate code to do the following:    1. Bind the temporaries for <place-form>     2. Evaluate <ind-form> (and bind into a temporary)    3. Evaluate the <value-form> (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form> with a possibly-new property list       obtained by combining the values from steps 2, 3, and 4.      If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different named property in the list,    then the change of the property denoted by <ind-form> will be to that     altered list, because the "access" step is done after the <value-form>    evaluation.  See example 7 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2,  and thus the expected left-to-right evaluation order is seen.    Note that this phrase "possibly-new property list" treats the     implementation of property lists as a "black box"  -- it can mean that     the former property list is somehow destructively re-used, or it can     mean partial or full copying of it.  This is like the question of REMOVE    or DELETE -- do you copy or do you destructively alter.  Since the answer    could go either way, the treatment of the resultant value for the     "possibly-new property list" must proceed as if it were a different copy    needing to be stored back into the generalized variable.The "read-modify-write" macros such as INCF, DECF, PUSH, POP, and REMF, as well as PSETF, SHIFTF, and ROTATEF should be specified to have the same evalauation order for the subforms ofthe "place" arguments; this would generally follow from their definitionin terms of SETF.Test Cases:  1. (setq char (make-char #\A 1))         ==>  #\Control-A     (rotatef (char-bit char :control)               (char-bit char :meta))      char  ==>  #\Meta-A     ;; It's as if you start with #\Control-A, and then first turn the     ;;  :control bit off, because the :meta bit was originally off; and     ;;  then to the resulting #\A,  you add the :meta bit since the     ;;  :control bit was originally on.     Note, however, that if an implementation doesn't support both of these     character 'bits', then this test case would have to be re-written to     reference two independent bits actually supported.  If an implementation     supports fewer than two independent character bits, then this test case     is entirely moot.  2. (setq integer #x69)                   ==>  #x69     (rotatef (ldb (byte 4 4) integer)               (ldb (byte 4 0) integer))     integer  ==>  #x96     ;; This very-realistic example is simply trying to swap two     ;;  independent bit fields in an integer.  Note that the generalized     ;;  variable of interest here is just the (possibly local) program     ;;  variable 'integer'.  3a.(setq l1 (setq l2 (list #x69)))                ==>  (#x69)     (setf (ldb (byte 4 4) (car l1))	   (ldb (byte 4 0) (car (prog1 l1                                   (setq l1 nil)))))      l1 ==> nil     l2 ==> (#x99)     ;; Note that the (setq l1 nil) didn't affect the actions of the setf     ;;  at all, since l1 was evaluated and its value was saved away in a     ;;  temporary variable as part of the step "2. Bind the temporaries      ;;  for <place-form>", and this was done before the evaluation of the     ;;  <value-form> which contains the (setq l1 nil).  Note also that the     ;;  step "4. Do the access to <place-form>" means fetching the CAR of     ;;  the saved (temporary) value of 'l1'; it does not mean doing a LDB     ;;  on anything like that.  3b.(setq l1 (setq l2 (list #x69)))                ==>  (#x69)     (setf (ldb (byte 4 4) (car l1))	   (ldb (byte 4 0) (car (rplaca l1 #x17))))     l1 ==> (#x77)     l2 ==> (#x77)     ;; Note that the (rplaca l1 #x17) altered the contents of what l1     ;;  was pointing to.  Thus even though l1 was evaluated and its       ;;  value was saved away in a temporary variable as part of the step      ;;  "2. Bind the temporaries for <place-form>", and even though this      ;;  was done before the evaluation of the <value-form> which contains      ;;  the rplaca, still the side-effect changes things because it alters     ;;  what will be fetched during the "do the access" step.  4. (setq integer #x69)     (setf (mask-field (byte 4 4) integer) (incf integer)) => #x6A     integer ==> #x6A  5. (setq integer #x6A)     (setf (mask-field (byte 4 4) integer) (ash (incf integer) 4)) => #x6B0     integer => #xBB  6. (setq s (setq r (list 'a 1 'b 2 'c 3)))         ==>  (a 1 b 2 c 3)     (setf (getf r 'b)            (progn (setq r nil) 6))                   ==>  6     r ==> (b 6)     s ==> (a 1 b 2 c 3)     ;; Note that the generalized variable of concern here is the (degenerate?)     ;;  one of simply the program variable 'r'; it is not a property-list      ;;  slot denoted by (getf r 'b).   At the time the step "4. Do the access     ;;  to <place-form>" is performed, the evaluation of the <value-form>     ;;  has already altered the generalized variable 'r', and thus a nil is     ;;  returned for this access; that is why a fresh property-list (B 6) is     ;;  created an stored back into 'r'.  7. (setq s (setq r (list (list 'a 1 'b 2 'c 3))))  ==>  ((a 1 b 2 c 3))     (setf (getf (car r) 'b)            (progn (setq r nil) 6))                   ==>  6     r ==> nil     s ==> ((A 1 B 6 C 3))     ;; Note that the (setq r nil) does not affect the actions of the setf      ;;  because the value of R had already been saved in a temporary variable     ;;  as part of the step "1. Bind the temporaries for <place-form>".  Only     ;;  the CAR of this value will be accessed, and subsequently modified      ;;  after the value computation.Rationale:As a principle,    (setf (foo-a x) (progn (setf (foo-b x) ...)                           new-a-value))should always set both of the "slots" of 'x', even if these slots are implemented as bit-fields, getf-properties, and so on.  Only by separating out evaluation from "generalized variable access", and by specifying thatthe access is done after all the evaluations, can this correctly be done.Current Practice:Lucid Common Lisp already operates pretty much according to this proposal.Symbolics Genera 7.2 foolishly adopted an earlier proposal(SETF-METHOD-FOR-SYMBOLS) before it was officially approved by X3J13 andits parent standards organization.  This proposal is incompatible withthat one, so Genera 7.2 does not implement the behavior described here,and fails test cases 1, 2, 4, 5, and 6.  Symbolics Genera 7.1is probably closer to this proposal. Performance impact:Small. This proposal might slow down macro-expansion slightly,might cause some current optimizations not to work as well. However,the net effect is likely negligible.Cost to Implementors:In some implementations, this would require a careful revisiting ofthe handling of SETF and generalized variable modifiers.Cost to Users:Small; although this will impose an incompatible change on implementations that don't behave as proposed, and might havean effect on (non-portable) code, we believe the effectsare not widespread.Cost of non-adoption:SETF left-to-right order of evaluation will not be well specified;implementations will differ for no good reason.Benefits:Uniform semantics and portability in the face of recursive "place specifiers"for SETF.  Setf of (LDB ... <place>) and of (GETF <place> ...) will behaveuniformly no matter the nature of the <place>.Anyone who has copied examples from p105 and p106 will continue tobe able to use them.Esthetics:See "Cost of non-adoption"Discussion:This is a difficult proposal to specify.In the detailed descriptions for each access form, the phrase    "the place referred to by the <place-form> must always be both      accessed and updated; note that the update is to the generalized      variable specified by <place-form>"is not intended to prevent optimizations that could occur when thecode "knows" that the new value will be EQ to the old one.  The onlyrequirements is that the results be semantically equivalent.There is an interesting parallel between this case for GETF and thevery common mistake made by Lisp programmers with respect to the function DELETE.  How often the complaint is filed that DELETE didn'tdo anything when it should have; but in fact the filer simply forgotthat delete, although permitted to destructively modify the originallist, may also return some tail of the list originally give it, whether or not an alteration occurs.      (setq l '(a a b c d)) ==> (a a b c d)      (delete 'a l)         ==> (b c d)      l 		    ==> (a a b c d)The unwary user thinks that because 'l' is still EQ to the original value that "DELETE didn't do anything".  The temptation to ignore the resultant value of DELETE parallels the temptation to forget about a need to performa final update to <place-form> in the setf-of-getf case.In the (degenerate?) case when a generalized variable is in fact simply a program variable, then there are no sub-forms to beconsidered "value-producing" forms; in fact, "doing the access" for sucha generalized variable (i.e. a program variable) is functionally thesame as evaluating it.  This explains why the behaviour in the "Problem Description" is at first perplexing -- the "do the access" step has the samesemantics as an evaluation step, even though it is done after all theprescribed evaluations.The issue PUSH-EVALUATION-ORDER is a clarification about just the pointof the evaluation order for the various subforms to a PUSH;  thus thereis a similarity to this issue, but the present issue has a much deeperproblem because of the need to call GET-SETF-METHOD during setf macroexpansion.*start*02809 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 18:11:40 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  18:11:48 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472948; Fri 7-Oct-88 21:10:26 EDTDate: Fri, 7 Oct 88 21:10 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue:	SETF-SUB-METHODS (Version 5)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881006-153004-1550@Xerox>References: <19880607212838.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19881008011002.5.MOON@EUPHRATES.SCRC.Symbolics.COM>My comments on version 4, in the second referenced message, still apply.I guess I ought to repeat them:  [I guess the dont-cares have beenremoved, at least, I couldn't find them]Date: Tue, 7 Jun 88 17:28 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>The writeup is much improved.  I favor SETF-SUB-METHODS:DELAYED-ACCESS-STORES.I don't think it's accurate to say there is no cost to users.  Forexample, the original setf of getf example, which was proposed by auser, will behave differently under this proposal than it behaved inseveral implementations.  Users of those implementations might have beendepending on the old behavior.  You can say there is no effect onportable programs, but you can't say that no users will be affected.Even users who had ported programs among several implementationsand mistakenly concluded that their programs were portable mightbe affected.I think the <dont care>s in the test cases should be removed.  CLtLspecifies specific values to be returned by all these forms; while those values are irrelevant to the current issue, I think it isbetter practice to include them in the test cases.  Otherwisesomeone might think you were proposing to stop specifying specificvalues to be returned, and allow the values to becomeimplementation-dependent.I was asked to provide Current Practice information for Symbolics:Symbolics Genera 7.2 foolishly adopted an earlier proposal(SETF-METHOD-FOR-SYMBOLS) before it was officially approved by X3J13 andits parent standards organization.  This proposal is incompatible withthat one, so Genera 7.2 does not implement the behavior described here,and fails test cases 1, 2, 4, 5, and 6.  I believe Symbolics Genera 7.1is closer to this proposal, however I don't have access to it so I didn'ttest it.I didn't test Symbolics CLOE, perhaps Kent can provide information on it.An earlier version of the proposal had Current Practice informationfor Xerox, Franz, HP, and DEC.  Where did it go?*start*01169 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 OCT 88 21:49:48 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Oct 88  21:49:58 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 07 OCT 88 18:38:44 PDTDate: 7 Oct 88 18:38 PDTFrom: masinter.paSubject: Re: Issue: SETF-SUB-METHODS (Version 5)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 7 Oct 88 21:10 EDTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: cl-cleanup@sail.stanford.eduMessage-ID: <881007-183844-1594@Xerox>David: I thought I responded to almost all of your comments;In response to your complaint about "no cost to users", I rewrote Cost toUsers.I removed the <dont care>s from the test cases.I incorporated your remarks about Symbolics Genera 7.2 in Current Practice.I thought JonL had responded to the reason why he removed the CurrentPractice for Xerox, Franz, HP and DEC, and agreed that the test cases hadchanged and so regenerating them would require some extra work and not benecessary.*start*16608 00024 USfDate:  8 Oct 88 21:50 PDTSender: masinter.paSubject: Issue:	SETF-SUB-METHODS (Version 5)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue: 		SETF-SUB-METHODSReferences: 	CLtL pp. 95-96, 99, 105-106, 166		Issue: PUSH-EVALUATION-ORDERCategory: 	CLARIFICATIONEdit history:  Version 1: JonL White & Ken D. Olum 12-Feb-88		(based on problem originally called SETF-METHOD-FOR-SYMBOLS)               Version 2: JonL White 23-May-88 (fix references and spellings).               Version 3: JonL White 25-May-88                Version 4: JonL White & Ken D. Olum 26-May-88 (final insights!)		Version 5: Masinter (respond to comments)Problem description:Implementations differ in the left-to-right orderof evaluation in the following form:     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6))In some implementations, the side-effect of the setq appears to happen beforethe evaluation of the place form (getf r 'b) which is necessary to fetch the list being updated.   A typical result is 'r' = (B 6), 's' = (A 1 B 2 C 3)after the operation. There is a similar problem with SETF's over LDB, MASK-FIELD, and CHAR-BIT.CLtL p99 is explicit about left-to-right order of evaluation.However, the specification is less clear about computations involvedin "evaluation" of the subforms, and other computations that are implicitin the notion of "doing an access" or "doing a store".Proposal:	SETF-SUB-METHODS:DELAYED-ACCESS-STORESThis proposal specifies more explicilty the behavior of SETF in the case  of access forms whose sub-forms are permitted to be generalized variable references [and which thus need to call GET-SETF-METHOD during setf macro expansion].Remember, first, that GET-SETF-METHOD returns the following:   -- Some temporary variables   -- A list of value-producing forms   -- A list of store-variables (normally one).   -- A storing form.   -- An accessing form.The code produced as the macro expansion of a SETF form thatitself admits a generalized variable as an argument must essentiallydo the following major steps:  ** It evaluates the value-producing sub-forms, in left-to-right order, and      binds the temporary variables to them.  This will be called "binding the      temporaries."  ** It "reads the value" from the generalized variable using the supplied      accessing form, to get the "old value";  this will be called "doing the     access."  [Note that this is done after all the evaluations of the      preceeding step, including any side-effects they may have.]  ** It binds the store-variable to a new value, and then installs this     new value into the generalized variable using the supplied "storing      form".   This will be called "doing the store.""Reading the value" of a generalized variable reference is not part ofthe series of evaluations  that must be done in left-to-right order. The place-specifier forms listed at the top of CLtL p96 permit admit (other)place-specifiers as arguments; during the SETF expansion of these forms, it is necessary to call GET-SETF-METHOD in order to figure out how the inner, nested generalized variable must be treated.  This proposal requires GETF be listed among these forms, since it must have a sub-recursive <place> specifier [however, there is no Common Lisp function serving as a pseudo-update functionfor it, the way DPB serves for LDB].  For each place-specifier form with a sub-recursive place specifier,  the information from GET-SETF-METHOD is used as follows.  CHAR-BIT:    In a form such as:        (SETF (CHAR-BIT <place-form> <bit-name>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated; note that the update is to the generalized variable     specified by <place-form> -- not to a character object itself.    Thus this SETF should generate code to do the following:    1. Bind the temporaries for <place-form>    2. Evaluate <bit-name> (and bind into a temporary)    3. Evaluate <value-form> (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form>, with the given bit-name of the        character fetched in step 4 changed to reflect the value from step 3.    If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different "bit" of the character --    then the change of the bit denoted by <bit-name> will be to that altered    character, because the "access" step is done after the <value-form>    evaluation.  See example 1 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2, and thus the expected left-to-right evaluation order is seen.  LDB:     In a form such as:        (SETF (LDB <byte-spec> <place-form>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated;  note that the update is to the generalized variable     specified by <place-form> -- not to any object of type integer.    Thus this SETF should generate code to do the following:    1. Evaluate <byte-spec> (and bind into a temporary)    2. Bind the temporaries for <place-form>    3. Evaluate <value-form>  (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form> with the given bit-field of the integer       fetched in step 4 replaced with the value from step 3.    If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different bit-field of the integer --    then the change of the bit-field denoted by <byte-spec> will be to that     altered integer, because the "access" step is done after the <value-form>    evaluation.  See example 2 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2, and thus the expected left-to-right evaluation order is seen.  MASK-FIELD:   This case is the same as LDB in all essential aspects.  GETF:    In a form such as:        (SETF (GETF <place-form> <ind-form>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated;  note that the update is to the generalized variable     specified by <place-form> -- not necessarily to the particular list    which is the property list in question.    Thus this SETF should generate code to do the following:    1. Bind the temporaries for <place-form>     2. Evaluate <ind-form> (and bind into a temporary)    3. Evaluate the <value-form> (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form> with a possibly-new property list       obtained by combining the values from steps 2, 3, and 4.      If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different named property in the list,    then the change of the property denoted by <ind-form> will be to that     altered list, because the "access" step is done after the <value-form>    evaluation.  See example 7 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2,  and thus the expected left-to-right evaluation order is seen.    Note that this phrase "possibly-new property list" treats the     implementation of property lists as a "black box"  -- it can mean that     the former property list is somehow destructively re-used, or it can     mean partial or full copying of it.  This is like the question of REMOVE    or DELETE -- do you copy or do you destructively alter.  Since the answer    could go either way, the treatment of the resultant value for the     "possibly-new property list" must proceed as if it were a different copy    needing to be stored back into the generalized variable.The "read-modify-write" macros such as INCF, DECF, PUSH, POP, and REMF, as well as PSETF, SHIFTF, and ROTATEF should be specified to have the same evalauation order for the subforms ofthe "place" arguments; this would generally follow from their definitionin terms of SETF.Test Cases:  1. (setq char (make-char #\A 1))         ==>  #\Control-A     (rotatef (char-bit char :control)               (char-bit char :meta))      char  ==>  #\Meta-A     ;; It's as if you start with #\Control-A, and then first turn the     ;;  :control bit off, because the :meta bit was originally off; and     ;;  then to the resulting #\A,  you add the :meta bit since the     ;;  :control bit was originally on.     Note, however, that if an implementation doesn't support both of these     character 'bits', then this test case would have to be re-written to     reference two independent bits actually supported.  If an implementation     supports fewer than two independent character bits, then this test case     is entirely moot.  2. (setq integer #x69)                   ==>  #x69     (rotatef (ldb (byte 4 4) integer)               (ldb (byte 4 0) integer))     integer  ==>  #x96     ;; This very-realistic example is simply trying to swap two     ;;  independent bit fields in an integer.  Note that the generalized     ;;  variable of interest here is just the (possibly local) program     ;;  variable 'integer'.  3a.(setq l1 (setq l2 (list #x69)))                ==>  (#x69)     (setf (ldb (byte 4 4) (car l1))	   (ldb (byte 4 0) (car (prog1 l1                                   (setq l1 nil)))))      l1 ==> nil     l2 ==> (#x99)     ;; Note that the (setq l1 nil) didn't affect the actions of the setf     ;;  at all, since l1 was evaluated and its value was saved away in a     ;;  temporary variable as part of the step "2. Bind the temporaries      ;;  for <place-form>", and this was done before the evaluation of the     ;;  <value-form> which contains the (setq l1 nil).  Note also that the     ;;  step "4. Do the access to <place-form>" means fetching the CAR of     ;;  the saved (temporary) value of 'l1'; it does not mean doing a LDB     ;;  on anything like that.  3b.(setq l1 (setq l2 (list #x69)))                ==>  (#x69)     (setf (ldb (byte 4 4) (car l1))	   (ldb (byte 4 0) (car (rplaca l1 #x17))))     l1 ==> (#x77)     l2 ==> (#x77)     ;; Note that the (rplaca l1 #x17) altered the contents of what l1     ;;  was pointing to.  Thus even though l1 was evaluated and its       ;;  value was saved away in a temporary variable as part of the step      ;;  "2. Bind the temporaries for <place-form>", and even though this      ;;  was done before the evaluation of the <value-form> which contains      ;;  the rplaca, still the side-effect changes things because it alters     ;;  what will be fetched during the "do the access" step.  4. (setq integer #x69)     (setf (mask-field (byte 4 4) integer) (incf integer)) => #x6A     integer ==> #x6A  5. (setq integer #x6A)     (setf (mask-field (byte 4 4) integer) (ash (incf integer) 4)) => #x6B0     integer => #xBB  6. (setq s (setq r (list 'a 1 'b 2 'c 3)))         ==>  (a 1 b 2 c 3)     (setf (getf r 'b)            (progn (setq r nil) 6))                   ==>  6     r ==> (b 6)     s ==> (a 1 b 2 c 3)     ;; Note that the generalized variable of concern here is the (degenerate?)     ;;  one of simply the program variable 'r'; it is not a property-list      ;;  slot denoted by (getf r 'b).   At the time the step "4. Do the access     ;;  to <place-form>" is performed, the evaluation of the <value-form>     ;;  has already altered the generalized variable 'r', and thus a nil is     ;;  returned for this access; that is why a fresh property-list (B 6) is     ;;  created an stored back into 'r'.  7. (setq s (setq r (list (list 'a 1 'b 2 'c 3))))  ==>  ((a 1 b 2 c 3))     (setf (getf (car r) 'b)            (progn (setq r nil) 6))                   ==>  6     r ==> nil     s ==> ((A 1 B 6 C 3))     ;; Note that the (setq r nil) does not affect the actions of the setf      ;;  because the value of R had already been saved in a temporary variable     ;;  as part of the step "1. Bind the temporaries for <place-form>".  Only     ;;  the CAR of this value will be accessed, and subsequently modified      ;;  after the value computation.Rationale:As a principle,    (setf (foo-a x) (progn (setf (foo-b x) ...)                           new-a-value))should always set both of the "slots" of 'x', even if these slots are implemented as bit-fields, getf-properties, and so on.  Only by separating out evaluation from "generalized variable access", and by specifying thatthe access is done after all the evaluations, can this correctly be done.Current Practice:Lucid Common Lisp already operates pretty much according to this proposal.Symbolics Genera 7.2 foolishly adopted an earlier proposal(SETF-METHOD-FOR-SYMBOLS) before it was officially approved by X3J13 andits parent standards organization.  This proposal is incompatible withthat one, so Genera 7.2 does not implement the behavior described here,and fails test cases 1, 2, 4, 5, and 6.  Symbolics Genera 7.1is probably closer to this proposal. Performance impact:Small. This proposal might slow down macro-expansion slightly,might cause some current optimizations not to work as well. However,the net effect is likely negligible.Cost to Implementors:In some implementations, this would require a careful revisiting ofthe handling of SETF and generalized variable modifiers.Cost to Users:Small; although this will impose an incompatible change on implementations that don't behave as proposed, and might havean effect on (non-portable) code, we believe the effectsare not widespread.Cost of non-adoption:SETF left-to-right order of evaluation will not be well specified;implementations will differ for no good reason.Benefits:Uniform semantics and portability in the face of recursive "place specifiers"for SETF.  Setf of (LDB ... <place>) and of (GETF <place> ...) will behaveuniformly no matter the nature of the <place>.Anyone who has copied examples from p105 and p106 will continue tobe able to use them.Esthetics:See "Cost of non-adoption"Discussion:This is a difficult proposal to specify.In the detailed descriptions for each access form, the phrase    "the place referred to by the <place-form> must always be both      accessed and updated; note that the update is to the generalized      variable specified by <place-form>"is not intended to prevent optimizations that could occur when thecode "knows" that the new value will be EQ to the old one.  The onlyrequirements is that the results be semantically equivalent.There is an interesting parallel between this case for GETF and thevery common mistake made by Lisp programmers with respect to the function DELETE.  How often the complaint is filed that DELETE didn'tdo anything when it should have; but in fact the filer simply forgotthat delete, although permitted to destructively modify the originallist, may also return some tail of the list originally give it, whether or not an alteration occurs.      (setq l '(a a b c d)) ==> (a a b c d)      (delete 'a l)         ==> (b c d)      l 		    ==> (a a b c d)The unwary user thinks that because 'l' is still EQ to the original value that "DELETE didn't do anything".  The temptation to ignore the resultant value of DELETE parallels the temptation to forget about a need to performa final update to <place-form> in the setf-of-getf case.In the (degenerate?) case when a generalized variable is in fact simply a program variable, then there are no sub-forms to beconsidered "value-producing" forms; in fact, "doing the access" for sucha generalized variable (i.e. a program variable) is functionally thesame as evaluating it.  This explains why the behaviour in the "Problem Description" is at first perplexing -- the "do the access" step has the samesemantics as an evaluation step, even though it is done after all theprescribed evaluations.The issue PUSH-EVALUATION-ORDER is a clarification about just the pointof the evaluation order for the various subforms to a PUSH;  thus thereis a similarity to this issue, but the present issue has a much deeperproblem because of the need to call GET-SETF-METHOD during setf macroexpansion.*start*16886 00024 US Date: 12 Dec 88 14:54 PSTFrom: masinter.pato: masinterSubject: Issue: SETF-SUB-METHODS (Version 5)Issue:         SETF-SUB-METHODSReferences:    CLtL pp. 95-96, 99, 105-106, 166               Issue: PUSH-EVALUATION-ORDERCategory:      CLARIFICATIONEdit history:  Version 1: JonL White & Ken D. Olum 12-Feb-88                   (based on problem originally called SETF-METHOD-FOR-SYMBOLS)               Version 2: JonL White 23-May-88 (fix references and spellings).               Version 3: JonL White 25-May-88                Version 4: JonL White & Ken D. Olum 26-May-88 (final insights!)               Version 5: Masinter (respond to comments)Problem description:Implementations differ in the left-to-right orderof evaluation in the following form:     (setq r '(a 1 b 2 c 3))     (setq s r)     (setf (getf r 'b) (progn (setq r nil) 6))In some implementations, the side-effect of the setq appears to happen beforethe evaluation of the place form (getf r 'b) which is necessary to fetch the list being updated.   A typical result is 'r' = (B 6), 's' = (A 1 B 2 C 3)after the operation. There is a similar problem with SETF's over LDB, MASK-FIELD, and CHAR-BIT.CLtL p99 is explicit about left-to-right order of evaluation.However, the specification is less clear about computations involvedin "evaluation" of the subforms, and other computations that are implicitin the notion of "doing an access" or "doing a store".Proposal:	SETF-SUB-METHODS:DELAYED-ACCESS-STORESThis proposal specifies more explicilty the behavior of SETF in the case  of access forms whose sub-forms are permitted to be generalized variable references [and which thus need to call GET-SETF-METHOD during setf macro expansion].Remember, first, that GET-SETF-METHOD returns the following:   -- Some temporary variables   -- A list of value-producing forms   -- A list of store-variables (normally one).   -- A storing form.   -- An accessing form.The code produced as the macro expansion of a SETF form thatitself admits a generalized variable as an argument must essentiallydo the following major steps:  ** It evaluates the value-producing sub-forms, in left-to-right order, and      binds the temporary variables to them.  This will be called "binding the      temporaries."  ** It "reads the value" from the generalized variable using the supplied      accessing form, to get the "old value";  this will be called "doing the     access."  [Note that this is done after all the evaluations of the      preceeding step, including any side-effects they may have.]  ** It binds the store-variable to a new value, and then installs this     new value into the generalized variable using the supplied "storing      form".   This will be called "doing the store.""Reading the value" of a generalized variable reference is not part ofthe series of evaluations  that must be done in left-to-right order. The place-specifier forms listed at the top of CLtL p96 permit admit (other)place-specifiers as arguments; during the SETF expansion of these forms, it is necessary to call GET-SETF-METHOD in order to figure out how the inner, nested generalized variable must be treated.  This proposal requires GETF be listed among these forms, since it must have a sub-recursive <place> specifier [however, there is no Common Lisp function serving as a pseudo-update functionfor it, the way DPB serves for LDB].  For each place-specifier form with a sub-recursive place specifier,  the information from GET-SETF-METHOD is used as follows.  CHAR-BIT:    In a form such as:        (SETF (CHAR-BIT <place-form> <bit-name>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated; note that the update is to the generalized variable     specified by <place-form> -- not to a character object itself.    Thus this SETF should generate code to do the following:    1. Bind the temporaries for <place-form>    2. Evaluate <bit-name> (and bind into a temporary)    3. Evaluate <value-form> (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form>, with the given bit-name of the        character fetched in step 4 changed to reflect the value from step 3.    If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different "bit" of the character --    then the change of the bit denoted by <bit-name> will be to that altered    character, because the "access" step is done after the <value-form>    evaluation.  See example 1 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2, and thus the expected left-to-right evaluation order is seen.  LDB:     In a form such as:        (SETF (LDB <byte-spec> <place-form>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated;  note that the update is to the generalized variable     specified by <place-form> -- not to any object of type integer.    Thus this SETF should generate code to do the following:    1. Evaluate <byte-spec> (and bind into a temporary)    2. Bind the temporaries for <place-form>    3. Evaluate <value-form>  (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form> with the given bit-field of the integer       fetched in step 4 replaced with the value from step 3.    If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different bit-field of the integer --    then the change of the bit-field denoted by <byte-spec> will be to that     altered integer, because the "access" step is done after the <value-form>    evaluation.  See example 2 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2, and thus the expected left-to-right evaluation order is seen.  MASK-FIELD:   This case is the same as LDB in all essential aspects.  GETF:    In a form such as:        (SETF (GETF <place-form> <ind-form>) <value-form>)    the place referred to by the <place-form> must always be both accessed     and updated;  note that the update is to the generalized variable     specified by <place-form> -- not necessarily to the particular list    which is the property list in question.    Thus this SETF should generate code to do the following:    1. Bind the temporaries for <place-form>     2. Evaluate <ind-form> (and bind into a temporary)    3. Evaluate the <value-form> (and bind into the store variable)    4. Do the access to <place-form>    5. Do the store into <place-form> with a possibly-new property list       obtained by combining the values from steps 2, 3, and 4.      If the evaluation of <value-form> in step 3 alters what is found in the     given "place" -- such as setting a different named property in the list,    then the change of the property denoted by <ind-form> will be to that     altered list, because the "access" step is done after the <value-form>    evaluation.  See example 7 in the test cases section.  Nevertheless, the     evaluations required for binding the temporaries are done in steps 1 and     2,  and thus the expected left-to-right evaluation order is seen.    Note that this phrase "possibly-new property list" treats the     implementation of property lists as a "black box"  -- it can mean that     the former property list is somehow destructively re-used, or it can     mean partial or full copying of it.  This is like the question of REMOVE    or DELETE -- do you copy or do you destructively alter.  Since the answer    could go either way, the treatment of the resultant value for the     "possibly-new property list" must proceed as if it were a different copy    needing to be stored back into the generalized variable.The "read-modify-write" macros such as INCF, DECF, PUSH, POP, and REMF, as well as PSETF, SHIFTF, and ROTATEF should be specified to have the same evalauation order for the subforms ofthe "place" arguments; this would generally follow from their definitionin terms of SETF.Test Cases:  1. (setq char (make-char #\A 1))         ==>  #\Control-A     (rotatef (char-bit char :control)               (char-bit char :meta))      char  ==>  #\Meta-A     ;; It's as if you start with #\Control-A, and then first turn the     ;;  :control bit off, because the :meta bit was originally off; and     ;;  then to the resulting #\A,  you add the :meta bit since the     ;;  :control bit was originally on.     Note, however, that if an implementation doesn't support both of these     character 'bits', then this test case would have to be re-written to     reference two independent bits actually supported.  If an implementation     supports fewer than two independent character bits, then this test case     is entirely moot.  2. (setq integer #x69)                   ==>  #x69     (rotatef (ldb (byte 4 4) integer)               (ldb (byte 4 0) integer))     integer  ==>  #x96     ;; This very-realistic example is simply trying to swap two     ;;  independent bit fields in an integer.  Note that the generalized     ;;  variable of interest here is just the (possibly local) program     ;;  variable 'integer'.  3a.(setq l1 (setq l2 (list #x69)))                ==>  (#x69)     (setf (ldb (byte 4 4) (car l1))	   (ldb (byte 4 0) (car (prog1 l1                                   (setq l1 nil)))))      l1 ==> nil     l2 ==> (#x99)     ;; Note that the (setq l1 nil) didn't affect the actions of the setf     ;;  at all, since l1 was evaluated and its value was saved away in a     ;;  temporary variable as part of the step "2. Bind the temporaries      ;;  for <place-form>", and this was done before the evaluation of the     ;;  <value-form> which contains the (setq l1 nil).  Note also that the     ;;  step "4. Do the access to <place-form>" means fetching the CAR of     ;;  the saved (temporary) value of 'l1'; it does not mean doing a LDB     ;;  on anything like that.  3b.(setq l1 (setq l2 (list #x69)))                ==>  (#x69)     (setf (ldb (byte 4 4) (car l1))	   (ldb (byte 4 0) (car (rplaca l1 #x17))))     l1 ==> (#x77)     l2 ==> (#x77)     ;; Note that the (rplaca l1 #x17) altered the contents of what l1     ;;  was pointing to.  Thus even though l1 was evaluated and its       ;;  value was saved away in a temporary variable as part of the step      ;;  "2. Bind the temporaries for <place-form>", and even though this      ;;  was done before the evaluation of the <value-form> which contains      ;;  the rplaca, still the side-effect changes things because it alters     ;;  what will be fetched during the "do the access" step.  4. (setq integer #x69)     (setf (mask-field (byte 4 4) integer) (incf integer)) => #x6A     integer ==> #x6A  5. (setq integer #x6A)     (setf (mask-field (byte 4 4) integer) (ash (incf integer) 4)) => #x6B0     integer => #xBB  6. (setq s (setq r (list 'a 1 'b 2 'c 3)))         ==>  (a 1 b 2 c 3)     (setf (getf r 'b)            (progn (setq r nil) 6))                   ==>  6     r ==> (b 6)     s ==> (a 1 b 2 c 3)     ;; Note that the generalized variable of concern here is the (degenerate?)     ;;  one of simply the program variable 'r'; it is not a property-list      ;;  slot denoted by (getf r 'b).   At the time the step "4. Do the access     ;;  to <place-form>" is performed, the evaluation of the <value-form>     ;;  has already altered the generalized variable 'r', and thus a nil is     ;;  returned for this access; that is why a fresh property-list (B 6) is     ;;  created an stored back into 'r'.  7. (setq s (setq r (list (list 'a 1 'b 2 'c 3))))  ==>  ((a 1 b 2 c 3))     (setf (getf (car r) 'b)            (progn (setq r nil) 6))                   ==>  6     r ==> nil     s ==> ((A 1 B 6 C 3))     ;; Note that the (setq r nil) does not affect the actions of the setf      ;;  because the value of R had already been saved in a temporary variable     ;;  as part of the step "1. Bind the temporaries for <place-form>".  Only     ;;  the CAR of this value will be accessed, and subsequently modified      ;;  after the value computation.Rationale:As a principle,    (setf (foo-a x) (progn (setf (foo-b x) ...)                           new-a-value))should always set both of the "slots" of 'x', even if these slots are implemented as bit-fields, getf-properties, and so on.  Only by separating out evaluation from "generalized variable access", and by specifying thatthe access is done after all the evaluations, can this correctly be done.Current Practice:Lucid Common Lisp already operates pretty much according to this proposal.Symbolics Genera 7.2 foolishly adopted an earlier proposal(SETF-METHOD-FOR-SYMBOLS) before it was officially approved by X3J13 andits parent standards organization.  This proposal is incompatible withthat one, so Genera 7.2 does not implement the behavior described here,and fails test cases 1, 2, 4, 5, and 6.  Symbolics Genera 7.1is probably closer to this proposal. Performance impact:Small. This proposal might slow down macro-expansion slightly,might cause some current optimizations not to work as well. However,the net effect is likely negligible.Cost to Implementors:In some implementations, this would require a careful revisiting ofthe handling of SETF and generalized variable modifiers.Cost to Users:Small; although this will impose an incompatible change on implementations that don't behave as proposed, and might havean effect on (non-portable) code, we believe the effectsare not widespread.Cost of non-adoption:SETF left-to-right order of evaluation will not be well specified;implementations will differ for no good reason.Benefits:Uniform semantics and portability in the face of recursive "place specifiers"for SETF.  Setf of (LDB ... <place>) and of (GETF <place> ...) will behaveuniformly no matter the nature of the <place>.Anyone who has copied examples from p105 and p106 will continue tobe able to use them.Esthetics:See "Cost of non-adoption"Discussion:This is a difficult proposal to specify.In the detailed descriptions for each access form, the phrase    "the place referred to by the <place-form> must always be both      accessed and updated; note that the update is to the generalized      variable specified by <place-form>"is not intended to prevent optimizations that could occur when thecode "knows" that the new value will be EQ to the old one.  The onlyrequirements is that the results be semantically equivalent.There is an interesting parallel between this case for GETF and thevery common mistake made by Lisp programmers with respect to the function DELETE.  How often the complaint is filed that DELETE didn'tdo anything when it should have; but in fact the filer simply forgotthat delete, although permitted to destructively modify the originallist, may also return some tail of the list originally give it, whether or not an alteration occurs.      (setq l '(a a b c d)) ==> (a a b c d)      (delete 'a l)         ==> (b c d)      l 		    ==> (a a b c d)The unwary user thinks that because 'l' is still EQ to the original value that "DELETE didn't do anything".  The temptation to ignore the resultant value of DELETE parallels the temptation to forget about a need to performa final update to <place-form> in the setf-of-getf case.In the (degenerate?) case when a generalized variable is in fact simply a program variable, then there are no sub-forms to beconsidered "value-producing" forms; in fact, "doing the access" for sucha generalized variable (i.e. a program variable) is functionally thesame as evaluating it.  This explains why the behaviour in the "Problem Description" is at first perplexing -- the "do the access" step has the samesemantics as an evaluation step, even though it is done after all theprescribed evaluations.The issue PUSH-EVALUATION-ORDER is a clarification about just the pointof the evaluation order for the various subforms to a PUSH;  thus thereis a similarity to this issue, but the present issue has a much deeperproblem because of the need to call GET-SETF-METHOD during setf macroexpansion.        TITAN 
         TITAN 
           o                     R       	                    á                    1      ô                          î             ƒ              ´                            …              u       
      #                           X      @à  z∫*start*01252 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 DEC 88 16:21:30 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 27 Dec 88  17:24:10 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Tue, 27 Dec 88 20:16:59 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Tue, 27 Dec 88 20:22:08 ESTDate: Tue, 27 Dec 88 20:22 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: SETF-SUB-METHODSTo: cl-cleanup@sail.stanford.eduMessage-Id: <19881228012217.3.BARMAR@OCCAM.THINK.COM>I have a question about the SETF-SUB-METHODS issue, which clarifies theorder of "evaluation" of access forms that are generalized variablereferences.The Cost to Users section only mentions the incompatibilities caused byimplementations changing to the required behavior.  What about users whohave implemented their own complex DEFINE-SETF-METHODs?  Will they needto change these if they wish their generalized variables to beconsistent with the language-defined ones?  Or does this not affect thereturn values from a SETF method?                                                barmar*start*01652 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 DEC 88 03:54:22 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 29 Dec 88  03:53:21 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00898g; Thu, 29 Dec 88 03:49:55 PSTReceived: by bhopal id AA09984g; Thu, 29 Dec 88 03:52:05 PSTDate: Thu, 29 Dec 88 03:52:05 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812291152.AA09984@bhopal>To: barmar@Think.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Barry Margolin's message of Tue, 27 Dec 88 20:22 EST <19881228012217.3.BARMAR@OCCAM.THINK.COM>Subject: Issue: SETF-SUB-METHODSre:  What about users who    have implemented their own complex DEFINE-SETF-METHODs?  Will they need    to change these if they wish their generalized variables to be    consistent with the language-defined ones?  Or does this not affect the    return values from a SETF method?Well, I won't say that a programmer who uses DEFINE-SETF-METHOD can'tshaft himself this way [by definition, DEFINE-SETF-METHOD is for the"not easy" case].  However, this proposal seems more directed towardsstopping the premature optimization where "evaluating a subform" and "doing the access" are falsly combined into one step.  [The originaltemptation to do so was when the sub-form was a symbol(?)]  I ratherhope, as you suggest, that this proposal affects the return valueof a SETF method only to the degree that the related accessing and storing forms don't make the premature optimization.-- JonL --*start*00840 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 19:15:00 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Jan 89  19:13:42 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 JAN 89 18:18:40 PSTDate: 9 Jan 89 18:16 PSTFrom: masinter.paSubject: Issue: SETF-SUB-METHODS (Version 5)To: cperdue@Sun.COM (Cris Perdue)cc: cl-cleanup@sail.stanford.eduMessage-ID: <890109-181840-5085@Xerox>In your ballot, you said: This does not seem to be the "right" choice of semantics, and Ibelieve that the presentation of the proposal needs substantial workeven if it is "right".Can you help us? in what way is it wrong? what might be better? whatcases are unclear that we need to clarify?*start*02621 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 11 JAN 89 00:03:31 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03190g; Wed, 11 Jan 89 00:00:30 PSTReceived: by bhopal id AA03531g; Wed, 11 Jan 89 00:02:47 PSTDate: Wed, 11 Jan 89 00:02:47 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901110802.AA03531@bhopal>To: cperdue@Sun.COMCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: Cris Perdue's message of Tue, 10 Jan 89 10:41:42 PST <8901101841.AA13760@clam.sun.com>Subject:  Issue: SETF-SUB-METHODS (Version 5)re: Consider example 6.      (setq s (setq r (list 'a 1 'b 2 'c 3)))      (setf (getf r 'b) (progn (setq r nil) 6))      r ==> (b 6)      s ==> (a 1 b 2 c 3)    I find the SETF expression naturally maps to:    (setf r (put-plist r 'b (progn (setq r nil) 6)))This is the conceptual bug you make if you fail to notice thedistinction between evaluating the "value-producing subforms"  and"reading the value" out of the generalized location.  The top partof the second page of the proposal tries to warn the reader aboutthis by saying:   "``reading the value'' of a generalized variable reference is not    part of the series of evaluatons that must be done in left-to-right    order."Of course, Test Case 6 is a worst-case pun of sorts, since "readingthe value" is exactly the same set of computer instructions as"evaluating the value-producing subforms".  It is a malice-aforethoughworst-case test, just to illustrate the point.  [Incidentally, these are Test Cases rather than Examples.]We are fully aware that this is (A) a "fine point" and (B) a verydetailed point.  However, failure to specify the details correctly willlead to an incorrect implementation, especially in regard to the TestCase 2.  A previous proposal had that flaw, and we didn't notice untilactually coding it up and observing some previously working codebreaking.  At least it isn't three pages of dense specification, sincemost all of the three parts are isomorphic.  But someone on thesubcommittee objected to a specification that was loosely worded like"and similarly for CHAR-BIT and LDB etc.".Since this is a Clarification (not an addition or change) of what we think CLtL already says or implies, then a "No" vote is not nearly someaningful as an alternate clarification.  I think you will find itis not so easy a task to specify a general rule for sub-form semanticsif you base it only on the more limited reading of Test Case 6.Test Case 2 must be accommodated also.-- JonL --*start*01823 00024 US Return-Path: <cperdue@Sun.COM>Received: from Sun.COM ([10.7.0.2]) by Xerox.COM ; 10 JAN 89 10:41:33 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA07207; Tue, 10 Jan 89 10:44:11 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA26417; Tue, 10 Jan 89 10:40:43 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA13760; Tue, 10 Jan 89 10:41:42 PSTDate: Tue, 10 Jan 89 10:41:42 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8901101841.AA13760@clam.sun.com>To: cperdue@Sun.COM, masinter.paSubject: Re:  Issue: SETF-SUB-METHODS (Version 5)Cc: cl-cleanup@sail.stanford.edu> In your ballot, you said: > > This does not seem to be the "right" choice of semantics, and I> believe that the presentation of the proposal needs substantial work> even if it is "right".> > Can you help us? in what way is it wrong? what might be better? what> cases are unclear that we need to clarify?Right.  I didn't feel I could do justice to this issue before the JanuaryX3J13 meeting.  Perhaps these comments will be of some use:Consider example 6.(setq s (setq r (list 'a 1 'b 2 'c 3)))(setf (getf r 'b) (progn (setq r nil) 6))r ==> (b 6)s ==> (a 1 b 2 c 3)I find the SETF expression naturally maps to:(setf r (put-plist r 'b (progn (setq r nil) 6)))where put-plist is a destructive function on lists in the usualCommon Lisp style, where it must be used for its value.With this expansion,r ==> (a 1 b 6 c 3)s ==> (a 1 b 6 c 3)Perhaps I am wrong, but I think others will realize that they findthis more natural also.Concerning the statement of the proposal, it seems to me that 3half-page discussions -- one for CHAR-BIT, one for GETF, and onefor LDB and MASK-FIELD, is far too much to have to say about sucha fine point in the language.*start*00920 00024 US Return-Path: <cperdue@Sun.COM>Received: from Sun.COM ([10.7.0.2]) by Xerox.COM ; 11 JAN 89 13:17:10 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA07029; Wed, 11 Jan 89 13:19:36 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA12243; Wed, 11 Jan 89 13:16:14 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA01716; Wed, 11 Jan 89 13:17:20 PSTDate: Wed, 11 Jan 89 13:17:20 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8901112117.AA01716@clam.sun.com>To: jonl@lucid.comSubject: Re:  Issue: SETF-SUB-METHODS (Version 5)Cc: cl-cleanup@sail.stanford.edu, masinter.paI have read Jeff Dalton's recent discussion as well as JonL'semail, and it is quite possible that I will change myview as to what the semantics should be stated to be.I'm not going to vote now for this proposal as it stands --will think about it harder after X3J13.				-Cris*start*02768 00024 US Return-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 11 JAN 89 12:27:23 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa07416; 11 Jan 89 20:14 GMTDate: Wed, 11 Jan 89 20:16:22 GMTMessage-Id: <18372.8901112016@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: SETF-SUB-METHODS (Version 5)To: Jon L White <@sail.stanford.edu:jonl@lucid.com>, cperdue@sun.comIn-Reply-To: Jon L White's message of Wed, 11 Jan 89 00:02:47 PSTCc: masinter.pa, cl-cleanup@sail.stanford.eduI thought about this issue for a long time this morning and foundit very confusing.  Eventualy, I decided that the proposal wasprobably right, but it could have been better explained.  Whatfinally convinced me was the thinking below (which I do not thinkis necessarily the better explanation).(setf (getf -variable- -expr1-) -expr2-)expands into something like:(let* ((#:temp0 -variable-) ;let's assume we do this binding for now.       (#:temp1 -expr1-)    ;in the example, -expr2- is just 'B.       (#:temp2 -expr2-))   ;in the example, this does the setq.  (setq -variable-        (list-putprop [ ? ] #:temp1 #:temp2))  #:temp2)Let's assume LIST-PUTPROP returns the entire plist, which may be a newlist or a modification of the old.Now the question is: what goes in [ ? ]?  If it's #:temp0, then in     (setq s (setq r (list 'a 1 'b 2 'c 3)))     (setf (getf r 'b) (progn (setq r nil) 6))LIST-PUTPROP would get the original value or R (before it was set toNIL), and the results would be:     r ==> (a 1 b 6 c 3)     s ==> (a 1 b 6 c 3) or (a 1 b 2 c 3)The other alternative is that [ ? ] is R.  Then LIST-PUTPROP gets thenew value of R (i.e., nil), and the results are:     r ==> (b 6)     s ==> (a 1 b 2 c 3)Now suppose we're doing    (setf (getf (car -variable-) -expr1-) -expr2-)This expands into   (let* ((#:temp0 -variable-)          (#:temp1 -expr1-)          (#:temp2 -expr2-))     (setf (car #:temp0)           (list-putprop (car #:temp0) #:temp1 #:temp2))     #:temp2)Here, (car #:temp0) acts as a sort of pointer to what we want tochange.  We can't point to a car (only to a whole cons), but wewant the car of that cons, not the cons that happens to be thevalue of the variable later on.  That's what (car ...) means asa place.  But a variable as a place wants a "pointer" to thatvariable, not to it's value, because that's what a variable meansas a place.  And such a "pointer" is just the variable itself.This suggests that [ ? ] should be R.  That is, we should dereferencethe "pointer" when calling LIST-PUTPROP.-- Jeff*start*00404 00024 US Date: 11 Jan 89 13:59 PSTFrom: masinter.paSubject: Re:  Issue: SETF-SUB-METHODS (Version 5)In-reply-to: cperdue@Sun.COM (Cris Perdue)'s message of Wed, 11 Jan 89 13:17:20 PSTTo: cperdue@Sun.COM (Cris Perdue)cc: jonl@lucid.com, cl-cleanup@sail.stanford.edu, masinter.paI believe that this will get voted on at this meeting unless there is a successful motion to table it.*start*01067 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 15:17:13 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  13:18:01 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA07029; Wed, 11 Jan 89 13:19:36 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA12243; Wed, 11 Jan 89 13:16:14 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA01716; Wed, 11 Jan 89 13:17:20 PSTDate: Wed, 11 Jan 89 13:17:20 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8901112117.AA01716@clam.sun.com>To: jonl@lucid.comSubject: Re:  Issue: SETF-SUB-METHODS (Version 5)Cc: cl-cleanup@sail.stanford.edu, masinter.paI have read Jeff Dalton's recent discussion as well as JonL'semail, and it is quite possible that I will change myview as to what the semantics should be stated to be.I'm not going to vote now for this proposal as it stands --will think about it harder after X3J13.				-Cris*start*00769 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 15:18:58 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  14:18:40 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 11 JAN 89 13:59:43 PSTDate: 11 Jan 89 13:59 PSTFrom: masinter.paSubject: Re:  Issue: SETF-SUB-METHODS (Version 5)In-reply-to: cperdue@Sun.COM (Cris Perdue)'s message of Wed, 11 Jan 89 13:17:20 PSTTo: cperdue@Sun.COM (Cris Perdue)cc: jonl@lucid.com, cl-cleanup@sail.stanford.edu, masinter.paMessage-ID: <890111-135943-10535@Xerox>I believe that this will get voted on at this meeting unless there is asuccessful motion to table it.*start*02887 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 15:15:38 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 11 Jan 89  12:51:37 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa07416; 11 Jan 89 20:14 GMTDate: Wed, 11 Jan 89 20:16:22 GMTMessage-Id: <18372.8901112016@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: SETF-SUB-METHODS (Version 5)To: Jon L White <@sail.stanford.edu:jonl@lucid.com>, cperdue@sun.comIn-Reply-To: Jon L White's message of Wed, 11 Jan 89 00:02:47 PSTCc: masinter.pa, cl-cleanup@sail.stanford.eduI thought about this issue for a long time this morning and foundit very confusing.  Eventualy, I decided that the proposal wasprobably right, but it could have been better explained.  Whatfinally convinced me was the thinking below (which I do not thinkis necessarily the better explanation).(setf (getf -variable- -expr1-) -expr2-)expands into something like:(let* ((#:temp0 -variable-) ;let's assume we do this binding for now.       (#:temp1 -expr1-)    ;in the example, -expr2- is just 'B.       (#:temp2 -expr2-))   ;in the example, this does the setq.  (setq -variable-        (list-putprop [ ? ] #:temp1 #:temp2))  #:temp2)Let's assume LIST-PUTPROP returns the entire plist, which may be a newlist or a modification of the old.Now the question is: what goes in [ ? ]?  If it's #:temp0, then in     (setq s (setq r (list 'a 1 'b 2 'c 3)))     (setf (getf r 'b) (progn (setq r nil) 6))LIST-PUTPROP would get the original value or R (before it was set toNIL), and the results would be:     r ==> (a 1 b 6 c 3)     s ==> (a 1 b 6 c 3) or (a 1 b 2 c 3)The other alternative is that [ ? ] is R.  Then LIST-PUTPROP gets thenew value of R (i.e., nil), and the results are:     r ==> (b 6)     s ==> (a 1 b 2 c 3)Now suppose we're doing    (setf (getf (car -variable-) -expr1-) -expr2-)This expands into   (let* ((#:temp0 -variable-)          (#:temp1 -expr1-)          (#:temp2 -expr2-))     (setf (car #:temp0)           (list-putprop (car #:temp0) #:temp1 #:temp2))     #:temp2)Here, (car #:temp0) acts as a sort of pointer to what we want tochange.  We can't point to a car (only to a whole cons), but wewant the car of that cons, not the cons that happens to be thevalue of the variable later on.  That's what (car ...) means asa place.  But a variable as a place wants a "pointer" to thatvariable, not to it's value, because that's what a variable meansas a place.  And such a "pointer" is just the variable itself.This suggests that [ ? ] should be R.  That is, we should dereferencethe "pointer" when calling LIST-PUTPROP.-- Jeff*start*01029 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 16:01:54 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  16:01:10 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA11476; Wed, 11 Jan 89 16:02:34 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA19952; Wed, 11 Jan 89 15:58:45 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA02137; Wed, 11 Jan 89 15:59:45 PSTDate: Wed, 11 Jan 89 15:59:45 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8901112359.AA02137@clam.sun.com>To: cperdue@Sun.COM, masinter.paSubject: Re:  Issue: SETF-SUB-METHODS (Version 5)Cc: cl-cleanup@sail.stanford.edu, jonl@lucid.com> I believe that this will get voted on at this meeting unless there is a> successful motion to table it.If so I'll vote against but with willingness to reconsider,especially if the proposal can be stated much more simply.