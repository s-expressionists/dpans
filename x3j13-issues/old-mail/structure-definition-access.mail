*start*03671 00024 US Originator: SenderNameTooLong%SAIL.STANFORD:EDU:XeroxDate:  6 Oct 87 23:57From: "GALLAGHER%cs.umass.edu%RELAY.CS.NET":GV:XeroxSubject: Extending DefstructTo: Common-Lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kevin Gallagher <GALLAGHER%cs.umass.edu@RELAY.CS.NET>Subject: Extending DefstructTo: Common-Lisp@SAIL.STANFORD.EDUReturn-Path: <@SAIL.Stanford.EDU,@RELAY.CS.NET:GALLAGHER@cs.umass.edu>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 06 OCT 87 23:57:04 PDTReceived: from RELAY.CS.NET by SAIL.STANFORD.EDU with TCP; 6 Oct 87  23:04:56 PDTReceived: from relay2.cs.net by RELAY.CS.NET id ab03913; 7 Oct 87 1:24 EDTReceived: from cs.umass.edu by RELAY.CS.NET id de12948; 7 Oct 87 1:22 EDTOriginal-Date: Tue, 6 Oct 87 18:39 EDTX-VMS-To: IN%"Common-Lisp@Sail.Stanford.EDU"GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI am glad to see the revival of the discussion of defstruct.  I broughtup this issue more than a year ago.  At that time it got only one reply.The defstruct facility would be much more useful to layered systemsbuilders if information about the defstruct definition was available.In addition, you should be able to access and update a slot in astructure via the slot name.  Most implementations keep the necessaryinformation around anyway.Simply being able to get the names of the accessor functions is notsufficient.  This will enable you to access the value of a slot by usingFUNCALL, but won't allow you to update the value of the slot becausefuncall is not a valid place form.I would like to see several functions added to the language:  STRUCTURE-SLOT structure slot                                   [Function]  Returns the value of the slot in STRUCTURE specified by SLOT.  STRUCTURE  is a defstruct instance and SLOT is a symbol.  SETF may be used with  STRUCTURE-SLOT to modify a slot in a structure.  STRUCTURE-SLOT-NAMES structure-type                             [Function]  STRUCTURE-TYPE must be a type defined by DEFSTRUCT.  This function  returns a list of slot names for structures of that type.  MAKE-STRUCTURE structure-type keyword-1 value-1 ...             [Function]  Creates an instance of a structure.  STRUCTURE-TYPE is the type of  structure to create.  The rest of the arguments are the same as for the  default constructor function.  If a slot is not initialised by a  slot-keyword, then the slot will be initialized with the default init  form specified in the defstruct.  STRUCTURE-OPTION structure-type option                          [Function]  STRUCTURE-TYPE must be a type defined by defstruct.  OPTION must be a  defstruct option (e.g., :conc-name).  This function returns the argument  that was given to that option if an argument was given in the call to  defstruct.  Otherwise it returns the default value of that option.  For example, after the defstruct on page 312,    (structure-option 'astronaut :conc-name) ==> astro-  STRUCTURE-SLOT-OPTION structure-type slot option                [Function]  STRUCTURE-TYPE must be a type defined by defstruct.  SLOT is the name of  a slot in that defstruct.  OPTION must be a defstruct slot option (:type  or :read-only).  This function returns the argument that was given to  that option if an argument was given in the call to defstruct.  Otherwise  it returns the default value of that option.  DEFSTRUCTP symbol                                               [Function]  This function returns true if SYMBOL is the name of a defstruct type.Kevin GallagherGallagher@CS.UMass.EDU*start*01859 00024 USfOriginator: SenderNameTooLong%SAIL.STANFORD:EDU:XeroxDate:  7 Oct 87 00:49From: "GALLAGHER%cs.umass.edu%RELAY.CS.NET":GV:XeroxSubject: Defstruct and CLOSTo: Common-Lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kevin Gallagher <GALLAGHER%cs.umass.edu@RELAY.CS.NET>Subject: Defstruct and CLOSTo: Common-Lisp@SAIL.STANFORD.EDUReturn-Path: <@SAIL.Stanford.EDU,@RELAY.CS.NET:GALLAGHER@cs.umass.edu>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 OCT 87 00:49:32 PDTReceived: from RELAY.CS.NET by SAIL.STANFORD.EDU with TCP; 6 Oct 87  23:05:08 PDTReceived: from relay2.cs.net by RELAY.CS.NET id ai03910; 7 Oct 87 1:24 EDTReceived: from cs.umass.edu by RELAY.CS.NET id dg12948; 7 Oct 87 1:22 EDTOriginal-Date: Tue, 6 Oct 87 19:00 EDTX-VMS-To: IN%"Common-Lisp@Sail.Stanford.EDU"GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> From: "Daniel L. Weinreb" <DLW@alderaan.scrc.symbolics.com> > > One idea that's been discussed that would do what you want, in fact do> something more general, is to redefine structures in terms of> object-oriented programming, if and after CLOS is accepted as part of> Common Lisp.  The basic idea is that CLOS would have a defined mechanism> for talking about slots and their properties.  I don't know whether> this idea is still current; I suspect it's mainly on the back burner> while the CLOS proposal itself is being finished.One reason people use structures rather than ``objects'' is that thereis a significant overhead incurred by using objects.  If defstruct weresubsumed into an object oriented standard there should be a way ofturning off all the power (and overhead) of the OOS.  In particular, youdon't want the defstruct accessor functions to become generic functions.Kevin Gallagher*start*01421 00024 US Originator: @SAIL.STANFORD.EDU:ghenis.pasa%Xerox:COM:XeroxDate:  2 Oct 87 11:15From: ghenis:PASA:XeroxSubject: Re: [KAHLE@Aquinas.Think.COM: defstruct request for common lisp]In-Reply-to: Barry Margolin <barmar@Think.COM>'s message of Thu, 1 Oct 87 23:16 EDTTo: barmar%Think:COM:Xeroxcc: ghenis:PASA:Xerox, common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.STANFORD.EDU:ghenis.pasa@Xerox.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 02 OCT 87 11:12:34 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Oct 87  10:33:11 PDTReceived: from PinotNoir.ms by ArpaGateway.ms ; 02 OCT 87 10:21:21 PDTOriginal-Date: 2 Oct 87 10:20 PDTMessage-ID: <871002-102121-5691@Xerox>    What limitation are you talking about?  Structure slot names    are also the names of functions, which can be FUNCALLed.  Thus, one    could write    (defun show-structure-slots (structure)      (dolist (slot (structure-slots (type-of structure)))        (format t "~A: ~S" slot (funcall slot structure))))Mea culpa for reading too literally. I was (narrowly) thinking of thesemantics of STRUCTURE-SLOTS as returning slot NAMES, which would be ofvery little use. Your interpretation could be better calledSTRUCTURE-ACCESSORS and its output is truly useful. From that point ofview Kahle's request makes a lot more sense...					Pablo Ghenis*start*01556 00024 US Originator: SenderNameTooLong%SAIL.STANFORD:EDU:XeroxDate: 26 Oct 87 09:13From: Cerys%XX.LCS.MIT:EDU:XeroxSubject: Re: extending DEFSTRUCTIn-Reply-to: Msg of Sun, 25 Oct 87 21:31 EST from Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>To: RWK%YUKON.SCRC.Symbolics:COM:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: "Daniel L. Cerys" <Cerys@XX.LCS.MIT.EDU>To: "Robert W. Kerns" <RWK@YUKON.SCRC.Symbolics.COM>Cc: common-lisp@SAIL.STANFORD.EDUSubject: Re: extending DEFSTRUCTIn-Reply-To: Msg of Sun, 25 Oct 87 21:31 EST from Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Return-Path: <@SAIL.Stanford.EDU:cerys%RTS-12.LCS.MIT.EDU.#Chaos@XX.LCS.MIT.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 08:13:04 PSTReceived: from XX.LCS.MIT.EDU by SAIL.STANFORD.EDU with TCP; 26 Oct 87  07:30:53 PSTReceived: from RTS-12.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 26 Oct 87 10:27-ESTMessage-Id: <2771248902-3508558@RTS-12>Original-Date: Mon, 26 Oct 87 10:21:42 ESTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> 	When *PRINT-STRUCTURE* in NIL:> I think a slightly better name is *PRINT-STRUCTURE-CONTENTS*.> (We've had this for a couple years).I agree on the utility of this variable, but not on its name.  Since*PRINT-ARRAY* determines whether the contents of arrays are printed, avariable named *PRINT-STRUCTURE* should do the same for structures.Using *PRINT-STRUCTURE-CONTENTS* wouldn't be as clear.*start*01243 00024 US Originator: @SAIL.Stanford.EDU:TOURETZKY%C.CS.CMU:EDU:XeroxDate: 24 Oct 87 13:00From: Dave.Touretzky%C.CS.CMU:EDU:XeroxSubject: extending DEFSTRUCTTo: common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <@SAIL.Stanford.EDU:TOURETZKY@C.CS.CMU.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 OCT 87 13:00:45 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 24 Oct 87  12:24:05 PDTReceived: ID <TOURETZKY@C.CS.CMU.EDU>; Sat 24 Oct 87 15:16:09-EDTOriginal-Date: Sat, 24 Oct 87 15:16:08 EDTMessage-ID: <12345095715.31.TOURETZKY@C.CS.CMU.EDU>I support the proposal of Gallagher and Corkill, with one modification:Instead of *INHIBIT-DEFSTRUCT-PRINTERS*, there should be a variable called*PRINT-STRUCTURE* that is analagous to *PRINT-ARRAY*.When *PRINT-STRUCTURE* is T:  defstructs with their own print functions will use them  defstructs without prnt functions will print in the #S() notationWhen *PRINT-STRUCTURE* in NIL:  defstructs with their own print functions will use them  defstructs without their own print function will print in the #<> notationWhen *PRINT-STRUCTURE* is :FORCE  all defstructs print in #S() notation-- Dave-------*start*03069 00024 US Originator: COMMON-LISP-mailer%SAIL.Stanford:EDU:XeroxDate: 26 Oct 87 22:27From: RWK%YUKON.SCRC.Symbolics:COM:XeroxSubject: extending DEFSTRUCTIn-Reply-to: <871026122502.1.DFM@WHITBY.Palladian.COM>To: DFM%JASPER%LIVE-OAK.LCS.MIT:EDU:Xeroxcc: Rick.Busdiecker%cs.cmu:EDU:Xerox, common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Subject: extending DEFSTRUCTTo: Don Morrison <DFM%JASPER@LIVE-OAK.LCS.MIT.EDU>cc: Rick.Busdiecker@cs.cmu.edu, common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <871026122502.1.DFM@WHITBY.Palladian.COM>Return-Path: <COMMON-LISP-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 22:27:23 PSTReceived: from SCRC-YUKON.ARPA by SAIL.STANFORD.EDU with TCP; 26 Oct 87  21:49:55 PSTReceived: from WHITE-BIRD.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 282589; Mon 26-Oct-87 23:37:47 ESTOriginal-Date: Mon, 26 Oct 87 23:37 ESTMessage-ID: <19871027043741.4.RWK@WHITE-BIRD.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon, 26 Oct 87 12:25 EST    From: Don Morrison <dfm@JASPER.Palladian.COM>    If you do, you probably should make it #<name-of-structure-type NNN>    where NNN is an integer (decimal?) such that two eq structures always    have the same number, and two not eq structures don't.  I believe this    corresponds pretty closely to current practice for those implementations    that do support such a beast.  The major difference, I believe, is that    often NNN is currently an address that can change over time; it would    probably be cleaner for eq structures to always print the same, no    matter how manner GCs have intervened.  Since the hash or whatever it is    you'd stick there would only need to be computed if you're printing the    thing, I suspect it wouldn't add any serious overhead to structures    that's not already there to support eq hash tables.Wait a minute, EQ hash tables can't work that way; they have to workon bignums and rationals and conses and other things that don't haveany private slot to store the hash in.  And yes, adding overhead tostructures to support this would indeed be prohibitively expensive.On the other hand, if you don't mind having things you print nevergo away in the GC, you could use EQ hash tables to implement this,and only incur a cost for structures you actually print.  But nothaving structures GC is a serious flaw, too.I don't see that we could reasonably impose this on implementations.Also, the octal address is often useful.  I use it all the timewhen I'm debugging the mouse input code so that I can't just pointat structures with the mouse.  We used to use it a lot more, and(sys:%find-structure-header #o234725) is sort of an idiom aroundhere amongst the hackers of the lower levels.  (It returns theobject; it means essentially "object at address", and figures outthe type codes).*start*05688 00024 US Originator: @SAIL.Stanford.EDU,@RELAY.CS.NET:CORK@cs.umass.edu%Xerox:COM:XeroxDate: 24 Oct 87 02:20From: "CORK%cs.umass.edu%RELAY.CS.NET":GV:XeroxSubject: RE: Extending DEFSTRUCTTo: Common-Lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: "Dan Corkill, COINS, Umass (413)545-0156" <CORK%cs.umass.edu@RELAY.CS.NET>Subject: RE: Extending DEFSTRUCTTo: Common-Lisp@SAIL.STANFORD.EDUReturn-Path: <@SAIL.Stanford.EDU,@RELAY.CS.NET:CORK@cs.umass.edu>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 OCT 87 02:20:37 PDTReceived: from RELAY.CS.NET by SAIL.STANFORD.EDU with TCP; 24 Oct 87  01:30:01 PDTReceived: from relay2.cs.net by RELAY.CS.NET id ac18609; 24 Oct 87 2:18 EDTReceived: from cs.umass.edu by RELAY.CS.NET id bf09392; 24 Oct 87 2:11 EDTOriginal-Date: Fri, 23 Oct 87 12:26 EDTX-VMS-To: IN%"Common-Lisp@SAIL.Stanford.Edu"GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVKevin Gallagher has twice proposed what I believe is a well-reasoned andmuch needed extension to defstruct-defined structures.  About a year agohis first proposal received one favorable response on the list and died.His most recent reposting (in response to the recent discussion ofdefstruct) has received no responses.[The proposed extensions were:  STRUCTURE-SLOT structure slot            {a valid SETF form}    [Function]  STRUCTURE-SLOT-NAMES structure-type                             [Function]  MAKE-STRUCTURE structure-type keyword-1 value-1 ...             [Function]  STRUCTURE-OPTION structure-type option                          [Function]  STRUCTURE-SLOT-OPTION structure-type slot option                [Function]  DEFSTRUCTP symbol                                               [Function]]I would like to believe that the lack of responses to Kevin's extensions(or any further discussion of defstruct and structures) indicated animplicit endorsement of a useful proposal.  Anyone who builds portabletools, layered systems, or extensible languages that rely on defstruct-defined structures needs these capabilities.  They are relatively easy foran implementer to provide, they are impossible for a user to write in animplementation independent manner, they do not violate the storageabstraction provided by defstruct, and they elevate structures to the samelevel of ``official'' support for interrogatives as arrays.  (I can ask forthe dimensions of an array but not the slot-names of a structure?)  Iheartily endorse his proposal.In fact, I would add two more EXTENSIONS that I have found frustratingly absent from the CL specifications.---------------------------------------------------------------------------Add'l extension 1:There is no way in the type system to detect if an object is a structurewhose structure name has been added to the CL data-type system (i.e.,defined with no :TYPE option).  The following would provide this ability:  STRUCTUREP object                                               [Function]Returns true if object is a structure whose structure name has been addedto the CL data-type system; nil otherwise.---------------------------------------------------------------------------Add'l extension 2:I often use defstruct print functions to print structures in a palatableformat for human eyes.  I also want them printed using the normal #S()notation when writing them to a database file.  The following is a temptingway of writing such print functions:(defun EMPLOYEE-DEFSTRUCT-PRINTER (employee stream print-depth)  (declare (ignore print-depth))  (cond    ;; Less-than-pretty printing requested ::    ((and (not *print-pretty*) *print-escape*)     (prin1 employee))    ;; Pretty printing requested ::    (t     (format stream "{Employee: ~A}" (employee-name employee)))))Of course, this will NOT work because there is no way of disabling theemployee print function during the printing performed by prin1.  Instead, Iam forced to duplicate the printing of the default #S() format myself.  (Imight be tempted to write a generic print-structure-in-default-formatfunction, but of course I would need the extensions proposed by Gallagherto do that!)  So instead of prin1, I must write:             (format stream             "#S(EMPLOYEE :SOCIAL-SECURITY-NUMBER ~S ~                 :NAME ~S :HOURLY-RATE ~S ...)"             (employee-social-security-number employee)             (employee-name employee)             (employee-hourly-rate employee) ...))Explicitly naming each slot in the structure (and remembering to change theprinter if a slot is added or deleted from the defstruct definition).Ugh!!  The abstraction provided by defstruct has been lost (as well aswhatever efficient default printing of structures has been provided by theimplementers).A simple parameter *INHIBIT-DEFSTRUCT-PRINTERS* to control whether or notprinting uses or ignores the defstruct print function would save the day!Voila:(defun EMPLOYEE-DEFSTRUCT-PRINTER (employee stream print-depth)  (declare (ignore print-depth))  (cond    ;; Less-than-pretty printing requested ::    ((and (not *print-pretty*) *print-escape*)     (let ((*inhibit-defstruct-printers* t))       (prin1 stream employee)))        ;; Pretty printing requested ::    (t     (format stream "{Employee: ~A}" (employee-name employee)))))---------------------------------------------------------------------------Structures have become such an important component of CL.  It's unfortunatethat the lack of a few simple extensions seriously hamper using them.-- Dan Corkill   cork@cs.umass.edu*start*02030 00024 US Originator: @SAIL.Stanford.EDU:Moon%ALLEGHENY.SCRC.Symbolics:COM:XeroxDate: 26 Oct 87 11:53From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Re: extending DEFSTRUCTIn-Reply-to: <2771248902-3508558@RTS-12>To: Cerys%XX.LCS.MIT:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: extending DEFSTRUCTTo: Daniel L. Cerys <Cerys@XX.LCS.MIT.EDU>cc: common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <2771248902-3508558@RTS-12>Return-Path: <@SAIL.Stanford.EDU:Moon@ALLEGHENY.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 11:53:54 PSTReceived: from [128.81.41.45] by SAIL.STANFORD.EDU with TCP; 26 Oct 87  09:34:45 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by ALLEGHENY.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 69577; Mon 26-Oct-87 12:11:28 ESTOriginal-Date: Mon, 26 Oct 87 12:11 ESTMessage-ID: <19871026171117.8.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon, 26 Oct 87  10:21:42 EST    From: "Daniel L. Cerys" <Cerys@XX.LCS.MIT.EDU>    > Kerns:    > 	When *PRINT-STRUCTURE* in NIL:    > I think a slightly better name is *PRINT-STRUCTURE-CONTENTS*.    > (We've had this for a couple years).    I agree on the utility of this variable, but not on its name.  Since    *PRINT-ARRAY* determines whether the contents of arrays are printed, a    variable named *PRINT-STRUCTURE* should do the same for structures.    Using *PRINT-STRUCTURE-CONTENTS* wouldn't be as clear.Don't you think that what that really indicates is that the name*PRINT-ARRAY* was poorly chosen and is not as clear?  If you lookthrough the list of printer flags on CLtL pp.370-373, *print-array*is the only one that doesn't connote very well what it does, to myear.  It's as if someone thought it was more important to make allthe names exactly two words long.*start*01628 00024 US Originator: SenderNameTooLong%SAIL.STANFORD:EDU:XeroxDate: 25 Oct 87 10:13From: norvig%cogsci.Berkeley.EDU%ucbvax.Berkeley:EDU:XeroxSubject: extending DEFSTRUCTTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: norvig%cogsci.Berkeley.EDU@ucbvax.Berkeley.EDU (Peter Norvig)To: common-lisp@sail.stanford.eduSubject: extending DEFSTRUCTReturn-Path: <@SAIL.Stanford.EDU:norvig%cogsci.Berkeley.EDU@ucbvax.Berkeley.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 10:13:25 PSTReceived: from [128.32.130.5] by SAIL.STANFORD.EDU with TCP; 25 Oct 87  09:39:29 PSTReceived: by cogsci.berkeley.edu (5.58/1.26)	id AA20167; Sun, 25 Oct 87 09:43:08 PSTOriginal-Date: Sun, 25 Oct 87 09:43:08 PSTMessage-Id: <8710251743.AA20167@cogsci.berkeley.edu>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI agree with Touretzky's proposal, except I would add:When *PRINT-STRUCTURE* is a non-nil list:  defstructs whose types are members of the list use their own print function  defstructs whose types are not in the list use #S()I think the membership test should be TYPEP, and that :INCLUDEd typesinherit the print function dynamically (with possibility of over-ride,of course).I personally prefer to use a macro DEFSTRUCT-PRINT-FUNCTION so that I can define the print function separately from the DEFSTRUCT itself,but I wouldn't go so far as to make that part of CL; rather, let's:define a GET-PRINT-FUNCTION function (with a SETF form)  which returns the print function associated with a type.*start*03793 00024 US Originator: @SAIL.Stanford.EDU:RWK%YUKON.SCRC.Symbolics:COM:XeroxDate: 25 Oct 87 19:08From: RWK%YUKON.SCRC.Symbolics:COM:XeroxSubject: extending DEFSTRUCTIn-Reply-to: <562168063/rfb@H.GP.CS.CMU.EDU>To: Rick.Busdiecker%cs.cmu:EDU:Xeroxcc: Dave.Touretzky%C.CS.CMU:EDU:Xerox, common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Subject: extending DEFSTRUCTTo: Rick.Busdiecker@cs.cmu.educc: Dave.Touretzky@C.CS.CMU.EDU, common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <562168063/rfb@H.GP.CS.CMU.EDU>Return-Path: <@SAIL.Stanford.EDU:RWK@YUKON.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 19:08:29 PSTReceived: from SCRC-YUKON.ARPA by SAIL.STANFORD.EDU with TCP; 25 Oct 87  18:30:43 PSTReceived: from WHITE-BIRD.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 281872; Sun 25-Oct-87 21:31:32 ESTOriginal-Date: Sun, 25 Oct 87 21:31 ESTMessage-ID: <19871026023112.9.RWK@WHITE-BIRD.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: 25 Oct 1987 08:47-EST     From: Rick.Busdiecker@H.GP.CS.CMU.EDU    I also support the proposed extensions to structure handling.	Date: Sat 24 Oct 87 15:16:08-EDT	From: Dave.Touretzky@C.CS.CMU.EDU    	When *PRINT-STRUCTURE* in NIL:I think a slightly better name is *PRINT-STRUCTURE-CONTENTS*.(We've had this for a couple years).Most of us find this has to be NIL in order not to be innundatedwith useless internal details of the structures we look at.(The #<...> representations are designed to provide what informationyou need at a glance).Generally, CL fails to distinguish between PRINT/READ as communicationbetween programs (in which case, you either want to bind all the flagsto standard, known values, or ignored totally), and communication withthe user or programmer, in which case you want the flags set for maximumusability.  #S syntax is clearly an example where utility for programswas chosen over usability for programmers.	  defstructs with their own print functions will use them	  defstructs without their own print function will print in the #<> notation    Is there really a standard for #<> notation?  If so, what is it and    where is it defined?  If not, perhaps we should define a default #<>    notation such as #<name-of-structure-type>.The standard is that it signals an error (see pg 360 of CLtL).What CLtL doesn't say, but should, is that:1)  The #< should be balanced with a >.2)  There are certain recommended higher conventions to be followed:  a) The type should be given first.  This is not necessarily     what TYPE-OF will return, but it should be descriptive     and non-confusing to the user.  (This means it should     probably be a type acceptable to TYPEP, of which this object     is a member).  The structure type name is the default.  b) Named objects should, where possible, follow their type     with their name.  c) Other descriptive information may be included, in a user-determined     (but brief) format.  d) Where it is desirable to distinguish different instances of     the same type of object, which may otherwise print the same,     the last thing printed before the closing ">" should be a     unique-ID.  (On our system we use the octal address by default).     This should generally be omitted when there is no difficulty     distinguishing objects on sight (for example, objects with     unique names).As you can see, these are conventions designed to make things easierfor the programmer looking at these objects while debugging, andnot something that some program or other rigid-thinking entitywill look at.*start*05857 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 28 Oct 87 02:59From: RWK%YUKON.SCRC.Symbolics:COM:XeroxSubject: re: defstruct extensionsIn-Reply-to: <8710271733.AA15979@vaxa.isi.edu>To: goldman%vaxa.isi:EDU:Xeroxcc: COMMON-LISP%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Subject: re: defstruct extensionsTo: goldman@vaxa.isi.educc: COMMON-LISP@sail.stanford.eduIn-Reply-To: <8710271733.AA15979@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 28 OCT 87 02:59:09 PSTReceived: from SCRC-YUKON.ARPA by SAIL.STANFORD.EDU with TCP; 28 Oct 87  02:15:17 PSTReceived: from WHITE-BIRD.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 283329; Wed 28-Oct-87 05:16:18 ESTOriginal-Date: Wed, 28 Oct 87 05:16 ESTMessage-ID: <19871028101610.9.RWK@WHITE-BIRD.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Tue, 27 Oct 87 09:33:23 PST    From: goldman@vaxa.isi.edu    The recently discussed extensions to DEFSTRUCT are reasonable and    needed improvements.  But I dissent from the proposal(s) for controlling    printing, which seem like they require the use of a sledgehammer to    crack an egg -- i.e., rebinding a special variable with dynamic effect    on printing of ALL structure instances (or even all instances of a    given class), including those embedded withing fields of other    instances, when what is wanted, if Corkill's example is    representative, is a finer control over a particular instance of printing.[I can't parse this last over-long sentence.]The default structure printing is no egg.  It is a large boulderthat someone dropped on us.  The right technology to deal withit is not a sledgehammer, but dynamite.  The one and only thingI want to have to do with the default structure printer is to*MAKE* *IT* *GO* *AWAY*!The one exception to this is if I indicate that I am doing outputthat is to be read by a program.  The default structure printeris something only a program could love.The issue of how structures print is closely related to theissue of separating the use of printer control variables forcontrolling program communication from the use of printercontrol variables as user-interface parameters.In this vein, I have another proposal to make:*PRINT-STRUCTURE-CONTENTS*  :FORCE-READABLE == force the now "standard" syntax.  T == use the now "standard" syntax unless a printer is       defined.  NIL (the recommended default at top level) = use the      #<...> syntax unless a printer is defined.[Feel free to add finer-grain control if desired, but this is definitely the level I would want to control this at.]PRINTING-RANDOM-OBJECT ((object stream &key (typep t) (unique-id t))			&body body)  Used in print functions, this takes care of printing the standard  part of non-readable objects.  If *PRINT-FOR-READ* is T (see below),  it signals an error.  The body is responsible for printing all  of the stuff in the middle, to identify the particular structure.  :TYPEP NIL suppresses the type name at the start (leaving that  responsibility to the body), and :UNIQUE-ID NIL suppresses the  number at the end.*PRINT-ESCAPE*  NIL == use the printer control variables.  T == use the printer control variables.  :FOR-READ = signal an error if PRINTING-RANDOM-OBJECT is called.  :FOR-READ-FORCE = skip print functions, and signal an error if    PRINTING-RANDOM-OBJECT is called (say, by the system-supplied    printer for a compiled function).    WITH-IO-ENVIRONMENT ((&Rest IO-keywords &KEY &ALLOW-OTHER-KEYS)		     &Body body)  Set up the IO parameters to allow programs to communicate.  Binds all IO parameters (including any defined by local  extensions to CL) to produce the standard results.  (*PRINT-ESCAPE*  is bound to :FOR-READ, *PRINT-STRUCTURE-CONTENTS* is bound to  T).  Any IO-keywords supplied override the standard values.  For example,  an application may which to say:  (WITH-IO-ENVIRONMENT (:PACKAGE "MY-DATABASE" :BASE 8.)     (PRINT DATABASE STREAM))[Actually, I really think that printer control should be on a per-streambasis, and the printer control variables should just serve as defaultswhen creating a stream.  But I don't see how to change that at this latedate.]DEFAULT-PRINT-STRUCTURE (object stream print-depth)  Print a structure in the now-standard manner.To take your example and recast it slightly:  (defstruct	(employee	 (:print-function	  (lambda (employee stream print-depth)	    ;; This print function won't be called if *PRINT-ESCAPE*            ;; is :FOR-READ-FORCE.	    (case *print-escape*	      (:for-read		(default-print-structure employee stream print-depth))	      (otherwise		(format stream "{Employee: ~A}"			(employee-name employee))))))))(One flaw in your example was that *PRINT-PRETTY* is only supposedto control simple changes like whitespace and 'FOO vs (QUOTE FOO).)Implementations would be allowed to default the printer flagswith somewhat more latitude than they are now.  For example:*print-case*, *print-level*, *print-length*, *print-array*,*print-structure-contents*.In addition, an implementation may provide other flags, suchas *PRINT-ARRAY-LENGTH*, (a maximum size to print using thereadable syntax for arrays), and these must be bound byWITH-IO-ENVIRONMENT to values to producing the standard syntax.Any program writing data for use by other programs which doesnot use WITH-IO-ENVIRONMENT is in error.  (Currently, any programwhich doesn't simulate WITH-IO-ENVIRONMENT by hand, is going tobreak whenever any user sets any control variables for whateverreason.*start*01163 00024 US Originator: @SAIL.Stanford.EDU:Rick.Busdiecker%H.GP.CS.CMU:EDU:XeroxDate: 25 Oct 87 08:01From: Rick.Busdiecker%H.GP.CS.CMU:EDU:XeroxSubject: extending DEFSTRUCTReply-to: Rick.Busdiecker%cs.cmu:EDU:XeroxTo: Dave.Touretzky%C.CS.CMU:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <@SAIL.Stanford.EDU:Rick.Busdiecker@H.GP.CS.CMU.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 07:01:46 PSTReceived: from H.GP.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 25 Oct 87  06:24:36 PSTOriginal-Date: 25 Oct 87 08:47 ESTMessage-Id: <562168063/rfb@H.GP.CS.CMU.EDU>I also support the proposed extensions to structure handling.    Date: Sat 24 Oct 87 15:16:08-EDT    From: Dave.Touretzky@C.CS.CMU.EDU        When *PRINT-STRUCTURE* in NIL:      defstructs with their own print functions will use them      defstructs without their own print function will print in the #<> notationIs there really a standard for #<> notation?  If so, what is it andwhere is it defined?  If not, perhaps we should define a default #<>notation such as #<name-of-structure-type>.			Rick*start*02823 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Dec 87 07:14Reply-to: baldwin%cs.rochester:EDU:XeroxFrom: baldwin%ACORN:ARPA:XeroxSubject: Re: structure type specifierIn-Reply-to: Msg of Tue, 8 Dec 87 06:53 EST from Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>To: RWK%YUKON.SCRC.Symbolics:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVReply-To: baldwin@cs.rochester.eduFrom: baldwin@ACORN.ARPATo: "Robert W. Kerns" <RWK@YUKON.SCRC.Symbolics.COM>Cc: common-lisp@sail.stanford.eduSubject: Re: structure type specifierIn-Reply-To: Msg of Tue, 8 Dec 87 06:53 EST from Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 DEC 87 07:14:59 PSTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.STANFORD.EDU with TCP; 8 Dec 87  06:48:11 PSTReceived: from BYRD.CS.ROCHESTER.EDU by ACORN.CS.ROCHESTER.EDU via CHAOS with CHAOS-MAIL id 25378; Tue 8-Dec-87 09:48:15 ESTMessage-Id: <2774962087-99174@BYRD>Original-Date: Tue, 8 Dec 87 09:48:07 ESTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV        From: Christopher Fry <cfry@OZ.AI.MIT.EDU>           STRUCTURE is not a legal type specifier ....        From: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>           Actually, it doesn't seem "awfully useful & natural" to me.        Natural, yes, but since CLtL doesn't have any primitives        for dealing with structures at all, it doesn't seem incredibly        useful.    Well, I think a standardized way of testing for "structure-hood"would be quite useful - from time to time I write my own tools forthings like pretty-printing, inspecting complex data structures, etc.(yes, most implementations have some or all of these, but the toolsaren't standard across implementations, so for portability or to fillin the gaps in some implementation I sometimes write my own.) I alsotend to write code that uses structures heavily, so my tools have todeal with them. In all of my tools I continually find myself wanting tofind out if an argument is a structure precisely BECAUSE Common Lispdoesn't provide primitives for getting inside a structure - knowingthat something is a structure then tells the printer/inspector/etcthat it has to punt (e.g., hope the user provided a decent:print-function, or something like that). Conversely, of course,if Common Lisp DID provide generic structure-manipulating primitives thenI would want to test for "structure-hood" in order to be able todecide whether those primitives could be applied to an object.In either case I think Common Lisp should provide a "structurep"predicate, "structure" as a type identifier, etc.*start*01958 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Dec 87 04:20From: RWK%YUKON.SCRC.Symbolics:COM:XeroxSubject: structure type specifierIn-Reply-to: <871207222343.9.CFRY@JONES.AI.MIT.EDU>To: cfry%OZ.AI.MIT:EDU:Xeroxcc: Common-Lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Subject: structure type specifierTo: Christopher Fry <cfry@OZ.AI.MIT.EDU>cc: Common-Lisp@sail.stanford.eduIn-Reply-To: <871207222343.9.CFRY@JONES.AI.MIT.EDU>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 DEC 87 04:20:35 PSTReceived: from SCRC-YUKON.ARPA by SAIL.STANFORD.EDU with TCP; 8 Dec 87  03:53:59 PSTReceived: from WHITE-BIRD.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 303407; Tue 8-Dec-87 06:53:54 ESTOriginal-Date: Tue, 8 Dec 87 06:53 ESTMessage-ID: <19871208115346.0.RWK@WHITE-BIRD.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon, 7 Dec 87 22:23 EST    From: Christopher Fry <cfry@OZ.AI.MIT.EDU>    STRUCTURE is not a legal type specifier according to    CLtL p 43 table of type specifier symbols.    Seems awfully useful & natural to me.    Has CLtL been superceded? Did I miss some reference somewhere?    Similarly STRUCTUREP isn't a CL function.    Does anyone have a CL implementation without structurep or equivalent?Actually, it doesn't seem "awfully useful & natural" to me.Natural, yes, but since CLtL doesn't have any primitivesfor dealing with structures at all, it doesn't seem incrediblyuseful.But that's the fault of CL, and not your idea.  Symbolics CLprovides NAMED-STRUCTURE-P and the STRUCTURE type.  Typescreated by DEFSTRUCT are all subtypes of STRUCTURE.If you know where to find them, there are also tools for decoding astructure.*start*02028 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Dec 87 17:03From: barmar%Think:COM:XeroxSubject: Re: structure type specifierIn-Reply-to: <2774962087-99174@BYRD>To: baldwin%cs.rochester:EDU:Xeroxcc: RWK%yukon.scrc.symbolics:COM:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: structure type specifierTo: baldwin@cs.rochester.eduCc: Robert W. Kerns <RWK@yukon.scrc.symbolics.com>, common-lisp@sail.stanford.eduIn-Reply-To: <2774962087-99174@BYRD>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 DEC 87 17:03:48 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 8 Dec 87  16:28:41 PSTReturn-Path: <@Think.COM:barmar@Think.COM>Received: from sauron.think.com by Think.COM; Tue, 8 Dec 87 19:23:49 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Tue, 8 Dec 87 19:22:21 ESTOriginal-Date: Tue, 8 Dec 87 19:23 ESTMessage-Id: <871208192313.6.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Tue, 8 Dec 87  09:48:07 EST    From: baldwin@ACORN    In all of my tools I continually find myself wanting to    find out if an argument is a structure precisely BECAUSE Common Lisp    doesn't provide primitives for getting inside a structure - knowing    that something is a structure then tells the printer/inspector/etc    that it has to punt (e.g., hope the user provided a decent    :print-function, or something like that).Presumably your tools also have to punt if the object is of a type notmentioned at all in CLtL (e.g. a flavor).  So the structure case couldbe handled by the T clause in your TYPECASE.  Unless it can do somethingdifferent with structures than it does with other undecipherableobjects there doesn't seem to be a need for a way to distinguish them.                                                barmar*start*00953 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  8 Dec 87 16:55Subject: Re: structure type specifierFrom: Larry Masinter:PARC:XeroxIn-Reply-to: cfry%OZ.AI.MIT:EDU:Xerox's message of 7 Dec 87 23:40To: cfry%OZ.AI.MIT:EDU:Xeroxcc: Common-Lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 DEC 87 16:55:21 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 8 Dec 87  16:21:14 PSTReceived: from Riesling.ms by ArpaGateway.ms ; 08 DEC 87 16:21:02 PSTOriginal-Date: 8 Dec 87 16:20:16 PST (Tuesday)Message-ID: <871208-162102-5563@Xerox>Its legit and even good design practice to treat every data type as if it mightbe a structure. If Xerox Common Lisp had STRUCTUREP, it would be true of everyobject. (Of course, some objects, like fixnums, don't have slots and are"preallocated".)*start*01596 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  9 Dec 87 07:07Reply-to: baldwin%cs.rochester:EDU:XeroxFrom: baldwin%ACORN:ARPA:XeroxSubject: Re: structure type specifierIn-Reply-to: Msg of Tue, 8 Dec 87 19:23 EST from Barry Margolin <barmar@Think.COM>To: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 DEC 87 07:07:04 PSTReceived: from ACORN.CS.ROCHESTER.EDU by SAIL.STANFORD.EDU with TCP; 9 Dec 87  06:34:55 PSTReceived: from BYRD.CS.ROCHESTER.EDU by ACORN.CS.ROCHESTER.EDU via CHAOS with CHAOS-MAIL id 25478; Wed 9-Dec-87 09:36:30 ESTMessage-Id: <2775047786-60842@BYRD>Original-Date: Wed, 9 Dec 87 09:36:26 EST	Presumably your tools also have to punt if the object is of a type not	mentioned at all in CLtL (e.g. a flavor)....    Problem is that things not mentioned at all in CLtL are necessarilyimplementation-dependent and so I have an "honest" choice betweencompromising portability for clear handling of these objects or not,whereas with structures I don't have this choice - they're a standardpart of Common Lisp, but Common Lisp doesn't give me the tools todo much with them. (Put another way, if I want to handle animplementation-dependent extension to Common Lisp in animplementation-dependent way I don't feel as bad about it as handlinga defined part of the language in a non-portable way.) For this reasonI still think Common Lisp badly needs at least minimal support a"structure" type. *start*02061 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  9 Dec 87 12:08From: RWK%YUKON.SCRC.Symbolics:COM:XeroxSubject: Re: structure type specifierIn-Reply-to: <2775047786-60842@BYRD>To: baldwin%cs.rochester:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Subject: Re: structure type specifierTo: baldwin@cs.rochester.educc: common-lisp@sail.stanford.eduIn-Reply-To: <2775047786-60842@BYRD>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 DEC 87 12:08:45 PSTReceived: from SCRC-YUKON.ARPA by SAIL.STANFORD.EDU with TCP; 9 Dec 87  11:24:58 PSTReceived: from WHITE-BIRD.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 304367; Wed 9-Dec-87 13:49:33 ESTOriginal-Date: Wed, 9 Dec 87 13:49 ESTMessage-ID: <19871209184929.0.RWK@WHITE-BIRD.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Wed, 9 Dec 87  09:36:26 EST    From: baldwin@ACORN	Problem is that things not mentioned at all in CLtL are necessarily    implementation-dependent and so I have an "honest" choice between    compromising portability for clear handling of these objects or not,    whereas with structures I don't have this choice - they're a standard    part of Common Lisp, but Common Lisp doesn't give me the tools to    do much with them. (Put another way, if I want to handle an    implementation-dependent extension to Common Lisp in an    implementation-dependent way I don't feel as bad about it as handling    a defined part of the language in a non-portable way.) For this reason    I still think Common Lisp badly needs at least minimal support a    "structure" type.I don't disagree, I'm just pointing out that it's not worthmuch unless we also include minimal support for working withobjects of the STRUCTURE type.  Neither you nor I are the firstto point this out.*start*02185 00024 US Date: 14 Dec 87 15:15From: hoey%nrl-aic:ARPA:XeroxSubject: Re: structure type specifierTo: RWK%YUKON.SCRC.Symbolics:COM:Xerox, Larry Masinter:PARC:Xerox, cfry%OZ.AI.MIT.EDU%MC.LCS.MIT:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Dan Hoey <hoey@nrl-aic.ARPA>Subject: Re: structure type specifierTo: "Robert W. Kerns" <RWK@YUKON.SCRC.Symbolics.COM>, "Larry Masinter".PARC, cfry%OZ.AI.MIT.EDU@MC.LCS.MIT.EDUReturn-Path: <hoey@nrl-aic.ARPA>Received: from nrl-aic.ARPA by Xerox.COM ; 14 DEC 87 15:14:06 PSTReturn-Path: <hoey>Received: Mon, 14 Dec 87 18:04:42 est by nrl-aic.ARPA id AA20567Original-Date: 14 Dec 87 17:40:00 EST (Mon)Message-Id: <566520002/hoey@nrl-aic>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 11 Dec 87 15:56 EST    From: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>        Date: 8 Dec 87 16:20:16 PST (Tuesday)        From: "Larry_Masinter.PARC"@Xerox.COM        Its legit and even good design practice to treat every data type as        if it might be a structure. If Xerox Common Lisp had STRUCTUREP, it        would be true of every object....    STRUCTURE (and STRUCTUREP) would just indicate whether they follow    the protocol of things you can to do **named structures**.  (That is,    Inquiring about slots, acessing the slots found, and basically getting    your hands on the information in the original DEFSTRUCT)....The point I took from Larry's note is that the protocol of things youcan do to named structures in Common Lisp doesn't include anything youcan't do to anything else.  You *can't* inquire about the slots or getyour hands on the DEFSTRUCT info.  There have been several proposalsfor making this information visible to the programmer, but until one isadopted, having the type STRUCTURE present is useless.It's true that Symbolics Common Lisp makes the type LISP:STRUCTUREavailable to the programmer, but that seems to be an accident.  The SCLextensions inherit STRUCTURE from the LISP package (where it is definedonly as an argument to the DOCUMENTATION function) and use the samesymbol for the internal type of named structures.Dan*start*03225 00024 US Date: 16 Dec 87 21:21From: RWK%YUKON.SCRC.Symbolics:COM:XeroxSubject: Re: structure type specifierIn-Reply-to: <566520002/hoey@nrl-aic>To: hoey%NRL-AIC:ARPA:Xeroxcc: Larry Masinter:PARC:Xerox, cfry%OZ.AI.MIT.EDU%MC.LCS.MIT:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Subject: Re: structure type specifierTo: Dan Hoey <hoey@NRL-AIC.ARPA>cc: "Larry Masinter".PARC, cfry%OZ.AI.MIT.EDU@MC.LCS.MIT.EDUIn-Reply-To: <566520002/hoey@nrl-aic>Return-Path: <RWK@YUKON.SCRC.Symbolics.COM>Received: from YUKON.SCRC.Symbolics.COM (SCRC-YUKON.ARPA) by Xerox.COM ; 16 DEC 87 21:20:58 PSTReceived: from WHITE-BIRD.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 308876; Thu 17-Dec-87 00:20:19 ESTOriginal-Date: Thu, 17 Dec 87 00:20 ESTMessage-ID: <19871217052015.3.RWK@WHITE-BIRD.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: 14 Dec 1987 17:40:00 EST (Mon)    From: Dan Hoey <hoey@nrl-aic.ARPA>	Date: Fri, 11 Dec 87 15:56 EST	From: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>	    Date: 8 Dec 87 16:20:16 PST (Tuesday)	    From: "Larry_Masinter.PARC"@Xerox.COM	    Its legit and even good design practice to treat every data type as	    if it might be a structure. If Xerox Common Lisp had STRUCTUREP, it	    would be true of every object....	STRUCTURE (and STRUCTUREP) would just indicate whether they follow	the protocol of things you can to do **named structures**.  (That is,	Inquiring about slots, acessing the slots found, and basically getting	your hands on the information in the original DEFSTRUCT)....    The point I took from Larry's note is that the protocol of things you    can do to named structures in Common Lisp doesn't include anything you    can't do to anything else.  You *can't* inquire about the slots or get    your hands on the DEFSTRUCT info.  There have been several proposals    for making this information visible to the programmer, but until one is    adopted, having the type STRUCTURE present is useless.If you represent Larry's view accurately, then we're all threesaying the same thing.    It's true that Symbolics Common Lisp makes the type LISP:STRUCTURE    available to the programmer, but that seems to be an accident.  Emphatically *NOT* an accident.  (However, it IS an accident it's inLISP:, not SCL: SCL is the package we normally use instead of LISP.).The type *IS* useful.  It is the set of types defined by DEFSTRUCT, andwould be useful in CL as well if CL only had the missing primitives forworking with structures that we've discussed so much.  If we didn'twant to make it available for programmers, we wouldn't have defined it.Our software (and I'll bet just about everyone else's software) providesways to investigate structures.  (Although they may not be advertizedor documented).								    The SCL    extensions inherit STRUCTURE from the LISP package (where it is defined    only as an argument to the DOCUMENTATION function) and use the same    symbol for the internal type of named structures.Indeed, that's why it's in the LISP: package, rather in SCL.    Dan*start*01995 00024 USaReturn-Path: <RWK@YUKON.SCRC.Symbolics.COM>Received: from YUKON.SCRC.Symbolics.COM (SCRC-YUKON.ARPA) by Xerox.COM ; 16 DEC 87 22:22:44 PSTReceived: from WHITE-BIRD.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 308888; Thu 17-Dec-87 01:22:33 ESTDate: Thu, 17 Dec 87 01:22 ESTFrom: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Subject: Re: structure type specifierTo: Masinter.paIn-Reply-To: <871214-133750-1961@Xerox>Message-ID: <19871217062230.1.RWK@WHITE-BIRD.SCRC.Symbolics.COM>    Date: 14 Dec 87 13:37 PST    From: Masinter.pa@Xerox.COM    Sigh. "All objects have class." The CLOS spec contains accessors for doing what    you want with structures, but it applies to all CL data objects, including the    built in classes. Certainly CONS is a "structure" with two slots "CAR" and    "CDR".      I'm not making myself clear, I can see.How about the "Generate a DEFSTRUCT definition" operation?You can't define NUMBER with DEFSTRUCT.  The STRUCTURE typeis tied directly to the capabilities of DEFSTRUCT (actually,to DEFSTRUCT without the :TYPE option).Obviously, this isn't as general or as useful as a more generalprotocol, but it isn't useless.  It helps establish the boundariesof what protocols do and don't apply.It certainly should be legitimate for CONS to be a subtype ofSTRUCTURE, or RATIONAL, etc.  (Although I don't believe theDEFSTRUCT language is powerful enough to tackle INTEGER, or ARRAY, or other variable-length types).  If I were defining thelanguage afresh, I wouldn't include DEFSTRUCT or STRUCTURE,but if we have the one, we should have the other.Also, I don't know whether to expect everyone to actually implementCLOS, especially the meta-object protocol required for thedegree of uniformity you're looking for.  One minute I wantto say "But not everyone will have CLOS, and so the arbitraryboundaries will exist for that reason as well".  The next, I'm notso pessimistic.*start*01160 00024 US Date: 16 Dec 87 23:46 PSTFrom: masinter.paSubject: Re: string as vector of fixnums ?In-reply-to: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>'s message of Thu, 17 Dec 87 00:23 ESTTo: RWK@YUKON.SCRC.Symbolics.COMcc: Masinter.paWe have some trouble understanding each other. I sent you a suggestion about some new function, not in CLtL, that I called, offhand "read-bytes". I mentioned that I thought CL could use some better support for reading in vectors of stuff as well as read-byte and read-char.You said "No, the problem really is that the name of the operation is poorly chosen.It really should be READ-VECTOR or something.  The requirement is thatelement-type of the vector must be a supertype of the element type ofthe stream, not that the vector be a string."I think it is the initial "No," that threw me. There's a problem that CL doesn't have read-bytes or read-vector either. You suggest adding READ-VECTOR instead of READ-BYTES, with the notion that it could read in characters from a character stream and bytes from a byte stream.Right?While we're at it, why not READ-SEQUENCE? Why stick with vectors?*start*03089 00024 US Return-Path: <RWK@YUKON.SCRC.Symbolics.COM>Received: from YUKON.SCRC.Symbolics.COM (SCRC-YUKON.ARPA) by Xerox.COM ; 17 DEC 87 01:14:16 PSTReceived: from WHITE-BIRD.SCRC.Symbolics.COM by YUKON.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 308930; Thu 17-Dec-87 04:13:52 ESTDate: Thu, 17 Dec 87 04:13 ESTFrom: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>Subject: string as vector of fixnums ?To: Masinter.paIn-Reply-To: <871216-234703-1164@Xerox>Message-ID: <19871217091344.4.RWK@WHITE-BIRD.SCRC.Symbolics.COM>    Date: 16 Dec 87 23:46 PST    From: masinter.pa@Xerox.COM    We have some trouble understanding each other. I sent you a suggestion about    some new function, not in CLtL, that I called, offhand "read-bytes". I mentioned    that I thought CL could use some better support for reading in vectors of stuff    as well as read-byte and read-char.        You said "No, the problem really is that the name of the operation is poorly    chosen.    It really should be READ-VECTOR or something.  The requirement is that    element-type of the vector must be a supertype of the element type of    the stream, not that the vector be a string."        I think it is the initial "No," that threw me. There's a problem that CL doesn't    have read-bytes or read-vector either. You suggest adding READ-VECTOR instead of    READ-BYTES, with the notion that it could read in characters from a character    stream and bytes from a byte stream.        Right?Well, actually, what threw ME was your mention of not havingyour Symbolics documentation handy, and wondering if there wassuch a thing in SCL.  This put me into the wrong context forinterpreting what your real issue was.The "No, the problem really is that the name ... is poorly chosen"referred to SCL, not to your suggestion (although I picked READ-VECTORas an improvement on READ-BYTES).  It's the :STRING-OUT name I wasreally complaining about.  But READ-BYTES has the problem that it'sspecific to byte streams; the operation is really generic acrossinput streams of any element type.Also, your function (and mine) fail to do anything reasonable about EOF.Myself, I'd just as soon pass in an EOF continuation.  The alternativeis to return multiple values.  Don't forget you have to allow for partialbuffer fills; you may reach EOF in the middle of the specified range.So you need to return a count of characters transfered, or a final index,or something.BTW, We hope to redesign our entire stream protocol for our next release.CL just scratches the surface.    While we're at it, why not READ-SEQUENCE? Why stick with vectors?Because nobody in his right mind would use lists, and if he did,there wouldn't be any performance advantage to looping.In other words, it's because of my long-standing myopia aboutsequences: they're just a kludge to keep down the number of functionsin the language, and not really interchangable.  Like I said, myopia.It's still a deeply ingrained prejudice after all these years.  Irecognize it when I think about it.*start*23745 00024 US Date: 18 Dec 86 13:45 PSTSender: Bobrow.paFrom: Danny Bobrow <Bobrow.pa>Subject: [Daniel L. Weinreb <DLW@ALDERAAN.SCRC.Symbolics.COM>: defstorage]To: Masintercc: Bobrow.paThis is the symbolics version of Blockrecord.  Are you still interested in taking a crack at the DEFRECORD design?danny     ----- Begin Forwarded Messages -----Return-Path: <DLW@ALDERAAN.SCRC.Symbolics.COM>Received: from ALDERAAN.SCRC.Symbolics.COM ([192.10.41.109]) by Xerox.COM ; 17 DEC 86 11:31:17 PSTReceived: from CHICOPEE.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 31349; Wed 17-Dec-86 14:25:35 ESTDate: Wed, 17 Dec 86 14:27 ESTFrom: Daniel L. Weinreb <DLW@ALDERAAN.SCRC.Symbolics.COM>Subject: defstorageTo: Bobrow.PA@XEROX.ARPAMessage-ID: <861217142711.0.DLW@CHICOPEE.SCRC.Symbolics.COM>Line-fold: NoOK, I have pulled together information about the "defstorage" macro usedin the Symbolics file system.  It was written by Bernie Greenberg, ashis first major project after leaving the Multics group at Honeywell tojoin the newly-minted Symbolics Inc.  A comment at the beginning of thefile says:;;; A PL/I like storage-laying-out facility;;; (I have now determined that "PL/I like" means that 3/4 of a PL/I compiler;;; is implemented in this file)Now that you're enthusiastic...Here's the documentation, such as it is.  An "art-8b" array means anarray of unsigned 8-bit integers.  If you have questions, I might beable to answer them, but Bernie is the expert.  He can be reached as"bsg" at any Symbolics host.;;;(lmfs:defstorage (STRUCTURE-NAME . OPTIONS);;;    FIELD-DEF;;;    FIELD-DEF;;;    .........;;;    FIELD-DEF);;;;;;   Defines a "layout" of 8-bit bytes into bit fields, fixna, char strings, counted;;;   char strings, flags, substructures, and macros for accessing these objects given;;;   an art-8b array in which they appear, storing them, and in the case of strings,;;;   comparing them, as well as the ability to define other kinds of macros.;;;   Note that all stored objects are "flat" objects, i.e., no Lisp pointers.;;;   Bytes and bits assigned in Lisp Machine (Hebraic) order in a word.;;;;;;    FIELD DEF has the syntax (FIELD-NAME . DATA TYPE DESCRIPTION);;; Examples:;;;    (foo-count  fixnum-bytes 2)          ;16-bit nonnegative integer;;;    (bar-count  fixnum)                  ;fullword-aligned 4-byte positive integer;;;    (title      char 8.)                 ;8 char character string, aligned to char;;;    (subtitle   char-with-length 14.)    ;14 char string stored with 2-byte length;;;    (glubtitle  short-char-with-length 10.)  ;same, 1-byte length;;;    (magic      byte)                    ;1-byte integer = (fixnum-bytes 1);;;    (valid      flag)		    ;T or NIL, occupies 1 bit;;;    (type       bit 3)		    ;3-bit nonnegative integer;;;    (ignore     mod word)		    ;Force alignment to a word.;;;					    ;any field name starting with "ignore";;;					    ;generates no macros; mod takes "word" or "byte";;;					    ;Magic words and kwds can be on any package.;;;    (descrip    mumble)		    ;Previously defined structure name includes;;;;;;  DATA TYPE DESCRIPTION  can also be (... array dimlist . DATA-TYPE-DESCRIPTION);;;  e.g., (foo-array array (3 2 4) fixnum).  Arrays of structures are legal.;;;  Array indexing is PL/I-like (unlike Lisp).  This is necessary because of ;;;  the need for consistent subscripting of substructures: First index/dim describes ;;;  number of biggest subunits.  First dim may be * for the last element in a structure.;;;  Arrays of a single dimension need not have the single dimension in a list.;;;;;;  If FIELD-NAME is *, no accessors or setter properties are generated for the field,;;;  but is space is still accounted for.  This is NOT SO for structure's or union's;;;  or arrays thereof (see below), where * means "don't catenate in a level of name".;;;  This is also true of "being"'s.;;;;;;   Accessor Syntax;;;   Accessor macro forms have the general syntax;;;   (ACCESSOR-NAME 8BIT-VALUE)  where 8BIT-VALUE is evaluated to produce a ;;;   art-8b array which is assumed to have the stucture at its base.  ACCESSOR-NAME;;;   is constructed as STRUCTURE-NAME-FIELD-NAME in general.  When substructures;;;   are involved, STRUCTURE-NAME-FIELD-NAME-FIELD2NDLEVEL-NAME... etc.  Note that;;;   the field names, not the structure names are used at other than the top level.;;;   If a lowest-level structure has only one component named *, its name is NOT;;;   incorporated in accessor names (or the "-" before it). This allows you to;;;   say "a DATE is a FIXNUM that I think of as a DATE", etc.;;;;;;   The value of the accessor macro form is a Lisp object; fixna for fixnum and;;;   bit fields, T/NIL for flags, freshly-consed strings for char/char-with-length.;;;   When an array reference is involved,  the accessor macro has the syntax;;;   (ACCESSOR-NAME 8BIT-VALUE SUBSC1 SUBSC2...) where the subscripts are evaluated,;;;   but not in any guaranteed order!.   A reference to an array with no supplied;;;   subscripts is called an "aggregate" reference, and produces a multilevel (if needed);;;   list of the listed levels of the array (e.g., a single-level list for a 1-dim array).;;;;;;   Properties are defined such that accessor macro forms can be SETF'ed; this includes;;;   aggregate setting of arrays.  Character fields also generate a "compare accessor"..;;;   (accessor-name-COMPARE 8BIT-VALUE COMPAREVAL) which tests string-equality of any kind;;;   of defstoraged char-string without consing. Subscripts, if any, follow COMPAREVAL.;;;;;;  If :ALTERANT appears among the keywords in OPTIONS, a macro called;;;  alter-STRUCTURE-NAME is defined (uppercase), which looks exactly like a DEFSTRUCT;;;  alterant and has the same effect.  :CONSTRUCTOR in the OPTIONS causes a;;;  make-STRUCTURE-NAME macro to be defined, like DEFSTRUCT, but this actually ALLOCATES;;;  an art-8b array and initializes it.  "Made" things like this are DESCRIBE-able,;;;  and get all their fields interpreted by so doing.  Otherwise,;;;  (lmfs:defstorage-describe 8bit-expression 'structure-name) does that.;;;;;;  If :UNION appears among the keywords in OPTIONS, all of the comprising fields;;;  of the structure are assumed to start at the beginning of the structure.  The;;;  size of the structure is the maximum size of the comprising fields. That is,;;;  all the fields overlap, and thus, a many-definitioned structure is created.;;;;;;  Substructures or unions can be included as DATA-TYPE-DESCRIPTIONs.  The syntax;;;  for such a FIELD-DEF is;;;  (FIELD-NAME structure;;;		 sub-FIELD-DEF-1;;;		 sub-FIELD-DEF-2;;;		 ...);;;  If "union" is given instead of "structure", a union is created (all the subfields;;;  overlap.  Unions and arrays of unions and arrays of structures, etc., are all fine,;;;  with the single restriction that ARRAYED substructures must (currently);;;  be an integral number of bytes.  If FIELD-NAME is *, it is not catenated into;;;  accessor names of the subfields; otherwise, it would be.;;;;;;  A DATA-TYPE-DESCRIPTION starting with "being" factors a declaration:;;;  (foo being flag;;;       a b c);;;  is equivalent to;;;  (a flag) (b flag) (c flag);;;  * may be used for the FIELD-NAME of a being.  The field-name of the being;;;  doesn't get used for anything, anyway.;;;;;;  Bit field arrays are currently limited to 1, 2, 4, or 8 bits, and;;;  must align with boundaries of that many bits.  Bit fields (single fields, not arrays);;;  may span byte boundaries, and need not align to byte boundaries.  Bit fields;;;  appearing as part of arrayed structures are may be any size, ;;;  and are not considered bit field arrays.;;;;;;  Macros called structure-name-SIZE-IN-BYTES (and -WORDS, and -BITS) are defined;;;  for outer level *and* internal structures, as long as they are not named *.;;;;;;  For the rest of the features and obscure restrictions read the code yourself.Here's an example.  In fact, I'll use those same field definitions he gave above:(lmfs:defstorage (testing)    (foo-count  fixnum-bytes 2)    (bar-count  fixnum)    (title      char 8.)    (subtitle   char-with-length 14.)    (glubtitle  short-char-with-length 10.)    (magic      byte)    (valid      flag)    (type       bit 3)    (ignore     mod word))And here's the expansion, with comments by me.  Note that this waswritten originally in 1981 so it uses some archaic constructs and is NOTCommon Lisp.;;; The sys:function-parent and record-source-file-name provide info;;; for the programming environment tools like the editor, cause warnings;;; if you try to reuse the name for something else, etc.(COMPILER-LET ((SYS:LOCAL-DECLARATIONS                (APPEND '((SYS:FUNCTION-PARENT TESTING LMFS:DEFSTORAGE))                        SYS:LOCAL-DECLARATIONS)))  (RECORD-SOURCE-FILE-NAME 'TESTING 'LMFS:DEFSTORAGE)  (EVAL-WHEN (COMPILE ZL:LOAD EVAL) ;; The following property is for DESCRIBE to use, or a describe-like tool maybe.    (ZL:PUTPROP 'TESTING                '(NIL                  ((FOO-COUNT FIXNUM-BYTES 2) (BAR-COUNT FIXNUM) (TITLE CHAR 8)                   (SUBTITLE CHAR-WITH-LENGTH 14) (GLUBTITLE SHORT-CHAR-WITH-LENGTH 10)                   (MAGIC BYTE) (VALID FLAG) (TYPE BIT 3) (IGNORE MOD WORD)))                'LMFS:DEFSTORAGE-DEF)    (ZL:PUTPROP 'TESTING                '((TESTING-FOO-COUNT 0 (LMFS:FIXNUM-BYTES 2))                  (TESTING-BAR-COUNT 32 (LMFS:FIXNUM-BYTES 4)) (TESTING-TITLE 64 (LMFS:CHAR 8))                  (TESTING-SUBTITLE 144 (LMFS:CHAR-WITH-LENGTH (14 . 2)))                  (TESTING-GLUBTITLE 264 (LMFS:CHAR-WITH-LENGTH (10 . 1)))                  (TESTING-MAGIC 344 (LMFS:FIXNUM-BYTES 1)) (TESTING-VALID 352 (LMFS:FLAG 1))                  (TESTING-TYPE 353 (LMFS:BIT 3)))                'LMFS:DEFSTORAGE-RUNTIME-INFO)    (ZL:PUTPROP 'TESTING 48 'LMFS:STRUCTURE-SIZE-IN-BYTES))  (DEFMACRO TESTING-SIZE-IN-BITS NIL    '(PROGN 384))  (DEFMACRO TESTING-SIZE-IN-BYTES NIL    '(PROGN 48))  (DEFMACRO TESTING-SIZE-IN-WORDS NIL    '(PROGN 12))  ;; MACRO is a primitive special form for defining macros.  The first argument is  ;; the entire macro body.  Maybe we didn't have &optional in defmacros in 1981.  (MACRO TESTING-FOO-COUNT (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG          (ONCE-ONLY (LMFS:8ARY)            `(DPB (AREF ,LMFS:8ARY 1) (BYTE 8 8) (AREF ,LMFS:8ARY 0))))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-FOO-COUNT (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:VAL)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG            (ONCE-ONLY (LMFS:8ARY LMFS:VAL)              `(PROGN (ZL:ASET (LDB (BYTE 8 8) ,LMFS:VAL) ,LMFS:8ARY 1)                      (ZL:ASET (LDB (BYTE 8 0) ,LMFS:VAL) ,LMFS:8ARY 0))))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:VAL 'NIL))))  (MACRO TESTING-BAR-COUNT (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG          (ONCE-ONLY (LMFS:8ARY)            `(DPB (AREF ,LMFS:8ARY 7)                  (BYTE 8 24)                  (DPB (AREF ,LMFS:8ARY 6)                       (BYTE 8 16)                       (DPB (AREF ,LMFS:8ARY 5) (BYTE 8 8) (AREF ,LMFS:8ARY 4))))))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-BAR-COUNT (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:VAL)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG            (ONCE-ONLY (LMFS:8ARY LMFS:VAL)              `(PROGN (ZL:ASET (LDB (BYTE 8 24) ,LMFS:VAL) ,LMFS:8ARY 7)                      (ZL:ASET (LDB (BYTE 8 16) ,LMFS:VAL) ,LMFS:8ARY 6)                      (ZL:ASET (LDB (BYTE 8 8) ,LMFS:VAL) ,LMFS:8ARY 5)                      (ZL:ASET (LDB (BYTE 8 0) ,LMFS:VAL) ,LMFS:8ARY 4))))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:VAL 'NIL))))  (MACRO TESTING-TITLE (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARRAY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARRAY) LMFS:MACROARG          `(LMFS:DEFSTORAGE-RT-MAKE-STRING ,LMFS:8ARRAY 8 8))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (DEFMACRO TESTING-TITLE-COMPARE (LMFS:8ARRAY LMFS:VALUE)    `(LMFS:DEFSTORAGE%STRING-EQUAL ,LMFS:8ARRAY 8 ,LMFS:VALUE 0 8))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-TITLE (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:V)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARRAY) LMFS:MACROARG            `(LMFS:DEFMACRO%STORE-SUBSTRING ,LMFS:V ,LMFS:8ARRAY 8 8))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:V 'NIL))))  (DEFMACRO TESTING-SUBTITLE-MAX-LENGTH NIL    '(PROGN 14))  (MACRO TESTING-SUBTITLE-LENGTH (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG          (ONCE-ONLY (LMFS:8ARY)            `(DPB (AREF ,LMFS:8ARY 17) (BYTE 8 8) (AREF ,LMFS:8ARY 16))))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-SUBTITLE-LENGTH (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:VAL)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG            (ONCE-ONLY (LMFS:8ARY LMFS:VAL)              `(PROGN (ZL:ASET (LDB (BYTE 8 8) ,LMFS:VAL) ,LMFS:8ARY 17)                      (ZL:ASET (LDB (BYTE 8 0) ,LMFS:VAL) ,LMFS:8ARY 16))))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:VAL 'NIL))))  (MACRO TESTING-SUBTITLE (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARRAY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARRAY) LMFS:MACROARG          (ONCE-ONLY (LMFS:8ARRAY)            `(LMFS:DEFSTORAGE-RT-MAKE-STRING ,LMFS:8ARRAY                                             18                                             (LMFS:*INTERNAL-TWO-BYTE-LENGTH-GETTER ,LMFS:8ARRAY                                                                                    16))))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-SUBTITLE (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:V)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARRAY) LMFS:MACROARG            (ONCE-ONLY (LMFS:8ARRAY LMFS:V)              `(LET ((LMFS:V-STRINGLEN (MIN 14 (STRING-LENGTH ,LMFS:V))))                 (LMFS:DEFMACRO%STORE-SUBSTRING ,LMFS:V ,LMFS:8ARRAY 18 LMFS:V-STRINGLEN)                 (ZL:SETF (LMFS:*INTERNAL-TWO-BYTE-LENGTH-GETTER ,LMFS:8ARRAY 16)                          LMFS:V-STRINGLEN))))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:V 'NIL))))  (DEFMACRO TESTING-SUBTITLE-COMPARE (LMFS:8ARRAY LMFS:VALUE)    (ONCE-ONLY (LMFS:8ARRAY LMFS:VALUE)      `(LET ((LMFS:DATL (LMFS:*INTERNAL-TWO-BYTE-LENGTH-GETTER ,LMFS:8ARRAY 16)))         (AND (= (STRING-LENGTH ,LMFS:VALUE) LMFS:DATL)              (LMFS:DEFSTORAGE%STRING-EQUAL ,LMFS:8ARRAY 18 ,LMFS:VALUE 0 LMFS:DATL)))))  (DEFMACRO TESTING-GLUBTITLE-MAX-LENGTH NIL    '(PROGN 10))  (MACRO TESTING-GLUBTITLE-LENGTH (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG          `(AREF ,LMFS:8ARY 32))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-GLUBTITLE-LENGTH (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:V)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG            `(ZL:ASET ,LMFS:V ,LMFS:8ARY 32))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:V 'NIL))))  (MACRO TESTING-GLUBTITLE (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARRAY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARRAY) LMFS:MACROARG          (ONCE-ONLY (LMFS:8ARRAY)            `(LMFS:DEFSTORAGE-RT-MAKE-STRING ,LMFS:8ARRAY                                             33                                             (LMFS:*INTERNAL-ONE-BYTE-LENGTH-GETTER ,LMFS:8ARRAY                                                                                    32))))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-GLUBTITLE (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:V)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARRAY) LMFS:MACROARG            (ONCE-ONLY (LMFS:8ARRAY LMFS:V)              `(LET ((LMFS:V-STRINGLEN (MIN 10 (STRING-LENGTH ,LMFS:V))))                 (LMFS:DEFMACRO%STORE-SUBSTRING ,LMFS:V ,LMFS:8ARRAY 33 LMFS:V-STRINGLEN)                 (ZL:SETF (LMFS:*INTERNAL-ONE-BYTE-LENGTH-GETTER ,LMFS:8ARRAY 32)                          LMFS:V-STRINGLEN))))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:V 'NIL))))  (DEFMACRO TESTING-GLUBTITLE-COMPARE (LMFS:8ARRAY LMFS:VALUE)    (ONCE-ONLY (LMFS:8ARRAY LMFS:VALUE)      `(LET ((LMFS:DATL (LMFS:*INTERNAL-ONE-BYTE-LENGTH-GETTER ,LMFS:8ARRAY 32)))         (AND (= (STRING-LENGTH ,LMFS:VALUE) LMFS:DATL)              (LMFS:DEFSTORAGE%STRING-EQUAL ,LMFS:8ARRAY 33 ,LMFS:VALUE 0 LMFS:DATL)))))  (MACRO TESTING-MAGIC (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG          `(AREF ,LMFS:8ARY 43))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-MAGIC (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:V)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG            `(ZL:ASET ,LMFS:V ,LMFS:8ARY 43))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:V 'NIL))))  (MACRO TESTING-VALID (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG          `(ZL:BIT-TEST 1 (AREF ,LMFS:8ARY 44)))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-VALID (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:V)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG            (ONCE-ONLY (LMFS:8ARY)              `(ZL:ASET ,(LET ((LMFS:BYTEGET `(AREF ,LMFS:8ARY 44)))                           (IF (LMFS:DEFSTORAGE-CONBOOLABLE* LMFS:V)                               (LMFS:DEFSTORAGE-CONBOOLE* LMFS:V 0 LMFS:BYTEGET)                               `(DPB (IF ,LMFS:V 1 0) (BYTE 1 0) ,LMFS:BYTEGET)))                        ,LMFS:8ARY                        44)))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:V 'NIL))))  (MACRO TESTING-TYPE (LMFS:MACROARG IGNORE)    (DECLARE (ARGLIST LMFS:8ARY))    (IF (= (ZL:LENGTH LMFS:MACROARG) 2)        (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG          `(LDB (BYTE 3 1) (AREF ,LMFS:8ARY 44)))        (LMFS:DEFSTORAGE-MT-AGGREGATE-ACCESSOR-GENERATOR LMFS:MACROARG 'NIL)))  (EVAL-WHEN (COMPILE ZL:LOAD EVAL)    (DEFSETF TESTING-TYPE (&WHOLE LMFS:MACROARG &REST IGNORE) (LMFS:VAL)      (IF (= (ZL:LENGTH LMFS:MACROARG) 2)          (ZL:DESTRUCTURING-BIND (NIL LMFS:8ARY) LMFS:MACROARG            (ONCE-ONLY (LMFS:8ARY)              `(ZL:ASET (DPB ,LMFS:VAL (BYTE 3 1) (AREF ,LMFS:8ARY 44)) ,LMFS:8ARY 44)))          (LMFS:DEFSTORAGE-MT-AGGREGATE-STORER-GENERATOR LMFS:MACROARG LMFS:VAL 'NIL)))))(lmfs:defstorage (testing)    (foo-count  fixnum-bytes 2)    (bar-count  fixnum)    (title      char 8.)    (subtitle   char-with-length 14.)    (glubtitle  short-char-with-length 10.)    (magic      byte)    (valid      flag)    (type       bit 3)    (ignore     mod word))(testing-foo-count x) ==> (DPB (AREF X 1) (BYTE 8 8) (AREF X 0))(testing-subtitle x) ==>   (LMFS:DEFSTORAGE-RT-MAKE-STRING X 18 (DPB (AREF X 17) (BYTE 8 8) (AREF X 16)))This means that bytes 16 and 17 are combined to form a 16-bit length,and then bytes starting at byte 18 are gathered to assemble thestring, using a simple runtime function (the -RT- means runtime).(testing-glubtitle x) ==> (LMFS:DEFSTORAGE-RT-MAKE-STRING X 33 (AREF X 32))Here there's just one byte of length, which is why it's "short".Here are some real uses of the macro:;;; Structure for a directory(defstorage (dir-header)  (version	      fixnum-bytes 2)			;structure version  (size		      fixnum-bytes 2)  (name		      char-with-length 30.)  (numbers being (fixnum-bytes 2)     number-of-entries					;for scanning     free-entry-list					;for easier alloc     entries-index-offset				;to find first one     direntry-size					;for scanning     entries-per-block					;==     default-generation-retention-count     uid-path-offset     uid-path-length     hierarchy-depth)  (default-volid      fixnum)				;for creation  (auto-expunge-p     flag)  (auto-expunge-interval   date)  (auto-expunge-last-time  date)  (default-link-transparencies link-transparencies))(defstorage (file-header)  (version		fixnum)  (logical-size		fixnum-bytes 2)  (bootload-generation  fixnum)				;for validating  (version-in-bootload  fixnum)				;used in above  (number-of-elements	fixnum-bytes 2)			;for later expansion  (ignore mod word)  (* union    (parts-array array 8 fh-element)    (parts being fh-element				;and/or reformatting	   fh-header						;this header itself	   info						;header-resident info	   header-fm						;file map of header	   dire						;directory-entry-ifno	   property-list	   file-map	   pad-area						;many natures of obsolescence	   pad2-area)))(defstorage (file-map)  (allocated-length     fixnum)  (valid-length         fixnum-bytes 2)			;how many in this fragment  (link                 fixnum-bytes 2)			;next fragment address or 0  (element		array (*) fixnum))It even has the following hair:;;; Another Haarenkoenig.;;; The point of this overgeneral hair is to address the following issue.  You say,;;; "Gee, I like the way DEFSTORAGE generates ACCESSOR macros, SETF macros, and;;; even *COMPARE* macros, but for shoe-horn-trumpet-name, I wish it would generate;;; a FROBDICATE macro (something of "my" own devising) too!  So I want to tell it;;; in general, how to define FROBDICATE macros, and then using what it thus defines,;;; define FROBDICATE macros for shoe-horn-trumpet-name and whatever else I want".(defmacro defdefstorage-macro-class (class-def-name sysargs runtime-args &body body)  `(defmacro ,class-def-name (special-macro-name structure-name accessor-name)     `(defmacro ,special-macro-name ,',runtime-args	((lambda ,',sysargs	    . ,',body)	  . ,(get-defstorage-rtinfo accessor-name structure-name)))))     ----- End Forwarded Messages -----  danny*start*00574 00024 US Date: 17 Dec 87 03:44 PSTFrom: masinter.paSubject: Re: structure type specifierIn-reply-to: Robert W. Kerns <RWK@YUKON.SCRC.Symbolics.COM>'s message of Thu, 17 Dec 87 01:22 ESTTo: RWK@YUKON.SCRC.Symbolics.COMcc: Masinter.pathere's no more guarantee that for a users' random defstruct that you can reconstruct all the relevant information than there is with NUMBER.Actually, you can define NUMBER with DEFSTRUCT, using(DEFSTRUCT NUMBER)since NUMBER is abstract. Certainly RATIO and COMPLEX can be structures, which (:INCLUDE NUMBER). 