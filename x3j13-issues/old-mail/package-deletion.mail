*start*07921 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 14:00:58 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Oct 88  13:57:10 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 468864; Sat 1-Oct-88 16:55:57 EDTDate: Sat, 1 Oct 88 16:55 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: KILL-PACKAGE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <880930171700.1.KMP@GRYPHON.SCRC.Symbolics.COM>,             <881001-010107-1861@Xerox>,             <880930-152534-1216@Xerox>Message-ID: <881001165530.5.KMP@GRYPHON.SCRC.Symbolics.COM>Changes made...  Renamed KILL-PACKAGE to DELETE-PACKAGE because some implementations  use that name already. [Genera doesn't use that name but will have  to change names anyway since no one is likely to buy into PKG-KILL.]  Very minor cosmetic edits to accomodate the renaming.  Added current practice based on mail from Masinter.Changes not made ...  I left the topic name the same. Hopefully that won't confuse anyone.  Masinter suggested (privately) that this should permit a symbol   argument to designate package-name as well. I used the term  "package or package name". I'd rather have that mean whatever the  term "package name" means globally in the spec. If that includes  symbols (which is fine by me, then it should work here, too. But  we shouldn't have one function that permits symbols and a bunch  more that take only strings.-----Modified Proposal Follows-----Issue:        KILL-PACKAGEReferences:   Packages (pp171-192), PACKAGE-NAME (p184), PACKAGEP (p76)Category:     ADDITIONEdit history: 30-Sep-88, Version 1 by Pitman	      01-Oct-88, Version 2 by PitmanStatus:       For Internal DiscussionProblem Description:  There is no way to get rid of a package in Common Lisp.  This absence makes interactive development work tricky in some  implementations. If a package is accidentally built incorrectly, the  user must either rename the package to another package or start over  by reloading his program in a fresh lisp image.  Some programs need to create and destroy packages at runtime.  Without such a facility, some clumsy combination of RENAME-PACKAGE,  UNINTERN, and UNUSE-PACKAGE is usually made to work. However, it is  easy for a casual programmer to forget to undo some of the   bookkeeping, leading to unwanted effects.Proposal (KILL-PACKAGE:NEW-FUNCTION):  Introduce the function DELETE-PACKAGE, described as follows:  DELETE-PACKAGE package                                 [Function]   Deletes PACKAGE from all package system data structures. PACKAGE may   be either a package or the name of a package.   If PACKAGE names a package which does not exist, or is a package   object which has been deleted already, an error is signalled.   The name and nicknames of the designated package cease to be   recognized package names.   If the designated package is used by other packages, the effect of   UNUSE-PACKAGE is done to remove that dependency, causing its external   symbols to stop being accessible to those packages.   Any symbols in the designated package still exist after this function   is called. If their home package was not the package to be deleted, the   home package will be unchanged. If their home package was that package,   the home package after this operation is unspecified; the effect of   printing such symbols is also unspecified.   The designated package persists after this function is called.   PACKAGEP is still true of it, but PACKAGE-NAME will return NIL.   The effect of any other package operation on PACKAGE is undefined.   DELETE-PACKAGE returns T.Test Case:  (SETQ *FOO-PACKAGE* (MAKE-PACKAGE "FOO" :USE NIL))  (SETQ *FOO-SYMBOL*  (INTERN "FOO" *FOO-PACKAGE*))  (EXPORT *FOO-SYMBOL* *FOO-PACKAGE*)  (SETQ *BAR-PACKAGE* (MAKE-PACKAGE "BAR" :USE '("FOO")))  (SETQ *BAR-SYMBOL*  (INTERN "BAR" *BAR-PACKAGE*))  (EXPORT *FOO-SYMBOL* *BAR-PACKAGE*)  (EXPORT *BAR-SYMBOL* *BAR-PACKAGE*)  (SETQ *BAZ-PACKAGE* (MAKE-PACKAGE "BAZ" :USE '("BAR")))  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        => #<Package "BAR">  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       => "BAR:BAR"  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    => FOO:FOO, :EXTERNAL  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => FOO:FOO, :INHERITED  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => BAR:BAR, :INHERITED  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => "BAR"  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     => (#<Package FOO>)  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) => (#<Package BAZ>)  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()  (DELETE-PACKAGE *BAR-PACKAGE*)  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        is unspecified  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       is unspecified  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    is undefined  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => NIL, NIL  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => NIL, NIL  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => NIL  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     is undefined  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => ()  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => ()  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) is undefined  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()Rationale:  This facility corrects the deficiency described in the problem description.Current Practice:  Symbolics has a function PKG-KILL which satisfies the proposed behavior.  When a package is killed the home package of all symbols in that package  are left undisturbed (i.e., local symbols pointing to the killed package).  Procyon Common Lisp has a DELETE-PACKAGE already. It differs in that it  signals an error if the package is used by another package. Procyon  returns the name of the package so deleted (as a string). Cost to Implementors:  The cost of providing this facility is probably small.Cost to Users:  Very slight to none. This change is essentially compatible.  Some code which cached packages in variables might have to be slightly  more cautious, but experience in the Symbolics implementation suggests  that it's really the responsibility of the person doing the DELETE-PACKAGE  to take care of worrying about the effects of having deleted the package:  normal programs need not bother testing a package for validity (using  PACKAGE-NAME) before using it.Cost of Non-Adoption:  Getting rid of a package would continue to be difficult to do portably.Benefits:  Better control of storage usage would be available portably.Aesthetics:  No significant effect.Discussion:  This was discussed as part of a larger bulk issue of how to undo all  sorts of definitions. Since that proposal has not gone anywhere   (perhaps bogged down under its own weight), this subtopic has been  broken off for separate discussion.  Pitman supports this addition.*start*03196 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 18:12:56 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Oct 88  18:09:06 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 468953; Sat 1-Oct-88 21:07:31 EDTDate: Sat, 1 Oct 88 21:07 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: KILL-PACKAGE (Version 1)To: jonl@Lucid.COMcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8810020046.AA08601@bhopal>Message-ID: <881001210701.2.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Sat, 1 Oct 88 17:46:55 PDT    From: Jon L White <jonl@lucid.com>    Oh, foo, I'm afraid this will have to be called DELETE-PACKAGE.This part is already dealt with. Your message and my correctedproposal (Version 2) probably crossed in the mail.    ...    Now as to the operation of DELETE-PACKAGE, it differs from your    proposal on the matter of what to do when some other packages are    "using" the one to be deleted.  Steele says "signal an error";    Lucid Common Lisp signals a continuable error, and going on will    remove the links.  Well, your stated behavior is at least conservative. Presumably thismeans that no one has code the correct operation of which depends oncalling DELETE-PACKAGE on packages which are "in use", so making achange won't break any of those programs.I'm inclined to believe it's better to define a useful behavior herebecause - It's easy to test for that case and guard against it in the   cases that matter. - It's a pain to do the bookkeeping that is otherwise required.By the way, I kind of agree that it's a little weird to silentlyremove the package from the using package's use list, but then again,deleting a package is not something people do lightly. It turns outthat this situation happens to me on a regular basis, though, becauseI often delete a whole bunch of packages, some of which use others.In that case, I'm happy it doesn't complain about the ones that usethe others because a moment later I'm going to delete them anyway.But, of course, that's just one data point.    Although LCL signals an error if the argument isn't a package, it     silently returns NIL if the argument is an already de-registered    package.I guess we're both inconsistent on this. Probably it should eithersignal errors about all kinds of things or be tolerant about all kindsof things...    Eric Benson convinced me at one point in time that all    the the deletors should simply return NIL if they can't do their    deletory action; this includes giving it totally wrong data.    How would you feel about that approach?I'm not really opposed to it, but I'd be curious to get some viewpointsfrom people outside of Lucid and Symbolics who have no vested stake inthis and are listening to evaluating these issues for the first time.I'll think about putting out a compromise proposal based on thisdiscussion and any other feedback I get in the next day or two.*start*00629 00024 USaReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 30 SEP 88 16:07:15 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 468652; Fri 30-Sep-88 19:07:25 EDTDate: Fri, 30 Sep 88 19:07 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: KILL-PACKAGE (Version 1)To: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <880930-152534-1216@Xerox>Message-ID: <880930190705.6.KMP@GRYPHON.SCRC.Symbolics.COM>What's DELETE-PACKAGE ?*start*00749 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 SEP 88 16:09:36 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Sep 88  15:54:24 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 30 SEP 88 15:25:34 PDTDate: 30 Sep 88 15:25 PDTFrom: masinter.paSubject: Re: Issue: KILL-PACKAGE (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 30 Sep 88 17:17 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880930-152534-1216@Xerox>I'm suprised this issue makes no mention of DELETE-PACKAGE or why it won't do.*start*06588 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 SEP 88 15:12:48 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 30 Sep 88  14:19:06 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 468565; Fri 30-Sep-88 17:17:47 EDTDate: Fri, 30 Sep 88 17:17 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: KILL-PACKAGE (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880930171700.1.KMP@GRYPHON.SCRC.Symbolics.COM>Issue:        KILL-PACKAGEReferences:   Packages (pp171-192), PACKAGE-NAME (p184), PACKAGEP (p76)Category:     ADDITIONEdit history: 30-Sep-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  There is no way to kill a package in Common Lisp.  This absence makes interactive development work tricky in some  implementations. If a package is accidentally built incorrectly, the  user must either rename the package to another package or start over  by reloading his program in a fresh lisp image.  Some programs need to create and destroy packages at runtime.  Without such a facility, some clumsy combination of RENAME-PACKAGE,  UNINTERN, and UNUSE-PACKAGE is usually made to work. However, it is  easy for a casual programmer to forget to undo some of the   bookkeeping, leading to unwanted effects.Proposal (KILL-PACKAGE:NEW-FUNCTION):  Introduce the function KILL-PACKAGE, described as follows:  KILL-PACKAGE package					[Function]   Kills PACKAGE by removing it from all package system data structures.   PACKAGE may be a package or the name of a package.   If PACKAGE names a package which does not exist, or is a package   object which has been killed already, an error is signalled.   The name and nicknames of the designated package cease to be   recognized package names.   If the designated package is used by other packages, the effect of   UNUSE-PACKAGE is done to remove that dependency, causing its external   symbols to stop being accessible to those packages.   Any symbols in the designated package still exist after this function   is called. If their home package was not the package to be killed, the   home package will be unchanged. If their home package was that package,   the home package after this operation is unspecified; the effect of   printing such symbols is also unspecified.   The designated package persists after this function is called.   PACKAGEP is still true of it, but PACKAGE-NAME will return NIL.   The effect of any other package operation on PACKAGE is undefined.   KILL-PACKAGE returns T.Test Case:  (SETQ *FOO-PACKAGE* (MAKE-PACKAGE "FOO" :USE NIL))  (SETQ *FOO-SYMBOL*  (INTERN "FOO" *FOO-PACKAGE*))  (EXPORT *FOO-SYMBOL* *FOO-PACKAGE*)  (SETQ *BAR-PACKAGE* (MAKE-PACKAGE "BAR" :USE '("FOO")))  (SETQ *BAR-SYMBOL*  (INTERN "BAR" *BAR-PACKAGE*))  (EXPORT *FOO-SYMBOL* *BAR-PACKAGE*)  (EXPORT *BAR-SYMBOL* *BAR-PACKAGE*)  (SETQ *BAZ-PACKAGE* (MAKE-PACKAGE "BAZ" :USE '("BAR")))  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        => #<Package "BAR">  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       => "BAR:BAR"  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    => FOO:FOO, :EXTERNAL  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => FOO:FOO, :INHERITED  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => BAR:BAR, :INHERITED  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)	       => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => "BAR"  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     => (#<Package FOO>)  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) => (#<Package BAZ>)  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()  (KILL-PACKAGE *BAR-PACKAGE*)  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        is unspecified  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       is unspecified  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    is undefined  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => NIL, NIL  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => NIL, NIL  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)	       => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => NIL  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     is undefined  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => ()  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => ()  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) is undefined  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()Rationale:  This facility corrects the deficiency described in the problem description.Current Practice:  Symbolics has a function PKG-KILL which satisfies the proposed behavior.  When a package is killed the home package of all symbols in that package  are left undisturbed (i.e., local symbols pointing to the killed package).Cost to Implementors:  The cost of providing this facility is probably small.Cost to Users:  Very slight to none. This change is essentially compatible.  Some code which cached packages in variables might have to be slightly  more cautious, but experience in the Symbolics implementation suggests  that it's really the responsibility of the person doing the KILL-PACKAGE  to take care of worrying about the effects of having killed the package:  normal programs need not bother testing a package for validity (using  PACKAGE-NAME) before using it.Cost of Non-Adoption:  Killing a package would continue to be difficult to do portably.Benefits:  Better control of storage usage would be available portably.Aesthetics:  No significant effect.Discussion:  This was discussed as part of a larger bulk issue of how to undo all  sorts of definitions. Since that proposal has not gone anywhere   (perhaps bogged down under its own weight), this subtopic has been  broken off for separate discussion.  Pitman supports this addition.*start*00724 00024 US Date:  1 Oct 88 01:01 PDTFrom: masinter.paSubject: Re: Issue: KILL-PACKAGE (Version 1)In-reply-to: your message of Fri, 30 Sep 88 19:07 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PAooops.... XEROX-COMMON-LISP:DELETE-PACKAGE. Sorry. Procyon Common Lisp also has DELETE-PACKAGE. Maybe DELETE-PACKAGE is a better name than KILL-PACKAGE?Procyon says that it signals an error to DELETE-PACKAGE a pacakge that is used by another package. Procyon allows DELETE-PACKAGE to take a package-name: i.e., a symbol whose symbol-name is used. This would be consistent with the way things in DEFPACKAGE are going. Procyon returns the name of the package so deleted as a string.*start*02068 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 17:53:09 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 1 Oct 88  17:49:41 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01458g; Sat, 1 Oct 88 16:47:23 PSTReceived: by bhopal id AA08601g; Sat, 1 Oct 88 17:46:55 PDTDate: Sat, 1 Oct 88 17:46:55 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810020046.AA08601@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Fri, 30 Sep 88 17:17 EDT <880930171700.1.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: KILL-PACKAGE (Version 1)Oh, foo, I'm afraid this will have to be called DELETE-PACKAGE.The name DELETE-PACKAGE was reached by consensus on the common-lispmailing list around late spring 1985, and Lucid Common Lisp has had it ever since.  VAXLISP version V2.2 also uses this name.It is also one of Guy Steele's "Clarifications" from 6-Dec-85It was also on the hardcopy sheet of "possible proposals of concern to Lucid" that I handed out to members of the subcommittee present at the PaloAlto meeting earlier this year [but indeed, you weren't bodily present -- I seem to remember a telephone and speaker phone -- so maybe you didn't get a copy.]Now as to the operation of DELETE-PACKAGE, it differs from yourproposal on the matter of what to do when some other packages are"using" the one to be deleted.  Steele says "signal an error";Lucid Common Lisp signals a continuable error, and going on willremove the links.  Although LCL signals an error if the argument isn't a package, it silently returns NIL if the argument is an already de-registeredpackage.  Eric Benson convinced me at one point in time that allthe the deletors should simply return NIL if they can't do theirdeletory action; this includes giving it totally wrong data.How would you feel about that approach?-- JonL --*start*08535 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 OCT 88 15:10:58 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 4 Oct 88  15:07:01 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 470509; Tue 4-Oct-88 18:05:06 EDTDate: Tue, 4 Oct 88 18:04 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: KILL-PACKAGE (Version 3)To: JonL@Lucid.COMcc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881004180459.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Well, no one else had much to say and I had more time to think aboutthis, so I decided to try to merge your suggestions and mine. I thinkI've satisfied both our stated goals -- let me know if I have not.I changed a bunch of the details of the Proposal section to make itsignal more errors, and to specify the corrective action that happensif you continue.The changed sections are: Proposal, Test Case, and Current Practice.Procyon and Lucid Lisp guys especially should check the Current Practice.-----Issue:        KILL-PACKAGEReferences:   Packages (pp171-192), PACKAGE-NAME (p184), PACKAGEP (p76)Category:     ADDITIONEdit history: 30-Sep-88, Version 1 by Pitman	      01-Oct-88, Version 2 by Pitman	      04-Oct-88, Version 3 by Pitman		(provide for correctable errors in some cases)Status:       For Internal DiscussionProblem Description:  There is no way to get rid of a package in Common Lisp.  This absence makes interactive development work tricky in some  implementations. If a package is accidentally built incorrectly, the  user must either rename the package to another package or start over  by reloading his program in a fresh lisp image.  Some programs need to create and destroy packages at runtime.  Without such a facility, some clumsy combination of RENAME-PACKAGE,  UNINTERN, and UNUSE-PACKAGE is usually made to work. However, it is  easy for a casual programmer to forget to undo some of the   bookkeeping, leading to unwanted effects.Proposal (KILL-PACKAGE:NEW-FUNCTION):  Introduce the function DELETE-PACKAGE, described as follows:  DELETE-PACKAGE package                                 [Function]   Deletes PACKAGE from all package system data structures. PACKAGE may   be either a package or the name of a package.   If PACKAGE is a package name (i.e., not type PACKAGE) which does not   currently name a package, a correctable error is signalled. If   continued, no deletion action is attempted. Instead, DELETE-PACKAGE   immediately returns NIL.   If PACKAGE is a package object (i.e., an object of type PACKAGE)   which has already been deleted, no error is signalled and no further   deletion action is attempted. Instead, DELETE-PACKAGE immediately   returns NIL.   If the designated package is used by other packages, a correctable   error is signalled. If continued, the effect of UNUSE-PACKAGE is   done to remove any dependencies, causing its external symbols to stop   being accessible to those packages. Once this is done, DELETE-PACKAGE   goes on to delete the package as it would have if no conflict had   occurred.   The principal effect of deleting the package is that the name and   nicknames of the designated package cease to be recognized package   names.   Any symbols in the designated package still exist after this function   is called. If their home package was not the package to be deleted, the   home package will be unchanged. If their home package was that package,   the home package after this operation is unspecified; the effect of   printing such symbols is also unspecified.   The designated package persists after this function is called.   PACKAGEP is still true of it, but PACKAGE-NAME will return NIL.   The effect of any other package operation on PACKAGE once it has been   deleted is undefined.   DELETE-PACKAGE returns T (if the deletion attempt was successful).Test Case:  (SETQ *FOO-PACKAGE* (MAKE-PACKAGE "FOO" :USE NIL))  (SETQ *FOO-SYMBOL*  (INTERN "FOO" *FOO-PACKAGE*))  (EXPORT *FOO-SYMBOL* *FOO-PACKAGE*)  (SETQ *BAR-PACKAGE* (MAKE-PACKAGE "BAR" :USE '("FOO")))  (SETQ *BAR-SYMBOL*  (INTERN "BAR" *BAR-PACKAGE*))  (EXPORT *FOO-SYMBOL* *BAR-PACKAGE*)  (EXPORT *BAR-SYMBOL* *BAR-PACKAGE*)  (SETQ *BAZ-PACKAGE* (MAKE-PACKAGE "BAZ" :USE '("BAR")))  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        => #<Package "BAR">  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       => "BAR:BAR"  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    => FOO:FOO, :EXTERNAL  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => FOO:FOO, :INHERITED  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => BAR:BAR, :INHERITED  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => "BAR"  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     => (#<Package FOO>)  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) => (#<Package BAZ>)  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()  (DELETE-PACKAGE *BAR-PACKAGE*)  Error: Package BAZ uses package BAR.  If continued, BAZ will be made to unuse-package BAR,	        and then BAR will be deleted.  Type :CONTINUE to continue.  Debug> :CONTINUE  				       => T  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        is unspecified  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       is unspecified  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    is undefined  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => NIL, NIL  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => NIL, NIL  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => NIL  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     is undefined  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => ()  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => ()  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) is undefined  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()Rationale:  This facility corrects the deficiency described in the problem description.Current Practice:  Symbolics has a function PKG-KILL which satisfies the proposed behavior  except that an error is not signalled if the package is used.  When a package is killed by PKG-KILL, the home package of all symbols  in that package are left undisturbed (i.e., local symbols pointing to  the killed package); this aspect is compatible with the stated proposal.  Procyon Common Lisp has a DELETE-PACKAGE already. It returns the name  of the package so deleted (as a string). [Perhaps it also differs in the  correctability of the errors it signals? -kmp]   Lucid Common Lisp provides DELETE-PACKAGE but the argument must be a  package object.Cost to Implementors:  The cost of providing this facility is probably small.Cost to Users:  Very slight to none. This change is essentially compatible.  Some code which cached packages in variables might have to be slightly  more cautious, but experience in the Symbolics implementation suggests  that it's really the responsibility of the person doing the DELETE-PACKAGE  to take care of worrying about the effects of having deleted the package:  normal programs need not bother testing a package for validity (using  PACKAGE-NAME) before using it.Cost of Non-Adoption:  Getting rid of a package would continue to be difficult to do portably.Benefits:  Better control of storage usage would be available portably.Aesthetics:  No significant effect.Discussion:  This was discussed as part of a larger bulk issue of how to undo all  sorts of definitions. Since that proposal has not gone anywhere   (perhaps bogged down under its own weight), this subtopic has been  broken off for separate discussion.  Pitman supports this addition.*start*01187 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 OCT 88 15:39:07 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 3 Oct 88  15:38:53 PDTReceived: by ti.com id AA25603; Mon, 3 Oct 88 17:34:26 CDTReceived: from Kelvin by tilde id AA11917; Mon, 3 Oct 88 17:16:38 CDTMessage-Id: <2800909048-11342747@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 3 Oct 88 17:17:28 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: KILL-PACKAGE (Version 2)In-Reply-To: Msg of Sat, 1 Oct 88 16:55 EDT from Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>> Proposal (KILL-PACKAGE:NEW-FUNCTION):> >   Introduce the function DELETE-PACKAGE, described as follows:...> Current Practice:The Explorer has both a DELETE-PACKAGE and a KILL-PACKAGE function.KILL-PACKAGE appears to conform to this proposal except that it returnsNIL instead of T.  DELETE-PACKAGE differs by signaling an error when thepackage is used by another package, and by uninterning all of thesymbols.*start*00855 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 OCT 88 14:19:31 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 4 Oct 88  14:18:58 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 470470; Tue 4-Oct-88 17:17:31 EDTDate: Tue, 4 Oct 88 17:17 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: KILL-PACKAGE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881001165530.5.KMP@GRYPHON.SCRC.Symbolics.COM>Message-ID: <19881004211714.4.MOON@EUPHRATES.SCRC.Symbolics.COM>KILL-PACKAGE:NEW-FUNCTION is fine with me, either as proposedor with JonL's suggested modifications.*start*04025 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 17:25:36 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 5 Oct 88  17:25:23 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03192g; Wed, 5 Oct 88 16:22:56 PSTReceived: by bhopal id AA02227g; Wed, 5 Oct 88 17:22:31 PDTDate: Wed, 5 Oct 88 17:22:31 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810060022.AA02227@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Tue, 4 Oct 88 18:04 EDT <881004180459.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: KILL-PACKAGE (Version 3)re: Current Practice:      . . .        Lucid Common Lisp provides DELETE-PACKAGE but the argument must be a      package object.Nope.  It works with "packages" exactly as the rest of this proposal says.re:  Proposal (KILL-PACKAGE:NEW-FUNCTION):      Introduce the function DELETE-PACKAGE, described as follows:      DELETE-PACKAGE package                                 [Function]       Deletes PACKAGE from all package system data structures. PACKAGE may       be either a package or the name of a package.       If PACKAGE is a package name (i.e., not type PACKAGE) which does not       currently name a package, a correctable error is signalled. If       continued, no deletion action is attempted. Instead, DELETE-PACKAGE       immediately returns NIL.Although this is the current Lucid practice, EB and I prefer to justreturn NIL here.  We must consider that DELETE-PACKAGE is only thetip of the iceberg for retracting global data structures.  There reallyneeds to be a DELETE-DEFSTRUCT and DELETE-DEFTYPE too.  So whatever isdone for the error semantics of one of these ought to be consistentfor all three.       If PACKAGE is a package object (i.e., an object of type PACKAGE)       which has already been deleted, no error is signalled and no further       deletion action is attempted. Instead, DELETE-PACKAGE immediately       returns NIL.       If the designated package is used by other packages, a correctable       error is signalled. If continued, the effect of UNUSE-PACKAGE is       done to remove any dependencies, causing its external symbols to stop       being accessible to those packages. Once this is done, DELETE-PACKAGE       goes on to delete the package as it would have if no conflict had       occurred.I wouldn't use the word "conflict" here, since it has a technical meaningin the context of packages (CLtL p178) that is somewhat counter to itsuse here.       The principal effect of deleting the package is that the name and       nicknames of the designated package cease to be recognized package       names.       Any symbols in the designated package still exist after this function       is called. If their home package was not the package to be deleted, the       home package will be unchanged. If their home package was that package,       the home package after this operation is unspecified; the effect of       printing such symbols is also unspecified.The phrase "still exist" seems odd to me.  Perhaps a better way to say itis that the symbols entered in a package are not modified except possiblyfor the symbol-package slot of those homed in that package.       The designated package persists after this function is called.       PACKAGEP is still true of it, but PACKAGE-NAME will return NIL.       The effect of any other package operation on PACKAGE once it has been       deleted is undefined.Again, the word "persists" is confusing to me.  What else could it do?automatically, self-GC?  A single sentence encapsulating what you aretrying to say here could go into the above paragraph: "The principaleffect ...".       DELETE-PACKAGE returns T (if the deletion attempt was successful).and NIL otherwise?-- JonL --*start*08397 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 17:02:54 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  17:02:22 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00876g; Fri, 7 Oct 88 17:01:07 PDTReceived: by bhopal id AA02168g; Fri, 7 Oct 88 16:59:28 PDTDate: Fri, 7 Oct 88 16:59:28 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810072359.AA02168@bhopal>To: CL-Cleanup@SAIL.Stanford.EDUSubject: Issue: PACKAGE-DELETION (Version 4)I've added the minor corrections from my note of Wed, 5 Oct 88 17:22:31 PDT,and changed the Issue name to conform with "cleanup" standards.  I alsodeleted the "testimonial" (as per Larry's suggestion) since this seems tobe a non-controversial issue.!Issue:        PACKAGE-DELETIONReferences:   Packages (pp171-192), PACKAGE-NAME (p184), PACKAGEP (p76)Category:     ADDITIONEdit history: 30-Sep-88, Version 1 by Pitman	      01-Oct-88, Version 2 by Pitman	      04-Oct-88, Version 3 by Pitman		(provide for correctable errors in some cases)	      07-Oct-88, Version 4 by JonLStatus:       Ready?Problem Description:  There is no way to get rid of a package in Common Lisp.  This absence makes interactive development work tricky in some  implementations. If a package is accidentally built incorrectly, the  user must either rename the package to another package or start over  by reloading his program in a fresh lisp image.  Some programs need to create and destroy packages at runtime.  Without such a facility, some clumsy combination of RENAME-PACKAGE,  UNINTERN, and UNUSE-PACKAGE is usually made to work. However, it is  easy for a casual programmer to forget to undo some of the   bookkeeping, leading to unwanted effects.Proposal (PACKAGE-DELETION:NEW-FUNCTION):  Introduce the function DELETE-PACKAGE, described as follows:  DELETE-PACKAGE package                                 [Function]   Deletes PACKAGE from all package system data structures. PACKAGE may   be either a package or the name of a package.   If PACKAGE is a package name (i.e., not type PACKAGE) which does not   currently name a package, a correctable error is signalled. If   continued, no deletion action is attempted. Instead, DELETE-PACKAGE   immediately returns NIL.   If PACKAGE is a package object (i.e., an object of type PACKAGE)   which has already been deleted, no error is signalled and no further   deletion action is attempted. Instead, DELETE-PACKAGE immediately   returns NIL.   If the designated package is used by other packages, a correctable   error is signalled. If continued, the effect of UNUSE-PACKAGE is   done to remove any dependencies, causing its external symbols to stop   being accessible to those packages. Once this is done, DELETE-PACKAGE   goes on to delete the package just as it would had there been no    packages on the use list.   After this operation completes, the contents of the symbol-package     slot of any symbol homed in the deleted package is unspecified; for    those symbols not homed in that package, the contents remain unchanged.   Except for this, symbols in the deleted package are not modified in   any other way.     The principal effect of deleting the package is that the name and   nicknames of the designated package cease to be recognized package   names.  The package object is still a package -- PACKAGEP is true   of it -- but  PACKAGE-NAME will return NIL.  The effect of any other    package operation on PACKAGE once it has been deleted is undefined.   DELETE-PACKAGE returns T if the deletion attempt was successful   and NIL otherwise.Test Case:  (SETQ *FOO-PACKAGE* (MAKE-PACKAGE "FOO" :USE NIL))  (SETQ *FOO-SYMBOL*  (INTERN "FOO" *FOO-PACKAGE*))  (EXPORT *FOO-SYMBOL* *FOO-PACKAGE*)  (SETQ *BAR-PACKAGE* (MAKE-PACKAGE "BAR" :USE '("FOO")))  (SETQ *BAR-SYMBOL*  (INTERN "BAR" *BAR-PACKAGE*))  (EXPORT *FOO-SYMBOL* *BAR-PACKAGE*)  (EXPORT *BAR-SYMBOL* *BAR-PACKAGE*)  (SETQ *BAZ-PACKAGE* (MAKE-PACKAGE "BAZ" :USE '("BAR")))  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        => #<Package "BAR">  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       => "BAR:BAR"  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    => FOO:FOO, :EXTERNAL  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => FOO:FOO, :INHERITED  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => BAR:BAR, :INHERITED  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => "BAR"  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     => (#<Package FOO>)  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) => (#<Package BAZ>)  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()  (DELETE-PACKAGE *BAR-PACKAGE*)  Error: Package BAZ uses package BAR.  If continued, BAZ will be made to unuse-package BAR,	        and then BAR will be deleted.  Type :CONTINUE to continue.  Debug> :CONTINUE  				       => T  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        is unspecified  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       is unspecified  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    is undefined  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => NIL, NIL  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => NIL, NIL  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => NIL  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     is undefined  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => ()  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => ()  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) is undefined  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()Rationale:  This facility corrects the deficiency described in the problem description.Current Practice:  Symbolics has a function PKG-KILL which satisfies the proposed behavior  except that an error is not signalled if the package is used.  When a package is killed by PKG-KILL, the home package of all symbols  in that package are left undisturbed (i.e., local symbols pointing to  the killed package); this aspect is compatible with the stated proposal.  Procyon Common Lisp has a DELETE-PACKAGE already. It returns the name  of the package so deleted (as a string). [Perhaps it also differs in the  correctability of the errors it signals? -kmp]  Lucid Common Lisp implements DELETE-PACKAGE, except that the continuation  option for a name that doesn't name a package is different.Cost to Implementors:  The cost of providing this facility is probably small.Cost to Users:  Very slight to none. This change is essentially compatible.  Some code which cached packages in variables might have to be slightly  more cautious, but experience in the Symbolics implementation suggests  that it's really the responsibility of the person doing the DELETE-PACKAGE  to take care of worrying about the effects of having deleted the package:  normal programs need not bother testing a package for validity (using  PACKAGE-NAME) before using it.Cost of Non-Adoption:  Getting rid of a package would continue to be difficult to do portably.Benefits:  Better control of storage usage would be available portably.Aesthetics:  No significant effect.Discussion:  This was discussed as part of a larger bulk issue of how to undo all  sorts of definitions. Since that proposal has not gone anywhere   (perhaps bogged down under its own weight), this subtopic has been  broken off for separate discussion.  Note that if a symbol's package component is modified as a result  of being "unintern'd" from a delete packaged, then it is unspecified  as to how it will  be printed.*start*02601 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 17:38:11 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  17:38:13 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472916; Fri 7-Oct-88 20:36:21 EDTDate: Fri, 7 Oct 88 20:36 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-DELETION (Version 4)To: jonl@lucid.comcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8810072359.AA02168@bhopal>Message-ID: <881007203609.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Grumble.For the record, I don't really think that (DELETE-PACKAGE no-such-name)should be treated the same as (DELETE-PACKAGE unregistered-package)In the former case, it is not clear what package you are referringto, so it's not clear which of several bugs you have: - The package name might have been mis-spelled. - The package might have been supposed to exist, but was never loaded/created. - The package might have already been deleted.In the latter case, there's only one possibility: - The package might have already been deleted.In the case where you're sure you are referring to the correct packageand all you're trying to say is "There is no doubt about the identityof the package to which I am referring. I would that unambiguously namedpackage to be inaccessible.", I have no problem about this returning NIL.In the other case, where any of a number of bugs could have happened,I'm more comfortable with an error being signalled -- partly for consistencywith your insistance that this function should signal an error ratherthan define a useful behavior in the other questionable case: packagealready in use. If that didn't cause an error to be signalled, then Iwould also not mind quietly returning NIL for the deletion of a packagewhich does not exist.I also deliberately did not say that delete package returns T if thedeletion is successful "and otherwise returns NIL" since sometimes itdoes not return at all. The usage "and otherwise ..." always impliesand exhaustive case analysis in my mind. The specific cases where NILare returned are already cited. I would prefer to just say it returns Tif it was successful and let anyone search the other cases, or elsesay something very clumsy like "If DELETE-PACKAGE returns normally,the value returned is T if the deletion was successful and NIL otherwise."*start*01543 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 20:41:23 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  20:41:09 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01120g; Fri, 7 Oct 88 19:20:57 PDTReceived: by bhopal id AA02759g; Fri, 7 Oct 88 19:19:18 PDTDate: Fri, 7 Oct 88 19:19:18 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080219.AA02759@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Fri, 7 Oct 88 20:36 EDT <881007203609.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-DELETION (Version 4)re: Grumble.    For the record, I don't really think that     (DELETE-PACKAGE no-such-name)    should be treated the same as     (DELETE-PACKAGE unregistered-package)Kent, I didn't change any of that.  I know, my msg said "added the minor corrections"; but I didn't take altering the semantics of DELETE-PACKAGE to be a "minor" correction, so I didn't do it.  Could you double check tobe sure that you didn't misread something?re: I also deliberately did not say that delete package returns T if the    deletion is successful "and otherwise returns NIL" since sometimes it    does not return at all. Is this really worth belaboring?  You do have to say what it returnsin the case when you call it on an already deleted package.-- JonL -- *start*01144 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 19:01:15 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 8 Oct 88  18:43:09 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 473416; Sat 8-Oct-88 21:41:38 EDTDate: Sat, 8 Oct 88 21:41 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-DELETION (Version 4)To: JonL@Lucid.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8810080219.AA02759@bhopal>Supersedes: <881008214054.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <881008214120.3.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri, 7 Oct 88 19:19:18 PDT    From: Jon L White <jonl@lucid.com>    Could you double check to be sure that you didn't misread something?    ...You're right. I misread this part. Sorry for doubting you.I won't belabor the style point now. Everyone's got too much to read already.*start*00924 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:58:27 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:58:39 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA22334; Thu, 13 Oct 88 15:57:02 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19925; Thu, 13 Oct 88 15:56:59 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132156.AA19925@defun.utah.edu>Date: Thu, 13 Oct 88 15:56:57 MDTSubject: issue PACKAGE-DELETIONTo: cl-cleanup@sail.stanford.eduAbout the only complaint I have with this proposal is that I think itought to explicitly state whether the processing on the symbols in thepackage is the same as uninterning them all.  It sounds kind of like itis but I might have missed something.-Sandra-------*start*00779 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:07:29 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:51:08 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476076; Thu 13-Oct-88 18:49:45 EDTDate: Thu, 13 Oct 88 18:49 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-DELETION (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013184936.7.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: We felt this was ready for vote.*start*08785 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 NOV 88 17:25:56 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Nov 88  17:23:59 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 21 NOV 88 17:19:10 PSTDate: 21 Nov 88 17:18 PSTFrom: masinter.paTo: CL-Cleanup@SAIL.Stanford.EDUSubject: Issue: PACKAGE-DELETION (Version 5)Line-fold: NOMessage-ID: <881121-171910-8795@Xerox>I attempted to clarify that FIND-PACKAGE and INTERN have unspecifiedresults if handed a deleted-package object.There was I think a mistake in the description of what happens ifother packages use the one being deleted, since it said something aboutthere being no other packages on the use list, but generally, if there isa "use list" at all , it points to packages that are used rather than packagesthat use the given one.Can anyone supply a sample implementation of DELETE-PACKAGE?!Forum:	CleanupIssue:        PACKAGE-DELETIONReferences:   Packages (pp171-192), PACKAGE-NAME (p184), PACKAGEP (p76)Category:     ADDITIONEdit history: 30-Sep-88, Version 1 by Pitman	      01-Oct-88, Version 2 by Pitman	      04-Oct-88, Version 3 by Pitman		(provide for correctable errors in some cases)	      07-Oct-88, Version 4 by JonL		21-Nov-88, Version 5 by MasinterProblem Description:  There is no way to get rid of a package in Common Lisp.  This absence makes interactive development work tricky in some  implementations. If a package is accidentally built incorrectly, the  user must either rename the package to another package or start over  by reloading his program in a fresh lisp image.  Some programs need to create and destroy packages at runtime.  Without such a facility, some clumsy combination of RENAME-PACKAGE,  UNINTERN, and UNUSE-PACKAGE is usually made to work. However, it is  easy for a casual programmer to forget to undo some of the   bookkeeping, leading to unwanted effects.Proposal (PACKAGE-DELETION:NEW-FUNCTION):  Introduce the function DELETE-PACKAGE, described as follows:  DELETE-PACKAGE package                                 [Function]   Deletes PACKAGE from all package system data structures. PACKAGE may   be either a package or the name of a package.   If PACKAGE is a package name (i.e., not type PACKAGE) which does not   currently name a package, a correctable error is signalled. If   continued, no deletion action is attempted. Instead, DELETE-PACKAGE   immediately returns NIL.   If PACKAGE is a package object (i.e., an object of type PACKAGE)   which has already been deleted, no error is signalled and no further   deletion action is attempted. Instead, DELETE-PACKAGE immediately   returns NIL.   If the designated package is used by other packages, a correctable   error is signalled. If continued, the effect of UNUSE-PACKAGE is   done to remove any dependencies, causing its external symbols to stop   being accessible to those packages. Once this is done, DELETE-PACKAGE   goes on to delete the package just as it would had there been no    packages that used it.   After this operation completes, the contents of the symbol-package     slot of any symbol homed in the deleted package is unspecified; for    those symbols not homed in that package, the contents remain unchanged.   Except for this, symbols in the deleted package are not modified in   any other way.     The effect of DELETE-PACKAGE is that the name and   nicknames of the designated package cease to be recognized package   names.   The package object is still a package -- PACKAGEP is true   of it -- but  PACKAGE-NAME will return NIL.  The effect of any other    package operation on PACKAGE once it has been deleted is undefined.   In particular, FIND-SYMBOL, INTERN and other functions that  look for a symbol name in a package will have unspecified results if  called with *PACKAGE* bound to the deleted package or with the  deleted package as an argument.   DELETE-PACKAGE returns T if the deletion attempt was successful   and NIL otherwise.Test Case:  (SETQ *FOO-PACKAGE* (MAKE-PACKAGE "FOO" :USE NIL))  (SETQ *FOO-SYMBOL*  (INTERN "FOO" *FOO-PACKAGE*))  (EXPORT *FOO-SYMBOL* *FOO-PACKAGE*)  (SETQ *BAR-PACKAGE* (MAKE-PACKAGE "BAR" :USE '("FOO")))  (SETQ *BAR-SYMBOL*  (INTERN "BAR" *BAR-PACKAGE*))  (EXPORT *FOO-SYMBOL* *BAR-PACKAGE*)  (EXPORT *BAR-SYMBOL* *BAR-PACKAGE*)  (SETQ *BAZ-PACKAGE* (MAKE-PACKAGE "BAZ" :USE '("BAR")))  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        => #<Package "BAR">  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       => "BAR:BAR"  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    => FOO:FOO, :EXTERNAL  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => FOO:FOO, :INHERITED  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => BAR:BAR, :INHERITED  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => "BAR"  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     => (#<Package FOO>)  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) => (#<Package BAZ>)  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()  (DELETE-PACKAGE *BAR-PACKAGE*)  Error: Package BAZ uses package BAR.  If continued, BAZ will be made to unuse-package BAR,	        and then BAR will be deleted.  Type :CONTINUE to continue.  Debug> :CONTINUE  				       => T  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        is unspecified  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       is unspecified  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    is undefined  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => NIL, NIL  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => NIL, NIL  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => NIL  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     is undefined  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => ()  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => ()  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) is undefined  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()Rationale:  This facility corrects the deficiency described in the problem description.Current Practice:  Symbolics has a function PKG-KILL which satisfies the proposed behavior  except that an error is not signalled if the package is used.  When a package is killed by PKG-KILL, the home package of all symbols  in that package are left undisturbed (i.e., local symbols pointing to  the killed package); this aspect is compatible with the stated proposal.  Procyon Common Lisp has a function called DELETE-PACKAGE already. It  returns the name   of the package so deleted (as a string). [Perhaps it also  differs in the correctability of the errors it signals?]  Lucid Common Lisp implements DELETE-PACKAGE, except that the continuation  option for a name that doesn't name a package is different.Cost to Implementors:  The cost of providing this facility is probably small.Cost to Users:  Very slight to none. This change is essentially compatible.  Some code which cached packages in variables might have to be slightly  more cautious, but experience in the Symbolics implementation suggests  that it's really the responsibility of the person doing the DELETE-PACKAGE  to take care of worrying about the effects of having deleted the package:  normal programs need not bother testing a package for validity (using  PACKAGE-NAME) before using it.Cost of Non-Adoption:  Getting rid of a package would continue to be difficult to do portably.Benefits:  Better control of storage usage would be available portably.Aesthetics:  No significant effect.Discussion:  This was discussed as part of a larger bulk issue of how to undo all  sorts of definitions. Since that proposal has not gone anywhere   (perhaps bogged down under its own weight), this subtopic has been  broken off for separate discussion.  Note that if a symbol's package component is modified as a result  of being "unintern'd" from a delete packaged, then it is unspecified  as to how it will  be printed.*start*01193 00024 USaReturn-Path: <HAUG@ERDOS.csc.ti.com>Received: from ti.com ([10.7.0.46]) by Xerox.COM ; 30 NOV 88 06:04:20 PSTReceived: by ti.com id AA21691; Wed, 30 Nov 88 08:04:26 CSTReceived: from ERDOS by tilde id AA15864; Wed, 30 Nov 88 08:01:03 CSTMessage-Id: <2805890424-12473816@ERDOS>Date: Wed, 30 Nov 88 08:00:24 CSTFrom: HAUG@ERDOS.csc.ti.comTo: masinter.paSubject: Re: Issue: PACKAGE-DELETION (Version 5)In-Reply-To: Msg of 21 Nov 88 17:18 PST from masinter.pa@Xerox.COM Larry,    This is the version of delete-package used on the Explorer andwritten by myself: (Defun DELETE-PACKAGE(pkg)  "Kills a package object and uninterns all symbols present in the package.It is illegal to delete a package when it is used by another so one must removesuch dependencies before proceeding."  (LET* ((pkg (FIND-PACKAGE pkg))	 (used-by-list (PACKAGE-USED-BY-LIST pkg)))    (WHEN used-by-list      (ERROR t "~s cannot be deleted since it is used by ~s~%" pkg used-by-list))    (SETF (PACK-SHADOWING-SYMBOLS pkg) nil)  ;; prevent UNINTERN from looking for name conflicts    (DO-LOCAL-SYMBOLS (var pkg) (UNINTERN var pkg))    (KILL-PACKAGE pkg)))  -- Dave Haug*start*00386 00024 US Date:  8 Dec 88 20:37 PSTFrom: masinter.paSubject: Re: Issue: PACKAGE-DELETION (Version 5)In-reply-to: your message of Wed, 30 Nov 88 08:00:24 CSTTo: HAUG@ERDOS.csc.ti.comcc: masinter.paYour version of DELETE-PACKAGE calls KILL-PACKAGE which itself is not in Common Lisp. It looks like KILL-PACKAGE does a lot, e.g., removes the package name, etc., no?*start*08373 00024 US Date:  8 Dec 88 20:40 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: PACKAGE-DELETION (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noForum:	CleanupIssue:        PACKAGE-DELETIONReferences:   Packages (pp171-192), PACKAGE-NAME (p184), PACKAGEP (p76)Category:     ADDITIONEdit history: 30-Sep-88, Version 1 by Pitman	      01-Oct-88, Version 2 by Pitman	      04-Oct-88, Version 3 by Pitman		(provide for correctable errors in some cases)	      07-Oct-88, Version 4 by JonL		21-Nov-88, Version 5 by MasinterProblem Description:  There is no way to get rid of a package in Common Lisp.  This absence makes interactive development work tricky in some  implementations. If a package is accidentally built incorrectly, the  user must either rename the package to another package or start over  by reloading his program in a fresh lisp image.  Some programs need to create and destroy packages at runtime.  Without such a facility, some clumsy combination of RENAME-PACKAGE,  UNINTERN, and UNUSE-PACKAGE is usually made to work. However, it is  easy for a casual programmer to forget to undo some of the   bookkeeping, leading to unwanted effects.Proposal (PACKAGE-DELETION:NEW-FUNCTION):  Introduce the function DELETE-PACKAGE, described as follows:  DELETE-PACKAGE package                                 [Function]   Deletes PACKAGE from all package system data structures. PACKAGE may   be either a package or the name of a package.   If PACKAGE is a package name (i.e., not type PACKAGE) which does not   currently name a package, a correctable error is signalled. If   continued, no deletion action is attempted. Instead, DELETE-PACKAGE   immediately returns NIL.   If PACKAGE is a package object (i.e., an object of type PACKAGE)   which has already been deleted, no error is signalled and no further   deletion action is attempted. Instead, DELETE-PACKAGE immediately   returns NIL.   If the designated package is used by other packages, a correctable   error is signalled. If continued, the effect of UNUSE-PACKAGE is   done to remove any dependencies, causing its external symbols to stop   being accessible to those packages. Once this is done, DELETE-PACKAGE   goes on to delete the package just as it would had there been no    packages that used it.   After this operation completes, the contents of the symbol-package     slot of any symbol homed in the deleted package is unspecified; for    those symbols not homed in that package, the contents remain unchanged.   Except for this, symbols in the deleted package are not modified in   any other way.     The effect of DELETE-PACKAGE is that the name and   nicknames of the designated package cease to be recognized package   names.   The package object is still a package -- PACKAGEP is true   of it -- but  PACKAGE-NAME will return NIL.  The effect of any other    package operation on PACKAGE once it has been deleted is undefined.   In particular, FIND-SYMBOL, INTERN and other functions that  look for a symbol name in a package will have unspecified results if  called with *PACKAGE* bound to the deleted package or with the  deleted package as an argument.   DELETE-PACKAGE returns T if the deletion attempt was successful   and NIL otherwise.Examples:  (SETQ *FOO-PACKAGE* (MAKE-PACKAGE "FOO" :USE NIL))  (SETQ *FOO-SYMBOL*  (INTERN "FOO" *FOO-PACKAGE*))  (EXPORT *FOO-SYMBOL* *FOO-PACKAGE*)  (SETQ *BAR-PACKAGE* (MAKE-PACKAGE "BAR" :USE '("FOO")))  (SETQ *BAR-SYMBOL*  (INTERN "BAR" *BAR-PACKAGE*))  (EXPORT *FOO-SYMBOL* *BAR-PACKAGE*)  (EXPORT *BAR-SYMBOL* *BAR-PACKAGE*)  (SETQ *BAZ-PACKAGE* (MAKE-PACKAGE "BAZ" :USE '("BAR")))  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        => #<Package "BAR">  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       => "BAR:BAR"  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    => FOO:FOO, :EXTERNAL  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => FOO:FOO, :INHERITED  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => BAR:BAR, :INHERITED  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => "BAR"  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     => (#<Package FOO>)  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) => (#<Package BAZ>)  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()  (DELETE-PACKAGE *BAR-PACKAGE*)  Error: Package BAZ uses package BAR.  If continued, BAZ will be made to unuse-package BAR,	        and then BAR will be deleted.  Type :CONTINUE to continue.  Debug> :CONTINUE  				       => T  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        is unspecified  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       is unspecified  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    is undefined  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => NIL, NIL  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => NIL, NIL  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => NIL  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     is undefined  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => ()  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => ()  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) is undefined  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()Rationale:  This facility corrects the deficiency described in the problem description.Current Practice:  Symbolics has a function PKG-KILL which satisfies the proposed behavior  except that an error is not signalled if the package is used.  When a package is killed by PKG-KILL, the home package of all symbols  in that package are left undisturbed (i.e., local symbols pointing to  the killed package); this aspect is compatible with the stated proposal.  Procyon Common Lisp has a function called DELETE-PACKAGE already. It  returns the name   of the package so deleted (as a string). [Perhaps it also  differs in the correctability of the errors it signals?]  Lucid Common Lisp implements DELETE-PACKAGE, except that the continuation  option for a name that doesn't name a package is different.Cost to Implementors:  The cost of providing this facility is probably small.Cost to Users:  Very slight to none. This change is essentially compatible.  Some code which cached packages in variables might have to be slightly  more cautious, but experience in the Symbolics implementation suggests  that it's really the responsibility of the person doing the DELETE-PACKAGE  to take care of worrying about the effects of having deleted the package:  normal programs need not bother testing a package for validity (using  PACKAGE-NAME) before using it.Cost of Non-Adoption:  Getting rid of a package would continue to be difficult to do portably.Benefits:  Better control of storage usage would be available portably.Aesthetics:  No significant effect.Discussion:  This was discussed as part of a larger bulk issue of how to undo all  sorts of definitions. Since that proposal has not gone anywhere   (perhaps bogged down under its own weight), this subtopic has been  broken off for separate discussion.  Note that if a symbol's package component is modified as a result  of being "unintern'd" from a delete packaged, then it is unspecified  as to how it will  be printed.        TITAN 
         TITAN 
           Z              }                                   :              	                           u       *             
      
              P                           ;                           L       
       A                                 5 "z*start*08336 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 21:06:26 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  20:41:45 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 DEC 88 20:40:59 PSTDate: 8 Dec 88 20:40 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: PACKAGE-DELETION (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881208-204059-5304@Xerox>!Forum:	CleanupIssue:        PACKAGE-DELETIONReferences:   Packages (pp171-192), PACKAGE-NAME (p184), PACKAGEP (p76)Category:     ADDITIONEdit history: 30-Sep-88, Version 1 by Pitman	      01-Oct-88, Version 2 by Pitman	      04-Oct-88, Version 3 by Pitman		(provide for correctable errors in some cases)	      07-Oct-88, Version 4 by JonL		21-Nov-88, Version 5 by MasinterProblem Description:  There is no way to get rid of a package in Common Lisp.  This absence makes interactive development work tricky in some  implementations. If a package is accidentally built incorrectly, the  user must either rename the package to another package or start over  by reloading his program in a fresh lisp image.  Some programs need to create and destroy packages at runtime.  Without such a facility, some clumsy combination of RENAME-PACKAGE,  UNINTERN, and UNUSE-PACKAGE is usually made to work. However, it is  easy for a casual programmer to forget to undo some of the   bookkeeping, leading to unwanted effects.Proposal (PACKAGE-DELETION:NEW-FUNCTION):  Introduce the function DELETE-PACKAGE, described as follows:  DELETE-PACKAGE package                                 [Function]   Deletes PACKAGE from all package system data structures. PACKAGE may   be either a package or the name of a package.   If PACKAGE is a package name (i.e., not type PACKAGE) which does not   currently name a package, a correctable error is signalled. If   continued, no deletion action is attempted. Instead, DELETE-PACKAGE   immediately returns NIL.   If PACKAGE is a package object (i.e., an object of type PACKAGE)   which has already been deleted, no error is signalled and no further   deletion action is attempted. Instead, DELETE-PACKAGE immediately   returns NIL.   If the designated package is used by other packages, a correctable   error is signalled. If continued, the effect of UNUSE-PACKAGE is   done to remove any dependencies, causing its external symbols to stop   being accessible to those packages. Once this is done, DELETE-PACKAGE   goes on to delete the package just as it would had there been no    packages that used it.   After this operation completes, the contents of the symbol-package     slot of any symbol homed in the deleted package is unspecified; for    those symbols not homed in that package, the contents remain unchanged.   Except for this, symbols in the deleted package are not modified in   any other way.     The effect of DELETE-PACKAGE is that the name and   nicknames of the designated package cease to be recognized package   names.   The package object is still a package -- PACKAGEP is true   of it -- but  PACKAGE-NAME will return NIL.  The effect of any other    package operation on PACKAGE once it has been deleted is undefined.   In particular, FIND-SYMBOL, INTERN and other functions that  look for a symbol name in a package will have unspecified results if  called with *PACKAGE* bound to the deleted package or with the  deleted package as an argument.   DELETE-PACKAGE returns T if the deletion attempt was successful   and NIL otherwise.Examples:  (SETQ *FOO-PACKAGE* (MAKE-PACKAGE "FOO" :USE NIL))  (SETQ *FOO-SYMBOL*  (INTERN "FOO" *FOO-PACKAGE*))  (EXPORT *FOO-SYMBOL* *FOO-PACKAGE*)  (SETQ *BAR-PACKAGE* (MAKE-PACKAGE "BAR" :USE '("FOO")))  (SETQ *BAR-SYMBOL*  (INTERN "BAR" *BAR-PACKAGE*))  (EXPORT *FOO-SYMBOL* *BAR-PACKAGE*)  (EXPORT *BAR-SYMBOL* *BAR-PACKAGE*)  (SETQ *BAZ-PACKAGE* (MAKE-PACKAGE "BAZ" :USE '("BAR")))  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        => #<Package "BAR">  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       => "BAR:BAR"  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    => FOO:FOO, :EXTERNAL  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => FOO:FOO, :INHERITED  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => BAR:BAR, :INHERITED  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => "BAR"  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     => (#<Package FOO>)  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => (#<Package BAR>)  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) => (#<Package BAZ>)  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()  (DELETE-PACKAGE *BAR-PACKAGE*)  Error: Package BAZ uses package BAR.  If continued, BAZ will be made to unuse-package BAR,	        and then BAR will be deleted.  Type :CONTINUE to continue.  Debug> :CONTINUE  				       => T  (SYMBOL-PACKAGE *FOO-SYMBOL*)        => #<Package "FOO">  (SYMBOL-PACKAGE *BAR-SYMBOL*)        is unspecified  (PRIN1-TO-STRING *FOO-SYMBOL*)       => "FOO:FOO"  (PRIN1-TO-STRING *BAR-SYMBOL*)       is unspecified  (FIND-SYMBOL "FOO" *BAR-PACKAGE*)    is undefined  (FIND-SYMBOL "FOO" *BAZ-PACKAGE*)    => NIL, NIL  (FIND-SYMBOL "BAR" *BAZ-PACKAGE*)    => NIL, NIL  (PACKAGEP *FOO-PACKAGE*)             => T  (PACKAGEP *BAR-PACKAGE*)             => T  (PACKAGEP *BAZ-PACKAGE*)             => T  (PACKAGE-NAME *FOO-PACKAGE*)         => "FOO"  (PACKAGE-NAME *BAR-PACKAGE*)         => NIL  (PACKAGE-NAME *BAZ-PACKAGE*)         => "BAZ"  (PACKAGE-USE-LIST *FOO-PACKAGE*)     => ()  (PACKAGE-USE-LIST *BAR-PACKAGE*)     is undefined  (PACKAGE-USE-LIST *BAZ-PACKAGE*)     => ()  (PACKAGE-USED-BY-LIST *FOO-PACKAGE*) => ()  (PACKAGE-USED-BY-LIST *BAR-PACKAGE*) is undefined  (PACKAGE-USED-BY-LIST *BAZ-PACKAGE*) => ()Rationale:  This facility corrects the deficiency described in the problem description.Current Practice:  Symbolics has a function PKG-KILL which satisfies the proposed behavior  except that an error is not signalled if the package is used.  When a package is killed by PKG-KILL, the home package of all symbols  in that package are left undisturbed (i.e., local symbols pointing to  the killed package); this aspect is compatible with the stated proposal.  Procyon Common Lisp has a function called DELETE-PACKAGE already. It  returns the name   of the package so deleted (as a string). [Perhaps it also  differs in the correctability of the errors it signals?]  Lucid Common Lisp implements DELETE-PACKAGE, except that the continuation  option for a name that doesn't name a package is different.Cost to Implementors:  The cost of providing this facility is probably small.Cost to Users:  Very slight to none. This change is essentially compatible.  Some code which cached packages in variables might have to be slightly  more cautious, but experience in the Symbolics implementation suggests  that it's really the responsibility of the person doing the DELETE-PACKAGE  to take care of worrying about the effects of having deleted the package:  normal programs need not bother testing a package for validity (using  PACKAGE-NAME) before using it.Cost of Non-Adoption:  Getting rid of a package would continue to be difficult to do portably.Benefits:  Better control of storage usage would be available portably.Aesthetics:  No significant effect.Discussion:  This was discussed as part of a larger bulk issue of how to undo all  sorts of definitions. Since that proposal has not gone anywhere   (perhaps bogged down under its own weight), this subtopic has been  broken off for separate discussion.  Note that if a symbol's package component is modified as a result  of being "unintern'd" from a delete packaged, then it is unspecified  as to how it will  be printed.*start*01272 00024 US Return-Path: <alarson@src.honeywell.com>Received: from moon.src.honeywell.com ([129.30.1.10]) by Xerox.COM ; 13 DEC 88 15:07:54 PSTReturn-Path: <alarson@src.honeywell.com>Received: from pavo.SRC.Honeywell.COM 	by moon.src.honeywell.com (5.59/smail2.6.3/06-17-88)	id AA24500; Tue, 13 Dec 88 17:07:45 CSTPosted-Date: Tue, 13 Dec 88 17:06:12 CSTReceived: by pavo.src.honeywell.com (3.2/SMI-3.2)	id AA11821; Tue, 13 Dec 88 17:06:12 CSTDate: Tue, 13 Dec 88 17:06:12 CSTFrom: alarson@src.honeywell.com (Aaron Larson)Message-Id: <8812132306.AA11821@pavo.src.honeywell.com>To: cl-cleanup@sail.stanford.eduCc: masinter.paIn-Reply-To: cl-cleanup@sail.stanford.edu's message of 8 Dec 88 20:40 PST <881208-204059-5304@Xerox>Subject: Issue: PACKAGE-DELETION (Version 5)....      If the designated package is used by other packages, a correctable      error is signalled. ..."continuable error"      After this operation completes, the contents of the symbol-package        slot of any symbol homed in the deleted package is unspecified; ...symbol S homed in pkg P == (eq P (symbol-package S)) ?Perhaps;  If package P was the value of (symbol-package S) then P is killed, it is  unspecified what the value of (symbol-package S) is.*start*01195 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 15 DEC 88 14:39:25 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00550g; Thu, 15 Dec 88 14:37:16 PSTReceived: by bhopal id AA19979g; Thu, 15 Dec 88 14:39:13 PSTDate: Thu, 15 Dec 88 14:39:13 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812152239.AA19979@bhopal>To: alarson@src.honeywell.comCc: cl-cleanup@sail.stanford.edu, masinter.paIn-Reply-To: Aaron Larson's message of Tue, 13 Dec 88 17:06:12 CST <8812132306.AA11821@pavo.src.honeywell.com>Subject: Issue: PACKAGE-DELETION (Version 5)re: ....	  If the designated package is used by other packages, a correctable	  error is signalled. ...    "continuable error"Yes, "continuable".  If there is to be another version, it can be changed.re:	  After this operation completes, the contents of the symbol-package  	  slot of any symbol homed in the deleted package is unspecified; ...    symbol S homed in pkg P == (eq P (symbol-package S)) ?A symbol's "home" package is defined to be the contents of itssymbol-package cell.  See CLtL p.175 (about middle of page).-- JonL --*start*01981 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 DEC 88 15:16:04 PSTReceived: from moon.src.honeywell.com (ALTURA.HONEYWELL.COM) by SAIL.Stanford.EDU with TCP; 15 Dec 88  15:15:17 PSTReturn-Path: <alarson@src.honeywell.com>Received: from pavo.SRC.Honeywell.COM 	by moon.src.honeywell.com (5.59/smail2.6.3/06-17-88)	id AA25319; Thu, 15 Dec 88 17:14:00 CSTPosted-Date: Thu, 15 Dec 88 17:12:20 CSTReceived: by pavo.src.honeywell.com (3.2/SMI-3.2)	id AA16934; Thu, 15 Dec 88 17:12:20 CSTDate: Thu, 15 Dec 88 17:12:20 CSTFrom: alarson@src.honeywell.com (Aaron Larson)Message-Id: <8812152312.AA16934@pavo.src.honeywell.com>To: jonl@lucid.comCc: cl-cleanup@sail.stanford.edu, masinter.paIn-Reply-To: Jon L White's message of Thu, 15 Dec 88 14:39:13 PST <8812152239.AA19979@bhopal>Subject: Issue: PACKAGE-DELETION (Version 5)   Posted-Date: Thu, 15 Dec 88 14:39:13 PST   Date: Thu, 15 Dec 88 14:39:13 PST   From: Jon L White <jonl@lucid.com>   re:	  After this operation completes, the contents of the symbol-package  	     slot of any symbol homed in the deleted package is unspecified; ...       symbol S homed in pkg P == (eq P (symbol-package S)) ?   A symbol's "home" package is defined to be the contents of its   symbol-package cell.  See CLtL p.175 (about middle of page).I guess I should have been more carefull in my statement.  The problem Iwas raising is that being "homed" is a satement about the symbol-package ofa symbol (and the fact that "homed" is slang), and stating that(symbol-package x) being the deleted package and being undefined iscontradictory.  The fact that you are stating something about the (previous)state of the symbol-packge, and that kill-package may (or may not) changethe symbol-package was being muddled.  In retrospect it was undoubtedlyobvious to everybody what the statement meant.