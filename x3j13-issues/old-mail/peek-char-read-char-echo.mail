*start*11472 00024 US Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 06 MAR 87 13:54:35 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 6 Mar 87  13:50:25 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL Date: Fri, 6 Mar 87 16:49 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: PEEK-CHAR-READ-CHAR-ECHOTo: CL-Cleanup@SAIL.STANFORD.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <870306164908.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        PEEK-CHAR-READ-CHAR-ECHOReferences:   READ-CHAR (p379), UNREAD-CHAR (p379), PEEK-CHAR (p379),	      MAKE-ECHO-STREAM (p330), Streams (p327-328),	      READ-PRESERVING-WHITESPACE (p376), 	      READ-DELIMITED-LIST (p377)Category:     CLARIFICATION/CHANGEEdit history: Revision 1 by KMP 03/06/87Problem Description:  The interaction between PEEK-CHAR, READ-CHAR and streams made by  MAKE-ECHO-STREAM is not made adequately clear about how many times  a particular character may be echoed and at what time such echo  is permissible.  For example, if *STANDARD-INPUT* is a non-interactive stream with  echo to the terminal, and the following code is executed:   (PROGN (PEEK-CHAR) (PRIN1 'XXX)	  (PEEK-CHAR) (PRIN1 'XXX)	  (READ-CHAR) (PRIN1 'XXX)	  (UNREAD-CHAR) (READ-CHAR))  what is seen on the terminal? There are at least four possibilities:  [1] Characters are echoed when first seen:      AXXXXXXXXX  [2] Characters are echoed whenever seen by PEEK-CHAR or READ-CHAR.      Characters are not unechoed by UNREAD-CHAR.      AXXXAXXXAXXXA  [3] Characters are not echoed by PEEK-CHAR but are echoed by READ-CHAR.      No `unecho' action is done by UNREAD-CHAR.      XXXXXXAXXXA  [4] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. READ-CHAR echos      but UNREAD-CHAR does not `unecho'. Operationally equivalent to [2]:      AXXXAXXXAXXXA  [5] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. READ-CHAR echos      but UNREAD-CHAR unechos (a magic Erase character must be       presupposed for display terminals, a file stream that can randomly      access during output and/or back up must be presupposed for files,      paper terminals just lose):      A<Erase>XXXA<Erase>XXXA<Erase>XXXA  [6] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. The first time      a char is seen by READ-CHAR it's echoed, UNREAD-CHAR does not echo,      re-fetching the char by READ-CHAR doesn't echo.  Operationally      equivalent to [1]:      AXXXXXXXXX  [7] PEEK-CHAR is implemented by peeking and does not echo. The first      time a char is seen by READ-CHAR it's echoed, UNREAD-CHAR does not      echo, re-fetching the char by READ-CHAR doesn't echo:      XXXXXXAXXX  This list is not believed to be exhaustive. It is only to illustrate  of the variety of possible ways in which the current specification can   be implemented without technically being in conflict with the written   word of CLtL. Obviously not all of these interpretations are considered   useful by all people, but usefulness has not been determined to be   criterial in satisfying the specification.  The description of streams (p327-328) is also [probably deliberately]  fuzzy on this issue as it relates to operating systems on which echoing   is done by the operating system. That is, some systems are line-at-a-time  and all READ-CHAR and PEEK-CHAR operations happen after issues of echo  have long since been resolved by a system call that reads and echos input   a line at a time. Other systems are character-at-a-time and these issues   hit home in a different way. It will probably be necessary to continue  leaving things slightly unspecified in order to accomodate the native   style of the variety of operating systems now trying to support Common   Lisp, but we should be more up front about the game we are playing. (For  example, code which must port between character-at-a-time and   line-at-a-time systems must be more careful about whether it does   newline-preceded or newline-terminated output than many CL programmers   might realize given the current wording.) Additionally, though, we should  be on the lookout for less ambitious goals involving only partial  compatibility to improve the situation wherever we can find a way to.  Abstract functions READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST  are implicitly affected by any decisions made on this issue since their  descriptions involve the use of UNREAD-CHAR and PEEK-CHAR, respectively.Proposal (PEEK-CHAR-READ-CHAR-ECHO:READ-CHAR):  Ammend the description of READ-CHAR to say that when the stream is  an echo stream (such as an interactive stream to the terminal or a  stream created by MAKE-ECHO-STREAM), the character will be echoed on  the stream at the time this operation is performed.  Ammend the description of UNREAD-CHAR to say that when the stream  is an echo stream (such as an interactive stream to the terminal or a  stream created by MAKE-ECHO-STREAM), no attempt will be made to undo   any echoing of the character which might already have been done on   the stream.  Ammend the description of PEEK-CHAR to say that when the stream is  an echo stream (such as an interactive stream to the terminal or a  stream created by MAKE-ECHO-STREAM), characters which are only peeked   at are not echoed. Note however that in the case that the PEEK-TYPE  argument is not NIL, the characters which are passed by PEEK-CHAR  are treated as if by READ-CHAR, and so are echoed.  Ammend the description of streams to mention that interactive streams  to the terminal, such as the one held by *TERMINAL-IO*, have the same  rules for the time at which echoing must occur as do streams created  by READ-CHAR, UNREAD-CHAR, and PEEK-CHAR.  Ammend the description of abstract input functions   READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST to acknowledge  that they are implicitly affected by these new echoing rules of   READ-CHAR, UNREAD-CHAR, and PEEK-CHAR.  Note: This is consistent with behavior [3] in the problem description.Proposal (PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR):  Ammend the description of READ-CHAR to say that when the stream is  an echo stream (such as an interactive stream to the terminal or a  stream created by MAKE-ECHO-STREAM), the character will be echoed on  the stream the first time those characters are seen. (Characters   which are not echoed by READ-CHAR are those which were put there by  UNREAD-CHAR and hence are assumed to have been echoed already by a  previous call to READ-CHAR.)  Ammend the description of UNREAD-CHAR to say that when the stream  is an echo stream (such as an interactive stream to the terminal or a  stream created by MAKE-ECHO-STREAM), no attempt will be made to undo   any echoing of the character which might already have been done on   the stream. However, characters placed on the stream by UNREAD-CHAR  will be marked in such as way as to inhibit later re-echo by READ-CHAR.  Ammend the description of PEEK-CHAR to say that when the stream is  an echo stream (such as an interactive stream to the terminal or a  stream created by MAKE-ECHO-STREAM), characters which are only peeked   at are not echoed. Note however that in the case that the PEEK-TYPE  argument is not NIL, the characters which are passed by PEEK-CHAR  are treated as if by READ-CHAR, and so are echoed unless they have  been marked otherwise by READ-CHAR.  Ammend the description of streams to mention that interactive streams  to the terminal, such as the one held by *TERMINAL-IO*, have the same  rules for the time at which echoing must occur as do streams created  by READ-CHAR, UNREAD-CHAR, and PEEK-CHAR.  Ammend the description of abstract input functions   READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST to acknowledge  that they are implicitly affected by these new echoing rules of   READ-CHAR, UNREAD-CHAR, and PEEK-CHAR.  Note: This is consistent with behavior [7] in the problem description.Rationale:  Correct echoing behavior is important to programs which do batch  processing, parsing, etc. Allowing multiple or premature echoing  is clearly unsatisfactory.  The first proposal, PEEK-CHAR-READ-CHAR-ECHO:READ-CHAR, is in use  in a number of systems and is known not to cause much problem. I  suspect that the true reason it causes little problems, however,  is that people who care about echo behavior just avoid UNREAD-CHAR   as too unpredictable.  The second proposal, PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR, is  not in use in any particular system that I can name, though I  wouldn't be surprised to find a system which did it. It proposes   a more rational interpretation of the echoing behavior of   UNREAD-CHAR which might make it possible for programmers concerned   about echo behavior not to have to shy away from UNREAD-CHAR   altogether. (I also believe that this behavior will improve the  behavior of READ-PRESERVING-WHITESPACE with regard to echoing,   since it mentions using UNREAD-CHAR.)  I believe that either of these proposals is an improvement over   existing practice. The latter proposal I suspect is more   practically coherent though I unfortunately have only mental   exercises and no actual personal experience upon which to base   that belief.Current Practice:  A wide variety of behaviors are in use.Adoption Cost:  The code to implement the proposed change itself is probably fairly  localized.  In some operating systems, there may be echoing constraints which  I am overlooking. Depending on what those are, I may be   over-trivializing the difficulty of adopting these for some  implementations. I invite informed commentary on this issue.  In some cases, there may be second order effects in the system   itself which would also require a somewhat less predictable amount   of work to fix. In most cases, my hope is that the work would be   slight only because I assume that anyone who was going to rely on   a particular echo behavior for anything major would have realized   that CLtL wasn't guaranteeing this point and would have sent mail  complaining about this problem a lot sooner. Since no one has made   much noise about this, my hope is that it hasn't affected too many   people yet.Benefits:  A number of applications involving of parsers, batch script  interpreters, and such would be possible to implement  straightforwardly and portably.Conversion Cost:  My guess is that most users naively expect (perhaps even without  realizing it explicitly) that echoing will take care of itself.  Usually by this I think they expect that echoing will occur at  the time of the READ-CHAR. My hope is that most user code already  expects the proposed behavior. However, because of the fact that  READ, READ-LINE, etc.Aesthetics:  These rules are intended to support the naive model that echoing  is the result of keyboard interaction and that each key struck  causes one character to echo. Users probably model file input as  batch keyboard input and expect analagous behavior. Because these  rules support that model, users will probably view this as a major  simplification and/or bug fix.Discussion:  KMP supports PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR.*start*02955 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 09 MAR 87 19:46:32 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 9 Mar 87  19:42:20 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Mon 9 Mar 87 22:14:42-ESTDate: Mon, 9 Mar 87 21:26 ESTMessage-ID: <FAHLMAN.12285143140.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: PEEK-CHAR-READ-CHAR-ECHOIn-reply-to: Msg of 9 Mar 1987  16:40-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>Kent,I agree that for text-based dialog-type interactions, such as the oneyou demonstrated, your unbuffered input model works better thanHemlock's buffered one.  However, for most kinds of interaction withLisp, a simple unbuffered listener cannot begin to match the convenienceof using an editor-based Lisp listener like the one we have in Hemlock.I've been using this for a couple of years now, and can't imagine goingback to an old Maclisp-style unbuffered listener for daily use.  As faras I'm concerned, any Lisp that doesn't have a first-rate Emacs listeneris unusable.  This is not just a matter of preferring what I'm familiarwith -- I was very much at home in unbuffered Maclisp and one time, andalso spent a period of involuntary exile on a line-mode Tops-10 Maclisp,so I've had ample opportunity to experience all three styles.I think that once such editor top-level modes are readily available,you'll find that the overwhelming majority of users favor them.  Forsome reason this style of interaction hasn't taken hold on Symbolics andTI machines; I suspect that this is because the editor top-level on Lispmachines has always had a few critical details wrong, but I'm not sure.And, of course, the Interlisp culture is completely different.Anyway, I feel as strongly about the advantages of this input style asyou probably feel about the advantages of a bit-mapped screen over a24x80 ASCII terminal.  I would fight very hard against any proposal thatwould take this editor-based listener away from me or that would forcethe output to go to a separate editor buffer.  There is the problem ofrunning conversational text-oriented code in an editor-based system.  Idon't think we have a really clean solution to that yet, but we have theoption of dropping into an unbuffered-input listener when running suchcode.  Or we could use the kind of separate echo/output buffer that yousuggest for this kind of interaction.  I'm happy to go as a tourist, butI won't live there.  Even for us occasional tourists, it is worthwhile cleaning up thesemantics of echo streams and unbuffered interactive streams, so Isupport your basic proposal, as long as it doesn't force every CommonLisp to use this as the default model for interactive I/O.-- Scott*start*02257 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 08 MAR 87 14:31:30 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 8 Mar 87  14:27:53 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 8 Mar 87 17:28:25-ESTDate: Sun, 8 Mar 87 17:28 ESTMessage-ID: <FAHLMAN.12284837588.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: CL-Cleanup@SAIL.STANFORD.EDUSubject: PEEK-CHAR-READ-CHAR-ECHOIn-reply-to: Msg of 6 Mar 1987  16:49-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>I agree in general with KMP's proposal that the behavior of echo streamsbe spelled out, and that FIRST-READ-CHAR is the best model to follow.There should be no problem in implementing this on any echo stream thatis unbuffered.In an echo stream whose input side is buffered (linemode or whatever),the data becomes available in a big lump, and then the Lisp system mayaccept this input a character at a time.  This proposal would in effectrequire that the echoing in an echo stream must be done by READ-CHARitself, rather than by the lower-level machinery that collects anddelivers a line's worth of characters.  That's OK with me, because oursystem uses ECHO streams very rarely, but it might not be OK withothers.One point that we want to be clear about is the following: *TERMINAL-IO*might not be an echo stream or anything remotely resembling one.  In CMUCommon Lisp, for example, there is a Hemlock top-level mode that allowsyou to edit the input expression in an editor buffer, which of coursedisplays what you are doing; when you press the "do-it" button, a big(possibly multiple-line) glob of input gets zapped to the Lisp as"terminal" input.  Obviously, any sort of echoing by the Lisp would beinappropriate here.So the parts of this proposal requiring "interactive streams...such asthe one held by *terminal-io*" to implement the echo-stream semanticsare too restrictive as they stand.  I think it would be reasonable tosay that UNBUFFERED terminal interaction should attempt to mimic thebehavior specified here for echo streams.One final point: "amend" is spelled with only one #\m.-- Scott*start*03977 00024 US Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 09 MAR 87 13:45:27 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 9 Mar 87  13:41:55 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL Date: Mon, 9 Mar 87 16:40 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: PEEK-CHAR-READ-CHAR-ECHOTo: Fahlman@C.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12284837588.BABYL@C.CS.CMU.EDU>Message-ID: <870309164039.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Well, I'm going to ramble here about interactive streams a bit, but Iwant to make it clear up front that it's still very important to me thatwe standardize on echo streams even if we don't end up agreeing oninteractive streams.One of the problems with some buffering strategies is that some userprograms that don't expect buffering don't work well within them.What I really want is for input and output to be reliably synchronizedand as I understand it, the strategy you say Hemlock uses is workingagainst that goal.For the sake of example, let's consider the following portable program: (DEFUN SQRT-SYSTEM ()   (DO ((VALUE (PROGN (FORMAT T "~&Number: ") (READ))	       (PROGN (FORMAT T "~&Number: ") (READ))))       ((NOT VALUE))     (FORMAT T "~&~S~%" (SQRT VALUE))))It seems to me that a lot safer way for your Hemlock interface to workis to keep input conceptually separate from program output (which wouldinclude echoing) and then whenever you type anything, it would put thatstuff in the program's input buffer (removing it from the buffer youwere just editing) and let it be re-echoed by the program. That way,you could do things like: Lisp> (SQRT-SYSTEM)<Do-It> Number: 4 9 16<Do-It>and see (#1): Lisp> (SQRT-SYSTEM) Number: 4 2 Number: 9 3 Number: 16 4 Number: If instead you say that buffered streams should not echo and that theoriginal input should be left in place, the typical program behaviorof (#2) looks like: Lisp> (SQRT-SYSTEM) Number: 4 9 16 2 Number:  3 Number:  4 Number: Of course, you could always write something that did: (DEFUN SQRT-SYSTEM ()   (DO ((VALUE (PROGN (IF (NOT (LISTEN)) (FORMAT T "~&Number: ")) (READ))	       (PROGN (IF (NOT (LISTEN)) (FORMAT T "~&Number: ")) (READ))))       ((NOT VALUE))     (PRINT (SQRT VALUE))))and then you'd see the following (#3) in you non-echoing buffered system: Lisp> (SQRT-SYSTEM) Number: 4 9 16<Do-It> 2 3 4 Number:This looks nice but it's a lot of pressure to put on users to say that theyshould always remember to use LISTEN before prompting. Users who don't usesystems which do this kind of buffering are going to wonder why they shouldhave to think about this.Obviously in some cases such as those involving printing terminals orlow-level line-at-a-time buffering which cannot be controlled, we'll haveno choice but to allow *TERMINAL-IO* to be an unbuffered stream upon whichno echo occurs, but I think that this should be by way of `tolerance' ofthings beyond our control and should not be the user interaction model thatwe want users to think in terms of. Maybe I'm being chauvanistic, though.I looked at the Apollo and was very surprised to find that Lucid(apparently) doesn't share my view. Perhaps they're just using toolsthat are supplied by the Apollo -- I don't know how the modularityworks, but it seems to me (admittedly not a sophisticated Apollo user)that the prompt should live only in the display window, that text in theinput pad should contain only characters to be stuffed to the inputstream, and that characters which get stuffed should be echoed in thedisplay area by the program at the time of READ-CHAR rather than beingechoed by the system at the time of window-to-window paste and notfurther echoed by the program. Hmm...*start*01361 00024 US Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 07:53:37 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 10 Mar 87  07:48:09 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 89228; Tue 10-Mar-87 10:06:24 ESTDate: Tue, 10 Mar 87 10:05 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: PEEK-CHAR-READ-CHAR-ECHOTo: Fahlman@C.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12285143140.BABYL@C.CS.CMU.EDU>Message-ID: <870310100529.5.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>I wasn't suggesting getting rid of Hemlock's buffered input, I wasjust suggesting an alternate model of how that buffered input wouldbe handled. ie, that you'd see your typein, elect when to send it,and then your typein would temporarily disappear from view in orderto allow your program to re-echo it in the appropriate place in theoutput text. I'm definitely not opposed to editor toplevels. I thinkthey're a fine idea. I just want programs tobe able to work equallywell with or without them if that is conveniently possible, and Ibelieve it is. Maybe if you go back and re-read my previous messagewith this in mind you'll see what I was after.*start*01725 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 13:57:58 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 10 Mar 87  13:54:49 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 10 Mar 87 16:18:51-ESTDate: Tue, 10 Mar 87 16:05 ESTMessage-ID: <FAHLMAN.12285346849.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: PEEK-CHAR-READ-CHAR-ECHOIn-reply-to: Msg of 10 Mar 1987  10:05-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>OK, I did misunderstand your earlier suggestion.  I read it assuggesting that the input editing would be done in one buffer, while theechoing and interspersed output goes to another.  I've tried an editorlistener that sends the output to a separate buffer from the input (onthe H-P system), and I'm pretty sure it's not the right thing.Your suggestion, in which the input disappears and then is re-created byechoing, is an interesting one, and worth trying.  I'm not ready tocommit to it yet, however.  there are lots of subtle factors that affectthe comfort of a top-level mode.I think that Rob's position is right: there are many ways of handlingLisp-listener interaction, some not thought of yet, and we don't want toclose any doors prematurely.  I think that if we can define what "theright thing" is for some lowest-common-denominator model like unbufferedchar-at-a-time input, then we can at least begin to play with ways ofmaking this shared model look right within the other more complex styleswe want to support.-- Scott*start*01028 00024 US Return-Path: <@SAIL.STANFORD.EDU:gls@Think.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 15:16:03 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 10 Mar 87  15:12:29 PSTReceived: from boethius by Think.COM via CHAOS; Tue, 10 Mar 87 17:39:22 ESTDate: Tue, 10 Mar 87 17:40 ESTFrom: Guy Steele <gls@Think.COM>Subject: PEEK-CHAR-READ-CHAR-ECHO: nostalgiaTo: Fahlman@c.cs.cmu.edu, KMP@scrc-stony-brook.arpaCc: CL-Cleanup@sail.stanford.edu, gls@think.comIn-Reply-To: <FAHLMAN.12285346849.BABYL@C.CS.CMU.EDU>Message-Id: <870310174014.2.GLS@BOETHIUS.THINK.COM>    Date: Tue, 10 Mar 1987  16:05 EST    From: "Scott E. Fahlman" <Fahlman@c.cs.cmu.edu>    Your suggestion, in which the input disappears and then is re-created by    echoing, is an interesting one, and worth trying.  I'm not ready to    commit to it yet, however.  there are lots of subtle factors that affect    the comfort of a top-level mode.Unless I am mistaken, ITS usually worked that way.--Guy*start*01011 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 16:40:51 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 10 Mar 87  16:37:07 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 89969; Tue 10-Mar-87 19:36:27 ESTDate: Tue, 10 Mar 87 19:36 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: PEEK-CHAR-READ-CHAR-ECHOTo: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <RAM.12285133039.BABYL@C.CS.CMU.EDU>Message-ID: <870310193621.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 9 Mar 1987  20:31 EST    From: Rob MacLachlan <RAM@C.CS.CMU.EDU>    Fixing echo streams is fine, but I don't think that    it is appropriate for the standard to specify how terminal interaction    must or even ought to work.I agree with this comment.  I'm going to refrain from commenting onthe rest of the discussion.*start*01598 00024 US Return-Path: <@SAIL.STANFORD.EDU:RAM@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 09 MAR 87 19:44:10 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 9 Mar 87  19:41:09 PSTReceived: ID <RAM@C.CS.CMU.EDU>; Mon 9 Mar 87 22:13:41-ESTDate: Mon, 9 Mar 87 20:31 ESTMessage-ID: <RAM.12285133039.BABYL@C.CS.CMU.EDU>From: Rob MacLachlan <RAM@C.CS.CMU.EDU>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: PEEK-CHAR-READ-CHAR-ECHOIn-reply-to: Msg of 9 Mar 1987  16:40-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>Well, actually what Hemlock does is rather complicated, but differentfrom all the things you discussed.  It does preserve proper sequencingof input and output between packets of input, but does so by insertingoutput at the end of the last read packet.  This is layered on top ofan IPC protocol that normally transmits text a line at a time.Your example will still lose, but I think that this could beinterpreted as a non-portability of the user rather than of theprogram.  If you obeyed the appropriate local convention of delimitingdistinct inputs with <Do-It> then it would work.Although I think that this system works great, the point is not todebate the relative merits of kinds of user interaction; the point isthat there's lots of ways to do it, and some of them haven't even beenthought of yet.  Fixing echo streams is fine, but I don't think thatit is appropriate for the standard to specify how terminal interactionmust or even ought to work.  Rob*start*11698 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 JUN 88 12:56:21 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Jun 88  12:54:15 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 423827; Thu 23-Jun-88 15:54:01 EDTDate: Thu, 23 Jun 88 15:53 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PEEK-CHAR-READ-CHAR-ECHO (Version 2)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880623155341.5.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Ok, I've revived this proposal per discussion in committee withcorrections to just treat echo streams (as created by MAKE-ECHO-STREAM)and not get caught up in the problems of terminal interaction.Please read carefully. A lot of little things changed in the processand I don't guarantee this is error-free.Naturally, if we could agree to just go forward with one of the twoproposals, the thing would be textually a bit simpler...-----Issue:        PEEK-CHAR-READ-CHAR-ECHOReferences:   READ-CHAR (p379), UNREAD-CHAR (p379), PEEK-CHAR (p379),	      MAKE-ECHO-STREAM (p330), Streams (p327-328),	      READ-PRESERVING-WHITESPACE (p376), 	      READ-DELIMITED-LIST (p377)Category:     CLARIFICATION/CHANGEEdit history: 06-Mar-88, Version 1 by Pitman,	      23-Jun-88, Version 2 by Pitman (remove interactive stuff)Status:	      For Internal Discussion	      Problem Description:  The interaction between PEEK-CHAR, READ-CHAR and streams made by  MAKE-ECHO-STREAM is not made adequately clear about how many times  a particular character may be echoed and at what time such echo  is permissible.  For example, given:   (WITH-INPUT-FROM-STRING (STRING-STREAM "A")     (LET ((*STANDARD-INPUT* (MAKE-ECHO-STREAM STRING-STREAM					       *STANDARD-OUTPUT*)))       (LET ((CHAR NIL))	 (PEEK-CHAR)             (PRIN1 '---)	 (PEEK-CHAR)             (PRIN1 '---)	 (SETQ CHAR (READ-CHAR)) (PRIN1 '---)	 (UNREAD-CHAR CHAR)      (PRIN1 '---)	 (READ-CHAR))))  what is seen on the terminal? There are at least these possibilities:  [1] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. The first time      a char is seen by READ-CHAR it's echoed, UNREAD-CHAR does not echo,      re-fetching the char by READ-CHAR doesn't echo.      A------------  [2] Characters are echoed whenever seen by PEEK-CHAR or READ-CHAR.      Characters are not unechoed by UNREAD-CHAR.      A---A---A---A---  [3] Characters are not echoed by PEEK-CHAR but are echoed by READ-CHAR.      No `unecho' action is done by UNREAD-CHAR.      ------A------A  [4] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. READ-CHAR echos      but UNREAD-CHAR does not `unecho'.      A---A---A------A  [5] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. READ-CHAR echos      but UNREAD-CHAR unechos (a magic Erase character must be       presupposed for display terminals, a file stream that can randomly      access during output and/or back up must be presupposed for files,      paper terminals just lose):      A<Erase>---A<Erase>---A---<Erase>---A  [6] PEEK-CHAR is implemented by peeking and does not echo. The first      time a char is seen by READ-CHAR it's echoed, UNREAD-CHAR does not      echo, re-fetching the char by READ-CHAR doesn't echo:      ------A------  This list is not believed to be exhaustive. It is only to illustrate  of the variety of possible ways in which the current specification can   be implemented without technically being in conflict with the written   word of CLtL. Obviously not all of these interpretations are considered   useful by all people, but usefulness has not been determined to be   criterial in satisfying the specification.  The description of streams (p327-328) is also [probably deliberately]  fuzzy on this issue as it relates to operating systems on which echoing   is done by the operating system. That is, some systems are line-at-a-time  and all READ-CHAR and PEEK-CHAR operations happen after issues of echo  have long since been resolved by a system call that reads and echos input   a line at a time. Other systems are character-at-a-time and these issues   hit home in a different way. It will probably be necessary to continue  leaving things slightly unspecified in order to accomodate the native   style of the variety of operating systems now trying to support Common   Lisp, but we should be more up front about the game we are playing. (For  example, code which must port between character-at-a-time and   line-at-a-time systems must be more careful about whether it does   newline-preceded or newline-terminated output than many CL programmers   might realize given the current wording.) Additionally, though, we should  be on the lookout for less ambitious goals involving only partial  compatibility to improve the situation wherever we can find a way to.  Abstract functions READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST  are implicitly affected by any decisions made on this issue since their  descriptions involve the use of UNREAD-CHAR and PEEK-CHAR, respectively.Proposal (PEEK-CHAR-READ-CHAR-ECHO:READ-CHAR):  Ammend the description of READ-CHAR to say that when the stream is  an echo stream (a stream created by MAKE-ECHO-STREAM), the character  will be echoed on the stream at the time this operation is performed.  Ammend the description of UNREAD-CHAR to say that when the stream  is an echo stream (a stream created by MAKE-ECHO-STREAM), no attempt  will be made to undo any echoing of the character which might already  have been done on the stream.  Ammend the description of PEEK-CHAR to say that when the stream is  an echo stream (a stream created by MAKE-ECHO-STREAM), characters  which are only peeked at are not echoed. Note however that in the  case that the PEEK-TYPE argument is not NIL, the characters which  are passed by PEEK-CHAR are treated as if by READ-CHAR, and so are  echoed.  Ammend the description of abstract input functions   READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST to acknowledge  that they are implicitly affected by these new echoing rules of   READ-CHAR, UNREAD-CHAR, and PEEK-CHAR.  Note: This is consistent with behavior [3] in the problem description.  Clarify that the echo behavior of interactive streams such as  *TERMINAL-IO* continues to be implementation dependent.  Rationale:    This is in use in a number of systems and few problems have been    reported. However, the reason there are so few reports may be that    few people use echo streams or that people who care about echo    behavior just avoid UNREAD-CHAR as too unpredictable (perhaps using    more reliable implementation-dependent primitives).  Proposal (PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR):  Ammend the description of READ-CHAR to say that when the stream is  an echo stream (a stream created by MAKE-ECHO-STREAM), the character  will be echoed on the stream the first time those characters are seen.  (Characters which are not echoed by READ-CHAR are those which were  put there by UNREAD-CHAR and hence are assumed to have been echoed  already by a previous call to READ-CHAR.)  Ammend the description of UNREAD-CHAR to say that when the stream  is an echo stream (a stream created by MAKE-ECHO-STREAM), no attempt  will be made to undo any echoing of the character which might already  have been done on the stream. However, characters placed on the  stream by UNREAD-CHAR will be marked in such as way as to inhibit  later re-echo by READ-CHAR.  Ammend the description of PEEK-CHAR to say that when the stream is  an echo stream (a stream created by MAKE-ECHO-STREAM), characters  which are only peeked at are not echoed. Note however that in the  case that the PEEK-TYPE argument is not NIL, the characters which  are passed by PEEK-CHAR are treated as if by READ-CHAR, and so are  echoed unless they have been marked otherwise by READ-CHAR.  Ammend the description of abstract input functions   READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST to acknowledge  that they are implicitly affected by these new echoing rules of   READ-CHAR, UNREAD-CHAR, and PEEK-CHAR.  Note: This is consistent with behavior [6] in the problem description.  Clarify that the echo behavior of interactive streams such as  *TERMINAL-IO* continues to be implementation dependent.  Rationale:    Although this is not known to be in use in any particular system,    nothing prevents its use. It proposes a more rational interpretation    of the echoing behavior of UNREAD-CHAR which might make it possible    for programmers concerned about echo behavior not to have to shy    away from UNREAD-CHAR. (It would probably also improve the behavior    of READ-PRESERVING-WHITESPACE with regard to echoing, since its    description mentions using UNREAD-CHAR.)Rationale:  Correct echoing behavior is important to programs which do batch  processing, parsing, etc. Allowing multiple or premature echoing  is clearly unsatisfactory.  Either of these proposals is an improvement over existing practice.Current Practice:  A wide variety of behaviors are in use.Cost to Implementors:  The code to implement the proposed change itself is probably fairly  localized.  In some operating systems, there may be echoing constraints which  I am overlooking. Depending on what those are, I may be   over-trivializing the difficulty of adopting these for some  implementations. I invite informed commentary on this issue.  In some cases, there may be second order effects in the system   itself which would also require a somewhat less predictable amount   of work to fix. In most cases, my hope is that the work would be   slight only because I assume that anyone who was going to rely on   a particular echo behavior for anything major would have realized   that CLtL wasn't guaranteeing this point and would have sent mail  complaining about this problem a lot sooner. Since no one has made   much noise about this, my hope is that it hasn't affected too many   people yet.Cost to Users:  Any change is effectively upward compatible since the previous  behavior is so ill-specified.  Most users probably naively expect (perhaps even without realizing  it explicitly) that echoing will take care of itself. That is, they  probably expect that echoing will occur at the time of the  READ-CHAR and probably do not give a lot of thought to the effect  of PEEK-CHAR. As such, FIRST-READ-CHAR probably best supports most   of their naive intuitions.Cost of Non-Adoption:  The streams returned by MAKE-ECHO-STREAM would continue to be  significantly hard to use portably.Benefits:  A number of applications involving of parsers, batch script  interpreters, and such would be possible to implement  straightforwardly and portably.Aesthetics:  [Thoughts anyone? -kmp]Discussion:  Pitman supports PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR because  he feels it is more practically coherent. However, he says he has  only mental exercises and no actual personal experience upon which  to base that belief.  Version 1 of this proposal treated interactive streams on par  with echo streams, but while people agreed that this issue is  a severe portability problem, some considered that the treatment  of interactive streams got involved in operating system issues  that were beyond the scope of the standard, so that part of the  text was removed. *start*01600 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 17:16:06 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 19 Sep 88  17:15:10 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 19 SEP 88 16:51:07 PDTDate: 19 Sep 88 16:51 PDTFrom: masinter.paSubject: Re: Issue: PEEK-CHAR-READ-CHAR-ECHO (Version 2)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 23 Jun 88 15:53 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880919-165107-2710@Xerox>I at first doubted your Current Practice until I tried it myself -- it certainlydid differ among the implementations I tried.Since as written there are no operating system interactions, I think this isreasonable to put in the standard. I can't think of any important performanceissues.I think you have picked on the two reasonable interpretations. I thinkFIRST-READ-CHAR is preferable from the point of view of many applications.Suppose a special version of READ is implemented in terms of READ-CHAR, andfurther that its written(case (setq first (read-char))  (#\( ... read list ...)  (#\#  ... read dispatching macro ...)  .... other special cases ...  (otherwise (unread-char first) (read-symbol)))where read-symbol is written in terms of read-char. It would be unfortunate tohave the first character of each symbol echoed twice, as I think would berequired by PEEK-CHAR-READ-CHAR-ECHO:READ-CHAR.*start*08836 00024 USfDate:  8 Oct 88 20:51 PDTSender: masinter.paSubject: Issue: PEEK-CHAR-READ-CHAR-ECHO (Version 3)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:        PEEK-CHAR-READ-CHAR-ECHOReferences:   READ-CHAR (p379), UNREAD-CHAR (p379), PEEK-CHAR (p379),	      MAKE-ECHO-STREAM (p330), Streams (p327-328),	      READ-PRESERVING-WHITESPACE (p376), 	      READ-DELIMITED-LIST (p377)Category:     CLARIFICATION/CHANGEEdit history: 06-Mar-88, Version 1 by Pitman,              23-Jun-88, Version 2 by Pitman (remove interactive stuff)               8-Oct-88, Version 3 by Pitman & Masinter	      Problem Description:  The interaction between PEEK-CHAR, READ-CHAR and streams made by  MAKE-ECHO-STREAM is not made adequately clear about how many times  a particular character may be echoed and at what time such echo  is permissible.  For example, given:   (WITH-INPUT-FROM-STRING (STRING-STREAM "A")     (LET ((*STANDARD-INPUT* (MAKE-ECHO-STREAM STRING-STREAM					       *STANDARD-OUTPUT*)))       (LET ((CHAR NIL))	 (PEEK-CHAR)             (PRIN1 '---)	 (PEEK-CHAR)             (PRIN1 '---)	 (SETQ CHAR (READ-CHAR)) (PRIN1 '---)	 (UNREAD-CHAR CHAR)      (PRIN1 '---)	 (READ-CHAR))))  what is seen on the terminal? There are at least these possibilities:  [1] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. The first time      a char is seen by READ-CHAR it's echoed, UNREAD-CHAR does not echo,      re-fetching the char by READ-CHAR doesn't echo.      A------------  [2] Characters are echoed whenever seen by PEEK-CHAR or READ-CHAR.      Characters are not unechoed by UNREAD-CHAR.      A---A---A---A---  [3] Characters are not echoed by PEEK-CHAR but are echoed by READ-CHAR.      No `unecho' action is done by UNREAD-CHAR.      ------A------A  [4] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. READ-CHAR echos      but UNREAD-CHAR does not `unecho'.      A---A---A------A  [5] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. READ-CHAR echos      but UNREAD-CHAR unechos (a magic Erase character must be       presupposed for display terminals, a file stream that can randomly      access during output and/or back up must be presupposed for files,      paper terminals just lose):      A<Erase>---A<Erase>---A---<Erase>---A  [6] PEEK-CHAR is implemented by peeking and does not echo. The first      time a char is seen by READ-CHAR it's echoed, UNREAD-CHAR does not      echo, re-fetching the char by READ-CHAR doesn't echo:      ------A------  This list is not believed to be exhaustive. It is only to illustrate  of the variety of possible ways in which the current specification can   be implemented without technically being in conflict with the written   word of CLtL. Obviously not all of these interpretations are considered   useful by all people, but usefulness has not been determined to be   criterial in satisfying the specification.  The description of streams (p327-328) is also [probably deliberately]  fuzzy on this issue as it relates to operating systems on which echoing   is done by the operating system. That is, some systems are line-at-a-time  and all READ-CHAR and PEEK-CHAR operations happen after issues of echo  have long since been resolved by a system call that reads and echos input   a line at a time. Other systems are character-at-a-time and these issues   hit home in a different way. It will probably be necessary to continue  leaving things slightly unspecified in order to accomodate the native   style of the variety of operating systems now trying to support Common   Lisp, but we should be more up front about the game we are playing. (For  example, code which must port between character-at-a-time and   line-at-a-time systems must be more careful about whether it does   newline-preceded or newline-terminated output than many CL programmers   might realize given the current wording.) Additionally, though, we should  be on the lookout for less ambitious goals involving only partial  compatibility to improve the situation wherever we can find a way to.  Abstract functions READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST  are implicitly affected by any decisions made on this issue since their  descriptions involve the use of UNREAD-CHAR and PEEK-CHAR, respectively.Proposal (PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR):  Ammend the description of READ-CHAR to say that when the stream is  an echo stream (a stream created by MAKE-ECHO-STREAM), the character  will be echoed on the stream the first time those characters are seen.  (Characters which are not echoed by READ-CHAR are those which were  put there by UNREAD-CHAR and hence are assumed to have been echoed  already by a previous call to READ-CHAR.)  Ammend the description of UNREAD-CHAR to say that when the stream  is an echo stream (a stream created by MAKE-ECHO-STREAM), no attempt  will be made to undo any echoing of the character which might already  have been done on the stream. However, characters placed on the  stream by UNREAD-CHAR will be marked in such as way as to inhibit  later re-echo by READ-CHAR.  Ammend the description of PEEK-CHAR to say that when the stream is  an echo stream (a stream created by MAKE-ECHO-STREAM), characters  which are only peeked at are not echoed. Note however that in the  case that the PEEK-TYPE argument is not NIL, the characters which  are passed by PEEK-CHAR are treated as if by READ-CHAR, and so are  echoed unless they have been marked otherwise by READ-CHAR.  Ammend the description of abstract input functions   READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST to acknowledge  that they are implicitly affected by these new echoing rules of   READ-CHAR, UNREAD-CHAR, and PEEK-CHAR.  Note: This is consistent with behavior [6] in the problem description.  Clarify that the echo behavior of interactive streams such as  *TERMINAL-IO* continues to be implementation dependent.Rationale:  Although this is not known to be in use in any particular system,  nothing prevents its use. It proposes a more rational interpretation  of the echoing behavior of UNREAD-CHAR which might make it possible  for programmers concerned about echo behavior not to have to shy  away from UNREAD-CHAR. (It would probably also improve the behavior  of READ-PRESERVING-WHITESPACE with regard to echoing, since its  description mentions using UNREAD-CHAR.)  Correct echoing behavior is important to programs which do batch  processing, parsing, etc. Allowing multiple or premature echoing  is clearly unsatisfactory.Current Practice:  A wide variety of behaviors are in use.Cost to Implementors:  Unknown.  The code to implement the proposed change itself is probably fairly  localized.  In some operating systems, there may be echoing constraints which  are overlooked here.   In some cases, there may be second order effects in the system   itself which would also require a somewhat less predictable amount   of work to fix. Cost to Users:  Any change is effectively upward compatible since the previous  behavior is so ill-specified.  Most users probably naively expect (perhaps even without realizing  it explicitly) that echoing will take care of itself. That is, they  probably expect that echoing will occur at the time of the  READ-CHAR and probably do not give a lot of thought to the effect  of PEEK-CHAR. As such, FIRST-READ-CHAR probably best supports most   of their naive intuitions.Cost of Non-Adoption:  The streams returned by MAKE-ECHO-STREAM would continue to be  significantly hard to use portably.Benefits:  A number of applications involving of parsers, batch script  interpreters, and such would be possible to implement  straightforwardly and portably.Aesthetics:  ?Discussion:  Pitman supports PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR because  he feels it is more practically coherent. However, he says he has  only mental exercises and no actual personal experience upon which  to base that belief.  Version 1 of this proposal treated interactive streams on par  with echo streams, but while people agreed that this issue is  a severe portability problem, some considered that the treatment  of interactive streams got involved in operating system issues  that were beyond the scope of the standard, so that part of the  text was removed.         TITAN 
         TITAN 
           ç                            ¹                            ¨             j       5      F             m              ,             Z             Ó              h       
       š                           A      !1 zº*start*00920 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 19:44:24 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:55:43 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476086; Thu 13-Oct-88 18:54:15 EDTDate: Thu, 13 Oct 88 18:54 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PEEK-CHAR-READ-CHAR-ECHO (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013185407.1.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: This issue looks ready for vote.X3J13 meeting: RWK: Check spelling of plurals of "echo" and "unecho". Masinter: Draft 1 date in edit history is probably wrong.*start*08868 00024 US Date: 26 Nov 88 20:32 PSTFrom: masinter.paSubject: Issue: PEEK-CHAR-READ-CHAR-ECHO (Version 3)To: Masinterfixed mispelling "echos" -> "echoes"Issue:        PEEK-CHAR-READ-CHAR-ECHOReferences:   READ-CHAR (p379), UNREAD-CHAR (p379), PEEK-CHAR (p379),	      MAKE-ECHO-STREAM (p330), Streams (p327-328),	      READ-PRESERVING-WHITESPACE (p376), 	      READ-DELIMITED-LIST (p377)Category:     CLARIFICATION/CHANGEEdit history: 06-Mar-87, Version 1 by Pitman              23-Jun-88, Version 2 by Pitman (remove interactive stuff)               8-Oct-88, Version 3 by Pitman & Masinter	      Problem Description:  The interaction between PEEK-CHAR, READ-CHAR and streams made by  MAKE-ECHO-STREAM is not made adequately clear about how many times  a particular character may be echoed and at what time such echo  is permissible.  For example, given:   (WITH-INPUT-FROM-STRING (STRING-STREAM "A")     (LET ((*STANDARD-INPUT* (MAKE-ECHO-STREAM STRING-STREAM					       *STANDARD-OUTPUT*)))       (LET ((CHAR NIL))	 (PEEK-CHAR)             (PRIN1 '---)	 (PEEK-CHAR)             (PRIN1 '---)	 (SETQ CHAR (READ-CHAR)) (PRIN1 '---)	 (UNREAD-CHAR CHAR)      (PRIN1 '---)	 (READ-CHAR))))  what is seen on the terminal? There are at least these possibilities:  [1] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. The first time      a char is seen by READ-CHAR it's echoed, UNREAD-CHAR does not echo,      re-fetching the char by READ-CHAR doesn't echo.      A------------  [2] Characters are echoed whenever seen by PEEK-CHAR or READ-CHAR.      Characters are not unechoed by UNREAD-CHAR.      A---A---A---A---  [3] Characters are not echoed by PEEK-CHAR but are echoed by READ-CHAR.      No `unecho' action is done by UNREAD-CHAR.      ------A------A  [4] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. READ-CHAR echoes      but UNREAD-CHAR does not `unecho'.      A---A---A------A  [5] PEEK-CHAR is implemented by READ-CHAR/UNREAD-CHAR. READ-CHAR echoes      but UNREAD-CHAR unechoes (a magic Erase character must be       presupposed for display terminals, a file stream that can randomly      access during output and/or back up must be presupposed for files,      paper terminals just lose):      A<Erase>---A<Erase>---A---<Erase>---A  [6] PEEK-CHAR is implemented by peeking and does not echo. The first      time a char is seen by READ-CHAR it's echoed, UNREAD-CHAR does not      echo, re-fetching the char by READ-CHAR doesn't echo:      ------A------  This list is not believed to be exhaustive. It is only to illustrate  of the variety of possible ways in which the current specification can   be implemented without technically being in conflict with the written   word of CLtL. Obviously not all of these interpretations are considered   useful by all people, but usefulness has not been determined to be   criterial in satisfying the specification.  The description of streams (p327-328) is also [probably deliberately]  fuzzy on this issue as it relates to operating systems on which echoing   is done by the operating system. That is, some systems are line-at-a-time  and all READ-CHAR and PEEK-CHAR operations happen after issues of echo  have long since been resolved by a system call that reads and echoes input   a line at a time. Other systems are character-at-a-time and these issues   hit home in a different way. It will probably be necessary to continue  leaving things slightly unspecified in order to accomodate the native   style of the variety of operating systems now trying to support Common   Lisp, but we should be more up front about the game we are playing. (For  example, code which must port between character-at-a-time and   line-at-a-time systems must be more careful about whether it does   newline-preceded or newline-terminated output than many CL programmers   might realize given the current wording.) Additionally, though, we should  be on the lookout for less ambitious goals involving only partial  compatibility to improve the situation wherever we can find a way to.  Abstract functions READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST  are implicitly affected by any decisions made on this issue since their  descriptions involve the use of UNREAD-CHAR and PEEK-CHAR, respectively.Proposal (PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR):  Ammend the description of READ-CHAR to say that when the stream is  an echo stream (a stream created by MAKE-ECHO-STREAM), the character  will be echoed on the stream the first time those characters are seen.  (Characters which are not echoed by READ-CHAR are those which were  put there by UNREAD-CHAR and hence are assumed to have been echoed  already by a previous call to READ-CHAR.)  Ammend the description of UNREAD-CHAR to say that when the stream  is an echo stream (a stream created by MAKE-ECHO-STREAM), no attempt  will be made to undo any echoing of the character which might already  have been done on the stream. However, characters placed on the  stream by UNREAD-CHAR will be marked in such as way as to inhibit  later re-echo by READ-CHAR.  Ammend the description of PEEK-CHAR to say that when the stream is  an echo stream (a stream created by MAKE-ECHO-STREAM), characters  which are only peeked at are not echoed. Note however that in the  case that the PEEK-TYPE argument is not NIL, the characters which  are passed by PEEK-CHAR are treated as if by READ-CHAR, and so are  echoed unless they have been marked otherwise by READ-CHAR.  Ammend the description of abstract input functions   READ-PRESERVING-WHITESPACE and READ-DELIMITED-LIST to acknowledge  that they are implicitly affected by these new echoing rules of   READ-CHAR, UNREAD-CHAR, and PEEK-CHAR.  Note: This is consistent with behavior [6] in the problem description.  Clarify that the echo behavior of interactive streams such as  *TERMINAL-IO* continues to be implementation dependent.Rationale:  Although this is not known to be in use in any particular system,  nothing prevents its use. It proposes a more rational interpretation  of the echoing behavior of UNREAD-CHAR which might make it possible  for programmers concerned about echo behavior not to have to shy  away from UNREAD-CHAR. (It would probably also improve the behavior  of READ-PRESERVING-WHITESPACE with regard to echoing, since its  description mentions using UNREAD-CHAR.)  Correct echoing behavior is important to programs which do batch  processing, parsing, etc. Allowing multiple or premature echoing  is clearly unsatisfactory.Current Practice:  A wide variety of behaviors are in use.Cost to Implementors:  Unknown.  The code to implement the proposed change itself is probably fairly  localized.  In some operating systems, there may be echoing constraints which  are overlooked here.   In some cases, there may be second order effects in the system   itself which would also require a somewhat less predictable amount   of work to fix. Cost to Users:  Any change is effectively upward compatible since the previous  behavior is so ill-specified.  Most users probably naively expect (perhaps even without realizing  it explicitly) that echoing will take care of itself. That is, they  probably expect that echoing will occur at the time of the  READ-CHAR and probably do not give a lot of thought to the effect  of PEEK-CHAR. As such, FIRST-READ-CHAR probably best supports most   of their naive intuitions.Cost of Non-Adoption:  The streams returned by MAKE-ECHO-STREAM would continue to be  significantly hard to use portably.Benefits:  A number of applications involving of parsers, batch script  interpreters, and such would be possible to implement  straightforwardly and portably.Aesthetics:  ?Discussion:  Pitman supports PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR because  he feels it is more practically coherent. However, he says he has  only mental exercises and no actual personal experience upon which  to base that belief.  Version 1 of this proposal treated interactive streams on par  with echo streams, but while people agreed that this issue is  a severe portability problem, some considered that the treatment  of interactive streams got involved in operating system issues  that were beyond the scope of the standard, so that part of the  text was removed.      ----- End Forwarded Messages -----        TITAN 
         TITAN 
         ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))            –                            ¹                            §             n       5      F             m              ,             Z             Ó              h       
       š                           B       )      ! zº*start*01056 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 15:25:08 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  15:24:54 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 15:23:48 PSTDate: 2 Jan 89 15:23 PSTSender: masinter.paSubject: re: Issue: PEEK-CHAR-READ-CHAR-ECHO (Version 3)To: cl-cleanup@sail.stanford.eduFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Message-ID: <890102-152348-1739@Xerox>However, I think it should be mentioned that this implies that PEEK-CHAR isreally no longer equivelent to read-char followed by unread-char, and can't beimplemented that way for any kind of metastream.  All metastreams must nowsupport PEEK-CHAR directly, and pass it along to the indirect streams, in casesome of those streams are echo streams.  This mostly increases the cost toimplementors, though it is also a cost to users in systems where the set ofmetastreams is user-extensible. *start*01384 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 19:15:05 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Jan 89  19:13:29 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 JAN 89 17:25:29 PSTDate: 9 Jan 89 17:24 PSTFrom: masinter.paSubject: re: Issue: PEEK-CHAR-READ-CHAR-ECHO (Version 3)In-reply-to: Kim A. Barrett <IIM@ECLA.USC.EDU>'s message of 2 Jan 89 15:23 PSTTo: Kim A. Barrett <IIM@ECLA.USC.EDU>cc: cl-cleanup@sail.stanford.eduMessage-ID: <890109-172529-5043@Xerox>Kim:The proposal only implies that PEEK-CHAR is no longer equivalent toREAD-CHAR followed by UNREAD-CHAR when the stream in question is streamcreated by MAKE-ECHO-STREAM. Certainly for any other stream, a stringstream, and any other stream that doesn't have ECHO behavior, PEEK-CHARcould be implemented by READ-CHAR followed by UNREAD-CHAR. It probablyimplies that synonym streams should "pass on" the PEEK-CHAR operation, andthat concatenated streams should also do so, but I'd be suprised if manyimplementations didn't already do that.This proposal does *not* necessarily affect what *TERMINAL-IO* does; onlywith streams created by MAKE-ECHO-STREAM. FYI, hardcopy & online versions have the typo "echos" fixed. Are thereothers?*start*02017 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 MAR 89 14:44:18 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 10 Mar 89  14:43:20 PSTDate: Fri, 10 Mar 89 14:41:00 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue PEEK-CHAR-READ-CHAR-ECHOTo: cl-cleanup@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUMessage-ID: <12476991441.30.IIM@ECLA.USC.EDU>Further discussion of this issue here at IIM has lead us to conclude that thedecision made at the Hawaii meeting to accept the proposalPEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR was a mistake.  Some of the argumentsagainst it involve flexibility of implementation, but none of us have time toreally do a proper job of writing up those arguments just now.  Besides which,the argument some of us have found most compelling has nothing to do withimplementation flexibility.The primary argument against the passed proposal is that an effort should bemade to make input appear "where it is used".  For example, consider aread-eval-print loop which prompts with a "* ".  Now consider the followingsequence of input characters:  'foo(+ 5 5)Under the proposal as adopted, if the read-eval-print loop were operating on anecho stream (which *standard-output* is bound to), then the resulting outputwould be   * 'foo(  FOO  * + 5 5)  10  *Note how the open-paren is misplaced.Note that the input and output streams of the echo-stream could have beenstring-input/output-streams, so this has nothing to do with possible lineoriented, pre-echoed input, as discussed in the proposal.  In fact, the wholediscussion of operating system considerations in the proposal is misleading,since the proposal is describing the behavior of echo-streams, which may havevery little to do with the streams used for direct terminal io, screenmanipulation, and etc.We wish to have this issue reconsidered.kab-------*start*03188 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 MAR 89 15:12:33 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Mar 89  15:11:34 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 554851; Fri 10-Mar-89 18:08:21 ESTDate: Fri, 10 Mar 89 18:08 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue PEEK-CHAR-READ-CHAR-ECHOTo: IIM@ECLA.USC.EDUcc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <12476991441.30.IIM@ECLA.USC.EDU>Message-ID: <890310180807.3.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri 10 Mar 89 14:41:00-PST    From: Kim A. Barrett <IIM@ECLA.USC.EDU>    Further discussion of this issue here at IIM has lead us to conclude that the    decision made at the Hawaii meeting to accept the proposal    PEEK-CHAR-READ-CHAR-ECHO:FIRST-READ-CHAR was a mistake.    ...    Under the proposal as adopted, if the read-eval-print loop were operating on an    echo stream (which *standard-output* is bound to), then the resulting output    would be ...      * 'foo(      FOO      * + 5 5)      10      *    Note how the open-paren is misplaced. ...I'm not positive I parsed your example correctly, but let me make a few remarksthat I hope will clarify...This issue was originally drafted to address interactive streams but waslater revised to address only the result of MAKE-ECHO-STREAM, not anarbitrary stream with echoing semantics exactly to preclude worry of thesort you describe -- such as might be the initial value of *STANDARD-OUTPUT*(or, actually, *STANDARD-INPUT*, I think you mean).You don't say in your mail whether you champion an alternative or leavingit vague. If you want to leave it vague, the chief problem is that the -exact-problem that you seem to be describing comes up in echo from files. The onlyway around it is to document which of several techniques you can use to reliablyparse such files to get the echo behavior you want.In particular, in Macsyma, you can write script files that say:F(X):=X+1$ /* Definition of F */G(X):=X+2$ /* Definition of G */The Macsyma interactive loop prompts with (C1), (C2), etc. before eachinput command, and the Macsyma batch file facility wants to be ableto type (Cn) and then echo all the chars of the input expression plus anyup to (but excluding) the start of the next real expression. It wants theecho to look like: (C1) F(X):=X+1$ /* Definition of F */ (C2) G(X):=X+2$ /* Definition of G */but if you don't have this stuff pinned down (so it can peek without echoing)you end up with: (C1) F(X):=X+1$ /* Definition of F */ G (C2) (X):=X+2$ /* Definition of G */This issue had to be dealt with for such non-interactive cases, andthe adopted technique solves the problem. The adopted technique is not intendedto be read as infringing on the possible implementations for interactiveuse for the reasons which I think you're citing -- which others cited as well.Does this make you feel any better?*start*03895 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 15:01:24 PSTReceived: from ECLC.USC.EDU by SAIL.Stanford.EDU with TCP; 13 Mar 89  15:01:49 PSTDate: Sun, 12 Mar 89 16:09:23 PSTFrom: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>Subject: Issue PEEK-CHAR-READ-CHAR-ECHOTo: kmp@SCRC-STONY-BROOK.ARPAcc: cl-cleanup@SAIL.STANFORD.EDU, iim%ECLA@ECLC.USC.EDUMessage-ID: <12477531820.30.IIM@ECLA.USC.EDU>The whole discussion of operating system considerations in the proposal justconfuses the issue, and isn't relevent to what the actual proposal says, sothat's a problem with the proposal.  It may have lead some people to vote forit because they got confused into thinking that the operating systemconsiderations were relevent.  Note that I may have fallen into this trap.When I wrote the example, I was thinking in terms of a reader that usedread-char/unread-char, rather than peek-char.  Looking at the proposal again,I note that it mentions the reader.However, I think the discussion of the cost of this proposal is pretty weak.First, an implication of the proposal is that peek-char is no longerequivelent to read-char followed by unread-char.  This means that all codewhich uses read-char/unread-char needs to be re-examined, and probablymodified.  That's a potentially large amount of code, due to the performanceeffect that is not mentioned at all in the proposal.  Namely, it is frequentlythe case when parsing input that you get stretches where all the charactersare going to be used.An example might be a reader's subroutine for reading an extended token.  Ifthe two forms of 'peeking' are equivelent, then the token reader can iterateon read-char until it finds a terminator, unreads it, and proceeds.  Underthis proposal, it has to iterate on peek-char, decide if it likes it, and ifso then read-char to really get it.  For such important subroutines in the reader as the token reader, the string reader, the whitespace scanner, and similar functions, this could mean something on the order of a factor of 2performance hit.  Slowing down important parts of the reader by a factor of2 is not likely to make anyone smile (except those C lovers out there :-).We're not advocating that it be left vague.  I should have taken the time topresent our counter-proposal, but I was in a hurry, and I've had this note onmy desk to do something about this issue for over a month now, so I didn't.Foolish me.Our position is that LAST-READ-CHAR is the proper behavior, with an additionalrestriction that it is an error to do output to a stream between the calls toread and unread.  As a hint, here is how we've implemented this behavior.1. Define two operations on streams, ECHO and UNECHO.2. echo-streams, when reading a character, apply echo to the output stream and   the character.  unread on echo-streams calls unecho on the output stream    and char, in addition to passing along the unread to the input stream.3. Other meta-streams simply pass these operations along to their output side.4. data-streams have two choices, depending on whether they have the   capability to 'back out' output.  If they can back it out, then echo is   equivilent to write-char, and unecho backs it out.  If they can't, then   they record the echo in a slot, writing any already pending echo.  unecho   clears the pending echo slot.  all normal output operations first write   pending echo.  a normal close also forces pending echoing.There is potentially more hair involved, intended to either support orcomplain about improper usage, like calling unread after peek, doing outputbetween the read and the unread, &etc.  Note that this depends on the singleunread restriction in order to work right in all cases.kab-------*start*00875 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 07:38:41 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 14 Mar 89  07:38:47 PSTReceived: from relay2.cs.net by RELAY.CS.NET id ad25718; 14 Mar 89 10:16 ESTReceived: from draper.com by RELAY.CS.NET id ag09120; 14 Mar 89 10:12 ESTDate: Tue, 14 Mar 89 08:22 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: More re: PEEK-CHAR-READ-CHAR-ECHOTo: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525Just for the record, I wouldn't wish to see any proposal adopted that didn'tsupport the notion of PEEK-CHAR being equivalent to READ-CHAR + UNREAD-CHAR.Maybe the IIM implementation solves this problem - or thinks it does - butI don't see quite how.*start*02487 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 07:38:51 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 14 Mar 89  07:38:43 PSTReceived: from relay2.cs.net by RELAY.CS.NET id ac25715; 14 Mar 89 10:16 ESTReceived: from draper.com by RELAY.CS.NET id af09120; 14 Mar 89 10:11 ESTDate: Tue, 14 Mar 89 08:19 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue PEEK-CHAR-READ-CHAR-ECHOTo: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525> From: "Kim A. Barrett" <IIM%ECLA@eclc.usc.EDU>> Subject: Issue PEEK-CHAR-READ-CHAR-ECHO> To: kmp@scrc-stony-brook.ARPA> Cc: cl-cleanup@sail.stanford.EDU, iim%ECLA@eclc.usc.EDU > 1. Define two operations on streams, ECHO and UNECHO.> 2. echo-streams, when reading a character, apply echo to the output stream and>    the character.  unread on echo-streams calls unecho on the output stream >    and char, in addition to passing along the unread to the input stream.> 3. Other meta-streams simply pass these operations along to their output side.> 4. data-streams have two choices, depending on whether they have the>    capability to 'back out' output.  If they can back it out, then echo is>    equivilent to write-char, and unecho backs it out.  If they can't, then>    they record the echo in a slot, writing any already pending echo.  unecho>    clears the pending echo slot.  all normal output operations first write>    pending echo.  a normal close also forces pending echoing.> There is potentially more hair involved, intended to either support or> complain about improper usage, like calling unread after peek, doing output> between the read and the unread, &etc.  Note that this depends on the single> unread restriction in order to work right in all cases.There SURE IS more hair involved.  All you're doing is punting the basicproblem down to a lower level.  Maybe the stream internally takes the actualsend-the-character-to-the-output-stream and implements it via SEND-OUT andUN-SEND-OUT calls, where SEND-OUT buffers the character in case an UN-SEND-OUTcomes along... In the 'foo(* a b) example, when the ( is seen, either it gets echoed at that point or itdoesn't.  This ECHO/UNECHO stuff doesn't change anything.  And posing arestriction on stream output between READ and UNREAD is unreasonable,in my opinion.*start*01539 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 14-Mar-89 09:28:31 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 09:23:23 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 14 Mar 89  09:23:21 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 556600; Tue 14-Mar-89 12:11:10 ESTDate: Tue, 14 Mar 89 12:11 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: More re: PEEK-CHAR-READ-CHAR-ECHOTo: "Steve Bacher (Batchman)" <SEB1525@draper.com>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: The message of 14 Mar 89 08:22 EST from "Steve Bacher (Batchman)" <SEB1525@draper.com>Message-ID: <19890314171109.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 14 Mar 89 08:22 EST    From: "Steve Bacher (Batchman)" <SEB1525@draper.com>    Just for the record, I wouldn't wish to see any proposal adopted that didn't    support the notion of PEEK-CHAR being equivalent to READ-CHAR + UNREAD-CHAR.Such a proposal was already adopted in January by an 11 to 5 vote.  To clarifythe double negatives, PEEK-CHAR-READ-CHAR-ECHO as adopted in January eliminatesthe equivalence of PEEK-CHAR to READ-CHAR+UNREAD-CHAR, but only when peekingfrom a stream created by MAKE-ECHO-STREAM.We can reconsider anything, of course, if that's how we want to spend our time.*start*01074 00024 US Date:  4 Apr 89 12:40 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: PEEK-CHAR-READ-CHAR-ECHOTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PEEK-CHAR-READ-CHAR-ECHOTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:35:16 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:31:23 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571244; Tue 4-Apr-89 15:31:19 EDTOriginal-Date: Tue, 4 Apr 89 15:30 EDTMessage-ID: <890404153055.6.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVKim Barrett mentioned again that he wants to reopen this, but nothingwas done at this meeting.