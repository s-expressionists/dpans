*start*04091 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 JAN 88 12:47:16 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Jan 88  12:44:38 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 328834; Tue 26-Jan-88 15:44:51 ESTDate: Tue, 26 Jan 88 15:44 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REMF-MULTIPLETo: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880126154442.7.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        REMF-MULTIPLEReferences:   REMPROP (p166), REMF (p167)Category:     CLARIFICATIONEdit history: 26-Jan-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  The descriptions of REMF and REMPROP are not explicit about what happens in  the case that a duplicated indicator occurs on the plist. One or both indicators  might be removed.Proposal (REMF-MULITPLE:REMOVE-ONE):  Clarify that REMF and REMPROP at most one indicator/value pair from the designated plist.  Rationale:    In a property list maintained by the normal property list operations, there will    only be one property by each name. This approach won't waste time trying to remove    other properties which are not present in the first place.Proposal (REMF-MULTIPLE:REMOVE-ALL):  Clarify that REMF and REMPROP remove all matching indicator/value pairs from the  designated plist.  Rationale:    In a property list maintained by other operations than the standard ones,    this might be useful. Also, since the return value of REMF and REMPROP is    not well-defined, iterating to remove more than one property is expensive    because you have to start over from the head of the list.Test Case:  ;; Case #1 - removing symbol properties,etc. using REMPROP  (DEFUN REMF-MULTIPLE-TEST-1 ()    (LET ((SYMBOL (GENSYM)))      (SETF (SYMBOL-PLIST SYMBOL) (LIST 'A 'B 'C 'D 'A 'B 'C 'D))      (FORMAT T "~&Before: ~S~%" (SYMBOL-PLIST SYMBOL))      (REMPROP SYMBOL 'A)      (FORMAT T "~&After:  ~S~%" (SYMBOL-PLIST SYMBOL))      (FORMAT T "~&This implementation uses REMF-MULTIPLE:~:[REMOVE-ALL~;REMOVE-ONE~] ~		   for REMPROP.~%"	      (GET SYMBOL 'A))))  ;; Case #2 - removing keywords,etc. using REMF  (DEFUN REMF-MULTIPLE-TEST-2 ()    (LABELS ((HELPER (&REST ARGUMENTS &KEY (A 1) (B 2))	       (FORMAT T "~&Helper received: ~S~%" ARGUMENTS)	       (LIST A B))	     (DRIVER (&REST ARGUMENTS)	       (FORMAT T "~&Helper received: ~S~%" ARGUMENTS)	       (SETQ ARGUMENTS (COPY-LIST ARGUMENTS))	       (REMF ARGUMENTS ':A)	       (APPLY #'HELPER ARGUMENTS)))      (LET ((RESULT (DRIVER :A 3 :B 4 :A 5 :B 6)))	(FORMAT T "~&Returned: ~S~%" RESULT)	(FORMAT T "~&This implementation uses REMF-MULTIPLE:~:[REMOVE-ALL~;REMOVE-ONE~] ~		     for REMF.~%"		(= (CAR RESULT) 5)))))Current Practice:  Symbolics implements REMF-MULTIPLE:REMOVE-ONE.Cost to Implementors:  For implementations needing to change, the cost of a change is probably very  small in most cases. Implementations needing change which do REMPROP and/or REMF  in microcode might have a slightly harder time, but any change should still be  very localized.Cost to Users:  None. Users must tread lightly on this issue right now because it is not well-defined.Cost of Non-Adoption:  The language description would continue to be vague for no particularly good reason.Benefits:  Users who want to use REMPROP or REMF in situations which involve lists that might  have duplicated elements would be able to do so more reliably.Aesthetics:  There is probably no particular aesthetic reason to think one of these solutions  is better than the other, but having the issue nailed down is probably an aesthetic  improvement.Discussion:  Pitman is agnostic on this for now. There are advantages to both.  If everybody already implements REMOVE-ONE, that would seem the way to go.*start*01237 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 FEB 88 07:58:16 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 3 Feb 88  07:55:51 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 334269; Tue 2-Feb-88 20:28:42 ESTDate: Tue, 2 Feb 88 20:28 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REMF-MULTIPLETo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880126154442.7.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19880203012838.5.MOON@EUPHRATES.SCRC.Symbolics.COM>I favor withdrawal of the REMF-MULTIPLE issue.Here's why: The only thing that CLtL pages 163-167 says aboutduplicated indicators on plists is that there aren't any(first line on page 164).  Contrary to what I thought, it doesnot even guarantee that GETF returns the first occurrence.If we're going to extend Common Lisp to allow duplicated indicators onplists, we should do it for all the property list functions, notjust REMF and REMPROP.*start*01578 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 23:29:02 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  23:28:13 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 DEC 88 23:27:28 PSTDate: 8 Dec 88 23:27 PSTFrom: masinter.paSubject: Re: Issue: REMF-MULTIPLE (Version 1)to: cl-cleanup@sail.stanford.eduMessage-ID: <881208-232728-5502@Xerox>In reviewing the issues, I've forgotten why we let this one slip, exceptexhaustion.  The issue was "The descriptions of REMF and REMPROP are notexplicit about what happens in the case that a duplicated indicator occurson the plist. One or both indicators might be removed."I would favor a proposal that said that REMF, GETF when dealing with liststhat act as property lists act on the first element that they find, andthat duplicate elements are allowed.This is consistent with Moon's assertion:"The only thing that CLtL pages 163-167 says about duplicated indicators onplists is that there aren't any (first line on page 164).  Contrary to whatI thought, it does not even guarantee that GETF returns the firstoccurrence.If we're going to extend Common Lisp to allow duplicated indicators onplists, we should do it for all the property list functions, not just REMFand REMPROP."but not with the conclusion we reached based on it.Maybe I'm asking for trouble re-raising issues at this late date. I'll putthis on the list of "Issues not resolved"*start*04950 00024 US Date: 12 Jan 89 15:05 PSTSender: masinter.paSubject: Issue: REMF-MULTIPLE (Version 2)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinterline-fold: NoStatus: DRAFTIssue:        REMF-MULTIPLEReferences:   REMPROP (p166), REMF (p167)Category:     CLARIFICATION/CHANGEEdit history: 26-Jan-88, Version 1 by Pitman            12-Jan-89, Version 2 by Masinter (add IS-ERROR per Moon)Problem Description:  The descriptions of REMF and REMPROP are not explicit about what happens in  the case that a duplicated indicator occurs on the plist. One or both indicators  might be removed.Proposal (REMF-MULITPLE:REMOVE-ONE):  Clarify that REMF and REMPROP at most one indicator/value pair from the designated plist.  Rationale:    In a property list maintained by the normal property list operations, there will    only be one property by each name. This approach won't waste time trying to remove    other properties which are not present in the first place.Proposal (REMF-MULTIPLE:REMOVE-ALL):  Clarify that REMF and REMPROP remove all matching indicator/value pairs from the  designated plist.  Rationale:    In a property list maintained by other operations than the standard ones,    this might be useful. Also, since the return value of REMF and REMPROP is    not well-defined, iterating to remove more than one property is expensive    because you have to start over from the head of the list.Proposal (REMF-MULTIPLE:IS-AN-ERROR):    Clarify that it "is an error" to pass a list with a duplicated     indicator to REMF or any other function that takes a    property list (including GETF); it "is an error" for a     symbol to have duplicated properties on its property list.  Rationale:	The only thing that CLtL pp 163-167 says about	duplicated indicators on plists is that there aren't any	(first line on page 164). It does not even gurantee 	that GETF returns the first occurrence.Test Case:  ;; Case #1 - removing symbol properties,etc. using REMPROP  (DEFUN REMF-MULTIPLE-TEST-1 ()    (LET ((SYMBOL (GENSYM)))      (SETF (SYMBOL-PLIST SYMBOL) (LIST 'A 'B 'C 'D 'A 'B 'C 'D))      (FORMAT T "~&Before: ~S~%" (SYMBOL-PLIST SYMBOL))      (REMPROP SYMBOL 'A)      (FORMAT T "~&After:  ~S~%" (SYMBOL-PLIST SYMBOL))      (FORMAT T "~&This implementation uses REMF-MULTIPLE:~:[REMOVE-ALL~;REMOVE-ONE~] ~		   for REMPROP.~%"	      (GET SYMBOL 'A))))  ;; Case #2 - removing keywords,etc. using REMF  (DEFUN REMF-MULTIPLE-TEST-2 ()    (LABELS ((HELPER (&REST ARGUMENTS &KEY (A 1) (B 2))	       (FORMAT T "~&Helper received: ~S~%" ARGUMENTS)	       (LIST A B))	     (DRIVER (&REST ARGUMENTS)	       (FORMAT T "~&Helper received: ~S~%" ARGUMENTS)	       (SETQ ARGUMENTS (COPY-LIST ARGUMENTS))	       (REMF ARGUMENTS ':A)	       (APPLY #'HELPER ARGUMENTS)))      (LET ((RESULT (DRIVER :A 3 :B 4 :A 5 :B 6)))	(FORMAT T "~&Returned: ~S~%" RESULT)	(FORMAT T "~&This implementation uses REMF-MULTIPLE:~:[REMOVE-ALL~;REMOVE-ONE~] ~		     for REMF.~%"		(= (CAR RESULT) 5)))))Current Practice:  Symbolics implements REMF-MULTIPLE:REMOVE-ONE.Cost to Implementors:  For implementations needing to change, the cost of a change is probably very  small in most cases. Implementations needing change which do REMPROP and/or REMF  in microcode might have a slightly harder time, but any change should still be  very localized.Cost to Users:  None. Users must tread lightly on this issue right now because it is not well-defined.Cost of Non-Adoption:  The language description would continue to be vague for no particularly good reason.Benefits:  IS-ERROR at least makes the situation more explicit. For the other proposals,  users who want to use REMPROP or REMF in situations which involve lists that might  have duplicated elements would be able to do so more reliably.Aesthetics:  There is probably no particular aesthetic reason to think one of these solutions  is better than the other, but having the issue nailed down is probably an aesthetic  improvement.Discussion:   This issue, first brought up in Cleanup almost a year ago, got lost.  Pitman is agnostic on this for now. There are advantages to both.  If everybody already implements REMOVE-ONE, that would seem the way to go."If we're going to extend Common Lisp to allow duplicated indicators onplists, we should do it for all the property list functions, notjust REMF and REMPROP."        TITAN 
         TITAN 
           å                                                               e              ·       %       ^              í       %       i             *       &       ú              Ë             I              3                           [              Y       
       è              º             €        (zº*start*04861 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 15:40:09 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Jan 89  15:24:48 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 JAN 89 15:11:46 PSTDate: 12 Jan 89 15:05 PSTSender: masinter.paSubject: Issue: REMF-MULTIPLE (Version 2)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinter.paline-fold: NoMessage-ID: <890112-151146-1173@Xerox>!Status: DRAFTIssue:        REMF-MULTIPLEReferences:   REMPROP (p166), REMF (p167)Category:     CLARIFICATION/CHANGEEdit history: 26-Jan-88, Version 1 by Pitman            12-Jan-89, Version 2 by Masinter (add IS-ERROR per Moon)Problem Description:  The descriptions of REMF and REMPROP are not explicit about what happens in  the case that a duplicated indicator occurs on the plist. One or both indicators  might be removed.Proposal (REMF-MULITPLE:REMOVE-ONE):  Clarify that REMF and REMPROP at most one indicator/value pair from the designated plist.  Rationale:    In a property list maintained by the normal property list operations, there will    only be one property by each name. This approach won't waste time trying to remove    other properties which are not present in the first place.Proposal (REMF-MULTIPLE:REMOVE-ALL):  Clarify that REMF and REMPROP remove all matching indicator/value pairs from the  designated plist.  Rationale:    In a property list maintained by other operations than the standard ones,    this might be useful. Also, since the return value of REMF and REMPROP is    not well-defined, iterating to remove more than one property is expensive    because you have to start over from the head of the list.Proposal (REMF-MULTIPLE:IS-AN-ERROR):    Clarify that it "is an error" to pass a list with a duplicated     indicator to REMF or any other function that takes a    property list (including GETF); it "is an error" for a     symbol to have duplicated properties on its property list.  Rationale:	The only thing that CLtL pp 163-167 says about	duplicated indicators on plists is that there aren't any	(first line on page 164). It does not even gurantee 	that GETF returns the first occurrence.Test Case:  ;; Case #1 - removing symbol properties,etc. using REMPROP  (DEFUN REMF-MULTIPLE-TEST-1 ()    (LET ((SYMBOL (GENSYM)))      (SETF (SYMBOL-PLIST SYMBOL) (LIST 'A 'B 'C 'D 'A 'B 'C 'D))      (FORMAT T "~&Before: ~S~%" (SYMBOL-PLIST SYMBOL))      (REMPROP SYMBOL 'A)      (FORMAT T "~&After:  ~S~%" (SYMBOL-PLIST SYMBOL))      (FORMAT T "~&This implementation uses REMF-MULTIPLE:~:[REMOVE-ALL~;REMOVE-ONE~] ~		   for REMPROP.~%"	      (GET SYMBOL 'A))))  ;; Case #2 - removing keywords,etc. using REMF  (DEFUN REMF-MULTIPLE-TEST-2 ()    (LABELS ((HELPER (&REST ARGUMENTS &KEY (A 1) (B 2))	       (FORMAT T "~&Helper received: ~S~%" ARGUMENTS)	       (LIST A B))	     (DRIVER (&REST ARGUMENTS)	       (FORMAT T "~&Helper received: ~S~%" ARGUMENTS)	       (SETQ ARGUMENTS (COPY-LIST ARGUMENTS))	       (REMF ARGUMENTS ':A)	       (APPLY #'HELPER ARGUMENTS)))      (LET ((RESULT (DRIVER :A 3 :B 4 :A 5 :B 6)))	(FORMAT T "~&Returned: ~S~%" RESULT)	(FORMAT T "~&This implementation uses REMF-MULTIPLE:~:[REMOVE-ALL~;REMOVE-ONE~] ~		     for REMF.~%"		(= (CAR RESULT) 5)))))Current Practice:  Symbolics implements REMF-MULTIPLE:REMOVE-ONE.Cost to Implementors:  For implementations needing to change, the cost of a change is probably very  small in most cases. Implementations needing change which do REMPROP and/or REMF  in microcode might have a slightly harder time, but any change should still be  very localized.Cost to Users:  None. Users must tread lightly on this issue right now because it is not well-defined.Cost of Non-Adoption:  The language description would continue to be vague for no particularly good reason.Benefits:  IS-ERROR at least makes the situation more explicit. For the other proposals,  users who want to use REMPROP or REMF in situations which involve lists that might  have duplicated elements would be able to do so more reliably.Aesthetics:  There is probably no particular aesthetic reason to think one of these solutions  is better than the other, but having the issue nailed down is probably an aesthetic  improvement.Discussion:   This issue, first brought up in Cleanup almost a year ago, got lost.  Pitman is agnostic on this for now. There are advantages to both.  If everybody already implements REMOVE-ONE, that would seem the way to go."If we're going to extend Common Lisp to allow duplicated indicators onplists, we should do it for all the property list functions, notjust REMF and REMPROP."*start*16584 00024 US Date: 12 Jan 89 16:26 PSTSender: masinter.paSubject: Issue: REMF-DESTRUCTION-UNSPECIFIED (Version 4)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinterline-fold: NoThis issue has a number of additional comments at the end. Status: DRAFTForum: CleanupIssue:        REMF-DESTRUCTION-UNSPECIFIEDReferences:   (SETF (GET ...) ...), REMPROP, (SETF (GETF ...) ...),	      REMF (pp165-167); NREVERSE (p248); DELETE, DELETE-IF,	      DELETE-IF-NOT, DELETE-DUPLICATES, NSUBSTITUTE, 	      NSUBSTITUTE-IF, NSUBSTITUTE-IF-NOT (pp254-256); NCONC,	      NRECONC (p269); NBUTLAST (p271); NSUBST, NSUBST-IF,	      NSUBST-IF-NOT (p274); NUNION, NINTERSECTION,	      NSET-EXCLUSIVE-OR (pp276-279).Category:     CLARIFICATION/CHANGEEdit history: 11-Feb-87, Version 1 by Dave Andre (DLA@Symbolics.COM)	      29-Oct-87, Version 2 by Pitman (flesh out proposals)	      28-Nov-88, Version 3 by Pitman (revised presentation)	      29-Nov-88, Version 4 by Pitman (slight editing per DLA)Problem Description: Currently, the exact nature of the side-effect performed by list modification routines is not specified. Either the specific modifications allowed should be specified so that programmers can rely on them and implementors can avoid accidentally causing problems by introducing well-meaning optimizations, or else the documentation should explicitly state that the effects are unspecified so that programmers will not depend on them and  implementors will feel comfortable about doing interesting optimizations.Proposal (REMF-DESTRUCTION-UNSPECIFIED:EXPLICITLY-VAGUE): Clarify that the way in which the destructive behavior of the operators below is achieved is explicitly vague in a number of ways, in order to provide individual implementations the necessary flexibility to do useful optimizations. (SETF (GETF place indicator) value)  is permitted to either SETF place or to SETF any part, CAR or  CDR, of the top-level list structure held by that place. (REMF place indicator)  is permitted to either SETF place or to SETF any part, CAR or  CDR, of the top-level list structure held by that place. (SETF (GET symbol indicator) value)  is constrained to behave exactly the same as  (SETF (GETF (SYMBOL-PLIST symbol) indicator) value). (REMPROP symbol indicator)  is constrained to behave exactly the same as  (REMF (SYMBOL-PLIST symbol) indicator). (NREVERSE sequence)  when sequence is a list, is permitted to SETF any part, CAR or   CDR, of the top-level list structure in that sequence.  when sequence is an array is permitted to re-order the elements   of the given sequence in order to produce the resulting array. (DELETE object sequence ...)  when sequence is a list, is permitted to SETF any part, CAR or   CDR, of the top-level list structure held in that sequence.  when sequence is an array is permitted to change the dimensions   of the array and to slide its elements into new positions without   permuting them to produce the resulting array.   (DELETE-IF test sequence ...)  is constrained to behave exactly like  (DELETE NIL sequence	  :TEST #'(LAMBDA (IGNORE ITEM) (FUNCALL test ITEM))	  ...). (DELETE-IF-NOT test sequence ...)  is constrained to behave exactly like  (DELETE NIL sequence	  :TEST #'(LAMBDA (IGNORE ITEM) (NOT (FUNCALL test ITEM)))	  ...). (DELETE-DUPLICATES sequence ...)  when sequence is a list, is permitted to SETF any part, CAR or   CDR, of the top-level list structure held in that sequence.  when sequence is an array is permitted to change the dimensions   of the array and to slide its elements into new positions without   permuting them to produce the resulting array. (NSUBSTITUTE new-object old-object sequence ...) (NSUBSTITUTE-IF new-object test sequence ...) (NSUBSTITUTE-IF-NOT new-object test sequence ...)  when sequence is a list, is permitted to SETF any part, CAR or   CDR, of the top-level list structure in that sequence.  when sequence is an array is permitted to SETF the contents of   any cell in that array which must be replaced by NEW-OBJECT.  Note, however, that since this side-effect is not required,  these functions should still not be used in for-effect-only  positions in portable code. (NCONC . lists)  is permitted to SETF any part, CAR or CDR, of the top-level of  any of the given lists (except the last, which is not required to  be a list and must not be modified). (NRECONC list tail)  is constrained to have side-effect behavior equivalent to:  (NCONC (NREVERSE list) tail). (NBUTLAST list ...)  is permitted to SETF any part, CAR or CDR, of the top-level of  any of the given list. (NSUBST new-object old-object tree) (NSUBST-IF new-object test tree)  (NSUBST-IF-NOT new-object test tree)  is permitted to SETF any part of the TREE of conses which must  be replaced by NEW-OBJECT.  Note, however, that since the tree might be a degenerate tree  containing no conses and since the side-effect is not required,  these functions should still not be used in for-effect-only  positions in portable code. (NUNION list1 list2 ...) (NINTERSECTION list1 list2 ...) (NSET-EXCLUSIVE-OR list1 list2 ...)  is permitted to SETF any part, CAR or CDR, of the top-level of  any of the given lists.  Note, however, that since this side-effect is not required,  these functions should still not be used in for-effect-only  positions in portable code. Note: The above clarifications are not intended as complete functional descriptions. They are intended to augment (rather than to replace) other descriptions already in effect.Test Cases: For GETF...    (SETQ FOO (LIST 'A 'B 'C 'D 'E 'F))    ==> (A B C D E F)    (SETQ BAR (CDDR FOO))                  ==> (C D E F)    (REMF FOO 'C)    BAR				           ==> ??    In Symbolics Common Lisp, BAR holds (C D E F).    CLtL allows other interpretations. eg, BAR might hold    (C), (NIL), (C NIL) or (C D).    Under this proposal, any of these interpretations (and others as well)    would still be valid For DELETE...    (SETQ FOO (LIST 'A 'B 'C))   ==> (A B C)    (SETQ BAR (CDR FOO))         ==> (B C)    (SETQ FOO (DELETE 'B FOO))   ==> (A C)    BAR                          ==> ??    (EQ (CDR FOO) (CAR BAR))     ==> ??    In Symbolics Common Lisp, these last two expressions return ((C)) and T.    Under this proposal, either of these interpretations (and others    as well) would be valid.Rationale: Implementations already vary widely on their implementation techniques for these functions. This effectively clarifies the status quo, making it more clear to programmers what they may rely upon in portable code.Current Practice: All valid implementations are believed to comply.Cost to Implementors: None. This is the status quo for implementors.Cost to Users: This change would not affect programs coded with "good programming practice".  That is, only programs which rely on currently undocumented features would be in any danger of breaking.  In fact, those programs are already in such danger, and this change to the documentation would just publicize it.  The clarification would -encourage- good programming practice by warning people to only obey the published contract of the above-mentioned functions. There is, however, no automatic technique for making this check for programs already in error. Bugs due to unexpected side-effects are in general among the hardest to reckon with.Cost of Non-Adoption: Programmers may naively believe there is only one possible or reasonable implementation of these functions. Some implementors may shy away from reasonable optimizations out of a paranoid belief that deviating from  some vague, unspoken rules will lead to programmer unrest. Making these things explicitly vague clarifies the implementor's rights in a way that permits numerous useful optimizations.Benefits:  Users would be discouraged from taking advantage of subtle details of these destructive operations because such details would be explicitly not guaranteed to be portable. Implementations can improve performance of many of the above-mentioned functions when they are not under the constraint to implement them in a highly constrained fashion. For example, in Symbolics systems, DELETE of a cdr-coded list could use the implementation primitive %CHANGE-LIST-TO-CONS rather than RPLACD to avoid creating forwarding pointers. Garbage collection effectiveness can also be improved. For example, all of the destructive operations which remove objects (eg, REMF) could remove CAR pointers to removed objects which are more volatile than the list itself, assisting the garbage collector and thereby improving memory usage and paging performance.Non-Benefits: Users who inadvertently depend on side-effect behavior may be rudely surprised when moving between implementations. Compatibility with older Lisp dialects is diminished.Performance Impact: Metering in Symbolics test  systems have shown that there are substantial performance gains to be had by allowing implementations flexibility in these areas.Aesthetics: Most of these functions implement abstract operations. For example, REMPROP implements an abstract operation on a "property list". Proper language design should not encourage people to delve below the level of abstraction into the nitty gritty.Discussion: Andre's original version of this proposal pushed for explicitly vague descriptions of these functions' side-effect behavior.  He believes that if users want more predictability from these functions, they should write private variants that implement whatever predictability they require.  Pitman originally opposed this position because he weighed portability a higher concern. Since the original discussion, however, his views on how to resolve this priority have been refined, and he now believes that leaving things vague is appropriate. As such, he now supports what is effectively Andre's original proposal. Pitman and Andre support this proposal.Additional Comments:"...I'd like to see a section in the spec that concerns these    "destructive" operations to say explicity that it is perfectly    all right for them _not_ to destroy anything but instead to    "cons" new results. ... Change "the destructive behavior of the operators" to say"if any". Change the proposal by... - striking the three or so places that it explicitly reminds you   to use SETQ in case a side-effect doesn't occur - adding some general purpose verbiage that says something like   that the purpose of these operators is to provide you the most   efficient algorithm, and that in some situations or some    implementations, there may be some reasons why the most   efficient thing is to copy rather than to side-effect. As such   none of these operators are actually required to side-effect,   but the user should assume that, whatever the implementation, it   will have speed competitive with or surpassing a side-effecting   implementation. SORT, STABLE-SORT, and MERGE are conspicuouslyabsent from the list. They should be added in as well.Should NCONC and NBUTLAST be explicitly vague?Whereas it seems less useful to maintain the actual list substructure in (SETF (GETF ...) ...), DELETE, NREVERSE, NSUBSTITUTE, etc, I can see a very useful role for the specific semantics of these few -- that they change the cdr of a particularcons cell -- and would question very highly the value of striving for speed at the cost of correct semantics.NSUBLIS seems to be missing; but I would classify it in with NSUBST,NCONC and NBUTLAST of the previous paragraph.- - - - -  SETF of GETF, REMF should be specified.NCONC, NBUTLAST, NSUBLIS, NSUBST, NSUBST-IF, NSUBST-IF-NOTshould be specified.Since the argument for explicitly-defined is portability and the utility ofreliable definitions, and the argument for explicitly-vague is performance,we should leave things explicitly vague only where a) it matters for performance and b) reasonable programs would not rely on the    "defined" behaviorI believe the things I say should be explicitly-vague are the ones wheregood style would avoid depending on side-effect behavior and whereperformance matters, while the ones I say should be explicitly-defined,there are reasonable applications which might rely on the explicitdefinition, and no strong claims that "explicitly-vague" can make adifference in performance.- - - - - - - - -The NSUBSTITUTE functions seem so "obvious" in implementation that itseems hard to justify not explicitly specifying them.  Seems to methatclassifying the sequence functions as a group is not of anysignificance.  There really are only three basic sequence functionslisted there and they are all quite different, and for differentreasons:  NREVERSE wants to be explicitly-vague primarily because of thelist reversal, and for that primarily because of optimizations neededfor cdr-coded implementations; DELETE because ofcdr-deleted-element-off-front-of-list for lists andwe've-got-to-copy-the-non-adjustable-array for vectors; NSUBSTITUTE Ican only imagine so that an implementation could "cheat" and useSUBSTITUTE, or just because it is a destructive sequence function.- - - - - - - - - - -Where you say (REMF place indicator)  is permitted to either SETF place or to SETF any part, CAR or  CDR, of the top-level list structure held by that place.you also need to say that it is an error after this operation toreference any CONS that was formerly part of the top-level liststructure and is no longer part of it.  Of course this applies notjust to REMF, but also to SETF of GETF, NREVERSE, DELETE,DELETE-DUPLICATES, NCONC, NUNION, NINTERSECTION, NSET-EXCLUSIVE-OR,SORT, STABLE-SORT, and MERGE and to the ones that are defined to beequivalent to these; these are all the ones that might changelist structure rather than just replacing CAR elements.You see, not only are these destructive functions allowed to changethe components of the conses that make up the top-level list structureof the argument, they are also allowed to reuse the storage of thoseconses for something else that isn't a cons at all.  You may recallthat this was DLA's original motivation for bringing up the issue.I strongly disagree with Larry's contention that SETF of GETF, REMF,SETF of GET, and REMPROP are not reasonable to include in this proposal.If anything, the property list operators have less justification for theuser to depend on the representation than (for example) DELETE, not morejustification.I disagree with JonL's and Larry's contention that NBUTLAST is notreasonable to include in this proposal.  I think it would be reasonableto implement NBUTLAST by sliding all the list elements to the right npositions and then returning NTHCDR n of the original list.  However,CLtL p.271 could be interpreted as -requiring- NBUTLAST to beimplemented in terms of RPLACD of a specific cons, rather than justmentioning that as an example; if so, I would change my mind andagree that NBUTLAST should be excluded from this proposal.I also believe that NCONC (and hence by implication NRECONC) isreasonable to optimize, but on that point I could easily be swayed tochange my mind since I can't think of any really plausibleoptimizations.  However, CLtL doesn't offer much evidence that aspecific implementation of NCONC is required.For the others Larry listed (NSUBST, NSUBST-IF, and NSUBST-IF-NOT), whatthe proposal actually says ("is permitted to SETF any part of the TREEof conses which must be replaced by NEW-OBJECT.") is not proposing toallow an implementation to modify any portion of a cons other than whatCLtL requires it to modify.  Perhaps that means there is no reason toinclude these in the proposal because the proposal says exactly the samething about these that CLtL says.  BTW CLtL appears to -require- aside-effect for these rather than merely -allowing- a side-effect.        TITAN 
         TITAN 
           >              á       	                           }                            ð             	       :      »             =              Ú              5              2             ƒ             —             X              °              £              û             œ             L      ? (zº*start*00899 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 12 JAN 89 19:17:19 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 520742; Thu 12-Jan-89 22:16:46 ESTDate: Thu, 12 Jan 89 22:16 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REMF-MULTIPLE (Version 2)To: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <890112-151146-1173@Xerox>Message-ID: <890112221635.6.KMP@BOBOLINK.SCRC.Symbolics.COM>I am pretty sure I had agreed to withdraw this issue base don Moon'scriticism.  CLtL is already clear that plists cannot have duplicatedentries.  As such, there is no ambiguity and no need to waste time onthis.  I think you should send mail to X3J13 saying that the issue hadbeen withdrawn.*start*00952 00024 USaReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 12 JAN 89 21:11:06 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 520784; Fri 13-Jan-89 00:10:23 ESTDate: Fri, 13 Jan 89 00:10 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REMF-MULTIPLE (Version 2)To: masinter.pacc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <890112-151146-1173@Xerox>Message-ID: <19890113051016.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI'll leave X3J13 off my reply.Symbolics' records say this issue was withdrawn because it's meaningless(it applies only in a situation that CLtL says cannot happen).  So I don'tknow why you're suddenly mailing it out to X3J13.  Maybe you're as tiredas I am after being inundated with hundreds of messages a day for weekson end.*start*00803 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 10:39:53 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Jan 89  10:39:15 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 13 JAN 89 10:31:04 PSTDate: 13 Jan 89 10:30 PSTFrom: masinter.paSubject: Re: Issue: REMF-MULTIPLE (Version 2)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 13 Jan 89 00:10 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <890113-103104-2989@Xerox>I've already sent off the new issues to be hardcopied.  Yes, I'm pretty tired ...We'll can just not bring it up at X3J13. Sorry.