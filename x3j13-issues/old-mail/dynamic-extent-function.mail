*start*04085 00024 US Date:  4 Apr 89 10:32 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: sandra%defun%cs.utah:EDU:XeroxSubject: issue DYNAMIC-EXTENT-FUNCTION, version 1To: cl-cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Subject: issue DYNAMIC-EXTENT-FUNCTION, version 1To: cl-cleanup@sail.stanford.eduReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 10:30:17 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 4 Apr 89  10:27:27 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA29744; Tue, 4 Apr 89 11:27:25 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA19101; Tue, 4 Apr 89 11:27:23 -0600Message-Id: <8904041727.AA19101@defun.utah.edu>Original-Date: Tue, 4 Apr 89 11:27:21 MDTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVAs promised, here's a first cut at this issue.  I'm not particularlyattached to the name DYNAMIC-EXTENT-FUNCTION, but I'm still feelingtoo burned out from arguing over what to rename DEFPROCLAIM to want towaste a lot of time on thinking up alternate names for this one too. :-(Forum:		CLEANUPIssue:          DYNAMIC-EXTENT-FUNCTIONReferences:     Scope and Extent		Issue DYNAMIC-EXTENTCategory:       ADDITIONEdit history:   04-Apr-89, Version 1 by LoosemoreProblem Description:  Proposal DYNAMIC-EXTENT:NEW-DECLARATION, passed at the March 89   meeting, provides a mechanism for declaring that the values of  variables have only dynamic (rather than indefinite) extent.  It  would be useful to have similar functionality to indicate that  functional bindings may have only dynamic extent.  (For example,  this would permit compilers to stack-allocate closures.)Proposal (DYNAMIC-EXTENT:NEW-DECLARATION):  Introduce a new declaration called DYNAMIC-EXTENT-FUNCTION.  This is  identical to the DYNAMIC-EXTENT declaration, except that the  arguments name functions instead of variables.Rationale:  This permits a programmer to offer advice to an implementation about  what functions may be stack-allocated for efficiency.  It may be difficult or impossible for a compiler to infer this  same information statically.Current Practice:  JonL says that Lucid's compiler can stack-allocate closures, but they  have no mechanism for programmers to give the compiler permission to  do so.  HPCL-I has an UPWARD-CLOSURES declaration that pervasively affects  all closures created within the scope of the declaration.Cost to Implementors:  No cost is forced since implementations are permitted to simply  ignore the DYNAMIC-EXTENT-FUNCTION declaration.Cost to Users:  None. This change is upward compatible.  There may be some hidden costs to debugging using this declaration (or any  feature which permits the user to access dynamic extent objects without  the compiler proving that they are appropriate). If the user misdeclares  something and returns a pointer into the stack (or stores it in the heap),  an undefined situation may result and the integrity of the Lisp storage  mechanism may be compromised. Debugging these situations may be tricky,  but users who have asked for this feature have indicated a willingness  to deal with such costs. Nevertheless, the perils should be clearly  documented and casual users should not be encouraged to use this  declaration.Cost of Non-Adoption:  Some portable code would be forced to run more slowly (due to  GC overhead), or to use non-portable language features.Benefits:  The cost of non-adoption is avoided.Aesthetics:  This declaration allows a fairly low level optimization to work  by asking the user to provide only very high level information.  The alternatives (sharpsign conditionals, some of which may  lead to more bit-picky abstractions) are far less aesthetic.Discussion:  Loosemore supports DYNAMIC-EXTENT-FUNCTION:NEW-DECLARATION.-------*start*04549 00024 US Date:  4 Apr 89 13:50 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: issue DYNAMIC-EXTENT-FUNCTION, version 1In-Reply-to: <8904041727.AA19101@defun.utah.edu>To: sandra%defun%cs.utah:EDU:Xeroxcc: cl-cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue DYNAMIC-EXTENT-FUNCTION, version 1To: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8904041727.AA19101@defun.utah.edu>Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 13:25:41 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  13:24:20 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571355; Tue 4-Apr-89 16:23:51 EDTOriginal-Date: Tue, 4 Apr 89 16:23 EDTMessage-ID: <19890404202338.6.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVComments on current practice:This is very different from Symbolics Genera current practice, whichI would describe as follows:First, if a function A has a DYNAMIC-EXTENT declaration for one of itsparameters F, and a caller of A passes a function B as the argumentcorresponding to the parameter F, then B is used in a "downward" way.Calling a function directly or via FUNCALL or APPLY is a "downward" usetoo.  If every use of a function is "downward", then the compilerimplements the function with dynamic extent (provided the function isnot globally named, but is only locally named or not named at all, i.e.defined with FLET, LABELS, or LAMBDA).  We currently use a differentname for the declaration, instead of DYNAMIC-EXTENT, but that isunimportant.Does the compiler committee's model of compilation permit compilation ofone function to be affected by declarations in the current definition ofanother function that it calls?  I hope so.Second, if a function has a SYS:DOWNWARD-FUNCTION declaration in front ofits body, then the function is implemented with dynamic extent regardlessof whether the compiler thinks all uses are "downward".  This feature isused less often than the first feature, but is still used pretty often.An example would be  (funcall (computation-that-returns-a-function)           (function (lambda (...)                       (declare (sys:downward-function))                       ...))           ...other args...)Here the function being called is not known at compile time, so thereis no place from which to obtain a DYNAMIC-EXTENT declaration.  Inyour proposal, the declaration cannot be made unless the function isgiven a name, so this example would have to be rewritten as:  (flet ((dummy-name (...)           ...))    (declare (dynamic-extent-function dummy-name))    (funcall (computation-that-returns-a-function)             (function dummy-name)             ...other args...))Third, there is a variation of the first feature by which a function candeclare that all of its arguments are used "downward"; this isespecially useful for declaring arguments that are elements of a listthat is the value of an &rest parameter, since there is no parametername corresponding to those arguments.  We do this by using * instead ofa parameter name, but I don't see any way to map that into theDYNAMIC-EXTENT declaration.  However, if we were willing to say that the&rest list also had to have dynamic extent in this case, then aDYNAMIC-EXTENT declaration of the &rest parameter would imply downwarduse of the functions, since otherwise they would not be OIPs (in thelanguage of the amended DYNAMIC-EXTENT proposal that we just passed).So I don't think we need this third feature.The fact that your proposal is different from Symbolics Genera currentpractice doesn't mean the proposal is wrong, after all it is also verydifferent from the current practices of the two implementations listedin the proposal.  But we should think hard about dynamic extent foranonymous lambdas, which can be quite important in practice.On a sillier note, should we minimize proliferation of names byreplacing   (declare (dynamic-extent-function name))with   (declare (dynamic-extent #'name)) ?This is a serious proposal, although I suspect that some peoplewill think it is a stupid idea.*start*03864 00024 US Date:  4 Apr 89 21:01 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: jonl%lucid:COM:XeroxSubject: issue DYNAMIC-EXTENT-FUNCTION, version 1In-Reply-to: Sandra J Loosemore's message of Tue, 4 Apr 89 11:27:21 MDT <8904041727.AA19101@defun.utah.edu>To: sandra%defun%cs.utah:EDU:Xeroxcc: cl-cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: sandra%defun@cs.utah.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Tue, 4 Apr 89 11:27:21 MDT <8904041727.AA19101@defun.utah.edu>Subject: issue DYNAMIC-EXTENT-FUNCTION, version 1Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 20:59:42 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 4 Apr 89  20:58:35 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA17233g; Tue, 4 Apr 89 20:52:50 PDTReceived: by bhopal id AA11925g; Tue, 4 Apr 89 20:59:22 PDTOriginal-Date: Tue, 4 Apr 89 20:59:22 PDTMessage-Id: <8904050359.AA11925@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre:   Introduce a new declaration called DYNAMIC-EXTENT-FUNCTION.  This is      identical to the DYNAMIC-EXTENT declaration, except that the      arguments name functions instead of variables.This is not sufficiently clear for a "specification".  I think you shouldat least talk about how the DYNAMIC-EXTENT-FUNCTION declaration only applies to lexical functions defined via FLET and LABELS, and is not to be used ina proclamation.  Additionally, you will have to say, for a form like:    (locally (declare (dynamic-extent-function f g))      (labels ((f (x) ...)               (g (y) ...)               (h (z) ...))	(declare <more-declarations>)       ...))whether or not the declaration in the LOCALLY is to apply to the twofunctions, or whether it has to be supplied in the place indicated by<more-declarations>  [my first inclination is that it doesn't apply,since similar program structure for type declarations wouldn't apply.]Similarly, you will have to say whether or not there is such a thingas a "free"  dynamic-extent-function  declaration.  E.g., what doesthe following mean:    (flet ((f (x) ...))      (funcall f gobbledygook)      (locally (declare (dynamic-extent-function f))        (cogitate #'f))      t)Here, my inclination is that unless the dynamic-extent-function declarationis applied to the name binding, it is useless to the compiler.  It's a bitlike allowing the compiler to represent FLOATs in specialized storage,providing it knows that during the entire lifetime of the variable -- including the binding time -- the value will only be FLOAT [hence, it can, e.g., use the flonum pdl instead of "boxing up" the value in the heap]Finally, you have to say how you handle a case like:    (mapcar (the dynamic-extent-function #'(lambda (x) <capture-stuff>))            ...)and if so, how to specify the particular dynamic scope of interest.Or, maybe you don't want to handle "anonymous" lexical functions. [Bythe bye, I realize that 'dynamic-extent-function' isn't a type -- Ionly wanted to illustrate the problem for "anonymous" functions.]If the places where the two declarations DYNAMIC-EXTENT-FUNCTION andDYNAMIC-EXTENT can be legitimately used don't overlap, then I don't see anything wrong with using the same name.  E.g.,   (let ((x (make-list n :initial-element 0)))     (declare (dynamic-extent x))     (labels ((f (y z) ...))       (declare (dynamic-extent f))       . . . ))should be unambiguous.-- JonL --P.S. The fact that I'm replying to a msg sent today doesn't mean that     I'm not still 4 weeks behind (in general) in mail reading.*start*02779 00024 US Date:  5 Apr 89 07:13 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: sandra%defun%cs.utah:EDU:XeroxSubject: Re: issue DYNAMIC-EXTENT-FUNCTION, version 1In-Reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Tue, 4 Apr 89 16:23 EDTTo: Moon%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: sandra%defun%cs.utah:EDU:Xerox, cl-cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Subject: Re: issue DYNAMIC-EXTENT-FUNCTION, version 1To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: Sandra J Loosemore <sandra%defun@cs.utah.edu>, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Tue, 4 Apr 89 16:23 EDTReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 APR 89 07:12:30 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 5 Apr 89  07:10:33 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA14298; Wed, 5 Apr 89 08:10:27 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA19876; Wed, 5 Apr 89 08:10:22 -0600Message-Id: <8904051410.AA19876@defun.utah.edu>Original-Date: Wed, 5 Apr 89 08:10:21 MDTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> Date: Tue, 4 Apr 89 16:23 EDT> From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>> > Does the compiler committee's model of compilation permit compilation of> one function to be affected by declarations in the current definition of> another function that it calls?  I hope so.Issue COMPILE-ENVIRONMENT-CONSISTENCY talks about situations in whichthe compiler is allowed to assume that functions defined in thecompiletime environment retain the same definitions at runtime.  Idon't see anything wrong with applying this technique in thosesituations.> Second, if a function has a SYS:DOWNWARD-FUNCTION declaration in front of> its body, then the function is implemented with dynamic extent regardless> of whether the compiler thinks all uses are "downward".  This feature is> used less often than the first feature, but is still used pretty often.I vaguely remembered seeing this in some ancient Symbolicsdocumentation.  It seems a little strange to me to have a declarationthat is only valid in one particular place, but this would indeed takecare of the problem with anonymous lambdas.> On a sillier note, should we minimize proliferation of names by> replacing> >    (declare (dynamic-extent-function name))> > with> >    (declare (dynamic-extent #'name)) ?I wouldn't have any strong objection to doing this, but maybe I'mbeing silly too.  :-)-Sandra-------*start*01872 00024 US Date:  5 Apr 89 07:25 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: sandra%defun%cs.utah:EDU:XeroxSubject: Re: issue DYNAMIC-EXTENT-FUNCTION, version 1In-Reply-to: Jon L White <jonl@lucid.com>, Tue, 4 Apr 89 20:59:22 PDTTo: jonl%lucid:COM:Xeroxcc: sandra%defun%cs.utah:EDU:Xerox, cl-cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Subject: Re: issue DYNAMIC-EXTENT-FUNCTION, version 1To: Jon L White <jonl@lucid.com>Cc: sandra%defun@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White <jonl@lucid.com>, Tue, 4 Apr 89 20:59:22 PDTReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 APR 89 07:23:02 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 5 Apr 89  07:21:47 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA14975; Wed, 5 Apr 89 08:21:43 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA19890; Wed, 5 Apr 89 08:21:40 -0600Message-Id: <8904051421.AA19890@defun.utah.edu>Original-Date: Wed, 5 Apr 89 08:21:39 MDTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI don't want to downplay your concerns, but it ought to be pointed outthat all of the problems you mention also apply to the DYNAMIC-EXTENTdeclaration proposal that we have already accepted.  (The onlydifference between the two is that DYNAMIC-EXTENT declarations applyto variable bindings and DYNAMIC-EXTENT-FUNCTION declarations apply tofunction bindings.)  Maybe I'm extrapolating beyond what was actuallystated in issue DECLARATION-SCOPE, but there's no confusion in my mindabout the scope of these two particular declarations, or what it meansfor them to appear "free". -Sandra-------*start*01425 00024 US Date:  5 Apr 89 08:51 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: issue DYNAMIC-EXTENT-FUNCTION, version 1In-Reply-to: <8904050359.AA11925@bhopal>To: jonl%lucid:COM:Xeroxcc: sandra%defun%cs.utah:EDU:Xerox, cl-cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue DYNAMIC-EXTENT-FUNCTION, version 1To: Jon L White <jonl@lucid.com>cc: sandra%defun@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: <8904050359.AA11925@bhopal>Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 APR 89 08:49:50 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 5 Apr 89  08:47:55 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571732; Wed 5-Apr-89 11:47:23 EDTOriginal-Date: Wed, 5 Apr 89 11:47 EDTMessage-ID: <19890405154713.0.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIt's my belief that a close reading of the GLS and KMP amendment toDYNAMIC-EXTENT (which was passed out at the meeting last week andwas unanimously adopted by X3J13 provides an unambiguous answer toeach of your concerns.*start*02009 00024 US Date:  5 Apr 89 17:44 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: jonl%lucid:COM:XeroxSubject: issue DYNAMIC-EXTENT-FUNCTION, version 1In-Reply-to: David A. Moon's message of Wed, 5 Apr 89 11:47 EDT <19890405154713.0.MOON@EUPHRATES.SCRC.Symbolics.CTo: Moon%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: sandra%defun%cs.utah:EDU:Xerox, cl-cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: sandra%defun@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 5 Apr 89 11:47 EDT <19890405154713.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: issue DYNAMIC-EXTENT-FUNCTION, version 1Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 APR 89 17:33:59 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 5 Apr 89  17:31:35 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00786g; Wed, 5 Apr 89 17:25:35 PDTReceived: by bhopal id AA04722g; Wed, 5 Apr 89 17:32:08 PDTOriginal-Date: Wed, 5 Apr 89 17:32:08 PDTMessage-Id: <8904060032.AA04722@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: It's my belief that a close reading of the GLS and KMP amendment to    DYNAMIC-EXTENT (which was passed out at the meeting last week and    was unanimously adopted by X3J13 provides an unambiguous answer to    each of your concerns.Well, the difficulty centers on how one interprets the word "identical"in Sandra's proposal.  I would invite you to make your interpretation,and put it into unambiguous words, explicitly in this proposal.By the bye, do you agree that a single declaration name -- DYNAMIC-EXTENT--  is satisfactory for both contexts?   A reasonable alternative might simply be to amend the previously passed proposal to include the function context.-- JonL --*start*01933 00024 US Date:  5 Apr 89 22:05 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: jonl%lucid:COM:XeroxSubject: issue DYNAMIC-EXTENT-FUNCTION, version 1In-Reply-to: Sandra J Loosemore's message of Wed, 5 Apr 89 08:21:39 MDT <8904051421.AA19890@defun.utah.edu>To: sandra%defun%cs.utah:EDU:Xeroxcc: cl-cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: sandra%defun@cs.utah.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Wed, 5 Apr 89 08:21:39 MDT <8904051421.AA19890@defun.utah.edu>Subject: issue DYNAMIC-EXTENT-FUNCTION, version 1Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 APR 89 22:04:57 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 5 Apr 89  22:03:16 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00980g; Wed, 5 Apr 89 21:57:29 PDTReceived: by bhopal id AA05644g; Wed, 5 Apr 89 22:03:57 PDTOriginal-Date: Wed, 5 Apr 89 22:03:57 PDTMessage-Id: <8904060503.AA05644@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: . . .all of the problems you mention also apply to the DYNAMIC-EXTENT    declaration proposal that we have already accepted.  (The only    difference between the two is that DYNAMIC-EXTENT declarations apply    to variable bindings and DYNAMIC-EXTENT-FUNCTION declarations apply to    function bindings.) This can't be true -- for example, there is no such thing as"anonymous variables" in the way that lambda-forms are anonymousfunctions.  And as Moon's recounting of the current Symbolics modelshows, downward lambdas can be very important.However, I was mostly concerned about the possibility that tworeaders might interpret your wording "identical" in somwhatnon-identical ways.-- JonL --*start*01835 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 26-May-89 08:44:40 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 MAY 89 08:43:58 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 26 May 89  08:42:38 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA25150; Fri, 26 May 89 09:42:55 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA09977; Fri, 26 May 89 09:42:52 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8905261542.AA09977@defun.utah.edu>Date: Fri, 26 May 89 09:42:51 MDTSubject: Re: issue DYNAMIC-EXTENT-FUNCTION, version 1To: cl-cleanup@sail.stanford.eduCc: sandra%defun@cs.utah.eduIn-Reply-To: Jon L White <jonl@lucid.com>, Wed, 5 Apr 89 22:03:57 PDTThe last round of discussion on this issue was kind of inconclusiveand then I got distracted with some real work, but I have some timenow to work on a new version.  It sounded like there was some supportfor the idea of just extending the existing DYNAMIC-EXTENT declarationto take arguments like (FUNCTION <x>) instead of adding anotherdeclaration just for functions, so that'll probably be in the newversion unless somebody complains.I don't know what to do about the related issue of declaring that ananonymous lambda has dynamic extent -- none of the alternatives thathave come up so far have much appeal.  Anyway, I don't think thisproblem is as critical, because you could just restructure the programto give the function a name.  I think you'd also get the right effectby declaring that all the closed-over variables and functionsreferenced in the lambda have dynamic extent.  So, I don't plan ondoing anything about it.-Sandra-------*start*02834 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 26-May-89 10:04:10 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 MAY 89 10:04:10 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 26 May 89  10:02:37 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA27476; Fri, 26 May 89 11:02:52 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA10054; Fri, 26 May 89 11:02:49 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8905261702.AA10054@defun.utah.edu>Date: Fri, 26 May 89 11:02:48 MDTSubject: Re: issue DYNAMIC-EXTENT-FUNCTION, version 1To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: Sandra J Loosemore <sandra%defun@cs.utah.edu>, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Fri, 26 May 89 12:22 EDT> Date: Fri, 26 May 89 12:22 EDT> From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>> > That> shows something interesting about the Symbolics sys:downward-function> declaration: the scope that defines the dynamic extent is larger than> the lambda-expression containing the declaration.That's the main reason why I'm not really enthusiastic about thisapproach -- the scoping rules just don't fit in with the rules forother declarations.> I guess you're going to require that>   (funcall <foo> (lambda (...) (declare (sys:downward-function)) ...))> be restructured as>   (flet ((dummy (...) ...))>     (declare (dynamic-extent #'dummy))>     (funcall <foo> #'dummy))Yes, this is what I had in mind.  Sorry if that wasn't clear in my original message.  I agree that the syntax is rather cumbersome.> After all, in this example>   (let ((a <foo>))>     (declare (dynamic-extent a))>     (<bar> #'(lambda (z) (if (<baz> z) (<frob> a) (<borf> z)))))> the dynamic extent declaration for A might mean that by the time the> scope of the declaration is exited, something will happen that will> make <baz> return false from then on, so A will no longer be referenced,> even though the closure that was given as an argument to <bar> will> continue to be called.I guess we differ over what "referenced" means.  My interpretation isthat the closure references A regardless of whether or not the pieceof code which references A inside the closure is actually executed onany particular invocation, and that it's therefore an error to saythat A has dynamic extent unless the closure also has dynamic extent. Maybe the real problem is that the DYNAMIC-EXTENT proposal didn'tformally define what "inaccessible" means.  I'm relying on anintuitive idea of what parts of a closure a garbage collector wouldhave to scan.-Sandra-------*start*04033 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 26-May-89 09:18:58 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 MAY 89 09:18:36 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 26 May 89  09:17:16 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 601589; 26 May 89 12:18:51 EDTDate: Fri, 26 May 89 12:22 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: issue DYNAMIC-EXTENT-FUNCTION, version 1To: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8905261542.AA09977@defun.utah.edu>Message-ID: <19890526162236.8.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>    Date: Fri, 26 May 89 09:42:51 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    The last round of discussion on this issue was kind of inconclusive    and then I got distracted with some real work, but I have some time    now to work on a new version.  It sounded like there was some support    for the idea of just extending the existing DYNAMIC-EXTENT declaration    to take arguments like (FUNCTION <x>) instead of adding another    declaration just for functions, so that'll probably be in the new    version unless somebody complains.Okay.    I don't know what to do about the related issue of declaring that an    anonymous lambda has dynamic extent -- none of the alternatives that    have come up so far have much appeal.  Anyway, I don't think this    problem is as critical, because you could just restructure the program    to give the function a name.Do you mean something like:(defmacro dynamic-extent-lambda (lambda-list &body body)  `(flet ((dummy-name ,lambda-list ,@body))     (declare (dynamic-extent dummy-name))     #'dummy-name))The problem with this is that the scope of the dynamic-extent declarationis too small, in fact, so small that this is an erroneous program.  Thatshows something interesting about the Symbolics sys:downward-functiondeclaration: the scope that defines the dynamic extent is larger thanthe lambda-expression containing the declaration.  Implementationally it'sthe surrounding function definition, semantically it would be enough for itto be the surrounding form.  I guess you're going to require that  (funcall <foo> (lambda (...) (declare (sys:downward-function)) ...))be restructured as  (flet ((dummy (...) ...))    (declare (dynamic-extent #'dummy))    (funcall <foo> #'dummy))which is okay except that it's hard to see how to define a macro thatgives it back a nice non-obtrusive syntax.  Maybe  (call-with-dynamic-functions    (funcall <foo> #'(lambda (...) ...)))Where the call-with-dynamic-functions macro pulls apart its subformlooking for lambda expressions.  The macro doesn't need to be in thestandard, programming stylists can define it for themselves.  It'sstill more obtrusive than something inside the lambda, though.    I think you'd also get the right effect    by declaring that all the closed-over variables and functions    referenced in the lambda have dynamic extent.  I don't think that would mean the same thing.  After all, in this example  (let ((a <foo>))    (declare (dynamic-extent a))    (<bar> #'(lambda (z) (if (<baz> z) (<frob> a) (<borf> z)))))the dynamic extent declaration for A might mean that by the time thescope of the declaration is exited, something will happen that willmake <baz> return false from then on, so A will no longer be referenced,even though the closure that was given as an argument to <bar> willcontinue to be called.  You are correct that the environment of theclosure could be discarded, but I don't see how the closure itselfcould be discarded; it would have to have indefinite extent.    So, I don't plan on doing anything about it.I guess that's probably for the best.*start*05679 00024 USfGV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 11-Jun-89 12:28:06 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JUN 89 12:28:05 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 11 Jun 89  12:26:05 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA04581; Sun, 11 Jun 89 13:26:28 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA20929; Sun, 11 Jun 89 13:26:25 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8906111926.AA20929@defun.utah.edu>Date: Sun, 11 Jun 89 13:26:24 MDTSubject: issue DYNAMIC-EXTENT-FUNCTION, version 2To: cl-cleanup@sail.stanford.eduI apologize for taking so long to finish this up -- I keep gettingdistracted with "real work" lately....Forum:		CLEANUPIssue:          DYNAMIC-EXTENT-FUNCTIONReferences:     Scope and Extent		Issue DYNAMIC-EXTENTCategory:       ADDITIONEdit history:   04-Apr-89, Version 1 by Loosemore		11-Jun-89, Version 2 by LoosemoreProblem Description:  Proposal DYNAMIC-EXTENT:NEW-DECLARATION, passed at the March 89   meeting, provides a mechanism for declaring that the values of  variables have only dynamic (rather than indefinite) extent.  It  would be useful to have similar functionality to indicate that  functional bindings may have only dynamic extent.  (For example,  this would permit compilers to stack-allocate closures.)Proposal (DYNAMIC-EXTENT-FUNCTION:EXTEND):  Extend the DYNAMIC-EXTENT declaration to accept arguments that are  lists of the form (FUNCTION <name>) where <name> is a function name,  as well as symbols.  A (FUNCTION <name>) list appearing in a DYNAMIC-EXTENT declaration is  used to declare that the lexically visible functional binding of <name>  has dynamic extent.  Except for the interpretation of <name> as the  name of a function instead of the name of a variable, such a declaration  otherwise has semantics that are identical to those already described  in proposal DYNAMIC-EXTENT:NEW-DECLARATION.Rationale:  This permits a programmer to offer advice to an implementation about  what functions may be stack-allocated for efficiency.  It may be difficult or impossible for a compiler to infer this  same information statically.Current Practice:  JonL says that Lucid's compiler can stack-allocate closures, but they  have no mechanism for programmers to give the compiler permission to  do so.  HPCL-I has an UPWARD-CLOSURES declaration that pervasively affects  all closures created within the scope of the declaration.  The Symbolics Genera compiler can often infer when functions can be   implemented to have dynamic extent.  Also, if a function has a  SYS:DOWNWARD-FUNCTION declaration in front of its body, then the  function is implemented with dynamic extent regardless of whether  the compiler thinks all uses are "downward".  (This declaration is  rather peculiar because its scope is actually larger than the lambda  expression containing the declaration; implementationally, it's the  surrounding function definition.)Cost to Implementors:  No cost is forced since implementations are permitted to simply  ignore the DYNAMIC-EXTENT declaration.  Cost to Users:  None. This change is upward compatible.  There may be some hidden costs to debugging using this declaration (or any  feature which permits the user to access dynamic extent objects without  the compiler proving that they are appropriate). If the user misdeclares  something and returns a pointer into the stack (or stores it in the heap),  an undefined situation may result and the integrity of the Lisp storage  mechanism may be compromised. Debugging these situations may be tricky,  but users who have asked for this feature have indicated a willingness  to deal with such costs. Nevertheless, the perils should be clearly  documented and casual users should not be encouraged to use this  declaration.Cost of Non-Adoption:  Some portable code would be forced to run more slowly (due to  GC overhead), or to use non-portable language features.Benefits:  The cost of non-adoption is avoided.Aesthetics:  This declaration allows a fairly low level optimization to work  by asking the user to provide only very high level information.  The alternatives (sharpsign conditionals, some of which may  lead to more bit-picky abstractions) are far less aesthetic.Discussion:  Loosemore supports DYNAMIC-EXTENT-FUNCTION:EXTEND.  This proposal does not attempt to address the issue of specifying  dynamic extent for anonymous closures (which is really a special case  of the more general problem of specifying dynamic extent for unnamed  objects of any type).  It's possible, although often awkward, to  restructure the program to give the object a name and explicitly  identify its extent.  One possible solution to the problem of dynamic extent for anonymous  lambdas would be to clarify that a reference to a closed-over variable  or function appearing lexically within a FUNCTION form is enough to  cause its value to be "saved" when the FUNCTION form is executed,  regardless of whether or not that reference is actually executed when  the resulting function is called.  Then, if all of the closed-over  functions and variables referenced within a closure are declared to  have dynamic extent, the closure could be assumed to have dynamic  extent as well.  (More precisely, its maximum extent would be the  intersection of the extents of the closed-over functions and  variables.)-------*start*01406 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 12-Jun-89 11:33:09 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JUN 89 11:31:44 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 12 Jun 89  11:30:29 PDTReceived: from bhopal ([192.43.178.13]) by heavens-gate id AA20149g; Mon, 12 Jun 89 11:28:17 PDTReceived: by bhopal id AA10549g; Mon, 12 Jun 89 11:30:28 PDTDate: Mon, 12 Jun 89 11:30:28 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8906121830.AA10549@bhopal>To: sandra%defun@cs.utah.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Sun, 11 Jun 89 13:26:24 MDT <8906111926.AA20929@defun.utah.edu>Subject: issue DYNAMIC-EXTENT-FUNCTION, version 2re:   . . .  Except for the interpretation of <name> as the      name of a function instead of the name of a variable, such a declaration      otherwise has semantics that are identical to those already described      in proposal DYNAMIC-EXTENT:NEW-DECLARATION.I like this.  It really says what I think is preferable -- that thedeclaration DYNAMIC-EXTENT applies to name-bindings, whether "value"or "functional".   Had we had a bit more foresight, this might havegotten into the original proposal, but it's no big deal to have twoproposals.-- JonL --*start*00864 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Jun-89 20:50:59 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 JUN 89 20:51:02 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 16 Jun 89  20:49:45 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 612459; 16 Jun 89 23:51:36 EDTDate: Fri, 16 Jun 89 23:52 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue DYNAMIC-EXTENT-FUNCTION, version 2To: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8906111926.AA20929@defun.utah.edu>Message-ID: <19890617035202.3.MOON@EUPHRATES.SCRC.Symbolics.COM>This is okay.*start*05386 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 21-Jun-89 11:41:06 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 11:40:51 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Jun 89  11:29:47 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 21 JUN 89 11:23:58 PDTDate: 21 Jun 89 11:23 PDTFrom: masinter.paSubject: issue DYNAMIC-EXTENT-FUNCTION, version 2To: x3j13@sail.stanford.eduMessage-ID: <890621-112358-17463@Xerox>This issue was postponed from the last meeting...!Forum:		CLEANUPIssue:          DYNAMIC-EXTENT-FUNCTIONReferences:     Scope and Extent		Issue DYNAMIC-EXTENTCategory:       ADDITIONEdit history:   04-Apr-89, Version 1 by Loosemore		11-Jun-89, Version 2 by LoosemoreProblem Description:  Proposal DYNAMIC-EXTENT:NEW-DECLARATION, passed at the March 89   meeting, provides a mechanism for declaring that the values of  variables have only dynamic (rather than indefinite) extent.  It  would be useful to have similar functionality to indicate that  functional bindings may have only dynamic extent.  (For example,  this would permit compilers to stack-allocate closures.)Proposal (DYNAMIC-EXTENT-FUNCTION:EXTEND):  Extend the DYNAMIC-EXTENT declaration to accept arguments that are  lists of the form (FUNCTION <name>) where <name> is a function name,  as well as symbols.  A (FUNCTION <name>) list appearing in a DYNAMIC-EXTENT declaration is  used to declare that the lexically visible functional binding of <name>  has dynamic extent.  Except for the interpretation of <name> as the  name of a function instead of the name of a variable, such a declaration  otherwise has semantics that are identical to those already described  in proposal DYNAMIC-EXTENT:NEW-DECLARATION.Rationale:  This permits a programmer to offer advice to an implementation about  what functions may be stack-allocated for efficiency.  It may be difficult or impossible for a compiler to infer this  same information statically.Current Practice:  JonL says that Lucid's compiler can stack-allocate closures, but they  have no mechanism for programmers to give the compiler permission to  do so.  HPCL-I has an UPWARD-CLOSURES declaration that pervasively affects  all closures created within the scope of the declaration.  The Symbolics Genera compiler can often infer when functions can be   implemented to have dynamic extent.  Also, if a function has a  SYS:DOWNWARD-FUNCTION declaration in front of its body, then the  function is implemented with dynamic extent regardless of whether  the compiler thinks all uses are "downward".  (This declaration is  rather peculiar because its scope is actually larger than the lambda  expression containing the declaration; implementationally, it's the  surrounding function definition.)Cost to Implementors:  No cost is forced since implementations are permitted to simply  ignore the DYNAMIC-EXTENT declaration.  Cost to Users:  None. This change is upward compatible.  There may be some hidden costs to debugging using this declaration (or any  feature which permits the user to access dynamic extent objects without  the compiler proving that they are appropriate). If the user misdeclares  something and returns a pointer into the stack (or stores it in the heap),  an undefined situation may result and the integrity of the Lisp storage  mechanism may be compromised. Debugging these situations may be tricky,  but users who have asked for this feature have indicated a willingness  to deal with such costs. Nevertheless, the perils should be clearly  documented and casual users should not be encouraged to use this  declaration.Cost of Non-Adoption:  Some portable code would be forced to run more slowly (due to  GC overhead), or to use non-portable language features.Benefits:  The cost of non-adoption is avoided.Aesthetics:  This declaration allows a fairly low level optimization to work  by asking the user to provide only very high level information.  The alternatives (sharpsign conditionals, some of which may  lead to more bit-picky abstractions) are far less aesthetic.Discussion:  Loosemore supports DYNAMIC-EXTENT-FUNCTION:EXTEND.  This proposal does not attempt to address the issue of specifying  dynamic extent for anonymous closures (which is really a special case  of the more general problem of specifying dynamic extent for unnamed  objects of any type).  It's possible, although often awkward, to  restructure the program to give the object a name and explicitly  identify its extent.  One possible solution to the problem of dynamic extent for anonymous  lambdas would be to clarify that a reference to a closed-over variable  or function appearing lexically within a FUNCTION form is enough to  cause its value to be "saved" when the FUNCTION form is executed,  regardless of whether or not that reference is actually executed when  the resulting function is called.  Then, if all of the closed-over  functions and variables referenced within a closure are declared to  have dynamic extent, the closure could be assumed to have dynamic  extent as well.  (More precisely, its maximum extent would be the  intersection of the extents of the closed-over functions and  variables.)