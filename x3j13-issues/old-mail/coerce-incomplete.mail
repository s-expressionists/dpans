*start*14503 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 28 FEB 88 08:09:15 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 28 Feb 88  08:07:33 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 28 FEB 88 08:08:05 PSTFrom: masinter.paDate: 28 Feb 88 8:07:18 PSTSubject: Issue: COERCE-INCOMPLETETo: cl-cleanup@sail.stanford.eduMessage-ID: <880228-080805-2138@Xerox>I'm not really back until next week, but this came in for consideration...----------Return-Path: <@RELAY.CS.NET:a37078%tansei.cc.u-tokyo.junet@UTOKYO-RELAY.CSNET>Received: from RELAY.CS.NET by Xerox.COM ; 25 FEB 88 23:39:52 PSTReceived: from relay2.cs.net by RELAY.CS.NET id aa07232; 26 Feb 88 2:16 ESTReceived: from utokyo-relay by RELAY.CS.NET id aa26262; 26 Feb 88 2:06 ESTReceived: by ccut.cc.u-tokyo.junet (5.51/6.3Junet-1.0/CSNET-JUNET)	id AA19019; Fri, 26 Feb 88 15:54:40 JSTReceived: by tansei.cc.u-tokyo.junet (4.12/6.3Junet-1.0)	id AA12493; Fri, 26 Feb 88 15:55:57+0900Date: Fri, 26 Feb 88 15:55:57+0900From: Masayuki Ida <a37078%tansei.cc.u-tokyo.junet@UTOKYO-RELAY.CSNET>Return-Path: <a37078@tansei.cc.u-tokyo.junet>Message-Id: <8802260655.AA12493@tansei.cc.u-tokyo.junet>To: ida%tansei.cc.u-tokyo.junet@UTOKYO-RELAY.CSNET, masinter.paSubject: CoercionDear Larry Masinter,I wrote my opinion on coercion which is attached consulting your suggestion on the format.Please find and use if you think it is valuable to have.Masayuki Ida--------------------------------------------------------------------Issue:	CoerceReference:	coerce (CLtL p50)Category:	changeEdit history:	version 1 by M.Ida,  26-Feb-1988Problem Description:--------------------Problem 1:Coerce is not symmetric or not generic among data types.In CLtL, Coerce is defined in page 50 and 51 that, 1) a sequence type may be converted to any other sequence type. 2)Some strings, symbols, and integers may be converted to characters.  2-1) If object is a string of length 1,      then the sole element of the string is returned. 2-2) If object is a symbol whose print name is of length 1,      then the sole element of the print name is returned.  2-3) If object is an integer n,      then (int-char n) is returned.3) any non-complex number can be converted to a XXX-float.4) any number can be converted to a complex number.The next table shows that how coerce is not symmetric among character,string, symbol and integer.    TABLE 1. Possible Conversions among character, string,symbol, integertype of conversion      provided functions              coercion under the CLtL character -> string    string                                      X character <- string    coerce (if the string has only one char.)   O character -> symbol    (intern (string @i[ch]))                    X character <- symbol    coerce (if pname length is 1)               O character -> integer   char-code, char-int                         X character <- integer   code-char (zero font-, zero bits- attrib.)  O                         int-char (any font- and any bits-) string -> symbol       intern, make-symbol                         X string <- symbol       string, symbol-name                         X string -> integer      (char-code (coerce @i[string] 'character))  X string <- integer      (string (code-char @i[integer]))            X symbol -> integer      (char-code (coerce @i[symbol] 'character))  X symbol <- integer      (intern (string (code-char @i[integer])))   XProblem 2:The function of coerce for character is defined to act as char-int/int-char not as char-code/code-char.Proposal: Coerce :replace-------------------------COERCE should be more generalized for string, symbol, integer, and characterdata types. The observations show there are no problem if extensions are fully written out in the details.Here is an extension to the current coerce definition using the CLOS.(defmethod coerce ((x character) (y (eql string))) (string x))(defmethod coerce ((x character) (y (eql symbol))) (intern (string x)))(defmethod coerce ((x character) (y (eql integer))) (char-code x))(defmethod coerce ((x string) (y (eql symbol))) (intern x))(defmethod coerce ((x symbol) (y (eql string))) (string x))(defmethod coerce ((x string) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql string))) (string (code-char x)))(defmethod coerce ((x symbol) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql symbol)))           (intern (sting (code-char x))))(defmethod coerce ((x integer) (y (eql character)))   (code-char x)) ; redefinition. CLtL defines as int-charThe keys are a) ignore char-bits and char-font upon the conversion of characters, assuming font-attribute will be flushed from the language spec.b) ignore the package name upon the conversion of symbols.(package name has no role upon the conversion.)c) the created symbol will be interned to the current package.Rationale:----------By extending the definition as this document suggests, the functionalityof coerce is symmetric among characters, strings, symbols and integers.Current Practice:Cost to implementors:Cost to users:Benefits:Aesthetics:Discussion:Among the functions in Table 1, we can pick up the role of @t[STRING] function.@T[STRING] has odd definition. It was alsothe starting point of discussions described in the following.The problems or the awkwards are mainly on the design of the symmetry of the function names.We would start the discussion with the following two observations.@* i) @t[(string @i(x))] is OK. But, @t[(coerce @i(x) 'string)] is illegal.@*While, @t[(character @i(x))] is OK. And @t[(coerce @i(x) 'character)] is OK too..@*ii) To convert from a symbol to a string, use @t[SYMBOL-NAME] or @t[STRING]. While, to convert from a string to a symbol, use @t[MAKE-SYMBOL] to an uninterned symbol, or use @t[INTERN] to an interned symbol.@*@*@*@b[ Discussions on Coercion in Common-Lisp E-mails 1986]The awkward were discussed already in Common-lisp E-mails.The author checked the 10M bytes E-mails on disk.The discussions around @t[coerce] were almost in 1986, and not much in 1985 or before.The sequence of our concern started by a mail of fateman@@dali.berkeley.edu,dated Fri, 16 May 1986 15:40 PDT as follows.@*1) fateman@@dali.berkeley.edu fri 16 may 1986 15:40 PDT:@*This mail describes the same issue as for STRING function.2) jeff@@aiva.edinburgh.ac.uk sun 18 may 17:17 GMT@*@t[ ...  'string' applied to a sequence of characters gives an error, typically saying the sequence can't be coerced to a string, but 'coerce' will in fact coerce it...]3) gls@@think.com, Mon 19 may 1986 12:20 EDT@*@begin[t]Research shows that the Common Lisp archives up to a couple of monthsago contains 18 messages that mention @t[COERCE].  None explicitly addressesthis issue, but the general tone of the messages is one of conservatism.I now remember that this issue was tied up with the design of thesequence functions.  There was real resistance to letting symbols betreated as general sequences, and so the general decision was made thatstring-specific functions would accept symbols, but general sequencefunctions would not. ...@end[t] To check his talk, @b[3.3] shows all the early discussions on @t[coerce] the author can find.4) fahlman@@c.cs.cmu.edu  Mon, 19 May 1986 20:44 EDT@*@t[... I would not object to generalizing coerce to handle some of the additional cases that people imagine it ought to handle.]@begin[verbatim]5) cfry@@oz.ai.mit.edu, Tue, 20 May 1986 03:21 EDT@*... Coercion is a powerful, easy to remember concept. I think it should be extended as much as possible.  ...  :   (coerce #\a 'string) => "a"   (coerce 123 'string) => "123"   (coerce #\a 'integer) => (char-code #\a) ; explicitly not provided CLtL p52. It appears that the only reason is that no one could decide on using char-code or char-int for the conversion so they chose not to do it at all. This reasoning is odd. Pick the most frequently used way, document it, and permit it. Same argument for coercion of numeric types.Further out extensions might be: (coerce #'foo 'compiled-function) => returns a compiled function object ... (coerce string-1 'pathname) (coerce bit-vector-1 'integer) ...Undoubtedly there are other coercions which would make sense. ... Users would save a lot of manual searching if coerce was extended.@end[verbatim]6) Eliot@@umass-cs.csnet,  Tue 20 May 1986 15:31 EST@*@t[Coercing symbols to stings is fine, as long as NIL is treated asthe empty SEQUENCE, rather than as a symbol.]@begin[verbatim]7) REM@@IMSSS, 19 May 09:34 PST  referring to the mail of gls sayingthat "@t[COERCE] was limited to ... sequence and numerical coercions".This is one of the bad points of many LISPs, including CL, functions thatare miss-named or otherwise don't do what you'd expect from their name. ... I hope the international standards committee will fix this kind ofproblem so programmers reading somebody else's code can have the meaningapparent in most cases form general programming tradition rather thanhaving to constantly check the manual to see if the function does whatit seems to say it would do.8) DCP@@scrc-quabbin.arpa, Wed, 21 May 1986 16:45 EDT,@*Does (coerce @i(symbol) 'string) return     (symbol-name @i(symbol)), or   (format nil "~S" @i(symbol)), or   (format nil "~A::~A"       (package-name (symbol-package @i(symbol))) (symbol-name @i(symbol)))or what ?  If this weren't enough, added in with my personal views ofstyle and functionality, for me to want to help veto this coercion, thespecial casing of NIL certainly would.  Programs should reflect theirmeaning.  A string is a sequence, a symbol is not.  Why shouldn't@#  (coerce :ascii-EOT 'integer)work?  The answer is that the requested behavior is not a coercionbetween compatible types, it is a functional translation between humanunderstandable names for the ascii control characters and the integersthat are their corresponding values.@end[verbatim]We found that there is a possibility to extend the semantics of @t[coerce]to cope with more generic types. It should be noted that the two key designers of Common Lispmentioned their opinions, and they do not always be against to the extension.The discussion was stopped at this point and we cannot find their continuation yet.We find from this story that @*1) If we don't care about the package, we may extend the coerceto the function from a symbol to a string, @*2) If we are free to care about the font- and bits- attribute, we may extend the coerce to include the function from a character to other types.@*@*@*@b[ Early discussions on coercion]The following sequence was picked up from the archives. They are almost all the meaningful talk the author can find. They were in 1983, one year before @i(CLtL) was published.@begin(verbatim)1) Guy Steele, dated 27 May 83 01:23:14 EDT, (in the summary of the discussion with DLW and moon upon the laser edition update) a)No.38: it is noted that DLW said "coercing of characters to integersshould probably be allowed too." and this point was marked as {controversial}.b) Moon's comment. "if (string x) <=> (coerce x 'string) exactly, say so.Both of these should coerce a character into a 1-element string; neither says so now. The old argument against this, that people might expect string of a number to give not numbers." and Guy Steele agreed.N.197: {gloss} string is required to signal an error if its argument is not astring and not a symbol.  This is wrong; it should convert a character to aone-character string.  Also it says that string will not convert a sequence ofcharacters into a string, but coerce will.  This might be all right, exceptunder coerce it says that when coercing to a string the implementation isallowed to return a more general type. ... Also the coerce writeupdoesn't say anything for or against coercing from a character to a 1-long string.{controversial} {will clarify}2) Fahlman, dated Sat, 28 May 1983 22:34 EDT;At least, I would like you to consider dropping these. ...Page 38: Coercing of characters to integers is not a very useful operation in portable code if the language spec does not specify the correspondence (and Common Lisp does not).  Do you still want to propose that we add this coercion?I'm not particularly opposed, I just worry that users will find it too easy to inadvertently do non-portable things if given this coercion.3) Moon, date: sat, 28 May 1983, 22:40-EDTI don't think coercion of characters to integers should be allowed, becausehow do you know whether you want the char-code or what.  Dan was probablyjust stuck in our old mindset from not having character objects on the Lispmachine. Coercion of characters to strings, however, I believe is useful.4) Daniel L.Weinreb, Date: Tuesday, 31 May 1983, 15:40-EDT... It's OK with me if COERCE doesn't coerce characters to integers. However, I strongly suggest putting in a clarification note to that effect... Or maybea Rationale note saying that it doesn't because it wouldn't be clear what to doabout the char-code versus whole character, and telling you to use the particularlyfunction instead. This note is for the benefit of users more than of implementors.5) Scott E. Fahlman, Date: Wed, 1 Jun 1983  01:47 EDT < referring 4)>    It's OK with me if COERCE doesn't coerce characters to integers.    However, I strongly suggest putting in a clarification note to that ...<< I assume Guy will do this. >>@end(verbatim)  As far as we can see from this talk, that the process of making a coercion betweencharacters and integers be restricted such that char-to-integer conversion is not provided,while integer-to-char is. The coercions from characters to integers arepurposely not provided; @t[char-code] or @t[char-int] may be used explicitly toperform such conversions (See @b[Appendix] for the definitions of @t[char-code]and @t[char-int]).The difference between @t(char-int) and @t(char-code) is on the treatment of@i(font) and @i(bits) attributes.If these two attributes have no significant meaning and are ignored by everyone,we can make the story much simpler. (And @b[4.] describes at least font- isnot alive).*start*13954 00024 US Return-Path: <@RELAY.CS.NET:a37078%tansei.cc.u-tokyo.junet@UTOKYO-RELAY.CSNET>Received: from RELAY.CS.NET by Xerox.COM ; 25 FEB 88 23:39:52 PSTReceived: from relay2.cs.net by RELAY.CS.NET id aa07232; 26 Feb 88 2:16 ESTReceived: from utokyo-relay by RELAY.CS.NET id aa26262; 26 Feb 88 2:06 ESTReceived: by ccut.cc.u-tokyo.junet (5.51/6.3Junet-1.0/CSNET-JUNET)	id AA19019; Fri, 26 Feb 88 15:54:40 JSTReceived: by tansei.cc.u-tokyo.junet (4.12/6.3Junet-1.0)	id AA12493; Fri, 26 Feb 88 15:55:57+0900Date: Fri, 26 Feb 88 15:55:57+0900From: Masayuki Ida <a37078%tansei.cc.u-tokyo.junet@UTOKYO-RELAY.CSNET>Return-Path: <a37078@tansei.cc.u-tokyo.junet>Message-Id: <8802260655.AA12493@tansei.cc.u-tokyo.junet>To: ida%tansei.cc.u-tokyo.junet@UTOKYO-RELAY.CSNET, masinter.paSubject: CoercionDear Larry Masinter,I wrote my opinion on coercion which is attached consulting your suggestion on the format.Please find and use if you think it is valuable to have.Masayuki Ida--------------------------------------------------------------------Issue:	CoerceReference:	coerce (CLtL p50)Category:	changeEdit history:	version 1 by M.Ida,  26-Feb-1988Problem Description:--------------------Problem 1:Coerce is not symmetric or not generic among data types.In CLtL, Coerce is defined in page 50 and 51 that, 1) a sequence type may be converted to any other sequence type. 2)Some strings, symbols, and integers may be converted to characters.  2-1) If object is a string of length 1,      then the sole element of the string is returned. 2-2) If object is a symbol whose print name is of length 1,      then the sole element of the print name is returned.  2-3) If object is an integer n,      then (int-char n) is returned.3) any non-complex number can be converted to a XXX-float.4) any number can be converted to a complex number.The next table shows that how coerce is not symmetric among character,string, symbol and integer.    TABLE 1. Possible Conversions among character, string,symbol, integertype of conversion      provided functions              coercion under the CLtL character -> string    string                                      X character <- string    coerce (if the string has only one char.)   O character -> symbol    (intern (string @i[ch]))                    X character <- symbol    coerce (if pname length is 1)               O character -> integer   char-code, char-int                         X character <- integer   code-char (zero font-, zero bits- attrib.)  O                         int-char (any font- and any bits-) string -> symbol       intern, make-symbol                         X string <- symbol       string, symbol-name                         X string -> integer      (char-code (coerce @i[string] 'character))  X string <- integer      (string (code-char @i[integer]))            X symbol -> integer      (char-code (coerce @i[symbol] 'character))  X symbol <- integer      (intern (string (code-char @i[integer])))   XProblem 2:The function of coerce for character is defined to act as char-int/int-char not as char-code/code-char.Proposal: Coerce :replace-------------------------COERCE should be more generalized for string, symbol, integer, and characterdata types. The observations show there are no problem if extensions are fully written out in the details.Here is an extension to the current coerce definition using the CLOS.(defmethod coerce ((x character) (y (eql string))) (string x))(defmethod coerce ((x character) (y (eql symbol))) (intern (string x)))(defmethod coerce ((x character) (y (eql integer))) (char-code x))(defmethod coerce ((x string) (y (eql symbol))) (intern x))(defmethod coerce ((x symbol) (y (eql string))) (string x))(defmethod coerce ((x string) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql string))) (string (code-char x)))(defmethod coerce ((x symbol) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql symbol)))           (intern (string (code-char x))))(defmethod coerce ((x integer) (y (eql character)))   (code-char x)) ; redefinition. CLtL defines as int-charThe keys are a) ignore char-bits and char-font upon the conversion of characters, assuming font-attribute will be flushed from the language spec.b) ignore the package name upon the conversion of symbols.(package name has no role upon the conversion.)c) the created symbol will be interned to the current package.Rationale:----------By extending the definition as this document suggests, the functionalityof coerce is symmetric among characters, strings, symbols and integers.Current Practice:Cost to implementors:Cost to users:Benefits:Aesthetics:Discussion:Among the functions in Table 1, we can pick up the role of @t[STRING] function.@T[STRING] has odd definition. It was alsothe starting point of discussions described in the following.The problems or the awkwards are mainly on the design of the symmetry of the function names.We would start the discussion with the following two observations.@* i) @t[(string @i(x))] is OK. But, @t[(coerce @i(x) 'string)] is illegal.@*While, @t[(character @i(x))] is OK. And @t[(coerce @i(x) 'character)] is OK too..@*ii) To convert from a symbol to a string, use @t[SYMBOL-NAME] or @t[STRING]. While, to convert from a string to a symbol, use @t[MAKE-SYMBOL] to an uninterned symbol, or use @t[INTERN] to an interned symbol.@*@*@*@b[ Discussions on Coercion in Common-Lisp E-mails 1986]The awkward were discussed already in Common-lisp E-mails.The author checked the 10M bytes E-mails on disk.The discussions around @t[coerce] were almost in 1986, and not much in 1985 or before.The sequence of our concern started by a mail of fateman@@dali.berkeley.edu,dated Fri, 16 May 1986 15:40 PDT as follows.@*1) fateman@@dali.berkeley.edu fri 16 may 1986 15:40 PDT:@*This mail describes the same issue as for STRING function.2) jeff@@aiva.edinburgh.ac.uk sun 18 may 17:17 GMT@*@t[ ...  'string' applied to a sequence of characters gives an error, typically saying the sequence can't be coerced to a string, but 'coerce' will in fact coerce it...]3) gls@@think.com, Mon 19 may 1986 12:20 EDT@*@begin[t]Research shows that the Common Lisp archives up to a couple of monthsago contains 18 messages that mention @t[COERCE].  None explicitly addressesthis issue, but the general tone of the messages is one of conservatism.I now remember that this issue was tied up with the design of thesequence functions.  There was real resistance to letting symbols betreated as general sequences, and so the general decision was made thatstring-specific functions would accept symbols, but general sequencefunctions would not. ...@end[t] To check his talk, @b[3.3] shows all the early discussions on @t[coerce] the author can find.4) fahlman@@c.cs.cmu.edu  Mon, 19 May 1986 20:44 EDT@*@t[... I would not object to generalizing coerce to handle some of the additional cases that people imagine it ought to handle.]@begin[verbatim]5) cfry@@oz.ai.mit.edu, Tue, 20 May 1986 03:21 EDT@*... Coercion is a powerful, easy to remember concept. I think it should be extended as much as possible.  ...  :   (coerce #\a 'string) => "a"   (coerce 123 'string) => "123"   (coerce #\a 'integer) => (char-code #\a) ; explicitly not provided CLtL p52. It appears that the only reason is that no one could decide on using char-code or char-int for the conversion so they chose not to do it at all. This reasoning is odd. Pick the most frequently used way, document it, and permit it. Same argument for coercion of numeric types.Further out extensions might be: (coerce #'foo 'compiled-function) => returns a compiled function object ... (coerce string-1 'pathname) (coerce bit-vector-1 'integer) ...Undoubtedly there are other coercions which would make sense. ... Users would save a lot of manual searching if coerce was extended.@end[verbatim]6) Eliot@@umass-cs.csnet,  Tue 20 May 1986 15:31 EST@*@t[Coercing symbols to stings is fine, as long as NIL is treated asthe empty SEQUENCE, rather than as a symbol.]@begin[verbatim]7) REM@@IMSSS, 19 May 09:34 PST  referring to the mail of gls sayingthat "@t[COERCE] was limited to ... sequence and numerical coercions".This is one of the bad points of many LISPs, including CL, functions thatare miss-named or otherwise don't do what you'd expect from their name. ... I hope the international standards committee will fix this kind ofproblem so programmers reading somebody else's code can have the meaningapparent in most cases form general programming tradition rather thanhaving to constantly check the manual to see if the function does whatit seems to say it would do.8) DCP@@scrc-quabbin.arpa, Wed, 21 May 1986 16:45 EDT,@*Does (coerce @i(symbol) 'string) return     (symbol-name @i(symbol)), or   (format nil "~S" @i(symbol)), or   (format nil "~A::~A"       (package-name (symbol-package @i(symbol))) (symbol-name @i(symbol)))or what ?  If this weren't enough, added in with my personal views ofstyle and functionality, for me to want to help veto this coercion, thespecial casing of NIL certainly would.  Programs should reflect theirmeaning.  A string is a sequence, a symbol is not.  Why shouldn't@#  (coerce :ascii-EOT 'integer)work?  The answer is that the requested behavior is not a coercionbetween compatible types, it is a functional translation between humanunderstandable names for the ascii control characters and the integersthat are their corresponding values.@end[verbatim]We found that there is a possibility to extend the semantics of @t[coerce]to cope with more generic types. It should be noted that the two key designers of Common Lispmentioned their opinions, and they do not always be against to the extension.The discussion was stopped at this point and we cannot find their continuation yet.We find from this story that @*1) If we don't care about the package, we may extend the coerceto the function from a symbol to a string, @*2) If we are free to care about the font- and bits- attribute, we may extend the coerce to include the function from a character to other types.@*@*@*@b[ Early discussions on coercion]The following sequence was picked up from the archives. They are almost all the meaningful talk the author can find. They were in 1983, one year before @i(CLtL) was published.@begin(verbatim)1) Guy Steele, dated 27 May 83 01:23:14 EDT, (in the summary of the discussion with DLW and moon upon the laser edition update) a)No.38: it is noted that DLW said "coercing of characters to integersshould probably be allowed too." and this point was marked as {controversial}.b) Moon's comment. "if (string x) <=> (coerce x 'string) exactly, say so.Both of these should coerce a character into a 1-element string; neither says so now. The old argument against this, that people might expect string of a number to give not numbers." and Guy Steele agreed.N.197: {gloss} string is required to signal an error if its argument is not astring and not a symbol.  This is wrong; it should convert a character to aone-character string.  Also it says that string will not convert a sequence ofcharacters into a string, but coerce will.  This might be all right, exceptunder coerce it says that when coercing to a string the implementation isallowed to return a more general type. ... Also the coerce writeupdoesn't say anything for or against coercing from a character to a 1-long string.{controversial} {will clarify}2) Fahlman, dated Sat, 28 May 1983 22:34 EDT;At least, I would like you to consider dropping these. ...Page 38: Coercing of characters to integers is not a very useful operation in portable code if the language spec does not specify the correspondence (and Common Lisp does not).  Do you still want to propose that we add this coercion?I'm not particularly opposed, I just worry that users will find it too easy to inadvertently do non-portable things if given this coercion.3) Moon, date: sat, 28 May 1983, 22:40-EDTI don't think coercion of characters to integers should be allowed, becausehow do you know whether you want the char-code or what.  Dan was probablyjust stuck in our old mindset from not having character objects on the Lispmachine. Coercion of characters to strings, however, I believe is useful.4) Daniel L.Weinreb, Date: Tuesday, 31 May 1983, 15:40-EDT... It's OK with me if COERCE doesn't coerce characters to integers. However, I strongly suggest putting in a clarification note to that effect... Or maybea Rationale note saying that it doesn't because it wouldn't be clear what to doabout the char-code versus whole character, and telling you to use the particularlyfunction instead. This note is for the benefit of users more than of implementors.5) Scott E. Fahlman, Date: Wed, 1 Jun 1983  01:47 EDT < referring 4)>    It's OK with me if COERCE doesn't coerce characters to integers.    However, I strongly suggest putting in a clarification note to that ...<< I assume Guy will do this. >>@end(verbatim)  As far as we can see from this talk, that the process of making a coercion betweencharacters and integers be restricted such that char-to-integer conversion is not provided,while integer-to-char is. The coercions from characters to integers arepurposely not provided; @t[char-code] or @t[char-int] may be used explicitly toperform such conversions (See @b[Appendix] for the definitions of @t[char-code]and @t[char-int]).The difference between @t(char-int) and @t(char-code) is on the treatment of@i(font) and @i(bits) attributes.If these two attributes have no significant meaning and are ignored by everyone,we can make the story much simpler. (And @b[4.] describes at least font- isnot alive).*start*01714 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 JUN 88 21:43:13 PDTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 12 Jun 88  21:42:38 PDTReceived: from relay2.cs.net by RELAY.CS.NET id aa01299; 13 Jun 88 0:36 EDTReceived: from utokyo-relay by RELAY.CS.NET id ae19675; 13 Jun 88 0:28 EDTReceived: by ccut.cc.u-tokyo.junet (5.51/6.3Junet-1.0/CSNET-JUNET)	id AA11864; Mon, 13 Jun 88 11:18:21 JSTReceived: by aoyama.cc.aoyama.junet (3.2/6.3Junet-1.0)	id AA26328; Mon, 13 Jun 88 11:07:16 JSTDate: Mon, 13 Jun 88 11:07:16 JSTFrom: Masayuki Ida <ida%aoyama.cc.aoyama.junet@UTOKYO-RELAY.CSNET>Return-Path: <ida@aoyama.cc.aoyama.junet>Message-Id: <8806130207.AA26328@aoyama.cc.aoyama.junet>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: COERCE-INCOMPLETESince I was not involved in the cl-cleanup list,I have no information on the process of COERCE-INCOMPLETE issue whichseems to be discussed.I guess it must be the issue I raised and I sent to Larry Masinteraccording to his request.I still have a interest on this issue butI myself understand the situation as it is the issue I gave to cl-clearupsubcommittee.So, I have no will to discuss on the matter unless the subcommitteeforward the mails of their discussions.I have a desire to receive the mailing-list,but as some of you may know,All the traffic between US and I are paid by myself.So, I am afraid that I will short of money for this year's research withthe expenses of un-needed mails.So, I hope a kind of moderated communication about the cleanup things.Hoping your kind treatment.Masayuki Ida*start*14473 00024 US Date: 10 Jun 88 01:58 PDTFrom: Masinter.paSubject: [masinter.pa: Issue: COERCE-INCOMPLETE]To: cl-cleanup@sail.stanford.educc: Masinter.paThis issue is for discussion in the subcommittee.     ----- Begin Forwarded Messages -----From: masinter.paDate: 28 Feb 88 8:07:18 PSTSubject: Issue: COERCE-INCOMPLETETo: cl-cleanup@sail.stanford.eduMessage-ID: <880228-080805-2138@Xerox>I'm not really back until next week, but this came in for consideration...----------Return-Path: <@RELAY.CS.NET:a37078%tansei.cc.u-tokyo.junet@UTOKYO-RELAY.CSNET>Received: from RELAY.CS.NET by Xerox.COM ; 25 FEB 88 23:39:52 PSTReceived: from relay2.cs.net by RELAY.CS.NET id aa07232; 26 Feb 88 2:16 ESTReceived: from utokyo-relay by RELAY.CS.NET id aa26262; 26 Feb 88 2:06 ESTReceived: by ccut.cc.u-tokyo.junet (5.51/6.3Junet-1.0/CSNET-JUNET)	id AA19019; Fri, 26 Feb 88 15:54:40 JSTReceived: by tansei.cc.u-tokyo.junet (4.12/6.3Junet-1.0)	id AA12493; Fri, 26 Feb 88 15:55:57+0900Date: Fri, 26 Feb 88 15:55:57+0900From: Masayuki Ida <a37078%tansei.cc.u-tokyo.junet@UTOKYO-RELAY.CSNET>Return-Path: <a37078@tansei.cc.u-tokyo.junet>Message-Id: <8802260655.AA12493@tansei.cc.u-tokyo.junet>To: ida%tansei.cc.u-tokyo.junet@UTOKYO-RELAY.CSNET, masinter.paSubject: CoercionDear Larry Masinter,I wrote my opinion on coercion which is attached consulting your suggestion on the format.Please find and use if you think it is valuable to have.Masayuki Ida--------------------------------------------------------------------Issue:	CoerceReference:	coerce (CLtL p50)Category:	changeEdit history:	version 1 by M.Ida,  26-Feb-1988Problem Description:--------------------Problem 1:Coerce is not symmetric or not generic among data types.In CLtL, Coerce is defined in page 50 and 51 that, 1) a sequence type may be converted to any other sequence type. 2)Some strings, symbols, and integers may be converted to characters.  2-1) If object is a string of length 1,      then the sole element of the string is returned. 2-2) If object is a symbol whose print name is of length 1,      then the sole element of the print name is returned.  2-3) If object is an integer n,      then (int-char n) is returned.3) any non-complex number can be converted to a XXX-float.4) any number can be converted to a complex number.The next table shows that how coerce is not symmetric among character,string, symbol and integer.    TABLE 1. Possible Conversions among character, string,symbol, integertype of conversion      provided functions              coercion under the CLtL character -> string    string                                      X character <- string    coerce (if the string has only one char.)   O character -> symbol    (intern (string @i[ch]))                    X character <- symbol    coerce (if pname length is 1)               O character -> integer   char-code, char-int                         X character <- integer   code-char (zero font-, zero bits- attrib.)  O                         int-char (any font- and any bits-) string -> symbol       intern, make-symbol                         X string <- symbol       string, symbol-name                         X string -> integer      (char-code (coerce @i[string] 'character))  X string <- integer      (string (code-char @i[integer]))            X symbol -> integer      (char-code (coerce @i[symbol] 'character))  X symbol <- integer      (intern (string (code-char @i[integer])))   XProblem 2:The function of coerce for character is defined to act as char-int/int-char not as char-code/code-char.Proposal: Coerce :replace-------------------------COERCE should be more generalized for string, symbol, integer, and characterdata types. The observations show there are no problem if extensions are fully written out in the details.Here is an extension to the current coerce definition using the CLOS.(defmethod coerce ((x character) (y (eql string))) (string x))(defmethod coerce ((x character) (y (eql symbol))) (intern (string x)))(defmethod coerce ((x character) (y (eql integer))) (char-code x))(defmethod coerce ((x string) (y (eql symbol))) (intern x))(defmethod coerce ((x symbol) (y (eql string))) (string x))(defmethod coerce ((x string) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql string))) (string (code-char x)))(defmethod coerce ((x symbol) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql symbol)))           (intern (sting (code-char x))))(defmethod coerce ((x integer) (y (eql character)))   (code-char x)) ; redefinition. CLtL defines as int-charThe keys are a) ignore char-bits and char-font upon the conversion of characters, assuming font-attribute will be flushed from the language spec.b) ignore the package name upon the conversion of symbols.(package name has no role upon the conversion.)c) the created symbol will be interned to the current package.Rationale:----------By extending the definition as this document suggests, the functionalityof coerce is symmetric among characters, strings, symbols and integers.Current Practice:Cost to implementors:Cost to users:Benefits:Aesthetics:Discussion:Among the functions in Table 1, we can pick up the role of @t[STRING] function.@T[STRING] has odd definition. It was alsothe starting point of discussions described in the following.The problems or the awkwards are mainly on the design of the symmetry of the function names.We would start the discussion with the following two observations.@* i) @t[(string @i(x))] is OK. But, @t[(coerce @i(x) 'string)] is illegal.@*While, @t[(character @i(x))] is OK. And @t[(coerce @i(x) 'character)] is OK too..@*ii) To convert from a symbol to a string, use @t[SYMBOL-NAME] or @t[STRING]. While, to convert from a string to a symbol, use @t[MAKE-SYMBOL] to an uninterned symbol, or use @t[INTERN] to an interned symbol.@*@*@*@b[ Discussions on Coercion in Common-Lisp E-mails 1986]The awkward were discussed already in Common-lisp E-mails.The author checked the 10M bytes E-mails on disk.The discussions around @t[coerce] were almost in 1986, and not much in 1985 or before.The sequence of our concern started by a mail of fateman@@dali.berkeley.edu,dated Fri, 16 May 1986 15:40 PDT as follows.@*1) fateman@@dali.berkeley.edu fri 16 may 1986 15:40 PDT:@*This mail describes the same issue as for STRING function.2) jeff@@aiva.edinburgh.ac.uk sun 18 may 17:17 GMT@*@t[ ...  'string' applied to a sequence of characters gives an error, typically saying the sequence can't be coerced to a string, but 'coerce' will in fact coerce it...]3) gls@@think.com, Mon 19 may 1986 12:20 EDT@*@begin[t]Research shows that the Common Lisp archives up to a couple of monthsago contains 18 messages that mention @t[COERCE].  None explicitly addressesthis issue, but the general tone of the messages is one of conservatism.I now remember that this issue was tied up with the design of thesequence functions.  There was real resistance to letting symbols betreated as general sequences, and so the general decision was made thatstring-specific functions would accept symbols, but general sequencefunctions would not. ...@end[t] To check his talk, @b[3.3] shows all the early discussions on @t[coerce] the author can find.4) fahlman@@c.cs.cmu.edu  Mon, 19 May 1986 20:44 EDT@*@t[... I would not object to generalizing coerce to handle some of the additional cases that people imagine it ought to handle.]@begin[verbatim]5) cfry@@oz.ai.mit.edu, Tue, 20 May 1986 03:21 EDT@*... Coercion is a powerful, easy to remember concept. I think it should be extended as much as possible.  ...  :   (coerce #\a 'string) => "a"   (coerce 123 'string) => "123"   (coerce #\a 'integer) => (char-code #\a) ; explicitly not provided CLtL p52. It appears that the only reason is that no one could decide on using char-code or char-int for the conversion so they chose not to do it at all. This reasoning is odd. Pick the most frequently used way, document it, and permit it. Same argument for coercion of numeric types.Further out extensions might be: (coerce #'foo 'compiled-function) => returns a compiled function object ... (coerce string-1 'pathname) (coerce bit-vector-1 'integer) ...Undoubtedly there are other coercions which would make sense. ... Users would save a lot of manual searching if coerce was extended.@end[verbatim]6) Eliot@@umass-cs.csnet,  Tue 20 May 1986 15:31 EST@*@t[Coercing symbols to stings is fine, as long as NIL is treated asthe empty SEQUENCE, rather than as a symbol.]@begin[verbatim]7) REM@@IMSSS, 19 May 09:34 PST  referring to the mail of gls sayingthat "@t[COERCE] was limited to ... sequence and numerical coercions".This is one of the bad points of many LISPs, including CL, functions thatare miss-named or otherwise don't do what you'd expect from their name. ... I hope the international standards committee will fix this kind ofproblem so programmers reading somebody else's code can have the meaningapparent in most cases form general programming tradition rather thanhaving to constantly check the manual to see if the function does whatit seems to say it would do.8) DCP@@scrc-quabbin.arpa, Wed, 21 May 1986 16:45 EDT,@*Does (coerce @i(symbol) 'string) return     (symbol-name @i(symbol)), or   (format nil "~S" @i(symbol)), or   (format nil "~A::~A"       (package-name (symbol-package @i(symbol))) (symbol-name @i(symbol)))or what ?  If this weren't enough, added in with my personal views ofstyle and functionality, for me to want to help veto this coercion, thespecial casing of NIL certainly would.  Programs should reflect theirmeaning.  A string is a sequence, a symbol is not.  Why shouldn't@#  (coerce :ascii-EOT 'integer)work?  The answer is that the requested behavior is not a coercionbetween compatible types, it is a functional translation between humanunderstandable names for the ascii control characters and the integersthat are their corresponding values.@end[verbatim]We found that there is a possibility to extend the semantics of @t[coerce]to cope with more generic types. It should be noted that the two key designers of Common Lispmentioned their opinions, and they do not always be against to the extension.The discussion was stopped at this point and we cannot find their continuation yet.We find from this story that @*1) If we don't care about the package, we may extend the coerceto the function from a symbol to a string, @*2) If we are free to care about the font- and bits- attribute, we may extend the coerce to include the function from a character to other types.@*@*@*@b[ Early discussions on coercion]The following sequence was picked up from the archives. They are almost all the meaningful talk the author can find. They were in 1983, one year before @i(CLtL) was published.@begin(verbatim)1) Guy Steele, dated 27 May 83 01:23:14 EDT, (in the summary of the discussion with DLW and moon upon the laser edition update) a)No.38: it is noted that DLW said "coercing of characters to integersshould probably be allowed too." and this point was marked as {controversial}.b) Moon's comment. "if (string x) <=> (coerce x 'string) exactly, say so.Both of these should coerce a character into a 1-element string; neither says so now. The old argument against this, that people might expect string of a number to give not numbers." and Guy Steele agreed.N.197: {gloss} string is required to signal an error if its argument is not astring and not a symbol.  This is wrong; it should convert a character to aone-character string.  Also it says that string will not convert a sequence ofcharacters into a string, but coerce will.  This might be all right, exceptunder coerce it says that when coercing to a string the implementation isallowed to return a more general type. ... Also the coerce writeupdoesn't say anything for or against coercing from a character to a 1-long string.{controversial} {will clarify}2) Fahlman, dated Sat, 28 May 1983 22:34 EDT;At least, I would like you to consider dropping these. ...Page 38: Coercing of characters to integers is not a very useful operation in portable code if the language spec does not specify the correspondence (and Common Lisp does not).  Do you still want to propose that we add this coercion?I'm not particularly opposed, I just worry that users will find it too easy to inadvertently do non-portable things if given this coercion.3) Moon, date: sat, 28 May 1983, 22:40-EDTI don't think coercion of characters to integers should be allowed, becausehow do you know whether you want the char-code or what.  Dan was probablyjust stuck in our old mindset from not having character objects on the Lispmachine. Coercion of characters to strings, however, I believe is useful.4) Daniel L.Weinreb, Date: Tuesday, 31 May 1983, 15:40-EDT... It's OK with me if COERCE doesn't coerce characters to integers. However, I strongly suggest putting in a clarification note to that effect... Or maybea Rationale note saying that it doesn't because it wouldn't be clear what to doabout the char-code versus whole character, and telling you to use the particularlyfunction instead. This note is for the benefit of users more than of implementors.5) Scott E. Fahlman, Date: Wed, 1 Jun 1983  01:47 EDT < referring 4)>    It's OK with me if COERCE doesn't coerce characters to integers.    However, I strongly suggest putting in a clarification note to that ...<< I assume Guy will do this. >>@end(verbatim)  As far as we can see from this talk, that the process of making a coercion betweencharacters and integers be restricted such that char-to-integer conversion is not provided,while integer-to-char is. The coercions from characters to integers arepurposely not provided; @t[char-code] or @t[char-int] may be used explicitly toperform such conversions (See @b[Appendix] for the definitions of @t[char-code]and @t[char-int]).The difference between @t(char-int) and @t(char-code) is on the treatment of@i(font) and @i(bits) attributes.If these two attributes have no significant meaning and are ignored by everyone,we can make the story much simpler. (And @b[4.] describes at least font- isnot alive).     ----- End Forwarded Messages -----*start*01557 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 19 JUN 88 22:46:14 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 19 Jun 88  22:45:51 PDTReceived: from Chardonnay.ms by ArpaGateway.ms ; 19 JUN 88 22:44:31 PDTDate: 19 Jun 88 22:44 PDTFrom: Masinter.paSubject: Re: Issue: COERCE-INCOMPLETEIn-reply-to: Masayuki Ida <ida%aoyama.cc.aoyama.junet@UTOKYO-RELAY.CSNET>'s message of Mon, 13 Jun 88 11:07:16 JSTTo: ida%aoyama.cc.aoyama.junet@UTOKYO-RELAY.CSNETcc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <880619-224431-6041@Xerox>A brief summary of our discussion of the issue COERCE-INCOMPLETE:We think that COERCE is incomplete in some ways. However, we are not all happywith the ways that you propose. Making COERCE symmetric would probably be a bad idea, e.g., that it can coercefrom INTEGER to FLOAT and not from FLOAT to INTEGER is on purpose. We think COERCE from integer to character is odd and non-portable and think itperhaps should be removed from the standard.COERCE from character to STRING is a good idea. We are now puzzled by the inconsistency of (COERCE x 'STRING) vs (STRING x) andwant to reduce it.We would like (COERCE x 'PATHNAME) to work like (PATHNAME x). The reason that (COERCE symbol 'STRING) is difficult is that (COERCE 'NIL'STRING) as a symbol could return "NIL", but (COERCE '() 'STRING) as the emptylist could return "". FUNCTION-TYPE has extended COERCE to work for 'FUNCTION.*start*01083 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 JUN 88 09:04:47 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 10 Jun 88  09:03:59 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA04670; Fri, 10 Jun 88 12:01:32 EDTMessage-Id: <8806101601.AA04670@multimax.ARPA>To: cl-cleanup@sail.stanford.edu, a37078%tansei.cc.u-tokyo.junet@relay.cs.netSubject: Re: Issue: COERCE-INCOMPLETEDate: Fri, 10 Jun 88 12:01:31 EDTFrom: Dan L. Pierson <pierson@multimax.ARPA>While I support the idea of filling out a more complete coercion matrix forCommon Lisp, I find some of the specifics of this proposal counter-intuitiveand unpleasant.  For example, I would like the following to return 5:    (COERCE "5" 'INTEGER)I would also like the following to work and return 456:    (COERCE "456" 'INTEGER)This proposal would require the first expression to return 53 (for asciiimplementations) and force the second expression to signal an error (Ithink). *start*03003 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 20 JUN 88 09:21:45 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Jun 88  09:21:27 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 421917; Mon 20-Jun-88 12:20:05 EDTDate: Mon, 20 Jun 88 12:19 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-FROM-TYPE (Version 1) To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880620121941.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:          COERCE-FROM-TYPEReferences:     COERCE (p51)Related-Issues: COERCE-INCOMPLETECategory:       ADDITIONEdit history:   20-Jun-88, Version 1 by PitmanStatus:	        For Internal DiscussionProblem Description:  COERCE is difficult to extend because ambiguities arise about the  source type of the coercion.  For example, should (COERCE NIL 'STRING) return "" or "NIL".  The choice would be arbitrary unless you knew whether NIL was being  viewed as an empty list or a symbol.  Similarly, (COERCE (CHAR-CODE #\A) 'STRING) might return the same  as (FORMAT NIL "~D" (CHAR-CODE #\A)) -- "65" in most ASCII-based  implementations -- or it might return "A", depending on whether the  result of char-code was viewed as a number or more specifically as  a character code.Proposal (COERCE-FROM-TYPE:NEW-ARGUMENT):  Add an extra optional argument to COERCE which specifies the type  from which the coercion is to be done. The new syntax would be:   COERCE object to &optional (from (TYPE-OF object))  Constrain that FROM must be such that (TYPEP OBJECT FROM) is true.Rationale:  This leaves room for a subsequent proposal to extend COERCE in  interesting ways. For example, extensions such as the following  might be considered:   (COERCE NIL 'STRING 'LIST)   => ""   (COERCE NIL 'STRING 'SYMBOL) => "NIL"  A new type CHAR-CODE might even be introduced as   (DEFTYPE CHAR-CODE () `(INTEGER 0 (,CHAR-BITS-LIMIT)))  so that COERCE could handle cases like:   (EQUAL (COERCE (CHAR-CODE #\A) 'STRING 'NUMBER)	  (FORMAT NIL "~D" (CHAR-CODE #\A))) => T   (COERCE (CHAR-CODE #\A) 'STRING 'CHAR-CODE) => "A"  Such specific proposals are deliberately not part of this proposal  in order to separate the general purpose mechanism from the more  specific details.Current Practice:  Probably no one implements the proposed behavior at this time.Cost to Implementors:  The more optimization a compiler does (or might do) of COERCE, the more  work might be necessary. In general, however, the changes would probably  not involve a major amount of work.Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  Various proposals to extend COERCE would probably not pass because  not everyone can agree on how to view the type of the first argu*start*03361 00024 USaReturn-Path: <@RELAY.CS.NET:ida%cc.aoyama.junet@UTOKYO-RELAY.CSNET>Received: from RELAY.CS.NET ([10.4.0.5]) by Xerox.COM ; 18 JUL 88 13:33:16 PDTReceived: from relay2.cs.net by RELAY.CS.NET id ae06456; 18 Jul 88 15:59 EDTReceived: from utokyo-relay by RELAY.CS.NET id bk06152; 18 Jul 88 15:43 EDTReceived: by ccut.cc.u-tokyo.junet (5.51/6.3Junet-1.0/CSNET-JUNET)	id AA13849; Mon, 18 Jul 88 18:03:26 JSTReceived: by kepa.cc.aoyama.junet (3.2/6.3Junet-1.0)	id AA05351; Mon, 18 Jul 88 16:55:32 JSTDate: Mon, 18 Jul 88 16:55:32 JSTFrom: Masayuki Ida <ida%cc.aoyama.junet@UTOKYO-RELAY.CSNET>Return-Path: <ida@cc.aoyama.junet>Message-Id: <8807180755.AA05351@kepa.cc.aoyama.junet>To: ida%cc.aoyama.junet@UTOKYO-RELAY.CSNET, masinter.paSubject: COERCE-FROM-TYPE and TYPE-OFThank you for forwarding an interesting mail to me.Here is my response.	Date: 12 Jul 88 16:45 PDT	From: Masinter.pa@xerox.com	This seems like an interesting solution...	     ----- Begin Forwarded Messages -----	Date: Mon, 20 Jun 88 12:19 EDT	From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>	Subject: Issue: COERCE-FROM-TYPE (Version 1) 	To: CL-Cleanup@SAIL.STANFORD.EDU	Message-ID: <880620121941.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>	Issue:          COERCE-FROM-TYPE	References:     COERCE (p51)	Related-Issues: COERCE-INCOMPLETE	Category:       ADDITION	Edit history:   20-Jun-88, Version 1 by Pitman	Status:	        For Internal Discussion	Problem Description:	  COERCE is difficult to extend because ambiguities arise about the	  source type of the coercion.	  For example, should (COERCE NIL 'STRING) return "" or "NIL".	  The choice would be arbitrary unless you knew whether NIL was being	  viewed as an empty list or a symbol.My primary points are on the relation to CLOS and the simplicity whichmight be obtained as a result of the integration.I further thought that coerce can be viewed as a generic function(I know recent talk of the mailing list for this).So I thought it is possible to define for the ambiguous casesconsulting type hierarchy related things in CLOS.For the above example, since CLOS defines the class precedence list for NULLas (null symbol list sequence t),(coerce nil 'string) should be "NIL" first if there are no special methods.I had thought that COERCE should grow up into a kind of universal function.But I realized that the current role of COERCE seems to be a very low level primitive.	Proposal (COERCE-FROM-TYPE:NEW-ARGUMENT):	  Add an extra optional argument to COERCE which specifies the type	  from which the coercion is to be done. The new syntax would be:	   COERCE object to &optional (from (TYPE-OF object))                                            ^^^^^^^^^^^^^^^^Did you finish the discussions on TYPE-OF ?When I raised the TYPE-OF issue two years ago on Common Lisp mailing list,we could not draw any conclusion at that time.The main issue of two years ago is symbolized by thefollwoing phrase of Dan Weinreb(?) or someone ; "we cannot definethe value of TYPE-OF even for 1. It maight be FIXNUM, INTEGERor more machine dependent one."I think its a good idea to add a third optional parameter for coerce.But is it good thing to choose TYPE-OF for this ?How about to use CLASS-OF for it ?Is it on too-abstract level ?Masayuki Ida*start*01201 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 04 SEP 88 16:18:02 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 4 Sep 88  16:09:45 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 04 SEP 88 16:05:13 PDTDate: 4 Sep 88 16:05 PDTFrom: Masinter.paSubject: Issue: COERCE (Version 1) vs COERCE-FROM-TYPEIn-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 20 Jun 88 12:19 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880904-160513-8886@Xerox>Kent: I think that the issues COERCE-FROM-TYPE and COERCE-INCOMPLETE are thesame issue, with two separate proposals. I'd like to merge the discussion ofthem, since I favor the combination of the two proposals better than either onealone, that is, add the TYPE argument, use the class precedence list to definethe priority when there is an ambiguity of how to view the type. M.Ida brought up a good point in his message of 18 Jul 88; do we need a cleanupto redefine TYPE-OF to be the same as (CLASS-NAME (CLASS-OF x)) ?*start*01410 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 SEP 88 02:33:24 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Sep 88  02:32:47 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 13 SEP 88 02:30:47 PDTDate: 13 Sep 88 02:31 PDTFrom: masinter.paSubject: Re: COERCE-FROM-TYPE and TYPE-OFIn-reply-to: your message of Mon, 18 Jul 88 16:55:32 JSTTo: Masayuki Ida <ida%cc.aoyama.junet@UTOKYO-RELAY.CSNET>, cl-cleanup@Sail.stanford.edu, peck@sun.comMessage-ID: <880913-023047-2587@Xerox>I think we need a cleanup item to redefine TYPE-OF to be basically (CLASS-NAME(CLASS-OF x)) with perhaps a few exceptions for vectors and arrays. I agree that "COERCE object to &optional (from (TYPE-OF object))" makes little sense without such a clarification. Certainly it would make senseto allow a class as well as a name as the optional "from" argument to COERCE.I'd like to see a merger of the COERCE-INCOMPLETE and COERCE-FROM-TYPE issuesinto a single one.A sample implementation of a conformal COERCE (which resorted to some built-inprimitives for data structure conversion) would be  useful addition to theproposal.Volunteers?This issue has been in the "pipe" too long. I'd like to see it ready in the nextcouple of weeks. So sooner rather than later.*start*01714 00024 USaReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 13 SEP 88 07:23:05 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 458237; Tue 13-Sep-88 10:23:15 EDTDate: Tue, 13 Sep 88 10:22 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: COERCE-FROM-TYPE and TYPE-OFTo: masinter.pacc: Masayuki Ida <ida%cc.aoyama.junet@UTOKYO-RELAY.CSNET>, cl-cleanup@SAIL.STANFORD.EDU, peck@sun.comIn-Reply-To: <880913-023047-2587@Xerox>Message-ID: <19880913142219.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 13 Sep 88 02:31 PDT    From: masinter.pa@Xerox.COM    I think we need a cleanup item to redefine TYPE-OF to be basically (CLASS-NAME    (CLASS-OF x)) with perhaps a few exceptions for vectors and arrays. I don't entirely agree.  CLASS-OF (88-002R pp.1-15 through 1-17) wascarefully defined to require the existence only of built-in classeson which it is clearly meaningful to put methods in portable programs.TYPE-OF (CLtL p.53) on the other hand is defined to be for debugging,not for type-dispatching, and to return as specific an answer as"convenient and useful."  Thus it seems unlikely that people wouldreally want these two to return the same answer, since they exist fordifferent purposes.Also 88-002R (chapter 2) says CLASS-NAME can return NIL.I would certainly oppose redefining CLASS-OF to have as vague adefinition as TYPE-OF.If it's proposed to redefine TYPE-OF to be no more specific thanCLASS-OF, I would counter-propose to eliminate TYPE-OF entirely,since it would be redundant.*start*00771 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 SEP 88 03:07:05 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Sep 88  03:06:32 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 21 SEP 88 03:05:12 PDTDate: 21 Sep 88 03:05 PDTFrom: masinter.paSubject: Issue: COERCE-INCOMPLETE (Version 1)To: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <880921-030512-5704@Xerox>I can't decide about this one (maybe its the wrong time of day again.) I'd liketo hear some opinions from the rest of you:extend coerce to handle more types?Add an extra argument? Make COERCE generic?Make COERCE take classes as well as type names?*start*08289 00024 US Date:  8 Oct 88 13:09 PDTFrom: masinter.paSubject: DRAFT Issue: COERCE-INCOMPLETE (Version 1)+To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterThis issue is still under debate and the writeup below is very rough. We think that TYPE-OF-UDERSPECIFIED might help make the issue clearer.We do not expect to discuss this issue in the full X3J13 session. This is just for your information that we're discussing the topic.Status: DRAFTIssue:	COERCE-INCOMPLETEReference:	coerce (CLtL p50)Category:	changeEdit history:	version 1 by M.Ida,  26-Feb-1988Problem Description:--------------------Problem 1:Coerce is not symmetric or not generic among data types.In CLtL, Coerce is defined in page 50 and 51 that, 1) a sequence type may be converted to any other sequence type. 2)Some strings, symbols, and integers may be converted to characters.  2-1) If object is a string of length 1,      then the sole element of the string is returned. 2-2) If object is a symbol whose print name is of length 1,      then the sole element of the print name is returned.  2-3) If object is an integer n,      then (int-char n) is returned.3) any non-complex number can be converted to a XXX-float.4) any number can be converted to a complex number.The next table shows that how coerce is not symmetric among character,string, symbol and integer.    TABLE 1. Possible Conversions among character, string,symbol, integertype of conversion      provided functions              coercion under the CLtL character -> string    string                                      X character <- string    coerce (if the string has only one char.)   O character -> symbol    (intern (string @i[ch]))                    X character <- symbol    coerce (if pname length is 1)               O character -> integer   char-code, char-int                         X character <- integer   code-char (zero font-, zero bits- attrib.)  O                         int-char (any font- and any bits-) string -> symbol       intern, make-symbol                         X string <- symbol       string, symbol-name                         X string -> integer      (char-code (coerce @i[string] 'character))  X string <- integer      (string (code-char @i[integer]))            X symbol -> integer      (char-code (coerce @i[symbol] 'character))  X symbol <- integer      (intern (string (code-char @i[integer])))   XProblem 2:The function of coerce for character is defined to act as char-int/int-char not as char-code/code-char.Proposal: Coerce :replace-------------------------COERCE should be more generalized for string, symbol, integer, and characterdata types. The observations show there are no problem if extensions are fully written out in the details.Here is an extension to the current coerce definition using the CLOS.(defmethod coerce ((x character) (y (eql string))) (string x))(defmethod coerce ((x character) (y (eql symbol))) (intern (string x)))(defmethod coerce ((x character) (y (eql integer))) (char-code x))(defmethod coerce ((x string) (y (eql symbol))) (intern x))(defmethod coerce ((x symbol) (y (eql string))) (string x))(defmethod coerce ((x string) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql string))) (string (code-char x)))(defmethod coerce ((x symbol) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql symbol)))           (intern (sting (code-char x))))(defmethod coerce ((x integer) (y (eql character)))   (code-char x)) ; redefinition. CLtL defines as int-charThe keys are a) ignore char-bits and char-font upon the conversion of characters, assuming font-attribute will be flushed from the language spec.b) ignore the package name upon the conversion of symbols.(package name has no role upon the conversion.)c) the created symbol will be interned to the current package.Rationale:----------By extending the definition as this document suggests, the functionalityof coerce is symmetric among characters, strings, symbols and integers.Current Practice:Cost to implementors:Cost to users:Benefits:Aesthetics:Discussion:<<discussion from original Common Lisp design.>>Making COERCE symmetric would probably be a bad idea, e.g., that it can coercefrom INTEGER to FLOAT and not from FLOAT to INTEGER is on purpose. We think COERCE from integer to character is odd and non-portable and think itperhaps should be removed from the standard.COERCE from character to STRING is a good idea. We are now puzzled by the inconsistency of (COERCE x 'STRING) vs (STRING x) andwant to reduce it.We would like (COERCE x 'PATHNAME) to work like (PATHNAME x). The reason that (COERCE symbol 'STRING) is difficult is that (COERCE 'NIL'STRING) as a symbol could return "NIL", but (COERCE '() 'STRING) as the emptylist could return "". FUNCTION-TYPE has extended COERCE to work for 'FUNCTION.    (COERCE "5" 'INTEGER) should return integer.Issue:          COERCE-FROM-TYPEReferences:     COERCE (p51)Related-Issues: COERCE-INCOMPLETECategory:       ADDITIONEdit history:   20-Jun-88, Version 1 by PitmanStatus:	        For Internal DiscussionProblem Description:  COERCE is difficult to extend because ambiguities arise about the  source type of the coercion.  For example, should (COERCE NIL 'STRING) return "" or "NIL".  The choice would be arbitrary unless you knew whether NIL was being  viewed as an empty list or a symbol.  Similarly, (COERCE (CHAR-CODE #\A) 'STRING) might return the same  as (FORMAT NIL "~D" (CHAR-CODE #\A)) -- "65" in most ASCII-based  implementations -- or it might return "A", depending on whether the  result of char-code was viewed as a number or more specifically as  a character code.Proposal (COERCE-FROM-TYPE:NEW-ARGUMENT):  Add an extra optional argument to COERCE which specifies the type  from which the coercion is to be done. The new syntax would be:   COERCE object to &optional (from (TYPE-OF object))  Constrain that FROM must be such that (TYPEP OBJECT FROM) is true.Rationale:  This leaves room for a subsequent proposal to extend COERCE in  interesting ways. For example, extensions such as the following  might be considered:   (COERCE NIL 'STRING 'LIST)   => ""   (COERCE NIL 'STRING 'SYMBOL) => "NIL"  A new type CHAR-CODE might even be introduced as   (DEFTYPE CHAR-CODE () `(INTEGER 0 (,CHAR-BITS-LIMIT)))  so that COERCE could handle cases like:   (EQUAL (COERCE (CHAR-CODE #\A) 'STRING 'NUMBER)	  (FORMAT NIL "~D" (CHAR-CODE #\A))) => T   (COERCE (CHAR-CODE #\A) 'STRING 'CHAR-CODE) => "A"  Such specific proposals are deliberately not part of this proposal  in order to separate the general purpose mechanism from the more  specific details.Current Practice:  Probably no one implements the proposed behavior at this time.Cost to Implementors:  The more optimization a compiler does (or might do) of COERCE, the more  work might be necessary. In general, however, the changes would probably  not involve a major amount of work.Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  Various proposals to extend COERCE would probably not pass because  not everyone can agree on how to view the type of the first argument.M.Ida respondsMy primary points are on the relation to CLOS and the simplicity whichmight be obtained as a result of the integration.I further thought that coerce can be viewed as a generic function(I know recent talk of the mailing list for this).So I thought it is possible to define for the ambiguous casesconsulting type hierarchy related things in CLOS.For the above example, since CLOS defines the class precedence list for NULLas (null symbol list sequence t),(coerce nil 'string) should be "NIL" first if there are no special methods.I had thought that COERCE should grow up into a kind of universal function.But I realized that the current role of COERCE seems to be a very low level primitive.Possibilities:extend coerce to handle more types?Add an extra argument? Make COERCE generic?Make COERCE take classes as well as type names?*start*08612 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 13:37:07 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  13:19:52 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 08 OCT 88 13:09:12 PDTDate: 8 Oct 88 13:09 PDTFrom: masinter.paSubject: DRAFT Issue: COERCE-INCOMPLETE (Version 1)+To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-130912-2162@Xerox>This issue is still under debate and the writeup below is very rough. We think that TYPE-OF-UDERSPECIFIED might help make the issue clearer.We do not expect to discuss this issue in the full X3J13 session. This is just for your information that we're discussing the topic.!Status: DRAFTIssue:	COERCE-INCOMPLETEReference:	coerce (CLtL p50)Category:	changeEdit history:	version 1 by M.Ida,  26-Feb-1988Problem Description:--------------------Problem 1:Coerce is not symmetric or not generic among data types.In CLtL, Coerce is defined in page 50 and 51 that, 1) a sequence type may be converted to any other sequence type. 2)Some strings, symbols, and integers may be converted to characters.  2-1) If object is a string of length 1,      then the sole element of the string is returned. 2-2) If object is a symbol whose print name is of length 1,      then the sole element of the print name is returned.  2-3) If object is an integer n,      then (int-char n) is returned.3) any non-complex number can be converted to a XXX-float.4) any number can be converted to a complex number.The next table shows that how coerce is not symmetric among character,string, symbol and integer.    TABLE 1. Possible Conversions among character, string,symbol, integertype of conversion      provided functions              coercion under the CLtL character -> string    string                                      X character <- string    coerce (if the string has only one char.)   O character -> symbol    (intern (string @i[ch]))                    X character <- symbol    coerce (if pname length is 1)               O character -> integer   char-code, char-int                         X character <- integer   code-char (zero font-, zero bits- attrib.)  O                         int-char (any font- and any bits-) string -> symbol       intern, make-symbol                         X string <- symbol       string, symbol-name                         X string -> integer      (char-code (coerce @i[string] 'character))  X string <- integer      (string (code-char @i[integer]))            X symbol -> integer      (char-code (coerce @i[symbol] 'character))  X symbol <- integer      (intern (string (code-char @i[integer])))   XProblem 2:The function of coerce for character is defined to act as char-int/int-char not as char-code/code-char.Proposal: Coerce :replace-------------------------COERCE should be more generalized for string, symbol, integer, and characterdata types. The observations show there are no problem if extensions are fully written out in the details.Here is an extension to the current coerce definition using the CLOS.(defmethod coerce ((x character) (y (eql string))) (string x))(defmethod coerce ((x character) (y (eql symbol))) (intern (string x)))(defmethod coerce ((x character) (y (eql integer))) (char-code x))(defmethod coerce ((x string) (y (eql symbol))) (intern x))(defmethod coerce ((x symbol) (y (eql string))) (string x))(defmethod coerce ((x string) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql string))) (string (code-char x)))(defmethod coerce ((x symbol) (y (eql integer)))           (char-code (coerce x 'character)))(defmethod coerce ((x integer) (y (eql symbol)))           (intern (sting (code-char x))))(defmethod coerce ((x integer) (y (eql character)))   (code-char x)) ; redefinition. CLtL defines as int-charThe keys are a) ignore char-bits and char-font upon the conversion of characters, assuming font-attribute will be flushed from the language spec.b) ignore the package name upon the conversion of symbols.(package name has no role upon the conversion.)c) the created symbol will be interned to the current package.Rationale:----------By extending the definition as this document suggests, the functionalityof coerce is symmetric among characters, strings, symbols and integers.Current Practice:Cost to implementors:Cost to users:Benefits:Aesthetics:Discussion:<<discussion from original Common Lisp design.>>Making COERCE symmetric would probably be a bad idea, e.g., that it can coercefrom INTEGER to FLOAT and not from FLOAT to INTEGER is on purpose. We think COERCE from integer to character is odd and non-portable and think itperhaps should be removed from the standard.COERCE from character to STRING is a good idea. We are now puzzled by the inconsistency of (COERCE x 'STRING) vs (STRING x) andwant to reduce it.We would like (COERCE x 'PATHNAME) to work like (PATHNAME x). The reason that (COERCE symbol 'STRING) is difficult is that (COERCE 'NIL'STRING) as a symbol could return "NIL", but (COERCE '() 'STRING) as the emptylist could return "". FUNCTION-TYPE has extended COERCE to work for 'FUNCTION.    (COERCE "5" 'INTEGER) should return integer.!Issue:          COERCE-FROM-TYPEReferences:     COERCE (p51)Related-Issues: COERCE-INCOMPLETECategory:       ADDITIONEdit history:   20-Jun-88, Version 1 by PitmanStatus:	        For Internal DiscussionProblem Description:  COERCE is difficult to extend because ambiguities arise about the  source type of the coercion.  For example, should (COERCE NIL 'STRING) return "" or "NIL".  The choice would be arbitrary unless you knew whether NIL was being  viewed as an empty list or a symbol.  Similarly, (COERCE (CHAR-CODE #\A) 'STRING) might return the same  as (FORMAT NIL "~D" (CHAR-CODE #\A)) -- "65" in most ASCII-based  implementations -- or it might return "A", depending on whether the  result of char-code was viewed as a number or more specifically as  a character code.Proposal (COERCE-FROM-TYPE:NEW-ARGUMENT):  Add an extra optional argument to COERCE which specifies the type  from which the coercion is to be done. The new syntax would be:   COERCE object to &optional (from (TYPE-OF object))  Constrain that FROM must be such that (TYPEP OBJECT FROM) is true.Rationale:  This leaves room for a subsequent proposal to extend COERCE in  interesting ways. For example, extensions such as the following  might be considered:   (COERCE NIL 'STRING 'LIST)   => ""   (COERCE NIL 'STRING 'SYMBOL) => "NIL"  A new type CHAR-CODE might even be introduced as   (DEFTYPE CHAR-CODE () `(INTEGER 0 (,CHAR-BITS-LIMIT)))  so that COERCE could handle cases like:   (EQUAL (COERCE (CHAR-CODE #\A) 'STRING 'NUMBER)	  (FORMAT NIL "~D" (CHAR-CODE #\A))) => T   (COERCE (CHAR-CODE #\A) 'STRING 'CHAR-CODE) => "A"  Such specific proposals are deliberately not part of this proposal  in order to separate the general purpose mechanism from the more  specific details.Current Practice:  Probably no one implements the proposed behavior at this time.Cost to Implementors:  The more optimization a compiler does (or might do) of COERCE, the more  work might be necessary. In general, however, the changes would probably  not involve a major amount of work.Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  Various proposals to extend COERCE would probably not pass because  not everyone can agree on how to view the type of the first argument.!M.Ida respondsMy primary points are on the relation to CLOS and the simplicity whichmight be obtained as a result of the integration.I further thought that coerce can be viewed as a generic function(I know recent talk of the mailing list for this).So I thought it is possible to define for the ambiguous casesconsulting type hierarchy related things in CLOS.For the above example, since CLOS defines the class precedence list for NULLas (null symbol list sequence t),(coerce nil 'string) should be "NIL" first if there are no special methods.I had thought that COERCE should grow up into a kind of universal function.But I realized that the current role of COERCE seems to be a very low level primitive.Possibilities:extend coerce to handle more types?Add an extra argument? Make COERCE generic?Make COERCE take classes as well as type names?*start*01343 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 12:51:13 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  12:51:32 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475736; Thu 13-Oct-88 15:50:10 EDTDate: Thu, 13 Oct 88 15:50 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETE (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013155002.7.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: KMP took responsibility for next draft.X3J13 meeting: RWK: Maybe we should just remove COERCE? Beckerle: Maybe we should make COERCE generic? KMP: It is inappropriate to make anything generic if you cannot describe      what it does. Since this issue is about what COERCE does, the issue      cannot be solved by making COERCE generic.  Greenblatt: Let's keep generic functions out of the language as must as	     possible on this "first round". [KMP thinks he meant the standard	     we're working on -- leaving the issue of making more things	     generic for a later standard.]*start*01066 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 12:56:04 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  12:56:12 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA17317; Thu, 13 Oct 88 13:54:35 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19818; Thu, 13 Oct 88 13:54:32 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810131954.AA19818@defun.utah.edu>Date: Thu, 13 Oct 88 13:54:31 MDTSubject: issue COERCE-FROM-TYPETo: cl-cleanup@sail.stanford.eduI don't like the idea of adding another argument to COERCE just tohandle one or two strange cases.  For coercing NIL to be a string, Iagree with Ida that the right thing to do is to use the sameprecedence rules as CLOS to disambiguate the situation.  And, I thinkthe whole idea of coercing a number to a string is pretty bogus,particularly since there isn't any one obvious way to do it.-Sandra-------*start*01617 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 11:53:15 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 26 Oct 88  11:51:28 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 26 OCT 88 11:40:05 PDTDate: 26 Oct 88 11:37 PDTFrom: masinter.paSubject: Issue: COERCE-INCOMPLETETo: cl-cleanup@sail.stanford.eduMessage-ID: <881026-114005-13463@Xerox>a) the definition of COERCE says that "If {\arg object} is already of {\argresult-type} (as determined by {\function typep}), {\arg object}is returned. Copying of {\arg object} is not necessary."Should this say "is not performed"? That is, (when (typep x y) (assert (eql x (coerce x y))))for all objects x, for all valid type specifiers y?Are there any implementations that do copy any types?I think the specification of COERCE will be clearer if the operation isdescribed sorted by type specifier rather than by the type of the object. Ithink that's how most implementations work. However, the description startsout talking about the type of "object" and only then talks about the typespecifiers.Certainly this is a "multi-method", but the resolution is right-to-leftrather than left-to-right, I think.Does COERCE work for types that are DEFTYPEd? I.e.,(DEFTYPE FROB () '(VECTOR (SIGNED-BYTE 3)))(COERCE X 'FROB)?The Problem Statement is that Coerce is incomplete and confusing. We maynot need to change the language to fix the problem, but we certainly needto clear up the description.*start*02395 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 15:24:28 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 22 Nov 88  15:21:36 PSTReceived: by ti.com id AA27050; Tue, 22 Nov 88 17:20:31 CSTReceived: from Kelvin by tilde id AA22859; Tue, 22 Nov 88 17:15:18 CSTMessage-Id: <2805232596-1141998@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 22 Nov 88 17:16:36 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.Stanford.EDU, Bartley@MIPS.csc.ti.comSubject: Re: Issue: COERCE-INCOMPLETE (Version 2)In-Reply-To: Msg of Mon, 21 Nov 88 18:02 EST from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>> Problem Description:> >   COERCE is difficult to extend because ambiguities arise about the>   source type of the coercion.> >   For example, if the symbol STRING were permitted as a second argument>   to coerce, as in (COERCE NIL 'STRING), there would be two posssible>   return values: "" or "NIL". The choice would be arbitrary and would>   have to be specified by the documentation. No matter which was chosen,>   it would probably turn out to be a problem for some applications at>   some times.In my opinion, I don't buy this as being a valid problem.  There areactually more possibilities than you have listed -- converting NIL to astring might be desired to result in "", "()", "NIL", "nil", "Nil", or"LISP:NIL" depending on what the user has in mind.  Granted that (COERCE NIL 'STRING 'SYMBOL) may be easier to remember than using SYMBOL-NAME or using (FORMAT NIL ...) and having to decide whether touse ~A or ~S, what *PRINT-CASE* should be, etc., but is that reallymaking it easier for the user to get the result he wants, or is it justallowing him to write code without having to think about what he reallymeans?   >   14. INTEGRAL-FLOAT <-> INTEGER> >       a. (COERCE x 'INTEGER 'INTEGRAL-FLOAT)> 	 == (TRUNCATE x)> >       b. (COERCE x 'INTEGRAL-FLOAT 'INTEGER)> 	 == (FLOAT x)There are several specific cases I could pick on, but here, for example,if a user can't remember the TRUNCATE function, how is he going toremember the INTEGRAL-FLOAT type and understand how to use it correctly?TRUNCATE seems a much simpler concept.*start*04976 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 NOV 88 13:00:07 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Nov 88  12:58:27 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 497416; Wed 23-Nov-88 15:58:29 ESTDate: Wed, 23 Nov 88 15:58 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881121180215.8.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19881123205815.5.MOON@EUPHRATES.SCRC.Symbolics.COM>I oppose this proposal.  I think what it's trying to do fundamentallycannot work.  I would characterize what it's trying to do as trying tobring as many one-input-one-output functions under the umbrella ofCOERCE as possible.  (Even worse of course is cases like ACCESSIBLE-SYMBOLwhere the function has two inputs, but you're getting the second inputfrom a special variable.)type-specifiers are supposed to be names for sets of objects.  Twotype-specifiers that designate the same set of objects are supposed tobe usable interchangeably, except when their equivalence is uncomputablebecause of SATISFIES.  However, when we start making up newtype-specifier names as a back-door way (or an elegant way, depending onone's point of view) to tell COERCE what internal function to call, werun into two problems:First, it isn't clear whether one can call COERCE with a type-specifierthat designates the same set of objects as one of the builtin typespecifiers, and get the same result.  Suppose I define my own typespecifier that designates the same set of objects as INTEGER-STRING, forexample.  Are the second and third arguments to COERCE reallytype-specifiers, or are they really just specially-recognized symbolsthat are made to resemble type-specifiers to make them easier toremember?Second, and I think this is an even worse problem, when x is a subtypeof y, Kent sometimes calls for an x coercion which is not compatible withthe y coercion.  For example, the proposal appears to say that(COERCE 65 'STRING) => "A" but (COERCE 65 'INTEGER-STRING) => "65", eventhough INTEGER-STRING is a subtype of STRING.I think the proposal is a good try, but I think the original idea ofCOERCE was not well-founded enough to survive such addition of features.Kent wanted line by line comments, I suppose I can do that too.   1. CHARACTER <-> STRINGstring -> character already exists, I don't see any harm in adding the inverse,especially since the function STRING already does it.   2. CHAR-CODE <-> CHARACTER   3. CHAR-INT <-> CHARACTER   7. CHAR-CODE <-> STRING   8. CHAR-INT <-> STRING   9. CHAR-CODE <-> SYMBOL  10. CHAR-INT <-> SYMBOL  11. CHAR-CODE <-> ACCESSIBLE-SYMBOL  12. CHAR-INT <-> ACCESSIBLE-SYMBOLI oppose all coercions between characters and numbers as fundamentallywrong-headed.  The existing coercion from integer to character should beremoved.   4. STRING <-> SYMBOL1-character symbols can already be coerced to characters, so allowingcoercion of symbols to strings would be okay, especially since thefunction STRING already does it.  The inverse direction is a 2-argumentfunction and so should not be added; although Kent's suggestion ofreturning an uninterned symbol is interesting, I suspect this is notwhat users would expect.   5. STRING <-> ACCESSIBLE-SYMBOL2-argument function, also has subtype problem noted earlier.   6. INTEGER <-> INTEGER-STRINGMulti-argument function in both directions unless you are base-ten-centric.I don't think this is a good idea.  13. PATHNAME <-> STRINGThis is okay.  The function STRING already does pathname -> string in SCL.  14. INTEGRAL-FLOAT <-> INTEGERInteger -> float already exists.  The inverse would be okay except thatthe INTEGRAL-FLOAT type is implementation-dependent, since whether amathematical value is a member of this type depends on the precision ofthe floating-point representation of the machine; the explanation givenin CLtL that float -> integer conversion requires the user to thinkabout rounding applies, in my opinion.I'd be in favor of removing COERCE from the language entirely.  Let'slook at what COERCE does that can't be easily done another way:sequence to sequence coercion: same as CONCATENATE except that itfirst does a TYPEP check and if satisfied, returns the argumentwithout copying it.strings, symbols, and integers to character: there are alreadyfunctions to do this.non-complex numbers to float: there are already functions to do this.numbers to complex: combination of calling COMPLEXP and COMPLEX.anything to t: same as IDENTITY.I really don't think we would lose anything, aside from compatibilitywith existing programs, by flushing COERCE.*start*10667 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 13:53:41 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Nov 88  13:51:37 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496806; Tue 22-Nov-88 16:50:45 ESTDate: Tue, 22 Nov 88 16:50 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: COERCE-INCOMPLETE (Version 2) To: Rob.MacLachlan@WB1.CS.CMU.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: The message of 22 Nov 88 14:12 EST from Rob.MacLachlan@WB1.CS.CMU.EDUMessage-ID: <881122165053.3.KMP@BOBOLINK.SCRC.Symbolics.COM>I'm willing to deal with this on a line-item basis if people want to point tosome line items they would strike, change, or add in order to fix things.If people wanted to flush all of the made-up types, I wouldn't probably object.But I hope they'd do it for a more purposeful reason than just because itdoesn't perpetuate the status quo. I'm hoping that we'll at least adopt CHAR-CODEand CHAR-INT because I believe them to be the most useful.  What I wanted todo, though, was to present a fully elaborated proposal because the last version(COERCE-FROM-TYPE, v1) only alluded to what might be done and I was worriedthat the idea wasn't clear in everyone's mind. Perhaps now it's all too clear. :-)In the case of ACCESSIBLE-SYMBOL, I certainly agree with your reservationsto an extent, but let me tell you where I was coming from. Btw, I thinkthe SYMBOL coercion is far more suspect than the ACCESSIBLE-SYMBOL declarationfor reasons that I hope will become apparent.Anyway, let me address a number of specific points in an attempt to keepthis complicated conversation focused... * Version 1 of COERCE-INCOMPLETE from Japan proposed that coercing an   integer to a character should assume that INTERN should be called.   I wanted to address that request specifically and not just leave it   out as if I'd ignored their request.   The reason I could not address their proposal by simply including it   in mind is that it doesn't have the good `symmetry' property mentioned   in the outline. If you do 	(COERCE (COERCE *SOME-SYMBOL* 'STRING) 'SYMBOL)   and INTERN is the coercion from symbol to string, then this is only an   identity if *SOME-SYMBOL* is in the current package. The thing that an   ACCESSIBLE-SYMBOL declaration would tell you is that 	(EQ *SOME-SYMBOL* (INTERN (SYMBOL-NAME *SOME-SYMBOL*)))   The KEYWORD declaration provides that same piece of information, of   course, but it's not possible to make every symbol a keyword, while it   is possible to make every symbol accessible (albeit not at the same time).   As it happens, I don't feel a need to justify these as declarations. It's   not like all declarations in CL are indispensable. Sometimes it's good to   provide the capability just for completeness. There are plenty of other   declarations that are equivalently useful/useless. Nevertheless, in a   very real sense, they ought to be useful from both a discrimination and a   declaration standpoint because as discriminators they can test whether   COERCE is defined on them, and as declarations, they can say it is safe   for COERCE to do a particular coercion which in the absence of that    declaration might be very questionable.   These are not types in the sense that they could be classes, but that   doesn't make them unimportant. They are view types which specifically   address the issue that one real type (class) can be used to represent any   of several abstract types. And COERCE is about coercing abstract types,   not classes. If it were not, then it would be obvious what definition to   give it in all cases purely on the basis of CLASS-OF and there would be   no dispute. * The same problem came up with CHAR-CODE, by the way. The Japanese proposal   specified that they wanted integers to be treated as char-codes for   no apparent reason (other than, presumably, some particular pragmatic   reason they were focused on at the time they wrote the proposal). I wanted   to suit that need without compromising the useful property, so I concocted   CHAR-CODE. * You seem down on TYPE-OF. There are two issues here really:     - Is it necessary/appropriate for the `type' arguments to really be       types. It is possible, of course, to do like DOCUMENTATION and just       say there's a fixed list of words with no necessary relation to       types, for example.       In fact though, as I mentioned above, it's potentially useful, both       for discrimination and declaration, for them to be actual types.       So I saw no need to restrict that.     - More importantly, I might want to say that COERCE should just take       4 required arguments. In fact, I might want to invert arg3 and arg4       so that "coerce X from fixnum to float" was written        (COERCE X 'FIXNUM 'FLOAT).       The issues here, though, are ...	 . Compatibility. Making the argument required means that we'd           break existing code. My proposal avoids that problem. If we're	   going to break existing code, I'd just as soon we can justify it.	 . Convenience. Often, TYPE-OF (were it more well-defined), is	   exactly what is needed, so I think it's reasonable to establish	   it as a default. Further, the to-type is not something for which	   there is likely to be reasonable default, so it wants to precede	   the optinoal argument.       So I hope you can see from this why I resisted both my inclination to       make the `from' argument required, and to invert the argument order.  * I am, by the way, disturbed by your use of the phrase "isn't very    type-like". To me, the purpose of types is to identify the set of    operations on an object, and to restrict the amount of discrimination    which must be done for those operations which are generic. I think this    satisfies that purpose of types to the letter. If you want to make the    case that I'm doing something creative and interesting, then I'll buy    into it. If you want to make the case that I'm doing something    blasphemous, you'll have to advance a considerably more elaborate    philosophy and convince me to buy into it. I'm not saying I won't listen.    I'm just saying I don't see it.  * On the subject of INTEGRAL-FLOAT, I confess to using sloppy wording.    "no fraction" was obviously a poor choice. It took me all day to write this    thing and I didn't expect it to be a final draft, so I won't be surprised    if that's not the last such little typo.    Ditto about the typo in CHAR-INT. Thanks for spotting it.  * In answer to your question about why call COERCE (rather than FLOAT), I    think the answers are two (somewhat related):      - Some people just want to learn fewer operators. They needn't learn	FLOAT if they know COERCE. I happen not to be one of those people,	but I've heard it enough places to believe it to be true.      - You may wonder why COERCE is powerful enough to not need FLOAT. 	Note that currently, CL says you can convert any (non-complex)	number to a FLOAT. But that's not invertible. If instead it said	you could convert any rational to a float or any integer to an	integral-float, both of those operations would be invertible.  	Also, the union of these two capabilities (and of float<->float 	conversion, if you insist) is as powerful as what's offered now.	No functionality would be lost, and yet things would be described	in a way that permitted the nice `symmetry' property we're talking	about. * I'm confused about your remark that it is "treacherous to support    symmetric coercion for any pair of types where the coercion in either   direction is information losing". I'm trying to work through the exercise   to see if in fact any information is necessarily lost. Consider:    (COERCE (COERCE " S:>kmp>foo.lisp " 'PATHNAME 'STRING) 'STRING 'PATHNAME)   might return "S:>kmp>foo.lisp" rather than " S:>kmp>foo.lisp ".   Perhaps that argues for saying the argument type should be NAMESTRING,   rather than STRING, to emphasize that the exact contents of the string do   not matter, and that all that matters is the fact that the string    represents a particular pathname. If that's all it represents, then no   information has been lost in the coercion because spaces were not part of   the information. Remember, information is not structure -- it is structure   + an intent to interpret that structure according to a particular set of   rules. If those rules do not distinguish two structurally different   objects, then those objects are equal.   Anyway, I don't even necessarily think we have to -say- that COERCE is   symmetric by nature. It might just be nice if it turned out to be true   by accident ("true", but not "necessarily true" in the terms of Krypke --   is that how you spell his name?).[I keep putting `symmetry' in quotes because something tells me that when mathematicians say `symmetric' they mean something different than what we mean here. I think we know what we mean, but until someone tells me the usage is correct (or that it is not, and supplied a better term), I'll keep quoting it.]The bottom line is that people have complained a lot about COERCE andI'm trying to figure out what we might do about this. I'm not trying toforce anything down anyone's throat. But if we are going to analyze theproblem, we should do it thoughtfully and expect that there may be someintermediate expression swell of ideas before we arrive at a bottom line.I appreciate your having taken the time to read through the proposal indetail and to answer it constructively. I hope you'll have time to get tothis reply in as much detail.In particular, I'm interested in whether you buy any of my arguments atall, whether you think there's another solution to COERCE or if youthink it's fine as it is or if you think it's just hopelessly broken,and whether there are particular changes that could be made to myproposal to make it more palatable to you -- ie, is there anything ofvalue in what I've said or do you think it's just way off track?If you have time to go back and read the Japanese proposal (as annotatedand mailed to X3J13 by Masinter just before the last X3J13 meeting), youmight find that helpful. If you've lost your copy, I'll be happy to forwardyou a copy. -kmp*start*09811 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 NOV 88 15:04:20 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Nov 88  15:02:05 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496145; Mon 21-Nov-88 18:02:01 ESTDate: Mon, 21 Nov 88 18:02 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881121180215.8.KMP@BOBOLINK.SCRC.Symbolics.COM>Issue:		 COERCE-INCOMPLETEReference:	 COERCE (p50)Category:	 ADDITIONEdit history:	 Version 1 of COERCE-INCOMPLETE, 26-Feb-88 by M. Ida		 Version 1 of COERCE-FROM-TYPE,  20-Jun-88 by Pitman		 Version 2 of COERCE-INCOMPLETE, 21-Nov-88 by PitmanRequired-Issues: TYPE-OF-UNDERCONSTRAINEDProblem Description:  COERCE is difficult to extend because ambiguities arise about the  source type of the coercion.  For example, if the symbol STRING were permitted as a second argument  to coerce, as in (COERCE NIL 'STRING), there would be two posssible  return values: "" or "NIL". The choice would be arbitrary and would  have to be specified by the documentation. No matter which was chosen,  it would probably turn out to be a problem for some applications at  some times.  Another example is (COERCE (CHAR-CODE #\A) 'STRING). This might  return the same as (FORMAT NIL "~D" (CHAR-CODE #\A)) -- "65" in  most ASCII-based implementations -- or it might return "A". Again,  the choice would be arbitrary.  There is clear desire on the part of the user community to lift some of  the existing restrictions on arguments to COERCE, but because of legitimate  concerns about ambiguities, the Common Lisp designers have thus far  refused to do so.  Unfortunately, the failure of COERCE to handle these cases means it is  very difficult to learn to use COERCE. And the fact that COERCE is not  easily learned contributes to difficulty in learning Common Lisp because  instead of a single coercion operator with general purpose semantics, a  number of very special purpose coercion operators must be learned instead.  Some middle ground needs to be found, which neither compromises the  clear semantics and portable nature of COERCE nor complicates COERCE  in a way that makes it unlearnable.  Also, some people have expressed a desire for COERCE to be more   `symmetric.' Usually they seem to mean that they want it to be the case  that if (COERCE x y) works, then (COERCE (COERCE x y) (TYPE-OF x))   should also work. Although this is not an essential desire, it would  certainly be nice to achieve.Proposal:  Add an extra optional argument to COERCE which specifies the type  from which the coercion is to be done. The new syntax would be:   COERCE object to &optional (from (TYPE-OF object))  Constrain that the FROM argument must be such that (TYPEP OBJECT FROM)  is true.  Define new types as follows:	CHAR-CODE					[Type]	The subrange of the integers which are valid character codes.	This type could be defined by:	  (DEFTYPE CHAR-CODE () `(INTEGER 0 (,CHAR-CODE-LIMIT)))	CHAR-INT					[Type]	The subrange of the integers which are valid char ints.	This would probably want to be defined in an 	implementation-dependent way since there is no	CHAR-INT-LIMIT, but a crude approximation might be:	  (DEFTYPE CHAR-CODE ()	    `(INTEGER 0 ,(CODE-CHAR (- CHAR-CODE-LIMIT 1)				    (- CHAR-BITS-LIMIT 1)				    (- CHAR-FONT-LIMIT 1))))	ACCESSIBLE-SYMBOL				[Type]	The set of symbols accessible the current package.	This type could be defined by:		  (DEFUN SYSTEM::ACCESSIBLE-SYMBOL-P (X)	    (AND (SYMBOLP X)	         (MULTIPLE-VALUE-BIND (SYMBOL FOUND)		     (FIND-SYMBOL (SYMBOL-NAME X) *PACKAGE*)		   (AND FOUND (EQ SYMBOL X)))))	  (DEFTYPE ACCESSIBLE-SYMBOL () 	    `(SATISFIES SYSTEM::ACCESSIBLE-SYMBOL-P))	INTEGER-STRING					[Type]	The set of strings which can be successfully parsed by	PARSE-NAMESTRING. This type could be defined by:	  (DEFUN SYSTEM::INTEGER-STRING-P (X)	    (AND (STRINGP X)	         (DOTIMES (I (LENGTH X) T)		   (LET ((CHAR (AREF X I)))		     (UNLESS (OR (DIGIT-CHAR-P CHAR)			         (AND (= I 0) (MEMBER CHAR '(#\+ #\-))))		       (RETURN NIL))))))	  (DEFTYPE INTEGER-STRING () `(SATISFIES SYSTEM::INTEGER-STRING-P))	INTEGRAL-FLOAT					[Type]	The set of floats which have no fraction. Put another way, the set of	floats X for which there is some integer Y such that (= X Y).	This could be defined by:	  (DEFUN SYSTEM::INTEGRAL-FLOAT-P (X)	    (AND (TYPEP X 'FLOAT)		 (OR (ZEROP X)	             (MULTIPLE-VALUE-BIND (QUOTIENT REMAINDER)		         (TRUNCATE X)		       (DECLARE (IGNORE QUOTIENT))		       (ZEROP REMAINDER)))))	 (DEFTYPE INTEGRAL-FLOAT-P () `(SATISFIES SYSTEM::INTEGRAL-FLOAT-P))  Extend COERCE to handle at least the following cases:   1. CHARACTER <-> STRING      a. (COERCE x 'STRING 'CHARACTER) == (STRING x)      b. (COERCE x 'CHARACTER 'STRING) == (CHARACTER x)   2. CHAR-CODE <-> CHARACTER      a. (COERCE x 'CHARACTER 'CHAR-CODE) == (CODE-CHAR x)      b. (COERCE x 'CHAR-CODE 'CHARACTER) == (CHAR-CODE x)   3. CHAR-INT <-> CHARACTER      a. (COERCE x 'CHARACTER 'CHAR-INT) == (INT-CHAR x)      b. (COERCE x 'CHAR-INT 'CHARACTER) == (CHAR-INT x)   4. STRING <-> SYMBOL      a. (COERCE x 'SYMBOL 'STRING) == (MAKE-SYMBOL x)      b. (COERCE x 'STRING 'SYMBOL) == (SYMBOL-NAME x)   5. STRING <-> ACCESSIBLE-SYMBOL      a. (COERCE x 'ACCESSIBLE-SYMBOL 'STRING) == (INTERN x)      b. (COERCE x 'STRING 'ACCESSIBLE-SYMBOL) == (SYMBOL-NAME x)   6. INTEGER <-> INTEGER-STRING      a. (COERCE x 'INTEGER-STRING 'INTEGER)	 == (WRITE-TO-STRING X :BASE 10 :RADIX NIL)      b. (COERCE x 'INTEGER 'INTEGER-STRING)	 == (PARSE-INTEGER x)   7. CHAR-CODE <-> STRING      a. (COERCE x 'STRING 'CHAR-CODE) ==	 == (COERCE (COERCE x 'CHARACTER 'CHAR-CODE) 'STRING 'CHARACTER)	 == (STRING (CODE-CHAR x))      b. (COERCE x 'CHAR-CODE 'STRING)	 == (COERCE (COERCE x 'CHARACTER 'STRING) 'CHAR-CODE 'CHARACTER)	 == (CHAR-CODE (CHARACTER x))   8. CHAR-INT <-> STRING      a. (COERCE x 'STRING 'CHAR-INT) ==	 == (COERCE (COERCE x 'CHARACTER 'CHAR-INT) 'STRING 'CHARACTER)	 == (STRING (INT-CHAR x))      b. (COERCE x 'CHAR-INT 'STRING)	 == (COERCE (COERCE x 'CHARACTER 'STRING) 'CHAR-INT 'CHARACTER)	 == (CHAR-INT (CHARACTER x))   9. CHAR-CODE <-> SYMBOL      a. (COERCE x 'SYMBOL 'CHAR-CODE)	 == (COERCE (COERCE x 'STRING 'CHAR-CODE) 'SYMBOL 'STRING)	 == (MAKE-SYMBOL (STRING (CODE-CHAR x)))      b. (COERCE x 'CHAR-CODE 'SYMBOL)	 == (COERCE (COERCE x 'STRING 'SYMBOL) 'CHAR-CODE 'STRING)	 == (CHAR-CODE (CHARACTER (SYMBOL-NAME x)))  10. CHAR-INT <-> SYMBOL      a. (COERCE x 'SYMBOL 'CHAR-INT)	 == (COERCE (COERCE x 'STRING 'CHAR-INT) 'SYMBOL 'STRING)	 == (MAKE-SYMBOL (STRING (INT-CHAR x)))      b. (COERCE x 'CHAR-INT 'SYMBOL)	 == (COERCE (COERCE x 'STRING 'SYMBOL) 'CHAR-INT 'STRING)	 == (CHAR-INT (CHARACTER (SYMBOL-NAME x)))  11. CHAR-CODE <-> ACCESSIBLE-SYMBOL      a. (COERCE x 'ACCESSIBLE-SYMBOL 'CHAR-CODE)	 == (COERCE (COERCE x 'STRING 'CHAR-CODE) 'ACCESSIBLE-SYMBOL 'STRING)	 == (INTERN (STRING (CODE-CHAR x)))      b. (COERCE x 'CHAR-CODE 'ACCESSIBLE-SYMBOL)	 == (COERCE (COERCE x 'STRING 'ACCESSIBLE-SYMBOL) 'CHAR-CODE 'STRING)	 == (CHAR-CODE (CHARACTER (SYMBOL-NAME x)))  12. CHAR-INT <-> ACCESSIBLE-SYMBOL      a. (COERCE x 'ACCESSIBLE-SYMBOL 'CHAR-INT)	 == (COERCE (COERCE x 'STRING 'CHAR-INT) 'ACCESSIBLE-SYMBOL 'STRING)	 == (INTERN (STRING (INT-CHAR x)))      b. (COERCE x 'CHAR-INT 'ACCESSIBLE-SYMBOL)	 == (COERCE (COERCE x 'STRING 'ACCESSIBLE-SYMBOL) 'CHAR-INT 'STRING)	 == (CHAR-INT (CHARACTER (SYMBOL-NAME x)))  13. PATHNAME <-> STRING      a. (COERCE x 'STRING 'PATHNAME)	 == (NAMESTRING x)      b. (COERCE x 'PATHNAME 'STRING)	 == (PARSE-NAMESTRING x)  14. INTEGRAL-FLOAT <-> INTEGER      a. (COERCE x 'INTEGER 'INTEGRAL-FLOAT)	 == (TRUNCATE x)      b. (COERCE x 'INTEGRAL-FLOAT 'INTEGER)	 == (FLOAT x)  Note that restrictions on the X argument to COERCE are as they would  be for the corresponding function. For example, in 1b only strings of  length 1 can be converted by CHARACTER.  Observe that in some cases, such as (COERCE NIL 'STRING) where the first  argument has a type which is a subtype of more than one of the above  cases, the result may not be what the user expects. To get a safe result  from COERCE, use of the third argument is strongly recommended.  (COERCE NIL 'STRING 'SYMBOL) and (COERCE NIL 'STRING 'LIST) are not  subject to the confusion that (COERCE NIL 'STRING) is.Rationale:  These proposed extensions make COERCE able to deal with a much larger  space of type coercions without the problems of ambiguity raised in  the Problem Description.  The proposed extensions are, for the most part, fairly symmetric.  Nearly every coercion that COERCE could do could be undone in a   fairly straightforward and reasonably reliable way.  Compatibility with the old style of coerce is handled by making the  third argument optional.  This proposal is upward compatible with the existing semantics of COERCE.  (The previous version of this proposal, by M. Ida, proposed incompatible  changes.)Current Practice:  Probably no one implements the proposed behavior at this time.Cost to Implementors:  The more optimization a compiler does (or might do) of COERCE, the more  work might be necessary. In general, however, the changes would probably  not involve a major amount of work.Cost to Users:  This*start*02555 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 12:40:20 PSTReceived: from FRED.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 22 Nov 88  12:37:27 PSTReceived: from FRED.SLISP.CS.CMU.EDU by FRED.SLISP.CS.CMU.EDU; 22 Nov 88 14:13:50 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: COERCE-INCOMPLETE (Version 2) In-reply-to: Your message of Mon, 21 Nov 88 18:02:00 -0500.             <881121180215.8.KMP@BOBOLINK.SCRC.Symbolics.COM> Date: Tue, 22 Nov 88 14:12:55 ESTFrom: Rob.MacLachlan@WB1.CS.CMU.EDUI am bothered by the addition of various bizarre types to the type systemjust so that coerce can do its thing.  Are these "real" types?  If so, whatdo they mean in a declaration?  If not "real", then why do we call them types?ACCESSIBLE-SYMBOL seems especially twisted.  The use of the "currentpackage" is the most problematical.  What is the "current package" for adeclaration?Especially in a language with dynamic typing, the boundary between "type"and "value" tends to blur, but I think that this proposal uses the CommonLisp type system in a way that isn't very type-like.  I am very suspiciousof any type that must be defined using SATISFIES.I also wonder about INTEGRAL-FLOAT.  To say that a float has "no fraction"is meaningless, or at least confusing.  I think that you really mean thatthe remainder is 0.0 when you truncate it, but it is unclear how you aregoing to tell this other than by doing the truncation.  If you do thetruncation, you have the result anyway, so why call COERCE?I think that in general, it is treacherous to support symmetric coercionfor any pair of types where the coercion in either direction is informationlosing.  This also applies to all the symbol coercions.The dependence on TYPE-OF is also bothersome.  Any clarafication of TYPE-OFisn't really a clarification of TYPE-OF, it is a clarification of the legalrun-time type systems in a Common Lisp implementation.  I consider thefunction performed by TYPE-OF to be very troublesome from a language designperspective, and I would rather people didn't depend on it.Also, there is an error in the approximate definition for CHAR-INT.  Itshould be something like:	  (DEFTYPE CHAR-INT ()	    `(INTEGER 0		      ,(CHAR-INT			(CODE-CHAR (- CHAR-CODE-LIMIT 1)				   (- CHAR-BITS-LIMIT 1)				   (- CHAR-FONT-LIMIT 1)))))  Rob*start*11758 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 NOV 88 15:04:20 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Nov 88  15:02:05 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496145; Mon 21-Nov-88 18:02:01 ESTDate: Mon, 21 Nov 88 18:02 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881121180215.8.KMP@BOBOLINK.SCRC.Symbolics.COM>Issue:		 COERCE-INCOMPLETEReference:	 COERCE (p50)Category:	 ADDITIONEdit history:	 Version 1 of COERCE-INCOMPLETE, 26-Feb-88 by M. Ida		 Version 1 of COERCE-FROM-TYPE,  20-Jun-88 by Pitman		 Version 2 of COERCE-INCOMPLETE, 21-Nov-88 by PitmanRequired-Issues: TYPE-OF-UNDERCONSTRAINEDProblem Description:  COERCE is difficult to extend because ambiguities arise about the  source type of the coercion.  For example, if the symbol STRING were permitted as a second argument  to coerce, as in (COERCE NIL 'STRING), there would be two posssible  return values: "" or "NIL". The choice would be arbitrary and would  have to be specified by the documentation. No matter which was chosen,  it would probably turn out to be a problem for some applications at  some times.  Another example is (COERCE (CHAR-CODE #\A) 'STRING). This might  return the same as (FORMAT NIL "~D" (CHAR-CODE #\A)) -- "65" in  most ASCII-based implementations -- or it might return "A". Again,  the choice would be arbitrary.  There is clear desire on the part of the user community to lift some of  the existing restrictions on arguments to COERCE, but because of legitimate  concerns about ambiguities, the Common Lisp designers have thus far  refused to do so.  Unfortunately, the failure of COERCE to handle these cases means it is  very difficult to learn to use COERCE. And the fact that COERCE is not  easily learned contributes to difficulty in learning Common Lisp because  instead of a single coercion operator with general purpose semantics, a  number of very special purpose coercion operators must be learned instead.  Some middle ground needs to be found, which neither compromises the  clear semantics and portable nature of COERCE nor complicates COERCE  in a way that makes it unlearnable.  Also, some people have expressed a desire for COERCE to be more   `symmetric.' Usually they seem to mean that they want it to be the case  that if (COERCE x y) works, then (COERCE (COERCE x y) (TYPE-OF x))   should also work. Although this is not an essential desire, it would  certainly be nice to achieve.Proposal:  Add an extra optional argument to COERCE which specifies the type  from which the coercion is to be done. The new syntax would be:   COERCE object to &optional (from (TYPE-OF object))  Constrain that the FROM argument must be such that (TYPEP OBJECT FROM)  is true.  Define new types as follows:	CHAR-CODE					[Type]	The subrange of the integers which are valid character codes.	This type could be defined by:	  (DEFTYPE CHAR-CODE () `(INTEGER 0 (,CHAR-CODE-LIMIT)))	CHAR-INT					[Type]	The subrange of the integers which are valid char ints.	This would probably want to be defined in an 	implementation-dependent way since there is no	CHAR-INT-LIMIT, but a crude approximation might be:	  (DEFTYPE CHAR-CODE ()	    `(INTEGER 0 ,(CODE-CHAR (- CHAR-CODE-LIMIT 1)				    (- CHAR-BITS-LIMIT 1)				    (- CHAR-FONT-LIMIT 1))))	ACCESSIBLE-SYMBOL				[Type]	The set of symbols accessible the current package.	This type could be defined by:		  (DEFUN SYSTEM::ACCESSIBLE-SYMBOL-P (X)	    (AND (SYMBOLP X)	         (MULTIPLE-VALUE-BIND (SYMBOL FOUND)		     (FIND-SYMBOL (SYMBOL-NAME X) *PACKAGE*)		   (AND FOUND (EQ SYMBOL X)))))	  (DEFTYPE ACCESSIBLE-SYMBOL () 	    `(SATISFIES SYSTEM::ACCESSIBLE-SYMBOL-P))	INTEGER-STRING					[Type]	The set of strings which can be successfully parsed by	PARSE-NAMESTRING. This type could be defined by:	  (DEFUN SYSTEM::INTEGER-STRING-P (X)	    (AND (STRINGP X)	         (DOTIMES (I (LENGTH X) T)		   (LET ((CHAR (AREF X I)))		     (UNLESS (OR (DIGIT-CHAR-P CHAR)			         (AND (= I 0) (MEMBER CHAR '(#\+ #\-))))		       (RETURN NIL))))))	  (DEFTYPE INTEGER-STRING () `(SATISFIES SYSTEM::INTEGER-STRING-P))	INTEGRAL-FLOAT					[Type]	The set of floats which have no fraction. Put another way, the set of	floats X for which there is some integer Y such that (= X Y).	This could be defined by:	  (DEFUN SYSTEM::INTEGRAL-FLOAT-P (X)	    (AND (TYPEP X 'FLOAT)		 (OR (ZEROP X)	             (MULTIPLE-VALUE-BIND (QUOTIENT REMAINDER)		         (TRUNCATE X)		       (DECLARE (IGNORE QUOTIENT))		       (ZEROP REMAINDER)))))	 (DEFTYPE INTEGRAL-FLOAT-P () `(SATISFIES SYSTEM::INTEGRAL-FLOAT-P))  Extend COERCE to handle at least the following cases:   1. CHARACTER <-> STRING      a. (COERCE x 'STRING 'CHARACTER) == (STRING x)      b. (COERCE x 'CHARACTER 'STRING) == (CHARACTER x)   2. CHAR-CODE <-> CHARACTER      a. (COERCE x 'CHARACTER 'CHAR-CODE) == (CODE-CHAR x)      b. (COERCE x 'CHAR-CODE 'CHARACTER) == (CHAR-CODE x)   3. CHAR-INT <-> CHARACTER      a. (COERCE x 'CHARACTER 'CHAR-INT) == (INT-CHAR x)      b. (COERCE x 'CHAR-INT 'CHARACTER) == (CHAR-INT x)   4. STRING <-> SYMBOL      a. (COERCE x 'SYMBOL 'STRING) == (MAKE-SYMBOL x)      b. (COERCE x 'STRING 'SYMBOL) == (SYMBOL-NAME x)   5. STRING <-> ACCESSIBLE-SYMBOL      a. (COERCE x 'ACCESSIBLE-SYMBOL 'STRING) == (INTERN x)      b. (COERCE x 'STRING 'ACCESSIBLE-SYMBOL) == (SYMBOL-NAME x)   6. INTEGER <-> INTEGER-STRING      a. (COERCE x 'INTEGER-STRING 'INTEGER)	 == (WRITE-TO-STRING X :BASE 10 :RADIX NIL)      b. (COERCE x 'INTEGER 'INTEGER-STRING)	 == (PARSE-INTEGER x)   7. CHAR-CODE <-> STRING      a. (COERCE x 'STRING 'CHAR-CODE) ==	 == (COERCE (COERCE x 'CHARACTER 'CHAR-CODE) 'STRING 'CHARACTER)	 == (STRING (CODE-CHAR x))      b. (COERCE x 'CHAR-CODE 'STRING)	 == (COERCE (COERCE x 'CHARACTER 'STRING) 'CHAR-CODE 'CHARACTER)	 == (CHAR-CODE (CHARACTER x))   8. CHAR-INT <-> STRING      a. (COERCE x 'STRING 'CHAR-INT) ==	 == (COERCE (COERCE x 'CHARACTER 'CHAR-INT) 'STRING 'CHARACTER)	 == (STRING (INT-CHAR x))      b. (COERCE x 'CHAR-INT 'STRING)	 == (COERCE (COERCE x 'CHARACTER 'STRING) 'CHAR-INT 'CHARACTER)	 == (CHAR-INT (CHARACTER x))   9. CHAR-CODE <-> SYMBOL      a. (COERCE x 'SYMBOL 'CHAR-CODE)	 == (COERCE (COERCE x 'STRING 'CHAR-CODE) 'SYMBOL 'STRING)	 == (MAKE-SYMBOL (STRING (CODE-CHAR x)))      b. (COERCE x 'CHAR-CODE 'SYMBOL)	 == (COERCE (COERCE x 'STRING 'SYMBOL) 'CHAR-CODE 'STRING)	 == (CHAR-CODE (CHARACTER (SYMBOL-NAME x)))  10. CHAR-INT <-> SYMBOL      a. (COERCE x 'SYMBOL 'CHAR-INT)	 == (COERCE (COERCE x 'STRING 'CHAR-INT) 'SYMBOL 'STRING)	 == (MAKE-SYMBOL (STRING (INT-CHAR x)))      b. (COERCE x 'CHAR-INT 'SYMBOL)	 == (COERCE (COERCE x 'STRING 'SYMBOL) 'CHAR-INT 'STRING)	 == (CHAR-INT (CHARACTER (SYMBOL-NAME x)))  11. CHAR-CODE <-> ACCESSIBLE-SYMBOL      a. (COERCE x 'ACCESSIBLE-SYMBOL 'CHAR-CODE)	 == (COERCE (COERCE x 'STRING 'CHAR-CODE) 'ACCESSIBLE-SYMBOL 'STRING)	 == (INTERN (STRING (CODE-CHAR x)))      b. (COERCE x 'CHAR-CODE 'ACCESSIBLE-SYMBOL)	 == (COERCE (COERCE x 'STRING 'ACCESSIBLE-SYMBOL) 'CHAR-CODE 'STRING)	 == (CHAR-CODE (CHARACTER (SYMBOL-NAME x)))  12. CHAR-INT <-> ACCESSIBLE-SYMBOL      a. (COERCE x 'ACCESSIBLE-SYMBOL 'CHAR-INT)	 == (COERCE (COERCE x 'STRING 'CHAR-INT) 'ACCESSIBLE-SYMBOL 'STRING)	 == (INTERN (STRING (INT-CHAR x)))      b. (COERCE x 'CHAR-INT 'ACCESSIBLE-SYMBOL)	 == (COERCE (COERCE x 'STRING 'ACCESSIBLE-SYMBOL) 'CHAR-INT 'STRING)	 == (CHAR-INT (CHARACTER (SYMBOL-NAME x)))  13. PATHNAME <-> STRING      a. (COERCE x 'STRING 'PATHNAME)	 == (NAMESTRING x)      b. (COERCE x 'PATHNAME 'STRING)	 == (PARSE-NAMESTRING x)  14. INTEGRAL-FLOAT <-> INTEGER      a. (COERCE x 'INTEGER 'INTEGRAL-FLOAT)	 == (TRUNCATE x)      b. (COERCE x 'INTEGRAL-FLOAT 'INTEGER)	 == (FLOAT x)  Note that restrictions on the X argument to COERCE are as they would  be for the corresponding function. For example, in 1b only strings of  length 1 can be converted by CHARACTER.  Observe that in some cases, such as (COERCE NIL 'STRING) where the first  argument has a type which is a subtype of more than one of the above  cases, the result may not be what the user expects. To get a safe result  from COERCE, use of the third argument is strongly recommended.  (COERCE NIL 'STRING 'SYMBOL) and (COERCE NIL 'STRING 'LIST) are not  subject to the confusion that (COERCE NIL 'STRING) is.Rationale:  These proposed extensions make COERCE able to deal with a much larger  space of type coercions without the problems of ambiguity raised in  the Problem Description.  The proposed extensions are, for the most part, fairly symmetric.  Nearly every coercion that COERCE could do could be undone in a   fairly straightforward and reasonably reliable way.  Compatibility with the old style of coerce is handled by making the  third argument optional.  This proposal is upward compatible with the existing semantics of COERCE.  (The previous version of this proposal, by M. Ida, proposed incompatible  changes.)Current Practice:  Probably no one implements the proposed behavior at this time.Cost to Implementors:  The more optimization a compiler does (or might do) of COERCE, the more  work might be necessary. In general, however, the changes would probably  not involve a major amount of work.Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  Various proposals to extend COERCE would probably not pass because  not everyone can agree on how to view the type of the first argument.Benefits:  Currently, whenver documentation refers to something being `coerced'  from one type or another, it might mean that COERCE is called, or it  might mean that some more specialized operator is called. This proposal  brings us much closer to having the meaning of "is coerced to" be  "the COERCE function is called", which would make things easier on  the consumers of that documentation.Aesthetics:  This proposal regularizes the semantics of COERCE by making it more  predictable and more   Pitman thinks this proposal would greatly improve the aesthetics of  COERCE. Does anyone want to present  Discussion:  For purposes of getting this proposal through in parallel, we have not  any assumptions about the impending character proposal. Nothing proposed  in this document is inherently in conflict with any potential output of  the Characters Committee. The fact that characters may have multiple  representations as integers is an important way to highlight the value of  this proposal, which is why character issues are included.  Needless to say, the proposal TYPE-OF-UNDERCONSTRAINED will need to be  dealt with. If a CL implementation is permitted to always return T for   (TYPE-OF anything), then the defaulting of the third argument in this  proposal is not going to work so well. That's why that issue is listed  as a `required issue' in the heading above.  Pitman supports this proposal.  Although this proposal is not the same in detail as M. Ida's original  proposal, it does address the same issues.  Pitman is hopeful that the  alternative solutions proposed here would still be satisfactory to the  Japanese community, and looks forward to feedback from that community  about this issue.*start*02570 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 16:50:16 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  16:49:08 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 16:47:33 PSTDate: 9 Dec 88 16:47 PSTFrom: masinter.paSubject: Re: Issue: COERCE-INCOMPLETE (Version 2)to: cl-cleanup@sail.stanford.eduMessage-ID: <881209-164733-1437@Xerox>This issue is Not Ready for mailing. We need to pick a set of possibilitiesif we can't agree. Perhaps we can have this ready for discussion nextmonth.I see we have some choices:a) remove COERCEb) leave COERCE alonec) extend COERCE slightlyd) extend COERCE a lotI think (b) or (c) are the best. I'll try to say why:We've observed that it is sometimes difficult to tell when you should useCOERCE -- that there are some conversions that COERCE does not do that someusers might "expect" it to do.However, COERCE does have the nice property that you can tell what it isdoing. That is, programs that use COERCE, whether (COERCE x 'STRING) or(COERCE x 'FLOAT), it is easy to see that the results of these will be astring or float repsectively, that if the input is of the desired type itwill be left alone, and otherwise it will be converted. So I think thatCommon Lisp with COERCE is a better language than Common Lisp without it.Certainly it is possible to write programs without COERCE, but they won'tbe as easy to read.COERCE embodies two operations: a type check plus a conversion if the typecheck is not satisfied. I think (COERCE x y) is valid for all typespecifiers y, even those which have no conversions, and that (COERCE x 'y)in those cases is a form of (TYPE-CHECK x y).I think that many of the extensions proposed in Version 2 are far-fetched.The more we burden COERCE with multiple kinds of arguments the worse wemake it.One of the problems with COERCE is that the second argument is treated bothas a type specifier and also an indicator for the type of conversionwanted. I might think that(coerce nil 'string) might well return a different value than(coerce nil '(vector character)).The major problems come where (coerce x 'type) operates differently thanthe 'natural' coerce function for type, viz: string, character, pathname,float.So why don't we just define:(coerce x 'string) == (string x)(coerce x 'character) == (character x)(coerce x 'pathname) = (pathname x)(coerce x 'float) = (float x),*start*00877 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 17:12:49 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 9 Dec 88  17:12:12 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU;  9 Dec 88 20:10:41 ESTTo: masinter.pacc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: COERCE-INCOMPLETE (Version 2) In-reply-to: Your message of 09 Dec 88 16:47:00 -0800.             <881209-164733-1437@Xerox> Date: Fri, 09 Dec 88 20:10:29 ESTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUI agree with Larry on this one.  We should leave COERCE alone or extend itto cover any situations that are demonstrably confusing to users.  I don'tthink it is a good idea to try to extend it to cover all possible cases.-- Scott*start*01271 00024 US Return-Path: <@multimax.encore.com:pierson@mist.encore.com>Received: from multimax.encore.com ([192.5.63.14]) by Xerox.COM ; 12 DEC 88 09:29:14 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA00376; Mon, 12 Dec 88 12:28:20 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA10721; Mon, 12 Dec 88 11:08:16 ESTMessage-Id: <8812121608.AA10721@mist.>To: masinter.paCc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: COERCE-INCOMPLETE (Version 2) In-Reply-To: Your message of 09 Dec 88 16:47:00 -0800.             <881209-164733-1437@Xerox> Date: Mon, 12 Dec 88 11:08:13 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    I see we have some choices:        a) remove COERCE    b) leave COERCE alone    c) extend COERCE slightly    d) extend COERCE a lot        I think (b) or (c) are the best. I'll try to say why:        ...    So why don't we just define:    (coerce x 'string) == (string x)    (coerce x 'character) == (character x)    (coerce x 'pathname) = (pathname x)    (coerce x 'float) = (float x),    I agree.In addition I think that COERCE is a dandy candidate for a genericfunction, but it's my understanding that nominations for that statushaven't been opened yet.*start*01386 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 09:31:54 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 12 Dec 88  09:29:26 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA00376; Mon, 12 Dec 88 12:28:20 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA10721; Mon, 12 Dec 88 11:08:16 ESTMessage-Id: <8812121608.AA10721@mist.>To: masinter.paCc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: COERCE-INCOMPLETE (Version 2) In-Reply-To: Your message of 09 Dec 88 16:47:00 -0800.             <881209-164733-1437@Xerox> Date: Mon, 12 Dec 88 11:08:13 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    I see we have some choices:        a) remove COERCE    b) leave COERCE alone    c) extend COERCE slightly    d) extend COERCE a lot        I think (b) or (c) are the best. I'll try to say why:        ...    So why don't we just define:    (coerce x 'string) == (string x)    (coerce x 'character) == (character x)    (coerce x 'pathname) = (pathname x)    (coerce x 'float) = (float x),    I agree.In addition I think that COERCE is a dandy candidate for a genericfunction, but it's my understanding that nominations for that statushaven't been opened yet.*start*01442 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 24 JUN 88 15:44:30 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 424437; Fri 24-Jun-88 18:44:06 EDTDate: Fri, 24 Jun 88 18:43 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: which functions should be generic?To: Masinter.pacc: common-lisp-object-system@sail.stanford.eduIn-Reply-To: <880624-122008-5902@Xerox>Message-ID: <19880624224355.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 24 Jun 88 12:19 PDT    From: Masinter.pa@Xerox.COM    Mr. Ida asks (relative to COERCE-INCOMPLETE):    "Will Coerce function be a (standard) generic function ?"It's difficult to implement COERCE's dispatch in terms of genericfunction dispatch since equivalence of type specifiers is not donein an object-oriented way.  There is no way to write a method thatis applicable both for (coerce '(#\a) 'string) and for(coerce '(#\a) '(vector string-char)), even though both of thoseforms mean the same thing.    I'd like to generalize this: Now that CLOS is part of the standard, which    functions in CL should be generic?I think this is the wrong mailing list to discuss changes that X3J13, oranyone else, might want to make to the language in order to take advantageof CLOS.*start*02785 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU by Xerox.COM ; 24 JUN 88 16:49:53 PDTReceived: from Score.Stanford.EDU by SAIL.Stanford.EDU with TCP; 24 Jun 88  16:48:51 PDTReceived: from hplabs.HP.COM by SCORE.STANFORD.EDU with TCP; Fri 24 Jun 88 16:50:28-PDTReceived: from hplms2.HP.COM (hplms2) by hplabs.HP.COM with SMTP ; Fri, 24 Jun 88 15:39:09 PSTReceived: from hplwhh.HPL.HP.COM (hplwhh.hpl.hp.com) by hplms2.HP.COM; Fri, 24 Jun 88 16:38:46 pdtReceived: from hplwhh by hplwhh.HPL.HP.COM; Fri, 24 Jun 88 16:37:05 pdtTo: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: common-lisp-object-system@sail.stanford.eduSubject: Re: which functions should be generic? X-Mailer: mh6.5In-Reply-To: Your message of Fri, 24 Jun 88 18:43:00 -0400.             <19880624224355.3.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Fri, 24 Jun 88 16:37:03 PDTMessage-Id: <6353.583198623@hplwhh>From: Warren Harris <harris%hplwhh@hplabs.HP.COM>> It's difficult to implement COERCE's dispatch in terms of generic> function dispatch since equivalence of type specifiers is not done> in an object-oriented way. This could be handled in the same way as the PRINT-OBJECT generic function.Implementations are required to call it from within their print system.One could supply a COERCE-OBJECT generic function which the COERCE functionwould ultimately call if the coercion argument named a class.  I realize that one could probably find a large number of candidates in CLtLto be made generic.  Ideally EQUAL should be generic too.  It alreadydepends on the type of objects you give it, looking inside of vectors, etc.Why not allow it to look inside of objects in an object dependent way?At some point the argument boils down to an efficiency consideration.  Idon't think anyone would be happy if EQ was required to be generic.  Thereshould be a strong rational for which functions are to be made generic andwhich are not.  (For example:  how should the average user know when to useELT instead of SVREF?)  Perhaps a generic layer of CL is in order.  CLalready kind of does this with its sequence operations.  I can think of threegeneric protocols off hand:	- sequences which access subcomponents by position	- objects and structures which access subcomponents by name	- math functions which operate on generic "numbers"It would be nice if CL had facilities for formally specifying the protocolsfor abstract classes like NUMBER, SEQUENCE, or OBJECT (i.e. first classprotocol objects, or an abstract-class metaclass), and allow individualclasses to implement a protocol.  This way the user can write code thatmeets a protocol without regard to the specifics of its implementation.*start*03177 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU by Xerox.COM ; 25 JUN 88 12:04:50 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 25 Jun 88  12:04:03 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 424648; Sat 25-Jun-88 15:01:44 EDTDate: Sat, 25 Jun 88 15:01 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: which functions should be generic? To: Warren Harris <harris%hplwhh@hplabs.HP.COM>cc: common-lisp-object-system@SAIL.STANFORD.EDUIn-Reply-To: <6353.583198623@hplwhh>Message-ID: <19880625190143.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 24 Jun 88 16:37:03 PDT    From: Warren Harris <harris%hplwhh@hplabs.HP.COM>    > It's difficult to implement COERCE's dispatch in terms of generic    > function dispatch since equivalence of type specifiers is not done    > in an object-oriented way.     This could be handled in the same way as the PRINT-OBJECT generic function.    Implementations are required to call it from within their print system.    One could supply a COERCE-OBJECT generic function which the COERCE function    would ultimately call if the coercion argument named a class.  But it's meaningful for COERCE's second argument to be a type specifier thatdoes not name a class.  CLtL gives as an example (vector (complex short-float)).It would be inconsistent to do some coercions with classes and others throughsome other mechanism.  I don't think your idea will work without a largerrecasting of Common Lisp in object-oriented terms.  While that's an interestingproject for investigation, I suspect it would quickly go way beyond theproper charter of a standardization effort.    It would be nice if CL had facilities for formally specifying the protocols    for abstract classes like NUMBER, SEQUENCE, or OBJECT (i.e. first class    protocol objects, or an abstract-class metaclass), and allow individual    classes to implement a protocol.  This way the user can write code that    meets a protocol without regard to the specifics of its implementation.While I strongly agree with this, and have thought so for several years, againI feel this is beyond the proper charter of a standardization effort.  Theredoes not appear to be any current practice at all, let alone a concensus fromwhich to build a standard.Some of the directions in which I feel Lisp ought to evolve in the 1990sinclude enormously better tools for modularity and program packaging,like what such languages as Ada have but better conceived and (as alwaysin Lisp) more flexible (the "locales" found in some dialects in Schememight be a good place to start); formal notions of protocols andmachine-understandable interface specifications; complete integration ofdatabase concepts into the language; and development tools that"understand" both Lisp programming concepts and the dynamics of largedevelopment teams.  None of this is X3J13's business, which is tostabilize the Lisp of the 1980s so people can use it.*start*01442 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 24 JUN 88 15:44:30 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 424437; Fri 24-Jun-88 18:44:06 EDTDate: Fri, 24 Jun 88 18:43 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: which functions should be generic?To: Masinter.pacc: common-lisp-object-system@sail.stanford.eduIn-Reply-To: <880624-122008-5902@Xerox>Message-ID: <19880624224355.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 24 Jun 88 12:19 PDT    From: Masinter.pa@Xerox.COM    Mr. Ida asks (relative to COERCE-INCOMPLETE):    "Will Coerce function be a (standard) generic function ?"It's difficult to implement COERCE's dispatch in terms of genericfunction dispatch since equivalence of type specifiers is not donein an object-oriented way.  There is no way to write a method thatis applicable both for (coerce '(#\a) 'string) and for(coerce '(#\a) '(vector string-char)), even though both of thoseforms mean the same thing.    I'd like to generalize this: Now that CLOS is part of the standard, which    functions in CL should be generic?I think this is the wrong mailing list to discuss changes that X3J13, oranyone else, might want to make to the language in order to take advantageof CLOS.*start*00977 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 14 DEC 88 00:18:53 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA07199g; Wed, 14 Dec 88 00:16:48 PSTReceived: by bhopal id AA12063g; Wed, 14 Dec 88 00:18:48 PSTDate: Wed, 14 Dec 88 00:18:48 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812140818.AA12063@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 9 Dec 88 16:47 PST <881209-164733-1437@Xerox>Subject: Issue: COERCE-INCOMPLETE (Version 2)Wasn't there some hairy issue with ...-FUNCTION-... in it's name thatwe discussed verbally at the June meeting?  and didn't we take a votethere to ammend that issue by saying that     (COERCE '(LAMBDA ...) 'FUNCTION)would be the way to go from list structure to a "real" function?That didn't seem to be in your list of obvious candidates for COERCEextension.-- JonL --*start*02910 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 DEC 88 15:26:02 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 30 Dec 88  15:25:51 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513694; Fri 30-Dec-88 18:24:45 ESTDate: Fri, 30 Dec 88 18:24 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: COERCE-INCOMPLETE (Version 2)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881209-164733-1437@Xerox>Message-ID: <19881230232406.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 9 Dec 88 16:47 PST    From: masinter.pa@Xerox.COM    So why don't we just define:    (coerce x 'string) == (string x)This is the whole problem.  Leaving aside the cases that arecurrently required to signal an error, (string nil) => "nil"and (coerce nil 'string) => "" are currently required by CLtL.So one way or another this would be an incompatible change.Maybe it would be worth the incompatible change for theincreased consistency, who knows?  I don't like incompatiblechanges.    (coerce x 'character) == (character x)Already true by definition (CLtL p.241).    (coerce x 'pathname) = (pathname x)Good idea.    (coerce x 'float) = (float x),Already true; not by definition, but deducible from CLtL.Also (coerce x 'rational) = (rational x) would be a good idea,don't you think?  CLtL p.52 indicates this was left out becausethe user should have to decide explicitly whether to use rationalor rationalize.The other functions that are also names of types that can be usedas type-specifiers without arguments are:ATOM BIT BREAK -- condition system typeCOMPLEX CONS ERROR -- condition system typeFUNCTION LIST NULL VECTOR except for FUNCTION, none of these is a coercer.  Should(coerce x 'function) = (eval `(function ,x))?  Actually thatmay have already been added to the language by the function-typeproposal, I forget.    I might think that    (coerce nil 'string) might well return a different value than    (coerce nil '(vector character)).I think that would be a really bad idea!  It's hard to be sure, butI think CLtL's definition of COERCE very carefully skates aroundany problems like this.  Making (coerce x 'string) = (string x)might introduce this problem if we're not careful.I think I've just been led back to the same place I always end upwhen thinking about COERCE, even though that's not what I expectedat all when I started this message.  We should either leave COERCEessentially the way it is or get rid of it.  I appreciate Larry'sargument that it's good to have because you know a lot about whatit will do even without knowing the specific coercions for thetarget type.*start*12245 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 12 JAN 89 15:07:05 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 520564; Thu 12-Jan-89 18:06:34 ESTReturn-path: <CL-Cleanup-mailer@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 496148; 21 Nov 88 18:06:52 ESTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Nov 88  15:02:05 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496145; Mon 21-Nov-88 18:02:01 ESTDate: Mon, 21 Nov 88 18:02 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881121180215.8.KMP@BOBOLINK.SCRC.Symbolics.COM>Resent-To: Masinter.PAResent-From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Resent-Date: Thu, 12 Jan 89 18:06 ESTResent-Message-ID: <890112180622.3.KMP@BOBOLINK.SCRC.Symbolics.COM>Issue:		 COERCE-INCOMPLETEReference:	 COERCE (p50)Category:	 ADDITIONEdit history:	 Version 1 of COERCE-INCOMPLETE, 26-Feb-88 by M. Ida		 Version 1 of COERCE-FROM-TYPE,  20-Jun-88 by Pitman		 Version 2 of COERCE-INCOMPLETE, 21-Nov-88 by PitmanRequired-Issues: TYPE-OF-UNDERCONSTRAINEDProblem Description:  COERCE is difficult to extend because ambiguities arise about the  source type of the coercion.  For example, if the symbol STRING were permitted as a second argument  to coerce, as in (COERCE NIL 'STRING), there would be two posssible  return values: "" or "NIL". The choice would be arbitrary and would  have to be specified by the documentation. No matter which was chosen,  it would probably turn out to be a problem for some applications at  some times.  Another example is (COERCE (CHAR-CODE #\A) 'STRING). This might  return the same as (FORMAT NIL "~D" (CHAR-CODE #\A)) -- "65" in  most ASCII-based implementations -- or it might return "A". Again,  the choice would be arbitrary.  There is clear desire on the part of the user community to lift some of  the existing restrictions on arguments to COERCE, but because of legitimate  concerns about ambiguities, the Common Lisp designers have thus far  refused to do so.  Unfortunately, the failure of COERCE to handle these cases means it is  very difficult to learn to use COERCE. And the fact that COERCE is not  easily learned contributes to difficulty in learning Common Lisp because  instead of a single coercion operator with general purpose semantics, a  number of very special purpose coercion operators must be learned instead.  Some middle ground needs to be found, which neither compromises the  clear semantics and portable nature of COERCE nor complicates COERCE  in a way that makes it unlearnable.  Also, some people have expressed a desire for COERCE to be more   `symmetric.' Usually they seem to mean that they want it to be the case  that if (COERCE x y) works, then (COERCE (COERCE x y) (TYPE-OF x))   should also work. Although this is not an essential desire, it would  certainly be nice to achieve.Proposal:  Add an extra optional argument to COERCE which specifies the type  from which the coercion is to be done. The new syntax would be:   COERCE object to &optional (from (TYPE-OF object))  Constrain that the FROM argument must be such that (TYPEP OBJECT FROM)  is true.  Define new types as follows:	CHAR-CODE					[Type]	The subrange of the integers which are valid character codes.	This type could be defined by:	  (DEFTYPE CHAR-CODE () `(INTEGER 0 (,CHAR-CODE-LIMIT)))	CHAR-INT					[Type]	The subrange of the integers which are valid char ints.	This would probably want to be defined in an 	implementation-dependent way since there is no	CHAR-INT-LIMIT, but a crude approximation might be:	  (DEFTYPE CHAR-CODE ()	    `(INTEGER 0 ,(CODE-CHAR (- CHAR-CODE-LIMIT 1)				    (- CHAR-BITS-LIMIT 1)				    (- CHAR-FONT-LIMIT 1))))	ACCESSIBLE-SYMBOL				[Type]	The set of symbols accessible the current package.	This type could be defined by:		  (DEFUN SYSTEM::ACCESSIBLE-SYMBOL-P (X)	    (AND (SYMBOLP X)	         (MULTIPLE-VALUE-BIND (SYMBOL FOUND)		     (FIND-SYMBOL (SYMBOL-NAME X) *PACKAGE*)		   (AND FOUND (EQ SYMBOL X)))))	  (DEFTYPE ACCESSIBLE-SYMBOL () 	    `(SATISFIES SYSTEM::ACCESSIBLE-SYMBOL-P))	INTEGER-STRING					[Type]	The set of strings which can be successfully parsed by	PARSE-NAMESTRING. This type could be defined by:	  (DEFUN SYSTEM::INTEGER-STRING-P (X)	    (AND (STRINGP X)	         (DOTIMES (I (LENGTH X) T)		   (LET ((CHAR (AREF X I)))		     (UNLESS (OR (DIGIT-CHAR-P CHAR)			         (AND (= I 0) (MEMBER CHAR '(#\+ #\-))))		       (RETURN NIL))))))	  (DEFTYPE INTEGER-STRING () `(SATISFIES SYSTEM::INTEGER-STRING-P))	INTEGRAL-FLOAT					[Type]	The set of floats which have no fraction. Put another way, the set of	floats X for which there is some integer Y such that (= X Y).	This could be defined by:	  (DEFUN SYSTEM::INTEGRAL-FLOAT-P (X)	    (AND (TYPEP X 'FLOAT)		 (OR (ZEROP X)	             (MULTIPLE-VALUE-BIND (QUOTIENT REMAINDER)		         (TRUNCATE X)		       (DECLARE (IGNORE QUOTIENT))		       (ZEROP REMAINDER)))))	 (DEFTYPE INTEGRAL-FLOAT-P () `(SATISFIES SYSTEM::INTEGRAL-FLOAT-P))  Extend COERCE to handle at least the following cases:   1. CHARACTER <-> STRING      a. (COERCE x 'STRING 'CHARACTER) == (STRING x)      b. (COERCE x 'CHARACTER 'STRING) == (CHARACTER x)   2. CHAR-CODE <-> CHARACTER      a. (COERCE x 'CHARACTER 'CHAR-CODE) == (CODE-CHAR x)      b. (COERCE x 'CHAR-CODE 'CHARACTER) == (CHAR-CODE x)   3. CHAR-INT <-> CHARACTER      a. (COERCE x 'CHARACTER 'CHAR-INT) == (INT-CHAR x)      b. (COERCE x 'CHAR-INT 'CHARACTER) == (CHAR-INT x)   4. STRING <-> SYMBOL      a. (COERCE x 'SYMBOL 'STRING) == (MAKE-SYMBOL x)      b. (COERCE x 'STRING 'SYMBOL) == (SYMBOL-NAME x)   5. STRING <-> ACCESSIBLE-SYMBOL      a. (COERCE x 'ACCESSIBLE-SYMBOL 'STRING) == (INTERN x)      b. (COERCE x 'STRING 'ACCESSIBLE-SYMBOL) == (SYMBOL-NAME x)   6. INTEGER <-> INTEGER-STRING      a. (COERCE x 'INTEGER-STRING 'INTEGER)	 == (WRITE-TO-STRING X :BASE 10 :RADIX NIL)      b. (COERCE x 'INTEGER 'INTEGER-STRING)	 == (PARSE-INTEGER x)   7. CHAR-CODE <-> STRING      a. (COERCE x 'STRING 'CHAR-CODE) ==	 == (COERCE (COERCE x 'CHARACTER 'CHAR-CODE) 'STRING 'CHARACTER)	 == (STRING (CODE-CHAR x))      b. (COERCE x 'CHAR-CODE 'STRING)	 == (COERCE (COERCE x 'CHARACTER 'STRING) 'CHAR-CODE 'CHARACTER)	 == (CHAR-CODE (CHARACTER x))   8. CHAR-INT <-> STRING      a. (COERCE x 'STRING 'CHAR-INT) ==	 == (COERCE (COERCE x 'CHARACTER 'CHAR-INT) 'STRING 'CHARACTER)	 == (STRING (INT-CHAR x))      b. (COERCE x 'CHAR-INT 'STRING)	 == (COERCE (COERCE x 'CHARACTER 'STRING) 'CHAR-INT 'CHARACTER)	 == (CHAR-INT (CHARACTER x))   9. CHAR-CODE <-> SYMBOL      a. (COERCE x 'SYMBOL 'CHAR-CODE)	 == (COERCE (COERCE x 'STRING 'CHAR-CODE) 'SYMBOL 'STRING)	 == (MAKE-SYMBOL (STRING (CODE-CHAR x)))      b. (COERCE x 'CHAR-CODE 'SYMBOL)	 == (COERCE (COERCE x 'STRING 'SYMBOL) 'CHAR-CODE 'STRING)	 == (CHAR-CODE (CHARACTER (SYMBOL-NAME x)))  10. CHAR-INT <-> SYMBOL      a. (COERCE x 'SYMBOL 'CHAR-INT)	 == (COERCE (COERCE x 'STRING 'CHAR-INT) 'SYMBOL 'STRING)	 == (MAKE-SYMBOL (STRING (INT-CHAR x)))      b. (COERCE x 'CHAR-INT 'SYMBOL)	 == (COERCE (COERCE x 'STRING 'SYMBOL) 'CHAR-INT 'STRING)	 == (CHAR-INT (CHARACTER (SYMBOL-NAME x)))  11. CHAR-CODE <-> ACCESSIBLE-SYMBOL      a. (COERCE x 'ACCESSIBLE-SYMBOL 'CHAR-CODE)	 == (COERCE (COERCE x 'STRING 'CHAR-CODE) 'ACCESSIBLE-SYMBOL 'STRING)	 == (INTERN (STRING (CODE-CHAR x)))      b. (COERCE x 'CHAR-CODE 'ACCESSIBLE-SYMBOL)	 == (COERCE (COERCE x 'STRING 'ACCESSIBLE-SYMBOL) 'CHAR-CODE 'STRING)	 == (CHAR-CODE (CHARACTER (SYMBOL-NAME x)))  12. CHAR-INT <-> ACCESSIBLE-SYMBOL      a. (COERCE x 'ACCESSIBLE-SYMBOL 'CHAR-INT)	 == (COERCE (COERCE x 'STRING 'CHAR-INT) 'ACCESSIBLE-SYMBOL 'STRING)	 == (INTERN (STRING (INT-CHAR x)))      b. (COERCE x 'CHAR-INT 'ACCESSIBLE-SYMBOL)	 == (COERCE (COERCE x 'STRING 'ACCESSIBLE-SYMBOL) 'CHAR-INT 'STRING)	 == (CHAR-INT (CHARACTER (SYMBOL-NAME x)))  13. PATHNAME <-> STRING      a. (COERCE x 'STRING 'PATHNAME)	 == (NAMESTRING x)      b. (COERCE x 'PATHNAME 'STRING)	 == (PARSE-NAMESTRING x)  14. INTEGRAL-FLOAT <-> INTEGER      a. (COERCE x 'INTEGER 'INTEGRAL-FLOAT)	 == (TRUNCATE x)      b. (COERCE x 'INTEGRAL-FLOAT 'INTEGER)	 == (FLOAT x)  Note that restrictions on the X argument to COERCE are as they would  be for the corresponding function. For example, in 1b only strings of  length 1 can be converted by CHARACTER.  Observe that in some cases, such as (COERCE NIL 'STRING) where the first  argument has a type which is a subtype of more than one of the above  cases, the result may not be what the user expects. To get a safe result  from COERCE, use of the third argument is strongly recommended.  (COERCE NIL 'STRING 'SYMBOL) and (COERCE NIL 'STRING 'LIST) are not  subject to the confusion that (COERCE NIL 'STRING) is.Rationale:  These proposed extensions make COERCE able to deal with a much larger  space of type coercions without the problems of ambiguity raised in  the Problem Description.  The proposed extensions are, for the most part, fairly symmetric.  Nearly every coercion that COERCE could do could be undone in a   fairly straightforward and reasonably reliable way.  Compatibility with the old style of coerce is handled by making the  third argument optional.  This proposal is upward compatible with the existing semantics of COERCE.  (The previous version of this proposal, by M. Ida, proposed incompatible  changes.)Current Practice:  Probably no one implements the proposed behavior at this time.Cost to Implementors:  The more optimization a compiler does (or might do) of COERCE, the more  work might be necessary. In general, however, the changes would probably  not involve a major amount of work.Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  Various proposals to extend COERCE would probably not pass because  not everyone can agree on how to view the type of the first argument.Benefits:  Currently, whenver documentation refers to something being `coerced'  from one type or another, it might mean that COERCE is called, or it  might mean that some more specialized operator is called. This proposal  brings us much closer to having the meaning of "is coerced to" be  "the COERCE function is called", which would make things easier on  the consumers of that documentation.Aesthetics:  This proposal regularizes the semantics of COERCE by making it more  predictable and more   Pitman thinks this proposal would greatly improve the aesthetics of  COERCE. Does anyone want to present  Discussion:  For purposes of getting this proposal through in parallel, we have not  any assumptions about the impending character proposal. Nothing proposed  in this document is inherently in conflict with any potential output of  the Characters Committee. The fact that characters may have multiple  representations as integers is an important way to highlight the value of  this proposal, which is why character issues are included.  Needless to say, the proposal TYPE-OF-UNDERCONSTRAINED will need to be  dealt with. If a CL implementation is permitted to always return T for   (TYPE-OF anything), then the defaulting of the third argument in this  proposal is not going to work so well. That's why that issue is listed  as a `required issue' in the heading above.  Pitman supports this proposal.  Although this proposal is not the same in detail as M. Ida's original  proposal, it does address the same issues.  Pitman is hopeful that the  alternative solutions proposed here would still be satisfactory to the  Japanese community, and looks forward to feedback from that community  about this issue.*start*01827 00024 USaReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 15 FEB 89 07:35:47 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 539495; Wed 15-Feb-89 10:35:22 ESTDate: Wed, 15 Feb 89 10:35 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: COERCE-INCOMPLETE (Version 2)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890214-163601-10990@Xerox>Message-ID: <890215103505.4.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 14 Feb 89 16:34 PST    From: masinter.pa@Xerox.COM    The last mail on this topic was 30-Dec-88.    We can either release version 2 (of 21-Nov-88), someone can produce a    new version, or we can drop it.I don't think it's our job to make the decision, only to make theoptions clear.  I think the real options are: 1. STATUS-QUO: Leave COERCE alone (modulo extensions per FUNCTION-TYPE). 2. EXTEND:     Extend COERCE per version 2 (since it's already written up). 3. DEPRECATE:  Deprecate COERCE.I don't think we have the authority to simply pocket veto the issue,especially given that the user community (in this case `Japan') hasindicated that this is important to them. It deserves to at least cometo a full vote in some form.    I'm inclined toward dropping the issue, even though some of the extensions    "would be nice". I think David's message of 30-Dec is in agreement.I suggest we take version 2, add an option to deprecate and an optionfor status quo, and then declare our work done on it and just leave itup to the committee to resolve this by 3-way vote. I'm willing to do thewriting.    Yes, the FUNCTION-TYPE issue already extended COERCE to deal with    'FUNCTION.*start*00889 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 FEB 89 16:59:26 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Feb 89  16:52:29 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 FEB 89 16:36:01 PSTDate: 14 Feb 89 16:34 PSTFrom: masinter.paSubject: Re: Issue: COERCE-INCOMPLETE (Version 2)To: cl-cleanup@sail.stanford.eduMessage-ID: <890214-163601-10990@Xerox>The last mail on this topic was 30-Dec-88.We can either release version 2 (of 21-Nov-88), someone can produce a newversion, or we can drop it.I'm inclined toward dropping the issue, even though some of the extensions"would be nice". I think David's message of 30-Dec is in agreement.Yes, the FUNCTION-TYPE issue already extended COERCE to deal with'FUNCTION.*start*00968 00024 US Date: 16 Feb 89 23:33 PSTFrom: masinter.paSubject: Re: Issue: COERCE-INCOMPLETE (Version 2)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 15 Feb 89 10:35 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PAI said "We can either release version 2 (of 21-Nov-88), someone can produce a new version, or we can drop it."You said we could either have STATUS-QUO, EXTEND, or DEPRECATE.I think my choices still stand, procedurally. You say you like "somebody can produce a new version" & are willing to write it.I don't see that we need to add an option for STATUS-QUO; if people want the STATUS-QUO, they can just vote against any of the proposals.(As an aside, I am opposed to using "STATUS-QUO" as the name of any proposal; I want to avoid repeating the debate over what that means.)I do think we can avoid raising any issue at X3J13 that we think doesn't need to be raised. *start*06826 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 MAR 89 14:42:57 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Mar 89  14:42:50 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 552470; Tue 7-Mar-89 17:40:29 ESTDate: Tue, 7 Mar 89 17:40 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETE (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890307174023.1.KMP@BOBOLINK.SCRC.Symbolics.COM>I'm crossing my fingers you'll think this is ready to ship to X3J13 fora vote. Everyone might not agree on the same option, but hopefully it atleast adequately expresses the viable options at this point and wecan just get a show of hands to figure out whether to adopt one of thesetwo things or to just give up on the issue. -kmp-----Issue:		 COERCE-INCOMPLETEReference:	 COERCE (p50)Category:	 ADDITION/CHANGEEdit history:	 Version 1 of COERCE-INCOMPLETE, 26-Feb-88 by M. Ida		 Version 1 of COERCE-FROM-TYPE,  20-Jun-88 by Pitman		 Version 2 of COERCE-INCOMPLETE, 21-Nov-88 by Pitman		  (consolidate previous two proposals)		 Version 3 of COERCE-INCOMPLETE, 07-Mar-89 by Pitman		  (eliminate unpopular proposal, two new options)Problem Description:  COERCE is difficult to extend because ambiguities arise about the  source type of the coercion.  For example, if the symbol STRING were permitted as a second argument  to coerce, as in (COERCE NIL 'STRING), there would be two posssible  return values: "" or "NIL". The choice would be arbitrary and would  have to be specified by the documentation. No matter which was chosen,  it would probably turn out to be a problem for some applications at  some times.  Another example is (COERCE (CHAR-CODE #\A) 'STRING). This might  return the same as (FORMAT NIL "~D" (CHAR-CODE #\A)) -- "65" in  most ASCII-based implementations -- or it might return "A". Again,  the choice would be arbitrary.  There is clear desire on the part of the user community to lift some of  the existing restrictions on arguments to COERCE, but because of legitimate  concerns about ambiguities, the Common Lisp designers have thus far  refused to do so.  Unfortunately, the failure of COERCE to handle these cases means it is  very difficult to learn to use COERCE. And the fact that COERCE is not  easily learned contributes to difficulty in learning Common Lisp because  instead of a single coercion operator with general purpose semantics, a  number of very special purpose coercion operators must be learned instead.  Some middle ground needs to be found, which neither compromises the  clear semantics and portable nature of COERCE nor complicates COERCE  in a way that makes it unlearnable.  Also, some people have expressed a desire for COERCE to be more   `symmetric.' Usually they seem to mean that they want it to be the case  that if (COERCE x y) works, then (COERCE (COERCE x y) (TYPE-OF x))   should also work. Although this is not an essential desire, it would  certainly be nice to achieve. Proposal (COERCE-INCOMPLETE:LIMITED-ARBITRARY-EXTENSION):  Define COERCE to accept the following equivalences:   1. (COERCE x 'STRING)    == (STRING x)   2. (COERCE x 'PATHNAME)  == (PATHNAME x)   3. (COERCE x 'RATIONAL)  == (RATIONAL x)  Clarify that   4. (COERCE x 'FLOAT)     == (FLOAT x)  Rationale:    Many users think of STRING, for example, as ``the way to coerce    something to a string'' and are baffled why COERCE and STRING    disagree on how to do this.    Such users think that if there's a moral battle to be waged    over how to coerce an object to a STRING, the battle has already    been lost by defining the STRING function -- that whatever    decision is made for STRING must also apply to COERCE for the    sake of simplicity.     Similar arguments can be made for PATHNAME, FLOAT, and RATIONAL.Proposal (COERCE-INCOMPLETE:DEPRECATE):  Deprecate COERCE.  Rationale:    COERCE is not functionally necessary -- no operation that it does    cannot be done in some other way.  As such, it is basically just    a matter of syntactic convenience, and perhaps isn't worth having    around if it will be the subject of endless debate.  Deprecating    it would allow us to declare this issue a `dead end' and focus our    attention on matters of greater substance.Current Practice:  Presumably No one implements either of the proposals at this time,  since none are compatible with CLtL.Cost to Implementors:  COERCE: Small to moderate.  DEPRECATE: None.Cost to Users:  COERCE: This is an incompatible change. (COERCE 'NIL 'STRING) => ""    but (STRING NIL) => "NIL".  How many applications are impacted by    this change is not clear. It would be straightforward to shadow    COERCE with an alternate definition that did the old thing in    cases where people were worried. Once such cases have been     identified, rewriting      (COERCE X 'STRING)    as     (IF X (COERCE X 'STRING) "")    will suffice in most cases.  DEPRECATE: No immediate work would be needed, although many maintained    applications would get upgraded in order to use the primitives that    are `in vogue.'Cost of Non-Adoption:  People will continue to see and debate the issues alluded to in  the Problem Description.Benefits:  The cost of Non-Adoption will be avoided.Aesthetics:  COERCE: Many people will probably see the idea of making    COERCE consistent with STRING, PATHNAME, FLOAT, and    RATIONAL as a clear improvement -- possibly outweighing    the costs of both an incompatible change and a decision    to arbitrarily favor one treatment over the other.  DEPRECATE: Some may take the deprecation of COERCE as an    aesthetic improvement because it eliminates the need to    debate this issue further. Others may see the     ``de-centralization'' of coercion as a step backward.Discussion:  Pitman supports COERCE-INCOMPLETE:LIMITED-ARBITRARY-EXTENSION.  Hopefully Moon and Masinter support it, too, since it's  basically patterned after a bunch of mail they were sending  back and forth.  A proposal to extend COERCE to permit a ``view type'' argument  was considered and rejected as too extreme to consider seriously  in the timeframe available.  Pierson suggests that COERCE ought to be a candidate for  generic function status.  Pitman thinks that making [two-argument] COERCE generic would  be a -very- bad idea  but believes that his earlier proposal  involving a third `view type' argument might be able to   accomodate such extension.*start*01338 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 11:36:24 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 9 Mar 89  11:35:25 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 553862; Thu 9-Mar-89 14:33:05 ESTDate: Thu, 9 Mar 89 14:32 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETE (Version 3)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890307174023.1.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890309193255.6.MOON@EUPHRATES.SCRC.Symbolics.COM>I agree that this is ready to send out.  The thing aboutCOERCE-INCOMPLETE:LIMITED-ARBITRARY-EXTENSION that strikes fearinto my heart is that it wipes out CLtL's simple statement thatany sequence type may be converted to any other sequence type,and starts people asking questions like does(coerce nil '(vector character)) => "" or "NIL"?This concern is not reflected at all in the writeup.I agree that this is ready to send out but I'm inclined to voteno on both proposals and keep the (unsatisfactory) status quo.*start*01253 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 22:44:30 PSTReceived: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by SAIL.Stanford.EDU with TCP; 9 Mar 89  22:44:19 PSTReceived: from GANG-GANG.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 280108; Fri 10-Mar-89 01:41:38 ESTDate: Fri, 10 Mar 89 01:42 ESTFrom: Glenn S. Burke <gsb@ALDERAAN.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETE (Version 3)To: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890307174023.1.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890310064205.1.GSB@GANG-GANG.SCRC.Symbolics.COM>I believe that any change to the status quo is incomplete withoutproviding a coercion mechanism whose "viewpoint" is that of a sequence.That is effectively what the current COERCE is, overloaded with thosetypes which do not conflict with SEQUENCE.Because of the problem of differing viewpoints, I'm inclined to thinkthat COERCE should be shrunk down to only being a sequence coercionfunction, and all other coercions should be handled by the appropriatefunctions.*start*07507 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 14-Mar-89 17:45:59 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 17:45:46 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Mar 89  17:31:00 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 MAR 89 14:29:58 PSTDate: 14 Mar 89 14:24 PSTFrom: masinter.paSubject: Issue: COERCE-INCOMPLETE (Version 3)To: X3J13@sail.stanford.edureply-to: cl-cleanup@sail.stanford.eduline-fold: noMessage-ID: <890314-142958-1976@Xerox>There are a couple of "additional comments" on the proposalat the end.!Issue:		 COERCE-INCOMPLETEReference:	 COERCE (p50)Category:	 ADDITION/CHANGEEdit history:	 Version 1 of COERCE-INCOMPLETE, 26-Feb-88 by M. Ida		 Version 1 of COERCE-FROM-TYPE,  20-Jun-88 by Pitman		 Version 2 of COERCE-INCOMPLETE, 21-Nov-88 by Pitman		  (consolidate previous two proposals)		 Version 3 of COERCE-INCOMPLETE, 07-Mar-89 by Pitman		  (eliminate unpopular proposal, two new options)Problem Description:  COERCE is difficult to extend because ambiguities arise about the  source type of the coercion.  For example, if the symbol STRING were permitted as a second argument  to coerce, as in (COERCE NIL 'STRING), there would be two posssible  return values: "" or "NIL". The choice would be arbitrary and would  have to be specified by the documentation. No matter which was chosen,  it would probably turn out to be a problem for some applications at  some times.  Another example is (COERCE (CHAR-CODE #\A) 'STRING). This might  return the same as (FORMAT NIL "~D" (CHAR-CODE #\A)) -- "65" in  most ASCII-based implementations -- or it might return "A". Again,  the choice would be arbitrary.  There is clear desire on the part of the user community to lift some of  the existing restrictions on arguments to COERCE, but because of legitimate  concerns about ambiguities, the Common Lisp designers have thus far  refused to do so.  Unfortunately, the failure of COERCE to handle these cases means it is  very difficult to learn to use COERCE. And the fact that COERCE is not  easily learned contributes to difficulty in learning Common Lisp because  instead of a single coercion operator with general purpose semantics, a  number of very special purpose coercion operators must be learned instead.  Some middle ground needs to be found, which neither compromises the  clear semantics and portable nature of COERCE nor complicates COERCE  in a way that makes it unlearnable.  Also, some people have expressed a desire for COERCE to be more   `symmetric.' Usually they seem to mean that they want it to be the case  that if (COERCE x y) works, then (COERCE (COERCE x y) (TYPE-OF x))   should also work. Although this is not an essential desire, it would  certainly be nice to achieve. Proposal (COERCE-INCOMPLETE:LIMITED-ARBITRARY-EXTENSION):  Define COERCE to accept the following equivalences:   1. (COERCE x 'STRING)    == (STRING x)   2. (COERCE x 'PATHNAME)  == (PATHNAME x)   3. (COERCE x 'RATIONAL)  == (RATIONAL x)  Clarify that   4. (COERCE x 'FLOAT)     == (FLOAT x)  Rationale:    Many users think of STRING, for example, as ``the way to coerce    something to a string'' and are baffled why COERCE and STRING    disagree on how to do this.    Such users think that if there's a moral battle to be waged    over how to coerce an object to a STRING, the battle has already    been lost by defining the STRING function -- that whatever    decision is made for STRING must also apply to COERCE for the    sake of simplicity.     Similar arguments can be made for PATHNAME, FLOAT, and RATIONAL.Proposal (COERCE-INCOMPLETE:DEPRECATE):  Deprecate COERCE.  Rationale:    COERCE is not functionally necessary -- no operation that it does    cannot be done in some other way.  As such, it is basically just    a matter of syntactic convenience, and perhaps isn't worth having    around if it will be the subject of endless debate.  Deprecating    it would allow us to declare this issue a `dead end' and focus our    attention on matters of greater substance.Current Practice:  Presumably No one implements either of the proposals at this time,  since none are compatible with CLtL.Cost to Implementors:  COERCE: Small to moderate.  DEPRECATE: None.Cost to Users:  COERCE: This is an incompatible change. (COERCE 'NIL 'STRING) => ""    but (STRING NIL) => "NIL".  How many applications are impacted by    this change is not clear. It would be straightforward to shadow    COERCE with an alternate definition that did the old thing in    cases where people were worried. Once such cases have been     identified, rewriting      (COERCE X 'STRING)    as     (IF X (COERCE X 'STRING) "")    will suffice in most cases.  DEPRECATE: No immediate work would be needed, although many maintained    applications would get upgraded in order to use the primitives that    are `in vogue.'Cost of Non-Adoption:  People will continue to see and debate the issues alluded to in  the Problem Description.Benefits:  The cost of Non-Adoption will be avoided.Aesthetics:  COERCE: Many people will probably see the idea of making    COERCE consistent with STRING, PATHNAME, FLOAT, and    RATIONAL as a clear improvement -- possibly outweighing    the costs of both an incompatible change and a decision    to arbitrarily favor one treatment over the other.  DEPRECATE: Some may take the deprecation of COERCE as an    aesthetic improvement because it eliminates the need to    debate this issue further. Others may see the     ``de-centralization'' of coercion as a step backward.Discussion:  Pitman supports COERCE-INCOMPLETE:LIMITED-ARBITRARY-EXTENSION.  Hopefully Moon and Masinter support it, too, since it's  basically patterned after a bunch of mail they were sending  back and forth.  A proposal to extend COERCE to permit a ``view type'' argument  was considered and rejected as too extreme to consider seriously  in the timeframe available.  Pierson suggests that COERCE ought to be a candidate for  generic function status.  Pitman thinks that making [two-argument] COERCE generic would  be a -very- bad idea  but believes that his earlier proposal  involving a third `view type' argument might be able to   accomodate such extension.!Additional commentsI agree that this is ready to send out.  The thing aboutCOERCE-INCOMPLETE:LIMITED-ARBITRARY-EXTENSION that strikes fearinto my heart is that it wipes out CLtL's simple statement thatany sequence type may be converted to any other sequence type,and starts people asking questions like does(coerce nil '(vector character)) => "" or "NIL"?This concern is not reflected at all in the writeup.I agree that this is ready to send out but I'm inclined to voteno on both proposals and keep the (unsatisfactory) status quo.-----  -----I believe that any change to the status quo is incomplete withoutproviding a coercion mechanism whose "viewpoint" is that of a sequence.That is effectively what the current COERCE is, overloaded with thosetypes which do not conflict with SEQUENCE.Because of the problem of differing viewpoints, I'm inclined to thinkthat COERCE should be shrunk down to only being a sequence coercionfunction, and all other coercions should be handled by the appropriatefunctions.-----  -----*start*07288 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Mar-89 11:11:01 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 11:03:22 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  10:44:26 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 16 MAR 89 09:59:01 PSTDate: 16 Mar 89 09:57 PSTFrom: masinter.paSubject: Issue: COERCE-INCOMPLETE (Version 3)To: x3j13@sail.stanford.eduline-fold: NOMessage-ID: <890316-095901-4371@Xerox>There are some additional comments at the end.!Issue:		 COERCE-INCOMPLETEReference:	 COERCE (p50)Category:	 ADDITION/CHANGEEdit history:	 Version 1 of COERCE-INCOMPLETE, 26-Feb-88 by M. Ida		 Version 1 of COERCE-FROM-TYPE,  20-Jun-88 by Pitman		 Version 2 of COERCE-INCOMPLETE, 21-Nov-88 by Pitman		  (consolidate previous two proposals)		 Version 3 of COERCE-INCOMPLETE, 07-Mar-89 by Pitman		  (eliminate unpopular proposal, two new options)Problem Description:  COERCE is difficult to extend because ambiguities arise about the  source type of the coercion.  For example, if the symbol STRING were permitted as a second argument  to coerce, as in (COERCE NIL 'STRING), there would be two posssible  return values: "" or "NIL". The choice would be arbitrary and would  have to be specified by the documentation. No matter which was chosen,  it would probably turn out to be a problem for some applications at  some times.  Another example is (COERCE (CHAR-CODE #\A) 'STRING). This might  return the same as (FORMAT NIL "~D" (CHAR-CODE #\A)) -- "65" in  most ASCII-based implementations -- or it might return "A". Again,  the choice would be arbitrary.  There is clear desire on the part of the user community to lift some of  the existing restrictions on arguments to COERCE, but because of legitimate  concerns about ambiguities, the Common Lisp designers have thus far  refused to do so.  Unfortunately, the failure of COERCE to handle these cases means it is  very difficult to learn to use COERCE. And the fact that COERCE is not  easily learned contributes to difficulty in learning Common Lisp because  instead of a single coercion operator with general purpose semantics, a  number of very special purpose coercion operators must be learned instead.  Some middle ground needs to be found, which neither compromises the  clear semantics and portable nature of COERCE nor complicates COERCE  in a way that makes it unlearnable.  Also, some people have expressed a desire for COERCE to be more   `symmetric.' Usually they seem to mean that they want it to be the case  that if (COERCE x y) works, then (COERCE (COERCE x y) (TYPE-OF x))   should also work. Although this is not an essential desire, it would  certainly be nice to achieve. Proposal (COERCE-INCOMPLETE:LIMITED-ARBITRARY-EXTENSION):  Define COERCE to accept the following equivalences:   1. (COERCE x 'STRING)    == (STRING x)   2. (COERCE x 'PATHNAME)  == (PATHNAME x)   3. (COERCE x 'RATIONAL)  == (RATIONAL x)  Clarify that   4. (COERCE x 'FLOAT)     == (FLOAT x)  Rationale:    Many users think of STRING, for example, as ``the way to coerce    something to a string'' and are baffled why COERCE and STRING    disagree on how to do this.    Such users think that if there's a moral battle to be waged    over how to coerce an object to a STRING, the battle has already    been lost by defining the STRING function -- that whatever    decision is made for STRING must also apply to COERCE for the    sake of simplicity.     Similar arguments can be made for PATHNAME, FLOAT, and RATIONAL.Proposal (COERCE-INCOMPLETE:DEPRECATE):  Deprecate COERCE.  Rationale:    COERCE is not functionally necessary -- no operation that it does    cannot be done in some other way.  As such, it is basically just    a matter of syntactic convenience, and perhaps isn't worth having    around if it will be the subject of endless debate.  Deprecating    it would allow us to declare this issue a `dead end' and focus our    attention on matters of greater substance.Current Practice:  Presumably No one implements either of the proposals at this time,  since none are compatible with CLtL.Cost to Implementors:  COERCE: Small to moderate.  DEPRECATE: None.Cost to Users:  COERCE: This is an incompatible change. (COERCE 'NIL 'STRING) => ""    but (STRING NIL) => "NIL".  How many applications are impacted by    this change is not clear. It would be straightforward to shadow    COERCE with an alternate definition that did the old thing in    cases where people were worried. Once such cases have been     identified, rewriting      (COERCE X 'STRING)    as     (IF X (COERCE X 'STRING) "")    will suffice in most cases.  DEPRECATE: No immediate work would be needed, although many maintained    applications would get upgraded in order to use the primitives that    are `in vogue.'Cost of Non-Adoption:  People will continue to see and debate the issues alluded to in  the Problem Description.Benefits:  The cost of Non-Adoption will be avoided.Aesthetics:  COERCE: Many people will probably see the idea of making    COERCE consistent with STRING, PATHNAME, FLOAT, and    RATIONAL as a clear improvement -- possibly outweighing    the costs of both an incompatible change and a decision    to arbitrarily favor one treatment over the other.  DEPRECATE: Some may take the deprecation of COERCE as an    aesthetic improvement because it eliminates the need to    debate this issue further. Others may see the     ``de-centralization'' of coercion as a step backward.Discussion:  Pitman supports COERCE-INCOMPLETE:LIMITED-ARBITRARY-EXTENSION.  Hopefully Moon and Masinter support it, too, since it's  basically patterned after a bunch of mail they were sending  back and forth.  A proposal to extend COERCE to permit a ``view type'' argument  was considered and rejected as too extreme to consider seriously  in the timeframe available.  Pierson suggests that COERCE ought to be a candidate for  generic function status.  Pitman thinks that making [two-argument] COERCE generic would  be a -very- bad idea  but believes that his earlier proposal  involving a third `view type' argument might be able to   accomodate such extension.!Additional comments:"... The thing aboutCOERCE-INCOMPLETE:LIMITED-ARBITRARY-EXTENSION that strikes fearinto my heart is that it wipes out CLtL's simple statement thatany sequence type may be converted to any other sequence type,and starts people asking questions like does(coerce nil '(vector character)) => "" or "NIL"?... I'm inclined to voteno on both proposals and keep the (unsatisfactory) status quo.""I believe that any change to the status quo is incomplete withoutproviding a coercion mechanism whose "viewpoint" is that of a sequence.That is effectively what the current COERCE is, overloaded with thosetypes which do not conflict with SEQUENCE.Because of the problem of differing viewpoints, I'm inclined to thinkthat COERCE should be shrunk down to only being a sequence coercionfunction, and all other coercions should be handled by the appropriatefunctions."*start*01020 00024 US GV-Info: barmar@Think.COM at 16-Mar-89 15:52:30 from AGReturn-Path: <barmar@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 16 MAR 89 15:48:45 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Thu, 16 Mar 89 17:59:11 ESTDate: Thu, 16 Mar 89 18:00 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: COERCE-INCOMPLETE (Version 3)To: masinter.paCc: x3j13@sail.stanford.eduIn-Reply-To: <890316-095901-4371@Xerox>Message-Id: <19890316230020.6.BARMAR@OCCAM.THINK.COM>There's an inconsistency in the names of the proposals.  In the Proposalsections, the two proposals are named LIMITED-ARBITRARY-EXTENSION andDEPRECATE.  But in some other sections they are called COERCE andDEPRECATE.Problem with DEPRECATE: Didn't we specify that the way to convert alambda expression into a function object is to use (COERCE x 'FUNCTION)?Or did we also define a new function that does this?                                                barmar*start*01396 00024 US GV-Info: KMP@STONY-BROOK.SCRC.Symbolics.COM at 16-Mar-89 16:19:19 from AGReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 16 MAR 89 16:18:56 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 559088; Thu 16-Mar-89 19:18:34 ESTDate: Thu, 16 Mar 89 19:18 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETE (Version 3)To: barmar@Think.COMcc: masinter.pa, x3j13@sail.stanford.eduIn-Reply-To: <19890316230020.6.BARMAR@OCCAM.THINK.COM>Message-ID: <890316191820.6.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Thu, 16 Mar 89 18:00 EST    From: Barry Margolin <barmar@Think.COM>    ...    Problem with DEPRECATE: Didn't we specify that the way to convert a    lambda expression into a function object is to use (COERCE x 'FUNCTION)?    Or did we also define a new function that does this?Re-read FUNCTION-TYPE. The thing Beckerle really wanted and finallygot (over my objection) was that COERCE did nothing `hard' ... Whatit ended up being able to be do can be expressed by #'IDENTITY and#'SYMBOL-FUNCTION. (COERCE x 'FUNCTION) == (ETYPECASE X   (SYMBOL   (SYMBOL-VALUE X))   (FUNCTION X))I don't really think anything more needs to be provided, even if weDEPRECATE coerce.*start*01246 00024 US GV-Info: sandra%defun@cs.utah.edu at 17-Mar-89 09:09:36 from AGReturn-Path: <sandra%defun@cs.utah.edu>Received: from cs.utah.edu ([128.110.4.21]) by Xerox.COM ; 17 MAR 89 08:55:17 PSTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA01151; Fri, 17 Mar 89 09:54:54 -0700Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA06800; Fri, 17 Mar 89 09:54:37 -0700From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8903171654.AA06800@defun.utah.edu>Date: Fri, 17 Mar 89 09:54:35 MSTSubject: Re: Issue: COERCE-INCOMPLETE (Version 3)To: Barry Margolin <barmar@Think.COM>Cc: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>, masinter.pa, x3j13@sail.stanford.eduIn-Reply-To: Barry Margolin <barmar@Think.COM>, Fri, 17 Mar 89 10:57 ESTBarMar is right.  I have a hardcopy of the FUNCTION-TYPE writeup thatwas mailed on 4 Sep 88, with a note from Larry indicating that it'sthe final version as passed at the June meeting.  It includesCOERCE'ing of lambda expressions to functions as item 6b.Personally, I don't think this is a valid argument for not getting ridof COERCE, since it is easy to coerce a lambda expression to a functionusing (EVAL `(FUNCTION ,x)).-Sandra-------*start*02036 00024 USaGV-Info: barmar@Think.COM at 17-Mar-89 08:14:39 from AGReturn-Path: <barmar@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 17 MAR 89 08:14:24 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Fri, 17 Mar 89 10:56:55 ESTDate: Fri, 17 Mar 89 10:57 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: COERCE-INCOMPLETE (Version 3)To: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>Cc: masinter.pa, x3j13@sail.stanford.eduIn-Reply-To: <890316191820.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-Id: <19890317155747.8.BARMAR@OCCAM.THINK.COM>    Date: Thu, 16 Mar 89 19:18 EST    From: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>	Date: Thu, 16 Mar 89 18:00 EST	From: Barry Margolin <barmar@Think.COM>	...	Problem with DEPRECATE: Didn't we specify that the way to convert a	lambda expression into a function object is to use (COERCE x 'FUNCTION)?	Or did we also define a new function that does this?    Re-read FUNCTION-TYPE. The thing Beckerle really wanted and finally    got (over my objection) was that COERCE did nothing `hard' ... What    it ended up being able to be do can be expressed by #'IDENTITY and    #'SYMBOL-FUNCTION.     (COERCE x 'FUNCTION) ==     (ETYPECASE X       (SYMBOL   (SYMBOL-VALUE X))       (FUNCTION X))    I don't really think anything more needs to be provided, even if we    DEPRECATE coerce.I can't find my copy of FUNCTION-TYPE, but I remember it being amendedto add coercion of lambda expressions to functions.  Maybe my memory isfaulty, but I remember something like(COERCE X 'FUNCTION) ==(ETYPECASE X  (SYMBOL (SYMBOL-FUNCTION X))  (FUNCTION X)  ((SATISFIES LAMBDA-EXP-P) (EVAL `(FUNCTION ,X))))      (DEFUN LAMBDA-EXP-P (X)  (AND (CONSP X)		; a non-null list       (EQ (CAR X) 'LAMBDA)	; beginning with LAMBDA       (NOT (NULL (CDR X)))	; with at least two elements       (LISTP (CADR X))))	; argument list is a list                                                barmar*start*01932 00024 US GV-Info: KMP@STONY-BROOK.SCRC.Symbolics.COM at 17-Mar-89 09:45:52 from AGReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 17 MAR 89 09:07:19 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 559547; Fri 17-Mar-89 12:05:36 ESTDate: Fri, 17 Mar 89 12:05 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: COERCE-INCOMPLETE (Version 3)To: sandra%defun@cs.utah.educc: barmar@Think.COM, KMP@STONY-BROOK.SCRC.Symbolics.COM, masinter.pa, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8903171654.AA06800@defun.utah.edu>Message-ID: <890317120519.8.KMP@BOBOLINK.SCRC.Symbolics.COM>[X3J13 removed as overkill for this level of discussion; CL-Cleanup added]    Date: Fri, 17 Mar 89 09:54:35 MST    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    ... BarMar is right. I have a hardcopy of the FUNCTION-TYPE writeup that    was mailed on 4 Sep 88, with a note from Larry indicating that it's    the final version as passed at the June meeting.  It includes    COERCE'ing of lambda expressions to functions as item 6b. ...Yeah, it's the same in my copy. Sorry about that. I just stopped readingtoo soon. Thanks for catching this.    I don't think this is a valid argument for not getting rid of COERCE,    since it is easy to coerce a lambda expression to a function using    (EVAL `(FUNCTION ,x)).I mostly agree, but I admit that most other coercion operators don't forceyou to cons unnecessary intermediate structure in order to do the coercion.Having something like the original SCHEME's ENCLOSE operator wouldn't botherme at all.  Too bad we didn't pick the name DISCLOSE for what ended up beingFUNCTION-LAMBDA-EXPRESSION.  I guess the right name for the ENCLOSE functionat this point is LAMBDA-EXPRESSION-FUNCTION.*start*01346 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 09:48:47 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 09:09:23 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 17 Mar 89  08:57:27 PSTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA01151; Fri, 17 Mar 89 09:54:54 -0700Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA06800; Fri, 17 Mar 89 09:54:37 -0700From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8903171654.AA06800@defun.utah.edu>Date: Fri, 17 Mar 89 09:54:35 MSTSubject: Re: Issue: COERCE-INCOMPLETE (Version 3)To: Barry Margolin <barmar@Think.COM>Cc: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>, masinter.pa, x3j13@sail.stanford.eduIn-Reply-To: Barry Margolin <barmar@Think.COM>, Fri, 17 Mar 89 10:57 ESTBarMar is right.  I have a hardcopy of the FUNCTION-TYPE writeup thatwas mailed on 4 Sep 88, with a note from Larry indicating that it'sthe final version as passed at the June meeting.  It includesCOERCE'ing of lambda expressions to functions as item 6b.Personally, I don't think this is a valid argument for not getting ridof COERCE, since it is easy to coerce a lambda expression to a functionusing (EVAL `(FUNCTION ,x)).-Sandra-------*start*01177 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 09:54:11 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 09:09:36 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  08:53:52 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 17 MAR 89 08:48:52 PSTDate: 17 Mar 89 08:47 PSTFrom: masinter.paSubject: Re: Issue: COERCE-INCOMPLETE (Version 3)In-reply-to: Barry Margolin <barmar@Think.COM>'s message of Fri, 17 Mar 89 10:57 ESTTo: Barry Margolin <barmar@Think.COM>cc: x3j13@sail.stanford.eduMessage-ID: <890317-084852-8321@Xerox>I sent you a copy of FUNCTION-TYPE, as amended and passed. There wasdiscussion of an amendment to allow coercion of lambda expressions tofunctions, but the decision at the June 88 X3J13 meeting was to not requiresuch coercions.Most of the issues passed so far are available from arisia.xerox.comclcleanup/passed. Some of the issues that were amended at the last meetinghaven't yet been stored 'as amended'. I hope to have them there in the nextfew days, as well as copies of all of the 'pending' issues.*start*01766 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 16:02:57 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 16:02:05 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  15:55:11 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Fri, 17 Mar 89 18:48:21 ESTDate: Fri, 17 Mar 89 18:48 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Re: Issue: COERCE-INCOMPLETE (Version 3)To: Sandra J Loosemore <sandra%defun@cs.utah.edu>Cc: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>, masinter.pa, x3j13@sail.stanford.eduIn-Reply-To: <8903171654.AA06800@defun.utah.edu>Message-Id: <19890317234839.3.BARMAR@OCCAM.THINK.COM>    Date: Fri, 17 Mar 89 09:54:35 MST    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    Personally, I don't think this is a valid argument for not getting rid    of COERCE, since it is easy to coerce a lambda expression to a function    using (EVAL `(FUNCTION ,x)).I disagree.  Many of us would not have voted in favor of FUNCTION-TYPEwithout the coercion.  We wanted either a specific function or theextension to COERCE.  We specifically did not feel that the above idiomshould be used in any actual code; it merely serves as a good way ofdescribing the value that the coercion returns.I'll go along with COERCE-INCOMPLETE:DEPRECATE if it is amended toinclude a new function that coerces a lambda expression, symbol, orfunction to a function.  I'll even suggest a name: MAKE-FUNCTION(unfortunately, FUNCTION is taken, so it can't follow the precedent ofnaming a function that coerces to type T just T).                                                barmar*start*00821 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 16:19:39 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 16:19:35 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  16:12:34 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 17 MAR 89 16:02:36 PSTDate: 17 Mar 89 15:57 PSTFrom: masinter.paSubject: Re: Issue: COERCE-INCOMPLETE (Version 3)In-reply-to: masinter.pa's message of 17 Mar 89 08:47 PSTTo: masinter.pacc: Barry Margolin <barmar@Think.COM>, x3j13@sail.stanford.eduMessage-ID: <890317-160236-2538@Xerox>Sorry, I was confused when I sent that message. Yes, COERCE coerces lambdaexpressions to functions. No, APPLY and FUNCALL do not (are not requiredto)do such coercions.*start*01092 00024 US Date:  4 Apr 89 08:11 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: COERCE-INCOMPLETETo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: COERCE-INCOMPLETETo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 08:11:23 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  08:09:35 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 570867; Tue 4-Apr-89 11:09:31 EDTOriginal-Date: Tue, 4 Apr 89 11:09 EDTMessage-ID: <890404110907.4.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say that someone made a motion for option DEPRECATE but itdied for lack of a second. This issue was marked withdrawn.