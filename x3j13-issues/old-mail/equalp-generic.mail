*start*08412 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 FEB 89 14:01:56 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 28 Feb 89  14:01:05 PSTDate: Tue, 28 Feb 89 13:48:20 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue EQUALP-GENERICTo: cl-cleanup@SAIL.STANFORD.EDUcc: JonL@LUCID.COM, iim@ECLA.USC.EDUMessage-ID: <12474360416.19.IIM@ECLA.USC.EDU>In response to JonL's complaint that a proposal to make EQUALP a genericfunction did not seem to be forthcoming ...-----Forum:		CleanupIssue:		EQUALP-GENERICReferences:	EQUALP, p81Related issues: EQUAL-STRUCTURE		HASH-TABLE-STABILITY		HASH-TABLE-TESTSCategory:	CHANGE ADDITIONEdit history:	Version 1, 02-28-89, Kim A. BarrettProblem description: The recent acceptance of Issue EQUAL-STRUCTURE (as ammended) has generated some complaints about its specified behavior on objects with metaclass STRUCTURE-CLASS.  Some programs which depend on EQUALP comparing the components of structures are now broken. There are some who feel that EQUALP could be made much more useful than it currently is by making it user extensible, but there are potential difficulties due to the recent acceptance of Issue HASH-TABLE-TESTS, which added EQUALP as a valid hash-table test.Proposal (EQUALP-GENERIC:YES): Specify that EQUALP is a generic function, and define the new generic function EQUALP-HASH.  Specify that a necessary requirement on all methods for these functions is that (EQUALP x y) => (= (EQUALP-HASH x t) (EQUALP-HASH y t)). Add a discussion of the constraints on equivelence predicates and their corresponding hash functions, similar to that presented in Issue HASH-TABLE-STABILITY. EQUALP object1 object2					[Generic Function]  The generic function EQUALP is a predicate which can be called to compare two  objects for equivelence.  The precise definition of equivelence is specified  by the methods defined on this function.  The result is either true or false,  depending on whether the objects are equivelent. Method Signatures:  EQUALP (object1 NUMBER) (object2 NUMBER)		[Primary Method]   Defines equality as being =.  EQUALP (object1 CHARACTER) (object2 CHARACTER)	[Primary Method]   Defines equality as being CHAR-EQUAL.  EQUALP (object1 CONS) (object2 CONS)			[Primary Method]   Defines equality as having EQUALP CAR's and EQUALP CDR's.  EQUALP (object1 PATHNAME) (object2 PATHNAME)		[Primary Method]   Defines equality as being EQUAL.  EQUALP (object1 VECTOR) (object2 VECTOR)		[Primary Method]   Defines equality as having the same length (observing fill-pointers when   present), and every pair of corresponding components are EQUALP.   EQUALP (object1 ARRAY) (object2 ARRAY)		[Primary Method]   Defines equality as having the same rank and dimensions, and every pair of   corresponding components are EQUALP.  EQUALP (object1 HASH-TABLE) (object2 HASH-TABLE)	[Primary Method]   Defines equality as satisfying the following conditions:   1. Each hash-table uses the same test function.   2. Each hash-table contains entries for the same set of keys, where the test      function is used to determine the equivelence of keys.   3. For each key, the associated values from the two tables are EQUALP.  EQUALP (object1 T) (object2 T)			[Primary Method]   The default method defines equality as being EQ. Remarks:  An error is signaled on an attempt to add a method on any built-in class.  Adding a method on a class after ALLOCATE-INSTANCE has been called on the  class has undefined consequences.  Implementations may be extended in this  case.  An implementation may specify additional methods on this function. EQUALP-HASH object &optional use-pointer depth		[Generic Function]  The generic function EQUALP-HASH is a called to compute a hash code for the  Object.  Use-Pointer is a flag.  If true, the memory location of the object  may be used to generate the hash code.  The default is false.  Depth is used to control the depth of recursion, allowing cuttoff.  This  prevents infinite recursion in the case of circular references.  Callers of  this function should not explicitely specify a value for this argument.  Methods on this function which need to make recursive calls should simply  pass the Depth argument along unchanged.  This function returns two values.  The first value is the hash code, which is  a non-negative fixnum.  The second value is a flag indicating whether the  memory location of the object (or any component) was used in generating the  hash code.  A caller who specifies NIL for the Use-Pointer argument may  reliably depend on the second value being false.  This function is used by the implementation to compute hash codes for EQUALP  hash-tables.  By specifying a NIL value for the second argument, it may also  be used to compute a code which is independent of the particular  "incarnation" or "core image", just as for SXHASH. Method Signatures:  EQUALP-HASH (object NUMBER) &optional use-pointer depth     [Primary Method]  EQUALP-HASH (object CHARACTER) &optional use-pointer depth  [Primary Method]  EQUALP-HASH (object CONS) &optional use-pointer depth	      [Primary Method]  EQUALP-HASH (object PATHNAME) &optional use-pointer depth   [Primary Method]  EQUALP-HASH (object VECTOR) &optional use-pointer depth     [Primary Method]  EQUALP-HASH (object ARRAY) &optional use-pointer depth      [Primary Method]  EQUALP-HASH (object HASH-TABLE) &optional use-pointer	depth [Primary Method]  EQUALP-HASH (object T) &optional use-pointer depth	      [Primary Method]   The manner in which the hash code is computed by the standard methods on   this function is implementation dependent. Remarks:  An error is signaled on an attempt to add a method on any built-in class.  Adding a method on a class after ALLOCATE-INSTANCE has been called on the  class has undefined consequences.  Implementations may be extended in this  case.  An implementation may specify additional methods on this function.Examples:Test Cases:Rationale: It is not possible to determine in a general way what components of user-defined classes should be examined when computing equality of instances. By specifying EQUALP to be a generic function which the user can extend, we allow the user to specify the algorithm for determining equivelence. The restrictions on adding additional methods are due to the possiblity of existing data structures having been built up using the previous set of methods.  One way an implementation could be extended would be to provide a mechanism for marking potentially invalid data structures when new methods are added.Current practice: Probably no current implementation already does this.Cost to Implementors: Probably small.  An implementation must already support the described functionality for EQUALP, and must have a function similar to EQUALP-HASH in order to implement hash-tables with an EQUALP test function.  This proposal merely exposes the hashing function and makes both of these functions user-specializable. Cost to Users: Users who were depending on EQUALP descending into structures will have to write methods for both functions for the classes they wish to continue to have this behavior.Cost of non-adoption:Performance impact: Probably small overall, though programs which rely heavily on EQUALP or EQUALP hash-tables may be affected due to the differing performance of generic functions compared with normal functions doing type analysis.  Presumably the performance can only be worse than what would be the case if this proposal were not adopted, since if defining these functions as generic produced better performance, then the implementation may have already made them generic, possibly without advertising the fact.Benefits: Allows users to specify the proper method for comparing instances of user defined classes.Aesthetics:Discussion: Other mechanisms for doing the recursion cuttoff in EQUALP-HASH are possible. The one offered in the proposal is simple and trivial to implement.  It is also kind of ugly, and it is possible that some users might want more than is offered for this.  Maybe some better alternative can be developed.-------*start*02465 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 FEB 89 15:08:27 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Feb 89  15:08:42 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 547765; Tue 28-Feb-89 18:06:27 ESTDate: Tue, 28 Feb 89 18:06 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue EQUALP-GENERICTo: IIM@ECLA.USC.EDUcc: cl-cleanup@SAIL.STANFORD.EDU, JonL@LUCID.COMIn-Reply-To: <12474360416.19.IIM@ECLA.USC.EDU>Message-ID: <19890228230626.7.KMP@BOBOLINK.SCRC.Symbolics.COM>For the record, I oppose making generic any CL function in thisstandard.The fact that DOCUMENTATION and DESCRIBE are generic is perhaps a badprecedent, but those are mostly used interactively or in `tolerant'applications anyway.I side with those who think the issue genericity is an appropriate thingfor a successor standard to study (based on the results of individualimplementations' experimentation).My principle reason is that I think that making something genericdoesn't necessarily solve the problems it looks like it solves. It seemsto appease those who don't look at it deeply, making them go away and bequiet because they think they can just go around changing methodswilly-nilly.  In fact, though, I think we need to develop some rulesabout redefinition, shadowing, and even about documenting protocolsbefore we can successfully make generic anything which is going toundergo a heavy pounding. And I don't think we yet have the wisdom to doany of that.By the way, I expect the ultimate "wisdom" we do evolve to have rulesagainst saying things like "the details of how this is done are not specific" and to require you to have a nice, clear abstract protocol.I don't think you can write serious code that uses EQUALP without it.I think people who use EQUALP should do so because they (a) recognizeit to be arbitrary and (b) like that particular arbitrary definition.I think anyone else should `roll their own.'If you were able to describe EQUALP in a more abstract way, I would notoppose you writing an implementation-specific generic function protocolfor your implementation and proposing it (with the results of your yearsof testing) for the next standard.*start*02008 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 MAR 89 20:10:03 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 1 Mar 89  20:08:17 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 01 MAR 89 19:50:35 PSTDate: Wed, 1 Mar 89 19:50 PSTFrom: Gregor.paSubject: Re: Issue EQUALP-GENERICTo: Kim A. Barrett <IIM@ECLA.USC.EDU>cc: cl-cleanup@SAIL.STANFORD.EDU, JonL@LUCID.COMFcc: BD:>Gregor>mail>outgoing-mail-5.text.newestIn-Reply-To: <12474360416.19.IIM@ECLA.USC.EDU>Message-ID: <19890302035029.0.GREGOR@SPIFF.parc.xerox.com>Line-fold: no    Date: Tue, 28 Feb 89 13:48:20 PST    From: Kim A. Barrett <IIM@ECLA.USC.EDU>Thanks for developing this proposal.  Those other ones of us whomentioned we would think about it have been too swamped.  This message comments on only one small part of your proposal.  I maycomment on other parts later.      An error is signaled on an attempt to add a method on any built-in class.      Adding a method on a class after ALLOCATE-INSTANCE has been called on the      class has undefined consequences.These two points confuse me.  I think the first is just covered by oneof the principles outlined in chapter 3.  Specifically, the results areundefined if you define a method on a specified generic function withspecified classes as the specializers.  This is really just the obviousextension of the function redefinition issue.  I don't think it is worthdefining a new class of generic function which signals this error.The second seems well intentioned but unreasonable.  For one thing, someimplementations may call allocate-instance before defclass returns.  Foranother, it seems too painful to suggest that in order to define such amethod you have to boot your lisp first.  If this is really the only waythe rest of the proposal can hold together, I think we need to reconsiderthe proposal.-------*start*01618 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 MAR 89 17:39:34 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 4 Mar 89  17:40:18 PSTDate: Sat, 4 Mar 89 17:37:32 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue EQUALP-GENERICTo: gregor.pacc: cl-cleanup@SAIL.STANFORD.EDU, iim@ECLA.USC.EDUMessage-ID: <12475450716.30.IIM@ECLA.USC.EDU>> Date: Wed, 1 Mar 89 19:50 PST> From: Gregor.pa@Xerox.COM>> > An error is signaled on an attempt to add a method on any built-in class.>> ... I think the first is just covered by one of the principles outlined in> chapter 3.  ...Yes.  I haven't gotten Chapter 3 assimilated into my thinking yet.> > Adding a method on a class after ALLOCATE-INSTANCE has been called on the> > class has undefined consequences. >> {This} seems well intentioned but unreasonable.  For one thing, some> implementations may call allocate-instance before defclass returns.  For> another, it seems too painful to suggest that in order to define such a> method you have to boot your lisp first.  If this is really the only way the> rest of the proposal can hold together, I think we need to reconsider the> proposal. I agree this is a serious weak point.  Clearly, something needs to be said hereabout the problem of breaking existing data structures by redefining thefunctions they were built with.  The restriction I wrote was intended mostly asa place-holder while we try to come up with something better.kab-------*start*10510 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 MAR 89 17:24:14 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Mar 89  17:22:39 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 552600; Tue 7-Mar-89 20:20:21 ESTDate: Tue, 7 Mar 89 20:20 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue EQUALP-GENERICTo: Kim A. Barrett <IIM@ECLA.USC.EDU>cc: cl-cleanup@SAIL.STANFORD.EDU, JonL@LUCID.COMIn-Reply-To: <12474360416.19.IIM@ECLA.USC.EDU>Message-ID: <19890308012006.6.MOON@EUPHRATES.SCRC.Symbolics.COM>I think you did some good work here, but I don't think you solvedall the problems that Gregor and I discovered in our walk on the beach.If I were you, I would give up and not try to solve the problem ofmaking EQUALP generic within the Common Lisp standard (I might stilltry to solve it as a research effort).  Details below.  Sorry aboutthe length.On the related question of "what did CLtL mean by the undefinedphrase `objects that have components'," I would prefer to abide bythe Kauai decision that this doesn't include structures and instancesof defclass-defined classes, rather than discuss the issue endlessly.On the other hand, I wouldn't shout down anyone who took the troubleto write up a cleanup issue in standard form.    Date: Tue 28 Feb 89 13:48:20-PST    From: Kim A. Barrett <IIM@ECLA.USC.EDU>    In response to JonL's complaint that a proposal to make EQUALP a generic    function did not seem to be forthcoming ...    -----    Forum:		Cleanup    Issue:		EQUALP-GENERIC    References:	EQUALP, p81    Related issues: EQUAL-STRUCTURE		    HASH-TABLE-STABILITY		    HASH-TABLE-TESTS    Category:	CHANGE ADDITION    Edit history:	Version 1, 02-28-89, Kim A. Barrett    Problem description:     The recent acceptance of Issue EQUAL-STRUCTURE (as ammended) has generated     some complaints about its specified behavior on objects with metaclass     STRUCTURE-CLASS.  Some programs which depend on EQUALP comparing the     components of structures are now broken.     There are some who feel that EQUALP could be made much more useful than it     currently is by making it user extensible, but there are potential     difficulties due to the recent acceptance of Issue HASH-TABLE-TESTS, which     added EQUALP as a valid hash-table test.    Proposal (EQUALP-GENERIC:YES):     Specify that EQUALP is a generic function, and define the new generic function     EQUALP-HASH.  Specify that a necessary requirement on all methods for these     functions is that (EQUALP x y) => (= (EQUALP-HASH x t) (EQUALP-HASH y t)).     Add a discussion of the constraints on equivelence predicates and their     corresponding hash functions, similar to that presented in Issue     HASH-TABLE-STABILITY.OK so far.CLtL says that objects that have components are only EQUALP if the two objectsare of the same type.  Perhaps this vague phrase means that CLASS-OF returnsthe same (EQ) class for both of them.  Who enforces this?  And who enforcesthat numbers are an exception to this rule?  Does every method enforce this,or is there some kind of shared code?     EQUALP object1 object2					[Generic Function]      The generic function EQUALP is a predicate which can be called to compare two      objects for equivelence.  The precise definition of equivelence is specified      by the methods defined on this function.  The result is either true or false,      depending on whether the objects are equivelent.     Method Signatures:      EQUALP (object1 NUMBER) (object2 NUMBER)		[Primary Method]       Defines equality as being =.      EQUALP (object1 CHARACTER) (object2 CHARACTER)	[Primary Method]       Defines equality as being CHAR-EQUAL.      EQUALP (object1 CONS) (object2 CONS)			[Primary Method]       Defines equality as having EQUALP CAR's and EQUALP CDR's.      EQUALP (object1 PATHNAME) (object2 PATHNAME)		[Primary Method]       Defines equality as being EQUAL.      EQUALP (object1 VECTOR) (object2 VECTOR)		[Primary Method]       Defines equality as having the same length (observing fill-pointers when       present), and every pair of corresponding components are EQUALP.       EQUALP (object1 ARRAY) (object2 ARRAY)		[Primary Method]       Defines equality as having the same rank and dimensions, and every pair of       corresponding components are EQUALP.      EQUALP (object1 HASH-TABLE) (object2 HASH-TABLE)	[Primary Method]       Defines equality as satisfying the following conditions:       1. Each hash-table uses the same test function.       2. Each hash-table contains entries for the same set of keys, where the test	  function is used to determine the equivelence of keys.       3. For each key, the associated values from the two tables are EQUALP.      EQUALP (object1 T) (object2 T)			[Primary Method]       The default method defines equality as being EQ.     Remarks:      An error is signaled on an attempt to add a method on any built-in class.      Adding a method on a class after ALLOCATE-INSTANCE has been called on the      class has undefined consequences.  Implementations may be extended in this      case.      An implementation may specify additional methods on this function.     EQUALP-HASH object &optional use-pointer depth		[Generic Function]      The generic function EQUALP-HASH is a called to compute a hash code for the      Object.  Use-Pointer is a flag.  If true, the memory location of the object      may be used to generate the hash code.  The default is false.I couldn't figure out how use-pointer is to be used.  Are we saying anythingabout what value a hash table supplies for this argument?  Up at the top youseemed to imply that hash tables supply T.  Then what use is the NIL value?      Depth is used to control the depth of recursion, allowing cuttoff.  This      prevents infinite recursion in the case of circular references.  Callers of      this function should not explicitely specify a value for this argument.      Methods on this function which need to make recursive calls should simply      pass the Depth argument along unchanged.The depth thing is a new feature since CLtL p.81 says EQUALP is permittedto be non-terminating if given circular arguments.Perhaps we should leave our the optional arguments and keep things simple.But that's not my main point, which is still to come.      This function returns two values.  The first value is the hash code, which is      a non-negative fixnum.  The second value is a flag indicating whether the      memory location of the object (or any component) was used in generating the      hash code.  A caller who specifies NIL for the Use-Pointer argument may      reliably depend on the second value being false.The second value is not well enough specified.  The problem is that ifan equalp-hash method for an object with components works by callingequalp-hash recursively on each component and combining the results,it has to combine both values.  Since you said the first value isa non-negative fixnum, we know it can be combined with LOGXOR orsomething more intelligent.  You haven't said anything about how tocombine the second value.  You may be assuming that the second valueis T or NIL and the appropriate combining function is OR, but youhaven't said that.  In fact a simple binary flag isn't really goodenough, because many implementations have multiple levels of memory(volatility, ephemeralness, generations) and efficiency dictates thatthe second value indicate which level was depended upon.  Possiblyit would work to require the second value to be an integer and useMAX as the combining function.  Or perhaps there should be a specificcombining function for this purpose with an implementation-dependentbehavior.  Even that isn't good enough, because a user who writesan equalp-hash method that actually computes a hash code, withoutrecursing into components, has to know what to return as the secondvalue.  We could say that NIL or 0 or some named constant meansthe first value does not depend on any memory locations.      This function is used by the implementation to compute hash codes for EQUALP      hash-tables.  By specifying a NIL value for the second argument, it may also      be used to compute a code which is independent of the particular      "incarnation" or "core image", just as for SXHASH.Now wait a minute, I think being independent of the core image and beingindependent of objects changing their address are two different issues.There can be other things besides memory addresses that are dynamicallyallocated on a per-core-image basis.  Character codes in systems withuser-defined character registries are a classic example.  You need toclarify whether use-pointer NIL means the value cannot change withinthe core image (e.g. when a relocating GC changes memory addresses)or means the value cannot change within the implementation (e.g. whenyou apply equalp-hash in a different core image to an object that isconsidered to be equivalent).     Method Signatures:      EQUALP-HASH (object NUMBER) &optional use-pointer depth     [Primary Method]      EQUALP-HASH (object CHARACTER) &optional use-pointer depth  [Primary Method]      EQUALP-HASH (object CONS) &optional use-pointer depth	      [Primary Method]      EQUALP-HASH (object PATHNAME) &optional use-pointer depth   [Primary Method]      EQUALP-HASH (object VECTOR) &optional use-pointer depth     [Primary Method]      EQUALP-HASH (object ARRAY) &optional use-pointer depth      [Primary Method]      EQUALP-HASH (object HASH-TABLE) &optional use-pointer	depth [Primary Method]      EQUALP-HASH (object T) &optional use-pointer depth	      [Primary Method]       The manner in which the hash code is computed by the standard methods on       this function is implementation dependent.It's pretty unclear what the EQUALP-HASH method on T would do with asecond argument of NIL.  What else can it use but the pointer (andperhaps the class)?  I don't see what it can do but return a constantvalue for all objects.  Maybe it would be better off signalling anerror.  Or maybe this is another argument against the use-pointerfeature.*start*08260 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 23:15:05 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 9 Mar 89  23:14:22 PSTDate: Thu, 9 Mar 89 23:11:34 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue EQUALP-GENERICTo: Moon@SCRC-STONY-BROOK.ARPAcc: cl-cleanup@SAIL.STANFORD.EDU, iim@ECLA.USC.EDUMessage-ID: <12476822243.25.IIM@ECLA.USC.EDU>> Date: Tue, 7 Mar 89 20:20 EST> From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>> CLtL says that objects that have components are only EQUALP if the two> objects are of the same type.  Perhaps this vague phrase means that CLASS-OF> returns the same (EQ) class for both of them.  Who enforces this?  And who> enforces that numbers are an exception to this rule?  Does every method> enforce this, or is there some kind of shared code?Good point.  Offhand, I can't think of a good way to share the code via any ofthe standard method-combination mechanisms.  Semi-minor point: arrays areanother exception to this rule.  I say semi-minor, because that means we havetwo exceptions, which starts making the rule seem somewhat feeble.> I couldn't figure out how use-pointer is to be used.  Are we saying anything> about what value a hash table supplies for this argument?  Up at the top you> seemed to imply that hash tables supply T.  Then what use is the NIL value?A NIL argument is intended to allow users to use this function in much the sameway they presently use SXHASH.  Since users don't have (portable) access to themechanisms by which it is possible to tell whether a hash-code has beeninvalidated by some state change in the system, for them to be able to use thisfunction directly they need to be able to turn off any dependencies on suchstate changes.> The depth thing is a new feature since CLtL p.81 says EQUALP is permitted to> be non-terminating if given circular arguments. Yes, but ... I'll have more to say about this at the end of this message.> The second value is not well enough specified.  ... You haven't said anything> about how to combine the second value.  You may be assuming that the second> value is T or NIL and the appropriate combining function is OR, but you> haven't said that. Yes, that is what I intended, and you're right that I should have been moreexplicit about it.  However ...> In fact a simple binary flag isn't really good enough, because many> implementations have multiple levels of memory (volatility, ephemeralness,> generations) and efficiency dictates that the second value indicate which> level was depended upon. Absolutely right.  I had even thought about this when I was analysing theproblem.  Unfortunately, I forgot about it when I was writing the proposal, andwhen I dug out the manuals I have for other Lisp implementations to check mywork against outside sources, none showed up this problem.> Possibly it would work to require the second value to be an integer and use> MAX as the combining function.  Or perhaps there should be a specific> combining function for this purpose with an implementation-dependent> behavior.  Even that isn't good enough, because a user who writes an> equalp-hash method that actually computes a hash code, without recursing into> components, has to know what to return as the second value.  We could say> that NIL or 0 or some named constant means the first value does not depend on> any memory locations.Using MAX isn't right either.  Consider an implementation in which memory isbroken up into regions which are collected seperately (no generations, justsmaller regions to be dealt with on any one gc).  In such an implementation youmight want to return an integer in which bit positions are associated withregions, and the appropriate combining function is LOGIOR.  So I think itpretty much has to be an implementation-specific function.  A named constantseems the right way to go for user-computed hash-codes.> Now wait a minute, I think being independent of the core image and being> independent of objects changing their address are two different issues.> There can be other things besides memory addresses that are dynamically> allocated on a per-core-image basis.  Character codes in systems with> user-defined character registries are a classic example.Right again.  I forgot that things like character codes might change in strangeways that have nothing to do with memory location.  I think use-pointer shouldprobably mean can't change within the implementation, for compatibility withSXHASH. > It's pretty unclear what the EQUALP-HASH method on T would do with a second> argument of NIL.  What else can it use but the pointer (and perhaps the> class)?  I don't see what it can do but return a constant value for all> objects.  Maybe it would be better off signalling an error.  Or maybe this is> another argument against the use-pointer feature.No, because of the desire to provide functionality similar to SXHASH.A problem which you didn't comment on (probably because others already have) isthe restriction I included on adding and removing methods.  I've pretty muchconvinced myself that this could be removed with the addition of a minor amountof machinery.  Specifically, add a function which can be used to determinewhether the definitions of EQUALP or EQUALP-HASH have changed since the lasttime you checked.  (I'm not going to try to specify it precisely just now.When I write another version of the proposal, I'll do so then.) Regarding the depth argument to EQUALP-HASH.  I keep waffling on this.  Myconcern is that if the object to be hashed is circular, and all the methodsthat are going to be invoked on the circular parts will continue walking thecircular structure, then EQUALP-HASH will hang.  The reason this is potentiallya problem, even though EQUALP is allowed to hang in such circumstances, is thatEQUALP might legitimately be optimized to do an EQL test 'up front'.  Thus,without the depth argument you could potentially try to hash some object and beunable to, despite the fact that you could find it again if you knew where tolook, because the EQL optimization would pick it up.Basically, the question is, do the semantics of EQUALP (and EQUAL) include theidea of doing an EQL test up front or not.  If the EQL test is an'optimization', then it is arguably bogus.  However, I suspect that most peoplewould expect it to be legit, even though the descriptions in CLtL (which don'tsay anything it) should hang when comparing any descended circular structure toitself (and most people would consider the latter behavior rather bizarre).Needless to say, this situation seems to be bugging me (probably excessively).On a more general note, I agree with you that finishing this job may be hard,and may not be possible under the present circumstances.  I had two reasons forgoing to the trouble. First, there seemed to me to be a significant number of people who wereinterested in seeing such a proposal at least attempted.  To paraphrase anargument that Kent Pitman sometimes uses, better to get a proposal out wherepeople can actually look at it and judge it on its merits, even if theconsensus ends up being to punt because its too hard or ill-defined a problem,than to pocket veto.  That way we at least have a record that shows that wegave the problem serious consideration when somebody later complains about whatwe've done.Secondly, I'm really much more interested in the possiblity of specifying howto do hash-tables with general user-specified test and hash functions.  I usedthis proposal as a concrete example to think about, and I feel like I'm muchcloser to a good solution than I would have been just trying to think about theproblem abstractly.  Even if we can't get such a thing into the standard due totime constraints, if we or anyone else can come up with such a specificationthat is widely acceptable, I think a lot of people would be made happier.So I'll keep working on it, and hopefully you and others will continue toprovide such useful comments.  Thanks.kab-------*start*00812 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Mar-89 13:38:06 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 13:38:03 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  13:38:24 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 MAR 89 13:23:03 PSTDate: 16 Mar 89 13:22 PSTFrom: masinter.paSubject: Re: Issue EQUALP-GENERICIn-reply-to: Kim A. Barrett <IIM@ECLA.USC.EDU>'s message of Thu, 9 Mar 89 23:11:34 PSTTo: Kim A. Barrett <IIM@ECLA.USC.EDU>cc: Moon@SCRC-STONY-BROOK.ARPA, cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <890316-132303-5408@Xerox>I didn't think this was ready for release. Will there be a new version very soon?*start*01008 00024 US Date:  4 Apr 89 11:21 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: EQUALP-GENERICTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EQUALP-GENERICTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 11:17:45 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:11:49 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571085; Tue 4-Apr-89 14:11:46 EDTOriginal-Date: Tue, 4 Apr 89 14:11 EDTMessage-ID: <890404141117.5.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say this issue was withdrawn by Barrett.