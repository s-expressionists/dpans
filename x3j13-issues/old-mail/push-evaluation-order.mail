*start*
02598 00024 USf
Originator: @SAIL.STANFORD.EDU:peck%Sun:COM:Xerox
Date: 20 May 87 14:44
Subject: Order of evaluation in PUSH (& PUSHNEW)
From: peck%Sun:COM:Xerox
To: common-lisp%sail.stanford:EDU:Xerox

Return-Path: <@SAIL.STANFORD.EDU:peck@Sun.COM>
Redistributed: Xerox-Common-Lisp^.x
Received: from SAIL.STANFORD.EDU by Xerox.COM ; 20 MAY 87 14:44:54 PDT
Received: from SUN.COM by SAIL.STANFORD.EDU with TCP; 20 May 87  13:59:28 PDT
Received: from snail.sun.com by Sun.COM (4.0/SMI-3.2)	id AA03347; Wed, 20 May 87 13:55:56 PDT
Received: from denali.sun.com by snail.sun.com (3.2/SMI-3.2)	id AA05880; Wed, 20 May 87 13:55:28 PDT
Received: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA29640; Wed, 20 May 87 13:58:00 PDT
Message-Id: <8705202058.AA29640@denali.sun.com>
Original-Date: Wed, 20 May 87 13:57:56 -0700

 In the form: (push (ref1) (car (ref2)))
It is unclear whether (ref1) should be evaluated before (ref2). 

CLtL, page 270 states:
" The *effect* of (PUSH Item Place) is *roughly* equivalent to
(SETF Place (CONS Item Place))
except that the latter would evaluate any subforms of Place twice
while PUSH takes care to evaluate them only once."

CLtL, in discussion of generalized variable accessors/modifiers,
page 99 states:
"Macros that manipulate generalized variables must guarentee the "obvious"
semantics: subforms of generalized-variable references are evaluated ...
in exactly the same order as they appear in the *source* program."

	[Is this the *definition* of "obvious" semantics...?]

PUSH is in the class of "Macros that manipulate generalized variables".
However, even though the *generalized-variable references*
are evaluated with the "obvious" semantics, should standard macros
necessarily evaluate *all* their arguments in the "obvious" order?

The problem is that PUSH is [almost] specified as a macro which expands 
 to something in which its args are not in the "obvious" source order.

Shall we just agree that PUSH does not follow the "obvious" semantics?

Lucic and Franz evaluate (ref2) then (ref1)
Symbolics evaluate (ref1) then (ref2)

Lucid:
> (macroexpand '(push (ref1) (car (ref2))))
((LAMBDA (#:G2) 
  ((LAMBDA (#:G1) (SET-CAR #:G2 #:G1)) 
   (CONS (REF1) (CAR #:G2)))) 
  (REF2))
T

ExCL:
<cl> (macroexpand '(push (ref1) (car (ref2))))
(LET* ((#:G8 (REF2))
       (#:G7 (CONS (REF1) (CAR #:G8))))
  (EXCL::.INV-CAR #:G8 #:G7)) 
T 

Symbolics:
Command: (macroexpand '(push (ref1) (car (ref2))))
(LET* ((#:G5 (REF1))
       (#:G4 (REF2)))
  NIL
  (SYS:RPLACA2 #:G4 (VALUES (CONS #:G5 (CAR #:G4)))))
T


Definitely one for the CL comittee.


*start*
02645 00024 USf
Originator: @SAIL.STANFORD.EDU:Moon%STONY-BROOK.SCRC.Symbolics:COM:Xerox
Date: 20 May 87 19:27
From: Moon%STONY-BROOK.SCRC.Symbolics:COM:Xerox
Subject: Order of evaluation in PUSH (& PUSHNEW)
In-Reply-to: <8705202058.AA29640@denali.sun.com>
To: peck%Sun:COM:Xerox
cc: common-lisp%sail.stanford:EDU:Xerox

GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV
From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>
Subject: Order of evaluation in PUSH (& PUSHNEW)
To: peck@Sun.COM
cc: common-lisp@sail.stanford.edu
In-Reply-To: <8705202058.AA29640@denali.sun.com>
Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>
Redistributed: Xerox-Common-Lisp^.x
Received: from SAIL.STANFORD.EDU by Xerox.COM ; 20 MAY 87 19:27:51 PDT
Received: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 20 May 87  18:44:29 PDT
Received: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 145741; Wed 20-May-87 20:56:15 EDT
Original-Date: Wed, 20 May 87 20:56 EDT
Message-ID: <870520205618.1.MOON@EUPHRATES.SCRC.Symbolics.COM>
GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV

    Date: Wed, 20 May 87 13:57:56 -0700
    From: peck@Sun.COM

     In the form: (push (ref1) (car (ref2)))
    It is unclear whether (ref1) should be evaluated before (ref2). 

The intention of the two paragraphs on page 99

  Other macros that manipulate generalized variables include ... push ....
    Macros that manipulate generalized variables must guarantee...
  subforms of generalized-variable references are evaluated ...
  in exactly the same order as they appear in the *source* program.

was to require (ref1) to be evaluated before (ref2).  If some
implementations fail to follow this, that's evidence that this part
of the specification is not considered universally important, but
I don't think it changes the language.

I hadn't realized until I read your message that the book is actually
ambiguous (here as in so many other places).  The quoted paragraphs could
be taken to restrict order of evaluation only of the subforms of
(car (ref2)), not all of the subforms of the push form.  I'm sure
this weaker interpretation was not what was intended, and the discussion
of (setf reference value) later on the same page supports that,
since value is not a subform of a generalized-variable reference.

I personally think it's pretty dangerous for order of evaluation to
be unspecified and implementation-dependent, so I would prefer to
leave the language the way I claim it was intended to be, and as part
of the standardization process write a less ambiguous specification.


*start*
01412 00024 USf
Originator: @SAIL.STANFORD.EDU:ibuki!weaver%labrea.stanford:EDU:Xerox
Date: 20 May 87 19:42
From: ibuki!weaver%labrea.stanford:EDU:Xerox
Subject: Order of evaluation in PUSH
To: labrea!common-lisp%sail:ARPA:Xerox

GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV
From: ibuki!weaver@labrea.stanford.edu (Eric Weaver)
To: labrea!common-lisp@sail.arpa
Subject: Order of evaluation in PUSH
Return-Path: <@SAIL.STANFORD.EDU:ibuki!weaver@labrea.stanford.edu>
Redistributed: Xerox-Common-Lisp^.x
Received: from SAIL.STANFORD.EDU by Xerox.COM ; 20 MAY 87 19:42:55 PDT
Received: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 20 May 87  19:10:13 PDT
Received: by labrea.stanford.edu; Wed, 20 May 87 18:08:28 PDT
Received: by ibuki.UUCP (1.4/4.7)	id AA3211335; Wed, 20 May 87 17:19:21 pdt
Original-Date: Wed, 20 May 87 17:19:21 pdt
Message-Id: <8705210019.AA3211335@ibuki.UUCP>
GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV

    Date: Wed, 20 May 87 13:57:56 -0700
    From: labrea!peck@Sun.COM

     In the form: (push (ref1) (car (ref2)))
    It is unclear whether (ref1) should be evaluated before (ref2). 
    ....

    Lucid and Franz evaluate (ref2) then (ref1)
    Symbolics evaluate (ref1) then (ref2)

KCL falls in the former group:

(macroexpand '(push (ref1) (car (ref2))))   =>

(LET* ((#:G7 (REF2)) (#:G8 (CONS (REF1) (CAR #:G7))))
  (PROGN (RPLACA #:G7 #:G8) #:G8))


*start*
02598 00024 USf
Originator: @SAIL.STANFORD.EDU:peck%Sun:COM:Xerox
Date: 20 May 87 14:44
Subject: Order of evaluation in PUSH (& PUSHNEW)
From: peck%Sun:COM:Xerox
To: common-lisp%sail.stanford:EDU:Xerox

Return-Path: <@SAIL.STANFORD.EDU:peck@Sun.COM>
Redistributed: Xerox-Common-Lisp^.x
Received: from SAIL.STANFORD.EDU by Xerox.COM ; 20 MAY 87 14:44:54 PDT
Received: from SUN.COM by SAIL.STANFORD.EDU with TCP; 20 May 87  13:59:28 PDT
Received: from snail.sun.com by Sun.COM (4.0/SMI-3.2)	id AA03347; Wed, 20 May 87 13:55:56 PDT
Received: from denali.sun.com by snail.sun.com (3.2/SMI-3.2)	id AA05880; Wed, 20 May 87 13:55:28 PDT
Received: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA29640; Wed, 20 May 87 13:58:00 PDT
Message-Id: <8705202058.AA29640@denali.sun.com>
Original-Date: Wed, 20 May 87 13:57:56 -0700

 In the form: (push (ref1) (car (ref2)))
It is unclear whether (ref1) should be evaluated before (ref2). 

CLtL, page 270 states:
" The *effect* of (PUSH Item Place) is *roughly* equivalent to
(SETF Place (CONS Item Place))
except that the latter would evaluate any subforms of Place twice
while PUSH takes care to evaluate them only once."

CLtL, in discussion of generalized variable accessors/modifiers,
page 99 states:
"Macros that manipulate generalized variables must guarentee the "obvious"
semantics: subforms of generalized-variable references are evaluated ...
in exactly the same order as they appear in the *source* program."

	[Is this the *definition* of "obvious" semantics...?]

PUSH is in the class of "Macros that manipulate generalized variables".
However, even though the *generalized-variable references*
are evaluated with the "obvious" semantics, should standard macros
necessarily evaluate *all* their arguments in the "obvious" order?

The problem is that PUSH is [almost] specified as a macro which expands 
 to something in which its args are not in the "obvious" source order.

Shall we just agree that PUSH does not follow the "obvious" semantics?

Lucic and Franz evaluate (ref2) then (ref1)
Symbolics evaluate (ref1) then (ref2)

Lucid:
> (macroexpand '(push (ref1) (car (ref2))))
((LAMBDA (#:G2) 
  ((LAMBDA (#:G1) (SET-CAR #:G2 #:G1)) 
   (CONS (REF1) (CAR #:G2)))) 
  (REF2))
T

ExCL:
<cl> (macroexpand '(push (ref1) (car (ref2))))
(LET* ((#:G8 (REF2))
       (#:G7 (CONS (REF1) (CAR #:G8))))
  (EXCL::.INV-CAR #:G8 #:G7)) 
T 

Symbolics:
Command: (macroexpand '(push (ref1) (car (ref2))))
(LET* ((#:G5 (REF1))
       (#:G4 (REF2)))
  NIL
  (SYS:RPLACA2 #:G4 (VALUES (CONS #:G5 (CAR #:G4)))))
T


Definitely one for the CL comittee.


*start*
06335 00024 USf
Return-Path: <@SAIL.Stanford.EDU:peck@Sun.COM>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU by Xerox.COM ; 16 OCT 87 01:12:50 PDT
Received: from SUN.COM by SAIL.STANFORD.EDU with TCP; 16 Oct 87  01:07:25 PDT
Received: from snail.sun.com by Sun.COM (4.0/SMI-3.2)
	id AA01645; Fri, 16 Oct 87 01:02:58 PDT
Received: from denali.sun.com by snail.sun.com (4.0/SMI-3.2)
	id AA21892; Fri, 16 Oct 87 01:06:59 PDT
Received: from localhost by denali.sun.com (3.2/SMI-3.2)
	id AA04926; Fri, 16 Oct 87 01:07:15 PDT
Message-Id: <8710160807.AA04926@denali.sun.com>
To: cl-cleanup@Sail.stanford.edu
Subject: Re: Issue: PUSH-EVALUATION-ORDER 
In-Reply-To: Your message of 09 Oct 87 13:47:00 -0700;
	<871009-134727-1519@Xerox> .
Date: Fri, 16 Oct 87 01:07:11 -0700
From: peck@Sun.COM

Issue: PUSH-EVALUATION-ORDER
References: CLtL pages 99 vs 270
Category: CLARIFICATION
Edit History: Jeff Peck, 15-Oct-1987, (version 1)
Problem Description:
    In the form: (PUSH (ref1) (CAR (ref2)))
It is unclear whether (ref1) should be evaluated before (ref2). 

CLtL, page 99, in a discussion of generalized variable macros, states:
 "Other macros that manipulate generalized variables include ... PUSH 
	...
  Macros that manipulate generalized variables must guarentee the "obvious"
  semantics: subforms of generalized-variable references are evaluated ...
  in exactly the same order as they appear in the *source* program."

[That is, the sub-forms of Place should be evaluated once, left to right.]

  "The expansion of these macros must consist of code that follows these
  rules or has the same effect as such code.  This is accomplished by
  introducing temporary variables bound to the subforms of the reference."
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^

This paragraph and a discussion of SETF on the previous pages may also be
 interpreted as requiring that *all* argument forms of such macros should
 be evaluated once, in source order, left to right.


However, CLtL, page 270 states:
 "The effect of (PUSH Item Place) is roughly equivalent to
    (SETF Place (CONS Item Place))
  except that the latter would evaluate any subforms of Place twice
  while PUSH takes care to evaluate them only once."

   That is, the effect of the form (PUSH Item Place) is to evaluate 
(SETF Place (CONS Item Place)) but with subforms of Place only evaluated once.

    Place and Item appear in different order in the PUSH form and the
indicated equivalent SETF form.  Should the PUSH form have primacy over the
obvious SETF form with respect to the left-to-right evaluation?

  Are all subforms in a macro argument list guarenteed to be evaluated in
order, or only those subforms representing generalized variable references?



Test Case:
    (macroexpand '(push (ref1) (car (ref2))))

    (LET* ((#:G8 (REF2))
	   (#:G7 (CONS (REF1) (CAR #:G8))))
      (EXCL::.INV-CAR #:G8 #:G7)) 
    
	    ---versus---
    
    (LET* ((#:G5 (REF1))
	   (#:G4 (REF2)))
      NIL
      (SYS:RPLACA2 #:G4 (VALUES (CONS #:G5 (CAR #:G4)))))



Proposal: PUSH-EVALUATION-ORDER:REDEFINE-PUSH
    The form of PUSH is (PUSH Place Item).
Rationale:
    PUSH is basically defined in the wrong order with respect to the obvious
implementation.  Other generalized variable access functions are defined
with the Place form preceding the Value form.  Accept for the natural visual
clue that PUSH should attach Item "in front" of Place, it would be more
natural to write (PUSH Place Item) and be parallel to SETF forms.
Discusion:
   Never mind, this would break reams of existing code...


Proposal: PUSH-EVALUATION-ORDER:PLACE-FIRST
    Page 270 should be modified to read:
 "(PUSH Item Place) is equivalent to (SETF Place (CONS Item Place))
  except that the subforms of Place are evaluated only once."
	and
 "(PUSHNEW Item Place :test P) is equivalent to
  (SETF Place (ADJOIN Item Place :test P)) except that the subforms of 
  Place are evaluated only once."

Rationale:
   The wording of CLtL on page 99 does not disallow or contradict this
interpretation.  The wording of page 270 is already very close to this.



Proposal: PUSH-EVALUATION-ORDER:ITEM-FIRST
    Page 270 should be modified to read:
 "(PUSH Item Place) is generally equivalent to (SETF Place (CONS Item Place))
  except that the subforms of Place are evaluated only once, and Item
  is evaluated before Place."
	and
 "(PUSHNEW Item Place :test P) is generally equivalent to
  (SETF Place (ADJOIN Item Place :test P)) except that the subforms of 
  Place are evaluated only once, and Item is evaluated before Place."

    Page 99 should be modified to explain explicitly that *all* argument
forms of *any* macro that ever uses generalized variable references, *must*
evaluate in left to right order as appearing in the source.

    Specifically, the phase "subforms of the reference" which appears
several times should be changed to something like:
 "subforms of the [generalized-variable manipulating macro] arguments".

    Perhaps PUSH should be used as an example instead of the over worked SETF.

Rational:
    This is the unstated intention of the page 97-100 discussion of 
generalized-variable referencing macros, and indeed the intended definition
of "obvious semantics" for all macros.



Current-practice:
    PLACE-FIRST:  Lucid, Franz and Kyoto evaluate Place then Item.
    ITEM-FIRST:   Symbolics evaluates Item then Place.

Adoption Cost:
    Minimal, PUSH could simply be defined by the appropriate macro.

Cost of non-adoption:
    Obvious programs may be non-portable. Although it should be rare that
order of evaluation will effect actual operation.  Occasional programs may
get different results on Symbolics.

Benefits:
    The implementation and semantics of PUSH become obvious to all.
With ITEM-FIRST, it is obvious when macros wrapped around PUSH will
evaluate their arguments in the proper order, no exceptions need to be made.

Esthetics:
    Most folks won't notice.  For true esthetics, see REDEFINE-PUSH.


Discussion:
    David Moon (Symbolics) argues that the unstated intention of page 99
is the definition of the language, while admitting that:
  "The quoted paragraphs could be taken to restrict order of evaluation only
   of the subforms of (CAR (ref2)), not all of the subforms of the PUSH form."

*start*
01750 00024 US 
Return-Path: <@SAIL.Stanford.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU by Xerox.COM ; 16 OCT 87 09:41:26 PDT
Received: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 16 Oct 87  09:35:56 PDT
Received: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 257095; Fri 16-Oct-87 12:35:53 EDT
Date: Fri, 16 Oct 87 12:35 EDT
From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>
Subject: Re: Issue: PUSH-EVALUATION-ORDER 
To: peck@Sun.COM
cc: cl-cleanup@Sail.stanford.edu
In-Reply-To: <8710160807.AA04926@denali.sun.com>
Message-ID: <19871016163545.4.MOON@EUPHRATES.SCRC.Symbolics.COM>

    Date: Fri, 16 Oct 87 01:07:11 -0700
    From: peck@Sun.COM

I favor PUSH-EVALUATION-ORDER:ITEM-FIRST.  I've always believed that
on page 99 of CLtL, "subforms of generalized-variable references" is
a typographical error for "subforms of macros that manipulate generalized
variable references."  I only wish this typo had been caught before
the book was published.   Note the paragraph a little further down the
page "As an example of these semantic rules, in the generalized-variable
reference (setf reference value), the value form must be evaluated after
all the subforms of the reference because the value form appears to the
right of them."  In this single sentence, the term "generalized-variable
reference" is used both to mean a setf-able place and a form that invokes
setf.  Confusing, isn't it?  However, I don't see how this paragraph
can be interpreted any other way than that these rules govern the order
of evaluation of all the subforms of one of these macros, not just the
subforms inside "place".

*start*
05834 00024 USf
Date: 23 Oct 87 10:32 PDT
From: Masinter.pa
To: cl-cleanup@Sail.stanford.edu
Subject: Issue: PUSH-EVALUATION-ORDER (Version 2) 
to: cl-cleanup@Sail.stanford.edu, peck@Sun.COM
cc: Masinter
line-fold: 80

I rewrote this proposal extensively; I removed all but the :ITEM-FIRST proposal, extended it to include INCF, DECF, PUSHNEW, and macros which are created with DEFINE-MODIFY-MACRO, and tried to write it as changes to the language rather than changes to CLtL, etc. 

Is this ready for release? Moon was the only one who responded.



Issue:         PUSH-EVALUATION-ORDER
References:    CLtL p. 99 (generalized variables), p 270 (PUSH)
               p. 201 (INCF, DECF).
Category:      	CLARIFICATION
Edit History:  Jeff Peck, 15-Oct-1987, version 1.
               Larry Masinter, 23-Oct-87, version 2.

Problem Description:

In the form: (PUSH (ref1) (CAR (ref2)))
It is unclear whether (ref1) should be evaluated before (ref2). 

CLtL, page 99, in a discussion of generalized variable macros, states:
"Other macros that manipulate generalized variables include ... PUSH....
 Macros that manipulate generalized variables must guarentee the "obvious"
 semantics: subforms of generalized-variable references are evaluated ...
 in exactly the same order as they appear in the *source* program."

That is, the sub-forms of Place should be evaluated once, left to right.

"The expansion of these macros must consist of code that follows these
 rules or has the same effect as such code.  This is accomplished by
 introducing temporary variables bound to the subforms of the reference."
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^

This paragraph and a discussion of SETF on the previous pages may also be
interpreted as requiring that *all* argument forms of such macros should
be evaluated once, in source order, left to right.


However, CLtL, page 270 states:
 "The effect of (PUSH Item Place) is roughly equivalent to
    (SETF Place (CONS Item Place))
  except that the latter would evaluate any subforms of Place twice
  while PUSH takes care to evaluate them only once."

That is, the effect of the form (PUSH Item Place) is to evaluate 
(SETF Place (CONS Item Place)) but with subforms of Place only evaluated once.

Place and Item appear in different order in the PUSH form and the
indicated equivalent SETF form.  Should the PUSH form have primacy over the
obvious SETF form with respect to the left-to-right evaluation?

Are all subforms in a macro argument list guarenteed to be evaluated in
order, or only those subforms representing generalized variable references?

The same question arises for other forms which manipulate generalized variables, e.g., PUSHNEW, INCF, DECF, and those defined with DEFINE-MODIFY-MACRO.


Test Case:

(LET ((REF2 (LIST '())))
 (PUSH (PROGN (PRINC "1") 'REF-1)
       (CAR (PROGN (PRINC "2") REF2))))

If the subforms evaluate in left-to-right order, this will print 12 rather than 21.

Proposal: PUSH-EVALUATION-ORDER:ITEM-FIRST

Explicitly state that for the macros that manipulate generalized variables (PUSH, PUSHNEW, INCF, DECF, SHIFTF, ROTATEF, PSETF, SETF and those defined with DEFINE-MODIFY-MACRO) the subforms of the macro (including but not limited to those of the generalized variable reference) are evaluated exactly as many times as they appear in the source program, and in exactly the same order as they appear in the source program.

For example, PUSH is expected to behave as if described as:

(PUSH Item Place) is generally equivalent to (SETF Place (CONS Item Place))
  except that the subforms of Place are evaluated only once, and Item
  is evaluated before Place."

The phase "subforms of the reference" which appears several times in CLtL should be made more specific to be "subforms of the [generalized-variable manipulating macro] arguments".

Rationale:

This is the unstated intention of the page 97-100 discussion of  generalized-variable referencing macros, and indeed the intended definition of "obvious semantics" for all macros.

Current practice:

Many implementations do not currently follow this evaluation order. In the form (PUSH Item Place), Lucid, Franz, Kyoto and Xerox evaluate Place then Item. Symbolics evaluates Item then Place.


For example, in Franz:

(macroexpand '(push (ref1) (car (ref2))))

    (LET* ((#:G8 (REF2))
	   (#:G7 (CONS (REF1) (CAR #:G8))))
      (EXCL::.INV-CAR #:G8 #:G7)) 
    
In Symbolics Common Lisp, it returns:
    
    (LET* ((#:G5 (REF1))
	   (#:G4 (REF2)))
      NIL
      (SYS:RPLACA2 #:G4 (VALUES (CONS #:G5 (CAR #:G4)))))


Adoption Cost:

Minimal, PUSH could simply be defined by the appropriate macro.

Cost of non-adoption:

Obvious programs may be non-portable, although it should be rare that order of evaluation will effect actual operation. 

Benefits:

The implementation and semantics of PUSH become obvious to all.  

Esthetics:

Common Lisp defines order of evaluation as left-to-right; this clarification ensures consistency across the language. 


Discussion:

David Moon (Symbolics) argues that the unstated intention of page 99
is the definition of the language, while admitting that:

"The quoted paragraphs could be taken to restrict order of evaluation only
   of the subforms of (CAR (ref2)), not all of the subforms of the PUSH form."

No performance impact is expected; while some macro expansions may appear to be more verbose, most compilers deal reasonably with the required order of evaluation.
        TITAN          TITAN           
TIMESROMAN 
                                      Y       
                     Y             Ž              ¹       *      I              ¶             	              B              {       
       D              z             ¿      _ zº*start*
00857 00024 US 
Return-Path: <dcm%hpfclp@hplabs.HP.COM>
Received: from hplabs.HP.COM ([15.255.16.7]) by Xerox.COM ; 23 OCT 87 12:00:51 PDT
Received: from hpfcla.HP.COM (hpfcla) by hplabs.HP.COM with SMTP ; Fri, 23 Oct 87 11:59:33 PDT
Received: from hpfclp.HP.COM by hpfcla.HP.COM; Fri, 23 Oct 87 12:56:39 mdt
Received: from hpfcdcm.HP.COM by hpfclp.HP.COM; Fri, 23 Oct 87 12:56:16 mdt
Received: from hpfcdcm by hpfcdcm.HP.COM; Fri, 23 Oct 87 12:55:20 mdt
Return-Path: <dcm@hpfcdcm>
To: Masinter.pa
Subject: Re: Issue: PUSH-EVALUATION-ORDER (Version 2) 
X-Mailer: mh6.5
In-Reply-To: Your message of 23 Oct 87 10:32:00 -0700.
             <871023-103240-6617@Xerox> 
Date: Fri, 23 Oct 87 12:55:13 MST
Message-Id: <1306.562013713@hpfcdcm>
From: Dave Matthews <dcm%hpfclp@hplabs.HP.COM>



I agree with PUSH-EVALUATION-ORDER:ITEM-FIRST.

Dave Matthews

*start*
05887 00024 US 
Date: 23 Oct 87 13:21 PDT
From: Masinter.pa
to: masinter
Subject: Edited Issue: PUSH-EVALUATION-ORDER (Version 3) 


Subject: Issue: PUSH-EVALUATION-ORDER (Version 3) 
to: cl-cleanup@Sail.stanford.edu, peck@Sun.COM
cc: Masinter
line-fold: 80

(This only differs from the previous message primarily in the change to line-folding).

I rewrote this proposal extensively; I removed all but the :ITEM-FIRST proposal, extended it to include INCF, DECF, PUSHNEW, and macros which are created with DEFINE-MODIFY-MACRO, and tried to write it as changes to the language rather than changes to CLtL, etc. 

Is this ready for release? Moon was the only one who responded.



Issue:         PUSH-EVALUATION-ORDER
References:    CLtL p. 99 (generalized variables), p 270 (PUSH)
               p. 201 (INCF, DECF).
Category:      	CLARIFICATION
Edit History:  Jeff Peck, 15-Oct-1987, version 1.
               Larry Masinter, 23-Oct-87, version 2.

Problem Description:

In the form: (PUSH (ref1) (CAR (ref2))), it is unclear whether (ref1) should be evaluated before (ref2). 

CLtL, page 99, in a discussion of generalized variable macros, states:
"Macros that manipulate generalized variables must guarentee the "obvious"  semantics: subforms of generalized-variable references are evaluated ...  in exactly the same order as they appear in the *source* program."

That is, the sub-forms of Place should be evaluated once, left to right.

"The expansion of these macros must consist of code that follows these rules or has the same effect as such code.  This is accomplished by introducing temporary variables bound to the **subforms of the reference.**"

This paragraph and a discussion of SETF on the previous pages may also be interpreted as requiring that *all* argument forms of such macros should be evaluated once, in source order, left to right.


However, CLtL, page 270 states:
"The effect of (PUSH Item Place) is roughly equivalent to
    (SETF Place (CONS Item Place))
except that the latter would evaluate any subforms of Place twice while PUSH takes care to evaluate them only once."

That is, the effect of the form (PUSH Item Place) is to evaluate

(SETF Place (CONS Item Place))

but with subforms of Place only evaluated once.

Place and Item appear in different order in the PUSH form and the indicated equivalent SETF form.  Should the PUSH form have primacy over the obvious SETF form with respect to the left-to-right evaluation?  Are all subforms in a macro argument list guarenteed to be evaluated in order, or only those subforms representing generalized variable references?

The same questions arise for other forms which manipulate generalized variables, e.g., PUSHNEW, INCF, DECF, and those defined with DEFINE-MODIFY-MACRO.


Test Case:

(LET ((REF2 (LIST '())))
 (PUSH (PROGN (PRINC "1") 'REF-1)
       (CAR (PROGN (PRINC "2") REF2))))

If the subforms evaluate in left-to-right order, this will print 12 rather than 21.

Proposal: PUSH-EVALUATION-ORDER:ITEM-FIRST

Explicitly state that for the macros that manipulate generalized variables (PUSH, PUSHNEW, INCF, DECF, SHIFTF, ROTATEF, PSETF, SETF and those defined with DEFINE-MODIFY-MACRO) the subforms of the macro (including but not limited to those of the generalized variable reference) are evaluated exactly as many times as they appear in the source program, and in exactly the same order as they appear in the source program.

For example, PUSH is expected to behave as if described as:

(PUSH Item Place)

is generally equivalent to

(SETF Place (CONS Item Place))

except that the subforms of Place are evaluated only once, and Item is evaluated before Place.

The phase "subforms of the reference" which appears several times in CLtL should be made more specific to be "subforms of the [generalized-variable manipulating macro] arguments".

Rationale:

This is the unstated intention of the page 97-100 discussion of  generalized-variable referencing macros, and indeed the intended definition of "obvious semantics" for all macros.

Current practice:

Many implementations do not currently follow this evaluation order. In the form (PUSH Item Place), Lucid, Franz, Kyoto and Xerox evaluate Place then Item. Symbolics evaluates Item then Place.


For example, in Franz:

(macroexpand '(push (ref1) (car (ref2))))

    (LET* ((#:G8 (REF2))
	   (#:G7 (CONS (REF1) (CAR #:G8))))
      (EXCL::.INV-CAR #:G8 #:G7)) 
    
In Symbolics Common Lisp, it returns:
    
    (LET* ((#:G5 (REF1))
	   (#:G4 (REF2)))
      NIL
      (SYS:RPLACA2 #:G4 (VALUES (CONS #:G5 (CAR #:G4)))))


Adoption Cost:

Minimal, PUSH could simply be defined by the appropriate macro.

Cost of non-adoption:

Obvious programs may be non-portable, although it should be rare that order of evaluation will effect actual operation. 

Benefits:

The implementation and semantics of PUSH become obvious to all.  

Esthetics:

Common Lisp defines order of evaluation as left-to-right; this clarification ensures consistency across the language. 


Discussion:

David Moon (Symbolics) argues that the unstated intention of page 99
is the definition of the language, while admitting that:

"The quoted paragraphs could be taken to restrict order of evaluation only
   of the subforms of (CAR (ref2)), not all of the subforms of the PUSH form."

No performance impact is expected; while some macro expansions may appear to be more verbose, most compilers deal reasonably with the required order of evaluation.

     ----- End Forwarded Messages -----
        TITAN           TITAN          
TIMESROMAN 
          
TIMESROMAN 
          ˜                            Y       
                     Y             û              ¹       *      G              ¶             	              B              {       
       D              z             ¿       )      s zº*start*
01248 00024 US 
Return-Path: <peck@Sun.COM>
Received: from Sun.COM by Xerox.COM ; 23 OCT 87 13:58:14 PDT
Received: from snail.sun.com ([192.9.0.3]) by Sun.COM (4.0/SMI-3.2)
	id AA02008; Fri, 23 Oct 87 13:52:25 PDT
Received: from denali.sun.com by snail.sun.com (4.0/SMI-3.2)
	id AB17065; Fri, 23 Oct 87 13:56:01 PDT
Received: from localhost by denali.sun.com (3.2/SMI-3.2)
	id AA01682; Fri, 23 Oct 87 13:56:42 PDT
Message-Id: <8710232056.AA01682@denali.sun.com>
To: Masinter.pa
Subject: Re: Issue: PUSH-EVALUATION-ORDER (Version 2) 
In-Reply-To: Your message of 23 Oct 87 10:32:00 -0700;
	<871023-103240-6617@Xerox> .
Date: Fri, 23 Oct 87 13:56:40 -0700
From: peck@Sun.COM

I noticed that i had botched the (re) wording of this, no big deal,
presumably any editor who actually rewrites CLtL or the spec will
fix it to be meaninful.

currently:
>> The phase "subforms of the reference" which appears several times in
>> CLtL should be made more specific to be "subforms of the
>> [generalized-variable manipulating macro] arguments".


what might make sense:
>> The phase "subforms of the reference" which appears several times in
>> CLtL should be made more specific to be "arguments of the
>> [generalized-variable manipulating] macro".


*start*
01039 00024 US 
Return-Path: <@SAIL.Stanford.EDU:Masinter.pa@Xerox.COM>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU by Xerox.COM ; 23 OCT 87 17:02:59 PDT
Received: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 23 Oct 87  17:00:34 PDT
Received: from Cabernet.ms by ArpaGateway.ms ; 23 OCT 87 17:01:17 PDT
Date: 23 Oct 87 17:01 PDT
From: Masinter.pa
Subject: Re: Issue: PUSH-EVALUATION-ORDER (Version 2) 
In-reply-to: peck@Sun.COM's message of Fri, 23 Oct 87 13:56:40 -0700
To: peck@Sun.COM
cc: CL-CLEANUP@SAIL.STANFORD.EDU
Message-ID: <871023-170117-1668@Xerox>

Version 3 will change

 >> The phase "subforms of the reference" which appears several times in
>> CLtL should be made more specific to be "subforms of the
>> [generalized-variable manipulating macro] arguments".


to

>> The phase "subforms of the reference" which appears several times in
>> CLtL should be made more specific to be "arguments of the
>> [generalized-variable manipulating] macro".


We like to get it right in the proposals.

*start*
00967 00024 US 
Return-Path: <FAHLMAN@C.CS.CMU.EDU>
Received: from C.CS.CMU.EDU by Xerox.COM ; 25 OCT 87 16:59:56 PST
Received: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 25 Oct 87 19:59:38-EST
Date: Sun, 25 Oct 87 19:59 EST
Message-ID: <FAHLMAN.12345420385.BABYL@C.CS.CMU.EDU>
Sender: FAHLMAN@C.CS.CMU.EDU
From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>
To: Masinter.pa
Subject: Issue: PUSH-EVALUATION-ORDER (Version 2) 
In-reply-to: Msg of 23 Oct 1987  20:01-EDT from Masinter.pa at Xerox.COM


    Version 3 will change ... to

    >> The phase "subforms of the reference" which appears several times in
    >> CLtL should be made more specific to be "arguments of the
    >> [generalized-variable manipulating] macro".

    We like to get it right in the proposals.

In that case, maybe "phase" should become "phrase".  I always thought
that macro calls had subforms rather than arguments, but whatever is OK
with the formalists in the group is OK with me.

-- Scott
*start*
02170 00024 US 
Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>
Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 08 NOV 87 12:06:25 PST
Received: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 274781; Sun 8-Nov-87 15:06:19 EST
Date: Sun, 8 Nov 87 15:06 EST
From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>
Subject: Re: Issue: PUSH-EVALUATION-ORDER (Version 2) 
To: Masinter.pa
cc: peck@Sun.COM, CL-CLEANUP@SAIL.STANFORD.EDU
In-Reply-To: <871023-170117-1668@Xerox>
Message-ID: <19871108200633.4.MOON@EUPHRATES.SCRC.Symbolics.COM>
Line-fold: No

    Date: 23 Oct 87 17:01 PDT
    From: Masinter.pa@Xerox.COM

    Version 3 will change

     >> The phase "subforms of the reference" which appears several times in
    >> CLtL should be made more specific to be "subforms of the
    >> [generalized-variable manipulating macro] arguments".

    to

    >> The phase "subforms of the reference" which appears several times in
    >> CLtL should be made more specific to be "arguments of the
    >> [generalized-variable manipulating] macro".

    We like to get it right in the proposals.

Still not right, I think.  The term "arguments" is not in the index of
CLtL, but my reading of pp.57-9 is that the term "argument" refers to the
-result- of evaluating a subform of a function call, and the phrase
"arguments of a macro" is an oxymoron.  CLtL 57 defines "macro call,"
so I think the phrase you are looking for above is:

  "subforms of the macro call" (on p.99, context implies that 
  generalized-variable manipulating macros are referred to, in
  some other places it might be necessary to say so explicitly.
  Really we should provide a complete list of them.)

I don't see any definition of the word "subform" in CLtL either, although
it's used here and there.  It means a form (that is, something whose
syntactic use is such that it will be evaluated) that is nested inside
another form.  It does not mean any object nested inside a form regardless
of syntactic context.  The distinction is only a distinction because of
special forms and macros, of course.

*start*
02260 00024 US 
Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 12:08:08 PST
Received: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 8 Nov 87  12:06:52 PST
Received: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 274781; Sun 8-Nov-87 15:06:19 EST
Date: Sun, 8 Nov 87 15:06 EST
From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>
Subject: Re: Issue: PUSH-EVALUATION-ORDER (Version 2) 
To: Masinter.pa
cc: peck@Sun.COM, CL-CLEANUP@SAIL.STANFORD.EDU
In-Reply-To: <871023-170117-1668@Xerox>
Message-ID: <19871108200633.4.MOON@EUPHRATES.SCRC.Symbolics.COM>
Line-fold: No

    Date: 23 Oct 87 17:01 PDT
    From: Masinter.pa@Xerox.COM

    Version 3 will change

     >> The phase "subforms of the reference" which appears several times in
    >> CLtL should be made more specific to be "subforms of the
    >> [generalized-variable manipulating macro] arguments".

    to

    >> The phase "subforms of the reference" which appears several times in
    >> CLtL should be made more specific to be "arguments of the
    >> [generalized-variable manipulating] macro".

    We like to get it right in the proposals.

Still not right, I think.  The term "arguments" is not in the index of
CLtL, but my reading of pp.57-9 is that the term "argument" refers to the
-result- of evaluating a subform of a function call, and the phrase
"arguments of a macro" is an oxymoron.  CLtL 57 defines "macro call,"
so I think the phrase you are looking for above is:

  "subforms of the macro call" (on p.99, context implies that 
  generalized-variable manipulating macros are referred to, in
  some other places it might be necessary to say so explicitly.
  Really we should provide a complete list of them.)

I don't see any definition of the word "subform" in CLtL either, although
it's used here and there.  It means a form (that is, something whose
syntactic use is such that it will be evaluated) that is nested inside
another form.  It does not mean any object nested inside a form regardless
of syntactic context.  The distinction is only a distinction because of
special forms and macros, of course.

*start*
03426 00024 US 
Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 12:21:56 PST
Received: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 8 Nov 87  12:19:58 PST
Received: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 274789; Sun 8-Nov-87 15:19:44 EST
Date: Sun, 8 Nov 87 15:20 EST
From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>
Subject: Issue: PUSH-EVALUATION-ORDER (Version 2) 
To: cl-cleanup@SAIL.STANFORD.EDU, peck@Sun.COM
In-Reply-To: <871023-103240-6617@Xerox>
Message-ID: <19871108202000.5.MOON@EUPHRATES.SCRC.Symbolics.COM>

This is fine with me except for a couple of minor corrections noted
below.

    Date: 23 Oct 87 10:32 PDT
    From: Masinter.pa@Xerox.COM

    I removed all but the :ITEM-FIRST
    proposal, extended it to include INCF, DECF, PUSHNEW, and macros which
    are created with DEFINE-MODIFY-MACRO

You forgot to add these to the References field, although they are
mentioned in the text in a couple of places.  It would probably be
better to list everything that's going to be affected in the References
field, so no one gets confused.

    Proposal: PUSH-EVALUATION-ORDER:ITEM-FIRST

    Explicitly state that for the macros that manipulate generalized
    variables (PUSH, PUSHNEW, INCF, DECF, SHIFTF, ROTATEF, PSETF, SETF and
    those defined with DEFINE-MODIFY-MACRO) the subforms of the macro

"of the macro call", to be strictly accurate.

    (including but not limited to those of the generalized variable
    reference) are evaluated exactly as many times as they appear in the
    source program, and in exactly the same order as they appear in the
    source program.

Good.

    For example, PUSH is expected to behave as if described as:

    (PUSH Item Place) is generally equivalent to (SETF Place (CONS Item
    Place))
      except that the subforms of Place are evaluated only once, and Item
      is evaluated before Place."

I wonder why "roughly" changed to "generally".

    The phase "subforms of the reference" which appears several times in
    CLtL should be made more specific to be "subforms of the
    [generalized-variable manipulating macro] arguments".

"subforms of the macro call".  Also "subforms" doesn't seem to be
officially defined anywhere, we need to be clear on this (see the
message I sent earlier today, same subject).

    Cost of non-adoption:

    Obvious programs may be non-portable, although it should be rare that
    order of evaluation will effect actual operation. 

"affect", unless you're making a very subtle joke here.

    Discussion:

    David Moon (Symbolics) argues that the unstated intention of page 99
    is the definition of the language, while admitting that:

    "The quoted paragraphs could be taken to restrict order of evaluation
    only
       of the subforms of (CAR (ref2)), not all of the subforms of the PUSH
    form."

I think you ought to put back the other part of my comment, since in
removing it my argument is eviscerated.  The paragraph on p.99 two
paragraphs after the one referenced makes it clear, at least to me,
that "subforms of generalized-variable references" was a typo, since
it discusses order of things that aren't such subforms.

I'll send out a proposed revision of the discussion in a second message,
in just a moment.

*start*
07169 00024 USf
Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 12:43:42 PST
Received: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 8 Nov 87  12:41:48 PST
Received: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 274799; Sun 8-Nov-87 15:41:36 EST
Date: Sun, 8 Nov 87 15:41 EST
From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>
Subject: Issue: PUSH-EVALUATION-ORDER (Version 3)
To: cl-cleanup@SAIL.STANFORD.EDU, peck@Sun.COM
In-Reply-To: <871023-103240-6617@Xerox>
Message-ID: <19871108204151.6.MOON@EUPHRATES.SCRC.Symbolics.COM>

I propose this revision of the discussion of this issue, with
minor corrections according to comments sent in my previous two
messages this afternoon commenting on version 2 of the proposal.

Issue:         PUSH-EVALUATION-ORDER
References:    CLtL p. 99 (generalized variables)
               p. 270 (PUSH)
               All macros that manipulate generalized variables
               (SETF, PSETF, GETF, REMF, INCF, DECF, PUSH, PUSHNEW,
               POP, CHECK-TYPE, ASSERT, CTYPECASE, CCASE, SHIFTF,
               ROTATEF, and all macros defined by DEFINE-MODIFY-MACRO).
Category:      CLARIFICATION
Edit History:  Jeff Peck, 15-Oct-1987, version 1.
               Larry Masinter, 23-Oct-87, version 2.
               David Moon, 8-Nov-87, version 3.

Problem Description:

In the form: (PUSH (ref1) (CAR (ref2)))
It is unclear whether (ref1) should be evaluated before (ref2). 

CLtL, page 99, in a discussion of generalized variable macros, states:
"Other macros that manipulate generalized variables include ... PUSH....
 Macros that manipulate generalized variables must guarantee the
 `obvious' semantics: subforms of generalized-variable references
 are evaluated ... in exactly the same order as they appear in
 the *source* program."

That is, the sub-forms of Place should be evaluated once, left to right.

"The expansion of these macros must consist of code that follows these
 rules or has the same effect as such code.  This is accomplished by
 introducing temporary variables bound to the subforms of the
 reference."

This paragraph and a discussion of SETF on the previous pages may also
be interpreted as requiring that *all* subforms of such macro calls
should be evaluated once, in source order, left to right.

However, CLtL, page 270 states:
 "The effect of (PUSH Item Place) is roughly equivalent to
    (SETF Place (CONS Item Place))
  except that the latter would evaluate any subforms of Place twice
  while PUSH takes care to evaluate them only once."

That is, the effect of the form (PUSH Item Place) is to evaluate 
(SETF Place (CONS Item Place)) but with subforms of Place only evaluated
once.

Place and Item appear in different order in the PUSH form and the
indicated equivalent SETF form.  Should the PUSH form have primacy over
the obvious SETF form with respect to the left-to-right evaluation?

Are all subforms in a macro call guaranteed to be evaluated in order, or
only those subforms representing generalized variable references?

The same question arises for other forms which manipulate generalized
variables, e.g., PUSHNEW, INCF, DECF, and those defined with
DEFINE-MODIFY-MACRO.


Test Case:

(LET ((REF2 (LIST '())))
 (PUSH (PROGN (PRINC "1") 'REF-1)
       (CAR (PROGN (PRINC "2") REF2))))

If the subforms evaluate in left-to-right order, this will print 12
rather than 21.

Proposal: PUSH-EVALUATION-ORDER:ITEM-FIRST

Explicitly state that for the macros that manipulate generalized
variables (PUSH, PUSHNEW, GETF, REMF, INCF, DECF, SHIFTF, ROTATEF,
PSETF, SETF, POP, and those defined with DEFINE-MODIFY-MACRO) the
subforms of the macro call (including but not limited to subforms of the
generalized variable reference) are evaluated exactly as many times as
they appear in the source program, and in exactly the same order as they
appear in the source program.  Explicitly state that for the macros
CHECK-TYPE, ASSERT, CTYPECASE, and CCASE, that rule is followed except
where CLtL specifies to the contrary.

In this context, "subform" means a form (that is, something whose
syntactic use is such that it will be evaluated) that is nested inside
another form.  It does not mean any object nested inside a form
regardless of syntactic context.

For example, PUSH is expected to behave as if described as:

 (PUSH Item Place) is roughly equivalent to
 (SETF Place (CONS Item Place)) except that the subforms of Place
 are evaluated only once, and Item is evaluated before Place."

The phase "subforms of the reference" which appears several times in
CLtL should be made more specific to be "subforms of the macro call,"
referring to the entire form that calls the generalized-variable
manipulating macro.

Rationale:

This is the unstated intention of the page 97-100 discussion of
generalized-variable referencing macros, and indeed the intended
definition of "obvious semantics" for all macros.

Current practice:

Many implementations do not currently follow this evaluation order. In
the form (PUSH Item Place), Lucid, Franz, Kyoto and Xerox evaluate Place
then Item. Symbolics evaluates Item then Place.


For example, in Franz:

(macroexpand '(push (ref1) (car (ref2))))

    (LET* ((#:G8 (REF2))
           (#:G7 (CONS (REF1) (CAR #:G8))))
      (EXCL::.INV-CAR #:G8 #:G7)) 
    
In Symbolics Common Lisp, it returns:
    
    (LET* ((#:G5 (REF1))
           (#:G4 (REF2)))
      NIL
      (SYS:RPLACA2 #:G4 (VALUES (CONS #:G5 (CAR #:G4)))))


Adoption Cost:

Minimal, PUSH etc. could simply be defined by the appropriate macros.

Cost of non-adoption:

Obvious programs may be non-portable, although it should be rare that
order of evaluation will affect actual operation. 

Benefits:

The implementation and semantics of PUSH become obvious to all.  

Esthetics:

Common Lisp defines order of evaluation as left-to-right; this
clarification ensures consistency across the language. 

Discussion:

David Moon (Symbolics) argues that the unstated intention of page 99
is the definition of the language, while admitting that:

"The quoted paragraphs could be taken to restrict order of evaluation
only of the subforms of (CAR (ref2)), not all of the subforms of the
PUSH form."

However, the second to last paragraph on page 99

  As an example of these semantic rules, in the generalized-variable
  reference (setf reference value), the value form must be evaluated
  after all the subforms of the reference because the value form
  appears to the right of them.

makes it clear, if it is still talking about the same semantic rules,
that in this context the phrase "generalized-variable reference" was
meant to refer to the entire macro call, not just the Place, and that
order of evaluation rules are not limited to subforms of Places.  We
suggest that the next specification of Common Lisp should adopt more
consistent terminology.

No performance impact is expected; while some macro expansions may
appear to be more verbose, most compilers deal reasonably with the
required order of evaluation.

*start*
01464 00024 US 
Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU by Xerox.COM ; 09 NOV 87 16:25:27 PST
Received: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 9 Nov 87  16:22:32 PST
Received: from Cabernet.ms by ArpaGateway.ms ; 09 NOV 87 16:19:32 PST
Date: 9 Nov 87 16:19 PST
From: Masinter.pa
Subject: Re: Issue: PUSH-EVALUATION-ORDER (Version 3)
In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s
 message of Sun, 8 Nov 87 15:41 EST
To: Moon@STONY-BROOK.SCRC.Symbolics.COM
cc: cl-cleanup@SAIL.STANFORD.EDU, peck@Sun.COM
Message-ID: <871109-161932-4273@Xerox>

I'm a little uneasy about "Explicitly state that for the macros
CHECK-TYPE, ASSERT, CTYPECASE, and CCASE, that rule is followed except
where CLtL specifies to the contrary."

I think that we also have to be careful about the following: suppose a
user defines

(defmacro wrong-order (x y) `(get ,y ,x))

If the user writes (push a (wrong-order (frob) (baz)))

are we willing to guarantee that "the subforms of the macro call
(including but not limited to subforms of the generalized variable
reference) are evaluated exactly as many times as they appear in the
source program, and in exactly the same order as they appear in the
source program. "?

Similarly if the user writes an "incorrect" setf-method, e.g.,

(defsetf wrong-order (x y) (z) `(setf (get ,y ,x) ,z))

I wish this weren't so sticky. . . .

*start*
02889 00024 US 
Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU by Xerox.COM ; 12 NOV 87 18:17:18 PST
Received: from SCRC-RIVERSIDE.ARPA by SAIL.STANFORD.EDU with TCP; 12 Nov 87  17:03:59 PST
Received: from EUPHRATES.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 187844; Thu 12-Nov-87 20:03:50 EST
Date: Thu, 12 Nov 87 20:03 EST
From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>
Subject: Re: Issue: PUSH-EVALUATION-ORDER (Version 3)
To: cl-cleanup@SAIL.STANFORD.EDU, peck@Sun.COM
In-Reply-To: <871109-161932-4273@Xerox>
Message-ID: <19871113010337.8.MOON@EUPHRATES.SCRC.Symbolics.COM>

    Date: 9 Nov 87 16:19 PST
    From: Masinter.pa@Xerox.COM

    I'm a little uneasy about "Explicitly state that for the macros
    CHECK-TYPE, ASSERT, CTYPECASE, and CCASE, that rule is followed except
    where CLtL specifies to the contrary."

I was trying to complete the set of references to macros affected by the
proposal, but I agree that this wording is poor.  I'm not sure what to
replace it with, though.

    I think that we also have to be careful about the following: suppose a
    user defines

    (defmacro wrong-order (x y) `(get ,y ,x))

    If the user writes (push a (wrong-order (frob) (baz)))

    are we willing to guarantee that "the subforms of the macro call
    (including but not limited to subforms of the generalized variable
    reference) are evaluated exactly as many times as they appear in the
    source program, and in exactly the same order as they appear in the
    source program. "?

Good point, and note that the same issue arises for
(setf (wrong-order (frob) (baz)) 1), so this point in no way shoots down
what we originally set out to do on the PUSH-EVALUATION-ORDER issue.

A more complicated version of wrong-order, for example, one with a loop
in it, would make it impossible to guarantee that statement.  So we have
to change the statement.  Ick.  I think what we mean is that evaluation of the direct subforms
of the macro call and of generalized-variable references in the macro
call is ordered, but evaluation of subforms of those subforms is determined by the
recursive evaluation process as normal.  I'd have to think about this more
to see if this is the best way to say it, it doesn't strike me as a model
of clarity.

    Similarly if the user writes an "incorrect" setf-method, e.g.,

    (defsetf wrong-order (x y) (z) `(setf (get ,y ,x) ,z))

This is not an issue since CLtL p.103 says "This binding permits the
body forms to be written without regard for order-of-evaluation issues."
Of course a user could write an incorrect define-setf-method.

    I wish this weren't so sticky. . . .

Me too.  I think it's inherent in defining the order of evaluation of
things that aren't functions, so there's no easy answer.

*start*
08474 00024 US 
Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU by Xerox.COM ; 15 NOV 87 13:29:08 PST
Received: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 15 Nov 87  03:06:00 PST
Received: from Cabernet.ms by ArpaGateway.ms ; 14 NOV 87 21:16:10 PST
Date: 14 Nov 87 21:15 PST
From: Masinter.pa
Subject: Issue: PUSH-EVALUATION-ORDER (Version 4)
To: cl-cleanup@SAIL.STANFORD.EDU, peck@Sun.COM
Message-ID: <871114-211610-3592@Xerox>


I merely appended the salient points of the discussion so far to the end of this. 
!
Issue:         PUSH-EVALUATION-ORDER
References:    CLtL p. 99 (generalized variables)
               p. 270 (PUSH)
               All macros that manipulate generalized variables
               (SETF, PSETF, GETF, REMF, INCF, DECF, PUSH, PUSHNEW,
               POP, CHECK-TYPE, ASSERT, CTYPECASE, CCASE, SHIFTF,
               ROTATEF, and all macros defined by DEFINE-MODIFY-MACRO).
Category:      CLARIFICATION
Edit History:  Jeff Peck, 15-Oct-1987, version 1.
               Larry Masinter, 23-Oct-87, version 2.
               David Moon, 8-Nov-87, version 3
               Larry Masinter, 14-Nov-87, version 4

Not ready for release

Problem Description:

In the form: (PUSH (ref1) (CAR (ref2)))
It is unclear whether (ref1) should be evaluated before (ref2). 

CLtL, page 99, in a discussion of generalized variable macros, states:
"Other macros that manipulate generalized variables include ... PUSH....
 Macros that manipulate generalized variables must guarantee the
 `obvious' semantics: subforms of generalized-variable references
 are evaluated ... in exactly the same order as they appear in
 the *source* program."

That is, the sub-forms of Place should be evaluated once, left to right.

"The expansion of these macros must consist of code that follows these
 rules or has the same effect as such code.  This is accomplished by
 introducing temporary variables bound to the subforms of the
 reference."

This paragraph and a discussion of SETF on the previous pages may also
be interpreted as requiring that *all* subforms of such macro calls
should be evaluated once, in source order, left to right.

However, CLtL, page 270 states:
 "The effect of (PUSH Item Place) is roughly equivalent to
    (SETF Place (CONS Item Place))
  except that the latter would evaluate any subforms of Place twice
  while PUSH takes care to evaluate them only once."

That is, the effect of the form (PUSH Item Place) is to evaluate 
(SETF Place (CONS Item Place)) but with subforms of Place only evaluated
once.

Place and Item appear in different order in the PUSH form and the
indicated equivalent SETF form.  Should the PUSH form have primacy over
the obvious SETF form with respect to the left-to-right evaluation?

Are all subforms in a macro call guaranteed to be evaluated in order, or
only those subforms representing generalized variable references?

The same question arises for other forms which manipulate generalized
variables, e.g., PUSHNEW, INCF, DECF, and those defined with
DEFINE-MODIFY-MACRO.


Test Case:

(LET ((REF2 (LIST '())))
 (PUSH (PROGN (PRINC "1") 'REF-1)
       (CAR (PROGN (PRINC "2") REF2))))

If the subforms evaluate in left-to-right order, this will print 12
rather than 21.

Proposal: PUSH-EVALUATION-ORDER:ITEM-FIRST

Explicitly state that for the macros that manipulate generalized
variables (PUSH, PUSHNEW, GETF, REMF, INCF, DECF, SHIFTF, ROTATEF,
PSETF, SETF, POP, and those defined with DEFINE-MODIFY-MACRO) the
subforms of the macro call (including but not limited to subforms of the
generalized variable reference) are evaluated exactly as many times as
they appear in the source program, and in exactly the same order as they
appear in the source program.  Explicitly state that for the macros
CHECK-TYPE, ASSERT, CTYPECASE, and CCASE, that rule is followed except
where CLtL specifies to the contrary.

In this context, "subform" means a form (that is, something whose
syntactic use is such that it will be evaluated) that is nested inside
another form.  It does not mean any object nested inside a form
regardless of syntactic context.

For example, PUSH is expected to behave as if described as:

 (PUSH Item Place) is roughly equivalent to
 (SETF Place (CONS Item Place)) except that the subforms of Place
 are evaluated only once, and Item is evaluated before Place."

The phase "subforms of the reference" which appears several times in
CLtL should be made more specific to be "subforms of the macro call,"
referring to the entire form that calls the generalized-variable
manipulating macro.

Rationale:

This is the unstated intention of the page 97-100 discussion of
generalized-variable referencing macros, and indeed the intended
definition of "obvious semantics" for all macros.

Current practice:

Many implementations do not currently follow this evaluation order. In
the form (PUSH Item Place), Lucid, Franz, Kyoto and Xerox evaluate Place
then Item. Symbolics evaluates Item then Place.


For example, in Franz:

(macroexpand '(push (ref1) (car (ref2))))

    (LET* ((#:G8 (REF2))
           (#:G7 (CONS (REF1) (CAR #:G8))))
      (EXCL::.INV-CAR #:G8 #:G7)) 
    
In Symbolics Common Lisp, it returns:
    
    (LET* ((#:G5 (REF1))
           (#:G4 (REF2)))
      NIL
      (SYS:RPLACA2 #:G4 (VALUES (CONS #:G5 (CAR #:G4)))))


Adoption Cost:

Minimal, PUSH etc. could simply be defined by the appropriate macros.

Cost of non-adoption:

Obvious programs may be non-portable, although it should be rare that
order of evaluation will affect actual operation. 

Benefits:

The implementation and semantics of PUSH become obvious to all.  

Esthetics:

Common Lisp defines order of evaluation as left-to-right; this
clarification ensures consistency across the language. 

Discussion:

David Moon  argues that the unstated intention of page 99
is the definition of the language, while admitting that:

"The quoted paragraphs could be taken to restrict order of evaluation
only of the subforms of (CAR (ref2)), not all of the subforms of the
PUSH form."

However, the second to last paragraph on page 99

  As an example of these semantic rules, in the generalized-variable
  reference (setf reference value), the value form must be evaluated
  after all the subforms of the reference because the value form
  appears to the right of them.

makes it clear, if it is still talking about the same semantic rules,
that in this context the phrase "generalized-variable reference" was
meant to refer to the entire macro call, not just the Place, and that
order of evaluation rules are not limited to subforms of Places.  We
suggest that the next specification of Common Lisp should adopt more
consistent terminology.

No serious performance impact is expected; while some macro expansions
may appear to be more verbose, most compilers deal reasonably with the
required order of evaluation.

Problems with this version:

The rules for CHECK-TYPE, ASSERT, CTYPECASE, and CCASE need to be 
stated.

Given: 

    (defmacro wrong-order (x y) `(get ,y ,x))

If the user writes (push a (wrong-order (frob) (baz)))

are we willing to guarantee that "the subforms of the macro call
(including but not limited to subforms of the generalized variable
reference) are evaluated exactly as many times as they appear in the
source program, and in exactly the same order as they appear in the
source program. "? No..

Note that the same issue arises for
(setf (wrong-order (frob) (baz)) 1)

so this point in no way shoots down what we originally set out to do
on the PUSH-EVALUATION-ORDER issue.

A more complicated version of wrong-order, for example, one with a loop
in it, would make it impossible to guarantee that statement.  So we have
to change the statement.  I think what we mean is that evaluation
of the direct subforms of the macro call and of generalized-variable
references in the macro call is ordered, but evaluation of subforms of
those subforms is determined by the recursive evaluation process as normal.

What about

(rotatef (wrong-order (frob 1) (frob 2))
         (wrong-order (frob 3) (frob 4))

If the user writes an "incorrect" setf-method, e.g.,

    (defsetf wrong-order (x y) (z) `(setf (get ,y ,x) ,z))

this is not an issue since CLtL p.103 says "This binding permits the
body forms to be written without regard for order-of-evaluation issues."
Of course a user could write an incorrect define-setf-method.

*start*
09026 00024 US 
Date: 25 Nov 87 17:44 PST
From: Masinter.pa
Subject: Issue: PUSH-EVALUATION-ORDER (Version 5)
To: cl-cleanup@SAIL.STANFORD.EDU, peck@Sun.COM
cc: Masinter

This version attempts to clean up the previous one. I've tried to address the various remarks and special cases by cleaning up the description. I think the prose is still turgid and there are likely the usual typos, but... Comments please.

I think this is my last message until after Thanksgiving. I hope you will have (or have had) a pleasant one.
If you can't tell, I've been going thru the open issues alphabetically. Feel free to respond to any of the open issues, of course.


Issue:         PUSH-EVALUATION-ORDER
References:    CLtL p. 99 (generalized variables)
               p. 270 (PUSH)
               All macros that manipulate generalized variables
               (SETF, PSETF, GETF, REMF, INCF, DECF, PUSH, PUSHNEW,
               POP, CHECK-TYPE, ASSERT, CTYPECASE, CCASE, SHIFTF,
               ROTATEF, and all macros defined by DEFINE-MODIFY-MACRO).
               Issue SETF-FUNCTION-VS-MACRO.
Category:      CLARIFICATION
Edit History:  Version 1, 15-Oct-87, Jeff Peck
               Version 2, 23-Oct-87, Larry Masinter
               Version 3, 8-Nov-87, David Moon 
               Version 4, 14-Nov-87, Larry Masinter 
               Version 5, 25-Nov-87, Larry Masinter

Problem Description:

In the form (PUSH (ref1) (CAR (ref2))) It is unclear whether (ref1) should be evaluated before (ref2). 

CLtL, page 99, in a discussion of generalized variable macros, states: 

"Macros that manipulate generalized variables must guarantee the `obvious' semantics: subforms of generalized-variable references are evaluated ... in exactly the same order as they appear in the *source* program. The expansion of these macros must consist of code that follows these rules or has the same effect as such code.  This is accomplished by introducing temporary variables bound to the subforms of the reference."

This paragraph and a discussion of SETF on the previous pages may also be interpreted as requiring that *all* subforms of such macro calls should be evaluated once, in source order, left to right.

However, CLtL, page 270 states:

"The effect of (PUSH Item Place) is roughly equivalent to

    (SETF Place (CONS Item Place))

except that the latter would evaluate any subforms of Place twice while PUSH takes care to evaluate them only once."

Place and Item appear in different order in the PUSH form and the indicated equivalent SETF form.  Should the PUSH form have primacy over the obvious SETF form with respect to the left-to-right evaluation?

Are all subforms in a macro call guaranteed to be evaluated in order, or only those subforms representing generalized variable references?

The same question arises for other forms which manipulate generalized variables, e.g., PUSHNEW, INCF, DECF, and those defined with DEFINE-MODIFY-MACRO.

Proposal: PUSH-EVALUATION-ORDER:ITEM-FIRST

This proposal is hard to state, although the intent is fairly clear: evalution proceeds from left to right whenever possible. The left-to-right rule does not remove the obligation on writers of macros and define-setf-method  to ensure left-to-right order, however. 

In this proposal, a form is something whose syntactic use is such that it will be evaluated. A "subform" means a form that is nested inside another form -- not any object nested inside a form regardless of syntactic context. 

(1) The evaluation ordering of subforms within a generalized variable reference is determined by the order specified by the second value returned by GET-SETF-METHOD. For all predefined generalized variable references (GETF, LDB), this order of evaluation is exactly left-to-right. When a generalized variable reference is derived from a macro expansion, this rule is applied *after* the macro is expanded to find the appropriate generalized variable reference. 

This is intended to make it clear that if the user writes a DEFMACRO or DEFINE-SETF-METHOD that doesn't preserve order, the the order specified in the user's code holds; e.g., given 
  (DEFMACRO WRONG-ORDER (X Y) `(GETF ,Y ,X))
 that (PUSH <value> (WRONG-ORDER <place1> <place2>)).

will evaluate <place2> first and then <place1> because that is the order they are evaluated in the macro expansion.
 
(2) For the macros that manipulate generalized variables (PUSH, PUSHNEW, GETF, REMF, INCF, DECF, SHIFTF, ROTATEF, PSETF, SETF, POP, and those defined with DEFINE-MODIFY-MACRO) the subforms of the macro call are evaluated exactly once in left to right order, with the subforms of the generalized variable references evaluted in the order specified in (1).

PUSH, PUSHNEW, GETF, REMF, INCF, DECF, SHIFTF, ROTATEF, PSETF, POP evaluate all subforms before modifying any of the generalized variable locations. SETF (in the case when the SETF macro has more than two arguments) performs its operation on each pair in sequence, i.e., in (SETF <place1> <value1> <place2> <value2> ...), the subforms of <place1> and <value1> are evaluated, the location specified by <place1> is modified to contain the value returned by <value1>, and then the rest of the SETF form is processed in a like manner.

(3) For the macros CHECK-TYPE, CTYPECASE, and CCASE, subforms of the generalized variable reference are evaluted once as in (1), but may be evaluted again if the type check files in the case of CHECK-TYPE or none of the cases hold in CTYPECASE and CCASE.

(4) For the macro ASSERT, the order of evaluation of the generalized variable references is not specified.  

(Rules 2, 3 and 4 cover all macros defined in Common Lisp that manupulate generalized variable references.)

Examples:

(LET ((REF2 (LIST '())))
 (PUSH (PROGN (PRINC "1") 'REF-1)
       (CAR (PROGN (PRINC "2") REF2))))

Under this proposal, this would be required to print 12 and not 21.

(LET (X)
   (PUSH (SETQ X (LIST 'A))
         (CAR (SETQ X (LIST 'B))))
    X)

; the PUSH first evalutes (SETQ X (LIST 'A)) =>  (A)
; then evaluates (SETQ X (LIST 'B)) => (B)
; then modifies the CAR of (this latest value) to be ((A) . B).
; The result is (((A) . B)). 


Documentation impact:

PUSH should more appropriately be described as:

"(PUSH Item Place) is roughly equivalent to (SETF Place (CONS Item Place)) except that the subforms of Place are evaluated only once, and Item is evaluated before Place."

The phase "subforms of the reference" which appears several times in CLtL should be made more specific to be "subforms of the macro call," referring to the entire form that calls the generalized-variable manipulating macro.

Rationale:

This is the unstated intention of the page 97-100 discussion of generalized-variable referencing macros, and indeed the intended definition of "obvious semantics" for all macros.

Current practice:

Many implementations do not currently follow this evaluation order. In the form (PUSH Item Place), Lucid, Franz, Kyoto and Xerox evaluate Place then Item. Symbolics evaluates Item then Place.


For example, in Franz:

(macroexpand '(push (ref1) (car (ref2))))

    (LET* ((#:G8 (REF2))
           (#:G7 (CONS (REF1) (CAR #:G8))))
      (EXCL::.INV-CAR #:G8 #:G7)) 
    
In Symbolics Common Lisp, it returns:
    
    (LET* ((#:G5 (REF1))
           (#:G4 (REF2)))
      NIL
      (SYS:RPLACA2 #:G4 (VALUES (CONS #:G5 (CAR #:G4)))))


Cost to implementors:

Minimal, PUSH etc. could simply be defined by the appropriate macros.

Cost to users:

No currently portable program should be affected. However, this is a minor incompatible change for some implementations. No serious performance impact is expected; while some macro expansions may appear to be more verbose, most compilers deal reasonably with the required order of evaluation.

Benefits:

The implementation and semantics of PUSH become more well specified. This removes a source of non-portability, abeit likely rare.

Esthetics:

Common Lisp defines order of evaluation as left-to-right; this clarification ensures consistency across the language. 

Discussion:

This seems to be the intent of most of the relevant language in CLtL.

For example, the second to last paragraph on page 99

  "As an example of these semantic rules, in the generalized-variable
  reference (setf reference value), the value form must be evaluated
  after all the subforms of the reference because the value form
  appears to the right of them."

makes it clear that in this context the phrase "generalized-variable reference" was meant to refer to the entire macro call, not just the Place, and that order of evaluation rules are not limited to subforms of Places.  We hope the specification should adopt more consistent terminology.

Note that DEFINE-SETF-METHOD is immune to the exception specified about DEFMACRO and DEFINE-SETF-METHOD, because since CLtL p.103 says about DEFINE-SETF-METHOD: 

"This binding permits the body forms to be written without regard for order-of-evaluation issues."
        TITAN           "þ      "þ zº*start*
08874 00024 US 
Date: 14 Feb 88 13:37 PST
From: Masinter.pa
Subject: Issue: PUSH-EVALUATION-ORDER (Version 5)
To: X3J13@Sail.stanford.edu
cc: Masinter
reply-to: CL-CLEANUP@Sail.Stanford.EDU

I believe this issue was not distributed before.

Issue:         PUSH-EVALUATION-ORDER
References:    CLtL p. 99 (generalized variables)
               p. 270 (PUSH)
               All macros that manipulate generalized variables
               (SETF, PSETF, GETF, REMF, INCF, DECF, PUSH, PUSHNEW,
               POP, CHECK-TYPE, ASSERT, CTYPECASE, CCASE, SHIFTF,
               ROTATEF, and all macros defined by DEFINE-MODIFY-MACRO).
               Issue SETF-FUNCTION-VS-MACRO.
Category:      CLARIFICATION
Edit History:  Version 1, 15-Oct-87, Jeff Peck
               Version 2, 23-Oct-87, Larry Masinter
               Version 3, 8-Nov-87, David Moon 
               Version 4, 14-Nov-87, Larry Masinter 
               Version 5, 25-Nov-87, Larry Masinter

Problem Description:

In the form (PUSH (ref1) (CAR (ref2))) It is unclear whether (ref1) should be evaluated before (ref2). 

CLtL, page 99, in a discussion of generalized variable macros, states: 

"Macros that manipulate generalized variables must guarantee the `obvious' semantics: subforms of generalized-variable references are evaluated ... in exactly the same order as they appear in the *source* program. The expansion of these macros must consist of code that follows these rules or has the same effect as such code.  This is accomplished by introducing temporary variables bound to the subforms of the reference."

This paragraph and a discussion of SETF on the previous pages may also be interpreted as requiring that *all* subforms of such macro calls should be evaluated once, in source order, left to right.

However, CLtL, page 270 states:

"The effect of (PUSH Item Place) is roughly equivalent to

    (SETF Place (CONS Item Place))

except that the latter would evaluate any subforms of Place twice while PUSH takes care to evaluate them only once."

Place and Item appear in different order in the PUSH form and the indicated equivalent SETF form.  Should the PUSH form have primacy over the obvious SETF form with respect to the left-to-right evaluation?

Are all subforms in a macro call guaranteed to be evaluated in order, or only those subforms representing generalized variable references?

The same question arises for other forms which manipulate generalized variables, e.g., PUSHNEW, INCF, DECF, and those defined with DEFINE-MODIFY-MACRO.

Proposal: PUSH-EVALUATION-ORDER:ITEM-FIRST

This proposal is hard to state, although the intent is fairly clear: evalution proceeds from left to right whenever possible. The left-to-right rule does not remove the obligation on writers of macros and define-setf-method  to ensure left-to-right order, however. 

In this proposal, a form is something whose syntactic use is such that it will be evaluated. A "subform" means a form that is nested inside another form -- not any object nested inside a form regardless of syntactic context. 

(1) The evaluation ordering of subforms within a generalized variable reference is determined by the order specified by the second value returned by GET-SETF-METHOD. For all predefined generalized variable references (GETF, LDB), this order of evaluation is exactly left-to-right. When a generalized variable reference is derived from a macro expansion, this rule is applied *after* the macro is expanded to find the appropriate generalized variable reference. 

This is intended to make it clear that if the user writes a DEFMACRO or DEFINE-SETF-METHOD that doesn't preserve order, the the order specified in the user's code holds; e.g., given 
  (DEFMACRO WRONG-ORDER (X Y) `(GETF ,Y ,X))
 that (PUSH <value> (WRONG-ORDER <place1> <place2>)).

will evaluate <place2> first and then <place1> because that is the order they are evaluated in the macro expansion.
 
(2) For the macros that manipulate generalized variables (PUSH, PUSHNEW, GETF, REMF, INCF, DECF, SHIFTF, ROTATEF, PSETF, SETF, POP, and those defined with DEFINE-MODIFY-MACRO) the subforms of the macro call are evaluated exactly once in left to right order, with the subforms of the generalized variable references evaluted in the order specified in (1).

PUSH, PUSHNEW, GETF, REMF, INCF, DECF, SHIFTF, ROTATEF, PSETF, POP evaluate all subforms before modifying any of the generalized variable locations. SETF (in the case when the SETF macro has more than two arguments) performs its operation on each pair in sequence, i.e., in (SETF <place1> <value1> <place2> <value2> ...), the subforms of <place1> and <value1> are evaluated, the location specified by <place1> is modified to contain the value returned by <value1>, and then the rest of the SETF form is processed in a like manner.

(3) For the macros CHECK-TYPE, CTYPECASE, and CCASE, subforms of the generalized variable reference are evaluted once as in (1), but may be evaluted again if the type check files in the case of CHECK-TYPE or none of the cases hold in CTYPECASE and CCASE.

(4) For the macro ASSERT, the order of evaluation of the generalized variable references is not specified.  

(Rules 2, 3 and 4 cover all macros defined in Common Lisp that manupulate generalized variable references.)

Examples:

(LET ((REF2 (LIST '())))
 (PUSH (PROGN (PRINC "1") 'REF-1)
       (CAR (PROGN (PRINC "2") REF2))))

Under this proposal, this would be required to print 12 and not 21.

(LET (X)
   (PUSH (SETQ X (LIST 'A))
         (CAR (SETQ X (LIST 'B))))
    X)

; the PUSH first evalutes (SETQ X (LIST 'A)) =>  (A)
; then evaluates (SETQ X (LIST 'B)) => (B)
; then modifies the CAR of (this latest value) to be ((A) . B).
; The result is (((A) . B)). 


Documentation impact:

PUSH should more appropriately be described as:

"(PUSH Item Place) is roughly equivalent to (SETF Place (CONS Item Place)) except that the subforms of Place are evaluated only once, and Item is evaluated before Place."

The phase "subforms of the reference" which appears several times in CLtL should be made more specific to be "subforms of the macro call," referring to the entire form that calls the generalized-variable manipulating macro.

Rationale:

This is the unstated intention of the page 97-100 discussion of generalized-variable referencing macros, and indeed the intended definition of "obvious semantics" for all macros.

Current practice:

Many implementations do not currently follow this evaluation order. In the form (PUSH Item Place), Lucid, Franz, Kyoto and Xerox evaluate Place then Item. Symbolics evaluates Item then Place.


For example, in Franz:

(macroexpand '(push (ref1) (car (ref2))))

    (LET* ((#:G8 (REF2))
           (#:G7 (CONS (REF1) (CAR #:G8))))
      (EXCL::.INV-CAR #:G8 #:G7)) 
    
In Symbolics Common Lisp, it returns:
    
    (LET* ((#:G5 (REF1))
           (#:G4 (REF2)))
      NIL
      (SYS:RPLACA2 #:G4 (VALUES (CONS #:G5 (CAR #:G4)))))


Cost to implementors:

Minimal, PUSH etc. could simply be defined by the appropriate macros.

Cost to users:

No currently portable program should be affected. However, this is a minor incompatible change for some implementations. No serious performance impact is expected; while some macro expansions may appear to be more verbose, most compilers deal reasonably with the required order of evaluation.

Benefits:

The implementation and semantics of PUSH become more well specified. This removes a source of non-portability, abeit likely rare.

Esthetics:

Common Lisp defines order of evaluation as left-to-right; this clarification ensures consistency across the language. 

Discussion:

This seems to be the intent of most of the relevant language in CLtL.

For example, the second to last paragraph on page 99

"As an example of these semantic rules, in the generalized-variable reference (setf reference value), the value form must be evaluated after all the subforms of the reference because the value form appears to the right of them."

makes it clear that in this context the phrase "generalized-variable reference" was meant to refer to the entire macro call, not just the Place, and that order of evaluation rules are not limited to subforms of Places.  We hope the specification should adopt more consistent terminology.

Note that DEFINE-SETF-METHOD is immune to the exception specified about DEFMACRO and DEFINE-SETF-METHOD, because since CLtL p.103 says about DEFINE-SETF-METHOD: 

"This binding permits the body forms to be written without regard for order-of-evaluation issues."
        TITAN 
         
TIMESROMAN 
          TITAN 
          TITAN            ^       ‚             ë       +      
¢       
      º             ¿              µ                           H             '       
       „              y             ‹      !Y zº