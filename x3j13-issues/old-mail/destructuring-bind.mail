*start*09220 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 JAN 89 08:41:39 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 25 Jan 89  08:40:40 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 526592; Wed 25-Jan-89 11:38:39 ESTDate: Wed, 25 Jan 89 11:38 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890125113840.7.KMP@BOBOLINK.SCRC.Symbolics.COM>I've reorganized/rewritten this per discussion thus far.If you disagree with something, simply identify your disagreementor (preferrably) propose a change that would make you happy.Many of the positions in this proposal are just straw men, sodon't waste your time arguing with me because I may not disagree.The particular points where I most expect disagreement and needadvice on how to proceed are: - How to clarify LOOP destructuring. Its writeup is currently   too vague. We could spawn a separate issue if discussion gets   out of hand, but there is scheduling overhead to doing so.   If the issue can be handled simply as a paragraph riding   on this proposal, I'd prefer that. - How much error checking should DESTRUCTURING-BIND do. I'd   personally prefer it always signal on mismatch, but I didn't    write that into the proposal because I wanted to start by   accomodating current practice. If you feel strongly that the   proposal as stated is too tight or too loose, please say so.-----Issue:        DESTRUCTURING-BINDForum:	      CleanupReferences:   DEFMACRO (CLtL pp145-151),	      The LOOP Facility (X3J13/89-004)Category:     ADDITIONEdit history: 24-Jan-89, Version 1 by Pitman	      25-Jan-89, Version 2 by PitmanStatus:	      For Internal DiscussionProblem Description:  Common Lisp programmers have frequently complained that the  destructuring facility used by DEFMACRO is not made available  for use in ordinary programming situations involving list data.  The presence of a destructuring facility in the recently adopted  LOOP facility will be likely to make the absence of a separable  destructuring facility all the more apparent.  Prior to the introduction of LET into Maclisp, many people wrote  their own LET macros. A popular expansion was in terms of a DO  which did not iterate. eg,    (LET ((A 3)) (+ A A)) ==> (DO ((A 3)) () (RETURN (+ A A)))  While this practice `worked,' it was not perspicuous and contributed   substantially to non-readability: not only were the macros hard to  understand, but the surface interface itself was not standardized  and varied in subtle ways. For example, some LET macros allowed GO  statements while others did not.  There is now considerable danger that a lot of people will write  DESTRUCTURING-BIND variants in terms of a LOOP expression that  immediately returns.    (DESTRUCTURING-BIND ((A B) C) (FOO) (LIST A B C))    ==> (LOOP FOR ((A B) C) ON (FOO) DO (RETURN (LIST A B C)))  Since the destructuring offered by LOOP is different in subtle ways  from the destructuring offered by DESTRUCTURING-BIND in implementations  offering that primitive natively, gratuitous headaches could result.Proposal (DESTRUCTURING-BIND:NEW-MACRO):  Provide a macro called DESTRUCTURING-BIND which behaves like the  destructuring bind in DEFMACRO. Specifically...  DESTRUCTURING-BIND lambda-list expression {decl|doc}* {form}*   [Macro]   Binds the variables specified in LAMBDA-LIST to the corresponding   values in the tree structure resulting from evaluating EXPRESSION,   then evaluates the FORMS in the body.   Anywhere in the LAMBDA-LIST where a parameter name may appear, and   where ordinary lambda-list syntax (as described in CLtL section 5.2.2)   does not otherwise allow a list, a lambda-list may appear in place of   the parameter name. When this is done, then the argument form that   would match the parameter is treated as a (possibly dotted) list, to   be used as an argument forms list for satisfying the parameters in   the embedded lambda-list.   If any of the lambda list keywords &OPTIONAL, &REST, &KEY,   &ALLOW-OTHER-KEYS and &AUX appears in the lambda list, it is treated   as with any other lambda-list.   If the lambda list keyword &BODY appears, it is treated as a synonym   for &REST.   If the lambda list keyword &WHOLE appears, it must be followed by a   single variable that is bound to the entire expression at the current   level. &WHOLE and the following variable should appear first in the   list, before any other parameter or lambda-list keyword.   It is also permissible for any level of the LAMBDA-LIST to be dotted,   ending in a parameter name. This situation is treaed exactly as if   the aprameter name that ends the list had appeared preceded by &REST   in a proper list. For example, the notation (X Y . Z) is equivalent   to (X Y &REST Z).   If the result of evaluating the expression does not match the    destructuring pattern, the consequences are undefined. Implementations   are not required to signal an error in this case, but neither are they   permitted to extend the behavior by defining it to be harmless.  Clarify that the destructuring done by LOOP does not permit the use of  any lambda-list-keywords. Further clarify that in LOOP, proper lists  are implicitly `&REST var' (where the non-use of var is quietly ignored).  Hence, it is permissible to have:    (LOOP FOR (X Y) ON '(A B C D) COLLECT (CONS X Y)) => ((A . B) (C . D))  but it is not permissible to have:    (DESTRUCTURING-BIND (X Y) '(A B C D) (CONS X Y))  since the pattern does not match. One must instead write:    (DESTRUCTURING-BIND (X Y &REST Z) '(A B C D)       (DECLARE (IGNORE Z))      (CONS X Y))Test Case:  (DEFUN IOTA (N) (LOOP FOR I FROM 1 TO N COLLECT I)) ;helper  (DESTRUCTURING-BIND ((A &OPTIONAL (B 'BEE)) ONE TWO THREE)		      `((ALPHA) ,@(IOTA 3))    (LIST A B THREE TWO ONE))  => (ALPHA BEE 3 2 1)Rationale:  The proposal directly addresses the stated problem, and is current practice  in numerous implementations. Our charter effectively dictates that where  feasible we should try to head off the widespread development of uselessly  different variants of commonplace tools.Current Practice:  Symbolics Genera, Envos Medley, TI Explorer, and Lucid CL all offer  DESTRUCTURING-BIND, though the details vary slightly.  The DESTRUCTURING-BIND offered by Symbolics Genera signals an error if  the pattern is not matched. The TI Explorer version does not.Cost to Implementors:  Very small. In most cases, it's a matter of renaming and/or exporting an  already existing symbol. In a few cases, a very small amount of   `program interface' code would have to be written.Cost to Users:  None. This is an upward compatible change.Cost of Non-Adoption:  Loss of the Benefits and Aesthetics cited below.Benefits:  Users will get a powerful feature they have asked for on many occassions.  In implementations which `autoload' code, it would be better for this  support to be separable so that people could do DESTRUCTURING-BIND  without demand loading all other LOOP support.Aesthetics:  Defining this macro centrally for the Common Lisp community will reduce  subtle deviations, which will in turn have positive aesthetic impact.Discussion:  JonL observes that although LOOP does destructuring, it can't directly  make use of the DESTRUCTURING-BIND interface suggested here.  Pitman and Gray think a facility of this sort is a good idea, though  obviously the details may still need a little fleshing out before the  proposal is ready for vote.  To date, the excuse for not satisfying this request has been a  religious war between factions who want to destructure lists by  writing    (DESTRUCTURING-BIND (var1 var2 var3) exp . body)  and those who want to destructure lists by writing    (DESTRUCTURING-BIND (LIST var1 var2 var3) exp . body)  The advantage of the former approach is that it is notationally  concise for the common case of destructuring a list. The disadvantage  is that it is not extensible to accomodate abstract kinds of  destructuring.  The advantage of the latter approach is that it allows interesting  extensions that accomodate data-hiding, such as:    (DEFMACRO MAKE-FOO (&REST ELEMENTS) `(LIST ,@ELEMENTS))    (DESTRUCTURING-BIND (MAKE-FOO var1 var2 var3) exp . body)  and later the ability to change the representation of a FOO without  updating the associated binding forms. The disadvantage is that it  is more verbose in the common case of destructuring a list, and still  even more verbose for nested lists.  Although destructuring has always existed in DEFMACRO, this has not  been adequate precedence for deciding the outcome of the religious war  because DEFMACRO only needs to destructure programs, and programs are  generally made up only of lists -- not arbitrary user-defined abstract  data types.*start*00779 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 JAN 89 11:11:06 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 25 Jan 89  11:11:09 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 25 JAN 89 10:55:36 PSTDate: 25 Jan 89 10:52 PSTFrom: masinter.paSubject: Re: Issue: DESTRUCTURING-BIND (Version 1)In-reply-to: Jon L White <jonl@lucid.com>'s message of Wed, 25 Jan 89 02:47:30 PSTTo: Jon L White <jonl@lucid.com>cc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890125-105536-6433@Xerox>I should read all my mail before answering...  I'll look over Kent's newversion before commenting further.*start*01515 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 JAN 89 11:11:06 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 25 Jan 89  11:11:04 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 25 JAN 89 10:55:33 PSTDate: 25 Jan 89 10:50 PSTFrom: masinter.paSubject: Re: Issue: DESTRUCTURING-BIND (Version 1)In-reply-to: Jon L White <jonl@lucid.com>'s message of Wed, 25 Jan 89 02:47:30 PSTTo: Jon L White <jonl@lucid.com>cc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890125-105533-6432@Xerox>It's not over until the committee sings, is it?I don't think the rationale for *passing* this issue should be "consistencywith LOOP", but I do think that's the rationale for *bringing up* thisissue.  The Rationale section should document the reasons why the changeswe are making are good changes. The reason this is a good change is that itis not only useful, it is  current practice in many implementations, and,it is consistent with LOOP, in that order.The reason for bringing it up now (which we might mention in the Discussionsection) is that LOOP reminded us of it, and the fact that LOOP can be usedfor the same thing pushes things over the edge.I don't think this is a big deal, but am a little sensitive that thechanges we make should be "right" judged independently of our schedule,even though we stick to the schedule.*start*05455 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 JAN 89 14:35:09 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 24 Jan 89  14:33:30 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 526165; Tue 24-Jan-89 17:31:26 ESTDate: Tue, 24 Jan 89 17:31 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890124173126.9.KMP@BOBOLINK.SCRC.Symbolics.COM>Issue:        DESTRUCTURING-BINDForum:	      CleanupReferences:   The LOOP Facility (X3J13/89-004)Category:     ADDITIONEdit history: 24-Jan-89, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  Programmers have frequently requested an interface to a destructuring  bind facility similar to that available in DEFMACRO.  To date, the excuse for not satisfying this request has been a religious  war between factions who want to destructure lists by writing    (DESTRUCTURING-BIND (var1 var2 var3) exp . body)  and those who want to destructure lists by writing    (DESTRUCTURING-BIND (LIST var1 var2 var3) exp . body)  The advantage of the former approach is that it is notationally concise  for the common case of destructuring a list. The disadvantage is that  it is not extensible to accomodate abstract kinds of destructuring.  The advantage of the latter approach is that it allows interesting  extensions that accomodate data-hiding, such as:    (DEFMACRO MAKE-FOO (&REST ELEMENTS) `(LIST ,@ELEMENTS))    (DESTRUCTURING-BIND (MAKE-FOO var1 var2 var3) exp . body)  and later the ability to change the representation of a FOO without  updating the associated binding forms. The disadvantage is that it  is more verbose in the common case of destructuring a list, and still  even more verbose for nested lists.  Destructuring always existed in DEFMACRO, but since forms seen by the  evaluator are generally just lists, rather than arbitrary user-defined  abstract data types, an argument for destructuring of the second kind  in that circumstance seemed like overkill to most people.Proposal (DESTRUCTURING-BIND:NEW-MACRO):  Provide a macro called DESTRUCTURING-BIND which behaves like the  destructuring bind in DEFMACRO.  (DESTRUCTURING-BIND pattern datum . body)  evaluates datum, binds the indicated pattern variables, and then  executes the body.  Clarify that LOOP does not permit the use of &keywords in its  destructuring, and that proper lists are implicitly `&REST ignore'  (where the variable is quietly ignored).Test Case:  (DEFUN IOTA (N) (LOOP FOR I FROM 1 TO N COLLECT I)) ;helper  (DESTRUCTURING-BIND ((A &OPTIONAL (B 'BEE)) ONE TWO THREE)		      `((ALPHA) ,@(IOTA 3))    (LIST A B THREE TWO ONE))  => (ALPHA BEE 3 2 1)Rationale:  Now that LOOP has been introduced into the language with destructuring  of the first kind, rules of internal consistency could be used to   bypass religious arguments in order to satisfy user common needs.  Prior to the introduction of LET into Maclisp, many people wrote their  own LET macros. A popular expansion was in terms of a DO which did not  iterate. eg,    (LET ((A 3)) (+ A A)) ==> (DO ((A 3)) () (RETURN (+ A A)))  While this practice worked, it was not perspicuous and contributed   substantially to non-readability: not only were the macros hard to  understand, but the surface interface itself was not standardized  and varied in subtle ways.  There is now considerable danger that a lot of people will write  DESTRUCTURING-BIND variants in terms of a LOOP expression that  immediately returns.    (DESTRUCTURING-BIND ((A B) C) (FOO) (LIST A B C))    ==> (LOOP FOR ((A B) C) ON (FOO) DO (RETURN (LIST A B C)))  We should help to head off the evolution of a number of uselessly  different variants by simply institutionalizing the real support  for this.Current Practice:  Symbolics Genera already offers this extension.Cost to Implementors:  Very small. In most cases, it's a matter of renaming and/or exporting an  already existing symbol. In a few cases, a very small amount of   `program interface' code would have to be written.Cost to Users:  None. This is an upward compatible change.Cost of Non-Adoption:  Loss of the Benefits and Aesthetics cited below.Benefits:  Users will get a powerful feature they have asked for on many occassions.  In implementations which `autoload' code, it would be better for this  support to be separable so that people could do DESTRUCTURING-BIND  without demand loading all other LOOP support.Aesthetics:  Defining this macro centrally will reduce subtle deviations, which will  have positive aesthetic impact.  Defining this facility allows other tools like DEFMACRO and LOOP to be  defined in terms of it. That modularization of description is also a  positive change.Discussion:  Pitman was on the side of the abstract destructuring and isn't the  slightest bit happy about the kind of destructuring which snuck in  on the `LOOP trojan horse.' However, he thinks something like this  is the rational thing to do at this point. The details are not so  important as coming up with a nice, unified story.*start*01510 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 JAN 89 15:27:42 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 24 Jan 89  15:27:26 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 24 JAN 89 15:16:34 PSTDate: 24 Jan 89 15:11 PSTFrom: masinter.paSubject: Re: Issue: DESTRUCTURING-BIND (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 24 Jan 89 17:31 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890124-151634-4622@Xerox>Envos Medley also implements DESTRUCTURING-BIND as specified. I think we should avoid the characterization "LOOP trojan horse" in thediscussion: if you think this is a problem with LOOP, we should discuss itunder the heading of LOOP. I'd like to avoid giving weight to arguments ofthe form "since we let in X, lets let in Y too" since they are potentiallyendless. I think the rationale for this is that it is useful and corresponds tocurrent practice.I think the Proposal needs more clarification, "... which behaves like thedestructuring bind in DEFMACRO" being inconsistent with "Clarify that LOOPdoes not permit the use of &keywords in its  destructuring, and that proper lists are implicitly `&REST ignore'  (where the variable is quietly ignored)."In Medley's DESTRUCTURING-BIND, you can use &KEY arguments too.*start*01506 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 JAN 89 17:22:17 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 24 Jan 89  17:22:20 PSTReceived: by ti.com id AA04967; Tue, 24 Jan 89 19:21:13 CSTReceived: from Kelvin by tilde id AA27299; Tue, 24 Jan 89 19:03:02 CSTMessage-Id: <2810682365-5804726@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 24 Jan 89 19:06:05 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: DESTRUCTURING-BIND (Version 1)In-Reply-To: Msg of Tue, 24 Jan 89 17:31 EST from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>> Proposal (DESTRUCTURING-BIND:NEW-MACRO):> >   Provide a macro called DESTRUCTURING-BIND which behaves like the>   destructuring bind in DEFMACRO.> >   (DESTRUCTURING-BIND pattern datum . body)> >   evaluates datum, binds the indicated pattern variables, and then>   executes the body....> Current Practice:> >   Symbolics Genera already offers this extension.The TI Explorer also already implements this, although it doesn'tcompletely match DEFMACRO in that there is no error for wrong number ofarguments or invalid keywords; I'm not sure whether that conforms to theintent of this proposal or not.  It looks like Genera does do errorchecking.I agree that this is a useful feature to have.*start*00684 00024 US Return-Path: <eb@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 24 JAN 89 19:15:38 PSTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA00719g; Tue, 24 Jan 89 19:09:18 PSTReceived: by blacksox id AA02442g; Tue, 24 Jan 89 19:11:59 pstDate: Tue, 24 Jan 89 19:11:59 pstFrom: Eric Benson <eb@lucid.com>Message-Id: <8901250311.AA02442@blacksox>To: masinter.paCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: masinter.pa@Xerox.COM's message of 24 Jan 89 15:11 PST <890124-151634-4622@Xerox>Subject: Issue: DESTRUCTURING-BIND (Version 1)Lucid CL also implements DESTRUCTURING-BIND.*start*01415 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 JAN 89 02:51:09 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 25 Jan 89  02:51:19 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00850g; Wed, 25 Jan 89 02:45:10 PSTReceived: by bhopal id AA07948g; Wed, 25 Jan 89 02:47:30 PSTDate: Wed, 25 Jan 89 02:47:30 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901251047.AA07948@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Tue, 24 Jan 89 17:31 EST <890124173126.9.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 1)Well, foo, I wish someone had thought of this sooner.  Clearly, lotsof implementations provide it just as proposed (but in implementationdependent ways, in order to facilitate error checking).  I think thisis a tad too late for CL1989, don't you?  double foo.I also agree with Larry that any motivational reasoning based on LOOPis a red-herring.  DESTRUCTURING-BIND itself would not be so useful inimplementing LOOP as would some underlying functionality that animplementation of  DESTRUCTURING-BIND might use.  GSB's portable LOOPcarries around it's own version of destruction (or, the seeds thereof?).-- JonL --*start*01387 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 JAN 89 18:03:51 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Jan 89  18:03:19 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 528636; Fri 27-Jan-89 21:01:24 ESTDate: Fri, 27 Jan 89 21:01 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 2)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <890125113840.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890128020158.9.MOON@EUPHRATES.SCRC.Symbolics.COM>I support version 2 of this.  I have a couple of minor comments:DESTRUCTURING-BIND should not allow &WHOLE any more than it should allow&ENVIRONMENT.  Those two features are specific to macroexpanders.Both LOOP and DESTRUCTURING-BIND allow NIL in place of a variablename as a way of ignoring a portion of the destructured tree, inSymbolics current practice.  I think that's a good idea and shouldgo in the standard.  It's only an abbreviation for a dummy variableand a DECLARE IGNORE, but the whole destructuring feature isnothing but an abbreviation anyway.*start*01367 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 JAN 89 18:24:15 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 27 Jan 89  18:24:20 PSTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA01066g; Fri, 27 Jan 89 18:17:44 PSTReceived: by blacksox id AA00103g; Fri, 27 Jan 89 18:19:47 pstDate: Fri, 27 Jan 89 18:19:47 pstFrom: Eric Benson <eb@lucid.com>Message-Id: <8901280219.AA00103@blacksox>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Fri, 27 Jan 89 21:01 EST <19890128020158.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 2)   Date: Fri, 27 Jan 89 21:01 EST   From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>   Both LOOP and DESTRUCTURING-BIND allow NIL in place of a variable   name as a way of ignoring a portion of the destructured tree, in   Symbolics current practice.  I think that's a good idea and should   go in the standard.  It's only an abbreviation for a dummy variable   and a DECLARE IGNORE, but the whole destructuring feature is   nothing but an abbreviation anyway.Should NIL be allowed in DEFMACRO argument lists also?*start*02873 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 JAN 89 07:03:51 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 30 Jan 89  07:03:59 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 529856; Mon 30-Jan-89 10:01:57 ESTDate: Mon, 30 Jan 89 10:01 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 2)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19890128020158.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <890130100149.3.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri, 27 Jan 89 21:01 EST    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    I support version 2 of this.  I have a couple of minor comments:    DESTRUCTURING-BIND should not allow &WHOLE any more than it should allow    &ENVIRONMENT.  Those two features are specific to macroexpanders.Sigh. EB sent something which touched on this same issue. I guess you'reright, but I think before we disallow them, we should probably make itclear that &WHOLE and &ENVIRONMENT only belong at toplevel of a DEFMACROlambda list and not within. That would make the implementation-strategyfor DEFMACRO more apparent. I made a separate issue,DEFMACRO-LAMBDA-LIST, to discuss this.Actually, it seems to me that the same case could be made for &BODY. Ithas no purpose in DESTRUCTURING-BIND since an explicit call toDESTRUCTURING-BIND will never have to affect the way something prettyprints. Nevertheless, since it is useful to have &BODY appear at recursivelevels of DEFMACRO binding forms, I think it should be permitted here.Still, we should be up front about our motivations here.    Both LOOP and DESTRUCTURING-BIND allow NIL in place of a variable    name as a way of ignoring a portion of the destructured tree, in    Symbolics current practice.  I think that's a good idea and should    go in the standard. It's only an abbreviation for a dummy variable    and a DECLARE IGNORE, but the whole destructuring feature is nothing    but an abbreviation anyway.This is ok with me. Does anyone object? If I hear no objection, thischange will be in the next version. Especially in error-checking versionswhere you might otherwise appear to be matching an empty list by thenormal destructuring rules (signalling an error in some implementations)this might be important.Of course, there are other places where such a convention would beuseful, too. LAMBDA, MULTIPLE-VALUE-BIND and MULTIPLE-VALUE-SETQ comeimmediately to mind. But I guess it's really too late to considerammending those. Oh well...*start*02904 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 31 JAN 89 02:35:41 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 31 Jan 89  02:33:08 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03991g; Tue, 31 Jan 89 02:27:38 PSTReceived: by bhopal id AA14720g; Tue, 31 Jan 89 02:29:58 PSTDate: Tue, 31 Jan 89 02:29:58 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901311029.AA14720@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: Kent M Pitman's message of Mon, 30 Jan 89 10:01 EST <890130100149.3.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 2)re: [use of NIL as an implicitly ignored variable, in binding constructs]    Of course, there are other places where such a convention would be    useful, too. LAMBDA, MULTIPLE-VALUE-BIND and MULTIPLE-VALUE-SETQ come    immediately to mind. But I guess it's really too late to consider    ammending those. Oh well...You might not remember that VAX/NIL had regular destructuring as a standardfeature of LET and DEFUN, along with the ignore-NIL hack.  The one place that it didn't easily generalize was for SETQ -- thus VAX/NIL had a special-form/macro called DESETQ, as a destructuring version of SETQ.As I remember it, some folks objected to the destructuring capabilityfor LET based on what they thought ought to be "primitive"; and othersobjected to it in DEFUN for similar reasons.  Of course, from animplementational point of view, neither LET nor DEFUN is typicallyprimitive; they are simply the portable interface to a useful construct.But the final killer for these extensions were what you term the "religious wars" regarding how to specify destructuring over a list:    (destructuring-bind (a b c) (produce-a-list) ...)or    (destructuring-bind `(,a ,b ,c) (produce-a-list) ...)VAX/NIL actually used an extended form like:    (destructuring-bind #(a b c) (produce-a-vector) ...)and *almost* had another extension like:    (destructuring-bind #S(FOO a b c) (produce-a-struct-FOO) ...)Neither extension was extensible in the more general sense, but they were certainly useful in writing a peephole optimizer for the output a NIL compiler.Incidentally, the place where LOOP and your recent proposal might"share" is if there were a destructuring version of SETQ.  It'sunlikely, however, that as many implementations provide theequivalent of DESETQ as provide DESTRUCTURING-BIND.  Again, Imight mention that I feel there is a low-level primitive thatwould facilitate writing all these "destructuring" forms -- for LOOP, for DESTRUCTURING-BIND, for DESETQ, etc -- but it maynot be worth it to try to "kernelize" this idea.-- JonL --*start*03800 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 FEB 89 15:13:59 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 3 Feb 89  15:13:02 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 533462; 3 Feb 89 18:10:54 ESTDate: Fri, 3 Feb 89 18:11 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 2)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <890130100149.3.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890203231131.9.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 30 Jan 89 10:01 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>	Date: Fri, 27 Jan 89 21:01 EST	From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>	I support version 2 of this.  I have a couple of minor comments:	DESTRUCTURING-BIND should not allow &WHOLE any more than it should allow	&ENVIRONMENT.  Those two features are specific to macroexpanders.    Sigh. EB sent something which touched on this same issue. I guess you're    right, but I think before we disallow them, we should probably make it    clear that &WHOLE and &ENVIRONMENT only belong at toplevel of a DEFMACRO    lambda list and not within. That would make the implementation-strategy    for DEFMACRO more apparent. I made a separate issue,    DEFMACRO-LAMBDA-LIST, to discuss this.I committed an error here.  &ENVIRONMENT is specific to macroexpanders,but &WHOLE should be allowed in DESTRUCTURING-BIND just as it is allowedother than at top level in DEFMACRO.  It's just that &WHOLE at top levelin DEFMACRO has a slightly special meaning.    Actually, it seems to me that the same case could be made for &BODY. It    has no purpose in DESTRUCTURING-BIND since an explicit call to    DESTRUCTURING-BIND will never have to affect the way something pretty    prints. Nevertheless, since it is useful to have &BODY appear at recursive    levels of DEFMACRO binding forms, I think it should be permitted here.    Still, we should be up front about our motivations here.I think it's more consistent to allow &BODY.	Both LOOP and DESTRUCTURING-BIND allow NIL in place of a variable	name as a way of ignoring a portion of the destructured tree, in	Symbolics current practice.  I think that's a good idea and should	go in the standard. It's only an abbreviation for a dummy variable	and a DECLARE IGNORE, but the whole destructuring feature is nothing	but an abbreviation anyway.Note that whichever way we decide, DESTRUCTURING-BIND and DEFMACRO shouldbe consistent about allowing NIL to mean ignore.    This is ok with me. Does anyone object? The main difficulty is that NIL in the cdr position has to be treated asa special case, it can't be the same as an ignored variable in the cdrposition when DESTRUCTURING-BIND (as DEFMACRO does) regards mismatchof length of a non-dotted list as an error.X3J13 LOOP, as documented in 89-004, has this feature.  However, it isinconsistent with DEFMACRO and (I think) DESTRUCTURING-BIND, becauseLOOP destructuring does not consider list length mismatch an error.					    If I hear no objection, this    change will be in the next version.Upon reflection, I'd like to withdraw the suggestion about NIL.  I don'tthink it should be put into the standard at this time.In fact the feature that I really prefer is the one that provides anautomatic DECLARE IGNORE for any variable that is named IGNORE and isnot referenced.  For some reason I was hesitant to suggest that; I thinkI was being stupid.*start*01430 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 08:44:42 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 6 Feb 89  08:45:00 PSTReceived: from fafnir.think.com by Think.COM; Mon, 6 Feb 89 11:32:08 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Mon, 6 Feb 89 11:40:40 ESTReceived: by verdi.think.com; Mon, 6 Feb 89 11:40:11 ESTDate: Mon, 6 Feb 89 11:40:11 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8902061640.AA27962@verdi.think.com>To: Moon@stony-brook.scrc.symbolics.comCc: KMP@stony-brook.scrc.symbolics.com, CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 3 Feb 89 18:11 EST <19890203231131.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 2)   Date: Fri, 3 Feb 89 18:11 EST   From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>   ...   In fact the feature that I really prefer is the one that provides an   automatic DECLARE IGNORE for any variable that is named IGNORE and is   not referenced.  For some reason I was hesitant to suggest that; I think   I was being stupid.Presumably you want the additional special treatment that suchvariables named IGNORE are exempt from the prohibition on the samevariable appearing twice in a lambda-list.--Guy*start*01457 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 09:37:08 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Feb 89  09:37:03 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 534098; Mon 6-Feb-89 12:01:45 ESTDate: Mon, 6 Feb 89 12:02 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 2)To: Guy Steele <gls@Think.COM>cc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8902061640.AA27962@verdi.think.com>Message-ID: <19890206170212.7.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 6 Feb 89 11:40:11 EST    From: Guy Steele <gls@Think.COM>       Date: Fri, 3 Feb 89 18:11 EST       From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>       ...       In fact the feature that I really prefer is the one that provides an       automatic DECLARE IGNORE for any variable that is named IGNORE and is       not referenced.  For some reason I was hesitant to suggest that; I think       I was being stupid.    Presumably you want the additional special treatment that such    variables named IGNORE are exempt from the prohibition on the same    variable appearing twice in a lambda-list.Right.*start*01810 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 11:50:50 PSTReceived: from ucbarpa.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 6 Feb 89  11:50:42 PSTReceived: from franz.UUCP by ucbarpa.Berkeley.EDU (5.61/1.33)	id AA25465; Mon, 6 Feb 89 11:25:49 -0800Received: from frisky by franz (3.2/3.14)	id AA19171; Mon, 6 Feb 89 10:32:26 PSTReceived: by frisky (3.2/3.14)	id AA00477; Mon, 6 Feb 89 10:29:42 PSTFrom: franz!frisky!jkf@ucbarpa.Berkeley.EDU (John Foderaro)Return-Path: <frisky!jkf>Message-Id: <8902061829.AA00477@frisky>To: David A. Moon <franz!akbar!franz!ucbarpa!STONY-BROOK.SCRC.Symbolics.COM!Moon@ucbarpa.Berkeley.EDU>Cc: Guy Steele <franz!Think.COM!gls@ucbarpa.Berkeley.EDU>, franz!STONY-BROOK.SCRC.Symbolics.COM!KMP@ucbarpa.Berkeley.EDU, franz!SAIL.STANFORD.EDU!CL-Cleanup@ucbarpa.Berkeley.EDUSubject: Re: Issue: DESTRUCTURING-BIND (Version 2) In-Reply-To: Your message of Mon, 06 Feb 89 12:02:00 EST.             <19890206170212.7.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Mon, 06 Feb 89 10:29:41 PST       From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>       In fact the feature that I really prefer is the one that provides an       automatic DECLARE IGNORE for any variable that is named IGNORE and is       not referenced.  You are kidding ... right?  If you aren't then I'd like to tack on an amendment that symbols beginning with the letters 'i' through 'n' are declaredinteger and all other symbols are declared float.Seriously, I think that what you want is the  'ignore-if-unused'declaration we added which permits the variable to be used, but if itisn't there are no complaints.  It is very useful in macros.*start*01462 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 12:52:31 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 6 Feb 89  12:51:03 PSTReceived: from pitney-bowes ([192.9.200.50]) by heavens-gate.lucid.com id AA01494g; Mon, 6 Feb 89 12:45:25 PSTReceived: by pitney-bowes id AA17605g; Mon, 6 Feb 89 12:44:10 PSTDate: Mon, 6 Feb 89 12:44:10 PSTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8902062044.AA17605@pitney-bowes>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: franz!frisky!jkf@ucbarpa.Berkeley.EDU, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Mon, 6 Feb 89 15:11 EST <19890206201122.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BIND (Version 2) Not to detract from the main point (which I endorse), doesn't(PROCLAIM '(IGNORE IGNORE)) have most of the desired effect in  the current language?  I think treating IGNORE specially is desirable since I see no comparable trick to allow duplicate entries in a lambda-list.(Without a standard, the trick above has the minor danger of "capturing" a lamentable use of IGNORE as a normal variable, but since you presumably would get a compiler warning, it's not an insidious problem.) (I suppose one could also introduce an &IGNORE lambda key word, but  the thought makes me vaguely uncomfortable.)  jlm*start*02954 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 FEB 89 14:19:25 PSTReceived: from ucbarpa.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 6 Feb 89  14:19:35 PSTReceived: from franz.UUCP by ucbarpa.Berkeley.EDU (5.61/1.33)	id AA29389; Mon, 6 Feb 89 14:04:19 -0800Received: from frisky by franz (3.2/3.14)	id AA19637; Mon, 6 Feb 89 13:30:40 PSTReceived: by frisky (3.2/3.14)	id AA00873; Mon, 6 Feb 89 13:27:55 PSTFrom: franz!frisky!jkf@ucbarpa.Berkeley.EDU (John Foderaro)Return-Path: <frisky!jkf>Message-Id: <8902062127.AA00873@frisky>To: David A. Moon <franz!akbar!franz!ucbarpa!STONY-BROOK.SCRC.Symbolics.COM!Moon@ucbarpa.Berkeley.EDU>Cc: franz!SAIL.STANFORD.EDU!CL-Cleanup@ucbarpa.Berkeley.EDUSubject: Re: Issue: DESTRUCTURING-BIND (Version 2) In-Reply-To: Your message of Mon, 06 Feb 89 15:11:00 EST.             <19890206201122.6.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Mon, 06 Feb 89 13:27:54 PSTWhat I suggested and what you want are in fact not separate issues.What you said you want is:    the feature that I really prefer is the one that provides an    automatic DECLARE IGNORE for any variable that is named IGNORE and is    not referenced.  In other words, what you want is a new type of declaration that a variableshould be '(declare (ignore ..))'d if it isn't used.  This is reasonablething to ask for.  You further want to restrict that to the singlesymbol named 'ignore'.  What is the point in adding somethingif you then go and restrict it to one symbol?   Where is the leverage?    If one must write a declaration, I see no advantage to the user in    having to use a longer declaration name than the existing IGNORE    declaration.The point is that what you are asking for is different than justautomatically putting in a (declare (ignore ignore)) after everybinding of ignore.   You are asking for 'ignore-if-unused' not 'ignore'(most compilers (I assume) will complain if a variable declared ignored isactually used).    In most systems it works    to write (PROGN var1 var2 var3 body...) in the macro expansion to    make var1, var2, var3 look like they are used, so no new declaration    is required for this. Maybe it is just me but I consider this practice to be vile.   I certainlyhope that it is legitimate for a compiler to complain if the only useof a variable is in a place where its value isn't used.I would consider the adoption of this 'auto-ignore' proposal asa little wart on the language that encourages bad programming style(i.e. rather than use a meaningful variable name and then declareit ignored, one would be encourage to be lazy and just use 'ignore').As we are all aware, many more man-hours are spent readingand modifying a piece of code than are spent typing it in, soextra time spent while typing it in really counts.*start*03462 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 FEB 89 11:23:25 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Feb 89  16:38:03 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 534599; Mon 6-Feb-89 19:35:41 ESTDate: Mon, 6 Feb 89 19:36 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DESTRUCTURING-BIND (Version 2) To: John Foderaro <franz!frisky!jkf@ucbarpa.Berkeley.EDU>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8902062127.AA00873@frisky>Supersedes: <19890206231007.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19890207003619.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 06 Feb 89 13:27:54 PST    From: franz!frisky!jkf@ucbarpa.Berkeley.EDU (John Foderaro)    What I suggested and what you want are in fact not separate issues.    What you said you want is:	the feature that I really prefer is the one that provides an	automatic DECLARE IGNORE for any variable that is named IGNORE and is	not referenced.      In other words, what you want is a new type of declaration that a variable    should be '(declare (ignore ..))'d if it isn't used.  This is reasonable    thing to ask for.  You further want to restrict that to the single    symbol named 'ignore'.  What is the point in adding something    if you then go and restrict it to one symbol?   Where is the leverage?I understand your point, but I don't see it that way.  To me, asking fora way to create user-defined synonyms for IGNORE is like asking for away to create user-defined synonyms for &REST.  It would be more generaland flexible, but it doesn't seem necessary nor very useful.	If one must write a declaration, I see no advantage to the user in	having to use a longer declaration name than the existing IGNORE	declaration.    The point is that what you are asking for is different than just    automatically putting in a (declare (ignore ignore)) after every    binding of ignore.   No it's not.			 You are asking for 'ignore-if-unused' not 'ignore'    (most compilers (I assume) will complain if a variable declared ignored is    actually used).No, I was asking for the equivalent of the IGNORE declaration.  UnfortunatelyI expressed myself poorly, so I can see how you thought I was asking forsomething different.  I'm sorry about that.	In most systems it works	to write (PROGN var1 var2 var3 body...) in the macro expansion to	make var1, var2, var3 look like they are used, so no new declaration	is required for this.     Maybe it is just me but I consider this practice to be vile.   I certainly    hope that it is legitimate for a compiler to complain if the only use    of a variable is in a place where its value isn't used.    I would consider the adoption of this 'auto-ignore' proposal as    a little wart on the language that encourages bad programming style    (i.e. rather than use a meaningful variable name and then declare    it ignored, one would be encourage to be lazy and just use 'ignore').    As we are all aware, many more man-hours are spent reading    and modifying a piece of code than are spent typing it in, so    extra time spent while typing it in really counts.Conciseness saves reading time also.*start*01341 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 07:57:03 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Mar 89  07:56:43 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 MAR 89 07:48:32 PSTDate: 14 Mar 89 07:48 PSTFrom: masinter.paSubject: Re: Issue: DESTRUCTURING-BIND (Version 2)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 25 Jan 89 11:38 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890314-074832-22564@Xerox>Version 2 is the most recent I have. There's been some debate about &WHOLE,&ENVIRONMENT, NIL and IGNORE in the destructuring list.&ENVIRONMENT:	everybody says disallow&WHOLE:	Moon said allow (the second time.)NIL:	Moon says allow as a way of ignoring.	KMP says OK.&BODY:	KMP makes case for disallowing, but says	allow.There was some additional discussion that resulted in the related issue ofDEFMACRO-LAMBDA-LIST. I'd be happy with a proposal that said NIL is ignored, &WHOLE and &BODY areallowed, and that &ENVIRONMENT is disallowed.KMP made a reference to "the next version" in his message of 30 Jan 89, somaybe he'll produce one.Larry*start*08779 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Mar-89 12:35:48 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 12:35:20 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  12:12:27 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 16 MAR 89 11:49:11 PSTDate: 16 Mar 89 11:46 PSTFrom: masinter.paSubject: *DRAFT* Issue: DESTRUCTURING-BIND, v.2to: X3J13@sail.stanford.eduline-fold: NOMessage-ID: <890316-114911-4982@Xerox>This issue is draft; there will hopefully be a new version beforethe meeting. The discussion centers around what lambda-list keywords should beallowed.&ENVIRONMENT:	everybody says disallow&WHOLE:	Moon said allow (the second time.)NIL:	Moon says allow as a way of ignoring.	KMP says OK, maybe in other places too.	Discussion of IGNORE led to new issue.&BODY:	KMP makes case for disallowing, but says	allow.There was some additional discussion that resulted in therelated issues of DEFMACRO-LAMBDA-LIST and IGNORE-VARIABLE.I'd be happy with a proposal that said NIL is ignored, &WHOLE and &BODY are allowed, and that &ENVIRONMENT is disallowed. I'd like to make sure it was consistentwith LOOP.!Issue:        DESTRUCTURING-BINDForum:	      CleanupReferences:   DEFMACRO (CLtL pp145-151),	      The LOOP Facility (X3J13/89-004)Category:     ADDITIONEdit history: 24-Jan-89, Version 1 by Pitman	      25-Jan-89, Version 2 by PitmanStatus:	      For Internal DiscussionProblem Description:  Common Lisp programmers have frequently complained that the  destructuring facility used by DEFMACRO is not made available  for use in ordinary programming situations involving list data.  The presence of a destructuring facility in the recently adopted  LOOP facility will be likely to make the absence of a separable  destructuring facility all the more apparent.  Prior to the introduction of LET into Maclisp, many people wrote  their own LET macros. A popular expansion was in terms of a DO  which did not iterate. eg,    (LET ((A 3)) (+ A A)) ==> (DO ((A 3)) () (RETURN (+ A A)))  While this practice `worked,' it was not perspicuous and contributed   substantially to non-readability: not only were the macros hard to  understand, but the surface interface itself was not standardized  and varied in subtle ways. For example, some LET macros allowed GO  statements while others did not.  There is now considerable danger that a lot of people will write  DESTRUCTURING-BIND variants in terms of a LOOP expression that  immediately returns.    (DESTRUCTURING-BIND ((A B) C) (FOO) (LIST A B C))    ==> (LOOP FOR ((A B) C) ON (FOO) DO (RETURN (LIST A B C)))  Since the destructuring offered by LOOP is different in subtle ways  from the destructuring offered by DESTRUCTURING-BIND in implementations  offering that primitive natively, gratuitous headaches could result.Proposal (DESTRUCTURING-BIND:NEW-MACRO):  Provide a macro called DESTRUCTURING-BIND which behaves like the  destructuring bind in DEFMACRO. Specifically...  DESTRUCTURING-BIND lambda-list expression {decl|doc}* {form}*   [Macro]   Binds the variables specified in LAMBDA-LIST to the corresponding   values in the tree structure resulting from evaluating EXPRESSION,   then evaluates the FORMS in the body.   Anywhere in the LAMBDA-LIST where a parameter name may appear, and   where ordinary lambda-list syntax (as described in CLtL section 5.2.2)   does not otherwise allow a list, a lambda-list may appear in place of   the parameter name. When this is done, then the argument form that   would match the parameter is treated as a (possibly dotted) list, to   be used as an argument forms list for satisfying the parameters in   the embedded lambda-list.   If any of the lambda list keywords &OPTIONAL, &REST, &KEY,   &ALLOW-OTHER-KEYS and &AUX appears in the lambda list, it is treated   as with any other lambda-list.   If the lambda list keyword &BODY appears, it is treated as a synonym   for &REST.   If the lambda list keyword &WHOLE appears, it must be followed by a   single variable that is bound to the entire expression at the current   level. &WHOLE and the following variable should appear first in the   list, before any other parameter or lambda-list keyword.   It is also permissible for any level of the LAMBDA-LIST to be dotted,   ending in a parameter name. This situation is treaed exactly as if   the aprameter name that ends the list had appeared preceded by &REST   in a proper list. For example, the notation (X Y . Z) is equivalent   to (X Y &REST Z).   If the result of evaluating the expression does not match the    destructuring pattern, the consequences are undefined. Implementations   are not required to signal an error in this case, but neither are they   permitted to extend the behavior by defining it to be harmless.  Clarify that the destructuring done by LOOP does not permit the use of  any lambda-list-keywords. Further clarify that in LOOP, proper lists  are implicitly `&REST var' (where the non-use of var is quietly ignored).  Hence, it is permissible to have:    (LOOP FOR (X Y) ON '(A B C D) COLLECT (CONS X Y)) => ((A . B) (C . D))  but it is not permissible to have:    (DESTRUCTURING-BIND (X Y) '(A B C D) (CONS X Y))  since the pattern does not match. One must instead write:    (DESTRUCTURING-BIND (X Y &REST Z) '(A B C D)       (DECLARE (IGNORE Z))      (CONS X Y))Test Case:  (DEFUN IOTA (N) (LOOP FOR I FROM 1 TO N COLLECT I)) ;helper  (DESTRUCTURING-BIND ((A &OPTIONAL (B 'BEE)) ONE TWO THREE)		      `((ALPHA) ,@(IOTA 3))    (LIST A B THREE TWO ONE))  => (ALPHA BEE 3 2 1)Rationale:  The proposal directly addresses the stated problem, and is current practice  in numerous implementations. Our charter effectively dictates that where  feasible we should try to head off the widespread development of uselessly  different variants of commonplace tools.Current Practice:  Symbolics Genera, Envos Medley, TI Explorer, and Lucid CL all offer  DESTRUCTURING-BIND, though the details vary slightly.  The DESTRUCTURING-BIND offered by Symbolics Genera signals an error if  the pattern is not matched. The TI Explorer version does not.Cost to Implementors:  Very small. In most cases, it's a matter of renaming and/or exporting an  already existing symbol. In a few cases, a very small amount of   `program interface' code would have to be written.Cost to Users:  None. This is an upward compatible change.Cost of Non-Adoption:  Loss of the Benefits and Aesthetics cited below.Benefits:  Users will get a powerful feature they have asked for on many occassions.  In implementations which `autoload' code, it would be better for this  support to be separable so that people could do DESTRUCTURING-BIND  without demand loading all other LOOP support.Aesthetics:  Defining this macro centrally for the Common Lisp community will reduce  subtle deviations, which will in turn have positive aesthetic impact.Discussion:  JonL observes that although LOOP does destructuring, it can't directly  make use of the DESTRUCTURING-BIND interface suggested here.  Pitman and Gray think a facility of this sort is a good idea, though  obviously the details may still need a little fleshing out before the  proposal is ready for vote.  To date, the excuse for not satisfying this request has been a  religious war between factions who want to destructure lists by  writing    (DESTRUCTURING-BIND (var1 var2 var3) exp . body)  and those who want to destructure lists by writing    (DESTRUCTURING-BIND (LIST var1 var2 var3) exp . body)  The advantage of the former approach is that it is notationally  concise for the common case of destructuring a list. The disadvantage  is that it is not extensible to accomodate abstract kinds of  destructuring.  The advantage of the latter approach is that it allows interesting  extensions that accomodate data-hiding, such as:    (DEFMACRO MAKE-FOO (&REST ELEMENTS) `(LIST ,@ELEMENTS))    (DESTRUCTURING-BIND (MAKE-FOO var1 var2 var3) exp . body)  and later the ability to change the representation of a FOO without  updating the associated binding forms. The disadvantage is that it  is more verbose in the common case of destructuring a list, and still  even more verbose for nested lists.  Although destructuring has always existed in DEFMACRO, this has not  been adequate precedence for deciding the outcome of the religious war  because DEFMACRO only needs to destructure programs, and programs are  generally made up only of lists -- not arbitrary user-defined abstract  data types.*start*01238 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Mar-89 16:14:40 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 16:14:37 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  16:02:40 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Thu, 16 Mar 89 17:45:15 ESTDate: Thu, 16 Mar 89 17:46 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: *DRAFT* Issue: DESTRUCTURING-BIND, v.2To: masinter.paCc: X3J13@sail.stanford.eduIn-Reply-To: <890316-114911-4982@Xerox>Message-Id: <19890316224608.4.BARMAR@OCCAM.THINK.COM>    Date: 16 Mar 89 11:46 PST    From: masinter.pa@xerox.com    Current Practice:      The DESTRUCTURING-BIND offered by Symbolics Genera signals an error if      the pattern is not matched. The TI Explorer version does not.Actually, Genera offers TWO versions of DESTRUCTURING-BIND:SYMBOLICS-COMMON-LISP:DESTRUCTURING-BIND andZETALISP:DESTRUCTURING-BIND.  The former signals an error, while thelatter does not (it's probably very similar to the Explorer version,since they are genetically closer).                                                barmar*start*01226 00024 US GV-Info: alarson@src.honeywell.com at 18-Mar-89 17:06:10 from AGReturn-Path: <alarson@src.honeywell.com>Received: from moon.src.honeywell.com ([129.30.1.10]) by Xerox.COM ; 18 MAR 89 17:06:03 PSTReturn-Path: <alarson@src.honeywell.com>Received: from pavo.SRC.Honeywell.COM by moon.src.honeywell.com (5.59/smail2.6.3/06-17-88);	Sat, 18 Mar 89 19:07:01 CST id AA09942 for masinter.pa@Xerox.COMPosted-Date: Sat, 18 Mar 89 19:05:07 CSTReceived: by pavo.src.honeywell.com (3.2/SMI-3.2)	id AA20299; Sat, 18 Mar 89 19:05:07 CSTDate: Sat, 18 Mar 89 19:05:07 CSTFrom: alarson@src.honeywell.com (Aaron Larson)Message-Id: <8903190105.AA20299@pavo.src.honeywell.com>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 16 Mar 89 11:46 PST <890316-114911-4982@Xerox>Subject: *DRAFT* Issue: DESTRUCTURING-BIND, v.2   If the result of evaluating the expression does not match the    destructuring pattern, the consequences are undefined. Implementations   are not required to signal an error in this case, but neither are they   permitted to extend the behavior by defining it to be harmless.At the risk of getting rpg started again, what does it mean?*start*01445 00024 USaDate:  4 Apr 89 08:59 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: DESTRUCTURING-BINDTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DESTRUCTURING-BINDTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 08:59:02 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  08:57:16 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 570958; Tue 4-Apr-89 11:57:09 EDTOriginal-Date: Tue, 4 Apr 89 11:56 EDTMessage-ID: <890404115645.2.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say that discussion on this was broken over two days withquite a number of possible amendments discussed.I came up with a written set of amendments for Thursday which werediscarded because Moon submitted a coherent revised proposal (consistent with those amendments, and adding at least one otherfeature not covered in those separate amendments) on Thursday.The revised proposal was Moon's v3, already mailed.The revised proposal was voted on, and passed 15-1.*start*00368 00024 US GV-Info: masinter.pa at  9-Apr-89 19:19:34 from massunterDate:  9 Apr 89 19:18 PDTFrom: masinter.paSubject: Re: Issue: DESTRUCTURING-BINDIn-reply-to: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xerox's message of 4 Apr 89 08:59 PDTTo: KMP@Symbolics.COMcc: MasinterI'm missing Version 3 of DESTRUCTURING-BIND, as passed. Can you send me a copy?*start*08479 00024 US GV-Info: KMP@STONY-BROOK.SCRC.Symbolics.COM at 10-Apr-89 07:56:11 from AGReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 10 APR 89 07:56:00 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 574300; Mon 10-Apr-89 10:55:47 EDTDate: Mon, 10 Apr 89 10:54 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DESTRUCTURING-BINDTo: masinter.pacc: KMP@Symbolics.COMIn-Reply-To: <890409-191940-3353@Xerox>References: <8903292351.AA01917@mickey.ctc.contel.com>Message-ID: <890410105459.5.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 9 Apr 89 19:18 PDT    From: masinter.pa@Xerox.COM    Subject: Re: Issue: DESTRUCTURING-BIND    I'm missing Version 3 of DESTRUCTURING-BIND, as passed. Can you send me a copy?It took it a while to get to me. Maybe you have it by now, but justin case you don't, here's another copy. -kmp-----Forwarded Message Follows-----Date: Wed, 29 Mar 89 18:51:15 ESTFrom: moon@symbolics.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: DESTRUCTURING-BIND, v.3Issue:        DESTRUCTURING-BINDForum:	      CleanupReferences:   DEFMACRO (CLtL pp145-151),	      The LOOP Facility (X3J13/89-004)Category:     ADDITIONEdit history: 24-Jan-89, Version 1 by Pitman	      25-Jan-89, Version 2 by Pitman	      29-Mar-89, Version 3, by Moon, amended based on pollProblem Description:  Common Lisp programmers have frequently complained that the  destructuring facility used by DEFMACRO is not made available  for use in ordinary programming situations involving list data.  The presence of a destructuring facility in the recently adopted  LOOP facility will be likely to make the absence of a separable  destructuring facility all the more apparent.  Prior to the introduction of LET into Maclisp, many people wrote  their own LET macros. A popular expansion was in terms of a DO  which did not iterate. eg,    (LET ((A 3)) (+ A A)) ==> (DO ((A 3)) () (RETURN (+ A A)))  While this practice `worked,' it was not perspicuous and contributed   substantially to non-readability: not only were the macros hard to  understand, but the surface interface itself was not standardized  and varied in subtle ways. For example, some LET macros allowed GO  statements while others did not.  There is now considerable danger that a lot of people will write  DESTRUCTURING-BIND variants in terms of a LOOP expression that  immediately returns.    (DESTRUCTURING-BIND ((A B) C) (FOO) (LIST A B C))    ==> (LOOP FOR ((A B) C) ON (FOO) DO (RETURN (LIST A B C)))  Since the destructuring offered by LOOP is different in subtle ways  from the destructuring offered by DESTRUCTURING-BIND in implementations  offering that primitive natively, gratuitous headaches could result.Proposal (DESTRUCTURING-BIND:NEW-MACRO):  Provide a macro called DESTRUCTURING-BIND which behaves like the  destructuring bind in DEFMACRO. Specifically...  DESTRUCTURING-BIND lambda-list expression {decl}* {form}*   [Macro]   Binds the variables specified in LAMBDA-LIST to the corresponding   values in the tree structure resulting from evaluating EXPRESSION,   then evaluates the FORMS in the body.   Anywhere in the LAMBDA-LIST where a parameter name may appear, and   where ordinary lambda-list syntax (as described in CLtL section 5.2.2)   does not otherwise allow a list, a lambda-list may appear in place of   the parameter name. When this is done, then the argument form that   would match the parameter is treated as a (possibly dotted) list, to   be used as an argument forms list for satisfying the parameters in   the embedded lambda-list.   If any of the lambda list keywords &OPTIONAL, &REST, &KEY,   &ALLOW-OTHER-KEYS and &AUX appears in the lambda list, it is treated   as with any other lambda-list.   If the lambda list keyword &BODY appears, it is treated as a synonym   for &REST.   The lambda list keyword &ENVIRONMENT is not allowed.   If the lambda list keyword &WHOLE appears, it must be followed by a   single variable that is bound to the entire expression at the current   level. &WHOLE and its following variable should appear first in the   list, before any other parameter or lambda-list keyword.   It is also permissible for any level of the LAMBDA-LIST to be dotted,   ending in a parameter name. This situation is treaed exactly as if   the aprameter name that ends the list had appeared preceded by &REST   in a proper list. For example, the notation (X Y . Z) is equivalent   to (X Y &REST Z).   If the result of evaluating the expression does not match the    destructuring pattern, an error should be signaled. Test Case:  (DEFUN IOTA (N) (LOOP FOR I FROM 1 TO N COLLECT I)) ;helper  (DESTRUCTURING-BIND ((A &OPTIONAL (B 'BEE)) ONE TWO THREE)		      `((ALPHA) ,@(IOTA 3))    (LIST A B THREE TWO ONE))  => (ALPHA BEE 3 2 1)Rationale:  The proposal directly addresses the stated problem, and is current practice  in numerous implementations. Our charter effectively dictates that where  feasible we should try to head off the widespread development of uselessly  different variants of commonplace tools.   The intent of the specification is to make DESTRUCTURING-BIND lambda-lists   compatible with inner-list elements of a macro lambda-list.Current Practice:  Symbolics Genera, Envos Medley, TI Explorer, and Lucid CL all offer  DESTRUCTURING-BIND, though the details vary slightly.  The DESTRUCTURING-BIND offered by Symbolics Genera signals an error if  the pattern is not matched. The TI Explorer version does not.Cost to Implementors:  Very small. In most cases, it's a matter of renaming and/or exporting an  already existing symbol. In a few cases, a very small amount of   `program interface' code would have to be written.Cost to Users:  None. This is an upward compatible change.Cost of Non-Adoption:  Loss of the Benefits and Aesthetics cited below.Benefits:  Users will get a powerful feature they have asked for on many occassions.  In implementations which `autoload' code, it would be better for this  support to be separable so that people could do DESTRUCTURING-BIND  without demand loading all other LOOP support.Aesthetics:  Defining this macro centrally for the Common Lisp community will reduce  subtle deviations, which will in turn have positive aesthetic impact.Discussion:  JonL observes that although LOOP does destructuring, it can't directly  make use of the DESTRUCTURING-BIND interface suggested here.  Pitman and Gray think a facility of this sort is a good idea, though  obviously the details may still need a little fleshing out before the  proposal is ready for vote.  To date, the excuse for not satisfying this request has been a  religious war between factions who want to destructure lists by  writing    (DESTRUCTURING-BIND (var1 var2 var3) exp . body)  and those who want to destructure lists by writing    (DESTRUCTURING-BIND (LIST var1 var2 var3) exp . body)  The advantage of the former approach is that it is notationally  concise for the common case of destructuring a list. The disadvantage  is that it is not extensible to accomodate abstract kinds of  destructuring.  The advantage of the latter approach is that it allows interesting  extensions that accomodate data-hiding, such as:    (DEFMACRO MAKE-FOO (&REST ELEMENTS) `(LIST ,@ELEMENTS))    (DESTRUCTURING-BIND (MAKE-FOO var1 var2 var3) exp . body)  and later the ability to change the representation of a FOO without  updating the associated binding forms. The disadvantage is that it  is more verbose in the common case of destructuring a list, and still  even more verbose for nested lists.  Although destructuring has always existed in DEFMACRO, this has not  been adequate precedence for deciding the outcome of the religious war  because DEFMACRO only needs to destructure programs, and programs are  generally made up only of lists -- not arbitrary user-defined abstract  data types.  The lambda-list form of DESTRUCTURING-BIND in this version is  not completely compatible with the destructuring done by LOOP  in three areas: LOOP allows NIL elements of a list to be ignored,  LOOP does not allow &-keywords, and LOOP destructuring ignores  extra elements in the list being matched.