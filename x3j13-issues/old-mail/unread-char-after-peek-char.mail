*start*01791 00024 UU?Date: 10 Oct 88 11:03 PDTFrom: cutting.paSubject: Re: DRAFT Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 1)In-reply-to: Kent M Pitman's message of Mon, 1 Aug 88 14:32 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDU, Cutting.PA"- A misreading of the proposal might lead one to believe that one could   do (SETQ CH1 (READ-CHAR STREAM))      (SETQ CH2 (PEEK-CHAR NIL STREAM))      (SETQ CH3 (READ-CHAR STREAM))      (UNREAD-CHAR CH1 STREAM)   since the unread-char is correctly separated from the PEEK-CHAR by an   intervening READ-CHAR. The problem is that the wrong char is being   unread. Some implementations support this, but it's definitely not   condoned by the description of UNREAD-CHAR on p379."I assume that the proposal, as a clarification, is to be read in the context of CLtL.  Your example is already prohibited by CLtL, hence this proposal need not address it.There are thus a set of constraints on UNREAD-CHAR:(1) UNREAD-CHAR must only be applied to the    result of the last call to READ-CHAR;(2) UNREAD-CHAR must not be called twice in succession    without an intervening call to READ-CHAR;(3) UNREAD-CHAR must not be called after PEEK-CHAR    without an intervening call to READ-CHAR.(1) and (2) are in CLtL and (3) is my proposed clarification.Your example is prohibited by (1).  "It would be clearer for the proposal to just say that doing either a   PEEK-CHAR or READ-CHAR `commits' all previous characters. UNREAD-CHAR   on any character preceding that which is seen by the PEEK-CHAR (including   those passed over by PEEK-CHAR when `seeking' with a non-NIL first   argument) is not portable."I don't find this clearer, but I could live with it.	Doug*start*02154 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 OCT 88 11:11:13 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 10 Oct 88  11:11:08 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 10 OCT 88 11:03:04 PDTDate: 10 Oct 88 11:03 PDTFrom: cutting.paSubject: Re: DRAFT Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 1)In-reply-to: Kent M Pitman's message of Mon, 1 Aug 88 14:32 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDU, Cutting.PAMessage-ID: <881010-110304-3799@Xerox>"- A misreading of the proposal might lead one to believe that one could   do (SETQ CH1 (READ-CHAR STREAM))      (SETQ CH2 (PEEK-CHAR NIL STREAM))      (SETQ CH3 (READ-CHAR STREAM))      (UNREAD-CHAR CH1 STREAM)   since the unread-char is correctly separated from the PEEK-CHAR by an   intervening READ-CHAR. The problem is that the wrong char is being   unread. Some implementations support this, but it's definitely not   condoned by the description of UNREAD-CHAR on p379."I assume that the proposal, as a clarification, is to be read in thecontext of CLtL.  Your example is already prohibited by CLtL, hence thisproposal need not address it.There are thus a set of constraints on UNREAD-CHAR:(1) UNREAD-CHAR must only be applied to the    result of the last call to READ-CHAR;(2) UNREAD-CHAR must not be called twice in succession    without an intervening call to READ-CHAR;(3) UNREAD-CHAR must not be called after PEEK-CHAR    without an intervening call to READ-CHAR.(1) and (2) are in CLtL and (3) is my proposed clarification.Your example is prohibited by (1).  "It would be clearer for the proposal to just say that doing either a   PEEK-CHAR or READ-CHAR `commits' all previous characters. UNREAD-CHAR   on any character preceding that which is seen by the PEEK-CHAR(including   those passed over by PEEK-CHAR when `seeking' with a non-NIL first   argument) is not portable."I don't find this clearer, but I could live with it.	Doug*start*05219 00024 USfReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 22:30:34 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 8 Oct 88  22:16:04 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 473488; Sun 9-Oct-88 01:14:46 EDTDate: Sun, 9 Oct 88 01:14 EDTFrom: CL-Cleanup@SAIL.Stanford.EDUSender: KMP@STONY-BROOK.SCRC.Symbolics.COMSubject: DRAFT Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 1)To: X3J13@SAIL.Stanford.EDUcc: cutting.paReferences: <880801-102621-1527@Xerox>Message-ID: <881009011429.9.KMP@BOBOLINK.SCRC.Symbolics.COM>This is a DRAFT still under discussion. The "Additional Comments"at the end are still to be dealt with.-----Issue:         UNREAD-CHAR-AFTER-PEEK-CHARReferences:    pp 379, 380 of CLtLCategory:      CLARIFICATIONEdit history:  Version 1 by Doug Cutting <Cutting.PA@Xerox.COM> on July 29, 1988Problem description:PEEK-CHAR and UNREAD-CHAR are very similar mechanisms.  The description ofPEEK-CHAR in CLtL even states that "it is as if one had called READ-CHAR andthen UNREAD-CHAR in succession."  But while CLtL prohibits calling UNREAD-CHARtwice in succession it does not prohibit calling UNREAD-CHAR after PEEK-CHAR.The obvious implementation of PEEK-CHAR and UNREAD-CHAR (a one-character buffer)will not work unless this prohibition is present.Proposal (UNREAD-CHAR-AFTER-PEEK-CHAR:DONT-ALLOW): UNREAD-CHAR may not be calledafter PEEK-CHAR without an intervening call to READ-CHAR.Test Cases/Examples:;;; Following is an example of code which should not be valid CL.(defun test (stream) (let ((char (read-char stream)))  (peek-char nil stream)  (unread-char char stream)  (assert (eql char (read-char stream)))))Rationale:PEEK-CHAR and UNREAD-CHAR provide equivalent functionality and it is thusreasonable for an implementation to implement them in terms of the samemechanism.Current practice:In Xerox Common Lisp, different (non-random-access) stream types behavedifferently. One, (TCP/FTP) handled this correctly, while another (keyboard withline-buffering turned off) did not.Cost to Implementors:Zero.  Implementations which allow this are still correct.Cost to Users:Small.  I suspect there is very little code which depends upon this workingcorrectly, as most code uses either PEEK-CHAR or UNREAD-CHAR, but not both.Cost of non-adoption:Implementations of sequential streams are forced to be unnecessarily complex inorder to be correct.Benefits:Allows simple yet adequately powerful implementation of sequential streams.Esthetics:Requires that users have shared, one-char buffer model of how UNREAD-CHAR andPEEK-CHAR work, rather than two separate one-char buffers.Discussion:- - - - - - - - - - Additional Comments - - - - - - - - - -  - The proposal part is confusingly worded.   The wording says that in a stream "abc", if I READ-CHAR to get the #\a   into variable CH1 and then I PEEK-CHAR to see the "b", then I must call   READ-CHAR before I can (UNREAD-CHAR CH1). But if I take that literally,   I'll do (SETQ CH2 (READ-CHAR S)) (UNREAD-CHAR CH1 S) and that's not what   I want. Having done the READ-CHAR, I can only UNREAD-CHAR the char I just   did READ-CHAR to get. In effect, I can never UNREAD-CHAR CH1 once I've   peeked at or read the next char. Some streams will let me back up at this   point, but only those which would have let me back up before doing the   READ-CHAR in the first place.   It would be clearer for the proposal to just say that doing either a   PEEK-CHAR or READ-CHAR `commits' all previous characters. UNREAD-CHAR   on any character preceding that which is seen by the PEEK-CHAR (including   those passed over by PEEK-CHAR when `seeking' with a non-NIL first   argument) is not portable. - A misreading of the proposal might lead one to believe that one could   do (SETQ CH1 (READ-CHAR STREAM))      (SETQ CH2 (PEEK-CHAR NIL STREAM))      (SETQ CH3 (READ-CHAR STREAM))      (UNREAD-CHAR CH1 STREAM)   since the unread-char is correctly separated from the PEEK-CHAR by an   intervening READ-CHAR. The problem is that the wrong char is being   unread. Some implementations support this, but it's definitely not   condoned by the description of UNREAD-CHAR on p379. - I found the following test case to be more insightful:   (defun test (&optional (stream *standard-input*))     (let* ((char1a (read-char stream))	    (char2a (peek-char nil stream))	    (char1b (progn (unread-char char1a stream)			   (read-char stream)))	    (char2b (read-char stream)))       (list char1a char2a char1b char2b)))  - Current practice (for my test case above) in Symbolics Genera:     (test)ab     => (#\a #\b #\a #\b)     (with-input-from-string (s "abc") (test s))     => (#\a #\b #\a #\b)     (progn (with-open-file (s "foo.output" :direction :output)	      (write-string "abc" s))            (with-open-file (s "foo.output" :direction :input) 	      (test s)))     Signals an error about unreading #\a when #\b was already unread.*start*00797 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 19:45:12 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  18:20:35 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA28113; Thu, 13 Oct 88 17:17:32 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA20000; Thu, 13 Oct 88 17:17:30 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132317.AA20000@defun.utah.edu>Date: Thu, 13 Oct 88 17:17:29 MDTSubject: issue UNREAD-CHAR-AFTER-PEEK-CHARTo: cl-cleanup@sail.stanford.eduI agree with the stuff in the discussion section -- the basic idea isright but the wording has got to be fixed.-Sandra-------*start*01815 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 DEC 88 12:19:02 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Dec 88  12:14:31 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 DEC 88 11:59:38 PSTDate: 2 Dec 88 11:57 PSTFrom: masinter.paSubject: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)To: cl-cleanup@SAIL.Stanford.EDUcc: cutting.paMessage-ID: <881202-115938-1581@Xerox>I took KMP's wording and used it in the Proposal.  !Issue:         UNREAD-CHAR-AFTER-PEEK-CHARReferences:    pp 379, 380 of CLtLCategory:      CLARIFICATIONEdit history:  Version 1 by Doug Cutting <Cutting.PA@Xerox.COM> on July 29, 1988               Version 2 by Masinter  2-Dec-88Problem description:PEEK-CHAR and UNREAD-CHAR are very similar mechanisms.  The description ofPEEK-CHAR in CLtL even states that "it is as if one had called READ-CHAR andthen UNREAD-CHAR in succession."  But while CLtL prohibits calling UNREAD-CHARtwice in succession it does not prohibit calling UNREAD-CHAR after PEEK-CHAR.The obvious implementation of PEEK-CHAR and UNREAD-CHAR (a one-character buffer)will not work unless this prohibition is present.Proposal (UNREAD-CHAR-AFTER-PEEK-CHAR:DONT-ALLOW):    Rewrite the specification so that it is clear that doing either a   PEEK-CHAR or READ-CHAR `commits' all previous characters. UNREAD-CHAR   on any character preceding that which is seen by the PEEK-CHAR (including   those passed over by PEEK-CHAR when `seeking' with a non-NIL first   argument) is not specified.   In particular, the results of calling  UNREAD-CHAR after PEEK-CHAR   is unspecified.Example:   (defun test (&optional (stream *standard-input*start*03613 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 DEC 88 12:19:02 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Dec 88  12:14:31 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 DEC 88 11:59:38 PSTDate: 2 Dec 88 11:57 PSTFrom: masinter.paSubject: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)To: cl-cleanup@SAIL.Stanford.EDUcc: cutting.paMessage-ID: <881202-115938-1581@Xerox>I took KMP's wording and used it in the Proposal.  !Issue:         UNREAD-CHAR-AFTER-PEEK-CHARReferences:    pp 379, 380 of CLtLCategory:      CLARIFICATIONEdit history:  Version 1 by Doug Cutting <Cutting.PA@Xerox.COM> on July 29, 1988               Version 2 by Masinter  2-Dec-88Problem description:PEEK-CHAR and UNREAD-CHAR are very similar mechanisms.  The description ofPEEK-CHAR in CLtL even states that "it is as if one had called READ-CHAR andthen UNREAD-CHAR in succession."  But while CLtL prohibits calling UNREAD-CHARtwice in succession it does not prohibit calling UNREAD-CHAR after PEEK-CHAR.The obvious implementation of PEEK-CHAR and UNREAD-CHAR (a one-character buffer)will not work unless this prohibition is present.Proposal (UNREAD-CHAR-AFTER-PEEK-CHAR:DONT-ALLOW):    Rewrite the specification so that it is clear that doing either a   PEEK-CHAR or READ-CHAR `commits' all previous characters. UNREAD-CHAR   on any character preceding that which is seen by the PEEK-CHAR (including   those passed over by PEEK-CHAR when `seeking' with a non-NIL first   argument) is not specified.   In particular, the results of calling  UNREAD-CHAR after PEEK-CHAR   is unspecified.Example:   (defun test (&optional (stream *standard-input*))     (let* ((char1a (read-char stream))		    (char2a (peek-char nil stream))	    (char1b (progn (unread-char char1a stream)			   (read-char stream)))	    (char2b (read-char stream)))       (list char1a char2a char1b char2b)))This is not legal, since the PEEK-CHAR for char2a "commits"the character read by char1a, and so the unread-char is not legal.Rationale:PEEK-CHAR and UNREAD-CHAR provide equivalent functionality and it is thusreasonable for an implementation to implement them in terms of the samemechanism.Current practice:In Xerox Common Lisp, different (non-random-access) stream types behavedifferently. One, (TCP/FTP) handled this correctly, while another did not.In Symbolics Genera, for the Example above:     (test)ab     => (#\a #\b #\a #\b)     (with-input-from-string (s "abc") (test s))     => (#\a #\b #\a #\b)     (progn (with-open-file (s "foo.output" :direction :output)	      (write-string "abc" s))            (with-open-file (s "foo.output" :direction :input) 	      (test s)))     Signals an error about unreading #\a when #\b was already unread.Cost to Implementors:Presumably none.  Implementations which allow this are still correct.Cost to Users:Small.  I suspect there is very little code which depends upon this workingcorrectly, as most code uses either PEEK-CHAR or UNREAD-CHAR, but not both.Cost of non-adoption:Implementations of sequential streams are forced to be unnecessarily complex inorder to be correct.Benefits:Allows simple yet adequately powerful implementation of sequential streams.Esthetics:Requires that users have shared, one-char buffer model of how UNREAD-CHAR andPEEK-CHAR work, rather than two separate one-char buffers.Discussion:     ----- End Forwarded Messages -----*start*00898 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 DEC 88 22:42:36 PSTReceived: from RELAY.CS.NET (GW1.CS.NET) by SAIL.Stanford.EDU with TCP; 4 Dec 88  22:40:54 PSTReceived: from relay2.cs.net by RELAY.CS.NET id af12775; 5 Dec 88 0:04 ESTReceived: from draper.com by RELAY.CS.NET id ae10454; 4 Dec 88 23:59 ESTDate: Sun, 4 Dec 88 23:27 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)To: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525I am in favor of this, and am glad to see this point brought up.  In fact,I would go further and make it an error to issue UNREAD-CHAR after PEEK-CHARin general.  Semantics of file and non-file streams should be identical,as much as is practical.*start*01315 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 16:12:00 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  16:11:08 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 16:06:49 PSTDate: 9 Dec 88 16:06 PSTFrom: masinter.paSubject: Re: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)In-reply-to: masinter.pa's message of 2 Dec 88 11:57 PSTTo: cl-cleanup@SAIL.Stanford.EDU, cutting.paMessage-ID: <881209-160649-1345@Xerox>My copy of version 2 of this proposal has been smashed. (I hope this didn'thappen to other bits of mail.I might be able to dig it out of the archive on Sail, but do any of youhave it handy?The header was:Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 DEC 8812:19:02 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Dec 88  12:14:31PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 DEC 88 11:59:38 PSTDate: 2 Dec 88 11:57 PSTFrom: masinter.paSubject: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)To: cl-cleanup@SAIL.Stanford.EDUcc: cutting.paMessage-ID: <881202-115938-1581@Xerox>*start*04182 00024 US Return-Path: <gsb@ALDERAAN.SCRC.Symbolics.COM>Received: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by Xerox.COM ; 09 DEC 88 16:53:04 PSTReceived: from GANG-GANG.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 250396; Fri 9-Dec-88 19:53:28 ESTDate: Fri, 9 Dec 88 19:53 ESTFrom: Glenn S. Burke <gsb@ALDERAAN.SCRC.Symbolics.COM>Subject: Re: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)To: masinter.paIn-Reply-To: <881209-160649-1345@Xerox>Message-ID: <19881210005320.7.GSB@GANG-GANG.SCRC.Symbolics.COM>Return-path: <CL-Cleanup-mailer@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 502038; 2 Dec 88 15:20:47 ESTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Dec 88  12:14:31 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 DEC 88 11:59:38 PSTDate: 2 Dec 88 11:57 PSTFrom: masinter.pa@Xerox.COMSubject: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)To: cl-cleanup@SAIL.Stanford.EDUcc: cutting.pa@Xerox.COMMessage-ID: <881202-115938-1581@Xerox>I took KMP's wording and used it in the Proposal.  !Issue:         UNREAD-CHAR-AFTER-PEEK-CHARReferences:    pp 379, 380 of CLtLCategory:      CLARIFICATIONEdit history:  Version 1 by Doug Cutting <Cutting.PA@Xerox.COM> on July 29, 1988               Version 2 by Masinter  2-Dec-88Problem description:PEEK-CHAR and UNREAD-CHAR are very similar mechanisms.  The description ofPEEK-CHAR in CLtL even states that "it is as if one had called READ-CHAR andthen UNREAD-CHAR in succession."  But while CLtL prohibits calling UNREAD-CHARtwice in succession it does not prohibit calling UNREAD-CHAR after PEEK-CHAR.The obvious implementation of PEEK-CHAR and UNREAD-CHAR (a one-character buffer)will not work unless this prohibition is present.Proposal (UNREAD-CHAR-AFTER-PEEK-CHAR:DONT-ALLOW):    Rewrite the specification so that it is clear that doing either a   PEEK-CHAR or READ-CHAR `commits' all previous characters. UNREAD-CHAR   on any character preceding that which is seen by the PEEK-CHAR (including   those passed over by PEEK-CHAR when `seeking' with a non-NIL first   argument) is not specified.   In particular, the results of calling  UNREAD-CHAR after PEEK-CHAR   is unspecified.Example:   (defun test (&optional (stream *standard-input*))     (let* ((char1a (read-char stream))		    (char2a (peek-char nil stream))	    (char1b (progn (unread-char char1a stream)			   (read-char stream)))	    (char2b (read-char stream)))       (list char1a char2a char1b char2b)))This is not legal, since the PEEK-CHAR for char2a "commits"the character read by char1a, and so the unread-char is not legal.Rationale:PEEK-CHAR and UNREAD-CHAR provide equivalent functionality and it is thusreasonable for an implementation to implement them in terms of the samemechanism.Current practice:In Xerox Common Lisp, different (non-random-access) stream types behavedifferently. One, (TCP/FTP) handled this correctly, while another did not.In Symbolics Genera, for the Example above:     (test)ab     => (#\a #\b #\a #\b)     (with-input-from-string (s "abc") (test s))     => (#\a #\b #\a #\b)     (progn (with-open-file (s "foo.output" :direction :output)	      (write-string "abc" s))            (with-open-file (s "foo.output" :direction :input) 	      (test s)))     Signals an error about unreading #\a when #\b was already unread.Cost to Implementors:Presumably none.  Implementations which allow this are still correct.Cost to Users:Small.  I suspect there is very little code which depends upon this workingcorrectly, as most code uses either PEEK-CHAR or UNREAD-CHAR, but not both.Cost of non-adoption:Implementations of sequential streams are forced to be unnecessarily complex inorder to be correct.Benefits:Allows simple yet adequately powerful implementation of sequential streams.Esthetics:Requires that users have shared, one-char buffer model of how UNREAD-CHAR andPEEK-CHAR work, rather than two separate one-char buffers.Discussion:     ----- End Forwarded Messages -----*start*03900 00024 US Return-Path: <@multimax.encore.com:pierson@mist.encore.com>Received: from multimax.encore.com ([192.5.63.14]) by Xerox.COM ; 12 DEC 88 09:29:04 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA00386; Mon, 12 Dec 88 12:28:28 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA10711; Mon, 12 Dec 88 11:02:21 ESTMessage-Id: <8812121602.AA10711@mist.>To: masinter.paSubject: [masinter.pa@Xerox.COM: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)]Date: Mon, 12 Dec 88 11:02:19 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>------- Forwarded MessageDate: 2 Dec 88 11:57 PSTFrom: masinter.pa@Xerox.COMSubject: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)To: cl-cleanup@SAIL.Stanford.EDUCc: cutting.pa@Xerox.COMI took KMP's wording and used it in the Proposal.  !Issue:         UNREAD-CHAR-AFTER-PEEK-CHARReferences:    pp 379, 380 of CLtLCategory:      CLARIFICATIONEdit history:  Version 1 by Doug Cutting <Cutting.PA@Xerox.COM> on July 29, 1988               Version 2 by Masinter  2-Dec-88Problem description:PEEK-CHAR and UNREAD-CHAR are very similar mechanisms.  The description ofPEEK-CHAR in CLtL even states that "it is as if one had called READ-CHAR andthen UNREAD-CHAR in succession."  But while CLtL prohibits calling UNREAD-CHARtwice in succession it does not prohibit calling UNREAD-CHAR after PEEK-CHAR.The obvious implementation of PEEK-CHAR and UNREAD-CHAR (a one-characterbuffer) will not work unless this prohibition is present.Proposal (UNREAD-CHAR-AFTER-PEEK-CHAR:DONT-ALLOW):    Rewrite the specification so that it is clear that doing either a   PEEK-CHAR or READ-CHAR `commits' all previous characters. UNREAD-CHAR   on any character preceding that which is seen by the PEEK-CHAR (including   those passed over by PEEK-CHAR when `seeking' with a non-NIL first   argument) is not specified.   In particular, the results of calling  UNREAD-CHAR after PEEK-CHAR   is unspecified.Example:   (defun test (&optional (stream *standard-input*))     (let* ((char1a (read-char stream))		    (char2a (peek-char nil stream))	    (char1b (progn (unread-char char1a stream)			   (read-char stream)))	    (char2b (read-char stream)))       (list char1a char2a char1b char2b)))This is not legal, since the PEEK-CHAR for char2a "commits"the character read by char1a, and so the unread-char is not legal.Rationale:PEEK-CHAR and UNREAD-CHAR provide equivalent functionality and it is thusreasonable for an implementation to implement them in terms of the samemechanism.Current practice:In Xerox Common Lisp, different (non-random-access) stream types behavedifferently. One, (TCP/FTP) handled this correctly, while another did not.In Symbolics Genera, for the Example above:     (test)ab     => (#\a #\b #\a #\b)     (with-input-from-string (s "abc") (test s))     => (#\a #\b #\a #\b)     (progn (with-open-file (s "foo.output" :direction :output)	      (write-string "abc" s))            (with-open-file (s "foo.output" :direction :input) 	      (test s)))     Signals an error about unreading #\a when #\b was already unread.Cost to Implementors:Presumably none.  Implementations which allow this are still correct.Cost to Users:Small.  I suspect there is very little code which depends upon this workingcorrectly, as most code uses either PEEK-CHAR or UNREAD-CHAR, but not both.Cost of non-adoption:Implementations of sequential streams are forced to be unnecessarily complex inorder to be correct.Benefits:Allows simple yet adequately powerful implementation of sequential streams.Esthetics:Requires that users have shared, one-char buffer model of how UNREAD-CHAR andPEEK-CHAR work, rather than two separate one-char buffers.Discussion:     ----- End Forwarded Messages ------------ End of Forwarded Message*start*05258 00024 US Date: 12 Dec 88 16:17 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noIssue:         UNREAD-CHAR-AFTER-PEEK-CHARReferences:    pp 379, 380 of CLtLCategory:      CLARIFICATIONEdit history:  Version 1 by Doug Cutting <Cutting.PA@Xerox.COM> on July 29, 1988               Version 2 by Masinter  2-Dec-88Problem description:PEEK-CHAR and UNREAD-CHAR are very similar mechanisms.  The description ofPEEK-CHAR in CLtL even states that "it is as if one had called READ-CHAR andthen UNREAD-CHAR in succession."  But while CLtL prohibits calling UNREAD-CHARtwice in succession it does not prohibit calling UNREAD-CHAR after PEEK-CHAR.The obvious implementation of PEEK-CHAR and UNREAD-CHAR (a one-character buffer)will not work unless this prohibition is present.Proposal (UNREAD-CHAR-AFTER-PEEK-CHAR:DONT-ALLOW):    Rewrite the specification so that it is clear that doing either a   PEEK-CHAR or READ-CHAR `commits' all previous characters. UNREAD-CHAR   on any character preceding that which is seen by the PEEK-CHAR (including   those passed over by PEEK-CHAR when `seeking' with a non-NIL first   argument) is not specified.   In particular, the results of calling  UNREAD-CHAR after PEEK-CHAR   is unspecified.Example:   (defun test (&optional (stream *standard-input*))     (let* ((char1a (read-char stream))		    (char2a (peek-char nil stream))	    (char1b (progn (unread-char char1a stream)			   (read-char stream)))	    (char2b (read-char stream)))       (list char1a char2a char1b char2b)))This is not legal, since the PEEK-CHAR for char2a "commits"the character read by char1a, and so the unread-char is not legal.Rationale:PEEK-CHAR and UNREAD-CHAR provide equivalent functionality and it is thusreasonable for an implementation to implement them in terms of the samemechanism.Current practice:In Xerox Common Lisp, different (non-random-access) stream types behavedifferently. One, (TCP/FTP) handled this correctly, while another did not.In Symbolics Genera, for the Example above:     (test)ab     => (#\a #\b #\a #\b)     (with-input-from-string (s "abc") (test s))     => (#\a #\b #\a #\b)     (progn (with-open-file (s "foo.output" :direction :output)	      (write-string "abc" s))            (with-open-file (s "foo.output" :direction :input) 	      (test s)))     Signals an error about unreading #\a when #\b was already unread.Cost to Implementors:Presumably none.  Implementations which allow this are still correct.Cost to Users:Small.  I suspect there is very little code which depends upon this workingcorrectly, as most code uses either PEEK-CHAR or UNREAD-CHAR, but not both.Cost of non-adoption:Implementations of sequential streams are forced to be unnecessarily complex inorder to be correct.Benefits:Allows simple yet adequately powerful implementation of sequential streams.Esthetics:Requires that users have shared, one-char buffer model of how UNREAD-CHAR andPEEK-CHAR work, rather than two separate one-char buffers.Discussion:<none>       ,                                         ,                                                TITAN 
          TITAN 
                                                                                  #             '                                                                                                                                                                                        B             /                                                    K             M             O             N             Q             2                          4                          E             I             M             F                                       F                                       	                          5             )             %             0                          "             ,                                       <             C                                                    J             H                                                                 H             K                          ,                                                                 1                                       @                          @                          G                                                                 F                                                    L             L                                                    P                                       
                          L                                                    N             ;                                                                ” Ûzº*start*03570 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 16:38:36 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  16:22:49 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 16:17:33 PSTDate: 12 Dec 88 16:17 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: UNREAD-CHAR-AFTER-PEEK-CHAR (Version 2)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-161733-5559@Xerox>!Issue:         UNREAD-CHAR-AFTER-PEEK-CHARReferences:    pp 379, 380 of CLtLCategory:      CLARIFICATIONEdit history:  Version 1 by Doug Cutting <Cutting.PA@Xerox.COM> on July 29, 1988               Version 2 by Masinter  2-Dec-88Problem description:PEEK-CHAR and UNREAD-CHAR are very similar mechanisms.  The description ofPEEK-CHAR in CLtL even states that "it is as if one had called READ-CHAR andthen UNREAD-CHAR in succession."  But while CLtL prohibits calling UNREAD-CHARtwice in succession it does not prohibit calling UNREAD-CHAR after PEEK-CHAR.The obvious implementation of PEEK-CHAR and UNREAD-CHAR (a one-character buffer)will not work unless this prohibition is present.Proposal (UNREAD-CHAR-AFTER-PEEK-CHAR:DONT-ALLOW):    Rewrite the specification so that it is clear that doing either a   PEEK-CHAR or READ-CHAR `commits' all previous characters. UNREAD-CHAR   on any character preceding that which is seen by the PEEK-CHAR (including   those passed over by PEEK-CHAR when `seeking' with a non-NIL first   argument) is not specified.   In particular, the results of calling  UNREAD-CHAR after PEEK-CHAR   is unspecified.Example:   (defun test (&optional (stream *standard-input*))     (let* ((char1a (read-char stream))		    (char2a (peek-char nil stream))	    (char1b (progn (unread-char char1a stream)			   (read-char stream)))	    (char2b (read-char stream)))       (list char1a char2a char1b char2b)))This is not legal, since the PEEK-CHAR for char2a "commits"the character read by char1a, and so the unread-char is not legal.Rationale:PEEK-CHAR and UNREAD-CHAR provide equivalent functionality and it is thusreasonable for an implementation to implement them in terms of the samemechanism.Current practice:In Xerox Common Lisp, different (non-random-access) stream types behavedifferently. One, (TCP/FTP) handled this correctly, while another did not.In Symbolics Genera, for the Example above:     (test)ab     => (#\a #\b #\a #\b)     (with-input-from-string (s "abc") (test s))     => (#\a #\b #\a #\b)     (progn (with-open-file (s "foo.output" :direction :output)	      (write-string "abc" s))            (with-open-file (s "foo.output" :direction :input) 	      (test s)))     Signals an error about unreading #\a when #\b was already unread.Cost to Implementors:Presumably none.  Implementations which allow this are still correct.Cost to Users:Small.  I suspect there is very little code which depends upon this workingcorrectly, as most code uses either PEEK-CHAR or UNREAD-CHAR, but not both.Cost of non-adoption:Implementations of sequential streams are forced to be unnecessarily complex inorder to be correct.Benefits:Allows simple yet adequately powerful implementation of sequential streams.Esthetics:Requires that users have shared, one-char buffer model of how UNREAD-CHAR andPEEK-CHAR work, rather than two separate one-char buffers.Discussion:<none>