*start*02406 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 04 JAN 88 18:34:20 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 4 Jan 88  18:32:43 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 314827; Mon 4-Jan-88 21:32:30 ESTDate: Mon, 4 Jan 88 21:31 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: &REST listsTo: Fahlman@C.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12364037774.BABYL@C.CS.CMU.EDU>Message-ID: <880104213156.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>[Common-Lisp removed; I can't bear to be heard by such multitudes. CL-Cleanup added.]    Date: Mon, 4 Jan 1988  20:27 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>	Is there general agreement on whether it is valid Common Lisp to	destructively modify (RPLACA, RPLACD) the list to which a &REST	parameter is bound?  I can't find a reference in CLtL for this.    I think there's general agreement that &rest args are supposed to be    righteous lists with indefinite extent, so RPLAC'ing them ought to be    legal.    However, this was one part of the Common Lisp spec that several early    implementations deliberately chose to deviate from in the interest of    greater efficiency.  (Symbolics and TI were able to gain considerable    efficiency by consing rest args on the stack.)  Both companies had plans    to fix this eventually, stack-consing only when the compiler could prove    it was safe to do so, but I don't know if this has finally been    accomplished and distributed to all users.I think TI has already fixed it. Symbolics' Cloe also fixes it.Symbolics Genera plans to fix it at some unspecified future date.But anyway, the rplaca/rplacd problem is not related to the issue of stackallocation. It's the following problem, which comes up in conventionalarchitectures as well: (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*)) (APPLY #'FOO *MY-LIST*) => T ;on Symbolics systems and probably			      ; many stock hardware implementationsThis implies that (DEFUN BAR (&REST X) (RPLACA X 'D)) (APPLY #'BAR *MY-LIST*) *MY-LIST* => (D B C) ;on Symbolics systems and probably many stock		      ; hardware implementations*start*02275 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 04 JAN 88 20:37:36 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 4 Jan 88  20:35:28 PSTReceived: by labrea.stanford.edu; Mon, 4 Jan 88 20:35:23 PSTReceived: from kent-state.lucid.com by edsel id AA13360g; Mon, 4 Jan 88 20:27:31 PSTReceived: by kent-state id AA00227g; Mon, 4 Jan 88 20:29:31 PSTDate: Mon, 4 Jan 88 20:29:31 PSTFrom: Eric Benson <edsel!eb@labrea.stanford.edu>Message-Id: <8801050429.AA00227@kent-state.lucid.com>To: KMP@stony-brook.scrc.symbolics.comCc: Fahlman@c.cs.cmu.edu, CL-Cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Mon, 4 Jan 88 21:31 EST <880104213156.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Subject: &REST lists   Date: Mon, 4 Jan 88 21:31 EST   From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>       Date: Mon, 4 Jan 1988  20:27 EST       From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>	   Is there general agreement on whether it is valid Common Lisp to	   destructively modify (RPLACA, RPLACD) the list to which a &REST	   parameter is bound?  I can't find a reference in CLtL for this.       I think there's general agreement that &rest args are supposed to be       righteous lists with indefinite extent, so RPLAC'ing them ought to be       legal.       ...   I think TI has already fixed it. Symbolics' Cloe also fixes it.   Symbolics Genera plans to fix it at some unspecified future date.   But anyway, the rplaca/rplacd problem is not related to the issue of stack   allocation. It's the following problem, which comes up in conventional   architectures as well:    (DEFVAR *MY-LIST* '(A B C))    (DEFUN FOO (&REST X) (EQ X *MY-LIST*))    (APPLY #'FOO *MY-LIST*) => T ;on Symbolics systems and probably				 ; many stock hardware implementations   This implies that    (DEFUN BAR (&REST X) (RPLACA X 'D))    (APPLY #'BAR *MY-LIST*)    *MY-LIST* => (D B C) ;on Symbolics systems and probably many stock			 ; hardware implementationsThe Revised­3 Report on Scheme specifies that the equivalent of a&REST argument must be a newly allocated list, to avoid precisely thisproblem.*start*00448 00024 US Date:  5 Feb 88 16:14 PSTFrom: Masinter.paSubject: Issue: REST-LIST-ALLOCATIONto: masinterThis is the issue name for whether &REST lists are newly allocated if RPLACDAd.Subject: Re: &REST listsIn-reply-to: Eric Benson <edsel!eb@labrea.stanford.edu>'s message of Mon, 4 Jan 88 20:29:31 PSTTo: edsel!eb@labrea.stanford.educc: KMP@stony-brook.scrc.symbolics.com, Fahlman@c.cs.cmu.edu, CL-Cleanup@sail.stanford.edu*start*03523 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 19 Mar 88 14:51From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: &REST argsIn-Reply-to: <19880317053813.3.HORNIG@WINTER.SCRC.Symbolics.COM>To: Hornig%ALDERAAN.SCRC.Symbolics:COM:Xerox, jbarnett%nrtc.northrop:COM:Xerox, goldman%vaxa.isi:EDU:Xerox, common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: &REST argsTo: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>, Jeff Barnett <jbarnett@nrtc.northrop.com>, goldman@vaxa.isi.edu, common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <19880317053813.3.HORNIG@WINTER.SCRC.Symbolics.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 19 MAR 88 14:51:51 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 19 Mar 88  14:04:29 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 366372; Sat 19-Mar-88 17:04:33 ESTOriginal-Date: Sat, 19 Mar 88 17:04 ESTMessage-ID: <19880319220430.6.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 17 Mar 88 00:38 EST    From: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>    Yes, declarations would be a good thing if we decide that Common Lisp    permits valid programs to store pointers to or to destructively modify    &REST arguments.  If we decide that Common Lisp does not permit it, or    leaves the result undefined (which is another way of saying the same    thing), then there is no need for declarations.Agreed.    I believe that there is general agreement that one is allowed to save    pointers to &REST arguments.Agreed.    There seems to be no agreement about destructive modification.The X3J13 Cleanup subcommittee has taken on this issue.  We discussedit at a meeting on Tuesday and will be discussing it further.  It's likelythat X3J13 will make a decision on this issue in June.  Of course, nothingX3J13 decides is final until a language specification is created, acceptedby written ballot, and reported out of the X3J13 committee to the parentstandards organizations.    I, personally, believe that destructive    modification should be permitted and that the language implementation    must guarantee that this will not currupt structures passed as APPLY    arguments.  This guarantee can be done through declarations, code    analysis, or just consing a lot.  For the record, I strongly disagree with this.  I believe Common Lisp shouldspecify that the value of an &REST parameter is permitted, but not required,to share structure with the last argument to APPLY.  I have two reasons forthis belief (both of which have come up on the mailing list before).1. In no other place does Common Lisp automatically unshare structure,except when the user is explicitly modifying the structure (as in REMOVE).Making APPLY automatically unshare would be a semantic wart.2. If APPLY copies its last argument, recursive programs that receive an&REST argument and pass it to APPLY become inefficient.  A linear timealgorithm can change to a quadratic time algorithm.  While the efficiencycould be regained through compiler flow analysis in many cases, I thinkit's better not to put the inefficiency into the language in the firstplace.*start*03791 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 20 Mar 88 02:09From: "mcvax!pilatus!ceb%uunet.UU.NET":GV:XeroxIn-Reply-to: Barry Margolin's message of Sat, 19 Mar 88 04:55:38 estSubject: &rest lists should not be copiedTo: barmar%think:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 20 MAR 88 02:09:15 PSTReceived: from uunet.UU.NET by SAIL.Stanford.EDU with TCP; 19 Mar 88  23:04:34 PSTReceived: from mcvax.UUCP by uunet.UU.NET (5.54/1.14) with UUCP 	id AA07506; Sun, 20 Mar 88 02:05:03 ESTReceived: by mcvax.cwi.nl; Sun, 20 Mar 88 07:49:03 +0100 (MET)Received: by cernvax.uucp (1.2/Ultrix2.0-B)	id AA24818; Sun, 20 Mar 88 07:03:27 +0100Original-Date: Sun, 20 Mar 88 07:03:27 +0100Message-Id: <8803200603.AA24818@cernvax.uucp>   Date: Sat, 19 Mar 88 04:55:38 est   From: Barry Margolin <cernvax!mcvax!Think.COM!barmar>      From: mcvax!pilatus!ceb@uunet.uu.net      Date: Sun, 13 Mar 88 13:22:44 +0100      If you want to be able to freely modify the structures which are      used to implement these features, something imbedded in the kernel of      the language is going to have to *copy* them.     While this is true, it is not really significant.    . . . &REST lists, however, have the additional potential   for being EQ with the list passed as the last argument to APPLY, and   this is what needs to be specified more carefully.. . . as they should.  What made me write were suggestions that the*default* behavior be (at least top-level) cons structure copying.  Iwanted to demonstrate that this could be potentially expensive, but Iguess it was counter-productive to draw in the issue of lower-levelcopying.  Anyhow, even enforcing only top-level copying, even if yourestrict yourself to rest lists of "reasonable" size, can cost manyconses, and should not be forced upon you.  Assuming bothkinds of behavior are desirable; one only should ask:1. Which one should be the default?2. How do you specify your choice?A number have written drawing attention to existing or proposed(mainly declare) forms to accomplish this.  As I understand thesethough, I don't like them because:1. The default behavior is copying, the more expensive of the two.2, If the default behavior were not to copy, it would not cost much   if at all more to ask for copying explicitly with a (let . . .   (copy-list <rest-arg-list>) construct.  Burying such stuff away in    the guts of a language only bring about over-use.  On the other   hand, explicit mention has positive effects on user optimization.3. One should avoid fueling the "there's too much junk in common-lisp"   fire whenever possible.4. Declare forms are reminiscent of other programming languages I   switched *from* to come to Lisp.  I accept them as means for   advising the compiler to obtain faster compiled code, as long as I can   safely ignore them when rapid prototyping.  However, at issue here   is averting potentially incorrect behavior (I include cancer-like   consing in this), regardless of whether you run interpreted or compiled.About the only real efficiency argument I have been able to drum upfor intervening at the moment of function invocation (as opposed towithin the called function body) is that stack consing might becheaper than general consing (even if you cdr code?).  If this isreally a consideration, then why not simply add keywords to apply andfriends, such as :stack-copy-args and/or :copy-args, with defaults setup reasonably?This would keep all of the strangeness in source code *and* and inthe compiler localized to the trouble point (within apply).ceb*start*02098 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 17 Mar 88 05:41From: Hornig%ALDERAAN.SCRC.Symbolics:COM:XeroxSubject: &REST argsIn-Reply-to: The message of 16 Mar 88 18:35 EST from Jeff Barnett <jbarnett@nrtc.northrop.com>,             <8803To: jbarnett%nrtc.northrop:COM:Xerox, goldman%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>Subject: &REST argsTo: Jeff Barnett <jbarnett@nrtc.northrop.com>, goldman@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: The message of 16 Mar 88 18:35 EST from Jeff Barnett <jbarnett@nrtc.northrop.com>,             <8803162317.AA14565@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 17 MAR 88 05:41:29 PSTReceived: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by SAIL.Stanford.EDU with TCP; 17 Mar 88  05:11:18 PSTReceived: from WINTER.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 179199; Thu 17-Mar-88 07:47:51 ESTOriginal-Date: Thu, 17 Mar 88 00:38 ESTMessage-ID: <19880317053813.3.HORNIG@WINTER.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVYes, declarations would be a good thing if we decide that Common Lisppermits valid programs to store pointers to or to destructively modify&REST arguments.  If we decide that Common Lisp does not permit it, orleaves the result undefined (which is another way of saying the samething), then there is no need for declarations.I believe that there is general agreement that one is allowed to savepointers to &REST arguments.  There seems to be no agreement aboutdestructive modification.  I, personally, believe that destructivemodification should be permitted and that the language implementationmust guarantee that this will not currupt structures passed as APPLYarguments.  This guarantee can be done through declarations, codeanalysis, or just consing a lot.  *start*02026 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 18 Mar 88 16:35From: Shane%JASPER.Palladian:COM:XeroxSubject: &REST argsIn-Reply-to: The message of 16 Mar 88 18:35 EST from Jeff Barnett <jbarnett@nrtc.northrop.com>To: jbarnett%nrtc.northrop:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: K. Shane Hartman <Shane@JASPER.Palladian.COM>Subject: &REST argsTo: jbarnett@nrtc.northrop.comcc: common-lisp@sail.stanford.eduIn-Reply-To: The message of 16 Mar 88 18:35 EST from Jeff Barnett <jbarnett@nrtc.northrop.com>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 18 MAR 88 16:35:33 PSTReceived: from XX.LCS.MIT.EDU by SAIL.Stanford.EDU with TCP; 18 Mar 88  14:44:08 PSTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 18 Mar 88 17:45-ESTReceived: from JASPER.Palladian.COM (JASPER.Palladian.COM) by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 84701; 18 Mar 88 17:35:44-ESTReceived: from KITTYHAWK.Palladian.COM by JASPER.Palladian.COM via CHAOS with CHAOS-MAIL id 27421; Fri 18-Mar-88 17:30:36 ESTOriginal-Date: Fri, 18 Mar 88 17:30 ESTMessage-ID: <880318173025.0.SHANE@KITTYHAWK.Palladian.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date:     Wed, 16 Mar 88 15:35:28 PST    From:     Jeff Barnett <jbarnett@nrtc.northrop.com>    In regards to the properties of &REST arguments:  There may be a way to    have our cake and eat it too given that CL has a declaration mechanism    in place already and optimization hints are considered first class citizens.    I propose an anology to the SYS:DOWNWARD-FUNCTION and SYS:DOWNWARD-FUNARG    decls in the Symbolics implementations.  In the function  with the &REST arg,    that arg could be declared DOWNWARD meaning that pointers to it and top-levelLucid uses the declaration DYNAMIC-EXTENT for this purpose.  -[Shane]->*start*02437 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 19 Mar 88 02:55From: barmar%Think:COM:XeroxIn-Reply-to: mcvax!pilatus!ceb@uunet.uu.net's message of Sun, 13 Mar 88 13:22:44 +0100 <8803131222.AA20860@cernvaSubject: &rest lists and other things ground through function applicationTo: "mcvax!pilatus!ceb%uunet.uu.net":GV:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>To: mcvax!pilatus!ceb@uunet.uu.netCc: common-lisp@sail.stanford.eduIn-Reply-To: mcvax!pilatus!ceb@uunet.uu.net's message of Sun, 13 Mar 88 13:22:44 +0100 <8803131222.AA20860@cernvax.uucp>Subject: &rest lists and other things ground through function applicationReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 19 MAR 88 02:55:17 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 19 Mar 88  01:56:20 PSTReturn-Path: <barmar@Think.COM>Received: from pozzo.think.com by Think.COM; Sat, 19 Mar 88 04:55:44 ESTReceived: by pozzo.think.com; Sat, 19 Mar 88 04:55:38 estOriginal-Date: Sat, 19 Mar 88 04:55:38 estMessage-Id: <8803190955.AA09901@pozzo.think.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV   From: mcvax!pilatus!ceb@uunet.uu.net   Date: Sun, 13 Mar 88 13:22:44 +0100   If you want to be able to freely modify the structures which are   used to implement these features, something imbedded in the kernel of   the language is going to have to *copy* them.     You could do a top-level copy, but then you are still not protected if   someone does a (setf (cadr passed-argument-structure 'truc).  In order   to beat this, you have to do an arbitrary depth copy, and then, when   you pass tangled, circular, non-ending horrible things which make   print go bananas (I do this often), you have to do circular list   detection, etc. . . . and you very quickly get into a game which can't   be won.While this is true, it is not really significant.  In the case of thesubstructure, this is no different from ordinary arguments - the Nthparameter seen by a function is always EQL to the Nth argument passedto the function.  &REST lists, however, have the additional potentialfor being EQ with the list passed as the last argument to APPLY, andthis is what needs to be specified more carefully.						barmar*start*05724 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 23 Mar 88 20:07From: barmar%Think:COM:XeroxSubject: &Rest ListsIn-Reply-to: <8803232113.AA02705@Think.COM>To: ELIOT%cs.umass:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: &Rest ListsTo: ELIOT@cs.umass.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: <8803232113.AA02705@Think.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAR 88 20:07:11 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 23 Mar 88  17:31:21 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Wed, 23 Mar 88 20:30:47 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Wed, 23 Mar 88 20:30:43 ESTOriginal-Date: Wed, 23 Mar 88 20:31 ESTMessage-Id: <19880324013118.3.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Wed, 23 Mar 88 12:50 EDT    From: ELIOT@cs.umass.edu       From:	IN%"Moon@SCRC-STONY-BROOK.ARPA"  "David A. Moon" 20-MAR-1988 08:07       Subj:	&REST args       As I stated in an earlier message I think that Common    Lisp should prohibit sharing of list structure in the last argument    to APPLY.          1. In no other place does Common Lisp automatically unshare structure,       except when the user is explicitly modifying the structure (as in REMOVE).       Making APPLY automatically unshare would be a semantic wart.    Common Lisp does commit itself to doing whatever has to be done so that    interpreted and compiled code behaves the same.  How did the compiler/interpreter distinction enter into this?  No onehas proposed distinguishing them.  In the environment I use, they bothbehave the same regarding &rest lists.  And even so, the compiler andinterpreter are allowed to have different ways of dealing with asituation that is undefined ("is an error", to use CLtL wording),because portable applications are not permitted to depend on thebehavior in such situations.						     Actually I don't care    whether that last argument to APPLY can be shared.  But I stongly    believe that Common Lisp should do whatever has to be done so that    all variants of the same function call are equivalent.  Consider:    (setq x '(1 2 3))    [1] (apply #'foo 1 2 3 NIL)    [2] (apply #'foo 1 2 (cddr x))    [3] (apply #'foo 1 (cdr x))    [4] (apply #'foo x)    [5] (funcall #'foo 1 2 3)    [6] (eval (cons 'foo x))    [7] (eval (list 'foo 1 2 3))    [8] (foo 1 2 3)    I strongly believe that all of [1-8] are the same function call and    must have the same semantics.  Since the list, x, cannot be modified by    [1, 5, 7, 8]  it should not be allowed to modify it in [2, 3, 4, 6].I disagree with this.  [5, 7, 8] don't even reference the list x, so howcan they be considered the same?  And the difference between [4] and [6]would be quite obvious if any of the elements of x were objects thatdon't self-evaluate, e.g.:(setq a 1 b 2 c 3 x '(a b c))(apply #'list x) => (a b c) (which, by the way, should not share			    structure with x)(eval (cons 'list x)) => (1 2 3)       2. If APPLY copies its last argument, recursive programs that receive an       &REST argument and pass it to APPLY become inefficient.  A linear time       algorithm can change to a quadratic time algorithm.  While the efficiency       could be regained through compiler flow analysis in many cases, I think       it's better not to put the inefficiency into the language in the first       place.    Using APPLY is probably inefficient anyhow.  I sure hope not!  Many implementations of EVAL use APPLY internally forall function calls, something along the lines of:(apply (symbol-function (car form)) (mapcar #'eval (cdr form)))(yes, this is extremely simplified, I know that the real thing is muchmore complex).						 If this kind of recursive    function has to run quickly it would probably be better to define an    auxillary function with a fixed number of arguments to do the real work.    Besides, most function calls are not made using APPLY.  Recursive    function calls using APPLY are too rare to justify a blemish in the    semantics of all function calls.It's not just recursive calls.  Consider all the functions that takearguments just like FORMAT.  They all call various intermediatefunctions, which call other intermediates, and eventually they callFORMAT itself.  The &rest list shouldn't be duplicated at each call.Many other functions take &rest arguments that are simply passed on toother functions using APPLY.    Some might argue that the correct way to disambiguate this situation is    to specify that APPLY must share its final argument with any &Rest list    argument as much as possible.  This doesn't make sense to me.  I don't    believe that it would make Common Lisp more efficient to any significant    degree.  I think it creates an undesirable inconsistency in the    semantics of function calls, as I argued above.  Furthermore, modifying    &Rest lists as a way to indirectly modify some argument to APPLY sounds    like one of the worst dirty programming tricks I have heard of in a long    time.  The possibility of causing exceedingly obscure bugs makes my skin    crawl.I don't think anyone is actually suggesting that people intentionallymodify &rest lists.  Personally, I prefer making it be undefined whether&rest lists share, so programmers aren't tempted to write such code.                                                barmar*start*04236 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 30 Mar 88 11:37From: mike%acorn%LIVE-OAK.LCS.MIT:EDU:XeroxSubject: &Rest ListsTo: ELIOT%cs.umass:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: mike%acorn@LIVE-OAK.LCS.MIT.EDU (mike@gold-hill.com after 1-April-88)To: ELIOT@cs.umass.eduSubject: &Rest ListsCc: common-lisp@SAIL.STANFORD.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 30 MAR 88 11:37:03 PSTReceived: from XX.LCS.MIT.EDU by SAIL.Stanford.EDU with TCP; 30 Mar 88  10:52:48 PSTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 30 Mar 88 11:00-ESTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 85770; 30 Mar 88 09:07:29-ESTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 97731; Wed 30-Mar-88 08:50:23-ESTOriginal-Date: Wed, 30 Mar 88 08:52 estCOMMENTS: NOTE %acorn@oak... CHANGES TO @GOLD-HILL.COM ON 1-April-88GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV           Calls made using APPLY are not specially optimized.  However, FOO can    be compiled using full knowledge of the body of FOO.  So if FOO does    not return its &Rest list it can be CONSed on the stack.  This "analysis" stuff is not really valuable.  Without global programknowledge, the vast majority of these cases will be undecidable. Ifyou pass any cons of the rest arg to any function, and return thevalue of any other function, then you can't decide it because the twofunctions could communicate via shared state: e.g.,--> file 1:  (let ((shared-state nil))    (defun bar (x)       (setq shared-state x))    (defun foo ()        shared-state))  --> file 2:  (defun test (&rest arg)    (bar arg)    (foo))Clearly, TEST returns its rest arg, and the only way for the compilerto know this is to have global knowledge of the functions FOO and BARThe only way around this is to re-write test:   (defun test (&rest arg1)    (let ((arg (copy-list arg1)))      (bar arg)      (foo)))Which is exactly what you have to do to eliminate sharing when the default is to allow sharing. (Note that in this case, the compilercould infer that arg1 could be a "stack-list" :-)  My point: relying on the compiler to "infer" stuff that should bedirectly expressable is a bad idea. It should be clear that ifthe default is to share rest-arg conses passed by apply, one can get the desired behavior possibly at the cost of having tocall copy-list. If the default is to copy, then in most cases,the compiler will not be able to eliminate the copying and therewill be run-time cost.     While we are discussing such low-level issues, it is worth thinking about    how difficult it is to take advantage of the possibility of sharing     &Rest lists.  Basically there are two ways to do it.  If you are willing to    give up or tremendously complicate separate compilation you can compile    a function CALL using special knowledge of the definition of the Callee.    For example, a call using APPLY could jump into the middle of the    function entry sequence, after the point where &Rest lists normally    get created.  This would be a major break with lisp tradition.     you must use several different calling conventions and pass along     enough information so that the Callee knows how its arguments have been     encoded.  This will slow down every function call by the amount needed     to encode/decode this information, and complicate the implementation    considerably.  Which option do you prefer?Having mulitple function entry points to support different callingconventions sounds like a good strategy to exploit compile-timeknowledge of the structure of the called function. A classic exampleof this is for type-checking. If checked and unchecked entries areavailable, then the compiler can set up an unchecked call if thetypes are known to be correct. There need be no run-time set-up oroverhead.    ...mike beckerleGold Hill*start*03418 00024 US Originator: Common-Lisp-mailer%sail.stanford:EDU:XeroxDate:  4 Apr 88 15:45From: barmar%think:COM:XeroxSubject: Re:  &rest replacement/additionIn-Reply-to: <8804041629.AA00637@pozzo.think.com>To: rst%think:COM:Xeroxcc: Sean.Engelson%SPICE.CS.CMU:EDU:Xerox, common-lisp%sail.stanford:EDU:Xerox, spe%spice.cs.cmu:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@think.com>Subject: Re:  &rest replacement/additionTo: rst@think.comCc: Sean.Engelson@SPICE.CS.CMU.EDU, common-lisp@sail.stanford.edu, spe@spice.cs.cmu.eduIn-Reply-To: <8804041629.AA00637@pozzo.think.com>Return-Path: <Common-Lisp-mailer@sail.stanford.edu>Redistributed: Xerox-Common-Lisp^.xReceived: from parcvax.xerox.com by Xerox.COM ; 04 APR 88 15:03:15 PDTReceived: by parcvax.xerox.com (5.54/1.15) 	id AA14562; Mon, 4 Apr 88 11:01:18 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 4 Apr 88  10:37:49 PDTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Mon, 4 Apr 88 13:35:29 EDTReceived: from OCCAM.THINK.COM by sauron.think.com; Mon, 4 Apr 88 13:35:24 EDTOriginal-Date: Mon, 4 Apr 88 13:36 EDTMessage-Id: <19880404173633.6.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon, 4 Apr 88 12:29:50 edt    From: rst@Think.COM       From: Barry Margolin <barmar@Think.COM>       Subject: &rest replacement/addition       Actually, if this were added, the operations that extract the arguments       need not be special forms.  &MORE-ARGS <var> could bind <var> to an       object of type MORE-ARGS.  Common Lisp would only specify accessors for       this object, so it could be passed along with no possibility of strange       side-effects.  APPLY could also be extended to allow a MORE-ARGS in       place of a list as its last argument.						    barmar    But can an object of type MORE-ARGS be returned from a function, or    otherwise stuffed in data structures which survive the dynamic extent    of the function call that spawned them?  That's what this whole    argument started with...No, I don't think that's what started this particular argument.  Theissue of stack-consed &REST lists is completely independent of the issueof side-effects on shared &REST lists.  They are two orthogonalmechanisms for speeding up calls to &REST functions; in fact, they eachaddress different cases (stack consing speeds up normal calls, sharingspeeds up calls via APPLY).  The above only addresses the issue ofpreventing the strange side-effects that the latter allows, which iswhat this discussion has been about.  I almost added a sentence thatsaid that this doesn't affect the stack-allocation issue, as thoseimplementations that currently allocate &REST lists on the stack wouldprobably want to allocate &MORE-ARGS objects there, too.Dynamic-extent &REST lists have never been valid Common Lisp (there areexamples on p.64 of CLtL that fail when &REST lists are stack-consed).If this new proposal were to be adopted, I doubt X3J13 would allow themto be stack-allocated, either.  Presumably, Symbolics's excuse forcontinuing to stack-cons &REST lists is that they were doing so beforeCommon Lisp, and they haven't gotten around to changing it.  Theywouldn't have such an excuse with the new mechanism.                                                barmar*start*02038 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Apr 88 06:25From: mike%acorn%LIVE-OAK.LCS.MIT:EDU:XeroxSubject: Re:  &rest replacement/additionTo: rst%Think:COM:Xeroxcc: Sean.Engelson%spice.cs.cmu:EDU:Xerox, barmar%Think:COM:Xerox, common-lisp%sail.stanford:EDU:Xerox, spe%spice.cs.cmu:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: mike%acorn@LIVE-OAK.LCS.MIT.EDU (mike@gold-hill.com any day now)To: rst@Think.COMSubject: Re:  &rest replacement/additionCc: Sean.Engelson@spice.cs.cmu.edu, barmar@Think.COM, common-lisp@sail.stanford.edu, spe@spice.cs.cmu.eduReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 APR 88 06:25:54 PDTReceived: from XX.LCS.MIT.EDU by SAIL.Stanford.EDU with TCP; 5 Apr 88  05:50:16 PDTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 5 Apr 88 08:49-EDTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 86182; 5 Apr 88 08:47:36-EDTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 98040; Tue 5-Apr-88 07:52:45-ESTOriginal-Date: Tue, 5 Apr 88 06:53 estCOMMENTS: NOTE %acorn@oak... WILL BECOME @GOLD-HILL.COM ANY DAY NOWGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV        But can an object of type MORE-ARGS be returned from a function, or    otherwise stuffed in data structures which survive the dynamic extent    of the function call that spawned them?  That's what this whole    argument started with...I agree. Are there any examples of CL constructs which allow areference to an object which has only dynamic extent? The closestthing I can think of is WITH-OPEN-FILE, but that just insures thatthe stream is closed, not that it's storage is reclaimed. Myintuition is also that allowing a first-class reference for adynamic-extent object is a bad idea....mikeb    *start*03223 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Apr 88 11:46From: pf%ti-csl.csc.ti:COM:XeroxSubject: Re: &rest [discussion] replacement/additionIn-Reply-to: Msg of 8 Apr 88 20:43:52 GMT from Jon L White <edsel!jonl@LABREA.STANFORD.EDU>To: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Paul Fuqua <pf@ti-csl.csc.ti.com>To: common-lisp@sail.stanford.eduSubject: Re: &rest [discussion] replacement/additionIn-Reply-To: Msg of 8 Apr 88 20:43:52 GMT from Jon L White <edsel!jonl@LABREA.STANFORD.EDU>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 APR 88 11:45:51 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 13 Apr 88  11:00:27 PDTReceived: by ti.com id AA29855; Wed, 13 Apr 88 12:58:18 CDTReceived: from Islington-Terrace by tilde id AA05452; Wed, 13 Apr 88 12:54:53 CDTMessage-Id: <2785945967-1737834@Islington-Terrace>Original-Date: Wed, 13 Apr 88 12:52:47 CDTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Friday, April 8, 1988  3:43pm (CDT)    From: Jon L White <edsel!jonl at LABREA.STANFORD.EDU>    Subject: &rest [discussion] replacement/addition        Of course, the problem isn't only the sharing of &rest lists, but the more     common flaw that they may, unannouncedly, have dynamic extent.  By this, I     mean the bug where a stack-allocated &rest list can creep out into global     data structures, even though it will surely disappear when the frame that     created it returns.  Allegedly, Symbolics is going to fix this bug in their     next release (and TI may have already fixed it?); but we are now five years     beyond the first CL specification!We fixed it for Release 3, which came out some time ago.  We use a separateinternal data type for stack-lists, which, when the list is returned from afunction or stored into the heap, is noticed and causes the list to copiedout of the stack.  There's other hair to preserve EQness and to cope withstack-groups and special-bindings.As a matter of fact, I asked about the problem of APPLYing a function with a&REST arg back when I was doing the function-calling microcode.  The easyapproach was to spread the list and re-collect it into a stack-list, whichwould avoid both the sharing and the consing, but we decided at the time toavoid the spreading overhead.  If the standard says not to share, we'llspread and re-collect.Incidentally, our implementation of keyword arguments also uses a &REST arg,so &KEY implies &REST internally.  Did that appear in the statistics?  Idon't know if other implementations do the same.The general rule around here is, "Don't modify a list if you don't know whereit came from."  Many constants in our implementation end up in read-onlyareas, and there are other instances of sharing than APPLY/&REST, so it'sseen as a bad idea to use destructive operations on random data objects.                              pfPaul FuquaTexas Instruments Computer Science Center, Dallas, TexasCSNet:  pf@csc.ti.com (ARPA too, eventually)UUCP:   {smu, texsun, im4u, rice}!ti-csl!pf*start*02211 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 11:49From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: &REST listsIn-Reply-to: <FAHLMAN.12364037774.BABYL@C.CS.CMU.EDU>To: Fahlman%C.CS.CMU:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: &REST listsTo: Scott E. Fahlman <Fahlman@C.CS.CMU.EDU>cc: common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12364037774.BABYL@C.CS.CMU.EDU>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 11:49:15 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Mar 88  11:05:15 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 361155; Fri 11-Mar-88 14:04:03 ESTOriginal-Date: Fri, 11 Mar 88 14:04 ESTMessage-ID: <19880311190404.0.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon, 4 Jan 1988  20:27 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>	Is there general agreement on whether it is valid Common Lisp to	destructively modify (RPLACA, RPLACD) the list to which a &REST	parameter is bound?  I can't find a reference in CLtL for this.    I think there's general agreement that &rest args are supposed to be    righteous lists with indefinite extent, so RPLAC'ing them ought to be    legal.I don't think I ever remembered to answer this.  This is speciousreasoning.  The premise that values of &rest parameters have indefiniteextent does not imply the conclusion that each value of an &restparameter is an independent object that does not share structure withany other object.  There is general agreement on the premise, butcertainly not on the conclusion.Please don't confuse the issue of extent, on which Symbolics stilldeliberately violates the standard (this is a well-known, documentedviolation, which will go away when we get the resources to make itgo away) with the issue of structure sharing.*start*01378 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 12:27From: Fahlman%C.CS.CMU:EDU:XeroxSubject: &REST listsIn-Reply-to: Msg of 11 Mar 1988  14:04-EST from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>To: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: common-lisp@SAIL.STANFORD.EDUSubject: &REST listsIn-reply-to: Msg of 11 Mar 1988  14:04-EST from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 12:26:05 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 11 Mar 88  11:47:31 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Fri 11 Mar 88 14:47:20-ESTOriginal-Date: Fri, 11 Mar 88 14:47 ESTMessage-ID: <FAHLMAN.12381539395.BABYL@C.CS.CMU.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIn response to David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>...Yes, I misunderstood the question about RPLACA and &rest args.  Sincewhoever asked the question did not mention the case of APPLY, I didn'trealize that shared lists were the issue.  I thought it was a questionabout whether the &rest list could be treated as a real list.-- Scott*start*03131 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 14:22Subject: Re: &REST listsFrom: NGALL%G.BBN:COM:XeroxIn-Reply-to: <19880311190404.0.MOON@EUPHRATES.SCRC.Symbolics.COM>To: Moon%SCRC-STONY-BROOK:ARPA:Xeroxcc: Fahlman%C.CS.CMU:EDU:Xerox, common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 14:22:48 PSTReceived: from G.BBN.COM by SAIL.Stanford.EDU with TCP; 11 Mar 88  13:44:09 PSTOriginal-Date: 11 Mar 88 16:42 ESTMessage-ID: <[G.BBN.COM]11-Mar-88 16:42:56.NGALL>Hmm... I'm getting a little confused by the issue of structure-sharingthe CONS object (and the CONSes linked to it) that is the value of an&REST parameter.  In general, there are two consequences of structuresharing:1) (The one alluded to in your message.) If one modifies the CAR orCDR cell of a shared CONS, other parts of the system may be affected(e.g., a calling function call form could be modified).2) (This is the one that bothers me.) Some other part of the systemmay modifiy a shared CONS at any time.  This means that although thelist (chain of CONSes) that is the value of the &REST parameter hasindefinite extent, some part of the system (e.g., some internal partof the function calling mechanism) could modify the CAR or CDR cell ofany of the CONSes.  For example, I could assign the value of the &RESTparameter (e.g., the list (1 2 3)) to the special variable *FOO*,return from the function, and discover that the value of *FOO* is now(1 . !!!END!!!).  The CONS is still there, but someone else (e.g., thefunction-return mechanism) modified its CDR cell.If you are suggesting that (2) would be possible under theclarification of &REST, then saving the value of the &REST parameteris fairly useless.  One would have to COPY it to prevent it from beingsmashed.If on the other hand, you are promising that a CL implementation willnever (internally) modify any CONS comprising the list that is thevalue of an &REST parameter, then this should be stated explicitly inthe clarification to &REST.In summary, stating that "the CONSes of the &REST list have indefiniteextent, but may be shared by other parts of the system", implicitlyallows the behavior mentioned in (2), and this makes saving the CONSesrelatively useless.-- Nick    ...    Date: Fri, 11 Mar 88 14:04 EST    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>        ... The premise that values of &rest parameters have indefinite    extent does not imply the conclusion that each value of an &rest    parameter is an independent object that does not share structure with    any other object.  There is general agreement on the premise, but    certainly not on the conclusion.        Please don't confuse the issue of extent, on which Symbolics still    deliberately violates the standard (this is a well-known, documented    violation, which will go away when we get the resources to make it    go away) with the issue of structure sharing.    *start*01906 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 14:46From: Fahlman%C.CS.CMU:EDU:XeroxSubject: &REST listsIn-Reply-to: Msg of 11 Mar 1988  16:42-EST from NGALL at G.BBN.COMTo: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: common-lisp@SAIL.STANFORD.EDUSubject: &REST listsIn-reply-to: Msg of 11 Mar 1988  16:42-EST from NGALL at G.BBN.COMReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 14:46:36 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 11 Mar 88  14:10:36 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Fri 11 Mar 88 17:03:43-ESTOriginal-Date: Fri, 11 Mar 88 17:03 ESTMessage-ID: <FAHLMAN.12381564223.BABYL@C.CS.CMU.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIn reply to NGALL at G.BBN.COM ...I believe that there is only one way in which the backbone of an &restlist might end up being shared, and that is if the list was passed in asthe last arg to APPLY.  In all other cases, the &rest list is built upfrom distinct arguments, and couldn't possibly be anything that the userhas his hands on.  We had a lengthy debate at one time about the APPLYcase: should we guarantee the user that the &rest list is a fresh copy,guarantee that the APPLY list is incorporated into the &rest list, ornot guarantee anything.  I believe that we never reached a firm decisionon this, which means that the "not guarantee anything" case wins bydefault.  So smashing a &rest arg list is not a good idea unless youknow where it came from and who else might have hold of it.  As Steelepointed out, smashing anything is not a good idea unless you know itspedigree.  If you want to be safe, copy it before smashing.-- Scott*start*01134 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 15:01From: Fahlman%C.CS.CMU:EDU:XeroxSubject: &REST listsIn-Reply-to: Msg of 11 Mar 1988  16:42-EST from NGALL at G.BBN.COMTo: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: common-lisp@SAIL.STANFORD.EDUSubject: &REST listsIn-reply-to: Msg of 11 Mar 1988  16:42-EST from NGALL at G.BBN.COMReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 15:00:58 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 11 Mar 88  14:30:44 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Fri 11 Mar 88 17:30:50-ESTOriginal-Date: Fri, 11 Mar 88 17:30 ESTMessage-ID: <FAHLMAN.12381569161.BABYL@C.CS.CMU.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo further clarify, I don't think that anyone is proposing that &restlists should be mysteriously modified by the system itself in a CommonLisp that adheres to the standard.-- Scott*start*03515 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 15:07From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Re: &REST listsIn-Reply-to: <[G.BBN.COM]11-Mar-88 16:42:56.NGALL>To: NGALL%G.BBN:COM:Xeroxcc: Fahlman%C.CS.CMU:EDU:Xerox, common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: &REST listsTo: NGALL@G.BBN.COMcc: Fahlman@C.CS.CMU.EDU, common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <[G.BBN.COM]11-Mar-88 16:42:56.NGALL>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 15:07:18 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Mar 88  14:34:15 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 361398; Fri 11-Mar-88 17:33:32 ESTOriginal-Date: Fri, 11 Mar 88 17:33 ESTMessage-ID: <19880311223331.9.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: 11 Mar 1988 16:42-EST    From: NGALL@G.BBN.COM    Hmm... I'm getting a little confused by the issue of structure-sharing    the CONS object (and the CONSes linked to it) that is the value of an    &REST parameter.  In general, there are two consequences of structure    sharing:    1) (The one alluded to in your message.) If one modifies the CAR or    CDR cell of a shared CONS, other parts of the system may be affected    (e.g., a calling function call form could be modified).    2) (This is the one that bothers me.) Some other part of the system    may modifiy a shared CONS at any time.  It's not considered kosher to modify shared data structure without documentingthat you do so.					    This means that although the    list (chain of CONSes) that is the value of the &REST parameter has    indefinite extent, some part of the system (e.g., some internal part    of the function calling mechanism) could modify the CAR or CDR cell of    any of the CONSes.  I don't see anything in CLtL that says the function calling mechanism isallowed to modify things.			For example, I could assign the value of the &REST    parameter (e.g., the list (1 2 3)) to the special variable *FOO*,    return from the function, and discover that the value of *FOO* is now    (1 . !!!END!!!).  The CONS is still there, but someone else (e.g., the    function-return mechanism) modified its CDR cell.    If you are suggesting that (2) would be possible under the    clarification of &REST, then saving the value of the &REST parameter    is fairly useless.  One would have to COPY it to prevent it from being    smashed.I'm not suggesting this.    If on the other hand, you are promising that a CL implementation will    never (internally) modify any CONS comprising the list that is the    value of an &REST parameter, then this should be stated explicitly in    the clarification to &REST.You're right.  It would be good to state explicitly that the functioncall mechanism will not bash lists received as values of &REST parameters,that users should not bash lists received as values of &REST parameters,and that users should not bash lists passed to APPLY as its last argument.Of course the same thing could be said about every other place in thelanguage where potentially shareable structure exists.*start*02010 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 15:35From: edsel!eb%labrea.Stanford:EDU:XeroxIn-Reply-to: "Scott E. Fahlman"'s message of Fri, 11 Mar 1988  17:03 EST <FAHLMAN.12381564223.BABYL@C.CS.CMU.EDU>Subject: &REST listsTo: Fahlman%c.cs.cmu:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Eric Benson <edsel!eb@labrea.Stanford.EDU>To: Fahlman@c.cs.cmu.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: "Scott E. Fahlman"'s message of Fri, 11 Mar 1988  17:03 EST <FAHLMAN.12381564223.BABYL@C.CS.CMU.EDU>Subject: &REST listsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 15:35:27 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 11 Mar 88  14:56:58 PSTReceived: by labrea.Stanford.EDU; Fri, 11 Mar 88 14:57:41 PSTReceived: from kent-state.lucid.com by edsel id AA21370g; Fri, 11 Mar 88 14:37:24 PSTReceived: by kent-state id AA04701g; Fri, 11 Mar 88 14:45:59 PSTOriginal-Date: Fri, 11 Mar 88 14:45:59 PSTMessage-Id: <8803112245.AA04701@kent-state.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIt's not only smashing a &rest argument that's a problem, it'ssmashing any list that has been given as the last argument to APPLY aswell.  Consider the following in an implementation that doesn't copythe last argument to APPLY when it is passed as a &rest argument:> (defvar *message*)*MESSAGE*> (defun set-message (&rest mess)    (setq *message* mess))SET-MESSAGE> (let ((winner (list 'a 'winner)))    (apply #'set-message winner)    (setf (cdr winner) (list 'loser))    winner)(A LOSER)Is *message* (A WINNER) or (A LOSER)?  (It might be(#<DTP-LOCATIVE 76123756> #<DTP-ODD-PC 12313453> ...)but that's a different problem.)  This suggests that once a list hasbeen given as the last argument to APPLY it is no longer OK to modifyit.*start*02659 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 16:41From: barmar%Think:COM:XeroxSubject: Re: &REST listsIn-Reply-to: <[G.BBN.COM]11-Mar-88 16:42:56.NGALL>To: NGALL%g.bbn:COM:Xeroxcc: Moon%stony-brook.scrc.symbolics:COM:Xerox, Fahlman%c.cs.cmu:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: &REST listsTo: NGALL@g.bbn.comCc: Moon@stony-brook.scrc.symbolics.com, Fahlman@c.cs.cmu.edu, common-lisp@sail.stanford.eduIn-Reply-To: <[G.BBN.COM]11-Mar-88 16:42:56.NGALL>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 16:41:44 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 11 Mar 88  16:00:07 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Fri, 11 Mar 88 17:39:02 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Fri, 11 Mar 88 17:38:58 ESTOriginal-Date: Fri, 11 Mar 88 17:40 ESTMessage-Id: <19880311224022.7.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: 11 Mar 1988 16:42-EST    From: NGALL@g.bbn.com    2) (This is the one that bothers me.) Some other part of the system    may modifiy a shared CONS at any time.  This means that although the    list (chain of CONSes) that is the value of the &REST parameter has    indefinite extent, some part of the system (e.g., some internal part    of the function calling mechanism) could modify the CAR or CDR cell of    any of the CONSes.  For example, I could assign the value of the &REST    parameter (e.g., the list (1 2 3)) to the special variable *FOO*,    return from the function, and discover that the value of *FOO* is now    (1 . !!!END!!!).  The CONS is still there, but someone else (e.g., the    function-return mechanism) modified its CDR cell.I don't think that he was suggesting that the conses could be smashedbehind your back by some automatic mechanism like returning from afunction call.  I think the following is an example of the sharing of&REST lists that may be possible.(defparameter *shared-list* '(1 2 3))(defun function-1 (&rest args)  (function-2)  (print args))(defun function-2 ()  (setf (car *shared-list*) 6))(defun caller ()  (apply #'function-1 *shared-list*))OK, what does (caller) print, (1 2 3) or (6 2 3)?  In Genera it printsthe latter.  Thus, one must be careful when passing argument lists thatcan be accessed by other functions.                                                barmar*start*02659 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Mar 88 17:12From: barmar%Think:COM:XeroxSubject: Re: &REST listsIn-Reply-to: <[G.BBN.COM]11-Mar-88 16:42:56.NGALL>To: NGALL%g.bbn:COM:Xeroxcc: Moon%stony-brook.scrc.symbolics:COM:Xerox, Fahlman%c.cs.cmu:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: &REST listsTo: NGALL@g.bbn.comCc: Moon@stony-brook.scrc.symbolics.com, Fahlman@c.cs.cmu.edu, common-lisp@sail.stanford.eduIn-Reply-To: <[G.BBN.COM]11-Mar-88 16:42:56.NGALL>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 MAR 88 17:12:24 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 11 Mar 88  16:38:28 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Fri, 11 Mar 88 17:39:02 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Fri, 11 Mar 88 17:38:58 ESTOriginal-Date: Fri, 11 Mar 88 17:40 ESTMessage-Id: <19880311224022.7.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: 11 Mar 1988 16:42-EST    From: NGALL@g.bbn.com    2) (This is the one that bothers me.) Some other part of the system    may modifiy a shared CONS at any time.  This means that although the    list (chain of CONSes) that is the value of the &REST parameter has    indefinite extent, some part of the system (e.g., some internal part    of the function calling mechanism) could modify the CAR or CDR cell of    any of the CONSes.  For example, I could assign the value of the &REST    parameter (e.g., the list (1 2 3)) to the special variable *FOO*,    return from the function, and discover that the value of *FOO* is now    (1 . !!!END!!!).  The CONS is still there, but someone else (e.g., the    function-return mechanism) modified its CDR cell.I don't think that he was suggesting that the conses could be smashedbehind your back by some automatic mechanism like returning from afunction call.  I think the following is an example of the sharing of&REST lists that may be possible.(defparameter *shared-list* '(1 2 3))(defun function-1 (&rest args)  (function-2)  (print args))(defun function-2 ()  (setf (car *shared-list*) 6))(defun caller ()  (apply #'function-1 *shared-list*))OK, what does (caller) print, (1 2 3) or (6 2 3)?  In Genera it printsthe latter.  Thus, one must be careful when passing argument lists thatcan be accessed by other functions.                                                barmar*start*01830 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Mar 88 05:15From: "mcvax!pilatus!ceb%uunet.UU.NET":GV:XeroxSubject: &rest lists and other things ground through function applicationTo: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 MAR 88 05:15:08 PSTReceived: from uunet.UU.NET by SAIL.Stanford.EDU with TCP; 13 Mar 88  04:49:01 PSTReceived: from mcvax.UUCP by uunet.UU.NET (5.54/1.14) with UUCP 	id AA27626; Sun, 13 Mar 88 07:49:36 ESTReceived: by mcvax.cwi.nl; Sun, 13 Mar 88 13:47:31 +0100 (MET)Received: by cernvax.uucp (1.2/Ultrix2.0-B)	id AA20860; Sun, 13 Mar 88 13:22:44 +0100Original-Date: Sun, 13 Mar 88 13:22:44 +0100Message-Id: <8803131222.AA20860@cernvax.uucp>With regards the current (or, by the time  this message makes it back,probably two week old) debate on this topic,  I have yet to see the following point mentioned:If you want to be able to freely modify the structures which areused to implement these features, something imbedded in the kernel ofthe language is going to have to *copy* them.  You could do a top-level copy, but then you are still not protected ifsomeone does a (setf (cadr passed-argument-structure 'truc).  In orderto beat this, you have to do an arbitrary depth copy, and then, whenyou pass tangled, circular, non-ending horrible things which makeprint go bananas (I do this often), you have to do circular listdetection, etc. . . . and you very quickly get into a game which can'tbe won.This is a problem which defies mechanical solution, and should bekept out of the language definition, except, as someone has alreadypointed out, for a clear staking of position in the standard.ceb*start*01094 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Mar 88 05:14From: "mcvax!pilatus!ceb%uunet.UU.NET":GV:XeroxSubject: &rest lists - correctionTo: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 MAR 88 05:15:01 PSTReceived: from uunet.UU.NET by SAIL.Stanford.EDU with TCP; 13 Mar 88  04:48:57 PSTReceived: from mcvax.UUCP by uunet.UU.NET (5.54/1.14) with UUCP 	id AA27623; Sun, 13 Mar 88 07:49:30 ESTReceived: by mcvax.cwi.nl; Sun, 13 Mar 88 13:47:10 +0100 (MET)Received: by cernvax.uucp (1.2/Ultrix2.0-B)	id AA20851; Sun, 13 Mar 88 13:22:41 +0100Original-Date: Sun, 13 Mar 88 13:22:41 +0100Message-Id: <8803131222.AA20851@cernvax.uucp>In my previous posting, the counter example should have read (setf (cdar ..) .), since (setf (cadr ..) .) *would* be covered bybackbone copying.  Hope this didn't cloud things.I grow rusty on "under-the-hood tinkering", since I now use mainlysemantically cleaner defstructs.*start*02749 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Mar 88 23:31From: ELIOT%cs.umass:EDU:XeroxSubject: &Rest ListsTo: common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 MAR 88 23:31:29 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 14 Mar 88  22:53:25 PSTReceived: from relay2.cs.net by RELAY.CS.NET id aa06767; 15 Mar 88 1:37 ESTReceived: from cs.umass.edu by RELAY.CS.NET id cb01442; 15 Mar 88 1:26 ESTOriginal-Date: Mon, 14 Mar 88 14:38 EDTX-VMS-To: IN%"common-lisp@sail.stanford.EDU"Ideally &Rest arguments should be the exclusive property of the function which defines them.  Two funny restrictions have sometimesbeen imposed on &Rest lists to enable certain optimizations.  Thequestion is whether the value of the optimization exceeds the costof documenting and not violating the restrictions.  The first optimization/restriction primarilly allows stack-consing at theexpense of making &Rest lists become undefined when the function returns.This is a fairly large optimization but it has already been prohibited(in the general case) by CLtL.The second optimization/restriction primarilly allows constant lists tobe used as &Rest lists at the expense of prohibiting functions frommodifying their &rest lists.  However, since CLtL already requires&Rest lists to exist after the function returns they will almostalways have to be CONSed as the function is called, unless fancyoptimizations have occured.  The primary case where this optimizationstill could matter is when Apply is used with a constant list to calla function with an &Rest list that does not have to be modified.I think that this optimization is rather minor, except in situationswhere a programmer has intentionally set up the code to take advantagof this.  However, it is a simple matter to rework this kind of functioncall to get the optimized behavior in a fully portable way.  Instead of:(defun bar (x)  (apply #'foo x))(defun foo (&rest theList)  ...)Use:(defun bar (x)  (foo x))(defun foo (theList)  ...)This new code is guaranteed to be portable and efficient, and it isalso easier to read.  Admittedly this rewrite isn't good for 100%of the cases, but it does make the optimized behavior of &Rest listsless important.  Sufficiently so that I think &Rest lists shouldbe implemented so that they behave as if:(defun foo (&rest x) ...)Should behave as if it were defined:(defun foo (&rest G0047)     ;Gensym really  (let ((x (copy-list G0047)))     ...))I think this fully and precisely specifies the semantics of &Rest.Chris Eliot*start*02195 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 16 Mar 88 12:39From: mike%acorn%LIVE-OAK.LCS.MIT:EDU:XeroxSubject: &Rest ListsTo: ELIOT%cs.umass:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: mike%acorn@LIVE-OAK.LCS.MIT.EDU (mike@gold-hill.com after 1-April-88)To: ELIOT@cs.umass.eduSubject: &Rest ListsCc: common-lisp@SAIL.STANFORD.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 MAR 88 12:39:25 PSTReceived: from XX.LCS.MIT.EDU by SAIL.Stanford.EDU with TCP; 16 Mar 88  11:58:21 PSTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 15 Mar 88 11:14-ESTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 84390; 15 Mar 88 11:07:32-ESTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 96800; Tue 15-Mar-88 10:08:06-ESTOriginal-Date: Tue, 15 Mar 88 10:09 estCOMMENTS: NOTE %acorn@oak... CHANGES TO @GOLD-HILL.COM ON 1-April-88GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    (defun foo (&rest x) ...)        Should behave as if it were defined:        (defun foo (&rest G0047)     ;Gensym really      (let ((x (copy-list G0047)))         ...))        I think this fully and precisely specifies the semantics of &Rest.        Chris EliotI couldn't disagree more. This implementation prohibits theprogrammer from exploiting sharing of list substructure. It reallytakes away some expressive power. One can get back the behaviorthat you want with the transform you've outlined here.Common lisp is not a functional language, it has tons of destructiveoperations. It is out of character for such a language to prohibitsharing of substructure by copying data structures implicitly. In general, when destructive operations are being used it should be theprogrammer's responsibility to copy a data structure manually.&REST should never cause copying of a list passed to it from APPLY....mike beckerleGOLD HILL *start*02225 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 16 Mar 88 21:01From: SYS%SAIL.Stanford:EDU:XeroxSubject: &Rest ListsTo: (Nobody):EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: System Files <SYS@SAIL.Stanford.EDU>Subject: &Rest ListsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 MAR 88 21:01:01 PSTOriginal-Date: 16 Mar 88 17:29 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVReceived: from XX.LCS.MIT.EDU by SAIL.Stanford.EDU with TCP; 16 Mar 88  11:58:21 PSTReceived: from LIVE-OAK.LCS.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 15 Mar 88 11:14-ESTReceived: from ACORN.Gold-Hill.DialNet.Symbolics.COM by MIT-LIVE-OAK.DialNet.Symbolics.COM via DIAL with SMTP id 84390; 15 Mar 88 11:07:32-ESTReceived: from BOSTON.Gold-Hill.DialNet.Symbolics.COM by ACORN.Gold-Hill.DialNet.Symbolics.COM via CHAOS with CHAOS-MAIL id 96800; Tue 15-Mar-88 10:08:06-ESTDate: Tue, 15 Mar 88 10:09 estFrom: mike%acorn@oak.lcs.mit.edu (mike@gold-hill.com after 1-April-88)COMMENTS: NOTE %acorn@oak... CHANGES TO @GOLD-HILL.COM ON 1-April-88To: ELIOT@cs.umass.eduSubject: &Rest ListsCc: common-lisp@SAIL.STANFORD.EDU    (defun foo (&rest x) ...)        Should behave as if it were defined:        (defun foo (&rest G0047)     ;Gensym really      (let ((x (copy-list G0047)))         ...))        I think this fully and precisely specifies the semantics of &Rest.        Chris EliotI couldn't disagree more. This implementation prohibits theprogrammer from exploiting sharing of list substructure. It reallytakes away some expressive power. One can get back the behaviorthat you want with the transform you've outlined here.Common lisp is not a functional language, it has tons of destructiveoperations. It is out of character for such a language to prohibitsharing of substructure by copying data structures implicitly. In general, when destructive operations are being used it should be theprogrammer's responsibility to copy a data structure manually.&REST should never cause copying of a list passed to it from APPLY....mike beckerleGOLD HILL *start*02015 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 16 Mar 88 21:18From: SYS%SAIL.Stanford:EDU:XeroxSubject: &REST argsTo: (Nobody):EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: System Files <SYS@SAIL.Stanford.EDU>Subject: &REST argsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 MAR 88 21:17:51 PSTOriginal-Date: 16 Mar 88 17:47 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVReceived: from nrtc.nrtc.northrop.com (NRTC.NORTHROP.COM) by SAIL.Stanford.EDU with TCP; 16 Mar 88  17:47:21 PSTDate:     Wed, 16 Mar 88 15:35:28 PSTFrom:     Jeff Barnett <jbarnett@nrtc.northrop.com>To:       common-lisp@sail.stanford.eduSubject:  &REST argsIn regards to the properties of &REST arguments:  There may be a way tohave our cake and eat it too given that CL has a declaration mechanismin place already and optimization hints are considered first class citizens.I propose an anology to the SYS:DOWNWARD-FUNCTION and SYS:DOWNWARD-FUNARGdecls in the Symbolics implementations.  In the function  with the &REST arg,that arg could be declared DOWNWARD meaning that pointers to it and top-levelCDRS are not stored upward and/or it could be declared NO-SETF meaning thatnone of the structure (top-level or otherwise) is modified.  The intentionhere is that the function not mdify part of the &REST arg because it is partof that arg---the function's contract (documentation) could specify that someother structure might be modified and if part of that structure is shared bythe &REST parameter, then caveat caller as usual.  On the call to apply, thelast argument could be declared to be SMASHABLE and/or SHARABLE when it isand/or compiler optimizers can detect when the list is freshly consed or aquote etc.  Apply could decide whether to pass the original, stack cons,or heap cons as appropriate.  When in doubt, it would always do the latter.*start*01738 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 16 Mar 88 21:30From: SYS%SAIL.Stanford:EDU:XeroxSubject: &rest args -- (declarations)To: (Nobody):EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: System Files <SYS@SAIL.Stanford.EDU>Subject: &rest args -- (declarations)Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 MAR 88 21:30:22 PSTOriginal-Date: 16 Mar 88 17:54 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 16 Mar 88  17:53:58 PSTPosted-Date: Wed, 16 Mar 88 15:17:23 PSTMessage-Id: <8803162317.AA14565@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.54/5.51)	id AA14565; Wed, 16 Mar 88 15:17:27 PSTTo: common-lisp@sail.stanford.eduFrom: goldman@vaxa.isi.eduSubject: &rest args -- (declarations)Date: Wed, 16 Mar 88 15:17:23 PSTSender: goldman@vaxa.isi.eduHas consideration been given to providing at least some declaration(s) the programmer can make  -- e.g., (DEFUN FOO (&REST L) (DECLARE (DYNAMIC-EXTENT L) (READ-ONLY L)) ...)that would effectively AUTHORIZE a compiler to perform certainoptimizations/transformations even when it could NOT otherwise PROVE the optimization/transformation preserved equivalence?[At least one implementation already provides a similar declarationfor functional arguments, that authorizes the "consing" oflexical closures on the stack.]There is no doubt some latitude for choosing relevant declarations.  I'mNOT proposing a particular set here in the hope that the matter has alreadybeen given more thought by someone else.   Has it?neil*start*03961 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 APR 88 03:49:16 PDTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 12 Apr 88  03:47:35 PDTReceived: by labrea.Stanford.EDU; Tue, 12 Apr 88 02:47:03 PSTReceived: from bhopal.lucid.com by edsel id AA23917g; Tue, 12 Apr 88 03:36:41 PDTReceived: by bhopal id AA18246g; Tue, 12 Apr 88 03:37:44 PDTDate: Tue, 12 Apr 88 03:37:44 PDTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8804121037.AA18246@bhopal.lucid.com>To: masinter.paCc: KMP@stony-brook.scrc.symbolics.com, CL-Cleanup@sail.stanford.edu, Moon@stony-brook.scrc.symbolics.com, Hornig@alderaan.scrc.symbolics.com, PRobertson@mead.scrc.symbolics.com, Laddaga@mead.scrc.symbolics.comIn-Reply-To: masinter.pa@Xerox.COM's message of 11 Apr 88 10:23 PDT <880411-102435-11763@Xerox>Subject: Issue: REST-ARGUMENT-EXTENTI generally agree with your assessment, Larry, although I am pessimisticabout bringing up &rest vectors again -- a *lot* of code already existsin the Common Lisp world  which assumes that the &rest parameter is boundto a list.On the other hand, while Kent may have noticed the large number of messagessent recently to Common-Lisp@sail on this topic, but I wonder if he read them?  The overwhelming majority of them concerned user disatisfaction with the unexpected "sharing" of rest lists -- our issue REST-LIST-ALLOCATION.  As Gail Z put it so succinctly -- if the CL spec can't get its act together to guarantee non-sharing in &rest lists, then there *must* be some construct added to the language so that the discerning user can prevent it.  In mymessage to Common-Lisp@sail of 8 Apr 88 01:00:38 PDT I quoted her:   Gail Zacharias talked about the common idiom of simply doing a COPY-LIST on    every &rest argument, to insure some normalcy.  Her reasoning seems, to me,    to bolster the case for those who claim that that CL semantics are deficient       Subject: &REST Lists       Date: 24 Mar 88 12:23:15 EST (Thu)       From: gz@spt.entity.com (Gail Zacharias)       . . .        If Common Lisp doesn't require unshared &rest lists, then I think       it must provide a declarative version of this idiom so the COPY-LIST can       be portably avoided when it's redundant.  Seems to me that the fact that       this is a common case where users find a need for conditionalization        indicates a real deficiency in Common Lisp's specification.       . . .    Of course, the problem isn't only the sharing of &rest lists, but the more    common flaw that they may, unannouncedly, have dynamic extent.  By this, I    mean the bug where a stack-allocated &rest list can creep out into global    data structures, even though it will surely disappear when the frame that    created it returns.  Allegedly, Symbolics is going to fix this bug in their    next release (and TI may have already fixed it?); but we are now five years    beyond the first CL specification!So as you say, we have a responsibility to resolve the very thorny issueof REST-LIST-ALLOCATION.On the other hand, since CL semantics already requires indefinite extentfor &rest values, and since Symbolics has been in violation of this partfor so many years, *** and because a subset of users find dynamic extentextremely userful *** then I don't think it would hurt all that muchto bless the effort to standardize the syntax for asking for it.-- JonL --P.S.: When I questioned whether Kent read the messages sent to Common-Lisp      mailing list, there was no intent to question his mental compotence.      Some months back he defended the dumping of a Symbolics internal       discussion onto the CL-Cleanup mailing list by saying that he refused       to read the allegedly voluminous Common-Lisp mails,  and thus couldn't       carry on the discussion there.*start*07951 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 00:26:53 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  00:25:46 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 00:24:47 PSTDate: 9 Dec 88 00:24 PSTFrom: masinter.pato: cl-cleanup@sail.stanford.eduSubject: DRAFT Issue: REST-LIST-ALLOCATION (Version 1)Message-ID: <881209-002447-5551@Xerox>This is an issue that we've avoided; I've had it on file for at least sixmonths. It addresses the question of whether APPLY newly allocations &RESTlists. There are the following options:Always newly allocatedAlways share structuresharing permitted but not requiredAlways newly allocated is made more palatable by DYNAMIC-EXTENTdeclarations or some such.Permitted but not required would be made more palatable by a portable wayof saying "unshared" so that COPY-LIST could be avoided.As time is short and this issue is not going to be ready in time, I've donea rush job on filling this out, made some mistakes about the proposal name,etc.!Forum:         CleanupIssue:         REST-LIST-ALLOCATIONReferences:    CLtL pp >>????<<Related issues: DYNAMIC-EXTENTCategory:      CLARIFICATIONEdit history:  8-Dec-88, Version 1 by MasinterProblem description:In the special case of calling a function with an &REST list via APPLY,implementations differ on whether a new copy of the list is freshlyallocated. For example, given (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*))does (APPLY #'FOO *MY-LIST*)return T?This issue is different from the question of the extent of "rest lists" inthe case when they *are* newly allocated which is indefinite; the issueDYNAMIC-EXTENT also contains some proposals about extent.Proposal (REST-LIST-ALLOCATION:NEWLY-ALLOCATED): Specify that &REST lists are newly allocated in the case when the functionis called via APPLY.Proposal (REST-LIST-ALLOCATION:MAY-SHARE): Specify that the value of an &REST parameter is permitted, but notrequired,to share (top-level) structure with the last argument to APPLY.Proposal (REST-LIST-ALLOCATION:MUST-SHARE)Specify that the value of an &REST parameter is permitted, but notrequired,to share (top-level) structure with the last argument to APPLY.>> this needs better spec about how the args match << Examples: (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*)) (APPLY #'FOO *MY-LIST*) => T ;on Symbolics systems and probably			      ; many stock hardware implementationsThis implies that (DEFUN BAR (&REST X) (RPLACA X 'D)) (APPLY #'BAR *MY-LIST*) *MY-LIST* => (D B C) ;on Symbolics systems and probably many stock		      ; hardware implementations    (setq x '(1 2 3))    [1] (apply #'foo 1 2 3 NIL)    [2] (apply #'foo 1 2 (cddr x))    [3] (apply #'foo 1 (cdr x))    [4] (apply #'foo x)    [5] (funcall #'foo 1 2 3)    [6] (eval (cons 'foo x))    [7] (eval (list 'foo 1 2 3))    [8] (foo 1 2 3)Which have the same semantics?--> file 1:  (let ((shared-state nil))    (defun bar (x)       (setq shared-state x))    (defun foo ()        shared-state))  --> file 2:  (defun test (&rest arg)    (bar arg)    (foo))(apply #'test '(a b c))Should     (defun foo (&rest x) ...)         behave as if it were defined:    (defun foo (&rest G0047)     ;Gensym really      (let ((x (copy-list G0047)))         ...))    Rationale:[[confusion]]Current practice:Some implementations always share. Some implementations never share.A few may share interpreted and not share compiled, or vice versa.Cost to Implementors:Low, for MAY. Higher for the others, for those implementations thatdon't conform. If you don't share and have to, nearly impossible. If you do share and shouldn't, inserting COPY-LIST inside eitherAPPLY or &REST handling is still hard and slow. Cost to Users:No matter what, somebody gets hurt. MAY means you have towrite awkward code if you care. The others, it depends on whatyou currently count on.Cost of non-adoption:Great confusion over the issue.Performance impact:SHARE costs least in consing, might slow down function call for some implementations. MAY lets implementations pick, hasleast impact. NEWLY-ALLOCATED requires consing incases where it didn't before.Benefits:Less confusionEsthetics:Differing, strongly held opinions.Discussion:The Revised3 Report on Scheme specifies that the equivalent of a&REST argument must be a newly allocated list, to avoid precisely thisproblem.Two arguments for PERMITTED-NOT-REQUIRED are:1. In no other place does Common Lisp automatically unshare structure,except when the user is explicitly modifying the structure (as in REMOVE).Making APPLY automatically unshare would be a semantic wart.2. If APPLY copies its last argument, recursive programs that receive an&REST argument and pass it to APPLY become inefficient.  A linear timealgorithm can change to a quadratic time algorithm.  While the efficiencycould be regained through compiler flow analysis in many cases, I thinkit's better not to put the inefficiency into the language in the firstplace.The DYNAMIC-EXTENT proposal would allow &REST liststhat were "newly allocated" to have dynamic extent if they wereto be passed down via APPLY. This puts the burden in theright place.It's not only smashing a &rest argument that's a problem, it'ssmashing any list that has been given as the last argument to APPLY aswell.  Consider the following in an implementation that doesn't copythe last argument to APPLY when it is passed as a &rest argument:> (defvar *message*)*MESSAGE*> (defun set-message (&rest mess)    (setq *message* mess))SET-MESSAGE> (let ((winner (list 'a 'winner)))    (apply #'set-message winner)    (setf (cdr winner) (list 'loser))    winner)(A LOSER)Is *message* (A WINNER) or (A LOSER)?  (It might be(#<DTP-LOCATIVE 76123756> #<DTP-ODD-PC 12313453> ...)but that's a different problem.)  This suggests that once a list hasbeen given as the last argument to APPLY it is no longer OK to modifyit.&REST should never cause copying of a list passed to it from APPLY."if the CL spec can't get its act together to guarantee non-sharing in &rest lists, then there *must* be some construct added to the language so that the discerning user can prevent it.  In mymessage to Common-Lisp@sail of 8 Apr 88 01:00:38 PDT I quoted her:   Gail Zacharias talked about the common idiom of simply doing a COPY-LISTon    every &rest argument, to insure some normalcy.  Her reasoning seems, tome,    to bolster the case for those who claim that that CL semantics aredeficient       Subject: &REST Lists       Date: 24 Mar 88 12:23:15 EST (Thu)       From: gz@spt.entity.com (Gail Zacharias)       . . .        If Common Lisp doesn't require unshared &rest lists, then I think       it must provide a declarative version of this idiom so the COPY-LISTcan       be portably avoided when it's redundant.  Seems to me that the factthat       this is a common case where users find a need for conditionalization       indicates a real deficiency in Common Lisp's specification.       . . .    Of course, the problem isn't only the sharing of &rest lists, but themore    common flaw that they may, unannouncedly, have dynamic extent.  By this,I    mean the bug where a stack-allocated &rest list can creep out intoglobal    data structures, even though it will surely disappear when the framethat    created it returns.  Allegedly, Symbolics is going to fix this bug intheir    next release (and TI may have already fixed it?); but we are now fiveyears    beyond the first CL specification!So as you say, we have a responsibility to resolve the very thorny issueof REST-LIST-ALLOCATION.*start*08714 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 15:47:59 PSTReceived: from mist.math.uoregon.edu by SAIL.Stanford.EDU with TCP; 12 Dec 88  15:45:17 PSTReceived: from fog.cs.uoregon.edu by mist.math.uoregon.edu; Mon, 12 Dec 88 15:43:08 PDTReceived: by fog.cs.uoregon.edu; Mon, 12 Dec 88 15:42:59 PDTDate: Mon, 12 Dec 88 15:42:59 PDTFrom: William Clinger <will@fog.cs.uoregon.edu>Message-Id: <8812122342.AA05921@fog.cs.uoregon.edu>To: cl-cleanup@sail.stanford.eduSubject: REST-LIST-ALLOCATION (Version 3)I didn't send Version 2 to this mailing list, but sent it toMasinter instead.  He requested that I make some small changesand send the result to CL-Cleanup.  Here it is.!Forum:         CleanupIssue:         REST-LIST-ALLOCATIONReferences:    CLtL pp 107-108 (APPLY)Related issues: DYNAMIC-EXTENTCategory:      CLARIFICATIONEdit history:  8-Dec-88, Version 1 by Masinter               9-Dec-88, Version 2 by Clinger (add rationale, more discussion)               12-Dec-88, Version 3 by Clinger (delete bogus examples)Problem description:In the special case of calling a function with an &REST list via APPLY,Common Lisp fails to specify whether a new copy of the list is freshlyallocated.  For example, given (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*))does (APPLY #'FOO *MY-LIST*)return T?This issue is different from the question of the extent of "rest lists" inthe case when they *are* newly allocated which is indefinite; the issueDYNAMIC-EXTENT also contains some proposals about extent.Proposal (REST-LIST-ALLOCATION:NEWLY-ALLOCATED): Specify that &REST lists are newly allocated in the case when the functionis called via APPLY.Proposal (REST-LIST-ALLOCATION:MAY-SHARE): Specify that the value of an &REST parameter is permitted, but not required,to share (top-level) structure with the last argument to APPLY.Proposal (REST-LIST-ALLOCATION:MUST-SHARE)Specify that the value of an &REST parameter is requiredto share (top-level) structure with the last argument to APPLY.>> this needs better spec about how the args match << Examples: (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*)) (APPLY #'FOO *MY-LIST*) => T ;on Symbolics systems and probably			      ; many stock hardware implementationsThis implies that (DEFUN BAR (&REST X) (RPLACA X 'D)) (APPLY #'BAR *MY-LIST*) *MY-LIST* => (D B C) ;on Symbolics systems and probably many stock		      ; hardware implementationsAnother example: which of the following have the same semantics?    (setq x '(1 2 3))    [1] (apply #'foo 1 2 3 NIL)    [2] (apply #'foo 1 2 (cddr x))    [3] (apply #'foo 1 (cdr x))    [4] (apply #'foo x)    [5] (funcall #'foo 1 2 3)Under REST-LIST-ALLOCATION:NEWLY-ALLOCATED:  [1]-[5] are equivalent.Under REST-LIST-ALLOCATION:MAY-SHARE:  Any answer to the question is correct for some conceivable implementation.  Abstracting over implementations, this means that [1]-[5] are pairwise  non-equivalent.Under REST-LIST-ALLOCATION:MUST-SHARE:  [1]-[4] are pairwise non-equivalent in all implementations.  This proposal  leaves open the question of whether [1] is equivalent to [5].And finally:Should     (defun foo (&rest x) ...)         behave (aside from efficiency) as if it were defined:    (defun foo (&rest G0047)     ;Gensym really      (let ((x (copy-list G0047)))         ...))    Rationale:The semantics of APPLY is unclear.  In consequence it is impossibleto write portable code that relies on &REST arguments sharing structurewith the last argument to APPLY.  Portable code can rely on &REST arguments*not* sharing structure with the last argument to APPLY, but only byperforming an explicit COPY-LIST on all &REST arguments; this is redundantand inefficient in implementations where &REST arguments are newlyallocated anyway.Current practice:Some implementations always share. Some implementations never share.A few may share interpreted and not share compiled, or vice versa.Cost to Implementors:None for MAY-SHARE, since that is the status quo.  Both of the otherproposals entail a significant cost for some implementations.If MUST-SHARE is adopted, then implementations that don't share structuremay be nearly impossible to convert.  If NEWLY-ALLOCATED is adopted, thenimplementations that do share will have to insert a call to COPY-LISTinside either APPLY or &REST list handling, which will slow things downand may be difficult as well.Cost to Users:No matter what, somebody gets hurt.  MAY-SHARE means you have towrite awkward and inefficient code if you care.  (This is alreadythe case for portable code.)  MUST-SHARE means you have to addexplicit calls to COPY-LIST to code that assumes the contrary.NEWLY-ALLOCATED means you have to rewrite code that assumes sharing.Cost of non-adoption:Great confusion over the issue.  A certain amount of awkwardness andinefficiency would remain inevitable if you want to write portable code.Performance impact:MUST-SHARE costs least in consing, but might slow down function call for some implementations.  MAY-SHARE lets implementations pick, hasleast impact.  NEWLY-ALLOCATED requires consing in cases where itdidn't before.Benefits:Less confusion.  Improved portability.Esthetics:Differing, strongly held opinions.Discussion:The Revised3 Report on Scheme specifies that the equivalent of a&REST argument must be a newly allocated list, to avoid precisely thisproblem.The argument for MUST-SHARE is that copying is inefficient, so&REST should never cause copying of a list passed to it from APPLY.Functions that desire a new copy can just call COPY-LIST.Two arguments for MAY-SHARE are:1. In no other place does Common Lisp automatically unshare structure,except when the user is explicitly modifying the structure (as in REMOVE).Making APPLY automatically unshare would be a semantic wart.2. If APPLY copies its last argument, recursive programs that receive an&REST argument and pass it to APPLY become inefficient.  A linear timealgorithm can change to a quadratic time algorithm.  While the efficiencycould be regained through compiler flow analysis in many cases, it'sbetter not to put the inefficiency into the language in the first place.The DYNAMIC-EXTENT proposal would allow &REST liststhat were "newly allocated" to have dynamic extent if they wereto be passed down via APPLY.  This puts the burden in theright place.Two (closely related) arguments for NEWLY-ALLOCATED:1. The programmer's model of function calling is simpler: functionstake arguments, and any two calls that pass the same arguments to thesame function are equivalent.  The MAY-SHARE and MUST-SHARE proposalsrequire a model in which functions generally take their arguments inthe form of a list, and the extent to which that list shares structurewith other lists in the system becomes an important part of thesemantics of a function call.2.  It's not only smashing a &rest argument that's a problem, it'ssmashing any list that has been given as the last argument to APPLY aswell.  Consider the following in an implementation that doesn't copythe last argument to APPLY when it is passed as a &rest argument:> (defvar *message*)*MESSAGE*> (defun set-message (&rest mess)    (setq *message* mess))SET-MESSAGE> (let ((winner (list 'a 'winner)))    (apply #'set-message winner)    (setf (cdr winner) (list 'loser))    winner)(A LOSER)Is *message* (A WINNER) or (A LOSER)?  (It might be(#<DTP-LOCATIVE 76123756> #<DTP-ODD-PC 12313453> ...)but that's a different problem.)  This suggests that once a list hasbeen given as the last argument to APPLY it is no longer OK to modifyit.Gail Zacharias talked about the common idiom of simply doing a COPY-LISTon every &rest argument, to insure some normalcy.  Her reasoning seemsto bolster the case for those who claim that the current CL semantics(MAY-SHARE) are deficient:    Subject: &REST Lists    Date: 24 Mar 88 12:23:15 EST (Thu)    From: gz@spt.entity.com (Gail Zacharias)    . . .     If Common Lisp doesn't require unshared &rest lists, then I think    it must provide a declarative version of this idiom so the COPY-LIST can    be portably avoided when it's redundant.  Seems to me that the fact that    this is a common case where users find a need for conditionalization    indicates a real deficiency in Common Lisp's specification.    . . . So we have a responsibility to resolve the very thorny issueof REST-LIST-ALLOCATION.*start*08635 00024 US Date: 12 Dec 88 16:08 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: REST-LIST-ALLOCATION (Version 3)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noThanks to Will Clinger for getting a last minute revision in.Forum:         CleanupIssue:         REST-LIST-ALLOCATIONReferences:    CLtL pp 107-108 (APPLY)Related issues: DYNAMIC-EXTENTCategory:      CLARIFICATIONEdit history:  8-Dec-88, Version 1 by Masinter               9-Dec-88, Version 2 by Clinger (add rationale, more discussion)               12-Dec-88, Version 3 by Clinger (delete bogus examples)Problem description:In the special case of calling a function with an &REST list via APPLY,Common Lisp fails to specify whether a new copy of the list is freshlyallocated.  For example, given (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*))does (APPLY #'FOO *MY-LIST*)return T?This issue is different from the question of the extent of "rest lists" inthe case when they *are* newly allocated which is indefinite; the issueDYNAMIC-EXTENT also contains some proposals about extent.Proposal (REST-LIST-ALLOCATION:NEWLY-ALLOCATED): Specify that &REST lists are newly allocated in the case when the functionis called via APPLY.Proposal (REST-LIST-ALLOCATION:MAY-SHARE): Specify that the value of an &REST parameter is permitted, but not required,to share (top-level) structure with the last argument to APPLY.Proposal (REST-LIST-ALLOCATION:MUST-SHARE)Specify that the value of an &REST parameter is requiredto share (top-level) structure with the last argument to APPLY.>> this needs better spec about how the args match << Examples: (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*)) (APPLY #'FOO *MY-LIST*) => T ;on Symbolics systems and probably			      ; many stock hardware implementationsThis implies that (DEFUN BAR (&REST X) (RPLACA X 'D)) (APPLY #'BAR *MY-LIST*) *MY-LIST* => (D B C) ;on Symbolics systems and probably many stock		      ; hardware implementationsAnother example: which of the following have the same semantics?    (setq x '(1 2 3))    [1] (apply #'foo 1 2 3 NIL)    [2] (apply #'foo 1 2 (cddr x))    [3] (apply #'foo 1 (cdr x))    [4] (apply #'foo x)    [5] (funcall #'foo 1 2 3)Under REST-LIST-ALLOCATION:NEWLY-ALLOCATED:  [1]-[5] are equivalent.Under REST-LIST-ALLOCATION:MAY-SHARE:  Any answer to the question is correct for some conceivable implementation.  Abstracting over implementations, this means that [1]-[5] are pairwise  non-equivalent.Under REST-LIST-ALLOCATION:MUST-SHARE:  [1]-[4] are pairwise non-equivalent in all implementations.  This proposal  leaves open the question of whether [1] is equivalent to [5].And finally:Should     (defun foo (&rest x) ...)         behave (aside from efficiency) as if it were defined:    (defun foo (&rest G0047)     ;Gensym really      (let ((x (copy-list G0047)))         ...))    Rationale:The semantics of APPLY is unclear.  In consequence it is impossibleto write portable code that relies on &REST arguments sharing structurewith the last argument to APPLY.  Portable code can rely on &REST arguments*not* sharing structure with the last argument to APPLY, but only byperforming an explicit COPY-LIST on all &REST arguments; this is redundantand inefficient in implementations where &REST arguments are newlyallocated anyway.Current practice:Some implementations always share. Some implementations never share.A few may share interpreted and not share compiled, or vice versa.Cost to Implementors:None for MAY-SHARE, since that is the status quo.  Both of the otherproposals entail a significant cost for some implementations.If MUST-SHARE is adopted, then implementations that don't share structuremay be nearly impossible to convert.  If NEWLY-ALLOCATED is adopted, thenimplementations that do share will have to insert a call to COPY-LISTinside either APPLY or &REST list handling, which will slow things downand may be difficult as well.Cost to Users:No matter what, somebody gets hurt.  MAY-SHARE means you have towrite awkward and inefficient code if you care.  (This is alreadythe case for portable code.)  MUST-SHARE means you have to addexplicit calls to COPY-LIST to code that assumes the contrary.NEWLY-ALLOCATED means you have to rewrite code that assumes sharing.Cost of non-adoption:Great confusion over the issue.  A certain amount of awkwardness andinefficiency would remain inevitable if you want to write portable code.Performance impact:MUST-SHARE costs least in consing, but might slow down function call for some implementations.  MAY-SHARE lets implementations pick, hasleast impact.  NEWLY-ALLOCATED requires consing in cases where itdidn't before.Benefits:Less confusion.  Improved portability.Esthetics:Differing, strongly held opinions.Discussion:The Revised3 Report on Scheme specifies that the equivalent of a&REST argument must be a newly allocated list, to avoid precisely thisproblem.The argument for MUST-SHARE is that copying is inefficient, so&REST should never cause copying of a list passed to it from APPLY.Functions that desire a new copy can just call COPY-LIST.Two arguments for MAY-SHARE are:1. In no other place does Common Lisp automatically unshare structure,except when the user is explicitly modifying the structure (as in REMOVE).Making APPLY automatically unshare would be a semantic wart.2. If APPLY copies its last argument, recursive programs that receive an&REST argument and pass it to APPLY become inefficient.  A linear timealgorithm can change to a quadratic time algorithm.  While the efficiencycould be regained through compiler flow analysis in many cases, it'sbetter not to put the inefficiency into the language in the first place.The DYNAMIC-EXTENT proposal would allow &REST liststhat were "newly allocated" to have dynamic extent if they wereto be passed down via APPLY.  This puts the burden in theright place.Two (closely related) arguments for NEWLY-ALLOCATED:1. The programmer's model of function calling is simpler: functionstake arguments, and any two calls that pass the same arguments to thesame function are equivalent.  The MAY-SHARE and MUST-SHARE proposalsrequire a model in which functions generally take their arguments inthe form of a list, and the extent to which that list shares structurewith other lists in the system becomes an important part of thesemantics of a function call.2.  It's not only smashing a &rest argument that's a problem, it'ssmashing any list that has been given as the last argument to APPLY aswell.  Consider the following in an implementation that doesn't copythe last argument to APPLY when it is passed as a &rest argument:> (defvar *message*)*MESSAGE*> (defun set-message (&rest mess)    (setq *message* mess))SET-MESSAGE> (let ((winner (list 'a 'winner)))    (apply #'set-message winner)    (setf (cdr winner) (list 'loser))    winner)(A LOSER)Is *message* (A WINNER) or (A LOSER)?  (It might be(#<DTP-LOCATIVE 76123756> #<DTP-ODD-PC 12313453> ...)but that's a different problem.)  This suggests that once a list hasbeen given as the last argument to APPLY it is no longer OK to modifyit.Gail Zacharias talked about the common idiom of simply doing a COPY-LISTon every &rest argument, to insure some normalcy.  Her reasoning seemsto bolster the case for those who claim that the current CL semantics(MAY-SHARE) are deficient:    Subject: &REST Lists    Date: 24 Mar 88 12:23:15 EST (Thu)    From: gz@spt.entity.com (Gail Zacharias)    . . .     If Common Lisp doesn't require unshared &rest lists, then I think    it must provide a declarative version of this idiom so the COPY-LIST can    be portably avoided when it's redundant.  Seems to me that the fact that    this is a common case where users find a need for conditionalization    indicates a real deficiency in Common Lisp's specification.    . . . So we have a responsibility to resolve the very thorny issueof REST-LIST-ALLOCATION.        TITAN 
         TITAN 
           Z              Ã                                                                             ·             ï       2       b       ,              +       ³       
                   ¿                           Å             H                            Ý       
       )              %                   ó *zº*start*03645 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 12 Apr 88 07:28From: gooch%CHANGABANG.CAD.MCC:COM:XeroxSubject: &rest [discussion] replacement/additionIn-Reply-to: <19880408222959.6.BARMAR@OCCAM.THINK.COM>Reply-to: gooch%MCC:COM:XeroxTo: barmar%Think.COM%MCC:COM:Xeroxcc: edsel!jonl%labrea.Stanford.EDU%mcc:COM:Xerox, common-lisp%sail.stanford.edu%mcc:COM:Xerox, spe%spice.cs.cmu.edu%mcc:COM:Xerox, ELIOT%cs.umass.edu%mcc:COM:Xerox, gz%spt.entity.com%mcc:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: William D. Gooch <gooch@CHANGABANG.CAD.MCC.COM>Subject: &rest [discussion] replacement/additionTo: barmar%Think.COM@MCC.COMcc: edsel!jonl%labrea.Stanford.EDU@mcc.com, common-lisp%sail.stanford.edu@mcc.com, spe%spice.cs.cmu.edu@mcc.com, ELIOT%cs.umass.edu@mcc.com, gz%spt.entity.com@mcc.comIn-Reply-To: <19880408222959.6.BARMAR@OCCAM.THINK.COM>Reply-To: gooch@MCC.COMReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 APR 88 07:28:21 PDTReceived: from MCC.COM by SAIL.Stanford.EDU with TCP; 12 Apr 88  06:54:18 PDTReceived: from HAL.CAD.MCC.COM by MCC.COM with TCP; Tue 12 Apr 88 08:51:03-CDTReceived: from CHANGABANG.CAD.MCC.COM by HAL.CAD.MCC.COM via CHAOS with CHAOS-MAIL id 78811; Tue 12-Apr-88 08:47:48 CDTOriginal-Date: Tue, 12 Apr 88 08:48 CDTMessage-ID: <880412084804.2.GOOCH@CHANGABANG.CAD.MCC.COM>Postal-address: MCC-CAD 3.8108Business-phone: (512) 338-3661GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 8 Apr 88 18:29 EDT    From: Barry Margolin <barmar@Think.COM>    I noticed you didn't try the following version.  This is identical to    the version you included in your message, except that it takes the    previous words as a single argument rather than as an &REST argument.    One definite advantage of this version is that it won't exceed    CALL-ARGUMENTS-LIMIT if it recurses deeply.I had run this version before, but neglected to include it in the timingruns.input string	code version		runtime (sec)	list consing (words)-------------------------------------------------------------------------hi there	no &rest, cons		14.25		1280ian gooch	no &rest, cons		138.3		4626    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    Date: Sat, 9 Apr 88 12:35 EDT    From: ELIOT%cs.umass.edu@RELAY.CS.NET	...I think &rest should always have a form which allows       its user to control consing, regardless of how performance might or       might not be affected.    After ALL the discussion about this topic, it seems that this claim should    be justified, if it is going to be made at all.  I think there is general    agreement that the only reason why the user might need control over consing    &rest lists is the effect on performance.You're right.  I guess I didn't mean that the way it came out.Performance is the object, but my current assumption is that consingmust adversely affect overall performance. 	Your data does not seem    to show such an effect.  Another experiment you could try would be to    run the same examples many times (100 or 1000 times) with the    garbage collector on.  The idea is to do so much consing that the GC must    run.  That way you can claim that the timings include the GC overhead.Good idea.  Results later.    If you do that and still get practically the same runtime results for all    of the different versions, then I think you should conclude that the runtime    of your example does not depend upon how the &rest list is handled.  -- William D. Gooch*start*06618 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 16:40:20 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  16:22:35 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 16:11:10 PSTDate: 12 Dec 88 16:08 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: REST-LIST-ALLOCATION (Version 3)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-161110-5531@Xerox>Thanks to Will Clinger for getting a last minute revision in.!Forum:         CleanupIssue:         REST-LIST-ALLOCATIONReferences:    CLtL pp 107-108 (APPLY)Related issues: DYNAMIC-EXTENTCategory:      CLARIFICATIONEdit history:  8-Dec-88, Version 1 by Masinter               9-Dec-88, Version 2 by Clinger (add rationale, more discussion)               12-Dec-88, Version 3 by Clinger (delete bogus examples)Problem description:In the special case of calling a function with an &REST list via APPLY,Common Lisp fails to specify whether a new copy of the list is freshlyallocated.  For example, given (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*))does (APPLY #'FOO *MY-LIST*)return T?This issue is different from the question of the extent of "rest lists" inthe case when they *are* newly allocated which is indefinite; the issueDYNAMIC-EXTENT also contains some proposals about extent.Proposal (REST-LIST-ALLOCATION:NEWLY-ALLOCATED): Specify that &REST lists are newly allocated in the case when the functionis called via APPLY.Proposal (REST-LIST-ALLOCATION:MAY-SHARE): Specify that the value of an &REST parameter is permitted, but not required,to share (top-level) structure with the last argument to APPLY.Proposal (REST-LIST-ALLOCATION:MUST-SHARE)Specify that the value of an &REST parameter is requiredto share (top-level) structure with the last argument to APPLY.>> this needs better spec about how the args match << Examples: (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*)) (APPLY #'FOO *MY-LIST*) => T ;on Symbolics systems and probably			      ; many stock hardware implementationsThis implies that (DEFUN BAR (&REST X) (RPLACA X 'D)) (APPLY #'BAR *MY-LIST*) *MY-LIST* => (D B C) ;on Symbolics systems and probably many stock		      ; hardware implementationsAnother example: which of the following have the same semantics?    (setq x '(1 2 3))    [1] (apply #'foo 1 2 3 NIL)    [2] (apply #'foo 1 2 (cddr x))    [3] (apply #'foo 1 (cdr x))    [4] (apply #'foo x)    [5] (funcall #'foo 1 2 3)Under REST-LIST-ALLOCATION:NEWLY-ALLOCATED:  [1]-[5] are equivalent.Under REST-LIST-ALLOCATION:MAY-SHARE:  Any answer to the question is correct for some conceivable implementation.  Abstracting over implementations, this means that [1]-[5] are pairwise  non-equivalent.Under REST-LIST-ALLOCATION:MUST-SHARE:  [1]-[4] are pairwise non-equivalent in all implementations.  This proposal  leaves open the question of whether [1] is equivalent to [5].And finally:Should     (defun foo (&rest x) ...)         behave (aside from efficiency) as if it were defined:    (defun foo (&rest G0047)     ;Gensym really      (let ((x (copy-list G0047)))         ...))    Rationale:The semantics of APPLY is unclear.  In consequence it is impossibleto write portable code that relies on &REST arguments sharing structurewith the last argument to APPLY.  Portable code can rely on &REST arguments*not* sharing structure with the last argument to APPLY, but only byperforming an explicit COPY-LIST on all &REST arguments; this is redundantand inefficient in implementations where &REST arguments are newlyallocated anyway.Current practice:Some implementations always share. Some implementations never share.A few may share interpreted and not share compiled, or vice versa.Cost to Implementors:None for MAY-SHARE, since that is the status quo.  Both of the otherproposals entail a significant cost for some implementations.If MUST-SHARE is adopted, then implementations that don't share structuremay be nearly impossible to convert.  If NEWLY-ALLOCATED is adopted, thenimplementations that do share will have to insert a call to COPY-LISTinside either APPLY or &REST list handling, which will slow things downand may be difficult as well.Cost to Users:No matter what, somebody gets hurt.  MAY-SHARE means you have towrite awkward and inefficient code if you care.  (This is alreadythe case for portable code.)  MUST-SHARE means you have to addexplicit calls to COPY-LIST to code that assumes the contrary.NEWLY-ALLOCATED means you have to rewrite code that assumes sharing.Cost of non-adoption:Great confusion over the issue.  A certain amount of awkwardness andinefficiency would remain inevitable if you want to write portable code.Performance impact:MUST-SHARE costs least in consing, but might slow down function call for some implementations.  MAY-SHARE lets implementations pick, hasleast impact.  NEWLY-ALLOCATED requires consing in cases where itdidn't before.Benefits:Less confusion.  Improved portability.Esthetics:Differing, strongly held opinions.Discussion:The Revised3 Report on Scheme specifies that the equivalent of a&REST argument must be a newly allocated list, to avoid precisely thisproblem.The argument for MUST-SHARE is that copying is inefficient, so&REST should never cause copying of a list passed to it from APPLY.Functions that desire a new copy can just call COPY-LIST.Two arguments for MAY-SHARE are:1. In no other place does Common Lisp automatically unshare structure,except when the user is explicitly modifying the structure (as in REMOVE).Making APPLY automatically unshare would be a semantic wart.2. If APPLY copies its last argument, recursive programs that receive an&REST argument and pass it to APPLY become inefficient.  A linear timealgorithm can change to a quadratic time algorithm.  While the efficiencycould be regained through compiler flow analysis in many cases, it'sbetter not to put the inefficiency into the language in the first place.The DYNAMIC-EXTENT proposal would allow &REST liststhat were "newly allocated" to have dynamic extent if they wereto be passed down via APPLY.  This puts the burden in theright place.Two (closely related) arguments for NEWLY-ALLOCATED:1. The programmer's model of function calling is simpler: functionstake arguments, and any two calls that pass *start*08529 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 16:40:20 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  16:22:35 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 16:11:10 PSTDate: 12 Dec 88 16:08 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: REST-LIST-ALLOCATION (Version 3)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-161110-5531@Xerox>Thanks to Will Clinger for getting a last minute revision in.!Forum:         CleanupIssue:         REST-LIST-ALLOCATIONReferences:    CLtL pp 107-108 (APPLY)Related issues: DYNAMIC-EXTENTCategory:      CLARIFICATIONEdit history:  8-Dec-88, Version 1 by Masinter               9-Dec-88, Version 2 by Clinger (add rationale, more discussion)               12-Dec-88, Version 3 by Clinger (delete bogus examples)Problem description:In the special case of calling a function with an &REST list via APPLY,Common Lisp fails to specify whether a new copy of the list is freshlyallocated.  For example, given (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*))does (APPLY #'FOO *MY-LIST*)return T?This issue is different from the question of the extent of "rest lists" inthe case when they *are* newly allocated which is indefinite; the issueDYNAMIC-EXTENT also contains some proposals about extent.Proposal (REST-LIST-ALLOCATION:NEWLY-ALLOCATED): Specify that &REST lists are newly allocated in the case when the functionis called via APPLY.Proposal (REST-LIST-ALLOCATION:MAY-SHARE): Specify that the value of an &REST parameter is permitted, but not required,to share (top-level) structure with the last argument to APPLY.Proposal (REST-LIST-ALLOCATION:MUST-SHARE)Specify that the value of an &REST parameter is requiredto share (top-level) structure with the last argument to APPLY.>> this needs better spec about how the args match << Examples: (DEFVAR *MY-LIST* '(A B C)) (DEFUN FOO (&REST X) (EQ X *MY-LIST*)) (APPLY #'FOO *MY-LIST*) => T ;on Symbolics systems and probably			      ; many stock hardware implementationsThis implies that (DEFUN BAR (&REST X) (RPLACA X 'D)) (APPLY #'BAR *MY-LIST*) *MY-LIST* => (D B C) ;on Symbolics systems and probably many stock		      ; hardware implementationsAnother example: which of the following have the same semantics?    (setq x '(1 2 3))    [1] (apply #'foo 1 2 3 NIL)    [2] (apply #'foo 1 2 (cddr x))    [3] (apply #'foo 1 (cdr x))    [4] (apply #'foo x)    [5] (funcall #'foo 1 2 3)Under REST-LIST-ALLOCATION:NEWLY-ALLOCATED:  [1]-[5] are equivalent.Under REST-LIST-ALLOCATION:MAY-SHARE:  Any answer to the question is correct for some conceivable implementation.  Abstracting over implementations, this means that [1]-[5] are pairwise  non-equivalent.Under REST-LIST-ALLOCATION:MUST-SHARE:  [1]-[4] are pairwise non-equivalent in all implementations.  This proposal  leaves open the question of whether [1] is equivalent to [5].And finally:Should     (defun foo (&rest x) ...)         behave (aside from efficiency) as if it were defined:    (defun foo (&rest G0047)     ;Gensym really      (let ((x (copy-list G0047)))         ...))    Rationale:The semantics of APPLY is unclear.  In consequence it is impossibleto write portable code that relies on &REST arguments sharing structurewith the last argument to APPLY.  Portable code can rely on &REST arguments*not* sharing structure with the last argument to APPLY, but only byperforming an explicit COPY-LIST on all &REST arguments; this is redundantand inefficient in implementations where &REST arguments are newlyallocated anyway.Current practice:Some implementations always share. Some implementations never share.A few may share interpreted and not share compiled, or vice versa.Cost to Implementors:None for MAY-SHARE, since that is the status quo.  Both of the otherproposals entail a significant cost for some implementations.If MUST-SHARE is adopted, then implementations that don't share structuremay be nearly impossible to convert.  If NEWLY-ALLOCATED is adopted, thenimplementations that do share will have to insert a call to COPY-LISTinside either APPLY or &REST list handling, which will slow things downand may be difficult as well.Cost to Users:No matter what, somebody gets hurt.  MAY-SHARE means you have towrite awkward and inefficient code if you care.  (This is alreadythe case for portable code.)  MUST-SHARE means you have to addexplicit calls to COPY-LIST to code that assumes the contrary.NEWLY-ALLOCATED means you have to rewrite code that assumes sharing.Cost of non-adoption:Great confusion over the issue.  A certain amount of awkwardness andinefficiency would remain inevitable if you want to write portable code.Performance impact:MUST-SHARE costs least in consing, but might slow down function call for some implementations.  MAY-SHARE lets implementations pick, hasleast impact.  NEWLY-ALLOCATED requires consing in cases where itdidn't before.Benefits:Less confusion.  Improved portability.Esthetics:Differing, strongly held opinions.Discussion:The Revised3 Report on Scheme specifies that the equivalent of a&REST argument must be a newly allocated list, to avoid precisely thisproblem.The argument for MUST-SHARE is that copying is inefficient, so&REST should never cause copying of a list passed to it from APPLY.Functions that desire a new copy can just call COPY-LIST.Two arguments for MAY-SHARE are:1. In no other place does Common Lisp automatically unshare structure,except when the user is explicitly modifying the structure (as in REMOVE).Making APPLY automatically unshare would be a semantic wart.2. If APPLY copies its last argument, recursive programs that receive an&REST argument and pass it to APPLY become inefficient.  A linear timealgorithm can change to a quadratic time algorithm.  While the efficiencycould be regained through compiler flow analysis in many cases, it'sbetter not to put the inefficiency into the language in the first place.The DYNAMIC-EXTENT proposal would allow &REST liststhat were "newly allocated" to have dynamic extent if they wereto be passed down via APPLY.  This puts the burden in theright place.Two (closely related) arguments for NEWLY-ALLOCATED:1. The programmer's model of function calling is simpler: functionstake arguments, and any two calls that pass the same arguments to thesame function are equivalent.  The MAY-SHARE and MUST-SHARE proposalsrequire a model in which functions generally take their arguments inthe form of a list, and the extent to which that list shares structurewith other lists in the system becomes an important part of thesemantics of a function call.2.  It's not only smashing a &rest argument that's a problem, it'ssmashing any list that has been given as the last argument to APPLY aswell.  Consider the following in an implementation that doesn't copythe last argument to APPLY when it is passed as a &rest argument:> (defvar *message*)*MESSAGE*> (defun set-message (&rest mess)    (setq *message* mess))SET-MESSAGE> (let ((winner (list 'a 'winner)))    (apply #'set-message winner)    (setf (cdr winner) (list 'loser))    winner)(A LOSER)Is *message* (A WINNER) or (A LOSER)?  (It might be(#<DTP-LOCATIVE 76123756> #<DTP-ODD-PC 12313453> ...)but that's a different problem.)  This suggests that once a list hasbeen given as the last argument to APPLY it is no longer OK to modifyit.Gail Zacharias talked about the common idiom of simply doing a COPY-LISTon every &rest argument, to insure some normalcy.  Her reasoning seemsto bolster the case for those who claim that the current CL semantics(MAY-SHARE) are deficient:    Subject: &REST Lists    Date: 24 Mar 88 12:23:15 EST (Thu)    From: gz@spt.entity.com (Gail Zacharias)    . . .     If Common Lisp doesn't require unshared &rest lists, then I think    it must provide a declarative version of this idiom so the COPY-LIST can    be portably avoided when it's redundant.  Seems to me that the fact that    this is a common case where users find a need for conditionalization    indicates a real deficiency in Common Lisp's specification.    . . . So we have a responsibility to resolve the very thorny issueof REST-LIST-ALLOCATION.*start*03004 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 13 DEC 88 18:15:55 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 508176; Tue 13-Dec-88 21:15:56 ESTDate: Tue, 13 Dec 88 21:15 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REST-LIST-ALLOCATION (Version 3)To: cl-cleanup@sail.stanford.educc: masinter.paIn-Reply-To: <881212-161110-5531@Xerox>Message-ID: <881213211541.3.KMP@BOBOLINK.SCRC.Symbolics.COM>This is a tough issue.NEWLY-ALLOCATED and MUST-SHARE have the virtue of involving the fewesthassles for portable code. Latent surprises of this kind are invariablyterribly hard to track down, and it's a definite feature to avoid theproblem.On the other hand, MAY-SHARE is the clearly efficient thing for what isprobably the most common case, so we should be careful not to pick asemantics that forces undue expense in that case.This problem may be related to the DYNAMIC-EXTENT issue. Just as we wantthe option of new structures being stack-allocated, we seem to want theoption of new structures being shared or unshared. I could imagine,as GZ suggests, a declaration to accomodate this. For example: (DEFUN FOO (&REST X)   (DECLARE (UNSHARED-STRUCTURE X))   ...)We might someday figure a way to generalize to other cases, such as usesof backquote. Consider: (LET ((X `(A ,B C)))   (DECLARE (UNSHARED-STRUCTURE X))   ...)For now, though, I think it best to consider restricting the variable toonly &REST variables (by not allowing the variable to be specified!).This kind of declaration may sound bizarre, but I think GZ is right inasserting that it's an important thing that portable programs must constantly reckon with and need a serious solution for.On the basis of the reasoning presented above, my position is that weshould do the following two things: - Drop the NEWLY-ALLOCATED and MUST-SHARE variants as practically   infeasible and ramp up MAY-SHARE. - Extend MAY-SHARE to include a mechanism that seriously addresses   the fact that sometimes we need to get a particular kind of   functionality. Perhaps declarations like     (REST-LIST-SHARING :NEVER)     (REST-LIST-SHARING :SOMETIMES)          (REST-LIST-SHARING :ALWAYS)   or     (REST-LIST-ALLOCATION :NEW)     (REST-LIST-ALLOCATION :UNSPECIFIC)     (REST-LIST-ALLOCATION :SHARE)   The only issue then would be whether there were implementations where   the always-share functionality would be impossible to implement (since   the never-share functionality could at least be simulated in    implementations where it couldn't be reliably detected), and whether we   were willing to allow such implementations to just signal an error in   that case. (If we were to permit implementations to not implement :SHARE,   we might be better off not offering the feature in the first place.)*start*03645 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 12 Apr 88 07:28From: gooch%CHANGABANG.CAD.MCC:COM:XeroxSubject: &rest [discussion] replacement/additionIn-Reply-to: <19880408222959.6.BARMAR@OCCAM.THINK.COM>Reply-to: gooch%MCC:COM:XeroxTo: barmar%Think.COM%MCC:COM:Xeroxcc: edsel!jonl%labrea.Stanford.EDU%mcc:COM:Xerox, common-lisp%sail.stanford.edu%mcc:COM:Xerox, spe%spice.cs.cmu.edu%mcc:COM:Xerox, ELIOT%cs.umass.edu%mcc:COM:Xerox, gz%spt.entity.com%mcc:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: William D. Gooch <gooch@CHANGABANG.CAD.MCC.COM>Subject: &rest [discussion] replacement/additionTo: barmar%Think.COM@MCC.COMcc: edsel!jonl%labrea.Stanford.EDU@mcc.com, common-lisp%sail.stanford.edu@mcc.com, spe%spice.cs.cmu.edu@mcc.com, ELIOT%cs.umass.edu@mcc.com, gz%spt.entity.com@mcc.comIn-Reply-To: <19880408222959.6.BARMAR@OCCAM.THINK.COM>Reply-To: gooch@MCC.COMReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 APR 88 07:28:21 PDTReceived: from MCC.COM by SAIL.Stanford.EDU with TCP; 12 Apr 88  06:54:18 PDTReceived: from HAL.CAD.MCC.COM by MCC.COM with TCP; Tue 12 Apr 88 08:51:03-CDTReceived: from CHANGABANG.CAD.MCC.COM by HAL.CAD.MCC.COM via CHAOS with CHAOS-MAIL id 78811; Tue 12-Apr-88 08:47:48 CDTOriginal-Date: Tue, 12 Apr 88 08:48 CDTMessage-ID: <880412084804.2.GOOCH@CHANGABANG.CAD.MCC.COM>Postal-address: MCC-CAD 3.8108Business-phone: (512) 338-3661GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 8 Apr 88 18:29 EDT    From: Barry Margolin <barmar@Think.COM>    I noticed you didn't try the following version.  This is identical to    the version you included in your message, except that it takes the    previous words as a single argument rather than as an &REST argument.    One definite advantage of this version is that it won't exceed    CALL-ARGUMENTS-LIMIT if it recurses deeply.I had run this version before, but neglected to include it in the timingruns.input string	code version		runtime (sec)	list consing (words)-------------------------------------------------------------------------hi there	no &rest, cons		14.25		1280ian gooch	no &rest, cons		138.3		4626    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    Date: Sat, 9 Apr 88 12:35 EDT    From: ELIOT%cs.umass.edu@RELAY.CS.NET	...I think &rest should always have a form which allows       its user to control consing, regardless of how performance might or       might not be affected.    After ALL the discussion about this topic, it seems that this claim should    be justified, if it is going to be made at all.  I think there is general    agreement that the only reason why the user might need control over consing    &rest lists is the effect on performance.You're right.  I guess I didn't mean that the way it came out.Performance is the object, but my current assumption is that consingmust adversely affect overall performance. 	Your data does not seem    to show such an effect.  Another experiment you could try would be to    run the same examples many times (100 or 1000 times) with the    garbage collector on.  The idea is to do so much consing that the GC must    run.  That way you can claim that the timings include the GC overhead.Good idea.  Results later.    If you do that and still get practically the same runtime results for all    of the different versions, then I think you should conclude that the runtime    of your example does not depend upon how the &rest list is handled.  -- William D. Gooch*start*01103 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 15:28:11 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  15:27:50 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 15:26:43 PSTDate: 2 Jan 89 15:25 PSTSender: masinter.paSubject: re: Issue: REST-LIST-ALLOCATION (Version 3)To: cl-cleanup@sail.stanford.eduFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Message-ID: <890102-152643-1745@Xerox>NEWLY-ALLOCATED: NOMUST-SHARE: NOI feel that both of these take away too much implementation freedom.  Whichleaves us with ...MAY-SHARE: YES.But I'd like to see something added that allows the programmer to force copyingwhen she cares, without requiring an explicit call to COPY-LIST (possiblyfeaturized).  Note that most cases of COPY-LIST on &REST parameters that I'veseen had nothing to do with the question of whether apply => &rest could share;they were put in to deal with implementations which always stack-cons &restlists.*start*04209 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 10:38:38 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Jan 89  10:36:26 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513971; Mon 2-Jan-89 13:25:47 ESTDate: Mon, 2 Jan 89 13:25 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REST-LIST-ALLOCATION (Version 3)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881213211541.3.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890102182514.3.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 13 Dec 88 21:15 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    This is a tough issue.    .... discussion elided for brevity ....    On the basis of the reasoning presented above, my position is that we    should do the following two things:     - Drop the NEWLY-ALLOCATED and MUST-SHARE variants as practically       infeasible and ramp up MAY-SHARE.I strongly agree with this.     - Extend MAY-SHARE to include a mechanism that seriously addresses       the fact that sometimes we need to get a particular kind of       functionality. Perhaps declarations like	 (REST-LIST-SHARING :NEVER)	 (REST-LIST-SHARING :SOMETIMES)     	 (REST-LIST-SHARING :ALWAYS)       or	 (REST-LIST-ALLOCATION :NEW)	 (REST-LIST-ALLOCATION :UNSPECIFIC)	 (REST-LIST-ALLOCATION :SHARE)Upin reflection, I don't support this part.  I can't understand why aportable program would ever depend on (REST-LIST-SHARING :ALWAYS),unless it's going to perform side-effects on the &rest list as a way ofpassing information back to the caller.  But I strongly believe thatside-effecting such a list is a really bad idea.  Any program that needsto create and modify a list should use an explicitly created list thatis passed as a normal argument, not the implicitly created list receivedas an &rest argument, in my opinion.  Also, as Kent pointed out theremight be implementations in which (REST-LIST-SHARING :ALWAYS) isimpossible to implement.The other reason for using (REST-LIST-SHARING :ALWAYS) might be a beliefthat it enhances efficiency.  But it seems to me that if sharing wasmore efficient than not sharing, the implementation would be doing italready, and in general the implementor knows better than the PORTABLEprogrammer what implementation technique for rest arguments is mostefficient.This leaves (REST-LIST-SHARING :NEVER).  The only justification for thisI can see that is that the program is going to perform side-effects onthe &rest list and wants them insulated from the caller, and furthermoredoesn't want the overhead of calling COPY-LIST in implementations thatdon't share.  This is certainly not as unreasonable as(REST-LIST-SHARING :ALWAYS), but it's still pretty specialized.  I havetwo objections to doing this with a declaration rather than withimperative code.  First: why should  (defun foo (&rest x)     (declare (rest-list-sharing :never))     (remf x :frob)     ...)compile into different instructions than  (defun foo (&rest x)     (setq x (copy-list x))     (remf x :frob)     ...)An implementation that never shares can easily notice the redundantcall to COPY-LIST and remove it.  All we need is a hint to programmersand implementors that this is an expected optimization.Second: declarations other than SPECIAL declarations are supposed to be"completely optional and correct declarations do not affect the meaningof a correct program."  A declaration about rest-list-sharing thatmakes it valid to perform side-effects on a rest-list clearly does notfit this dictum of CLtL.  On the other hand, if even with the declarationit is still not correct to perform side-effects on a rest-list, thenI don't see any use for (REST-LIST-SHARING :NEVER); it can only make aprogram slower.In conclusion, REST-LIST-ALLOCATION:MAY-SHARE without additionaldeclarations is the only proposal that I find viable and consistentwith the rest of Common Lisp.*start*01307 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 JAN 89 15:39:57 PSTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 5 Jan 89  15:39:31 PSTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA12186@EDDIE.MIT.EDU>; Thu, 5 Jan 89 18:38:12 ESTReceived: by spt.entity.com (smail2.5); 5 Jan 89 18:06:05 EST (Thu)To: cl-cleanup@sail.stanford.eduSubject: Issue: REST-LIST-ALLOCATION (Version 3)Message-Id: <8901051806.AA14403@spt.entity.com>Date: 5 Jan 89 18:06:05 EST (Thu)From: gz@spt.entity.com (Gail Zacharias)I would be (a little) more comfortable with MAY-SHARE if it explicitly statedthat the &rest argument is guaranteed to be a proper list.  I know this is notdirectly related to rest list sharing, but in practical terms I'mconcerned about the following situation:	(defun debugged-function (&rest args)	   (declare (optimize (safety 0)))	   ... (cadr args) ...)	(apply #'debugged-function '(a . 17))The error should be detected before debugged-function is called (orput another way, whether this error is detected or not should be determinedby optimize settings in effect around apply, not in debugged-function).*start*01188 00024 US Date:  2 Jan 89 19:14 PSTFrom: masinter.paSubject: Re: Issue: REST-LIST-ALLOCATION (Version 3)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 13 Dec 88 21:15 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: cl-cleanup@sail.stanford.edu, masinter.pare: "The only issue then would be whether there were implementations where the always-share functionality would be impossible to implement" In the Medley implementation of Common Lisp (and in all the Interlisp implementations I'm familiar with), APPLY always "spreads" its arguments on the stack, independent of the internal argument structure of the recipient function; an &REST argument is always "consed" from the stack structure. In this implementation, always-share would require APPLY to "look ahead" somehow, and invoke some kind of alternate version of the function which could take the rest list "shared". Re "Perhaps declarations like...."I am opposed to adding declarations that change the behavior of correct programs. Except for SPECIAL, declarations change only the "checking" for incorrect programs and not the behavior of correct programs.*start*01652 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 09:02:36 PSTReceived: from mist.math.uoregon.edu ([128.223.4.3]) by SAIL.Stanford.EDU with TCP; 3 Jan 89  09:02:25 PSTReceived: from fog.cs.uoregon.edu by mist.math.uoregon.edu; Tue, 3 Jan 89 09:00:06 PDTReceived: by fog.cs.uoregon.edu; Tue, 3 Jan 89 08:59:44 PDTDate: Tue, 3 Jan 89 08:59:44 PDTFrom: William Clinger <will@fog.cs.uoregon.edu>Message-Id: <8901031659.AA06887@fog.cs.uoregon.edu>To: Moon@STONY-BROOK.SCRC.Symbolics.COM, cl-cleanup@sail.stanford.eduSubject: Re:  Issue: REST-LIST-ALLOCATION (Version 3)Moon writes of his example that:  All I did was change APPLY to FUNCALL, and remove the corresponding  &REST.  I find it inconsistent if calling with APPLY is guaranteed to  copy one of the arguments, but calling with FUNCALL is not.To my way of thinking, APPLY never copies any arguments so APPLY isperfectly consistent with FUNCALL even if &REST lists are alwaysfreshly consed.  You see, my understanding of APPLY is that it callsits first argument on the elements of the list that is its secondargument (or the analagous thing if you give it more than two arguments).The arguments, therefore, are the elements of the list, not the listitself, and so the arguments are not copied.It is true that the list created by &REST list processing may happen tobe a copy of some existing list, possibly even a list that was oncepassed to APPLY, but I don't see why APPLY should be given credit forhaving made the copy.Peace, Will*start*02139 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 09:39:10 PSTReceived: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by SAIL.Stanford.EDU with TCP; 3 Jan 89  09:38:25 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 255261; Tue 3-Jan-89 12:37:06 ESTDate: Tue, 3 Jan 89 12:36 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re:  Issue: REST-LIST-ALLOCATION (Version 3)To: William Clinger <will@fog.cs.uoregon.edu>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8901031659.AA06887@fog.cs.uoregon.edu>Message-ID: <19890103173617.5.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 3 Jan 89 08:59:44 PDT    From: William Clinger <will@fog.cs.uoregon.edu>    Moon writes of his example that:      All I did was change APPLY to FUNCALL, and remove the corresponding      &REST.  I find it inconsistent if calling with APPLY is guaranteed to      copy one of the arguments, but calling with FUNCALL is not.    To my way of thinking, APPLY never copies any arguments so APPLY is    perfectly consistent with FUNCALL even if &REST lists are always    freshly consed.  You see, my understanding of APPLY is that it calls    its first argument on the elements of the list that is its second    argument (or the analagous thing if you give it more than two arguments).    The arguments, therefore, are the elements of the list, not the list    itself, and so the arguments are not copied.    It is true that the list created by &REST list processing may happen to    be a copy of some existing list, possibly even a list that was once    passed to APPLY, but I don't see why APPLY should be given credit for    having made the copy.Something happens in between the APPLY and the &REST.  You think of it asconnected with the &REST, I think of it as connected with the APPLY, andsomeone else might think of it as an independent thing not really connectedwith either of them.  Okay.Peace yourself.*start*02915 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 22:32:28 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 3 Jan 89  22:30:35 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03970g; Tue, 3 Jan 89 22:25:13 PSTReceived: by bhopal id AA01102g; Tue, 3 Jan 89 22:27:25 PSTDate: Tue, 3 Jan 89 22:27:25 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901040627.AA01102@bhopal>To: will@fog.cs.uoregon.eduCc: Moon@STONY-BROOK.SCRC.Symbolics.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: William Clinger's message of Tue, 3 Jan 89 08:59:44 PDT <8901031659.AA06887@fog.cs.uoregon.edu>Subject:  Issue: REST-LIST-ALLOCATION (Version 3)re: To my way of thinking, APPLY never copies any arguments so APPLY is    perfectly consistent with FUNCALL even if &REST lists are always    freshly consed.  You see, my understanding of APPLY is that it calls    its first argument on the elements of the list that is its second    argument (or the analagous thing if you give it more than two arguments).    The arguments, therefore, are the elements of the list, not the list    itself, and so the arguments are not copied.There was much debate on the Common-Lisp mailing list some months back,and I vaguely remember the upshot being that "users" definitely did notwant the _default_ state of &rests to be anything optimized -- it leadsto far too much confusion when debugging.  On the other side, numerousimplementors (especially those with roots in MIT) argued at length forthe freedom to make one or other time-saving or space-sharing hack.In acknowledgement of the trade-off between efficiency and "clean, simple" semantics, people seemed willing to allow a declaration whichpermited one or more of these hacks.  For example, DYNAMIC-EXTENT couldbe applied to the variable holding the &rest argument, meaning thatit is OK to stack-cons it.  Gail Zacharias stated this position mostsuccinctly -- the demand for simple semantics by default, with "hair"to be added at the users discretion -- although it would take me awhile to resurrect the old mail.  [Frankly, however, I don't rememberanyone proposing a declaration/proclamation that permitted theAPPLY-->&rest hack.]Many of  the arguments against "sharing" were similar to what I've quoted from your msg above.  I agree with your explanation of APPLY, eventhough I'm an implementor with "roots in MIT" (actually, so is GZ!).Lucid's implementation works similar to Xerox/Envos' Medley in regardto &rest treatment; however it does have a stack-consing capabilityenabled by declarations.  Either way, as Larry Masinter points out,it would be a tremendous re-vamp of the implemntation to even permitthe smallest amount of sharing when called via APPLY.-- JonL --*start*00896 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 19:14:57 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Jan 89  19:13:36 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 09 JAN 89 17:53:34 PSTDate: 9 Jan 89 17:52 PSTFrom: masinter.paSubject: Re: Issue: REST-LIST-ALLOCATION (Version 3)In-reply-to: gz@spt.entity.com (Gail Zacharias)'s message of 5 Jan 89 18:06:05 EST (Thu)To: gz@spt.entity.com (Gail Zacharias)cc: cl-cleanup@sail.stanford.eduMessage-ID: <890109-175334-5056@Xerox>My reading of CLtL is that no setting of the OPTIMIZE/SAFETY settingrequires checking for invalid arguments to CADR.The only thing that SAFETY 0 does is allow you to turn off some of theerror checking that CLtL requires you normally to enforce.