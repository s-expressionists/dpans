*start*02264 00024 USfReturn-Path: <@SAIL.STANFORD.EDU:unido!ztivax!kolb@seismo.CSS.GOV>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 14 AUG 87 16:52:48 PDTReceived: from seismo.CSS.GOV by SAIL.STANFORD.EDU with TCP; 14 Aug 87  16:51:10 PDTReceived: from unido.UUCP by seismo.CSS.GOV (5.54/1.14) with UUCP 	id AA13396; Fri, 14 Aug 87 19:51:00 EDTReceived: by unido.uucp with uucp; 	  Fri, 14 Aug 87 16:01:15 +0100From: "Dieter Kolb" <unido!ztivax!kolb@seismo.CSS.GOV>Date: Fri, 14 Aug 87 15:06:16 -0100Message-Id: <8708141406.AA04604@ztivax.uucp>Received: by ztivax.uucp; Fri, 14 Aug 87 15:06:16 -0100To: CL-Cleanup@sail.stanford.eduSubject: Redefinition of system functionsProblem description:CLtL allows the redefinition of functions exported from other packages. Unexperienced programmers may redefine a system function unintentional which may result into an inconsistent state of the system and cause to abort.This happens, for example, if a beginner follows the CL introductory book "Essential LISP" by Anderson et.al. page 41 where an exercise asks to define a function make-list. After the redefinition of make-list the system crashs without returning a message that the function has been redefined.CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions.Solution:Redefinition of exported functions should stay allowed. However, some functions - especially all functions of the package LISP -  should be protected from redefinition. In the case a user tries to redefine such a function a confirmation should be required.Protected user functions can be specified in a special list (look-up-table, value of the variable *protected-functions-from-redefinition*). Functions from package LISP are protected per se and have not to be added into this list. There should be two functions to add and to remove an entry to/from this list:protect-function-from-redefinition namerelease-function-for-redefinition nameThe only function involved in protecting functions from redefinition seems to be defun. Advising (in the sense of Interlisp) protected functions, however, should stay allowed. Dieter Kolb*start*01837 00024 USfReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 14 AUG 87 20:56:38 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 14 Aug 87  20:54:58 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Fri 14 Aug 87 23:54:46-EDTDate: Fri, 14 Aug 87 23:54 EDTMessage-ID: <FAHLMAN.12326577897.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Dieter Kolb <unido!ztivax!kolb@SEISMO.CSS.GOV>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Redefinition of system functionsIn-reply-to: Msg of Fri 14 Aug 87 15:06:16 -0100 from Dieter Kolb <unido!ztivax!kolb at seismo.CSS.GOV>If there are functions whose redefinition would destroy a particularLisp system, I wouldn't mind getting a warning and perhaps even acorrectable error from DEFUN if I am about to lose.  The set ofprotected functions might include all of the built-in Common Lispfunctions, or it might be a small subset, depending on the details ofthe implementation.There must be a way to turn this protection off, however -- some peopleknow what they are doing and don't want Lisp to save them.  Advising isone such case, patching over bugs in the built-in functions is another,and turning a built-in function into a CLOS generic function so that newbehaviors can be added for new types is yet another (once we decide howmuch of this will be allowed).In any case, I think that such protection probably should be consideredan programming-environment issue that is left up to each implementor.Is there any real need for a standard solution here?  I suppose we doneed to make clear that randomly modifying the built-in functions is notsomething that is allowed in strictly legal Common Lisp programs.-- Scott*start*00898 00024 USfDate: 16 Aug 87 01:39 PDTFrom: masinter.paTO: MASINTERSubject: Re: Redefinition of system functionsIn-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Fri, 14 Aug 87 23:54 EDTTo: CL-Cleanup@SAIL.STANFORD.EDUI suppose this sort of policy issue should be handled by the cleanup committee too. I'm not sure the form/format we've been using for specific changes is appropriate.There are two policy issues that come to mind: one is the policy on syntactic extensions (as IF-BODY became) and this is the second. To echo what you've said in different words:Issue: LISP-SYMBOL-REDEFINITIONIt "is an error" to redefine or modify any of the functions in CLtL, that environments are encoraged to check for this error, signal it or at least ask the user whether it is really intended. I've been less sure if this deserves a "cleanup", but since it is *start*09367 00024 USfDate: 20 Nov 87 13:34 PSTFrom: Masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITIONTo: Dabrowski@ICST-ECF.ARPAcc: MasinterLine-fold: NOThe tricky part of this issue, which I believe should say that it is an error to redefine or shadow any symbol in the CLtL, is to add the justification, make clear that the wording says that of course good programming environments might well allow TRACE or BREAK or whatever on them, but that those are environment issues, and as far as the STANDARD is concerned, you can't do it.Enclosed is the proposal format and the mail I have collected on this topic. If you like, you can send me a copy of the proposal for forwarding on to the cleanup committee for review.This is the proposal format with some changes to section titles, a bitof reorganization (to put the Costs together and the Benefits together),and some minor changes to the rules: I described what I thought was anExample vs a Test Case, etc.  Format for proposals to the cleanup committee (Version 13)                    November 20, 1987Replace the text below in >> double inverted angle-brackets <<. Bebrief; leave testimonials and personal opinions to the discussion at theend. Be complete; do not expect someone else to fix or redesign parts.Spell out names (e.g., Masinter rather than LMM) and upper-case all Lispsymbols (DEFUN rather than Defun). I like it better if you write in thethird person rather than first.Issue:         >>A short descriptive label, which starts with a name               which occurs in the index of CLtL, and be a suitable               symbol in the Common Lisp style, e.g., CDR-TERMINATION.<<References:    >>The pages of CLtL which describe the feature being               discussed, and other references, including other               related issues.<<Category:      >>One or more of:               CLARIFICATION -- proposal to resolve an ambiguity or case               of under-specified situation in CLtL, where this               ambiguity interferes with portability of code.               CHANGE -- proposal for an incompatible change.               ADDITION -- proposal for a compatible extension<<Edit history:  >>Author and date of submission (version 1), and author               and date of subsequent versions.<<Problem description:>>Describe the problem being addressed -- why is the current situationunclear or unsatisfactory? Avoid describing the proposal here or arguingfor its adoption. <<Proposal (>>issue-label:proposal-label<<): >> Describe as precisely aspossible what you are proposing.  Ideally, this should take the form oftext that could be dropped into the new specification document.Proposals should be for changes to Common Lisp, rather than changes toCLtL.  If necessary, propose a set of labelled alternatives here, ratherthan a single proposal. Each proposal must be a complete design; do notleave out details.  Avoid arguing for the proposal here, just describeit.<<Test Cases/Examples:>> Examples are samples of Common Lisp code that illustrates the issue.along with explanatory text.Test Cases are simple stand-alone expressions which are valid anddo not signal an error if the proposal is adhered to. (Use ASSERTif you need.)<<Rationale:>> A one or two sentence summary of the arguments that follow. <<Current practice:>>Do some/many/no Common Lisp implementations already work this way?Survey independent Common Lisp implementations - preferably three ormore.<<Cost to Implementors:>>What is the cost to implementors of adopting the proposal?  How muchimplementation effort is required?  Is public-domain code available? Forpervasive changes, can the conversion be automated?<<Cost to Users:>>For incompatible changes, what is the cost to users of convertingexisting user code?  To what extent can the process be automated? How?<<Cost of non-adoption:>>How serious is it if nothing is done? <<Benefits:>>What is better if the proposal is adopted? How serious is the problemif just left as it is? <<Esthetics:>>How does this proposal affect the simplicity of the language, ease oflearning, etc. You can spell it aesthetics if you like. <<Discussion:>> Additional arguments, discussions, endorsements, testimonials, etc.should go here. A blow-by-blow account of debates is not necessary. <<Return-Path: <@SAIL.STANFORD.EDU:unido!ztivax!kolb@seismo.CSS.GOV>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 14 AUG 87 16:52:48 PDTReceived: from seismo.CSS.GOV by SAIL.STANFORD.EDU with TCP; 14 Aug 87  16:51:10 PDTReceived: from unido.UUCP by seismo.CSS.GOV (5.54/1.14) with UUCP 	id AA13396; Fri, 14 Aug 87 19:51:00 EDTReceived: by unido.uucp with uucp; 	  Fri, 14 Aug 87 16:01:15 +0100From: "Dieter Kolb" <unido!ztivax!kolb@seismo.CSS.GOV>Date: Fri, 14 Aug 87 15:06:16 -0100Message-Id: <8708141406.AA04604@ztivax.uucp>Received: by ztivax.uucp; Fri, 14 Aug 87 15:06:16 -0100To: CL-Cleanup@sail.stanford.eduSubject: Redefinition of system functionsProblem description:CLtL allows the redefinition of functions exported from other packages. Unexperienced programmers may redefine a system function unintentional which may result into an inconsistent state of the system and cause to abort.This happens, for example, if a beginner follows the CL introductory book "Essential LISP" by Anderson et.al. page 41 where an exercise asks to define a function make-list. After the redefinition of make-list the system crashs without returning a message that the function has been redefined.CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions.Solution:Redefinition of exported functions should stay allowed. However, some functions - especially all functions of the package LISP -  should be protected from redefinition. In the case a user tries to redefine such a function a confirmation should be required.Protected user functions can be specified in a special list (look-up-table, value of the variable *protected-functions-from-redefinition*). Functions from package LISP are protected per se and have not to be added into this list. There should be two functions to add and to remove an entry to/from this list:protect-function-from-redefinition namerelease-function-for-redefinition nameThe only function involved in protecting functions from redefinition seems to be defun. Advising (in the sense of Interlisp) protected functions, however, should stay allowed. Dieter Kolb     ----- Next Message -----Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 14 AUG 87 20:56:38 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 14 Aug 87  20:54:58 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Fri 14 Aug 87 23:54:46-EDTDate: Fri, 14 Aug 87 23:54 EDTMessage-ID: <FAHLMAN.12326577897.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Dieter Kolb <unido!ztivax!kolb@SEISMO.CSS.GOV>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Redefinition of system functionsIn-reply-to: Msg of Fri 14 Aug 87 15:06:16 -0100 from Dieter Kolb <unido!ztivax!kolb at seismo.CSS.GOV>If there are functions whose redefinition would destroy a particularLisp system, I wouldn't mind getting a warning and perhaps even acorrectable error from DEFUN if I am about to lose.  The set ofprotected functions might include all of the built-in Common Lispfunctions, or it might be a small subset, depending on the details ofthe implementation.There must be a way to turn this protection off, however -- some peopleknow what they are doing and don't want Lisp to save them.  Advising isone such case, patching over bugs in the built-in functions is another,and turning a built-in function into a CLOS generic function so that newbehaviors can be added for new types is yet another (once we decide howmuch of this will be allowed).In any case, I think that such protection probably should be consideredan programming-environment issue that is left up to each implementor.Is there any real need for a standard solution here?  I suppose we doneed to make clear that randomly modifying the built-in functions is notsomething that is allowed in strictly legal Common Lisp programs.-- Scott     ----- Next Message -----Date: 16 Aug 87 01:39 PDTFrom: masinter.paTO: MASINTERSubject: Re: Redefinition of system functionsIn-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Fri, 14 Aug 87 23:54 EDTTo: CL-Cleanup@SAIL.STANFORD.EDUI suppose this sort of policy issue should be handled by the cleanup committee too. I'm not sure the form/format we've been using for specific changes is appropriate.There are two policy issues that come to mind: one is the policy on syntactic extensions (as IF-BODY became) and this is the second. To echo what you've said in different words:Issue: LISP-SYMBOL-REDEFINITIONIt "is an error" to redefine or modify any of the functions in CLtL, that environments are encoraged to check for this error, signal it or at least ask the user whether it is really intended.      ----- End Forwarded Messages -----*start*09655 00024 US Date: 20 Nov 87 13:39:40 PST (Friday)From: Mailer.paTo: Masinter.paSubject: Undeliverable mailICST-ECF.ARPA said 554 Unable to deliver mail to given recipient(s)The text of your message was--------------------Received: from Cabernet.ms by ArpaGateway.ms ; 20 NOV 87 13:34:40 PSTDate: 20 Nov 87 13:34 PSTFrom: Masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITIONTo: Dabrowski@ICST-ECF.ARPAcc: MasinterLine-fold: NOThe tricky part of this issue, which I believe should say that it is an error to redefine or shadow any symbol in the CLtL, is to add the justification, make clear that the wording says that of course good programming environments might well allow TRACE or BREAK or whatever on them, but that those are environment issues, and as far as the STANDARD is concerned, you can't do it.Enclosed is the proposal format and the mail I have collected on this topic. If you like, you can send me a copy of the proposal for forwarding on to the cleanup committee for review.This is the proposal format with some changes to section titles, a bitof reorganization (to put the Costs together and the Benefits together),and some minor changes to the rules: I described what I thought was anExample vs a Test Case, etc.  Format for proposals to the cleanup committee (Version 13)                    November 20, 1987Replace the text below in >> double inverted angle-brackets <<. Bebrief; leave testimonials and personal opinions to the discussion at theend. Be complete; do not expect someone else to fix or redesign parts.Spell out names (e.g., Masinter rather than LMM) and upper-case all Lispsymbols (DEFUN rather than Defun). I like it better if you write in thethird person rather than first.Issue:         >>A short descriptive label, which starts with a name               which occurs in the index of CLtL, and be a suitable               symbol in the Common Lisp style, e.g., CDR-TERMINATION.<<References:    >>The pages of CLtL which describe the feature being               discussed, and other references, including other               related issues.<<Category:      >>One or more of:               CLARIFICATION -- proposal to resolve an ambiguity or case               of under-specified situation in CLtL, where this               ambiguity interferes with portability of code.               CHANGE -- proposal for an incompatible change.               ADDITION -- proposal for a compatible extension<<Edit history:  >>Author and date of submission (version 1), and author               and date of subsequent versions.<<Problem description:>>Describe the problem being addressed -- why is the current situationunclear or unsatisfactory? Avoid describing the proposal here or arguingfor its adoption. <<Proposal (>>issue-label:proposal-label<<): >> Describe as precisely aspossible what you are proposing.  Ideally, this should take the form oftext that could be dropped into the new specification document.Proposals should be for changes to Common Lisp, rather than changes toCLtL.  If necessary, propose a set of labelled alternatives here, ratherthan a single proposal. Each proposal must be a complete design; do notleave out details.  Avoid arguing for the proposal here, just describeit.<<Test Cases/Examples:>> Examples are samples of Common Lisp code that illustrates the issue.along with explanatory text.Test Cases are simple stand-alone expressions which are valid anddo not signal an error if the proposal is adhered to. (Use ASSERTif you need.)<<Rationale:>> A one or two sentence summary of the arguments that follow. <<Current practice:>>Do some/many/no Common Lisp implementations already work this way?Survey independent Common Lisp implementations - preferably three ormore.<<Cost to Implementors:>>What is the cost to implementors of adopting the proposal?  How muchimplementation effort is required?  Is public-domain code available? Forpervasive changes, can the conversion be automated?<<Cost to Users:>>For incompatible changes, what is the cost to users of convertingexisting user code?  To what extent can the process be automated? How?<<Cost of non-adoption:>>How serious is it if nothing is done? <<Benefits:>>What is better if the proposal is adopted? How serious is the problemif just left as it is? <<Esthetics:>>How does this proposal affect the simplicity of the language, ease oflearning, etc. You can spell it aesthetics if you like. <<Discussion:>> Additional arguments, discussions, endorsements, testimonials, etc.should go here. A blow-by-blow account of debates is not necessary. <<Return-Path: <@SAIL.STANFORD.EDU:unido!ztivax!kolb@seismo.CSS.GOV>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 14 AUG 87 16:52:48 PDTReceived: from seismo.CSS.GOV by SAIL.STANFORD.EDU with TCP; 14 Aug 87  16:51:10 PDTReceived: from unido.UUCP by seismo.CSS.GOV (5.54/1.14) with UUCP 	id AA13396; Fri, 14 Aug 87 19:51:00 EDTReceived: by unido.uucp with uucp; 	  Fri, 14 Aug 87 16:01:15 +0100From: "Dieter Kolb" <unido!ztivax!kolb@seismo.CSS.GOV>Date: Fri, 14 Aug 87 15:06:16 -0100Message-Id: <8708141406.AA04604@ztivax.uucp>Received: by ztivax.uucp; Fri, 14 Aug 87 15:06:16 -0100To: CL-Cleanup@sail.stanford.eduSubject: Redefinition of system functionsProblem description:CLtL allows the redefinition of functions exported from other packages. Unexperienced programmers may redefine a system function unintentional which may result into an inconsistent state of the system and cause to abort.This happens, for example, if a beginner follows the CL introductory book "Essential LISP" by Anderson et.al. page 41 where an exercise asks to define a function make-list. After the redefinition of make-list the system crashs without returning a message that the function has been redefined.CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions.Solution:Redefinition of exported functions should stay allowed. However, some functions - especially all functions of the package LISP -  should be protected from redefinition. In the case a user tries to redefine such a function a confirmation should be required.Protected user functions can be specified in a special list (look-up-table, value of the variable *protected-functions-from-redefinition*). Functions from package LISP are protected per se and have not to be added into this list. There should be two functions to add and to remove an entry to/from this list:protect-function-from-redefinition namerelease-function-for-redefinition nameThe only function involved in protecting functions from redefinition seems to be defun. Advising (in the sense of Interlisp) protected functions, however, should stay allowed. Dieter Kolb     ----- Next Message -----Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 14 AUG 87 20:56:38 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 14 Aug 87  20:54:58 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Fri 14 Aug 87 23:54:46-EDTDate: Fri, 14 Aug 87 23:54 EDTMessage-ID: <FAHLMAN.12326577897.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Dieter Kolb <unido!ztivax!kolb@SEISMO.CSS.GOV>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Redefinition of system functionsIn-reply-to: Msg of Fri 14 Aug 87 15:06:16 -0100 from Dieter Kolb <unido!ztivax!kolb at seismo.CSS.GOV>If there are functions whose redefinition would destroy a particularLisp system, I wouldn't mind getting a warning and perhaps even acorrectable error from DEFUN if I am about to lose.  The set ofprotected functions might include all of the built-in Common Lispfunctions, or it might be a small subset, depending on the details ofthe implementation.There must be a way to turn this protection off, however -- some peopleknow what they are doing and don't want Lisp to save them.  Advising isone such case, patching over bugs in the built-in functions is another,and turning a built-in function into a CLOS generic function so that newbehaviors can be added for new types is yet another (once we decide howmuch of this will be allowed).In any case, I think that such protection probably should be consideredan programming-environment issue that is left up to each implementor.Is there any real need for a standard solution here?  I suppose we doneed to make clear that randomly modifying the built-in functions is notsomething that is allowed in strictly legal Common Lisp programs.-- Scott     ----- Next Message -----Date: 16 Aug 87 01:39 PDTFrom: masinter.paTO: MASINTERSubject: Re: Redefinition of system functionsIn-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Fri, 14 Aug 87 23:54 EDTTo: CL-Cleanup@SAIL.STANFORD.EDUI suppose this sort of policy issue should be handled by the cleanup committee too. I'm not sure the form/format we've been using for specific changes is appropriate.There are two policy issues that come to mind: one is the policy on syntactic extensions (as IF-BODY became) and this is the second. To echo what you've said in different words:Issue: LISP-SYMBOL-REDEFINITIONIt "is an error" to redefine or modify any of the functions in CLtL, that environments are encoraged to check for this error, signal it or at least ask the user whether it is really intended.      ----- End Forwarded Messages -----*start*40401 00024 US Date: 20 Nov 87 13:42 PSTFrom: Masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITIONTo: Dabrowski@icst-ecf.Arpacc: MasinterHere is more mail on the related issue of shadowing symbols with FLET/LABELS/MACROLET. I believe the consensus again is that it "should be" an error.     ----- Begin Forwarded Messages -----Originator: @SAIL.Stanford.EDU:pyrnj!pyramid!bein%RUTGERS:EDU:XeroxDate: 24 Oct 87 21:09From: pyrnj!pyramid!bein%RUTGERS:EDU:XeroxSubject: macrolet/flet/labelsTo: common-lisp@sail.stanford.edu%RUTGERS:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David Bein <pyrnj!pyramid!bein@RUTGERS.EDU>Subject: macrolet/flet/labelsTo: "common-lisp@sail.stanford.edu"@RUTGERS.EDUReturn-Path: <@SAIL.Stanford.EDU:pyrnj!pyramid!bein@RUTGERS.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 OCT 87 21:09:13 PDTReceived: from RUTGERS.EDU by SAIL.STANFORD.EDU with TCP; 24 Oct 87  20:35:59 PDTReceived: by RUTGERS.EDU (5.54/1.14) with UUCP 	id AA16558; Sat, 24 Oct 87 23:39:14 EDTReceived: from pyrnova.pyramid.COM (manpyrnova) by pyramid.UUCP (5.51/OSx4.0b-870424)	id AA23234; Sat, 24 Oct 87 19:01:02 PDTReceived: by pyrnova.pyramid.COM (5.52/OSx4.0b-870424)	id AA27898; Sat, 24 Oct 87 19:02:43 PDTOriginal-Date: 24 Oct 87 18:57 PDTMessage-Id: <562125428/bein@pyrnova>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV  What is the current consensus about using a namewithin a macrolet/flet/labels construct whichis a special form? I am cleaning things up thisway and it occurred to me that things could goeither way.  I think the only really ugly one is QUOTE since mostcompilers seem to treat that specially in all kinds ofplaces. Another equally nasty one would be FUNCTION.--David     ----- Next Message -----Originator: @SAIL.Stanford.EDU:Pavel.pa%Xerox:COM:XeroxDate: 25 Oct 87 16:58From: Pavel:PA:XeroxSubject: Re: macrolet/flet/labelsIn-Reply-to: <562125428/bein@pyrnova>To: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.Stanford.EDU:Pavel.pa@Xerox.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 16:58:10 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 25 Oct 87  16:20:49 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 25 OCT 87 16:21:30 PSTOriginal-Date: Sun, 25 Oct 87 15:44:22 PSTMessage-ID: <871025-162130-1009@Xerox>	Date: 24 Oct 87 18:57 PDT	From: David Bein <pyrnj!pyramid!bein@RUTGERS.EDU>	  What is the current consensus about using a name	within a macrolet/flet/labels construct which	is a special form? I am cleaning things up this	way and it occurred to me that things could go	either way.I am of the opinion that the names of the special forms are reallyreserved words and that you cannot redefine them even lexically.  Thus,none of the names of special forms can be used as the defined-name inflet, labels, or macrolet.I can't imagine a case in which this could be anything but extremelyconfusing to a program reader nor can I think of any reason why it mightbe useful.	Pavel     ----- Next Message -----Originator: @SAIL.Stanford.EDU:SWM%SAPSUCKER.SCRC.Symbolics:COM:XeroxDate: 26 Oct 87 09:42From: SWM%SAPSUCKER.SCRC.Symbolics:COM:XeroxSubject: Re: macrolet/flet/labelsIn-Reply-to: <871025-162130-1009@Xerox>To: Pavel:PA:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Scott McKay <SWM@SAPSUCKER.SCRC.Symbolics.COM>Subject: Re: macrolet/flet/labelsTo: Pavel.pa, common-lisp@sail.stanford.eduIn-Reply-To: <871025-162130-1009@Xerox>Return-Path: <@SAIL.Stanford.EDU:SWM@SAPSUCKER.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 09:42:40 PSTReceived: from [128.81.41.223] by SAIL.STANFORD.EDU with TCP; 26 Oct 87  08:55:34 PSTReceived: from EVENING-GROSBEAK.SCRC.Symbolics.COM by SAPSUCKER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 175095; Mon 26-Oct-87 11:57:40 ESTOriginal-Date: Mon, 26 Oct 87 11:55 ESTMessage-ID: <19871026165544.1.SWM@EVENING-GROSBEAK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Sun, 25 Oct 87 15:44:22 PST    From: Pavel.pa@Xerox.COM	    Date: 24 Oct 87 18:57 PDT	    From: David Bein <pyrnj!pyramid!bein@RUTGERS.EDU>	      What is the current consensus about using a name	    within a macrolet/flet/labels construct which	    is a special form? I am cleaning things up this	    way and it occurred to me that things could go	    either way.    I am of the opinion that the names of the special forms are really    reserved words and that you cannot redefine them even lexically.  Thus,    none of the names of special forms can be used as the defined-name in    flet, labels, or macrolet.    I can't imagine a case in which this could be anything but extremely    confusing to a program reader nor can I think of any reason why it might    be useful.We subscribe to your notions here.  Our compiler warns you that you willprobably lose when you FLET/LABEL/MACROLET a special form.     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Nov 87 00:54From: IIM%ECLA.USC:EDU:XeroxSubject: flet/labels/macroletTo: common-lisp%SAIL.STANFORD:EDU:Xeroxcc: iim%ECLA.USC:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: "Kim A. Barrett" <IIM@ECLA.USC.EDU>Subject: flet/labels/macroletTo: common-lisp@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 NOV 87 00:54:48 PSTReceived: from ECLA.USC.EDU by SAIL.STANFORD.EDU with TCP; 5 Nov 87  00:00:51 PSTOriginal-Date: Thu, 5 Nov 87 00:01:23 PSTMessage-ID: <12348118610.33.IIM@ECLA.USC.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV  It is our opinion that it is reasonable for a local function/macro to beable to shadow a special form.  If such shadowing is not allowed, it'sbasically just another totally arbitrary rule that the programmer has toremember.  It also makes for some extra work for program-analyzingprograms, either in the analysis of flet/labels/macrolet forms, where itmust check the names to see if they would shadow any of the standardspecial-forms, or at form-processing time (where it is currently impossibleto do portably).  Note that the description of how such programs should process a formwhose car is a symbol (on page 57 of CLtL) is wrong, in that it may notcorrectly handle local definitions.  The key point is that such a programis allowed to special knowledge for 'functions' other than the 24 standardspecial-forms.  If it does have such knowledge, it must first examine thelocal environment to see if its definition is being shadowed.Unfortunately, there is no portable way to examine the local environment.  Actually, as I'm sitting here writing this, my thoughts keep driftinginto a diatribe against the lack of portable mechanisms for dealing withenvironments.  If you want to write a portable code walker that accepts aninitial environment argument, either you simply can't do it ifspecial-forms can be shadowed, or you have to restrict your code walker toonly knowing about the standard special forms, which means it's stillimpossible, if the many complaints I've heard from people trying to writesuch things is any indication.  Well, if I'm going to complain about it, I suppose I should propose asolution, so here goes ...  It seems to me that the necessary functionality for examining thefunction environment is pretty easy to describe.  All you really need issomething like    (defun local-function-p (symbol environment)      "This function returns T if the specified symbol names a local       function or macro in the specified environment, and Nil otherwise.       Environment should be either the environment argument passed to a       macroexpander function (obtained with the &environment       lambda-keyword), or the environment argument to applyhook/evalhook."       ...)  I would expect that, for any given implementation, it is completelytrivial to write the code for local-function-p.  Does anyone know of acounter-example?  With this function available, when your code walker isprocessing a form which is a list whose car is a symbol, it does thefollowing  ;; special forms can be shadowed  (if (local-function-p (car form) environment)      (multiple-value-bind (newform macrop)          (macroexpand-1 form environment)        (if macrop            << recurse on newform >>            << treate the form as a function call >>            ))      << do the stuff described on page 57 of CLtL >>      )  ;; special forms cannot be shadowed  (cond ((member (car form) *the-infamous-24-built-in-special-forms-names*)         << run special code >>         )        ((local-function-p (car form) environment)         (multiple-value-bind (newform macrop)             (macroexpand-1 form environment)           (if macrop               << recurse on newform >>               << treate the form as a function call >>               )))        (t         << do the stuff described on page 57 of CLtL >>         ))  The functionality needed for augmenting environments is less obvious tome, since I haven't studied all that many code walkers to know what theirneeds are, nor all that many implementations, to know what their quirksare, as far as manipulation of environments is concerned.  I thinksomething like the following would be adequate for the walkers andimplementations I have seen, but feel free to blow holes in it.    (defun augment-function-environment           (function-list environment &optional macroletp)      "Return a new environment which is the same as environment except       that the functions specified in function-list are visible.       Environment should be an environment argument passed to a       macroexpander function or applyhook/evalhook.  Function-list is       something suitable for the second argument to flet/labels/macrolet.       If the optional third argument is true, they are added to the       environment as local macro definitions, otherwise as local       functions."      ...)  The reason for returning a new object, rather than possibly destructivelymodifying it, is so that the environment can be captured at a particularpoint without risking having it get modified during further processing.The definitions are needed for macrolet so that macroexpanding within theaugmented environment will work.  I don't know if anything clever needs tobe done with the definitions for local functions.  If so, then rather thanhaving a macroletp flag this will probably need an argument which must be(member flet labels macrolet).  Again, this seems like it should be trivialto write for a given implementation, although I feel a lot less certainabout it for augment-function-environment than I do for local-function-p.I can't offhand think of a reasonable data structure for implementingenvironments which would have problems with this, but that doesn't meanthere aren't any.  As an argument for this being sufficient, I believe that these twofunctions are all that is needed to make the PCL code walker reallyportable, up to non-standard special-forms in a particular implementation.  By the way, I have no strong attachment to the names specified above.They are only intended to be suggestive.kab-------     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Nov 87 01:59From: mincy%Think:COM:XeroxSubject: flet/labels/macroletIn-Reply-to: <12348118610.33.IIM@ECLA.USC.EDU>To: IIM%ecla.usc:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Mincy <mincy@Think.COM>Subject: flet/labels/macroletTo: IIM@ecla.usc.edu, common-lisp@sail.stanford.eduIn-Reply-To: <12348118610.33.IIM@ECLA.USC.EDU>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 NOV 87 01:59:43 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 5 Nov 87  01:16:08 PSTReturn-Path: <mincy@Think.COM>Received: from zeno by Think.COM via CHAOS; Thu, 5 Nov 87 04:15:58 ESTOriginal-Date: Thu, 5 Nov 87 04:20 ESTMessage-Id: <871105042045.8.MINCY@ZENO.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu 5 Nov 87 00:01:23-PST    From: "Kim A. Barrett" <IIM@ecla.usc.edu>      It is our opinion that it is reasonable for a local function/macro to be    able to shadow a special form.  If such shadowing is not allowed, it's    basically just another totally arbitrary rule that the programmer has to    remember.  It also makes for some extra work for program-analyzing    programs, either in the analysis of flet/labels/macrolet forms, where it    must check the names to see if they would shadow any of the standard    special-forms, or at form-processing time (where it is currently impossible    to do portably).I, just to be different, do not think that it is reasonable or desirable tohide special-forms lexically.  These forms really are special, users have to understandthem separately from other things like funtion call.  Making it so that could be lexically hidden only makes special forms superficially like other forms.You still cant funcall a special form.       It seems to me that the necessary functionality for examining the    function environment is pretty easy to describe.  All you really need is    something like	(defun local-function-p (symbol environment)	  "This function returns T if the specified symbol names a local	   function or macro in the specified environment, and Nil otherwise.	   Environment should be either the environment argument passed to a	   macroexpander function (obtained with the &environment	   lambda-keyword), or the environment argument to applyhook/evalhook."	   ...)I have had this problem as well.  One of the few places where I've *HAD* to resortto #+symbolics ..., #+lucid ...   I would suggest that it return something differentso that lexical macros can be distinguished from lexical functions.Say return multiple values where the first value is t if is a local function ormacro and the second value of t if the symbol is lexical macro.      I would expect that, for any given implementation, it is completely    trivial to write the code for local-function-p.  Does anyone know of a    counter-example?  With this function available, when your code walker is    processing a form which is a list whose car is a symbol, it does the    following      The functionality needed for augmenting environments is less obvious to    me, since I haven't studied all that many code walkers to know what their    needs are, nor all that many implementations, to know what their quirks    are, as far as manipulation of environments is concerned.  I think    something like the following would be adequate for the walkers and    implementations I have seen, but feel free to blow holes in it.I am not really convinced that this is needed.  But, I havent really thought about it.    kab-jeff     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Nov 87 21:38From: IIM%ECLA.USC:EDU:XeroxSubject: flet/labels/macrolet & environmentsTo: common-lisp%SAIL.STANFORD:EDU:Xeroxcc: iim%ECLA.USC:EDU:Xerox, mincy%THINK:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: flet/labels/macrolet & environmentsTo: common-lisp@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDU, mincy@THINK.COMReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 NOV 87 20:30:34 PSTReceived: from ECLA.USC.EDU by SAIL.STANFORD.EDU with TCP; 5 Nov 87  19:49:57 PSTOriginal-Date: Thu, 5 Nov 87 19:49:37 PSTMessage-ID: <12348334919.24.IIM@ECLA.USC.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 5 Nov 87 04:20 EST    From: Jeff Mincy <mincy@Think.COM>      ... These forms {special-forms -- kab} really are special, users have    to understand them seperately from other things like function call. ...    You still can't funcall a special-form.   I don't think this is an adequate argument by itself.  Many macros alsohave peculiar syntax, which has to be learned on a case by case basis bythe user.  You also can't funcall macros.  But you can locally redefinethem.  There is a certain simplicity to the description of flet &etc.  It saysthat withing the specified scope, named functional references which matchthe specified names refer to the specified definitions.  If the names ofspecial-forms cannot be shadowed, you have to add a statement to thateffect as an additional caveat.  Note that I am NOT arguing that it is necessarily reasonable for a userto write such code, since it may very well break things.  But this is truefor any local redefinition, especially of 'standard' names, like thebuilt-in Common Lisp names that are in the Lisp package.  I would considerit perfectly acceptable for a compiler to issue some sort of style warningwhen it encounters a local redefinition of a standard Common Lisp function,as long as there is some way for the user to turn it off if that is REALLYwhat he means to do.  I understand that some compilers already do this.  Infact, I've just added this to my todo list, for the next time I start majorsurgery on our compiler.  Its interesting to note that everywhere else I can find where the issueof possibly redefining a special-form comes up, CLtL specifically says itis an error to do so, yet is totally silent on the subject regarding localredefinition.  Not that I'm putting this forward as an argument in favor ofallowing shadowing, since it doesn't address the question of what is theRIGHT thing to do.  I was just wondering if it was an oversight, or if itwas intentional.  As a random additional piece of dirt to throw into this mess, whathappens if you have an flet &etc in which the same name appears twice?  Myguess is that, with the usual left-to-right order of evaluation, combinedwith the scoping rules, the most obvious answer is that the LAST of thedefinitions ends up taking precedence, and the previous one(s) get ignored.Of course, the left-to-right ordering is kind of a red herring, since theorder is left undefined, like in a LET form, where the same questionarises.  Very peculiar, and probably worth a compiler warning.    ... I would suggest that it {local-function-p -- kab} return a second    value of t if the symbol is a lexical macro.  I had thought about this, and in an earlier version actually had it in,but decided it probably isn't necessary.  In the places I've seen wherethis function would get used, the second value would probably only beuseful as an efficiency hack, allowing you to avoid superflously callingmacroexpand on a form that references a local function, rather than amacro.  Not being one to sneer at efficiency issues, I think I've changedmy mind again, and agree with your suggestion.    I am not really convinced that this {augment-function-environment --    kab} is needed.  ...  You need something like augment-function-environment so that your codewalker can process an flet/labels/macrolet form and update the environmentyou are passing around in a way that keeps it compatable with the CommonLisp implementation's representation of environments, so that you can passthe updated environment to macroexpand.  Look at the PCL code walker for anexample of the horrible kludges people are forced to try in order to writesomething that is at least semi-portable.kab-------     ----- Next Message -----Date: 10 Nov 87 11:50 PSTFrom: Masinter.paTO: MasinterSubject: Issue: SPECIAL-FORM-SHADOWSubject: Re: flet/labels/macrolet & environmentsIn-reply-to: IIM@ECLA.USC.EDU's message of 5 Nov 87 21:38To: common-lisp@Sail.stanford.eduUnless some severe limits are placed on implementations as to their use of LISP functions and special forms within macro expansions of standard macros, the only reasonable *standard* for Common Lisp is to rule out completely any lexical redefinition of LISP functions and special forms.We could explicitly list some names that were portably lexically redefinable, if implementations were willing to guarantee that those names would never be used in any macro expansion. This seems awkward and baroque.      ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 87 12:06From: IIM%ECLA.USC:EDU:XeroxSubject: flet/labels/macrolet and environmentsTo: common-lisp%SAIL.STANFORD:EDU:Xeroxcc: Mincy%THINK:COM:Xerox, iim%ECLA.USC:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: flet/labels/macrolet and environmentsTo: common-lisp@SAIL.STANFORD.EDUcc: Mincy@THINK.COM, iim@ECLA.USC.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 NOV 87 12:06:04 PSTReceived: from ECLA.USC.EDU by SAIL.STANFORD.EDU with TCP; 11 Nov 87  11:17:06 PSTOriginal-Date: Wed, 11 Nov 87 11:17:51 PSTMessage-ID: <12349814619.24.IIM@ECLA.USC.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV{ The mailer seems to have bounced the first time I sent this.  Apologies to anyone who receives it twice.  kab }     Date: Thu, 5 Nov 87 04:20 EST    From: Jeff Mincy <mincy@Think.COM>      ... These forms {special-forms -- kab} really are special, users have    to understand them seperately from other things like function call. ...    You still can't funcall a special-form.   I don't think this is an adequate argument by itself.  Many macros alsohave peculiar syntax, which has to be learned on a case by case basis bythe user.  You also can't funcall macros.  But you can locally redefinethem.  There is a certain simplicity to the description of flet &etc.  It saysthat within the specified scope, named functional references which matchthe specified names refer to the specified definitions.  If the names ofspecial-forms cannot be shadowed, you have to add a statement to thateffect as an additional caveat.  Note that I am NOT arguing that it is necessarily reasonable for a userto write such code, since it may very well break things.  But this is truefor any local redefinition, especially of 'standard' names, like thebuilt-in Common Lisp names that are in the Lisp package.  I would considerit perfectly acceptable for a compiler to issue some sort of style warningwhen it encounters a local redefinition of a standard Common Lisp function,as long as there is some way for the user to turn it off if that is REALLYwhat he means to do.  I understand that some compilers already do this.  Infact, I've just added this to my todo list, for the next time I start majorsurgery on our compiler.  Its interesting to note that everywhere else I can find where the issueof possibly redefining a special-form comes up, CLtL specifically says itis an error to do so, yet is totally silent on the subject regarding localredefinition.  Not that I'm putting this forward as an argument in favor ofallowing shadowing, since it doesn't address the question of what is theRIGHT thing to do.  I was just wondering if it was an oversight, or if itwas intentional.  As a random additional piece of dirt to throw into this mess, whathappens if you have an flet &etc in which the same name appears twice?  Myguess is that, with the usual left-to-right order of evaluation, combinedwith the scoping rules, the most obvious answer is that the LAST of thedefinitions ends up taking precedence, and the previous one(s) get ignored.Of course, the left-to-right ordering is kind of a red herring, since theorder is left undefined, like in a LET form, where the same questionarises.  Very peculiar, and probably worth a compiler warning.    ... I would suggest that it {local-function-p -- kab} return a second    value of t if the symbol is a lexical macro.  I had thought about this, and in an earlier version actually had it in,but decided it probably isn't necessary.  In the places I've seen wherethis function would get used, the second value would probably only beuseful as an efficiency hack, allowing you to avoid superflously callingmacroexpand on a form that references a local function, rather than amacro.  Not being one to sneer at efficiency issues, I think I've changedmy mind again, and agree with your suggestion.    I am not really convinced that this {augment-function-environment --    kab} is needed.  ...  You need something like augment-function-environment so that your codewalker can process an flet/labels/macrolet form and update the environmentyou are passing around in a way that keeps it compatable with the CommonLisp implementation's representation of environments, so that you can passthe updated environment to macroexpand.  Look at the PCL code walker for anexample of the horrible kludges people are forced to try in order to writesomething that is at least semi-portable.kab-------     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 87 18:44From: jbarnett%nrtc.northrop:COM:XeroxSubject: Re: Local redefs of special formsTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Barnett <jbarnett@nrtc.northrop.com>To: common-lisp@sail.stanford.eduSubject: Re: Local redefs of special formsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 NOV 87 18:44:46 PSTReceived: from NRTC.NORTHROP.COM by SAIL.STANFORD.EDU with TCP; 11 Nov 87  16:31:02 PSTReceived: by nrtc.nrtc.northrop.com id aa03871; 11 Nov 87 16:31 PSTOriginal-Date: Wed, 11 Nov 87 16:28:54 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIf you allow FLETS, et al, to shadow special forms, there is an implementationissue with inline function expansions nee DEFSUBSTs.  The compiler cannotsubstitute the function body and optimize as some compilers now do.  In factthe body must be (re)expanded in the null lexical environment no matter what.Consider the following example:(defsubst foo (x) (car x))(flet((car (l) (cdr l)))  (foo (car q)))The value of the flet should be (cadr q) while if the compiler is not careful,the result will be (cddr q) instead.  Note, this issue has nothing to do withspecial forms, it depends only on the interaction between an inline function,the defsubst, and local function defs, the flet.  In order to get the propersemantics AND the optimization implied by using an inline function, a compilermust mark expressions with their lexical environment.  Perhaps the expression(foo (cdr q)) in the above would need to look something like     (#<env 1> (foo (car q)))     (#<env 0) (foo (#<env 1> (car q)))     (#<env 0> (car (#<env1> (car q))))and if the flet is inlined     (#<env 0> (car (cdr (#<env 1> q))))at different times as the compiler elaborated the original.  Note, the envwrap around the variable is necesssary also:  Think about the interactionsthat might result (with more complex local fcn defs) if there is a specialdeclaration around an inline expansion    (let(...)      (declare ....)      (in-line-fcn reference ...) ...)If the subst's body is just substituted AND it binds a declared variable, allhell will break loose.I don't think that you can get out of the delemma without some sort of envwrapper.  In any event, there needs to be a good set of primitives tomanage and interagate environments so that sexy system macros and substsdon't blow the bunnies.  As long as they need to exist, why not standardize,document, and distribute them?     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 12 Nov 87 14:49From: barmar%Think:COM:XeroxSubject: Re: Local redefs of special formsIn-Reply-to: <8711120203.AA21595@Think.COM>To: jbarnett%nrtc.northrop:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: Local redefs of special formsTo: Jeff Barnett <jbarnett@nrtc.northrop.com>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <8711120203.AA21595@Think.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 NOV 87 14:48:28 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 12 Nov 87  13:54:16 PSTReturn-Path: <@occam.think.com:barmar@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 12 Nov 87 13:54:29 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 12 Nov 87 13:54:24 ESTOriginal-Date: Thu, 12 Nov 87 13:56 ESTMessage-Id: <871112135607.0.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date:     Wed, 11 Nov 87 16:28:54 PST    From: Jeff Barnett <jbarnett@nrtc.northrop.com>    If you allow FLETS, et al, to shadow special forms, there is an implementation    issue with inline function expansions nee DEFSUBSTs.  The compiler cannot    substitute the function body and optimize as some compilers now do.  In fact    the body must be (re)expanded in the null lexical environment no matter what.    Consider the following example:    (defsubst foo (x) (car x))    (flet((car (l) (cdr l)))      (foo (car q)))While what you are saying is true, this particular case is not germaineto the discussion, because CAR is not a special form, it is a function.Also, if a compiler is going to do inline substitution, it should takecare to use the appropriate environment.  I tried the above on aSymbolics lispm and it simply decided not to do the inline substitution;not optimal, but within the standard.The problem you are describing DOES exist, but it is with macros.  Inthe case of inline functions, the compiler can simply punt using theexpansion if there is a name clash or use the global definition, but itdoesn't have the choice with macros.  If you change the above example to(defmacro foo (x)  `(car ,x))you will encounter the problem.  This problem that macros violatelexical scoping is well-known, and there is ongoing research on how todeal with it.  A proposed solution was the subject of a presentation atthe 1986 Lisp & Functional Programming conference, with a titlesomething like "Hygienic Macro Expansion".  There is a subcommittee ofX3J13 following the research, and if any acceptable solutions come upI'm sure they will let us know about them.                                                barmar     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Nov 87 20:58From: "Gray%dsg.csc.ti.com%RELAY.CS.NET":GV:XeroxSubject: Re: Local redefs of special formsTo: COMMON-LISP%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David N Gray <Gray%dsg.csc.ti.com@RELAY.CS.NET>To: COMMON-LISP@SAIL.STANFORD.EDUSubject: Re: Local redefs of special formsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 NOV 87 20:58:11 PSTReceived: from RELAY.CS.NET by SAIL.STANFORD.EDU with TCP; 13 Nov 87  20:15:56 PSTReceived: from relay2.cs.net by RELAY.CS.NET id ad14665; 13 Nov 87 22:27 ESTReceived: from csl.ti.com by RELAY.CS.NET id ae15242; 13 Nov 87 22:24 ESTReceived: from Kelvin by tilde id AA09293; Fri, 13 Nov 87 20:24:03 CSTMessage-Id: <2772843873-1355116@Kelvin>Original-Date: Fri, 13 Nov 87 20:24:33 CSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> From: Jeff Barnett <jbarnett@nrtc.northrop.com>> Date: 12 Nov 87 05:21:47 GMT> > If you allow FLETS, et al, to shadow special forms, there is an implementation> issue with inline function expansions nee DEFSUBSTs.  The compiler cannot> substitute the function body and optimize as some compilers now do.  In fact> the body must be (re)expanded in the null lexical environment no matter what.> Consider the following example:> > (defsubst foo (x) (car x))> > (flet((car (l) (cdr l)))>   (foo (car q)))> > The value of the flet should be (cadr q) while if the compiler is not careful,> the result will be (cddr q) instead.   ...Jeff,But DEFSUBST is not part of Common Lisp, and I imagine that this is partof the reason it isn't.  Furthermore, DEFSUBSTs and INLINE functions arenot the same thing.  Doing it the Common Lisp way:  (proclaim '(inline foo))  (defun foo (x) (car x))the compiler is required to ensure that any inline expansion preservesthe semantics of the function call.  Rather than attempting to achievethis as a source transformation, our compiler does the expansion duringcompilation, after all local function and variable names have beenreplaced by pointers to the appropriate symbol table entries.  Thus forsomething that can be done by either a macro or inline function (aDEFSUBST is considered to be a macro in this context), it is preferableto use an inline function and let the compiler worry about getting theenvironments right.  The problem remains for things that have to beimplemented as macros because they don't follow the syntax or semanticsof a function call.    -- David Gray     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 03:03:57 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 14 Nov 87  03:01:44 PSTReceived: ID <TOURETZKY@C.CS.CMU.EDU>; Sat 14 Nov 87 06:01:20-ESTDate: Sat, 14 Nov 87 06:01:16 ESTFrom: Dave.Touretzky@C.CS.CMU.EDUSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Moon@SCRC-STONY-BROOK.ARPAcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19871113002102.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <12350510652.7.TOURETZKY@C.CS.CMU.EDU>Here is an explanation of the proper role of COERCE wrt arrays:My "treat arrays as sequences" proposal was intended to do more than justextend the applicability of the sequence functions to arrays.  It was alsosupposed to change the feel of arrays in the language, by implying that shapeisn't all that important; content is what matters.To preserve the primacy of content, no matter what shape a sequence has (list,vector, or n-dimensional array), we should be able to convert it to some othershape and have the behavior of FIND, POSITION, LENGTH, ELT, etc., stay thesame.  Looked at this way, it's perfectly obvious that if ARR is a 3x3 array,then (COERCE 'LIST ARR) should return a nine element list, not a triple oftriples.As for going from lists to arrays, I suggest that  (COERCE '(ARRAY dims) SEQ)should be equivalent to  (REPLACE (MAKE-ARRAY 'dims) SEQ)Note that SEQ may be any type of sequence, including an array; its elementswill be extracted in row-major order as if ELT were used.  This definition alsopreserves the results of ELT, FIND, POSITION, etc., as long as the source anddestination objects have the same LENGTH.  If the source is longer, itsextra elements are lost; if the destination is longer, its extra elementshave undefined initial values.-- Dave-------     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 13:41:49 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 14 Nov 87  13:39:52 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 279870; Sat 14-Nov-87 16:39:29 ESTDate: Sat, 14 Nov 87 16:39 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Dave.Touretzky@C.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <12350510652.7.TOURETZKY@C.CS.CMU.EDU>Message-ID: <19871114213919.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sat 14 Nov 87 06:01:16-EST    From: Dave.Touretzky@C.CS.CMU.EDU    Here is an explanation of the proper role of COERCE wrt arrays:    My "treat arrays as sequences" proposal was intended to do more than just    extend the applicability of the sequence functions to arrays.  It was also    supposed to change the feel of arrays in the language, by implying that shape    isn't all that important; content is what matters.Okay; this rationale should go into the SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS proposal.    To preserve the primacy of content, no matter what shape a sequence has (list,    vector, or n-dimensional array), we should be able to convert it to some other    shape and have the behavior of FIND, POSITION, LENGTH, ELT, etc., stay the    same.  Looked at this way, it's perfectly obvious that if ARR is a 3x3 array,    then (COERCE 'LIST ARR) should return a nine element list, not a triple of    triples.Sure (ignoring wrong argument order to COERCE).  Does this mean coercions fromnon-vector arrays to lists should be put back into the proposal, but with a cleardescription of what they do (unlike last time)?    As for going from lists to arrays, I suggest that      (COERCE '(ARRAY dims) SEQ)    should be equivalent to      (REPLACE (MAKE-ARRAY 'dims) SEQ)    Note that SEQ may be any type of sequence, including an array; its elements    will be extracted in row-major order as if ELT were used.  This definition also    preserves the results of ELT, FIND, POSITION, etc., as long as the source and    destination objects have the same LENGTH.  If the source is longer, its    extra elements are lost; if the destination is longer, its extra elements    have undefined initial values.This is pretty hard to understand in light of the proposal that coercing anarray to a vector should share the storage, rather than creating a new vectorand using REPLACE to copy the elements.  So is the semantics we are looking forfrom COERCE to be sharing, copying, or undefined which?     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 87 14:38From: barmar%Think:COM:XeroxSubject: Re: Local redefs of special formsIn-Reply-to: <2772843873-1355116@Kelvin>To: "Gray%dsg.csc.ti.com%relay.cs.net":GV:Xeroxcc: COMMON-LISP%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: Local redefs of special formsTo: David N Gray <Gray%dsg.csc.ti.com@relay.cs.net>Cc: COMMON-LISP@sail.stanford.eduIn-Reply-To: <2772843873-1355116@Kelvin>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 14:38:31 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 14 Nov 87  14:05:23 PSTReturn-Path: <@Think.COM:barmar@Think.COM>Received: from sauron.think.com by Think.COM; Sat, 14 Nov 87 17:04:41 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Sat, 14 Nov 87 17:04:36 ESTOriginal-Date: Sat, 14 Nov 87 17:06 ESTMessage-Id: <871114170611.4.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 13 Nov 87  20:24:33 CST    From: David N Gray <Gray%dsg.csc.ti.com@relay.cs.net>    Jeff,    But DEFSUBST is not part of Common Lisp, and I imagine that this is part    of the reason it isn't.  Furthermore, DEFSUBSTs and INLINE functions are    not the same thing.  Doing it the Common Lisp way:      (proclaim '(inline foo))      (defun foo (x) (car x))On Symbolics Lispms, DEFSUBST is simply a macro, and	(defsubst foo (x) (car x))expands into precisely the above PROCLAIM followed by DEFUN.                                                barmar     ----- End Forwarded Messages -----*start*40689 00024 US Date: 20 Nov 87 14:33:34 PST (Friday)From: Mailer.paTo: Masinter.paSubject: Undeliverable mailICST-ECF.ARPA said 554 Unable to deliver mail to given recipient(s)The text of your message was--------------------Received: from Cabernet.ms by ArpaGateway.ms ; 20 NOV 87 13:43:09 PSTDate: 20 Nov 87 13:42 PSTFrom: Masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITIONTo: Dabrowski@icst-ecf.Arpacc: MasinterHere is more mail on the related issue of shadowing symbols with FLET/LABELS/MACROLET. I believe the consensus again is that it "should be" an error.     ----- Begin Forwarded Messages -----Originator: @SAIL.Stanford.EDU:pyrnj!pyramid!bein%RUTGERS:EDU:XeroxDate: 24 Oct 87 21:09From: pyrnj!pyramid!bein%RUTGERS:EDU:XeroxSubject: macrolet/flet/labelsTo: common-lisp@sail.stanford.edu%RUTGERS:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David Bein <pyrnj!pyramid!bein@RUTGERS.EDU>Subject: macrolet/flet/labelsTo: "common-lisp@sail.stanford.edu"@RUTGERS.EDUReturn-Path: <@SAIL.Stanford.EDU:pyrnj!pyramid!bein@RUTGERS.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 OCT 87 21:09:13 PDTReceived: from RUTGERS.EDU by SAIL.STANFORD.EDU with TCP; 24 Oct 87  20:35:59 PDTReceived: by RUTGERS.EDU (5.54/1.14) with UUCP 	id AA16558; Sat, 24 Oct 87 23:39:14 EDTReceived: from pyrnova.pyramid.COM (manpyrnova) by pyramid.UUCP (5.51/OSx4.0b-870424)	id AA23234; Sat, 24 Oct 87 19:01:02 PDTReceived: by pyrnova.pyramid.COM (5.52/OSx4.0b-870424)	id AA27898; Sat, 24 Oct 87 19:02:43 PDTOriginal-Date: 24 Oct 87 18:57 PDTMessage-Id: <562125428/bein@pyrnova>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV  What is the current consensus about using a namewithin a macrolet/flet/labels construct whichis a special form? I am cleaning things up thisway and it occurred to me that things could goeither way.  I think the only really ugly one is QUOTE since mostcompilers seem to treat that specially in all kinds ofplaces. Another equally nasty one would be FUNCTION.--David     ----- Next Message -----Originator: @SAIL.Stanford.EDU:Pavel.pa%Xerox:COM:XeroxDate: 25 Oct 87 16:58From: Pavel:PA:XeroxSubject: Re: macrolet/flet/labelsIn-Reply-to: <562125428/bein@pyrnova>To: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.Stanford.EDU:Pavel.pa@Xerox.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 16:58:10 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 25 Oct 87  16:20:49 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 25 OCT 87 16:21:30 PSTOriginal-Date: Sun, 25 Oct 87 15:44:22 PSTMessage-ID: <871025-162130-1009@Xerox>	Date: 24 Oct 87 18:57 PDT	From: David Bein <pyrnj!pyramid!bein@RUTGERS.EDU>	  What is the current consensus about using a name	within a macrolet/flet/labels construct which	is a special form? I am cleaning things up this	way and it occurred to me that things could go	either way.I am of the opinion that the names of the special forms are reallyreserved words and that you cannot redefine them even lexically.  Thus,none of the names of special forms can be used as the defined-name inflet, labels, or macrolet.I can't imagine a case in which this could be anything but extremelyconfusing to a program reader nor can I think of any reason why it mightbe useful.	Pavel     ----- Next Message -----Originator: @SAIL.Stanford.EDU:SWM%SAPSUCKER.SCRC.Symbolics:COM:XeroxDate: 26 Oct 87 09:42From: SWM%SAPSUCKER.SCRC.Symbolics:COM:XeroxSubject: Re: macrolet/flet/labelsIn-Reply-to: <871025-162130-1009@Xerox>To: Pavel:PA:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Scott McKay <SWM@SAPSUCKER.SCRC.Symbolics.COM>Subject: Re: macrolet/flet/labelsTo: Pavel.pa, common-lisp@sail.stanford.eduIn-Reply-To: <871025-162130-1009@Xerox>Return-Path: <@SAIL.Stanford.EDU:SWM@SAPSUCKER.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 09:42:40 PSTReceived: from [128.81.41.223] by SAIL.STANFORD.EDU with TCP; 26 Oct 87  08:55:34 PSTReceived: from EVENING-GROSBEAK.SCRC.Symbolics.COM by SAPSUCKER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 175095; Mon 26-Oct-87 11:57:40 ESTOriginal-Date: Mon, 26 Oct 87 11:55 ESTMessage-ID: <19871026165544.1.SWM@EVENING-GROSBEAK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Sun, 25 Oct 87 15:44:22 PST    From: Pavel.pa@Xerox.COM	    Date: 24 Oct 87 18:57 PDT	    From: David Bein <pyrnj!pyramid!bein@RUTGERS.EDU>	      What is the current consensus about using a name	    within a macrolet/flet/labels construct which	    is a special form? I am cleaning things up this	    way and it occurred to me that things could go	    either way.    I am of the opinion that the names of the special forms are really    reserved words and that you cannot redefine them even lexically.  Thus,    none of the names of special forms can be used as the defined-name in    flet, labels, or macrolet.    I can't imagine a case in which this could be anything but extremely    confusing to a program reader nor can I think of any reason why it might    be useful.We subscribe to your notions here.  Our compiler warns you that you willprobably lose when you FLET/LABEL/MACROLET a special form.     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Nov 87 00:54From: IIM%ECLA.USC:EDU:XeroxSubject: flet/labels/macroletTo: common-lisp%SAIL.STANFORD:EDU:Xeroxcc: iim%ECLA.USC:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: "Kim A. Barrett" <IIM@ECLA.USC.EDU>Subject: flet/labels/macroletTo: common-lisp@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 NOV 87 00:54:48 PSTReceived: from ECLA.USC.EDU by SAIL.STANFORD.EDU with TCP; 5 Nov 87  00:00:51 PSTOriginal-Date: Thu, 5 Nov 87 00:01:23 PSTMessage-ID: <12348118610.33.IIM@ECLA.USC.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV  It is our opinion that it is reasonable for a local function/macro to beable to shadow a special form.  If such shadowing is not allowed, it'sbasically just another totally arbitrary rule that the programmer has toremember.  It also makes for some extra work for program-analyzingprograms, either in the analysis of flet/labels/macrolet forms, where itmust check the names to see if they would shadow any of the standardspecial-forms, or at form-processing time (where it is currently impossibleto do portably).  Note that the description of how such programs should process a formwhose car is a symbol (on page 57 of CLtL) is wrong, in that it may notcorrectly handle local definitions.  The key point is that such a programis allowed to special knowledge for 'functions' other than the 24 standardspecial-forms.  If it does have such knowledge, it must first examine thelocal environment to see if its definition is being shadowed.Unfortunately, there is no portable way to examine the local environment.  Actually, as I'm sitting here writing this, my thoughts keep driftinginto a diatribe against the lack of portable mechanisms for dealing withenvironments.  If you want to write a portable code walker that accepts aninitial environment argument, either you simply can't do it ifspecial-forms can be shadowed, or you have to restrict your code walker toonly knowing about the standard special forms, which means it's stillimpossible, if the many complaints I've heard from people trying to writesuch things is any indication.  Well, if I'm going to complain about it, I suppose I should propose asolution, so here goes ...  It seems to me that the necessary functionality for examining thefunction environment is pretty easy to describe.  All you really need issomething like    (defun local-function-p (symbol environment)      "This function returns T if the specified symbol names a local       function or macro in the specified environment, and Nil otherwise.       Environment should be either the environment argument passed to a       macroexpander function (obtained with the &environment       lambda-keyword), or the environment argument to applyhook/evalhook."       ...)  I would expect that, for any given implementation, it is completelytrivial to write the code for local-function-p.  Does anyone know of acounter-example?  With this function available, when your code walker isprocessing a form which is a list whose car is a symbol, it does thefollowing  ;; special forms can be shadowed  (if (local-function-p (car form) environment)      (multiple-value-bind (newform macrop)          (macroexpand-1 form environment)        (if macrop            << recurse on newform >>            << treate the form as a function call >>            ))      << do the stuff described on page 57 of CLtL >>      )  ;; special forms cannot be shadowed  (cond ((member (car form) *the-infamous-24-built-in-special-forms-names*)         << run special code >>         )        ((local-function-p (car form) environment)         (multiple-value-bind (newform macrop)             (macroexpand-1 form environment)           (if macrop               << recurse on newform >>               << treate the form as a function call >>               )))        (t         << do the stuff described on page 57 of CLtL >>         ))  The functionality needed for augmenting environments is less obvious tome, since I haven't studied all that many code walkers to know what theirneeds are, nor all that many implementations, to know what their quirksare, as far as manipulation of environments is concerned.  I thinksomething like the following would be adequate for the walkers andimplementations I have seen, but feel free to blow holes in it.    (defun augment-function-environment           (function-list environment &optional macroletp)      "Return a new environment which is the same as environment except       that the functions specified in function-list are visible.       Environment should be an environment argument passed to a       macroexpander function or applyhook/evalhook.  Function-list is       something suitable for the second argument to flet/labels/macrolet.       If the optional third argument is true, they are added to the       environment as local macro definitions, otherwise as local       functions."      ...)  The reason for returning a new object, rather than possibly destructivelymodifying it, is so that the environment can be captured at a particularpoint without risking having it get modified during further processing.The definitions are needed for macrolet so that macroexpanding within theaugmented environment will work.  I don't know if anything clever needs tobe done with the definitions for local functions.  If so, then rather thanhaving a macroletp flag this will probably need an argument which must be(member flet labels macrolet).  Again, this seems like it should be trivialto write for a given implementation, although I feel a lot less certainabout it for augment-function-environment than I do for local-function-p.I can't offhand think of a reasonable data structure for implementingenvironments which would have problems with this, but that doesn't meanthere aren't any.  As an argument for this being sufficient, I believe that these twofunctions are all that is needed to make the PCL code walker reallyportable, up to non-standard special-forms in a particular implementation.  By the way, I have no strong attachment to the names specified above.They are only intended to be suggestive.kab-------     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Nov 87 01:59From: mincy%Think:COM:XeroxSubject: flet/labels/macroletIn-Reply-to: <12348118610.33.IIM@ECLA.USC.EDU>To: IIM%ecla.usc:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Mincy <mincy@Think.COM>Subject: flet/labels/macroletTo: IIM@ecla.usc.edu, common-lisp@sail.stanford.eduIn-Reply-To: <12348118610.33.IIM@ECLA.USC.EDU>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 NOV 87 01:59:43 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 5 Nov 87  01:16:08 PSTReturn-Path: <mincy@Think.COM>Received: from zeno by Think.COM via CHAOS; Thu, 5 Nov 87 04:15:58 ESTOriginal-Date: Thu, 5 Nov 87 04:20 ESTMessage-Id: <871105042045.8.MINCY@ZENO.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu 5 Nov 87 00:01:23-PST    From: "Kim A. Barrett" <IIM@ecla.usc.edu>      It is our opinion that it is reasonable for a local function/macro to be    able to shadow a special form.  If such shadowing is not allowed, it's    basically just another totally arbitrary rule that the programmer has to    remember.  It also makes for some extra work for program-analyzing    programs, either in the analysis of flet/labels/macrolet forms, where it    must check the names to see if they would shadow any of the standard    special-forms, or at form-processing time (where it is currently impossible    to do portably).I, just to be different, do not think that it is reasonable or desirable tohide special-forms lexically.  These forms really are special, users have to understandthem separately from other things like funtion call.  Making it so that could be lexically hidden only makes special forms superficially like other forms.You still cant funcall a special form.       It seems to me that the necessary functionality for examining the    function environment is pretty easy to describe.  All you really need is    something like	(defun local-function-p (symbol environment)	  "This function returns T if the specified symbol names a local	   function or macro in the specified environment, and Nil otherwise.	   Environment should be either the environment argument passed to a	   macroexpander function (obtained with the &environment	   lambda-keyword), or the environment argument to applyhook/evalhook."	   ...)I have had this problem as well.  One of the few places where I've *HAD* to resortto #+symbolics ..., #+lucid ...   I would suggest that it return something differentso that lexical macros can be distinguished from lexical functions.Say return multiple values where the first value is t if is a local function ormacro and the second value of t if the symbol is lexical macro.      I would expect that, for any given implementation, it is completely    trivial to write the code for local-function-p.  Does anyone know of a    counter-example?  With this function available, when your code walker is    processing a form which is a list whose car is a symbol, it does the    following      The functionality needed for augmenting environments is less obvious to    me, since I haven't studied all that many code walkers to know what their    needs are, nor all that many implementations, to know what their quirks    are, as far as manipulation of environments is concerned.  I think    something like the following would be adequate for the walkers and    implementations I have seen, but feel free to blow holes in it.I am not really convinced that this is needed.  But, I havent really thought about it.    kab-jeff     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Nov 87 21:38From: IIM%ECLA.USC:EDU:XeroxSubject: flet/labels/macrolet & environmentsTo: common-lisp%SAIL.STANFORD:EDU:Xeroxcc: iim%ECLA.USC:EDU:Xerox, mincy%THINK:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: flet/labels/macrolet & environmentsTo: common-lisp@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDU, mincy@THINK.COMReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 NOV 87 20:30:34 PSTReceived: from ECLA.USC.EDU by SAIL.STANFORD.EDU with TCP; 5 Nov 87  19:49:57 PSTOriginal-Date: Thu, 5 Nov 87 19:49:37 PSTMessage-ID: <12348334919.24.IIM@ECLA.USC.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 5 Nov 87 04:20 EST    From: Jeff Mincy <mincy@Think.COM>      ... These forms {special-forms -- kab} really are special, users have    to understand them seperately from other things like function call. ...    You still can't funcall a special-form.   I don't think this is an adequate argument by itself.  Many macros alsohave peculiar syntax, which has to be learned on a case by case basis bythe user.  You also can't funcall macros.  But you can locally redefinethem.  There is a certain simplicity to the description of flet &etc.  It saysthat withing the specified scope, named functional references which matchthe specified names refer to the specified definitions.  If the names ofspecial-forms cannot be shadowed, you have to add a statement to thateffect as an additional caveat.  Note that I am NOT arguing that it is necessarily reasonable for a userto write such code, since it may very well break things.  But this is truefor any local redefinition, especially of 'standard' names, like thebuilt-in Common Lisp names that are in the Lisp package.  I would considerit perfectly acceptable for a compiler to issue some sort of style warningwhen it encounters a local redefinition of a standard Common Lisp function,as long as there is some way for the user to turn it off if that is REALLYwhat he means to do.  I understand that some compilers already do this.  Infact, I've just added this to my todo list, for the next time I start majorsurgery on our compiler.  Its interesting to note that everywhere else I can find where the issueof possibly redefining a special-form comes up, CLtL specifically says itis an error to do so, yet is totally silent on the subject regarding localredefinition.  Not that I'm putting this forward as an argument in favor ofallowing shadowing, since it doesn't address the question of what is theRIGHT thing to do.  I was just wondering if it was an oversight, or if itwas intentional.  As a random additional piece of dirt to throw into this mess, whathappens if you have an flet &etc in which the same name appears twice?  Myguess is that, with the usual left-to-right order of evaluation, combinedwith the scoping rules, the most obvious answer is that the LAST of thedefinitions ends up taking precedence, and the previous one(s) get ignored.Of course, the left-to-right ordering is kind of a red herring, since theorder is left undefined, like in a LET form, where the same questionarises.  Very peculiar, and probably worth a compiler warning.    ... I would suggest that it {local-function-p -- kab} return a second    value of t if the symbol is a lexical macro.  I had thought about this, and in an earlier version actually had it in,but decided it probably isn't necessary.  In the places I've seen wherethis function would get used, the second value would probably only beuseful as an efficiency hack, allowing you to avoid superflously callingmacroexpand on a form that references a local function, rather than amacro.  Not being one to sneer at efficiency issues, I think I've changedmy mind again, and agree with your suggestion.    I am not really convinced that this {augment-function-environment --    kab} is needed.  ...  You need something like augment-function-environment so that your codewalker can process an flet/labels/macrolet form and update the environmentyou are passing around in a way that keeps it compatable with the CommonLisp implementation's representation of environments, so that you can passthe updated environment to macroexpand.  Look at the PCL code walker for anexample of the horrible kludges people are forced to try in order to writesomething that is at least semi-portable.kab-------     ----- Next Message -----Date: 10 Nov 87 11:50 PSTFrom: Masinter.paTO: MasinterSubject: Issue: SPECIAL-FORM-SHADOWSubject: Re: flet/labels/macrolet & environmentsIn-reply-to: IIM@ECLA.USC.EDU's message of 5 Nov 87 21:38To: common-lisp@Sail.stanford.eduUnless some severe limits are placed on implementations as to their use of LISP functions and special forms within macro expansions of standard macros, the only reasonable *standard* for Common Lisp is to rule out completely any lexical redefinition of LISP functions and special forms.We could explicitly list some names that were portably lexically redefinable, if implementations were willing to guarantee that those names would never be used in any macro expansion. This seems awkward and baroque.      ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 87 12:06From: IIM%ECLA.USC:EDU:XeroxSubject: flet/labels/macrolet and environmentsTo: common-lisp%SAIL.STANFORD:EDU:Xeroxcc: Mincy%THINK:COM:Xerox, iim%ECLA.USC:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: flet/labels/macrolet and environmentsTo: common-lisp@SAIL.STANFORD.EDUcc: Mincy@THINK.COM, iim@ECLA.USC.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 NOV 87 12:06:04 PSTReceived: from ECLA.USC.EDU by SAIL.STANFORD.EDU with TCP; 11 Nov 87  11:17:06 PSTOriginal-Date: Wed, 11 Nov 87 11:17:51 PSTMessage-ID: <12349814619.24.IIM@ECLA.USC.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV{ The mailer seems to have bounced the first time I sent this.  Apologies to anyone who receives it twice.  kab }     Date: Thu, 5 Nov 87 04:20 EST    From: Jeff Mincy <mincy@Think.COM>      ... These forms {special-forms -- kab} really are special, users have    to understand them seperately from other things like function call. ...    You still can't funcall a special-form.   I don't think this is an adequate argument by itself.  Many macros alsohave peculiar syntax, which has to be learned on a case by case basis bythe user.  You also can't funcall macros.  But you can locally redefinethem.  There is a certain simplicity to the description of flet &etc.  It saysthat within the specified scope, named functional references which matchthe specified names refer to the specified definitions.  If the names ofspecial-forms cannot be shadowed, you have to add a statement to thateffect as an additional caveat.  Note that I am NOT arguing that it is necessarily reasonable for a userto write such code, since it may very well break things.  But this is truefor any local redefinition, especially of 'standard' names, like thebuilt-in Common Lisp names that are in the Lisp package.  I would considerit perfectly acceptable for a compiler to issue some sort of style warningwhen it encounters a local redefinition of a standard Common Lisp function,as long as there is some way for the user to turn it off if that is REALLYwhat he means to do.  I understand that some compilers already do this.  Infact, I've just added this to my todo list, for the next time I start majorsurgery on our compiler.  Its interesting to note that everywhere else I can find where the issueof possibly redefining a special-form comes up, CLtL specifically says itis an error to do so, yet is totally silent on the subject regarding localredefinition.  Not that I'm putting this forward as an argument in favor ofallowing shadowing, since it doesn't address the question of what is theRIGHT thing to do.  I was just wondering if it was an oversight, or if itwas intentional.  As a random additional piece of dirt to throw into this mess, whathappens if you have an flet &etc in which the same name appears twice?  Myguess is that, with the usual left-to-right order of evaluation, combinedwith the scoping rules, the most obvious answer is that the LAST of thedefinitions ends up taking precedence, and the previous one(s) get ignored.Of course, the left-to-right ordering is kind of a red herring, since theorder is left undefined, like in a LET form, where the same questionarises.  Very peculiar, and probably worth a compiler warning.    ... I would suggest that it {local-function-p -- kab} return a second    value of t if the symbol is a lexical macro.  I had thought about this, and in an earlier version actually had it in,but decided it probably isn't necessary.  In the places I've seen wherethis function would get used, the second value would probably only beuseful as an efficiency hack, allowing you to avoid superflously callingmacroexpand on a form that references a local function, rather than amacro.  Not being one to sneer at efficiency issues, I think I've changedmy mind again, and agree with your suggestion.    I am not really convinced that this {augment-function-environment --    kab} is needed.  ...  You need something like augment-function-environment so that your codewalker can process an flet/labels/macrolet form and update the environmentyou are passing around in a way that keeps it compatable with the CommonLisp implementation's representation of environments, so that you can passthe updated environment to macroexpand.  Look at the PCL code walker for anexample of the horrible kludges people are forced to try in order to writesomething that is at least semi-portable.kab-------     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 87 18:44From: jbarnett%nrtc.northrop:COM:XeroxSubject: Re: Local redefs of special formsTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Barnett <jbarnett@nrtc.northrop.com>To: common-lisp@sail.stanford.eduSubject: Re: Local redefs of special formsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 NOV 87 18:44:46 PSTReceived: from NRTC.NORTHROP.COM by SAIL.STANFORD.EDU with TCP; 11 Nov 87  16:31:02 PSTReceived: by nrtc.nrtc.northrop.com id aa03871; 11 Nov 87 16:31 PSTOriginal-Date: Wed, 11 Nov 87 16:28:54 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIf you allow FLETS, et al, to shadow special forms, there is an implementationissue with inline function expansions nee DEFSUBSTs.  The compiler cannotsubstitute the function body and optimize as some compilers now do.  In factthe body must be (re)expanded in the null lexical environment no matter what.Consider the following example:(defsubst foo (x) (car x))(flet((car (l) (cdr l)))  (foo (car q)))The value of the flet should be (cadr q) while if the compiler is not careful,the result will be (cddr q) instead.  Note, this issue has nothing to do withspecial forms, it depends only on the interaction between an inline function,the defsubst, and local function defs, the flet.  In order to get the propersemantics AND the optimization implied by using an inline function, a compilermust mark expressions with their lexical environment.  Perhaps the expression(foo (cdr q)) in the above would need to look something like     (#<env 1> (foo (car q)))     (#<env 0) (foo (#<env 1> (car q)))     (#<env 0> (car (#<env1> (car q))))and if the flet is inlined     (#<env 0> (car (cdr (#<env 1> q))))at different times as the compiler elaborated the original.  Note, the envwrap around the variable is necesssary also:  Think about the interactionsthat might result (with more complex local fcn defs) if there is a specialdeclaration around an inline expansion    (let(...)      (declare ....)      (in-line-fcn reference ...) ...)If the subst's body is just substituted AND it binds a declared variable, allhell will break loose.I don't think that you can get out of the delemma without some sort of envwrapper.  In any event, there needs to be a good set of primitives tomanage and interagate environments so that sexy system macros and substsdon't blow the bunnies.  As long as they need to exist, why not standardize,document, and distribute them?     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 12 Nov 87 14:49From: barmar%Think:COM:XeroxSubject: Re: Local redefs of special formsIn-Reply-to: <8711120203.AA21595@Think.COM>To: jbarnett%nrtc.northrop:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: Local redefs of special formsTo: Jeff Barnett <jbarnett@nrtc.northrop.com>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <8711120203.AA21595@Think.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 NOV 87 14:48:28 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 12 Nov 87  13:54:16 PSTReturn-Path: <@occam.think.com:barmar@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 12 Nov 87 13:54:29 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 12 Nov 87 13:54:24 ESTOriginal-Date: Thu, 12 Nov 87 13:56 ESTMessage-Id: <871112135607.0.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date:     Wed, 11 Nov 87 16:28:54 PST    From: Jeff Barnett <jbarnett@nrtc.northrop.com>    If you allow FLETS, et al, to shadow special forms, there is an implementation    issue with inline function expansions nee DEFSUBSTs.  The compiler cannot    substitute the function body and optimize as some compilers now do.  In fact    the body must be (re)expanded in the null lexical environment no matter what.    Consider the following example:    (defsubst foo (x) (car x))    (flet((car (l) (cdr l)))      (foo (car q)))While what you are saying is true, this particular case is not germaineto the discussion, because CAR is not a special form, it is a function.Also, if a compiler is going to do inline substitution, it should takecare to use the appropriate environment.  I tried the above on aSymbolics lispm and it simply decided not to do the inline substitution;not optimal, but within the standard.The problem you are describing DOES exist, but it is with macros.  Inthe case of inline functions, the compiler can simply punt using theexpansion if there is a name clash or use the global definition, but itdoesn't have the choice with macros.  If you change the above example to(defmacro foo (x)  `(car ,x))you will encounter the problem.  This problem that macros violatelexical scoping is well-known, and there is ongoing research on how todeal with it.  A proposed solution was the subject of a presentation atthe 1986 Lisp & Functional Programming conference, with a titlesomething like "Hygienic Macro Expansion".  There is a subcommittee ofX3J13 following the research, and if any acceptable solutions come upI'm sure they will let us know about them.                                                barmar     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Nov 87 20:58From: "Gray%dsg.csc.ti.com%RELAY.CS.NET":GV:XeroxSubject: Re: Local redefs of special formsTo: COMMON-LISP%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David N Gray <Gray%dsg.csc.ti.com@RELAY.CS.NET>To: COMMON-LISP@SAIL.STANFORD.EDUSubject: Re: Local redefs of special formsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 NOV 87 20:58:11 PSTReceived: from RELAY.CS.NET by SAIL.STANFORD.EDU with TCP; 13 Nov 87  20:15:56 PSTReceived: from relay2.cs.net by RELAY.CS.NET id ad14665; 13 Nov 87 22:27 ESTReceived: from csl.ti.com by RELAY.CS.NET id ae15242; 13 Nov 87 22:24 ESTReceived: from Kelvin by tilde id AA09293; Fri, 13 Nov 87 20:24:03 CSTMessage-Id: <2772843873-1355116@Kelvin>Original-Date: Fri, 13 Nov 87 20:24:33 CSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> From: Jeff Barnett <jbarnett@nrtc.northrop.com>> Date: 12 Nov 87 05:21:47 GMT> > If you allow FLETS, et al, to shadow special forms, there is an implementation> issue with inline function expansions nee DEFSUBSTs.  The compiler cannot> substitute the function body and optimize as some compilers now do.  In fact> the body must be (re)expanded in the null lexical environment no matter what.> Consider the following example:> > (defsubst foo (x) (car x))> > (flet((car (l) (cdr l)))>   (foo (car q)))> > The value of the flet should be (cadr q) while if the compiler is not careful,> the result will be (cddr q) instead.   ...Jeff,But DEFSUBST is not part of Common Lisp, and I imagine that this is partof the reason it isn't.  Furthermore, DEFSUBSTs and INLINE functions arenot the same thing.  Doing it the Common Lisp way:  (proclaim '(inline foo))  (defun foo (x) (car x))the compiler is required to ensure that any inline expansion preservesthe semantics of the function call.  Rather than attempting to achievethis as a source transformation, our compiler does the expansion duringcompilation, after all local function and variable names have beenreplaced by pointers to the appropriate symbol table entries.  Thus forsomething that can be done by either a macro or inline function (aDEFSUBST is considered to be a macro in this context), it is preferableto use an inline function and let the compiler worry about getting theenvironments right.  The problem remains for things that have to beimplemented as macros because they don't follow the syntax or semanticsof a function call.    -- David Gray     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 03:03:57 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 14 Nov 87  03:01:44 PSTReceived: ID <TOURETZKY@C.CS.CMU.EDU>; Sat 14 Nov 87 06:01:20-ESTDate: Sat, 14 Nov 87 06:01:16 ESTFrom: Dave.Touretzky@C.CS.CMU.EDUSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Moon@SCRC-STONY-BROOK.ARPAcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19871113002102.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <12350510652.7.TOURETZKY@C.CS.CMU.EDU>Here is an explanation of the proper role of COERCE wrt arrays:My "treat arrays as sequences" proposal was intended to do more than justextend the applicability of the sequence functions to arrays.  It was alsosupposed to change the feel of arrays in the language, by implying that shapeisn't all that important; content is what matters.To preserve the primacy of content, no matter what shape a sequence has (list,vector, or n-dimensional array), we should be able to convert it to some othershape and have the behavior of FIND, POSITION, LENGTH, ELT, etc., stay thesame.  Looked at this way, it's perfectly obvious that if ARR is a 3x3 array,then (COERCE 'LIST ARR) should return a nine element list, not a triple oftriples.As for going from lists to arrays, I suggest that  (COERCE '(ARRAY dims) SEQ)should be equivalent to  (REPLACE (MAKE-ARRAY 'dims) SEQ)Note that SEQ may be any type of sequence, including an array; its elementswill be extracted in row-major order as if ELT were used.  This definition alsopreserves the results of ELT, FIND, POSITION, etc., as long as the source anddestination objects have the same LENGTH.  If the source is longer, itsextra elements are lost; if the destination is longer, its extra elementshave undefined initial values.-- Dave-------     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 13:41:49 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 14 Nov 87  13:39:52 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 279870; Sat 14-Nov-87 16:39:29 ESTDate: Sat, 14 Nov 87 16:39 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Dave.Touretzky@C.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <12350510652.7.TOURETZKY@C.CS.CMU.EDU>Message-ID: <19871114213919.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sat 14 Nov 87 06:01:16-EST    From: Dave.Touretzky@C.CS.CMU.EDU    Here is an explanation of the proper role of COERCE wrt arrays:    My "treat arrays as sequences" proposal was intended to do more than just    extend the applicability of the sequence functions to arrays.  It was also    supposed to change the feel of arrays in the language, by implying that shape    isn't all that important; content is what matters.Okay; this rationale should go into the SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS proposal.    To preserve the primacy of content, no matter what shape a sequence has (list,    vector, or n-dimensional array), we should be able to convert it to some other    shape and have the behavior of FIND, POSITION, LENGTH, ELT, etc., stay the    same.  Looked at this way, it's perfectly obvious that if ARR is a 3x3 array,    then (COERCE 'LIST ARR) should return a nine element list, not a triple of    triples.Sure (ignoring wrong argument order to COERCE).  Does this mean coercions fromnon-vector arrays to lists should be put back into the proposal, but with a cleardescription of what they do (unlike last time)?    As for going from lists to arrays, I suggest that      (COERCE '(ARRAY dims) SEQ)    should be equivalent to      (REPLACE (MAKE-ARRAY 'dims) SEQ)    Note that SEQ may be any type of sequence, including an array; its elements    will be extracted in row-major order as if ELT were used.  This definition also    preserves the results of ELT, FIND, POSITION, etc., as long as the source and    destination objects have the same LENGTH.  If the source is longer, its    extra elements are lost; if the destination is longer, its extra elements    have undefined initial values.This is pretty hard to understand in light of the proposal that coercing anarray to a vector should share the storage, rather than creating a new vectorand using REPLACE to copy the elements.  So is the semantics we are looking forfrom COERCE to be sharing, copying, or undefined which?     ----- Next Message -----Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 87 14:38From: barmar%Think:COM:XeroxSubject: Re: Local redefs of special formsIn-Reply-to: <2772843873-1355116@Kelvin>To: "Gray%dsg.csc.ti.com%relay.cs.net":GV:Xeroxcc: COMMON-LISP%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: Local redefs of special formsTo: David N Gray <Gray%dsg.csc.ti.com@relay.cs.net>Cc: COMMON-LISP@sail.stanford.eduIn-Reply-To: <2772843873-1355116@Kelvin>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 14:38:31 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 14 Nov 87  14:05:23 PSTReturn-Path: <@Think.COM:barmar@Think.COM>Received: from sauron.think.com by Think.COM; Sat, 14 Nov 87 17:04:41 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Sat, 14 Nov 87 17:04:36 ESTOriginal-Date: Sat, 14 Nov 87 17:06 ESTMessage-Id: <871114170611.4.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 13 Nov 87  20:24:33 CST    From: David N Gray <Gray%dsg.csc.ti.com@relay.cs.net>    Jeff,    But DEFSUBST is not part of Common Lisp, and I imagine that this is part    of the reason it isn't.  Furthermore, DEFSUBSTs and INLINE functions are    not the same thing.  Doing it the Common Lisp way:      (proclaim '(inline foo))      (defun foo (x) (car x))On Symbolics Lispms, DEFSUBST is simply a macro, and	(defsubst foo (x) (car x))expands into precisely the above PROCLAIM followed by DEFUN.                                                barmar     ----- End Forwarded Messages -----*start*01431 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 NOV 87 16:03:57 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 23 Nov 87  16:02:16 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 NOV 87 15:08:23 PSTDate: 23 Nov 87 15:08 PSTFrom: Masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITIONTo: cl-cleanup@sail.stanford.eduMessage-ID: <871123-150823-2868@Xerox>The mail I sent to Dabrowski@ICST-ECF.ARPA on this issue was returned asundeliverable.I think perhaps this issue deserves a writeup (merging it withSPECIAL-FORM-SHADOW). There was one proposal mentioned to bring into the standard somefacilities for declaring that certain symbols were "locked" and notsubject to redefinition (local or global).My belief is that without a new macro expansion mechanism, there is noway that we can ensure portability without severe restrictions onimplementations. Given: (flet ((open  ))   (with-open-file ...))will the expansion of with-open-file use OPEN or SI::OPEN? There is a small interaction with CLOS in the sense that adding newmethods for a generic function "redefines" the generic function in some(explicitly allowed) ways.On the other hand, this may be beyond the scope of the cleanupcommittee. I will leave this issue marked as Need Volunteer unless I hearotherwise.*start*04863 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 17 SEP 88 15:06:09 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 17 Sep 88  15:04:48 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 17 SEP 88 15:02:50 PDTDate: 17 Sep 88 15:02 PDTFrom: masinter.pato: cl-cleanup@Sail.stanford.eduSubject: LISP-SYMBOL-REDEFINITIONcc: "Dieter Kolb" <unido!ztivax!kolb@seismo.CSS.GOV>Message-ID: <880917-150250-2427@Xerox>This issue was discussed on this mail list over a year ago, and has come up fromtime to time on the general Common Lisp list. For a while, there was a volunteerfor creating a writup, but the mail to the volunteer was returned. So...finally....!Issue:         LISP-SYMBOL-REDEFINITIONReferences:    Cleanup issue PACKAGE-CLUTTER		CLtL pp 67-69 Defining named functionsCategory:      CLARIFICATIONEdit history:  Masinter, Version 1, 17-Sep-88Problem description:CLtL allows the redefinition of functions exported from other packages.Unexperienced programmers may redefine a system function unintentional  whichmay result into an inconsistent state of the system and cause to  abort. Thishas happened, for example, with a beginner follows an introductory book where an exercise asks to define a function make-list. After theredefinition of make-list the system crashs without returning a message that thefunction has been  redefined.CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions.Proposal LISP-SYMBOL-REDEFINITION:DISALLOW The results of redefining as a function or variable any of the functions,macros, special forms, or constants defined in the LISP package are unspecified;similarly, the result of locally binding (with LAMBDA, LET, LET* etc) anyconstant, or lexically defining (with FLET or LABELS) any function in the LISPpackage is unspecified.The results of applying TRACE to any function in the LISP package isunspecified.Following the proposed definition of "results are unspecified", this means thatis, implementations may signal an error, or other unspecified behavior mayensue. For example, programming environments may warn the user aboutredefinition of LISP symbols and then allow them. Some environments maydistinguish between functions that are safe to redefine and those that are not.Examples:The behavior of the construct:(FLET ((OPEN (filename &key direction) (format t "Open called....") 			(OPEN filename :direction direction)))    (with-open-file (x "frob" :direction ':output) 		(format t "was Open called?")))is unspecified; for example, the macro expansion of with-open-file might referto the OPEN function and might not.(defun car (x) (cdr x))might signal an error.Rationale:Allowing arbitrary redefinition of symbols in the LISP package would placesevere restrictions on implementations not to actually use those symbols inmacro expansions of other LISP symbols, in function calls, etc. While somelooser restrictions might do for any particular Common Lisp implementation,there seems to be no good way to distinguish between those symbols that areredefinable and those that are not.In general, programs can redefine functions safely by creating new symbols intheir own package, possibly shadowing the name.Current practice:Many Lisp environments have some mechanism for warning about redefinition ofLisp symbols and preventing accidental redefinition while allowing it wherenecessary (e.g., to patch the Lisp system itself, fix a bug, add anoptimization.)Fewer check for lexical redefinition, since such redefinition is not asdangerous. Certainly, there are some symbols that are never used in macroexpansions of the standard Common Lisp macros. However, implementations dodiffer on the behavior of macro expansions.Cost to Implementors:This proposal clarifies the status quo -- that the results are unspecified. Itallows and encourages implementors to check for such redefinition, but does notrequire it.Cost to Users:This proposal clarifies that implementations are free to check for a conditionthat they might not have before, and may clarify that some current user code isnon-portable.Benefits:This issue frequently arises. Adopting this proposal would clarify a frequentsource of question about Common Lisp. Cost of non-adoption:Continued questions.Esthetics:Disallowing all redefinition is the simplest way of disallowing the ones thatreally are trouble. Discussion:There have been various proposals for allowing users to extend the "protection"mechanism to their own macros, functions, packages. These proposals seem likethey are environment issues and not language ones, however.*start*01394 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 18 SEP 88 12:17:16 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 461241; Sun 18-Sep-88 15:17:17 EDTDate: Sun, 18 Sep 88 15:17 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: LISP-SYMBOL-REDEFINITIONTo: masinter.pacc: cl-cleanup@Sail.stanford.edu, Dieter Kolb <unido!ztivax!kolb@seismo.CSS.GOV>In-Reply-To: <880917-150250-2427@Xerox>Message-ID: <19880918191704.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI guess we have to go with LISP-SYMBOL-REDEFINITION:DISALLOW.  Weunfortunately have to include the part that prohibits lexicallyshadowing (redefining is the wrong word here) functions in theLISP package with FLET or LABELS or MACROLET (the latter is missing from the writeup), since research into straightening outthe syntactic environment of macroexpansion isn't mature enoughto put into a standard yet.You can drop the part about lexically shadowing constants, since the 3rdparagraph on CLtL p.69 already covers this.  It's unclear what the CLtLsentence about bindings of lexical variables of the same name issupposed to mean: since CL does not include an UNSPECIAL declaration,there is no way to express such a binding.*start*01829 00024 US Return-Path: <jlm@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 18 SEP 88 13:44:37 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02875g; Sun, 18 Sep 88 12:41:59 PSTReceived: by bhopal id AA11384g; Sun, 18 Sep 88 13:41:25 PDTDate: Sun, 18 Sep 88 13:41:25 PDTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8809182041.AA11384@bhopal>To: masinter.paCc: cl-cleanup@Sail.stanford.edu, unido!ztivax!kolb@seismo.CSS.GOVIn-Reply-To: masinter.pa@Xerox.COM's message of 17 Sep 88 15:02 PDT <880917-150250-2427@Xerox>Subject: LISP-SYMBOL-REDEFINITIONInstead of disallowing all symbols in the lisp package, why not have aglobal registry (list, hash-table, etc.) of symbols whose redefinitionis disallowed, initialized in an implementation-specific manner to anysuperset of the symbols in the lisp package?  This has two advantages:    (1)  Users would have a simple mechanism to protect their own       definitions, e.g.        (SETF (GETHASH 'MY-CAR *REDEFINTIONS-RESTRICTED*) T)       or with a more elaborate mechanism:       (SETF (GETHASH 'MY-CAR *REDEFINTION-RESTRICTIONS*) 	     '((:TRACE :ALLOWED) (:DEFVAR :ALLOWED) (:OTHERWISE :FORBIDDEN)))	  (2)  By temporarily removing a symbol from the registry you could enable       it for redefinition (e.g., while patching bugs or experimenting).I also think the behavior of TRACE could be constrained somewhat morethan is stated.  E.g., TRACE could be explicitly required to avoid introducing infinite loops or recursions into standard CL functions,if necessary by failing to trace certain functions.  TRACE could alsobe required to indicate to the user when functions in the registry arebeing traced.  But perhaps this is just common sense and/or purelyenvironmental issues...   jlm*start*01270 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 22 SEP 88 17:20:28 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA07051g; Thu, 22 Sep 88 16:19:56 PSTReceived: by bhopal id AA07323g; Thu, 22 Sep 88 17:19:20 PDTDate: Thu, 22 Sep 88 17:19:20 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809230019.AA07323@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: masinter.pa, cl-cleanup@Sail.stanford.edu, unido!ztivax!kolb@seismo.CSS.GOVIn-Reply-To: David A. Moon's message of Sun, 18 Sep 88 15:17 EDT <19880918191704.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: LISP-SYMBOL-REDEFINITIONre: I guess we have to go with LISP-SYMBOL-REDEFINITION:DISALLOW.  We    unfortunately have to include the part that prohibits lexically    shadowing (redefining is the wrong word here) functions in the ...I very much dislike the use of "shadow" here, since it so readily invokesthe other meaning of SHADOW, which in fact has some bearing on the problem (i.e., functions named by symbols with names like "IF" and "CAR").  At thePalo Alto meeting in March of this year, I thought we started using the term "lexical override"; or some such term.  Anything but "shadow".-- JonL --*start*02316 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 23:18:09 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 27 Sep 88  23:18:12 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00613g; Tue, 27 Sep 88 22:16:09 PSTReceived: by bhopal id AA06493g; Tue, 27 Sep 88 23:15:16 PDTDate: Tue, 27 Sep 88 23:15:16 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809280615.AA06493@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Tue, 27 Sep 88 13:04 EDT <880927130442.2.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: LISP-SYMBOL-REDEFINITION (?)re: How would you feel about something like the following. It's    broader, but still tries to be specific...     Symbols on the LISP package may have function or macro     definitions, variable definitions or SPECIAL proclamations, or     type definitions only if explicitly permitted in the specification.     Neither users nor implementors are permitted to add new kinds of     definitions for these symbols.Uncomfortable with the part that says that user's can't use LISPpackage symbols for names.  I very much agree that vendors (and VAR's like Intellicorp!!!) should not have any definitions "hanging off"LISP symbols other than the mandated ones.  However, this may spell a bit of work for implementations like VAXLISP that use the property list for compiler internals.In fact, at one point in time, some of Lucid's window tool kitimplementation "leaked over" into the Lisp package; the symbolPOSITION had some random defstruct about it; and when a usertried his own defstruct, he was overly surprised to see that the system depended on that one [the windows package simplyforgot to shadow POSITION].Jim Boyce here at Lucid has taken an interest in this matter; I'dlike to get him to write out a full critique, and possibly a newproposal.  In particular, he points out that we should also constrainimplementors from depending on the *lack* of any additional definitions other than the CLtL ones.  Can you imagine a vendorselling a Lisp that _dies_ as soon as you do (defvar list 3)?-- JonL --*start*02710 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 10:13:18 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Sep 88  09:56:03 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 467027; Wed 28-Sep-88 12:54:21 EDTDate: Wed, 28 Sep 88 12:54 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LISP-SYMBOL-REDEFINITION (?)To: jonl@Lucid.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8809280615.AA06493@bhopal>Message-ID: <880928125405.7.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Tue, 27 Sep 88 23:15:16 PDT    From: Jon L White <jonl@lucid.com>    re: How would you feel about something like the following. It's	broader, but still tries to be specific...	 Symbols on the LISP package may have function or macro	 definitions, variable definitions or SPECIAL proclamations, or	 type definitions only if explicitly permitted in the specification.	 Neither users nor implementors are permitted to add new kinds of	 definitions for these symbols.    ... I very much agree that vendors (and VAR's     like Intellicorp!!!) should not have any definitions "hanging off"    LISP symbols other than the mandated ones.  However, this may spell     a bit of work for implementations like VAXLISP that use the property     list for compiler internals.I didn't say anything about property lists. Property lists are safe as longboth the symbol and the indicator aren't global. Either of (GET 'LISP:xxx 'PRIVATE:xxx)and  (GET 'PRIVATE:xxx 'LISP:xxx)is safe.    In fact, at one point in time, some of Lucid's window tool kit    implementation "leaked over" into the Lisp package; the symbol    POSITION had some random defstruct about it; and when a user    tried his own defstruct, he was overly surprised to see that     the system depended on that one [the windows package simply    forgot to shadow POSITION].That's why I mentioned "types" above. I don't think you should have a pre-defined type by this name, but not everyone puts types on the plist.    Jim Boyce here at Lucid has taken an interest in this matter; I'd    like to get him to write out a full critique, and possibly a new    proposal.  In particular, he points out that we should also constrain    implementors from depending on the *lack* of any additional     definitions other than the CLtL ones.  Can you imagine a vendor    selling a Lisp that _dies_ as soon as you do (defvar list 3)?Right.*start*02139 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 16:46:18 PDTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 28 Sep 88  16:45:37 PDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA09075@EDDIE.MIT.EDU>; Wed, 28 Sep 88 19:43:21 EDTReceived: by spt.entity.com (smail2.5); 28 Sep 88 18:08:31 EDT (Wed)To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: Scott.Fahlman@B.GP.CS.CMU.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Wed, 28 Sep 88 12:12 EDT <880928121218.6.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 2) Message-Id: <8809281808.AA29619@spt.entity.com>Date: 28 Sep 88 18:08:31 EDT (Wed)From: gz@spt.entity.com (Gail Zacharias)   Date: Wed, 28 Sep 88 12:12 EDT   From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>   I wasn't really thinking about this issue, but I'd be happy if you   couldn't have global definitions of LIST, MEMBER, etc. or SPECIAL   bindings of them. But it's ok with me if you have lexical bindings of them.   Would that satisfy you. Does that seem to inconsistent to anyone?Yes.  I sometimes find it useful to put temporary special declarations onnormally-lexical variables as a q&d debugging technique.  I don't see why Ishouldn't be allowed to do this for a variable named LIST.  I also don't seewhy I shouldn't be allowed to have a macro named MOST-POSITIVE-FIXNUM.  Infact I don't really understand the motivation for putting ANY restrictions onUSERS wrt this issue.  It seems to be mainly a matter of style or goodprogramming practice but then so is putting *'s around specials, and thestandard isn't going to require that.  If a programmer doesn't choose to beconcerned about co-existing with other programs in the same lisp, that's hisbusiness.  He might even know what he's doing. Implementations might want toissue warnings in such cases, but that's not the same as making such programsarbitrarily illegal.*start*05275 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 16:43:24 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Oct 88  16:42:47 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 07 OCT 88 16:24:44 PDTDate: 7 Oct 88 16:24 PDTFrom: masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITION (Version 2)to: cl-cleanup@sail.stanford.eduMessage-ID: <881007-162444-1360@Xerox>down to the wire, but if you have a chance, you might want to glance atthis before I send it out next time around...!Issue:         LISP-SYMBOL-REDEFINITIONReferences:    Cleanup issue PACKAGE-CLUTTER		CLtL pp 67-69 Defining named functionsCategory:      CLARIFICATIONEdit history:  Masinter, Version 1, 17-Sep-88               Masinter, Version 2, 7-Oct-88Problem description:CLtL allows the redefinition of functions exported from other packages.Unexperienced programmers may redefine a system function unintentionalwhichmay result into an inconsistent state of the system and cause to  abort.Thishas happened, for example, with a beginner follows an introductory book where an exercise asks to define a function MAKE-LIST. After theredefinition of MAKE-LIST the system crashs without returning a messagethat thefunction has been  redefined.CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions.Proposal LISP-SYMBOL-REDEFINITION:DISALLOW The results of redefining as a function any of the functions,macros, or special forms defined in the LISP package are unspecified;similarly, the result of lexically defining (with FLET, LABELS orMACROLET) any function or macro in the LISP package is unspecified.Clarify that, as implied by CLtL p. 69, it is an error to rebindany symbol in CL defined as a constant.The results of applying TRACE to any function in the LISP package isunspecified.Following the proposed definition of "results are unspecified", this meansthatimplementations may signal an error, or other unspecified behavior mayensue. For example, programming environments may warn the user aboutredefinition of LISP symbols and then allow them. Some environments maydistinguish between functions that are safe to redefine and those that arenot.Examples:The behavior of the construct:(FLET ((OPEN (filename &key direction) (format t "Open called....") 			(OPEN filename :direction direction)))    (with-open-file (x "frob" :direction ':output) 		(format t "was Open called?")))is unspecified; for example, the macro expansion of with-open-file mightreferto the OPEN function and might not.(defun car (x) (cdr x))might signal an error.Rationale:This proposal is the only simple resolution of the problem description thatwe can imagine that is consistent with current implementation techniques.Allowing arbitrary redefinition of symbols in the LISP package would placesevere restrictions on implementations not to actually use those symbols inmacro expansions of other LISP symbols, in function calls, etc. While somelooser restrictions might do for any particular Common Lisp implementation,there seems to be no good way to distinguish between those symbols that areredefinable and those that are not.In general, programs can redefine functions safely by creating new symbolsintheir own package, possibly shadowing the name.Current practice:Many Lisp environments have some mechanism for warning about redefinitionofLisp symbols and preventing accidental redefinition while allowing it wherenecessary (e.g., to patch the Lisp system itself, fix a bug, add anoptimization.)Fewer check for lexical redefinition, since such redefinition is not asdangerous. Certainly, there are some symbols that are never used in macroexpansions of the standard Common Lisp macros. However, implementations dodiffer on the behavior of macro expansions.Cost to Implementors:This proposal clarifies the status quo -- that the results are unspecified.Itallows and encourages implementors to check for such redefinition, but doesnotrequire it.Cost to Users:This proposal clarifies that implementations are free to check for aconditionthat they might not have before, and may clarify that some current usercode isnon-portable.Benefits:This issue frequently arises. Adopting this proposal would clarify afrequentsource of question about Common Lisp. Cost of non-adoption:Continued questions.Esthetics:Disallowing all redefinition is the simplest way of disallowing the onesthatreally are trouble. Discussion:There have been various proposals for allowing users to extend the"protection"mechanism to their own macros, functions, packages. These proposals seemlikethey are environment issues and not language ones, however. For example,you might have a list *REDEFINITIONS-RESTRICTIONS* or IL:UNSAFE-TO-MODIFY-FUNCTIONS>It is unfortunate that the restriction on reusing LISP package symbols inFLET, LABELS or MACROLET is necessary, but the research into straighteningoutthe syntactic environment of macroexpansion isn't mature enough to put intoa standard yet.*start*00805 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 07 OCT 88 18:54:00 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472985; Fri 7-Oct-88 21:53:29 EDTDate: Fri, 7 Oct 88 21:53 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LISP-SYMBOL-REDEFINITION (Version 2)To: masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <881007-162444-1360@Xerox>Message-ID: <19881008015308.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI can't read this, it's full of typos, at least near the beginning.Either that or my eyes are going from dealing with 300 or 400messages of mail backlog in the last two days.*start*05113 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 21:51:05 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Oct 88  21:50:18 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 07 OCT 88 19:03:59 PDTDate: 7 Oct 88 19:04 PDTFrom: masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITION (Version 3)to: cl-cleanup@sail.stanford.eduLine-fold: NOMessage-ID: <881007-190359-1626@Xerox>David was right; version 2 was full of typos. The original problem description -- about an incident where a beginning user redefined MAKE-LIST -- is not in fact really addressed by this issue, since we haven't required implementations to signal an error (and don't want to.)!Issue:         LISP-SYMBOL-REDEFINITIONReferences:    Cleanup issue PACKAGE-CLUTTER		CLtL pp 67-69 Defining named functionsCategory:      CLARIFICATIONEdit history:  Masinter, Version 1, 17-Sep-88 from (Kolb, 14-Aug-87)               Masinter, Version 2, 7-Oct-88               Masinter, Version 3,  7-Oct-88, fix typosProblem description:Is it legal to redefine Common Lisp functions? There is no explicitprohibition, and many implementations do allow redefinition offunctions in the Lisp package.CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions.Proposal LISP-SYMBOL-REDEFINITION:DISALLOW The results of redefining as a function any of the functions,macros, or special forms defined in the LISP package are unspecified;similarly, the result of lexically defining (with FLET, LABELS orMACROLET) any function or macro in the LISP package is unspecified.Clarify that, as implied by CLtL p. 69, it is an error to rebindany symbol in CL defined as a constant.The results of applying TRACE to any function in the LISP package isunspecified.Following the proposed definition of "results are unspecified", this means thatimplementations may signal an error, or other unspecified behavior mayensue. For example, programming environments may warn the user aboutredefinition of LISP symbols and then allow them. Some environments maydistinguish between functions that are safe to redefine and those that arenot.Examples:The behavior of the construct:(FLET ((OPEN (filename &key direction) (format t "Open called....") 			(OPEN filename :direction direction)))    (with-open-file (x "frob" :direction ':output) 		(format t "was Open called?")))is unspecified; for example, the macro expansion of with-open-file might referto the OPEN function and might not.(defun car (x) (cdr x))might signal an error.Rationale:This proposal is the only simple resolution of the problem description thatwe can imagine that is consistent with current implementation techniques.Allowing arbitrary redefinition of symbols in the LISP package would placesevere restrictions on implementations not to actually use those symbols inmacro expansions of other LISP symbols, in function calls, etc. While somelooser restrictions might do for any particular Common Lisp implementation,there seems to be no good way to distinguish between those symbols that areredefinable and those that are not.In general, programs can redefine functions safely by creating new symbols intheir own package, possibly shadowing the name.Current practice:Many Lisp environments have some mechanism for warning about redefinition ofLisp symbols and preventing accidental redefinition while allowing it wherenecessary (e.g., to patch the Lisp system itself, fix a bug, add anoptimization.)Fewer check for lexical redefinition, since such redefinition is not asdangerous. Certainly, there are some symbols that are never used in macroexpansions of the standard Common Lisp macros. However, implementations dodiffer on the behavior of macro expansions.Cost to Implementors:This proposal clarifies the status quo -- that the results are unspecified. Itallows and encourages implementors to check for such redefinition, but does notrequire it.Cost to Users:This proposal clarifies that implementations are free to check for a conditionthat they might not have before, and may clarify that some current user code isnon-portable.Benefits:This issue frequently arises. Adopting this proposal would clarify a frequentsource of question about Common Lisp. Cost of non-adoption:Continued questions.Esthetics:Disallowing all redefinition is the simplest way of disallowing the ones thatreally are trouble. Discussion:There have been various proposals for allowing users to extend the "protection"mechanism to their own macros, functions, packages. These proposals seem likethey are environment issues and not language ones, however. It is unfortunate that the restriction on reusing LISP package symbols inFLET, LABELS or MACROLET is necessary, but the research into straightening outthe syntactic environment of macroexpansion isn't mature enough to put intoa standard yet.*start*04895 00024 UU?Date:  8 Oct 88 19:52 PDTSender: masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITION (Version 3)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:         LISP-SYMBOL-REDEFINITIONReferences:    Cleanup issue PACKAGE-CLUTTER		CLtL pp 67-69 Defining named functionsCategory:      CLARIFICATIONEdit history:  Masinter, Version 1, 17-Sep-88 from (Kolb, 14-Aug-87)               Masinter, Version 2, 7-Oct-88               Masinter, Version 3,  7-Oct-88, fix typosProblem description:Is it legal to redefine Common Lisp functions? There is no explicitprohibition, and many implementations do allow redefinition offunctions in the Lisp package.CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions.Proposal LISP-SYMBOL-REDEFINITION:DISALLOW The results of redefining as a function any of the functions,macros, or special forms defined in the LISP package are unspecified;similarly, the result of lexically defining (with FLET, LABELS orMACROLET) any function or macro in the LISP package is unspecified.Clarify that, as implied by CLtL p. 69, it is an error to rebindany symbol in CL defined as a constant.The results of applying TRACE to any function in the LISP package isunspecified.Following the proposed definition of "results are unspecified", this means thatimplementations may signal an error, or other unspecified behavior mayensue. For example, programming environments may warn the user aboutredefinition of LISP symbols and then allow them. Some environments maydistinguish between functions that are safe to redefine and those that arenot.Examples:The behavior of the construct:(FLET ((OPEN (filename &key direction) (format t "Open called....") 			(OPEN filename :direction direction)))    (with-open-file (x "frob" :direction ':output) 		(format t "was Open called?")))is unspecified; for example, the macro expansion of with-open-file might referto the OPEN function and might not.(DEFUN CAR (X) (CDR X))might signal an error.Rationale:This proposal is the only simple resolution of the problem description thatwe can imagine that is consistent with current implementation techniques.Allowing arbitrary redefinition of symbols in the LISP package would placesevere restrictions on implementations not to actually use those symbols inmacro expansions of other LISP symbols, in function calls, etc. While somelooser restrictions might do for any particular Common Lisp implementation,there seems to be no good way to distinguish between those symbols that areredefinable and those that are not.In general, programs can redefine functions safely by creating new symbols intheir own package, possibly shadowing the name.Current practice:Many Lisp environments have some mechanism for warning about redefinition ofLisp symbols and preventing accidental redefinition while allowing it wherenecessary (e.g., to patch the Lisp system itself, fix a bug, add anoptimization.)Fewer check for lexical redefinition, since such redefinition is not asdangerous. Certainly, there are some symbols that are never used in macroexpansions of the standard Common Lisp macros. However, implementations dodiffer on the behavior of macro expansions.Cost to Implementors:This proposal clarifies the status quo -- that the results are unspecified. Itallows and encourages implementors to check for such redefinition, but does notrequire it.Cost to Users:This proposal clarifies that implementations are free to check for a conditionthat they might not have before, and may clarify that some current user code isnon-portable.Benefits:This issue frequently arises. Adopting this proposal would clarify a frequentsource of question about Common Lisp. Cost of non-adoption:Continued questions.Esthetics:Disallowing all redefinition is the simplest way of disallowing the ones thatreally are trouble. Discussion:There have been various proposals for allowing users to extend the "protection"mechanism to their own macros, functions, packages. These proposals seem likethey are environment issues and not language ones, however. It is unfortunate that the restriction on reusing LISP package symbols inFLET, LABELS or MACROLET is necessary, but the research into straightening outthe syntactic environment of macroexpansion isn't mature enough to put intoa standard yet.        TITAN 
         TITAN 
                                       H                                         )       +      ?       
                                                                   
       w                            e                    z*start*04885 00024 UU?Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 20:07:28 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  19:56:10 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 OCT 88 19:52:28 PDTDate: 8 Oct 88 19:52 PDTSender: masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITION (Version 3)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-195228-2477@Xerox>!Issue:         LISP-SYMBOL-REDEFINITIONReferences:    Cleanup issue PACKAGE-CLUTTER		CLtL pp 67-69 Defining named functionsCategory:      CLARIFICATIONEdit history:  Masinter, Version 1, 17-Sep-88 from (Kolb, 14-Aug-87)               Masinter, Version 2, 7-Oct-88               Masinter, Version 3,  7-Oct-88, fix typosProblem description:Is it legal to redefine Common Lisp functions? There is no explicitprohibition, and many implementations do allow redefinition offunctions in the Lisp package.CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions.Proposal LISP-SYMBOL-REDEFINITION:DISALLOW The results of redefining as a function any of the functions,macros, or special forms defined in the LISP package are unspecified;similarly, the result of lexically defining (with FLET, LABELS orMACROLET) any function or macro in the LISP package is unspecified.Clarify that, as implied by CLtL p. 69, it is an error to rebindany symbol in CL defined as a constant.The results of applying TRACE to any function in the LISP package isunspecified.Following the proposed definition of "results are unspecified", this means thatimplementations may signal an error, or other unspecified behavior mayensue. For example, programming environments may warn the user aboutredefinition of LISP symbols and then allow them. Some environments maydistinguish between functions that are safe to redefine and those that arenot.Examples:The behavior of the construct:(FLET ((OPEN (filename &key direction) (format t "Open called....") 			(OPEN filename :direction direction)))    (with-open-file (x "frob" :direction ':output) 		(format t "was Open called?")))is unspecified; for example, the macro expansion of with-open-file might referto the OPEN function and might not.(DEFUN CAR (X) (CDR X))might signal an error.Rationale:This proposal is the only simple resolution of the problem description thatwe can imagine that is consistent with current implementation techniques.Allowing arbitrary redefinition of symbols in the LISP package would placesevere restrictions on implementations not to actually use those symbols inmacro expansions of other LISP symbols, in function calls, etc. While somelooser restrictions might do for any particular Common Lisp implementation,there seems to be no good way to distinguish between those symbols that areredefinable and those that are not.In general, programs can redefine functions safely by creating new symbols intheir own package, possibly shadowing the name.Current practice:Many Lisp environments have some mechanism for warning about redefinition ofLisp symbols and preventing accidental redefinition while allowing it wherenecessary (e.g., to patch the Lisp system itself, fix a bug, add anoptimization.)Fewer check for lexical redefinition, since such redefinition is not asdangerous. Certainly, there are some symbols that are never used in macroexpansions of the standard Common Lisp macros. However, implementations dodiffer on the behavior of macro expansions.Cost to Implementors:This proposal clarifies the status quo -- that the results are unspecified. Itallows and encourages implementors to check for such redefinition, but does notrequire it.Cost to Users:This proposal clarifies that implementations are free to check for a conditionthat they might not have before, and may clarify that some current user code isnon-portable.Benefits:This issue frequently arises. Adopting this proposal would clarify a frequentsource of question about Common Lisp. Cost of non-adoption:Continued questions.Esthetics:Disallowing all redefinition is the simplest way of disallowing the ones thatreally are trouble. Discussion:There have been various proposals for allowing users to extend the "protection"mechanism to their own macros, functions, packages. These proposals seem likethey are environment issues and not language ones, however. It is unfortunate that the restriction on reusing LISP package symbols inFLET, LABELS or MACROLET is necessary, but the research into straightening outthe syntactic environment of macroexpansion isn't mature enough to put intoa standard yet.*start*05015 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:33:08 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:31:12 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA19322; Thu, 13 Oct 88 13:29:25 PDTDate: Thu, 13 Oct 88 13:29:25 PDTMessage-Id: <8810132029.AA19322@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: LISP-SYMBOL-REDEFINITION (version 4)Issue:         LISP-SYMBOL-REDEFINITION References:    Cleanup issue PACKAGE-CLUTTER		CLtL pp 67-69 Defining named functions Category:      CLARIFICATION Edit history:  Masinter, Version 1, 17-Sep-88 from (Kolb, 14-Aug-87)               Masinter, Version 2, 7-Oct-88               Masinter, Version 3,  7-Oct-88, fix typos               van Roggen, Version 4, 13-Oct-88, undefined, not unspecified Problem description: Is it legal to redefine Common Lisp functions? There is no explicitprohibition, and many implementations do allow redefinition offunctions in the Lisp package. CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions. Proposal LISP-SYMBOL-REDEFINITION:DISALLOW The consequences of redefining as a function or macro any of the functions,macros, or special forms defined in the LISP package are undefined;similarly, the consequence of lexically defining (with FLET, LABELS orMACROLET) any function or macro in the LISP package is undefined. Clarify that, as implied by CLtL p. 69, it is an error to rebindany symbol in CL defined as a constant. The consequences of applying TRACE to any function in the LISP package isundefined. Following the proposed definition of "consequences are undefined", this means thatimplementations may signal an error, or other undefined behavior mayensue. For example, programming environments may warn the user aboutredefinition of LISP symbols and then allow them. Some environments maydistinguish between functions that are safe to redefine and those that arenot. Examples: The behavior of the construct: (FLET ((OPEN (filename &key direction) (format t "Open called....") 			(OPEN filename :direction direction)))    (with-open-file (x "frob" :direction ':output) 		(format t "was Open called?"))) is undefined; for example, the macro expansion of with-open-file might referto the OPEN function and might not. (DEFUN CAR (X) (CDR X)) might signal an error. Rationale: This proposal is the only simple resolution of the problem description thatwe can imagine that is consistent with current implementation techniques. Allowing arbitrary redefinition of symbols in the LISP package would placesevere restrictions on implementations not to actually use those symbols inmacro expansions of other LISP symbols, in function calls, etc. While somelooser restrictions might do for any particular Common Lisp implementation,there seems to be no good way to distinguish between those symbols that areredefinable and those that are not. In general, programs can redefine functions safely by creating new symbols intheir own package, possibly shadowing the name. Current practice: Many Lisp environments have some mechanism for warning about redefinition ofLisp symbols and preventing accidental redefinition while allowing it wherenecessary (e.g., to patch the Lisp system itself, fix a bug, add anoptimization.) Fewer check for lexical redefinition, since such redefinition is not asdangerous. Certainly, there are some symbols that are never used in macroexpansions of the standard Common Lisp macros. However, implementations dodiffer on the behavior of macro expansions. Cost to Implementors: This proposal clarifies the status quo -- that the consequences are undefined. Itallows and encourages implementors to check for such redefinition, but does notrequire it. Cost to Users: This proposal clarifies that implementations are free to check for a conditionthat they might not have before, and may clarify that some current user code isnon-portable. Benefits: This issue frequently arises. Adopting this proposal would clarify a frequentsource of question about Common Lisp.  Cost of non-adoption: Continued questions. Esthetics: Disallowing all redefinition is the simplest way of disallowing the ones thatreally are trouble.  Discussion: There have been various proposals for allowing users to extend the "protection"mechanism to their own macros, functions, packages. These proposals seem likethey are environment issues and not language ones, however.  It is unfortunate that the restriction on reusing LISP package symbols inFLET, LABELS or MACROLET is necessary, but the research into straightening outthe syntactic environment of macroexpansion isn't mature enough to put intoa standard yet.*start*01561 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 15:33:15 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:32:38 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 476038; 13 Oct 88 18:30:38 EDTDate: Thu, 13 Oct 88 18:30 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LISP-SYMBOL-REDEFINITION (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013183025.0.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Needs to be discussed concurrently with PACKAGE-CLUTTER since they are pretty closely related. Thought ready to vote.X3J13 meeting: Perdue: Concern about not being able to TRACE functions in LISP. Masinter: It's already a dangerous thing to do.  KMP: Just noticed that proposal should say "undefined", -not- "unspecified". Haflich: Proposal should say if it's ok for users to redefine symbols	  that CLtL doesn't define. PACKAGE-CLUTTER suggests that the	  system can't provide a LAMBDA definition, but this proposal	  should say whether users can create such a definition. Slater: Can you shadow CAR? [in the package sense] Masinter: Of course. JonL: The term "shadow" is used ambiguously. Don't talk about shadowing       using FLET because it leads to confusion. No vote was attempted.*start*02155 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 OCT 88 16:01:03 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Oct 88  16:01:02 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 474475; Tue 11-Oct-88 18:59:36 EDTDate: Tue, 11 Oct 88 18:59 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LISP-SYMBOL-REDEFINITION (Version 3)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881007-190359-1626@Xerox>Message-ID: <19881011225918.3.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 7 Oct 88 19:04 PDT    From: masinter.pa@Xerox.COM    David was right; version 2 was full of typos. The original problem    description -- about an incident where a beginning user redefined    MAKE-LIST -- is not in fact really addressed by this issue, since we    haven't required implementations to signal an error (and don't want    to.)LISP-SYMBOL-REDEFINITION:DISALLOW looks okay.  I'm not concerned aboutthe original problem description -- a good programming environment forbeginning users would keep them from redefining MAKE-LISTunintentionally, and a bad programming environment for beginning userswould not, but they both implement Common Lisp the language as amendedby this proposal.  So actually I think the original problem descriptionreally is addressed by this issue, it's just not eliminated by it.    Clarify that, as implied by CLtL p. 69, it is an error to rebind    any symbol in CL defined as a constant.Does "rebind" mean as with LET, or as with SETQ, or as with MAKUNBOUND?I think you mean all three, it would be better to be more explicit.You also need to cover redefining type-specifiers with DEFTYPE, DEFSTRUCT,or DEFCLASS, and redefining SETF macros or functions with DEFSETF orDEFINE-SETF-METHOD (or with DEFUN or equivalent when the cleanupproposal for that goes through, sorry its name escapes me at the moment,maybe setf-function-vs-macro).*start*05953 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 14:15:51 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 22 Nov 88  14:14:19 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 22 NOV 88 13:57:42 PSTDate: 22 Nov 88 13:57 PSTFrom: masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITION (version 5)To: cl-cleanup@sail.stanford.eduline-fold: noMessage-ID: <881122-135742-10719@Xerox>I attempted to incorporate the extra cases Moon pointed out (on 13 Oct)and reorganized the proposal a bit to avoid some of the circumlocutionsinvolved in saying "the consequences of blah blah ...  blah are undefined."!Issue:         LISP-SYMBOL-REDEFINITION References:    Cleanup issue PACKAGE-CLUTTER		CLtL pp 67-69 Defining named functions Category:      CLARIFICATION Edit history:  Masinter, Version 1, 17-Sep-88 from (Kolb, 14-Aug-87)               Masinter, Version 2, 7-Oct-88               Masinter, Version 3,  7-Oct-88, fix typos               van Roggen, Version 4, 13-Oct-88, undefined, not unspecified               Masinter, Version 5, 22-Nov-88, add more cases Problem description: Is it legal to redefine Common Lisp functions? There is no explicitprohibition, and many implementations do allow redefinition offunctions in the Lisp package. CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions. Proposal LISP-SYMBOL-REDEFINITION:DISALLOWThis proposal uses the phrase "the consequences are undefined" in thesense that implementations may signal an error, or other undefined behaviormay ensue, and attempts to specify that user programs generally cannotportably modify the behavior of the symbols in the LISP package.For example, programming environments may warn the user aboutredefinition of LISP symbols and then allow them. Some environments maydistinguish between functions that are safe to redefine and those that arenot.Specify that the consequences of performing any of the followingoperations are undefined:* redefining as a function or macro any of the functions,macros, or special forms defined in the LISP package;* lexically defining (with FLET, LABELS orMACROLET) any function or macro in the LISP package; * attempting to rebind any symbol in CL defined as a constant;this covers binding as with LET or LAMBDA, assignmentas with SETQ or SETF, or using MAKUNBOUND;(implied by CLtL p. 69)* defining type-specifiers as with DEFTYPE, DEFSTRUCT, orDEFCLASS, any of the built in type specifiers, classes;* defining or redefining SETF macros or functions of anyof the functions, macros or special forms that have specifiedSETF behavior, using either DEFSETF or DEFINE-SETF-METHOD(or with DEFUN if the proposal under SETF-FUNCTION-VS-MACROis adopted);* applying TRACE to any function in the LISP package.No other restrictions are placed on users attaching definitionson symbols in the LISP package; for example, a user programmay (DEFVAR CAR 3)Examples: The behavior of the construct: (FLET ((OPEN (filename &key direction) (format t "Open called....") 			(OPEN filename :direction direction)))    (with-open-file (x "frob" :direction ':output) 		(format t "was Open called?"))) is undefined; for example, the macro expansion of with-open-file might referto the OPEN function and might not. (DEFUN CAR (X) (CDR X)) might signal an error. Rationale: This proposal is the only simple resolution of the problem description thatwe can imagine that is consistent with current implementation techniques. Allowing arbitrary redefinition of symbols in the LISP package would placesevere restrictions on implementations not to actually use those symbols inmacro expansions of other LISP symbols, in function calls, etc. While somelooser restrictions might do for any particular Common Lisp implementation,there seems to be no good way to distinguish between those symbols that areredefinable and those that are not. In general, programs can redefine functions safely by creating new symbols intheir own package, possibly shadowing the name. Current practice: Many Lisp environments have some mechanism for warning about redefinition ofLisp symbols and preventing accidental redefinition while allowing it wherenecessary (e.g., to patch the Lisp system itself, fix a bug, add anoptimization.) Fewer check for lexical redefinition, since such redefinition is not asdangerous. Certainly, there are some symbols that are never used in macroexpansions of the standard Common Lisp macros. However, implementations dodiffer on the behavior of macro expansions. Cost to Implementors: This proposal clarifies the status quo -- that the consequences are undefined. Itallows and encourages implementors to check for such redefinition, but does notrequire it. Cost to Users: This proposal clarifies that implementations are free to check for a conditionthat they might not have before, and may clarify that some current user code isnon-portable. Benefits: This issue frequently arises. Adopting this proposal would clarify a frequentsource of question about Common Lisp.  Cost of non-adoption: Continued questions. Esthetics: Disallowing all redefinition is the simplest way of disallowing the ones thatreally are trouble.  Discussion: There have been various proposals for allowing users to extend the "protection"mechanism to their own macros, functions, packages. These proposals seem likethey are environment issues and not language ones, however.  It is unfortunate that the restriction on reusing LISP package symbols inFLET, LABELS or MACROLET is necessary, but the research into straightening outthe syntactic environment of macroexpansion isn't mature enough to put intoa standard yet.*start*05811 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 17:33:13 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  17:16:11 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 DEC 88 16:58:45 PSTDate: 8 Dec 88 16:42 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: LISP-SYMBOL-REDEFINITION (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881208-165845-4914@Xerox>!Forum:         CleanupIssue:         LISP-SYMBOL-REDEFINITION References:    Cleanup issue PACKAGE-CLUTTER               CLtL pp 67-69 Defining named functions Category:      CLARIFICATION Edit history:  Masinter, Version 1, 17-Sep-88 from (Kolb, 14-Aug-87)               Masinter, Version 2, 7-Oct-88               Masinter, Version 3,  7-Oct-88, fix typos               van Roggen, Version 4, 13-Oct-88, undefined, not unspecified               Masinter, Version 5, 22-Nov-88, add more cases Problem description: Is it legal to redefine Common Lisp functions? There is no explicitprohibition, and many implementations do allow redefinition offunctions in the Lisp package. CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions. Proposal LISP-SYMBOL-REDEFINITION:DISALLOWThis proposal uses the phrase "the consequences are undefined" in thesense that implementations may signal an error, or other undefined behaviormay ensue, and attempts to specify that user programs generally cannotportably modify the behavior of the symbols in the LISP package.For example, programming environments may warn the user aboutredefinition of LISP symbols and then allow them. Some environments maydistinguish between functions that are safe to redefine and those that arenot.Specify that the consequences of performing any of the followingoperations are undefined:* redefining as a function or macro any of the functions,macros, or special forms defined in the LISP package;* lexically defining (with FLET, LABELS orMACROLET) any function or macro in the LISP package; * attempting to rebind any symbol in CL defined as a constant;this covers binding as with LET or LAMBDA, assignmentas with SETQ or SETF, or using MAKUNBOUND;(implied by CLtL p. 69)* defining type-specifiers as with DEFTYPE, DEFSTRUCT, orDEFCLASS, any of the built in type specifiers, classes;* defining or redefining SETF macros or functions of anyof the functions, macros or special forms that have specifiedSETF behavior, using either DEFSETF or DEFINE-SETF-METHOD(or with DEFUN if the proposal under SETF-FUNCTION-VS-MACROis adopted);* applying TRACE to any function in the LISP package.No other restrictions are placed on users attaching definitionson symbols in the LISP package; for example, a user programmay (DEFVAR CAR 3)Examples: The behavior of the construct: (FLET ((OPEN (filename &key direction) (format t "Open called....") 			(OPEN filename :direction direction)))    (with-open-file (x "frob" :direction ':output) 		(format t "was Open called?"))) is undefined; for example, the macro expansion of with-open-file might referto the OPEN function and might not. (DEFUN CAR (X) (CDR X)) might signal an error. Rationale: This proposal is the only simple resolution of the problem description thatwe can imagine that is consistent with current implementation techniques. Allowing arbitrary redefinition of symbols in the LISP package would placesevere restrictions on implementations not to actually use those symbols inmacro expansions of other LISP symbols, in function calls, etc. While somelooser restrictions might do for any particular Common Lisp implementation,there seems to be no good way to distinguish between those symbols that areredefinable and those that are not. In general, programs can redefine functions safely by creating new symbols intheir own package, possibly shadowing the name. Current practice: Many Lisp environments have some mechanism for warning about redefinition ofLisp symbols and preventing accidental redefinition while allowing it wherenecessary (e.g., to patch the Lisp system itself, fix a bug, add anoptimization.) Fewer check for lexical redefinition, since such redefinition is not asdangerous. Certainly, there are some symbols that are never used in macroexpansions of the standard Common Lisp macros. However, implementations dodiffer on the behavior of macro expansions. Cost to Implementors: This proposal clarifies the status quo -- that the consequences are undefined. Itallows and encourages implementors to check for such redefinition, but does notrequire it. Cost to Users: This proposal clarifies that implementations are free to check for a conditionthat they might not have before, and may clarify that some current user code isnon-portable. Benefits: This issue frequently arises. Adopting this proposal would clarify a frequentsource of question about Common Lisp.  Cost of non-adoption: Continued questions. Esthetics: Disallowing all redefinition is the simplest way of disallowing the ones thatreally are trouble.  Discussion: There have been various proposals for allowing users to extend the "protection"mechanism to their own macros, functions, packages. These proposals seem likethey are environment issues and not language ones, however.  It is unfortunate that the restriction on reusing LISP package symbols inFLET, LABELS or MACROLET is necessary, but the research into straightening outthe syntactic environment of macroexpansion isn't mature enough to put intoa standard yet.*start*00769 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 22:46:56 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Jan 89  22:45:23 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 06 JAN 89 11:16:35 PSTDate: 6 Jan 89 11:06 PSTFrom: masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITION (Version 5)In-reply-to: cperdue@Sun.COM (Cris Perdue)'s message of Thu, 5 Jan 89 18:05:29 PSTTo: cperdue@Sun.COM (Cris Perdue)cc: cl-cleanup@sail.stanford.eduMessage-ID: <890106-111635-248@Xerox>On your ballot, Sun commented "This appears to disallow too much." What things would you allow that are disallowed by this proposal?*start*01708 00024 US Return-Path: <cperdue@Sun.COM>Received: from Sun.COM ([10.7.0.2]) by Xerox.COM ; 09 JAN 89 09:30:47 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA11226; Mon, 9 Jan 89 09:33:39 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA08846; Mon, 9 Jan 89 09:30:19 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA11960; Mon, 9 Jan 89 09:31:24 PSTDate: Mon, 9 Jan 89 09:31:24 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8901091731.AA11960@clam.sun.com>To: masinter.paSubject: Re: Issue: LISP-SYMBOL-REDEFINITION (Version 5)Here it is:To: masinter.pa@Xerox.COMSubject: Re:  Issue: LISP-SYMBOL-REDEFINITION (Version 5)Cc: cl-cleanup@sail.stanford.edu> On your ballot, Sun commented "This appears to disallow too much." > > What things would you allow that are disallowed by this proposal?Well, that *is* a fair question.At minimum, it seems excessive to disallow application of TRACEto functions in the LISP package.  I have worked on implementationsof TRACE, and I believe it can work on functions in the Lisp package.If we don't wish to support TRACE on all functions in the Lisp package,we could require TRACE to either work or to not establish tracingof the function.I'd prefer to permit redefinition of macros and functions in theLISP package, though I know there are difficulties.  One would haveto admit that the compiler may treat any or all of these as inline,assuming the built-in definitions, regardless of any user's redefinition.Implementations must also be permitted to call any function in the LISPpackage from any code whatsoever in the implementation.  Perhaps thismakes redefinition unsupportable.*start*00469 00024 US Date:  9 Jan 89 01:04 PSTFrom: masinter.paSubject: Re: Issue: LISP-SYMBOL-REDEFINITION (Version 5)In-reply-to: masinter.pa's message of 6 Jan 89 11:06 PSTTo: masinter.pacc: cperdue@Sun.COM (Cris Perdue)I know you replied but I've apparently misfiled your reply.  Can you retransmit?The query was On your ballot, Sun commented "This appears to disallow too much." What things would you allow that are disallowed by this proposal?*start*02189 00024 US Date:  4 Apr 89 12:15 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: LISP-SYMBOL-REDEFINITIONTo: CL-Cleanup%SAIL.Stanford:EDU:Xeroxcc: sandra%defun%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LISP-SYMBOL-REDEFINITIONTo: CL-Cleanup@SAIL.Stanford.EDUcc: sandra%defun@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:02:00 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:59:22 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571187; Tue 4-Apr-89 14:59:17 EDTOriginal-Date: Tue, 4 Apr 89 14:58 EDTMessage-ID: <890404145850.8.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI need some help here. My notes say: GZ wanted an amendment to strike item 8 from this list. Sandra had some concern about the penultimate paragraph where she wanted a prohibition on the ability to trace local functions (in implementations that permit that).  Moon thinks the proposal was amended to explicitly allow tracing of such local function bindings.>> Sandra: Please resolve this! We went round in circles about item 8.  A straw poll to send this back for more work failed 6-10, so we kept on. A motion was made to terminate discussion. This passed by 2/3 vote. Moon's notes say item 8 may need further refinement, as for instance by GLS's amendment.  The goal is to separate properties into the ones the user can bash and the ones the user cannot bash. [Anyway, we should expect that item 8 may come up in some form at the next meeting.] Ultimately, I have written in my notes that we voted on   ``proposal replaced by RPG, item 8 struck, w/ Sandra's prohibition     to trace local functions'' and that it passed 14-3.>> This might not be accurate depending on how the discrepancy above is resolved.*start*01585 00024 USaDate:  5 Apr 89 08:09 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: pierson%mist.encore:COM:XeroxSubject: Re: Issue: LISP-SYMBOL-REDEFINITIONIn-Reply-to: Your message of Tue, 04 Apr 89 14:58:00 -0400.To: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: sandra%defun@SAIL.Stanford.EDU%multimax.encore:COM:Xerox, CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: "sandra%defun@SAIL.Stanford.EDU"@multimax.encore.com, CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: LISP-SYMBOL-REDEFINITIONIn-Reply-To: Your message of Tue, 04 Apr 89 14:58:00 -0400.From: Dan L. Pierson <pierson@mist.encore.com>Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 APR 89 08:07:37 PDTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 5 Apr 89  08:05:21 PDTReceived: from mist.encore.COM by multimax.encore.com with SMTP (5.61/25-eef)	id AA05665; Wed, 5 Apr 89 11:05:04 -0400Received: from localhost by mist. (4.0/SMI-4.0)	id AA04672; Wed, 5 Apr 89 11:06:53 EDTMessage-Id: <8904051506.AA04672@mist.>Original-Date: Wed, 05 Apr 89 11:06:51 EDTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV     Ultimately, I have written in my notes that we voted on       ``proposal replaced by RPG, item 8 struck, w/ Sandra's prohibition         to trace local functions''     and that it passed 14-3.    My note agree with this interpretation.    *start*05454 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at  9-Apr-89 21:56:18 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 APR 89 21:56:13 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Apr 89  21:55:03 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 09 APR 89 21:55:03 PDTDate: 9 Apr 89 21:54 PDTFrom: masinter.paSubject: Issue: LISP-SYMBOL-REDEFINITION, v.6To: cl-cleanup@SAIL.Stanford.EDUline-fold: NOMessage-ID: <890409-215503-3430@Xerox>I've compared my notes against Mary's minutes, and they agreethat we struck 8 and added a phrase "and to trace that binding"("Sandra's amendment".)!Status: Passed, Mar 89 X3J13, as amendedForum:         CleanupIssue:         LISP-SYMBOL-REDEFINITION References:    Cleanup issue PACKAGE-CLUTTER               CLtL pp 67-69 Defining named functions Category:      CLARIFICATION Edit history:  Masinter, Version 1, 17-Sep-88 from (Kolb, 14-Aug-87)               Masinter, Version 2, 7-Oct-88               Masinter, Version 3,  7-Oct-88, fix typos               van Roggen, Version 4, 13-Oct-88, undefined, not unspecified               Masinter, Version 5, 22-Nov-88, add more cases		Masinter, Version 6,  9-Apr-89, make Mar 89 X3j13 amendments Problem description: Is it legal to redefine Common Lisp functions? There is no explicitprohibition, and many implementations do allow redefinition offunctions in the Lisp package. CLtL only says that special forms can not be redefined. But this doesn't solve the general problem of redefining system functions. Proposal LISP-SYMBOL-REDEFINITION:MAR89-X3J13Except where explicitly allowed, the consequences are undefined if anyof the following actions are performed on symbols in the COMMON-LISPpackage:1. Binding or altering its value (lexically or dynamically)2. Defining or binding it as a function3. Defining or binding it as a macro4. Defining it as a type specifier (defstruct, defclass, deftype)5. Defining it as a structure (defstruct)6. Defining it as a declaration7. Using it as a symbol macro8. Altering its print name (this may already be prohibited)9. Altering its package10. Tracing it11. Declaring or proclaiming it special or lexical12. Declaring or proclaiming its type or ftype13. Removing it from the package COMMON-LISPIf such a symbol is not globally defined as a variable or a constant,it is allowed to lexically bind it and declare the type of that binding.If such a symbol is not defined as a function, macro, or special form,it is allowed to (lexically) bind it as a function and to declare theftype of that binding and to trace that binding.If such a symbol is not defined as a function, macro, or special form,it is allowed to (lexically) bind it as a macro.Examples: The behavior of the construct: (FLET ((OPEN (filename &key direction) (format t "Open called....") 			(OPEN filename :direction direction)))    (with-open-file (x "frob" :direction ':output) 		(format t "was Open called?"))) is undefined; for example, the macro expansion of with-open-file might referto the OPEN function and might not. (DEFUN CAR (X) (CDR X)) might signal an error. Rationale: This proposal is the only simple resolution of the problem description thatwe can imagine that is consistent with current implementation techniques. Allowing arbitrary redefinition of symbols in the system would placesevere restrictions on implementations not to actually use those symbols inmacro expansions of other symbols, in function calls, etc. While somelooser restrictions might do for any particular Common Lisp implementation,there seems to be no good way to distinguish between those symbols that areredefinable and those that are not. In general, programs can redefine functions safely by creating new symbols intheir own package, possibly shadowing the name. Current practice: Many Lisp environments have some mechanism for warning about redefinition ofLisp symbols and preventing accidental redefinition while allowing it wherenecessary (e.g., to patch the Lisp system itself, fix a bug, add anoptimization.) Fewer check for lexical redefinition, since such redefinition is not asdangerous. Certainly, there are some symbols that are never used in macroexpansions of the standard Common Lisp macros. However, implementations dodiffer on the behavior of macro expansions. Cost to Implementors: This proposal clarifies the status quo -- that the consequences are undefined. Itallows and encourages implementors to check for such redefinition, but does notrequire it. Cost to Users: This proposal clarifies that implementations are free to check for a conditionthat they might not have before, and may clarify that some current user code isnon-portable. Benefits: This issue frequently arises. Adopting this proposal would clarify a frequentsource of question about Common Lisp.  Cost of non-adoption: Continued questions. Esthetics: Disallowing all redefinition is the simplest way of disallowing the ones thatreally are trouble.  Discussion: At the March 89 X3j13 meeting, a proposed additional constraint ("Altering its property list") was removed. Presumably this meansthat conformal programs are allowed to alter the property list of symbols in the COMMON-LISP package.