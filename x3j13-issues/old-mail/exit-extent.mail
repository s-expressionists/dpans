*start*08631 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 27 FEB 87 14:25:35 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 27 Feb 87  14:22:53 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL Date: Fri, 27 Feb 87 17:21 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITTo: CL-Cleanup@SAIL.STANFORD.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <870227172152.3.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITReferences:   UNWIND-PROTECT (p140, p142, p39)Category:     CLARIFICATION/CHANGEEdit history: Revision 1 by KMP 02/27/87Problem Description:  If a non-local return is done while in the cleanup form of an  UNWIND-PROTECT, the behavior is not always well-defined.  There are three basic cases:  0. Transfer to another point within the cleanup form.     (UNWIND-PROTECT 3 (BLOCK NIL (RETURN 4)) (PRINT 'XXX))     I believe that we all agree about how this form is to     be interpreted. Effectively:       . 3 evaluates to itself, which is queued for return        from the UNWIND-PROTECT.       . The BLOCK expression is entered, 4 is returned to	it and discarded because this is a not-for-value 	situation.      . XXX is printed, XXX is returned by the PRINT and	that value is discarded because this is a not-for-value	situation.      . The 3 which was yielded earlier is retrieved and	returned as the value of the UNWIND-PROTECT. 1. Transfer to a point inside the point to which control     would have transferred.    (CATCH 'FOO      (CATCH 'BAR	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))    I believe that this is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found within the scope of the target of the       pending THROW (to FOO). 2. Transfer to a point outside the point to which return would    already have been. For example:    (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))    I believe that this is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW (to FOO).Note about Voting:  Two votes are required here: a behavior for item 1 and a  behavior for item 2.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:1A):  Some may believe that what this code is doing is an error,   and that the debugger should be entered with (PRINT 'XXX)   still pending for execution after exit from the debugger.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:1B):  Some may believe that what this code is doing is an error,   and that the debugger should be entered but the (PRINT 'XXX)   would not be executed upon exit from the debugger.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:1C):  Others may believe that the pending seek for tag FOO is   discarded by the second THROW and that value 4 is transfered  to (CATCH 'BAR ...), which returns 4.  The (CATCH 'FOO ...) then returns the 4 because it's first  argument has returned normally.]  Of course, it follows that XXX is not printed in this case.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:1D):  Some may believe that after the throw to BAR is done, the   THROW to FOO should somehow complete but that XXX would   never be printed.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:1E):  Some may believe that after the throw to BAR is done, the   THROW to FOO should somehow complete and that XXX would be  printed.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:2A):  Some may believe that what this code is doing is an error,  and that the debugger should be entered with (PRINT 'XXX)  still pending for execution after exit from the debugger.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:2B):  Some may believe that what this code is doing is an error,  and that the debugger should be entered but the (PRINT 'XXX)  would not be executed upon exit from the debugger.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:2C):  Others may believe that the pending seek for tag FOO is  discarded by the second THROW and that value 4 is transfered  to (CATCH 'BAR ...), which returns 4.   Of course, it follows that XXX is not printed in this case.Rationale (C):  I can only supply rationales for 1C and 2C because they are  the only ones I understand. In Scheme, the action of THROW  is usefully described by saying that it is just like any  other function. It happens to discard the current continuation,  run some cleanup things (like variable unbindings and   UNWIND-PROTECT actions), and transfer control elsewhere in  the program. In doing so, the function uses data structure   primitives not generally available to other programs, but it  is not linguistically different and receives no special   exemption with regard to THROWs or other non-local transfers  of control done within its execution.  As such, a THROW from within an UNWIND-PROTECT cleanup  is not different than one in any other code. It discards the  ongoing action (stack unwinding) and replaces it by another  action (as it happens, another stack unwinding). The previous  unwind is never resumed.Current Practice:  Most interpreted implementations agree with implementation   1C and 2C.  Some compiled implementations agree with 1C and 2C.  Some just output garbage code (probably because lots of people  don't anticipate this case, which is admittedly quite rare).  There may be implementations which do not take action C.   Certainly I have heard such be seriously proposed by competent  professionals.Adoption Cost:  In most cases, correctly supporting any solution we pick up   will require some compiler modification. In some (perhaps many)   cases, that work was in order anyway since compilers may  currently be doing nothing particularly useful or defensible with  the code in question.Benefits:  Programs which do this accidentally should behave the same on   all systems so that bugs can be detected and fixed very early   rather than being found later on a system which disagrees.  Programs which do this on purpose generally are trying to do   something fairly intricate and really need to be able to depend   on it being uniformly treated. A portable error system and   debugger may be among these.Conversion Cost:  Most user programs don't do this so the cost of converting  existing code is probably minimal. (I would bet that anyone   who is deliberately doing this already is expecting option C  anyway, so the cost of conversion is even lower in that case.)Aesthetics:  Languages are always easier to understand if the semantics of   primitive linguistic glue is well-defined. In that regard,   anything is better than the current state.  Option C is likely to be a lot more intuitive to Scheme   programmers and people who do reasoning about programs in   terms of continuation passing than any of the other options.Discussion:  Obviously, the same arguments relate to other kinds of non-local  return (whether lexical or dynamic in nature) across the same   boundaries. Equivalent arguments can be given for the behavior of  RETURN, RETURN-FROM, GO, etc. In the lexical case, the nature of  the search is somewhat different both in time (early binding)   and technique, but for the sake of this discussion that distinction  is not important to me. If someone believes that it is, they should  say so. For now, this vote should be assumed to implicitly address  all such primitives so that they are treated consistently and so  that no later redundant votes on this messy issue are necessary.   KMP strongly favors options 1C and 2C.*start*00750 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:gls@Think.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 03 MAR 87 10:02:25 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 3 Mar 87  09:59:48 PSTReceived: from boethius by Think.COM via CHAOS; Tue, 3 Mar 87 12:58:53 ESTDate: Tue, 3 Mar 87 13:00 ESTFrom: Guy Steele <gls@Think.COM>Subject: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITTo: CL-Cleanup@sail.stanford.eduIn-Reply-To: <870227172152.3.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-Id: <870303130052.7.GLS@BOETHIUS.THINK.COM>I support choices 1C and 2C for this proposal.This is one of those rare and happy cases where thething that is most general and powerful actuallyhappens to be the easiest to implement.*start*01923 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 FEB 87 20:52:11 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 28 Feb 87  20:50:27 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sat 28 Feb 87 23:51:14-ESTDate: Sat, 28 Feb 87 23:51 ESTMessage-ID: <FAHLMAN.12282810128.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: CL-Cleanup@SAIL.STANFORD.EDUSubject: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITIn-reply-to: Msg of 27 Feb 1987  17:21-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>My preference would be 1A or 1B and 2A or 2B.I don't think that KMP's distinction between the A and B cases isuseful, because I think it is totally meaningless to simply "exit fromthe debugger" after an unseen-throw-tag error and proceed to execute thecode after the throw.  Any halfway decent compiler would have decidedthat this code is unreachable and would have thrown it away.  (The sameis true for GO and any other unconditional transfer that fails.)More precisely, I think we should specify that it "is an error" for thecleanup forms of an unwind-protect to contain any non-local transfer ofcontrol that exits that unwind-protect.  I think that this is the bestsolution precisely because it eliminates any confusion about whichnon-local transfer should take precedence under what conditions.If anyone can point out a situation in which such a non-local exit isreally useful (that is, it does something that is not easilyaccomplished some other, less confusing way) then I agree with KMP that1C and 2C is the most reasonable interpretation, and the one leastlikely to contain further nasty interactions in complex cases we haven'tthought of yet.  I could live with C.Spice Lisp currently seems to do 1C and 2C, both compiled andinterpreted.-- Scott*start*01813 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 FEB 87 21:22:13 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 28 Feb 87  21:20:18 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 1 Mar 87 00:21:02-ESTDate: Sun, 1 Mar 87 00:20 ESTMessage-ID: <FAHLMAN.12282815552.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: [RAM: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT]I find the following arguments persuasive, so I would like to change myposition on this issue from favoring A/B to favoring proposal C, as KMPdoes.---------------------------------------------------------------------------Date: Sunday, 1 March 1987  00:06-ESTFrom: Rob MacLachlan <RAM>To:   Scott E. Fahlman <Fahlman>Re:   UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITAlthough you may think that it is hairy to allow unwinding out ofcleanup forms, it complicates the language semantics more to disallowit.  It may be non-obvious that you can unwind in these places, but itfalls out of the normal scoping rules in a straightforward way onceyou beat in the idea that the cleaup code is evaluated in the lexicaland dynamic environment in which the unwind-protect form appears.Forbidding non-local exits makes evaluation in a cleanup formdifferent from evaluation anywhere else.Any implementation that can't unwind from a cleanup form is almostcertainly broken, since it is very hard to be sure that code in thecleanup forms isn't going to throw.  For example, With-Open-File triesto close the file if you unwind, and this operation could easily getan error.  The user could then throw out of the debugger, or acondition handler might also throw.  Rob*start*03475 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 22 APR 87 23:10:29 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 22 Apr 87  23:07:45 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 122478; Thu 23-Apr-87 02:08:00 EDTDate: Thu, 23 Apr 87 02:07 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITTo: CL-Cleanup@SAIL.STANFORD.EDUcc: Hornig@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <870227172152.3.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <870423020745.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Larry's status report says that this issue has been agreed, and that theanswer is 1c and 2c (in the terminology of the referenced message), thatis, the throw that invoked the unwind-protect is abandoned and the newthrow takes place, regardless of whether the target of the new throw isdynamically inside or equal-to-or-outside-of the target of the originalthrow.I never agreed to this, and I think you are overlooking something.  Iwent back through the old discussion and couldn't find any discussion ofthis issue: Consider the form  (loop    (catch 'foo      (unwind-protect (loop)        (throw 'foo t))))With the proposed semantics, it is impossible to stop this programexcept by hitting it with two throws in rapid succession, with exactlythe right amount of delay between them so that the catch andunwind-protect have not yet been re-established when the second throwstrikes.  Consider any program-stopping operation that aborts executionby throwing to a catch in the top-level read-eval-print loop (control-Gin Maclisp or c-Abort in Genera; most other systems have their ownequivalent of this).  With the proposed semantics, when this throwexecutes the unwind-protect cleanup handler, as it must, the throw willbe abandoned and execution will resume looping.To me, the inability to stop a program is a much worse problem thanproviding so-called correct semantics for a contrived program thatdoesn't correspond to any real application.  It was suggested that theerror system might depend on the ability to abort throws like this.  Ifthat were demonstrated, I would change my tune, but until it'sdemonstrated I am completely skeptical of the notion that any errorsystem would do this.Therefore I propose that case 1, transfer to a point inside the point towhich control would have transferred, not do the second throw.  Thereare two things we could require it to do instead (or we could justwimping out and say it "is an error").  It could signal an error, orit could resume the original throw, just as if the cleanup handler hadexited normally.  I prefer signalling an error, because I firmly believethat the program is ill-formed.  Note that signalling an error mustavoid the following pitfall once an error-handling facility is added toCommon Lisp:  (loop    (ignore-errors      (unwind-protect (loop)        (error))))The illegal-nested-throw error must not be caught by ignore-errors ornothing will have been solved.At a minimum I would like to see these considerations included in thediscussion section of the issue file before it is released.  Not allreaders of the file will immediately realize that option (1c) installsa serious environment bug into Common Lisp.*start*01873 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 23 APR 87 21:52:27 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 23 Apr 87  21:50:03 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 123691; Fri 24-Apr-87 00:49:23 EDTDate: Fri, 24 Apr 87 00:49 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITTo: CL-Cleanup@sail.stanford.educc: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>In-Reply-To: <870423123259.1.HORNIG@WINTER.SCRC.Symbolics.COM>Message-ID: <870424004910.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Here's an opinion on this issue from one of our developers, with aninteresting rationale.  I agree with the rationale, which is why Isupport either the mentioned proposal or the one that signals an errorand allows the outer THROW to be completed from the debugger.Date: Thu, 23 Apr 87 12:32 EDTFrom: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>I found KMP's proposal for this and I can now comment effectively.  Mypersonal feelings are that the right proposal for 1 is the one below.  Iagree with KMP that 2C is correct for 2.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:1?):  Some may believe that the throw to BAR is suppressed,  the THROW to FOO should somehow complete, but that XXX would   never be printed.The important factor here is that I believe that whenever there are twoTHROW's in competition, that we should always proceed to the outermostCATCH.  This rule permits a programmer to assume that if he does a THROWout of a computation that that computation will be exited, one way oranother.  This is related to Moon's comment about the programmingenvironment and aborting.*start*02458 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 MAY 87 20:39:22 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 1 May 87  20:37:07 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Fri 1 May 87 23:26:54-EDTDate: Fri, 1 May 87 23:26 EDTMessage-ID: <FAHLMAN.12299047704.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITIn-reply-to: Msg of 23 Apr 1987  02:07-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>    Larry's status report says that this issue has been agreed...    I never agreed to this, and I think you are overlooking something.Well, it should have been "agreed by those present at the pre-X3J13meeting", I guess.    Therefore I propose that case 1, transfer to a point inside the point to    which control would have transferred, not do the second throw.  There    are two things we could require it to do instead (or we could just    wimping out and say it "is an error").  It could signal an error, or    it could resume the original throw, just as if the cleanup handler had    exited normally.  I prefer signalling an error, because I firmly believe    that the program is ill-formed.I think you've spotted a case that the rest of us missed.  At least, itdidn't come up in earlier discussion.  I'm not completely sure what isright, but I'm inclined to agree that "signals an error" is the rightthing here, rather than just allowing the throw whose tag is outermostto win.  I've got a hunch that trying to do the latter would justintroduce another layer of subtle problems.    Note that signalling an error must    avoid the following pitfall once an error-handling facility is added to    Common Lisp:      (loop        (ignore-errors          (unwind-protect (loop)            (error))))    The illegal-nested-throw error must not be caught by ignore-errors or    nothing will have been solved.I guess we need a class of errors that don't get ignored, despite theuser's instructions.  There are probably some other members of thisclass.  Some asynchronous things that have nothing to do with the codeinside the IGNORE-ERRORS form might qualify: system almost out ofmemory, memory error, and stuff like that.-- Scott*start*06432 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 04 MAY 87 14:26:10 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 4 May 87  14:23:05 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 131431; Mon 4-May-87 17:22:42 EDTDate: Mon, 4 May 87 17:22 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITTo: Fahlman@C.CS.CMU.EDU, Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12299047704.BABYL@C.CS.CMU.EDU>References: The message of 23 Apr 1987 02:07-EDT from David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>,            The message of 29 Apr 1980 16:09-EDT from Jon L White <JONL at MIT-MC>Message-ID: <870504172241.0.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Fri, 1 May 1987  23:26 EDT    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    In-reply-to: Msg of 23 Apr 1987 02:07-EDT	         from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>	...	Note that signalling an error must	avoid the following pitfall once an error-handling facility is added to	Common Lisp:	  (loop	    (ignore-errors	      (unwind-protect (loop)		(error))))	The illegal-nested-throw error must not be caught by ignore-errors or	nothing will have been solved.Personally, I consider the meaning of this to be well-formed. It'd besad for a programmer to get into this, but I think that in this casethe user has pretty clearly asked to have a loop that cannot be exitedand deserves to have that request carried out. Consider how ridiculous it would have looked on Star Trek when theyneeded to divert the computer's attention and said "Computer, compute tothe last digit the value of pi".  If I recall, Spock makes a remark like"As you know, the value of pi is a transcendental number withoutresolution. ... The computer will work on this problem to the exclusionof all else ...". Imagine how frustrated he'd have been if the computerhad refused to execute the command because it didn't seem like he reallymeant what he said.Well, ok, so this isn't the most likely scenario. But the truth is,as Prof. Bill Martin said once in a linguistics class I took from him --We create syntax in a language not to allow us to say the things thatare obvious, but so that we can say things that are not obvious. If wedidn't need to say things that were not obvious, we'd just jumble allthe words together and assume people would figure out some uniquely determined, obviously useful interpretation. In fact, we make carefulrules to allow us to say bizarre things not so we can say bizarre thingsall the time, but so that if there comes a time to say such things, wewon't be at a loss for words.By the way, I did once write a CL program that wanted the semantics thatMoon claims are implausible. In Common Lisp, there was no portable way tomake a Lisp have a Macsyma toplevel (ie, where the vendor's abort characterwould return me to Macsyma and not to Lisp). So I wrote something which dideffectively: (DEFUN MACSYMA-TOPLEVEL ()   (PROG ()     LOOP (UNWIND-PROTECT (REALLY-MACSYMA-TOPLEVEL)			  (GO LOOP))))so that people who'd invoked Macsyma toplevel couldn't get back to toplevellisp. So while it might be rare, it's not unthinkable that someone could reallywrite this and mean what they said...As such, I don't rate this desire to let the user intervene at the samelevel of importance that Moon does. However, since I do find it aninteresting issue, I'm willing to entertain the issue for discussionfor now without prejudice to its ultimate importance.    I guess we need a class of errors that don't get ignored, despite the    user's instructions.  There are probably some other members of this    class.  Some asynchronous things that have nothing to do with the code    inside the IGNORE-ERRORS form might qualify: system almost out of    memory, memory error, and stuff like that.If we did make this illegal, I'm curious exactly what Moon would want tohave happen here. The most plausible scenario I can come up with that fitsin this hypothetical framework is the following (which is essentially likewhat Scott is suggesting) ... THROW could notice that it was going to THROW to a point inside a THROW which was already active. At this point, it could signal a SERIOUS-CONDITION (some type which was not a subtype of ERROR), so that IGNORE-ERRORS did not catch the condition, but that did have a default handler that would force entry into the debugger. This would allow an opportunity for user-intervention. The debugger could offer options which should include:   * Going ahead with the inner THROW (and discarding the outer     THROW attempt).   * Exiting from this UNWIND-PROTECT cleanup body and continuing     the ongoing THROW.   * Blowing away the process without running its UNWIND-PROTECT     cleanups. This would allow for user intervention without precluding what I believe to be the clean semantics (choice C). I'm suspicious of any choice which doesn't even allow the user to get style-C semantics if that's what he wants.Dave, is this the sort of thing you're proposing? If not, couldyou please sketch what you are suggesting for contrast?By the way, I ran across the following piece of mail the other daywhile looking around for something else. I just thought you'd beinterested to know that this problem is as old as UNWIND-PROTECTitself; the message is from only a few days after UNWIND-PROTECTwas first installed in Maclisp and although the bug is not likethe one we're discussing, the test scenario is a lot similar tothe code sketch Moon did above...-----Forwarded Message Follows-----Date: 29 April 1980 16:09-EDTFrom: Jon L White <JONL at MIT-MC>To: KMP at MIT-MC, RWK at MIT-MCcc: BUG-LISP at MIT-MCSubject: UNWIND-PROTECTOn the 15th of Feb, KMP sent out a bug notice about UNWIND-PROTECTlosing, for which I made the diagnosis that ERRSET was not savingand restoring the UNREAL flag. The test case is (DEFUN KMP-LOSES () (ERRSET (UNWIND-PROTECT NIL (OPEN '((DSK BOO) BAR BZ)))))Well, I found a way to fix ERRSET without taking more pdl locations,and the assembled code (already initialized) is on LISP;BBLISP 995QIO....*start*03825 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAY 87 11:55:51 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 10 May 87  11:54:48 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 10 May 87 14:54:06-EDTDate: Sun, 10 May 87 14:54 EDTMessage-ID: <FAHLMAN.12301313646.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: [RAM: exiting from unwind protects]I find the following pretty persuasive...Date: Saturday, 2 May 1987  11:16-EDTFrom: Rob MacLachlan <RAM>To:   fahlmanRe:   exiting from unwind protectsReSent-Date: Sun 10 May 87 10:56:56-EDTReSent-From: Rob.MacLachlan@C.CS.CMU.EDUReSent-To: fahlman@C.CS.CMU.EDUReSent-Message-ID: <12301270482.15.RAM@C.CS.CMU.EDU>I don't really agree with Moon about this thing.  I certainly knew aboutabout the feature of being about to write something that you can't exitfrom using any common lisp facility, but I don't see this as a"serious environment bug".  Our system has always has this property.When someone first pointed out this property of Common Lisp way backwhen, I did in fact write the pathological example and it did in factbehave in the pathological fashion.  After a while I got bored oftrying to throw out of the break loop, and I quit.If I had really been doing anything, I could always have skipped overthe losing frame using debug-return.  Environment problems can haveenvironment solutions.  In any case, I could have saved work I wasdoing from the break loop.  This feature certainly isn't a big deal;there are lots of ways a malicious Lisp user can blow the system outof the water.  What happened the last time you did (makunbound '*terminal-io*)?In contrast, it seems to me that all the "fixes" for this problemresult in substantial increases in the complexity of the languagedefintion for no gain.  It seems that Moon has already introducedthree new things into the language: 1] The concept of "throwing out of an unwind protect cleanup".  When    are you in an unwind protect?  What does it mean to throw out of    it?  Does this apply to lexical exits too?  Does this signal an    error?      (block block        (unwind-protect <foo>          (return-from block)))    Does this?      (unwind-protect <foo>        (block block          (return-from block))) 2] The concept of errors that aren't errors, which we need so that    users can't screw themselves with this feature no matter how hard    they try. 3] The implicit requirement that an implementation have some exit    mechanism other than throw so that it can unwind out of cleanup    forms even if the user can't.  What does the system do when you    are running in an unwind protect and the user types an interrupt?    In fact, it seems that Moon is being inconsistent here, since he    has already assumed that interrupts do throw.  If the user    interrupts when running in a cleanup do you signal an error, and    then signal an error whenever the user tries to abort out of the    debugger?If I had ever been screwed by this, I would think differently.  I'msure that most of the reason that this problem doesn't happen is thatpeople usually don't write code that aborts from unwind protectcleanups.  There is a big difference between saying that something israrely needed and possibly dangerous and saying that it must signal anerror.I am convinced that the simplest evaluation model is to say that theunwind-protect cleanup is evaluated in the lexical and dynamicenvironment of the unwind-protect form.  Any alternative must somehowintroduce an "in an unwind protect cleanup" marker into the dynamicenvironment of the cleanup forms.  Rob*start*09020 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 MAY 87 21:06:05 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 12 May 87  21:04:19 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 138596; Wed 13-May-87 00:02:53 EDTDate: Wed, 13 May 87 00:02 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: [RAM: exiting from unwind protects]To: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12301313646.BABYL@C.CS.CMU.EDU>Message-ID: <870513000235.7.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sun, 10 May 1987  14:54 EDT    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    I find the following pretty persuasive...I don't.  Actually it seems to be mostly irrelevant to the issue athand.  Here's some commentary on it.  Feel free to show this to RAM ifyou wish.    Date: Saturday, 2 May 1987  11:16-EDT    From: Rob MacLachlan <RAM>    I don't really agree with Moon about this thing.  I certainly knew about    about the feature of being about to write something that you can't exit    from using any common lisp facility, but I don't see this as a    "serious environment bug".  Our system has always has this property.    When someone first pointed out this property of Common Lisp way back    when, I did in fact write the pathological example and it did in fact    behave in the pathological fashion.  After a while I got bored of    trying to throw out of the break loop, and I quit.    If I had really been doing anything, I could always have skipped over    the losing frame using debug-return.  Environment problems can have    environment solutions.  I don't know what debug-return is (presumably something in the SpiceLisp environment).  Unless it's something that bypasses unwind-protectand deliberately doesn't evaluate the cleanup forms, I don't think itsolves the problem.  However, I agree that environment problems can haveenvironment solutions, and I think the issue is to make sure that thelanguage doesn't forbid the environment from solving this by trying toenforce a particular semantics for the pathological construct, insteadof having it be an error.			    In any case, I could have saved work I was    doing from the break loop.  This feature certainly isn't a big deal;    there are lots of ways a malicious Lisp user can blow the system out    of the water.  What happened the last time you did     (makunbound '*terminal-io*)?The second paragraph on p.329 appears to say that it is invalid for aportable program to do that.  What I am arguing for is a similarrestriction on portable programs doing the similar thing withunwind-protect and throw.  So I think this example actually supports myposition.    In contrast, it seems to me that all the "fixes" for this problem    result in substantial increases in the complexity of the language    defintion for no gain.  It seems that Moon has already introduced    three new things into the language:     1] The concept of "throwing out of an unwind protect cleanup".  When	are you in an unwind protect?  What does it mean to throw out of	it?  Does this apply to lexical exits too?  Does this signal an	error?	  (block block	    (unwind-protect <foo>	      (return-from block)))	Does this?	  (unwind-protect <foo>	    (block block	      (return-from block)))Most of this would be answered by re-reading the relevant proposal tothe cleanup committee (are these archived someplace public?), whichwas not written by me.  I agree that we need a better-written versionof that proposal that is easier to understand and less ambiguous.  Theone I am looking at is  Message-ID: <870227172152.3.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>  Issue:        UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT  Edit history: Revision 1 by KMP 02/27/87My only contribution to the discussion wasin the message <870423020745.9.MOON@EUPHRATES.SCRC.Symbolics.COM>.Here are some relevant excerpts from the referenced proposal:  If a non-local return is done while in the cleanup form of an  UNWIND-PROTECT, the behavior is not always well-defined.  There are three basic cases:  ...  1. Transfer to a point inside the point to which control     would have transferred.and what I proposed in answer to this was to do one of threethings in case 1, transfer to a point inside the point towhich control would have transferred.  1. wimp out and say it "is an error"  2. signal an error  3. resume the original throw, just as if the cleanup handler had     exited normally.I prefer signalling an error, because I firmly believe that the programis ill-formed.Note that I have not introduced any new concepts here.  I don't thinkthe UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT proposal introduced newconcepts either; it just made explicit reference to concepts thatwere already in Common Lisp.  The argument that these concepts makethe language definition too complex seems to be an argument that thelanguage definition should not attempt to define the semantics of throwingprecisely.     2] The concept of errors that aren't errors, which we need so that	users can't screw themselves with this feature no matter how hard	they try.Last time I read the "error proposal" it included this concept.  I don'tthink I invented it, I just borrowed it from there while writing up thediscussion of throw vs. unwind-protect.  Certainly in the absence of theerror proposal this concept is not introduced into the language, since thelanguage currently does not contain an IGNORE-ERRORS construct, nor anyother construct that is sensitive to the issue.     3] The implicit requirement that an implementation have some exit	mechanism other than throw so that it can unwind out of cleanup	forms even if the user can't.  What does the system do when you	are running in an unwind protect and the user types an interrupt?	In fact, it seems that Moon is being inconsistent here, since he	has already assumed that interrupts do throw.  If the user	interrupts when running in a cleanup do you signal an error, and	then signal an error whenever the user tries to abort out of the	debugger?All of point 3 appears to be a misunderstanding of what was beingdiscussed and proposed.  "Transfer to a point inside the point to whichcontrol would have transferred" is irrelevant to "the user types aninterrupt" (which I take to mean something like Maclisp's control-Xand control-G, i.e. abort the program and return to a read-eval-printloop) since those would be transfers to a point outside of, or equal to,any throw currently in progress.    If I had ever been screwed by this, I would think differently.  The inside-Symbolics component of this discussion originated with acustomer being screwed by this.								    I'm    sure that most of the reason that this problem doesn't happen is that    people usually don't write code that aborts from unwind protect    cleanups.  There is a big difference between saying that something is    rarely needed and possibly dangerous and saying that it must signal an    error.    I am convinced that the simplest evaluation model is to say that the    unwind-protect cleanup is evaluated in the lexical and dynamic    environment of the unwind-protect form.  Nobody ever proposed anything different as far as I am aware.					     Any alternative must somehow    introduce an "in an unwind protect cleanup" marker into the dynamic    environment of the cleanup forms.The issue is actually what happens you nest throws (throughout thisdiscussion "throw" has been understood to include all non-local exits,not only the THROW function).  Thus the marker in question is "in throw",not "in an unwind protect cleanup".Yes, the dynamic state of a program that is throwing would need toinclude an indication of where it was throwing to if we were to adoptthe proposal that misnested throws signal an error or the proposal thatthey resume the outer throw.  In the "is an error" case, there are norequirements on the implementation, and the requirement is only thatportable programs cannot assume any particular behavior.  However, Ican't imagine an implementation of throw that does -not- remember in itsdynamic state where it's going to throw to when it finishes evaluatingsome unwind-protect cleanup forms.To get back to earth after all this lofty flaming, remember that thespecific case mentioned in the UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITproposal was    (CATCH 'FOO      (CATCH 'BAR	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))and the question is: what does the THROW to BAR do?  One possible answerthat many people seemed to favor is it throws to BAR and the throw toFOO never happens.  The answer I prefer is that this is not a validCommon Lisp program.  Does this make the issue clear?*start*04594 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:edsel!bhopal!jonl@navajo.stanford.edu>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 MAY 87 21:22:55 PDTReceived: from NAVAJO.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 13 May 87  21:21:16 PDTReceived: by navajo.stanford.edu; Wed, 13 May 87 21:18:45 PDTReceived: from bhopal.edsel.uucp by edsel.uucp (2.2/SMI-2.0)	id AA01380; Wed, 13 May 87 20:01:41 pdtReceived: by bhopal.edsel.uucp (3.2/SMI-3.2)	id AA03441; Wed, 13 May 87 20:03:04 PDTDate: Wed, 13 May 87 20:03:04 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8705140303.AA03441@bhopal.edsel.uucp>To: navajo!Moon%STONY-BROOK.SCRC.Symbolics.COM@navajo.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 13 May 87 00:02 EDT <870513000235.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Cc: navajo!cl-cleanup%SAIL@navajo.stanford.eduSubject: looping in unwind-protect cleanupsI tend to agree with you that looping caused by UWP cleanup forms throwing back through the same cleanup forms is a serious error;  and that this situation not only ought to be "signalled" as an error, but also ought tobe recuperable (from the debugger, I suppose).   However, one or two loose ends need to be cleared up.  You mention the example from the originalproposal:    (CATCH 'FOO      (CATCH 'BAR	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))and you use the phrase "... this is not a valid Common Lisp program."  I have trouble with that characterization, since it seems to imply some mechanically checkable property of programs.  The "serious error"mentioned above is a dynamic condition, which could be caused by other programs that are not so clearly analyzable.  For example, consider just removing the (THROW 'BAR 4) out of the lexical context:    (CATCH 'FOO      (CATCH 'BAR	(UNWIND-PROTECT (THROW 'FOO 3)	  (DO-A-BIT-OF-WORK)	  (PRINT 'XXX))))    (DEFUN DO-A-BIT-OF-WORK ()       (UNLESS (WINNINGP)	(THROW 'BAR 4)))I think you see how this could be extended to produce an example that couldnot be mechanically proven invalid by the UWP-non-local-exit criterion,even though it would get into the disastrous loop.How about this characterization of the problem: for a given process, theunwind-protect cleanup forms should be viewed as non-reentrant code.  Anattempt to execute such code reentrantly will signal an error, which willprobably enter the debugger (and entering the debugger won't, by itself,cause another throw, so there is no fear of infinite looping from thisstep).  In such a case, the user should have the choice of continuing with the re-entrant invocation, or of doing an "abort" which skips doing thesignalled UWP frame's cleanups.  In the first case, he may want to "tryagain" at the cleanups, because it just might be that they were entered"re-entrantly" only because he interrupted in the middle of some cleanups,and then asked the debugger to "abort to toplevel"; or maybe entering the"embrace" depends on some global data which he has just "fixed".  In the second case, he may recognize the "deadly embrace" as hopeless, and simplywish to punt out of it.There is some concern about "hairing up" the UWP/THROW mechanisms.  Idon't believe that this approach, or *** ones like it *** (which werealluded to in previous messages) is really all that complex.  Implementationally, it would seem to require at most:  (1) For each UWP frame, the "cleanup forms" have an associated lock       (possibly a per-process lock) that is acquired upon entry [and       released upon exit?].  Failure to acquire the lock signals the       re-entrancy error.  The acquisition/release time could hardly      be more than a few memory cycles time, and hence won't be a serious      slowdown for THROWing.  (2) The low-level part of THROW would admit a "skip me" argument, so      that it could be told which UWP/CATCH frame to omit the cleanups      on [but not the lock releasings?].  Only one "skip me" is needed,       since nested "deadly embraces"  could be undone one step at a time.      [In fact there really only could be one frame to "skip" -- the one       whose lock is already tied up.]I don't mean to imply that this is the only, or the best, or even theclearest implementation of such an idea; but I claim that non-re-entrancy isn't all that deep a concept here.  It's more to the point than saying"non-interruptible" (which is wrong); and more succinct than some othercharacterizations of how one might detect the "deadly embrace".-- JonL --*start*03128 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 MAY 87 21:59:26 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 13 May 87  21:58:44 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 139634; Thu 14-May-87 00:57:23 EDTDate: Thu, 14 May 87 00:57 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: looping in unwind-protect cleanupsTo: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8705140303.AA03441@bhopal.edsel.uucp>Message-ID: <870514005708.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Wed, 13 May 87 20:03:04 PDT    From: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)    ...you use the phrase "... this is not a valid Common Lisp program."      I have trouble with that characterization, since it seems to imply     some mechanically checkable property of programs.I didn't mean to imply that.    ...I think you see how this could be extended to produce an example that could    not be mechanically proven invalid by the UWP-non-local-exit criterion,    even though it would get into the disastrous loop.Sure.  If you give me a few hours, I will mail you examples of programsin Common Lisp, Ada, and Basic the determination of whose validity intheir respective languages is equivalent to the halting problem.  Thebasic plan is to write a program where it cannot be mechanically provenwhether an array subscript is out of bounds.    ....Implementationally, it would seem to require at most:      (1) For each UWP frame, the "cleanup forms" have an associated lock ....This is rather overcomplicated, so let me tell you how the versions ofSymbolics systems that implement my proposed checking do it.  None ofthese are released yet.  This is from memory, I didn't write the code.1. Every catch (including ones generated internally by tagbody and blockwhen nonlocal exits via go, return, or return-from are happening) containsa validity bit, which is initially 1.2. When throw plans to throw past a catch, it sets its validity bit to 0.This happens after throw finds the target catch (since Common Lisp says ifthere is no matching catch, the error is signalled in the dynamic environmentof the throw), and before throw starts removing state from the stack andevaluating cleanup forms.  Here throw includes nonlocal go, return, andreturn-from along with certain debugger commands.3. An attempt to throw to a catch whose validity bit is 0 signals an errorthat isn't caught by IGNORE-ERRORS.4. The error in 3 is implemented by the Common Lisp function BREAK.5. When throw evaluates an unwind-protect cleanup form, it first removesit from the list of such forms, so that if you throw again it won't beevaluated again.  (I'm pretty sure that a close reading of CLtL showsthat this is required.)Note that the only data structure or dynamic state is one bit per catch,the only overhead is in throw, and the error signalling is implementedwith an existing Common Lisp facility.*start*02089 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:edsel!bhopal!jonl@navajo.stanford.edu>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 14 MAY 87 10:40:19 PDTReceived: from NAVAJO.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 14 May 87  10:39:24 PDTReceived: by navajo.stanford.edu; Thu, 14 May 87 10:36:48 PDTReceived: from bhopal.edsel.uucp by edsel.uucp (2.2/SMI-2.0)	id AA03537; Thu, 14 May 87 10:23:10 pdtReceived: by bhopal.edsel.uucp (3.2/SMI-3.2)	id AA03960; Thu, 14 May 87 10:24:36 PDTDate: Thu, 14 May 87 10:24:36 PDTFrom: edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Message-Id: <8705141724.AA03960@bhopal.edsel.uucp>To: navajo!Moon%STONY-BROOK.SCRC.Symbolics.COM@navajo.stanford.eduCc: navajo!cl-cleanup%SAIL@navajo.stanford.eduIn-Reply-To: David A. Moon's message of Thu, 14 May 87 00:57 EDT <870514005708.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: looping in unwind-protect cleanupsRe: . . . let me tell you how the versions of    Symbolics systems that implement my proposed checking do it.  None of    these are released yet.  This is from memory, I didn't write the code.    . . .     Note that the only data structure or dynamic state is one bit per catch,    the only overhead is in throw, and the error signalling is implemented    with an existing Common Lisp facility.A lock is effectively 1 bit per catch, and by storeing it in the catchframe, it is process-specific; lock-acquisition would be done in THROW,and is very low overhead.  I suspect these two proposed implementationsare isomorphic at a fundamental level, with your "validity bit" replaceingmy "lock".The only thing that seems a bit peculiar in your review of the new Symbolicscode is that the error signalled by "failure to acquire the lock" has to be treated specially (not caught by IGNORE-ERRORS, goes directly to BREAK, "does not pass GO, lands in jail", whatever).  Maybe that is the reason RAM and some others were so upset by the original proposal.  I think I see the point of the special handling; but I don't like the singularity.-- JonL --*start*12469 00024 USfDate: 24 Oct 87 17:30 PDTFrom: Masinter.paSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)To: cl-cleanup@Sail.stanford.edu, Hornig@SCRC.Symbolics.COMLine-fold: 80cc: Masinter.paMy habit of starting alphabetically and not getting all the way done has caused this issue to be neglected. I thought I would start from the end this pass. This is an important issue, it seems to be in the way of producing a valid portable error system. It took me several hours to try to put together a version that summarized the arguments that took place last May. I hope I have captured them. We now also have some new members; do we have any new opinions? (If anyone wants my archive on this or any issue, let me know and I will store it.)Issue:          UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITReferences:     UNWIND-PROTECT (p140, p142, p39)                Issue IGNORE-ERRORS, Draft error proposal.Category:       CLARIFICATION/CHANGEEdit history:   Version 1 by Pitman   27-Feb-87                Version 2 by Masinter 24-Oct-87Problem Description:If a non-local return is done while in the cleanup form of an UNWIND-PROTECT, the behavior is not always well-defined.There are three basic cases:Situation 0. Transfer to another point within the cleanup form.   (UNWIND-PROTECT 3 (BLOCK NIL (RETURN 4)) (PRINT 'XXX))There is no ambiguity about how this form is to be interpreted.Effectively:       . 3 evaluates to itself, which is queued for return        from the UNWIND-PROTECT.       . The BLOCK expression is entered, 4 is returned to	it and discarded because this is a not-for-value 	situation.      . XXX is printed, XXX is returned by the PRINT and	that value is discarded because this is a not-for-value	situation.      . The 3 which was yielded earlier is retrieved and	returned as the value of the UNWIND-PROTECT.Situation 1. Transfer to a point inside the point to which control     would have transferred.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found within the scope of the target of the       pending THROW (to FOO).Situation 2. Transfer to a point outside the point to which return would    already have been. For example:    (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW (to FOO).What is the appropriate behavior for situation 1 and situation 2 and similar ones? For example, suppose that when WITH-OPEN-FILE tries to close the file upon unwinding, it signals an error, and the condition handler also attempts to throw? The question applies to all non-local transfers, whether performed by THROW, RETURN-FROM, RETURN, GO.There is general agreement about Situation 2, but three proposals for Situation 1.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:2-EXIT):Where an UNWIND-PROTECT cleanup form attempts a non-local exit to a point outside the original non-local exit, control is passed to the outer exit (and the pending original non-local exit is discarded.)In Situation 2, the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.[In no case will UNWIND-PROTECT cleanup forms ever be attempted more than once.]Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:1-RETURN-INNER):While processing UNWIND-PROTECT cleanup forms, a non-local exit to a point outside of the scope of the UNWIND-PROTECT, but still within the dynamic scope of of the target of the original non-local exit.... ... the second non-local exit succeeds, and the original pending exit is discarded. In Situation 1, the pending seek for tag FOO is discarded by the second THROW to BAR and the value 4 is transfered to (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...) then returns the 4 because its first argument has returned normally. XXX is not printed.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:1-RETURN-OUTER):... the second non-local exit instead continues the original (more extensive) one. In Situation 1, the second THROW to BAR is discarded in lieu of continuing the THROW to FOO.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:1-SIGNAL-ERROR):... signals an error.(If the IGNORE-ERRORS cleanup proposal or the proposed error/signal system be adopted, it would be an error which would not be ignored by IGNORE-ERRORS, for reasons outlined below.)In situation 1, the second THROW to BAR would signal an error.  Implementation notes:There are several ways of implementing 1-SIGNAL-ERROR; this example is merely given to illustrate: 1. Every CATCH, and every TAGBODY and BLOCK which might have non-local exits via GO, RETURN or RETURN-FROM creates a marker with a validity state, initially true.2. When a non-local exit (via THROW, GO, RETURN or RETURN-FROM) plans to return control past a validity marker, it sets its validity state to false, before any state is removed from the stack and any cleanup form is evaluated. (For THROW, this happens after the target CATCH is found, since, if there is no matching catch, the error is signalled in the dynamic environment of the THROW).3. If the validity state of the target of a non-local exit is false,  an (non-ignorable) error is signalled.4. When a non-local exit evaluates an unwind-protect cleanup form, it first removes it from the list of such forms, so that with any subsequent non-local exit it won't be evaluated again.Rationale:Current Practice:Some implementations generate garbage code in situations 2 and 3.  Some have differing behavior compiled and interpreted.Most that have implementations seem to implement 2-EXIT, but there is some divergence in Situation 1. For example, Spice Lisp and Xerox implement 1-RETURN-INNER, while Symbolics implements 1-SIGNAL-ERROR. Some compiled implementations agree with 1C and 2C. Some just output garbage code (probably because lots of people don't anticipate this case, which is admittedly quite rare).Adoption Cost:While require some compiler modifications in some implementations. In some cases, that work was in order anyway since compilers may currently be doing nothing particularly useful or defensible with the code in question.  There is some sentiment that 1-RETURN-INNER is the simplest to implement. Benefits:No matter which proposal is adopted, having this situation uniformly treated seems critical.Programs which do this accidentally should behave the same on all systems so that bugs can be detected and fixed very early rather than being found later on a system which disagrees.Programs which do this on purpose generally are trying to do something fairly intricate and really need to be able to depend on it being uniformly treated. A portable error/signal system and debugger may be among these.1-RETURN-INNER's motiviation is simplicity and aesthetics; 1-SIGNAL-ERROR and 1-RETURN-OUTER's motivation are robustness and convenience. These are discussed here.1-RETURN-INNER is more intuitive to programmers who reason about programs in terms of continuation passing. It falls out of the normal scoping rules as a consequence of the fact that the cleaup code is evaluated in the lexical and dynamic environment in which the UNWIND-PROTECT form appears. The action of THROW is usefully described by saying that it is just like any other function. It happens to discard the current continuation,  run some cleanup things (like variable unbindings and UNWIND-PROTECT actions), and transfer control elsewhere in the program. In doing so, the function uses data structure primitives not generally available to other programs, but it is not linguistically different and receives no special exemption with regard to THROWs or other non-local transfers of control done within its execution. A THROW from within an UNWIND-PROTECT cleanup is not different than one in any other code; it discards the ongoing action (stack unwinding) and replaces it by another action (as it happens, another stack unwinding). The previous unwind is never resumed.1-SIGNAL-ERROR and 1-RETURN-OUTER complicate the language semantics but improve environment reliability. For example, given  (LOOP    (CATCH 'FOO      (UNWIND-PROTECT (LOOP)        (THROW 'FOO T))))With 1-RETURN-INNER there is no way of exiting such a form. 1-SIGNAL-ERROR would prevent programmers from getting into this unfortunate situation.1-RETURN-OUTER would guarantee that, upon a non-local exit out of a computation, the   computation will be exited, one way or another. Conversion Cost:Most user programs don't do this so the cost of converting existing code is probably minimal. (There is some evidence that there are programs that expect the behavior of 1-RETURN-INNER, so that the cost of conversion is even lower in that case.)Discussion:1-SIGNAL-ERROR (and 1-RETURN-OUTER) prevent a serious environment bug, where it is possible to create loops which cannot be aborted with interrupts, the debugger or the like. The error signalled in 1-SIGNAL-ERROR must not be one caught by IGNORE-ERRORS; otherwise(loop    (ignore-errors      (unwind-protect (loop)        (error))))would have similar non-termination capabilities. Some argue that the situation that 1-SIGNAL-ERROR attempts to prevent is perfectly valid: while it would be for a programmer to get into this, the user has pretty clearly asked to have a loop that cannot be exited and deserves to have that request carried out.  "We create syntax in a language not to allow us to say the things that are obvious, but so that we can say things that are not obvious. If we didn't need to say things that were not obvious, we'd just jumble all the words together and assume people would figure out some uniquely determined, obviously useful interpretation. In fact, we make careful rules to allow us to say bizarre things not so we can say bizarre things all the time, but so that if there comes a time to say such things, we won't be at a loss for words."One real example offered was a top-level, where the Common Lisp implementation's abort character would return to that level.  (DEFUN MY-TOPLEVEL ()   (PROG ()     LOOP (UNWIND-PROTECT (REALLY-MY-TOPLEVEL)			  (GO LOOP))))so that people who'd invoked my toplevel couldn't get back to toplevel Lisp. While it might be rare, it's not unthinkable that someone could really write this and mean what they said...Some do not credit the seriousness of the "environment bug"; generally, programming environments may need some way of aborting such a program without executing the offending cleanup form, but it is an environment problem which should have an environment solution. There are many other ways a malicious Lisp user could blow the system outof the water, e.g.  (makunbound '*terminal-io*), although those are admittedly not valid Common Lisp programs.Moon supported 1-SIGNAL-ERROR or 1-RETURN-OUTER.Fahlman said he is inclined to support 1-SIGNAL-ERROR over 1-RETURN-OUTER.Masinter, Pitman and Steele indicated support for 1-RETURN-INNER. All endorse 2-EXIT.        TITAN          TITAN           
TIMESROMAN 
                        &              \                            Q             
^       :      v       B      ,                     B              A                    f             &              m                                                      *       
                                              7            . ,z*start*00471 00024 USaDate: Sat, 24 Oct 87 17:42:32 PDTFrom: Pavel.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)In-reply-to: <871024-173113-2262@Xerox>To: MasinterIn the sentence``The question applies to all non-local transfers, whether performed by THROW, RETURN-FROM, RETURN, GO.''Since RETURN is a macro, perhaps this should be``The question applies to all non-local transfers, whether performed by THROW, RETURN-FROM, or GO.''*start*00799 00024 USaDate: Sat, 24 Oct 87 17:53:27 PDTFrom: Pavel.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)In-reply-to: <871024-173113-2262@Xerox>To: MasinterUnder the current practice heading, you refer to ``situations 2 and 3'' where you presumably mean ``situations 1 and 2''.Also, you refer to ``1C and 2C'' but these have no definitions.Under ``Adoption Cost'', this non-sentence appears:``While require some compiler modifications in some implementations.''Under the ``Benefits'' section, the phrase ``Programs which'', appearing twice, should be ``Programs that''.Another odd phrase appears under ``Discussion'':``while it would be for a programmer to get into this,''The quote in this paragraph should be attributed to its source (RAM?).*start*00375 00024 UShDate: 24 Oct 87 17:54 PDTFrom: Masinter.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)In-reply-to: Pavel.pa's message of Sat, 24 Oct 87 17:42:32 PDTTo: Pavel.pacc: Masinter.pawell, RETURN is the only macro I can think of off-hand that translates to a non-local exit; it certainly does no harm to mention it, does it?*start*00512 00024 UShDate: Sat, 24 Oct 87 17:58:19 PDTFrom: Pavel.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)In-reply-to: "Your message of 24 Oct 87 17:54 PDT"To: MasinterIt does no harm to mention RETURN, but it caught my attention as being anomolous, but maybe that's just because I wrote the compiler and am thus super-sensitive to the difference between macros and special forms.I sent my content comments to the whole list.  I favor 1-RETURN-INNER and 2-EXIT.	Pavel*start*00895 00024 UShReturn-Path: <@SAIL.Stanford.EDU:Pavel.pa@Xerox.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 OCT 87 17:59:46 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 24 Oct 87  17:57:13 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 24 OCT 87 17:56:02 PDTDate: Sat, 24 Oct 87 17:55:55 PDTFrom: Pavel.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)In-reply-to: <871024-173113-2262@Xerox>To: cl-cleanup@Sail.stanford.edu, Hornig@SCRC.Symbolics.COMMessage-ID: <871024-175602-2272@Xerox>I support 1-RETURN-INNER because of the semantic cleanliness issue.  Idon't give much credit to the unbreakable loop issue; it doesn't seemlike a linguistic issue to me.  After all, Common Lisp doesn't evenadmit that there is such a thing as an interrupt character.I also support 2-EXIT.	Pavel*start*00829 00024 UShReturn-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 25 OCT 87 17:28:57 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 25 Oct 87 20:28:25-ESTDate: Sun, 25 Oct 87 20:28 ESTMessage-ID: <FAHLMAN.12345425612.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)    Fahlman said he is inclined to support 1-SIGNAL-ERROR over    1-RETURN-OUTER.    All endorse 2-EXIT.I can't reconstruct my earlier opinion on this, but I now favor1-RETURN-INNER.  I think that we should pin this down, rather thanletting it be an "is an error" case that will differ from oneimplementation to another.I also favor 2-EXIT.-- Scott*start*01400 00024 UShReturn-Path: <@SAIL.Stanford.EDU:gls@Think.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 10:52:40 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 26 Oct 87  10:49:45 PSTReturn-Path: <gls@Think.COM>Received: from kali.think.com by Think.COM; Mon, 26 Oct 87 13:49:21 ESTReceived: by kali.think.com; Mon, 26 Oct 87 13:49:43 ESTDate: Mon, 26 Oct 87 13:49:43 ESTFrom: gls@Think.COMMessage-Id: <8710261849.AA06599@kali.think.com>To: Masinter.paCc: cl-cleanup@sail.stanford.edu, Hornig@scrc.symbolics.com, Masinter.paIn-Reply-To: Masinter.pa@xerox.com's message of 24 Oct 87 17:30 PDT <871024-173113-2262@Xerox>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)I will reiterate my support for 1-RETURN-INNER (as well as 2-EXIT).We have here a classic case of the irresistible force (QUIT, dammit!)versus the immovable mountain (UNWIND-PROTECT).  I find that thesuggestion that situation 1 produce an error, but one that IGNORE-ERRORSwon't ignore, to be at least one level of epicycle too many.Which mechanism are to we regard as primitive: the error system or thecatch/throw system?  Or are they disjoint?  I prefer, for simplicity, amodel in which the error system can be explained. as much as possible, as acomplex thing built on top of catch, throw, and unwind-protect.--Guy*start*01831 00024 UShReturn-Path: <@SAIL.Stanford.EDU:Masinter.pa@Xerox.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 12:00:45 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 26 Oct 87  11:56:51 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 26 OCT 87 11:51:01 PSTDate: 26 Oct 87 12:50 PDTFrom: Masinter.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)In-reply-to: Ram@C.CS.CMU.EDU's message of Sun, 25 Oct 87 16:32 ESTTo: Ram@C.CS.CMU.EDUcc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <871026-115101-1826@Xerox>I discarded the "is an error" possibility, not out of hand, but ratherbecause no one argued for it (Moon said in one message that we could"wimp out" and take that option, but it didn't seem like he was favoringit.)I've read your message several times; I think what you are saying isthat you preferRETURN-INNER, RETURN-OUTER, IS-AN-ERROR (not written up), andSIGNAL-ERROR.in that order. Is that a correct reading of your position?I think that your example   (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))is a good one and should be in the proposal: it is a situation whereRETURN-INNER and RETURN-OUTER would have the same behavior; in such asituation, it seems clear that SIGNALS-AN-ERROR seems out of place.Here is another case to consider:(DEFUN UNSTOPPABLE () (UNWIND-PROTECT (LOOP) (UNSTOPPABLE)))Doesn't this have the same "unstoppable" property, completely orthogonalto this issue? I.e., that it cannot be aborted by an asynchronous"interrupt" unless they happen to come in at exactly the right moment?Maybe I should have written it as(labels ((unstoppable () (unwind-protect (loop) (unstoppable))))(unstoppable))*start*03891 00024 USaReturn-Path: <RAM@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 25 OCT 87 13:32:43 PSTReceived: ID <RAM@C.CS.CMU.EDU>; Sun 25 Oct 87 16:32:12-ESTDate: Sun, 25 Oct 87 16:32 ESTMessage-ID: <RAM.12345382618.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)In-reply-to: Msg of 24 Oct 1987  20:30-EDT from Masinter.pa at Xerox.COMI don't see why the "is an error" possibility for case one has beendiscarded out of hand.  The only argument for making this well definedis that it is "in the way of producing a valid portable error system".One could suppose that there are complex, non-obvious, situations inwhich one of RETURN-INNER or RETURN-OUTER is required to implement anerror system.  If this were the case, then we would be forced to makethat choice.  But Moon (I believe) argues that it is quite acceptableto be required to signal an error, and thus SIGNAL-ERROR is presumablynot incompatible with having a portable error system.Moon further went on to argue that the error which is required to besignalled is required not to be handleable.This seems to be a strong indication that "is an error" is in fact thecorrect interpretation.  The language semantics of "an error thatcannot be handled" is indistinguishable from "is an error", since aprogram cannot exploit this distinction.  This is a pure environmentissue.Of course, saying that this condition "is an error" allows all of thesuggested interpretations, and thus means that noone is required to toanything.My presonal preference for a definite semantics of this construct isRETURN-INNER.  This is largely due to the conceptual simplicity that Ias a compiler writer perceive.  The reason I have argued for "is anerror" is that I don't want to be forced to implement any of thealternatives.  I think that people have greatly underestimated the semantic garbagethat this change will load on to lexical exits.  The reason that thisdoesn't bother anyone is that existing Common Lisp implementationsimplement non-local lexical exits on top of dynamic exits, rather thanthe other way around.  It is bogus to suppose that each syntacticallydistinct BLOCK will have a distinct run-time data structure that youcan allocte bits in.If you have a construct like:  (block foo    ...    (block bar      ...))It is not currently required that compilers maintain any distinctionbetween blocks FOO and BAR; those are just different names for thesame continuation.Yet if we fill in the ...'s in this way, then SIGNAL-ERROR preventsthe obvious interpretation of BLOCK as naming a continuation:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))FOO and BAR name exactly the same continuation, but they are somehowmagically gratuitously distinctified simply due to being used fromwithin an unwind-protect.Note that in this test case, the result of RETURN-INNER andRETURN-OUTER are exactly the same.  Although I favor RETURN-INNER,RETURN-OUTER is not nearly as semantically bankrupt as SIGNAL-ERROR,since it doesn't require distinctions to be made between identicalcontinuations.  But I still believe RETURN-OUTER is more difficult to implement thanRETURN-INNER, since it still introduces an innerness/outernessdistinction that is not fundamentally part of a lexical exit.  Insimply naming these proposals RETURN-INNER/RETURN-OUTER, a dynamiccomponent has implicitly been introduced into lexical exit.RETURN-INNER simply ways "use this continuation"; RETURN-OUTER says"maybe use some other continuation depending on some rule of dynamicscoping that is otherwise totally irrelevant to the semantics ofRETURN-FROM unless there is an UNWIND-PROTECT around somewhere".  Rob*start*01673 00024 UShReturn-Path: <RAM@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 26 OCT 87 16:16:58 PSTReceived: ID <RAM@C.CS.CMU.EDU>; Mon 26 Oct 87 19:16:29-ESTDate: Mon, 26 Oct 87 19:16 ESTMessage-ID: <RAM.12345674667.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)In-reply-to: Msg of 26 Oct 1987  14:50-EST from Masinter.pa at Xerox.COM    Date: Monday, 26 October 1987  14:50-EST    From: Masinter.pa at Xerox.COM    To:   Ram at C.CS.CMU.EDU    Re:   Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 2)    I've read your message several times; I think what you are saying is    that you prefer    RETURN-INNER, RETURN-OUTER, IS-AN-ERROR (not written up), and    SIGNAL-ERROR.Actually, I favor IS-AN-ERROR over RETURN-OUTER, since it would allowme to implement RETURN-INNER.  If I was writing an error system, Imight be more concerned about making this rigorously defined.    Here is another case to consider:    (DEFUN UNSTOPPABLE () (UNWIND-PROTECT (LOOP) (UNSTOPPABLE)))    Doesn't this have the same "unstoppable" property, completely orthogonal    to this issue? I.e., that it cannot be aborted by an asynchronous    "interrupt" unless they happen to come in at exactly the right moment?Yep.  That's real interesting.  I suppose one could argue that itisn't so important to prevent people from screwing themselves thisway, since real men don't write recursive functions.  I see this asdemonstrating a fundamental property of UNWIND-PROTECT: it allowstransfer of control to be usurped.  Rob*start*09269 00024 UShDate: 27 Oct 87 14:50 PSTFrom: Masinter.paSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)To: cl-cleanup@Sail.stanford.edu, Hornig@SCRC.Symbolics.COMLine-fold: 80cc: Masinter.paI've rewritten this to include only the 2-EXIT, 1-RETURN-INNER combination, naming it CONTINUATION-MODEL.Is this ready for release?Issue:          UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITReferences:     UNWIND-PROTECT (p140, p142, p39)                Issue IGNORE-ERRORS, Draft error proposal.Category:       CLARIFICATION/CHANGEEdit history:   Version 1 by Pitman   27-Feb-87                Version 2 by Masinter 24-Oct-87                Version 3 by Masinter 27-Oct-87Problem Description:If a non-local return is done while in the cleanup form of an UNWIND-PROTECT, the behavior is not always well-defined.There are three basic cases:Situation 0. Transfer to another point within the cleanup form.   (UNWIND-PROTECT 3 (BLOCK NIL (RETURN 4)) (PRINT 'XXX))There is no ambiguity about how this form is to be interpreted.Effectively:       . 3 evaluates to itself, which is queued for return        from the UNWIND-PROTECT.       . The BLOCK expression is entered, 4 is returned to	it and discarded because this is a not-for-value 	situation.      . XXX is printed, XXX is returned by the PRINT and	that value is discarded because this is a not-for-value	situation.      . The 3 which was yielded earlier is retrieved and	returned as the value of the UNWIND-PROTECT.Situation 1. Transfer to a point inside the point to which control     would have transferred.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found within the scope of the target of the       pending THROW (to FOO).Situation 2. Transfer to a point outside the point to which return would    already have been. For example:    (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW (to FOO).What is the appropriate behavior for situation 1 and situation 2 and similar ones? For example, suppose that when WITH-OPEN-FILE tries to close the file upon unwinding, it signals an error, and the condition handler also attempts to throw? The question applies to all non-local transfers, whether performed by THROW, RETURN-FROM, RETURN, GO.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:CONTINUATION-MODEL):In all cases, a transfer of control within an UNWIND-PROTECT cleanup form to a point outside of the UNWIND-PROTECT causes the original control transfer which initialed the execution of the cleanup forms to be abandonded.During the execution of the cleanup forms of an UNWIND-PROTECT a non-local exit to a point outside of the scope of the UNWIND-PROTECT, but still within the dynamic scope of of the target of the original non-local exit succeeds, and the original pending exit is discarded. For example, in Situation 1, the pending seek for tag FOO is discarded by the second THROW to BAR and the value 4 is transfered to (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...) then returns the 4 because its first argument has returned normally. XXX is not printed.Where an UNWIND-PROTECT cleanup form attempts a non-local exit to a point outside the original non-local exit, control is passed to the outer exit (and the pending original non-local exit is discarded.) For example, in Situation 2, the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.In no case will UNWIND-PROTECT cleanup forms ever be attempted more than once.Rationale:Current Practice:Some implementations generate garbage code in situations 1 and 2.  Some have differing behavior compiled and interpreted.Most that have implementations seem to implement the proposed semantics for situation 2, but there is some divergence in Situation 1. For example, Spice Lisp and Xerox implement the proposed semantics, while Symbolics Common Lisp signals an error.Adoption Cost:While require some compiler modifications in some implementations, in most cases, that work was in order anyway since compilers may currently be doing nothing particularly useful or defensible with the code in question. Benefits:Having this situation uniformly treated seems critical:Programs that do this accidentally should behave the same on all systems so that bugs can be detected and fixed very early rather than being found later on a system which disagrees.Programs that do this on purpose generally are trying to do something fairly intricate and really need to be able to depend on it being uniformly treated. A portable error/signal system and debugger may be among these. For example, one programmer created his own "top level", to which the system "abort" character would return, by doing: (DEFUN MY-TOPLEVEL ()   (TAGBODY LOOP (UNWIND-PROTECT (REALLY-MY-TOPLEVEL)			      (GO LOOP))))Aesthetics:This proposal is more intuitive to programmers who reason about programs in terms of continuation passing. It falls out of the normal scoping rules as a consequence of the fact that the cleaup code is evaluated in the lexical and dynamic environment in which the UNWIND-PROTECT form appears. The action of THROW is usefully described by saying that it is just like any other function. It happens to discard the current continuation,  run some cleanup things (like variable unbindings and UNWIND-PROTECT actions), and transfer control elsewhere in the program. In doing so, the function uses data structure primitives not generally available to other programs, but it is not linguistically different and receives no special exemption with regard to THROWs or other non-local transfers of control done within its execution. A THROW from within an UNWIND-PROTECT cleanup is not different than one in any other code; it discards the ongoing action (stack unwinding) and replaces it by another action (as it happens, another stack unwinding). The previous unwind is never resumed.Conversion Cost:Most user programs don't do this so the cost of converting existing code is probably minimal. (There is some evidence that there are programs that expect this behavior, so there is no conversion cost for those programs.)Discussion:Two alternatives for situation 2 were seriously considered: that it should signal an error, and that it the second non-local exit instead continues the original (more extensive) one; e.g., in Situation 1, the second THROW to BAR would be discarded in lieu of continuing the THROW to FOO.Either of these alternatives would help prevent users from (either intentionally or unintentionally) creating situations where it is impossible to abort a computation with a THROW or other non-local return (e.g., an interrupt implemented via THROW.)For example,  given  (LOOP    (CATCH 'FOO      (UNWIND-PROTECT (LOOP)        (THROW 'FOO T))))With this proposal there is no way of exiting such a form. Signalling an error would prevent programmers from getting into this unfortunate situation.However, similar "unstoppable" loops can be created, without resorting to non-nested non-local transfers within UNWIND-PROTECT clauses; for example:(LABELS ((HA () (UNWIND-PROTECT (LOOP) (HA)))) (HA))While it would be for a programmer to accidentally create such an unstoppable loop, the user has pretty clearly asked to have a loop that cannot be exited and deserves to have that request carried out.One implication is that it is likely that programming environments need to provide some mechanism other than THROW to stop a truly run-away computation.An interesting example which supports this proposal is one where there are two BLOCKs   (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangably, signalling an error in this situation would be inappropriate.         TITAN           TITAN          
TIMESROMAN 
          S              &              \                                         

       F                                              u                     
                   6                                        B             U      " !z*start*00892 00024 UShReturn-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 27 OCT 87 17:41:14 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 27 Oct 87 20:40:53-ESTDate: Tue, 27 Oct 87 20:40 ESTMessage-ID: <FAHLMAN.12345952172.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Masinter.paSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)In-reply-to: Msg of 27 Oct 1987  17:50-EST from Masinter.pa at Xerox.COMLooks good to me.  The only thing that might be a bit confusing is thistalk of whether you can or cannot abort a loop by THROW.  I understoodthis, but casual readers may not realize that we are referring here tosome asynchronous event that would initiate a throw to top-level.  Thenagain, maybe the readers of this proposal will all catch the intendedmeaning as it is.-- Scott*start*00502 00024 UShDate: 27 Oct 87 19:01 PSTFrom: Daniels.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)In-reply-to: Masinter.pa's message of 27 Oct 87 14:50 PSTTo: Masinter.pacc: cl-cleanup@Sail.stanford.eduIn the first paragraph of the proposal proper, "...the original control transfer which initialed the execution..." should read "...the original control transfer which initiated the execution..."Otherwise, I'm reasonably satisfied with it.		-- Andy. --*start*01198 00024 UShReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 28 OCT 87 13:22:20 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 266202; Wed 28-Oct-87 16:23:03 ESTDate: Wed, 28 Oct 87 16:21 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)To: Masinter.pacc: CL-Cleanup@SAIL.Stanford.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COM, Hornig@ALDERAAN.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <871027-145108-1674@Xerox>Message-ID: <871028162111.3.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Version 3 of the UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT writeup is incomplete.It lacks a rationale. Version 1 had a rationale which you might be able toresurrect.Version 3 also seems to have lost the endorsement summary. I hope it will bereplaced before presentation to the committee.Modulo these minor issues, I support the CONTINUATION-MODEL proposal as stated.It takes the position I had endorsed when I originally introduced this issue.*start*01972 00024 UShReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 11:55:57 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 8 Nov 87  11:54:32 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 274779; Sun 8-Nov-87 14:54:19 ESTDate: Sun, 8 Nov 87 14:54 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)To: cl-cleanup@SAIL.STANFORD.EDU, Hornig@SCRC.Symbolics.COMIn-Reply-To: <871027-145108-1674@Xerox>Message-ID: <19871108195430.3.MOON@EUPHRATES.SCRC.Symbolics.COM>I don't think this issue is nearly ready for release, for two reasons:(1) The discussion appears to have been thoroughly garbled duringediting.  KMP pointed out some problems in his message of 28 October,but I noticed several more while reading it just now.  I could provideline-by-line commentary if requested, but I'm not sure that's the bestuse of limited time right now.(2) Of the several alternative proposals for this issue, the only onethat seemed appropriate to me has been removed.  After re-reading the12 messages on the topic that I thought were worth saving, I get thefeeling that the issues have not really been clarified and that thediscussion is largely dealing with strawmen.  It seems like thecleanup committee is heading towards making a serious mistake here.I could spend several hours now rearguing the same arguments I made lastspring, hopefully putting more care and clarity into them so that morepeople would be convinced.  It's a subtle issue that's hard to thinkabout and I'm sure my past comments on it have not been asunderstandable as they ought to be.  However, again this issue seemslike a waste of time right now.  I'd rather concentrate on cleanupissues that are closer to agreement.*start*01443 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 NOV 87 17:14:00 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 9 Nov 87  17:11:07 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 275890; Mon 9-Nov-87 20:02:03 ESTDate: Mon, 9 Nov 87 20:01 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUcc: Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COM, Hornig@ALDERAAN.SCRC.Symbolics.COMIn-Reply-To: <19871108195430.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <871109200150.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Although I agree with the proposal as stated, I feel very strongly(partly out of empathy from previous situations where I've beenoutnumbered on issues) that if he wants equal, unbiased space, heshould get it.At the very least, we can remove a number of the proposal variantsthat have no champions.Perhaps Moon and I can draft a balanced proposal expressing bothpoints of view, but I doubt it can be done before this meeting.And I agree with him that it's not a good idea to push on thiscomplicated issue at this late date if we aren't very close toagreement on the presentation.*start*02381 00024 UShReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 NOV 87 12:23:05 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 10 Nov 87  12:19:48 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 10 NOV 87 12:18:43 PSTDate: 10 Nov 87 12:18 PSTFrom: Masinter.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 9 Nov 87 20:01 ESTTo: CL-Cleanup@SAIL.Stanford.EDU, Moon@STONY-BROOK.SCRC.Symbolics.COM, Hornig@ALDERAAN.SCRC.Symbolics.COMMessage-ID: <871110-121843-5449@Xerox>Well, in my attempt to summarize the discussion, I apparently botchedit. In re-reading it, I don't think I did justice to the summary of thealternative view. However, despite a number of editing errors andtypo's, I think "thoroughly garbled" is a bit strong.The reason there is no text under the Rationale heading is that the textthat occured in version 1 was  moved into the discussion and aestheticsections. I agree the proposals read better if the Rationale headerincludes a summary of what is to come. I would summarize the Rationaleis that this is the simplest and most consistent of the alternativesconsidered.  The endorsement summary was removed because enougharguments and new evidence and test cases had arisen that it would havebeen presumptuous to copy an endorsement from a previous proposal into arewriting.I did review all of the mail before preparing the latest version. I readcarefully David's original arguments and the responses. I don't see anyneed to reiterate them, but it would be useful to respond to theadditional comments which were posted since. In particular,  theoriginal argument (unless this is an error, it is possible to constructnon-abortable loops) had two serious rebuttals (independent of thisissue, it is possible to construct non-abortable loops; sometimes users*want* to create non-abortable loops). I agree to postpone this issue for the next round; if anyone would likea copy of the previous mail on the topic (I have about 25 messagessaved) let me know and I'll make it available.The mail I have says that Pitman, Daniels, Fahlman, Ram, Steele (andmyself) support the current proposal (modulo a few minor edits). *start*11878 00024 USfDate: 13 Feb 88 17:12 PSTFrom: Masinter.paSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)To: cl-cleanup@Sail.stanford.edu, Hornig@SCRC.Symbolics.COMLine-fold: 80cc: Masinter.paAs this issue is somewhat controversial, it is not for inclusion in the mailing. I tried to at least go back and extract what I thought were David's previous arguments about this proposal and include them in the discussion section. Its been almost a year now since this was first brought up... we should get some closure soon.Issue:          UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITReferences:     UNWIND-PROTECT (p140, p142, p39)                Issue IGNORE-ERRORS, Draft error proposal.Category:       CLARIFICATION/CHANGEEdit history:   Version 1 by Pitman   27-Feb-87                Version 2 by Masinter 24-Oct-87                Version 3 by Masinter 27-Oct-87                Version 4 by Masinter 13-Feb-88Problem Description:If a non-local return is done while in the cleanup form of an UNWIND-PROTECT, the behavior is not always well-defined.There are three basic cases:Situation 0. Transfer to another point within the cleanup form.   (UNWIND-PROTECT 3 (BLOCK NIL (RETURN 4)) (PRINT 'XXX))There is no ambiguity about how this form is to be interpreted.Effectively:       . 3 evaluates to itself, which is queued for return        from the UNWIND-PROTECT.       . The BLOCK expression is entered, 4 is returned to	it and discarded because this is a not-for-value 	situation.      . XXX is printed, XXX is returned by the PRINT and	that value is discarded because this is a not-for-value	situation.      . The 3 which was yielded earlier is retrieved and	returned as the value of the UNWIND-PROTECT.Situation 1. Transfer to a point inside the point to which control     would have transferred.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found within the scope of the target of the       pending THROW (to FOO).Situation 2. Transfer to a point outside the point to which return would    already have been. For example:    (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW (to FOO).What is the appropriate behavior for situation 1 and situation 2 and similar ones? For example, suppose that when WITH-OPEN-FILE tries to close the file upon unwinding, it signals an error, and the condition handler also attempts to throw? The question applies to all non-local transfers, whether performed by THROW, RETURN-FROM, RETURN, GO.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:CONTINUATION-MODEL):In all cases, a transfer of control within an UNWIND-PROTECT cleanup form to a point outside of the UNWIND-PROTECT causes the original control transfer which initiated the execution of the cleanup forms to be abandonded.During the execution of the cleanup forms of an UNWIND-PROTECT a non-local exit to a point outside of the scope of the UNWIND-PROTECT, but still within the dynamic scope of of the target of the original non-local exit succeeds, and the original pending exit is discarded. For example, in Situation 1, the pending seek for tag FOO is discarded by the second THROW to BAR and the value 4 is transfered to (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...) then returns the 4 because its first argument has returned normally. XXX is not printed.Where an UNWIND-PROTECT cleanup form attempts a non-local exit to a point outside the original non-local exit, control is passed to the outer exit (and the pending original non-local exit is discarded.) For example, in Situation 2, the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.In no case will UNWIND-PROTECT cleanup forms ever be attempted more than once.Rationale:The primary issues have to do with the safety of the language vs. the uniformity of the model behind non-local transfer of control.Current Practice:Some implementations generate garbage code in situations 1 and 2.  Some have differing behavior compiled and interpreted.Most that have implementations seem to implement the proposed semantics for situation 2, but there is some divergence in Situation 1. For example, Spice Lisp and Xerox implement the proposed semantics, while Symbolics Common Lisp signals an error.Adoption Cost:While require some compiler modifications in some implementations, in most cases, that work was in order anyway since compilers may currently be doing nothing particularly useful or defensible with the code in question. Benefits:Having this situation uniformly treated seems critical:Programs that do this accidentally should behave the same on all systems so that bugs can be detected and fixed very early rather than being found later on a system which disagrees.Programs that do this on purpose generally are trying to do something fairly intricate and really need to be able to depend on it being uniformly treated. A portable error/signal system and debugger may be among these. For example, one programmer created his own "top level", to which the system "abort" character would return, by doing: (DEFUN MY-TOPLEVEL ()   (TAGBODY LOOP (UNWIND-PROTECT (REALLY-MY-TOPLEVEL)			      (GO LOOP))))Aesthetics:This proposal is more intuitive to programmers who reason about programs in terms of continuation passing. It falls out of the normal scoping rules as a consequence of the fact that the cleaup code is evaluated in the lexical and dynamic environment in which the UNWIND-PROTECT form appears. The action of THROW is usefully described by saying that it is just like any other function. It happens to discard the current continuation,  run some cleanup things (like variable unbindings and UNWIND-PROTECT actions), and transfer control elsewhere in the program. In doing so, the function uses data structure primitives not generally available to other programs, but it is not linguistically different and receives no special exemption with regard to THROWs or other non-local transfers of control done within its execution. A THROW from within an UNWIND-PROTECT cleanup is not different than one in any other code; it discards the ongoing action (stack unwinding) and replaces it by another action (as it happens, another stack unwinding). The previous unwind is never resumed.Conversion Cost:Most user programs don't do this so the cost of converting existing code is probably minimal. (There is some evidence that there are programs that expect this behavior, so there is no conversion cost for those programs.)Discussion:Two alternatives for situation 2 were seriously considered: that it should signal an error, and that it the second non-local exit instead continues the original (more extensive) one; e.g., in Situation 1, the second THROW to BAR would be discarded in lieu of continuing the THROW to FOO.Either of these alternatives would help prevent users from (either intentionally or unintentionally) creating situations where it is impossible to abort a computation with a THROW or other non-local return (e.g., an interrupt implemented via THROW.)For example,  given  (LOOP    (CATCH 'FOO      (UNWIND-PROTECT (LOOP)        (THROW 'FOO T))))With this proposal there is no way of exiting such a form. Signalling an error would prevent programmers from getting into this unfortunate situation.However, similar "unstoppable" loops can be created, without resorting to non-nested non-local transfers within UNWIND-PROTECT clauses; for example:(LABELS ((HA () (UNWIND-PROTECT (LOOP) (HA)))) (HA))While it would be for a programmer to accidentally create such an unstoppable loop, the user has pretty clearly asked to have a loop that cannot be exited and deserves to have that request carried out.One implication is that it is likely that programming environments need to provide some mechanism other than THROW to stop a truly run-away computation.An interesting example which supports this proposal is one where there are two BLOCKs   (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangably, signalling an error in this situation would be inappropriate. To quote Guy Steele:"We have here a classic case of the irresistible force (QUIT, dammit!)versus the immovable mountain (UNWIND-PROTECT).  I find that thesuggestion that situation 1 produce an error, but one that IGNORE-ERRORSwon't ignore, to be at least one level of epicycle too many.Which mechanism are to we regard as primitive: the error system or thecatch/throw system?  Or are they disjoint?  I prefer, for simplicity, amodel in which the error system can be explained. as much as possible, as acomplex thing built on top of catch, throw, and unwind-protect."David Moon says:"Of the several alternative proposals for this issue, the only onethat seemed appropriate to me has been removed. After re-reading the12 messages on the topic that I thought were worth saving, I get thefeeling that the issues have not really been clarified and that thediscussion is largely dealing with strawmen.  It seems like thecleanup committee is heading towards making a serious mistake here.Consider the form  (loop    (catch 'foo      (unwind-protect (loop)        (throw 'foo t))))With the proposed semantics, it is impossible to stop this programexcept by hitting it with two throws in rapid succession, with exactlythe right amount of delay between them so that the catch andunwind-protect have not yet been re-established when the second throwstrikes.  Consider any program-stopping operation that aborts executionby throwing to a catch in the top-level read-eval-print loop (control-Gin Maclisp or c-Abort in Genera; most other systems have their ownequivalent of this).  With the proposed semantics, when this throwexecutes the unwind-protect cleanup handler, as it must, the throw willbe abandoned and execution will resume looping.To me, the inability to stop a program is a much worse problem thanproviding so-called correct semantics for a contrived program thatdoesn't correspond to any real application.  It was suggested that theerror system might depend on the ability to abort throws like this.  Ifthat were demonstrated, I would change my tune, but until it'sdemonstrated I am completely skeptical of the notion that any errorsystem would do this."        TITAN           TITAN          
TIMESROMAN 
          
TIMESROMAN 
                        &              \                                         

       F                                              u                     
                   6                                        B             S            , "z*start*00287 00024 US Date: Sat, 13 Feb 88 17:58:11 PSTFrom: Pavel.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)In-reply-to: <880213-171305-10510@Xerox>To: MasinterTypo:``While it would be for a programmer to accidentally create'' has a missing word.*start*01588 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 FEB 88 18:10:27 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Feb 88  18:08:15 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 13 FEB 88 18:07:49 PSTDate: Sat, 13 Feb 88 18:07:23 PSTFrom: Pavel.paSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 3)In-reply-to: <880213-171305-10510@Xerox>To: cl-cleanup@Sail.stanford.edu, Hornig@SCRC.Symbolics.COMMessage-ID: <880213-180749-10547@Xerox>With reference to Moon's objections to the given proposal, namely that he wantsa way within his environment to interrupt any loop, no matter how perverselydefined, I remain unconvinced that this is really a language issue.  Since thelanguage does not specify any relationship between user actions (such as pushingsome magic key on the keyboard) and a linguistic effect (such as performing somethrow or other non-local transfer), I cannot accept this argument at thelinguistic level.  If you really want this facility in your environment, thenadd another operation to the abstract machine of the implementation, a THROWthat can't be overridden by any ``nested'' THROW.  Your debugger or whatever canthen be implemented in terms of that (when appropriate) and the languagedefinition remains clean.I remain strongly in favor of this proposal; it seems to me to have awonderfully simple semantics, easily understood and eassily incorporated intothe programmer's mental model.	Pavel*start*12042 00024 USfDate: 23 May 88 13:35 PDTFrom: masinter.paSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)To: cl-cleanup@sail.stanford.educc: MasinterMy notes from the subcommittee meeting that I broadcast  21 March were that "JonL and Moon have comments. Moon has a description of stack model and unwind as atomic."  Through the fuzz of time I'm no longer sure what I meant by that (much less what David meant.)I'd like to get this one out of committee, in whatever form is necessary.Issue:          UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITReferences:     UNWIND-PROTECT (p140, p142, p39)                Issue IGNORE-ERRORS, Draft error proposal.Category:       CLARIFICATION/CHANGEEdit history:   Version 1 by Pitman   27-Feb-87                Version 2 by Masinter 24-Oct-87                Version 3 by Masinter 27-Oct-87                Version 4 by Masinter 13-Feb-88                Version 5 by Masinter 23-May-88Problem Description:If a non-local return is done while in the cleanup form of an UNWIND-PROTECT, the behavior is not always well-defined.There are three basic cases:Situation 0. Transfer to another point within the cleanup form.   (UNWIND-PROTECT 3 (BLOCK NIL (RETURN 4)) (PRINT 'XXX))There is no ambiguity about how this form is to be interpreted.Effectively:       . 3 evaluates to itself, which is queued for return        from the UNWIND-PROTECT.       . The BLOCK expression is entered, 4 is returned to	it and discarded because this is a not-for-value 	situation.      . XXX is printed, XXX is returned by the PRINT and	that value is discarded because this is a not-for-value	situation.      . The 3 which was yielded earlier is retrieved and	returned as the value of the UNWIND-PROTECT.Situation 1. Transfer to a point inside the point to which control     would have transferred.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found within the scope of the target of the       pending THROW (to FOO).Situation 2. Transfer to a point outside the point to which return would    already have been. For example:    (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW (to FOO).What is the appropriate behavior for situation 1 and situation 2 and similar ones? For example, suppose that when WITH-OPEN-FILE tries to close the file upon unwinding, it signals an error, and the condition handler also attempts to throw? The question applies to all non-local transfers, whether performed by THROW, RETURN-FROM, RETURN, GO.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:CONTINUATION-MODEL):In all cases, a transfer of control within an UNWIND-PROTECT cleanup form to a point outside of the UNWIND-PROTECT causes the original control transfer which initiated the execution of the cleanup forms to be abandonded.During the execution of the cleanup forms of an UNWIND-PROTECT a non-local exit to a point outside of the scope of the UNWIND-PROTECT, but still within the dynamic scope of of the target of the original non-local exit succeeds, and the original pending exit is discarded. For example, in Situation 1, the pending seek for tag FOO is discarded by the second THROW to BAR and the value 4 is transfered to (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...) then returns the 4 because its first argument has returned normally. XXX is not printed.Where an UNWIND-PROTECT cleanup form attempts a non-local exit to a point outside the original non-local exit, control is passed to the outer exit (and the pending original non-local exit is discarded.) For example, in Situation 2, the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.In no case will UNWIND-PROTECT cleanup forms ever be attempted more than once.Rationale:The primary issues have to do with the safety of the language vs. the uniformity of the model behind non-local transfer of control.Current Practice:Some implementations generate garbage code in situations 1 and 2.  Some have differing behavior compiled and interpreted.Most that have implementations seem to implement the proposed semantics for situation 2, but there is some divergence in Situation 1. For example, Spice Lisp and Xerox implement the proposed semantics, while Symbolics Common Lisp signals an error.Cost to Implementors:While require some compiler modifications in some implementations, in most cases, that work was in order anyway since compilers may currently be doing nothing particularly useful or defensible with the code in question. Cost to Users:Most user programs don't do this so the cost of converting existing code is probably minimal. (There is some evidence that there are programs that expect this behavior, so there is no conversion cost for those programs.)Benefits:Having this situation uniformly treated seems critical:Programs that do this accidentally should behave the same on all systems so that bugs can be detected and fixed very early rather than being found later on a system which disagrees.Programs that do this on purpose generally are trying to do something fairly intricate and really need to be able to depend on it being uniformly treated. A portable error/signal system and debugger may be among these. For example, one programmer created his own "top level", to which the system "abort" character would return, by doing: (DEFUN MY-TOPLEVEL ()   (TAGBODY LOOP (UNWIND-PROTECT (REALLY-MY-TOPLEVEL)			      (GO LOOP))))Aesthetics:This proposal is more intuitive to programmers who reason about programs in terms of continuation passing. It falls out of the normal scoping rules as a consequence of the fact that the cleaup code is evaluated in the lexical and dynamic environment in which the UNWIND-PROTECT form appears. The action of THROW is usefully described by saying that it is just like any other function. It happens to discard the current continuation,  run some cleanup things (like variable unbindings and UNWIND-PROTECT actions), and transfer control elsewhere in the program. In doing so, the function uses data structure primitives not generally available to other programs, but it is not linguistically different and receives no special exemption with regard to THROWs or other non-local transfers of control done within its execution. A THROW from within an UNWIND-PROTECT cleanup is not different than one in any other code; it discards the ongoing action (stack unwinding) and replaces it by another action (as it happens, another stack unwinding). The previous unwind is never resumed.Discussion:This issue is controversial. While the proposal included here hada number of strong endorsements, there were also some strenuous objections. Two alternatives for situation 2 were seriously considered: that it should signal an error, and that it the second non-local exit instead continues the original (more extensive) one; e.g., in Situation 1, the second THROW to BAR would be discarded in lieu of continuing the THROW to FOO.Either of these alternatives would help prevent users from (either intentionally or unintentionally) creating situations where it is impossible to abort a computation with a THROW or other non-local return (e.g., an interrupt implemented via THROW.)For example,  given  (LOOP    (CATCH 'FOO      (UNWIND-PROTECT (LOOP ... )        (THROW 'FOO T))))With this proposal there is no way of exiting such a form. Signalling an error would prevent programmers from getting into this unfortunate situation.However, similar "unstoppable" loops can be created, without resorting to non-nested non-local transfers within UNWIND-PROTECT clauses; for example:(LABELS ((HA () (UNWIND-PROTECT (LOOP) (HA)))) (HA))While it would be unfortunate for a programmer to accidentally create such an unstoppable loop, the user has pretty clearly asked to have a loop that cannot be exited and deserves to have that request carried out.One implication is that it is likely that programming environments need to provide some mechanism other than THROW to stop a truly run-away computation.An interesting example which supports this proposal is one where there are two BLOCKs   (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangably, signalling an error in this situation would be inappropriate. Guy Steele:"We have here a classic case of the irresistible force (QUIT, dammit!)versus the immovable mountain (UNWIND-PROTECT).  I find that thesuggestion that situation 1 produce an error, but one that IGNORE-ERRORSwon't ignore, to be at least one level of epicycle too many.Which mechanism are to we regard as primitive: the error system or thecatch/throw system?  Or are they disjoint?  I prefer, for simplicity, amodel in which the error system can be explained. as much as possible, as acomplex thing built on top of catch, throw, and unwind-protect."David Moon:"Of the several alternative proposals for this issue, the only onethat seemed appropriate to me has been removed. After re-reading the12 messages on the topic that I thought were worth saving, I get thefeeling that the issues have not really been clarified and that thediscussion is largely dealing with strawmen.  It seems like thecleanup committee is heading towards making a serious mistake here.Consider the form  (loop    (catch 'foo      (unwind-protect (loop)        (throw 'foo t))))With the proposed semantics, it is impossible to stop this programexcept by hitting it with two throws in rapid succession, with exactlythe right amount of delay between them so that the catch andunwind-protect have not yet been re-established when the second throwstrikes.  Consider any program-stopping operation that aborts executionby throwing to a catch in the top-level read-eval-print loop (control-Gin Maclisp or c-Abort in Genera; most other systems have their ownequivalent of this).  With the proposed semantics, when this throwexecutes the unwind-protect cleanup handler, as it must, the throw willbe abandoned and execution will resume looping.To me, the inability to stop a program is a much worse problem thanproviding so-called correct semantics for a contrived program thatdoesn't correspond to any real application.  It was suggested that theerror system might depend on the ability to abort throws like this.  Ifthat were demonstrated, I would change my tune, but until it'sdemonstrated I am completely skeptical of the notion that any errorsystem would do this."        TITAN           TITAN          
TIMESROMAN 
          
TIMESROMAN 
                               &              \                                         

       F                                              u                                   
                   6                          R                   -Z "z*start*11984 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAY 88 13:42:31 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 May 88  13:39:54 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 MAY 88 13:35:28 PDTDate: 23 May 88 13:35 PDTFrom: masinter.paSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)To: cl-cleanup@sail.stanford.educc: Masinter.paMessage-ID: <880523-133528-5237@Xerox>My notes from the subcommittee meeting that I broadcast  21 March were that"JonL and Moon have comments. Moon has a description of stack model and unwindas atomic."  Through the fuzz of time I'm no longer sure what I meant by that(much less what David meant.)I'd like to get this one out of committee, in whatever form is necessary.!Issue:          UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITReferences:     UNWIND-PROTECT (p140, p142, p39)                Issue IGNORE-ERRORS, Draft error proposal.Category:       CLARIFICATION/CHANGEEdit history:   Version 1 by Pitman   27-Feb-87                Version 2 by Masinter 24-Oct-87                Version 3 by Masinter 27-Oct-87                Version 4 by Masinter 13-Feb-88                Version 5 by Masinter 23-May-88Problem Description:If a non-local return is done while in the cleanup form of an UNWIND-PROTECT,the behavior is not always well-defined.There are three basic cases:Situation 0. Transfer to another point within the cleanup form.   (UNWIND-PROTECT 3 (BLOCK NIL (RETURN 4)) (PRINT 'XXX))There is no ambiguity about how this form is to be interpreted.Effectively:       . 3 evaluates to itself, which is queued for return        from the UNWIND-PROTECT.       . The BLOCK expression is entered, 4 is returned to	it and discarded because this is a not-for-value 	situation.      . XXX is printed, XXX is returned by the PRINT and	that value is discarded because this is a not-for-value	situation.      . The 3 which was yielded earlier is retrieved and	returned as the value of the UNWIND-PROTECT.Situation 1. Transfer to a point inside the point to which control     would have transferred.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found within the scope of the target of the       pending THROW (to FOO).Situation 2. Transfer to a point outside the point to which return would    already have been. For example:    (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW (to FOO).What is the appropriate behavior for situation 1 and situation 2 and similarones? For example, suppose that when WITH-OPEN-FILE tries to close the file uponunwinding, it signals an error, and the condition handler also attempts tothrow? The question applies to all non-local transfers, whether performed byTHROW, RETURN-FROM, RETURN, GO.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:CONTINUATION-MODEL):In all cases, a transfer of control within an UNWIND-PROTECT cleanup form to apoint outside of the UNWIND-PROTECT causes the original control transfer whichinitiated the execution of the cleanup forms to be abandonded.During the execution of the cleanup forms of an UNWIND-PROTECT a non-local exitto a point outside of the scope of the UNWIND-PROTECT, but still within thedynamic scope of of the target of the original non-local exit succeeds, and theoriginal pending exit is discarded. For example, in Situation 1, the pendingseek for tag FOO is discarded by the second THROW to BAR and the value 4 istransfered to (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...) thenreturns the 4 because its first argument has returned normally. XXX is notprinted.Where an UNWIND-PROTECT cleanup form attempts a non-local exit to a pointoutside the original non-local exit, control is passed to the outer exit (andthe pending original non-local exit is discarded.) For example, in Situation 2,the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.In no case will UNWIND-PROTECT cleanup forms ever be attempted more than once.Rationale:The primary issues have to do with the safety of the language vs. the uniformityof the model behind non-local transfer of control.Current Practice:Some implementations generate garbage code in situations 1 and 2.  Some havediffering behavior compiled and interpreted.Most that have implementations seem to implement the proposed semantics forsituation 2, but there is some divergence in Situation 1. For example, SpiceLisp and Xerox implement the proposed semantics, while Symbolics Common Lispsignals an error.Cost to Implementors:While require some compiler modifications in some implementations, in mostcases, that work was in order anyway since compilers may currently be doingnothing particularly useful or defensible with the code in question. Cost to Users:Most user programs don't do this so the cost of converting existing code isprobably minimal. (There is some evidence that there are programs that expectthis behavior, so there is no conversion cost for those programs.)Benefits:Having this situation uniformly treated seems critical:Programs that do this accidentally should behave the same on all systems so thatbugs can be detected and fixed very early rather than being found later on asystem which disagrees.Programs that do this on purpose generally are trying to do something fairlyintricate and really need to be able to depend on it being uniformly treated. Aportable error/signal system and debugger may be among these. For example, oneprogrammer created his own "top level", to which the system "abort" characterwould return, by doing: (DEFUN MY-TOPLEVEL ()   (TAGBODY LOOP (UNWIND-PROTECT (REALLY-MY-TOPLEVEL)			      (GO LOOP))))Aesthetics:This proposal is more intuitive to programmers who reason about programs interms of continuation passing. It falls out of the normal scoping rules as aconsequence of the fact that the cleaup code is evaluated in the lexical anddynamic environment in which the UNWIND-PROTECT form appears. The action ofTHROW is usefully described by saying that it is just like any other function.It happens to discard the current continuation,  run some cleanup things (likevariable unbindings and UNWIND-PROTECT actions), and transfer control elsewherein the program. In doing so, the function uses data structure primitives notgenerally available to other programs, but it is not linguistically differentand receives no special exemption with regard to THROWs or other non-localtransfers of control done within its execution. A THROW from within anUNWIND-PROTECT cleanup is not different than one in any other code; it discardsthe ongoing action (stack unwinding) and replaces it by another action (as ithappens, another stack unwinding). The previous unwind is never resumed.Discussion:This issue is controversial. While the proposal included here hada number of strong endorsements, there were also some strenuous objections. Two alternatives for situation 2 were seriously considered: that it shouldsignal an error, and that it the second non-local exit instead continues theoriginal (more extensive) one; e.g., in Situation 1, the second THROW to BARwould be discarded in lieu of continuing the THROW to FOO.Either of these alternatives would help prevent users from (either intentionallyor unintentionally) creating situations where it is impossible to abort acomputation with a THROW or other non-local return (e.g., an interruptimplemented via THROW.)For example,  given  (LOOP    (CATCH 'FOO      (UNWIND-PROTECT (LOOP ... )        (THROW 'FOO T))))With this proposal there is no way of exiting such a form. Signalling an errorwould prevent programmers from getting into this unfortunate situation.However, similar "unstoppable" loops can be created, without resorting tonon-nested non-local transfers within UNWIND-PROTECT clauses; for example:(LABELS ((HA () (UNWIND-PROTECT (LOOP) (HA)))) (HA))While it would be unfortunate for a programmer to accidentally create such anunstoppable loop, the user has pretty clearly asked to have a loop that cannotbe exited and deserves to have that request carried out.One implication is that it is likely that programming environments need toprovide some mechanism other than THROW to stop a truly run-away computation.An interesting example which supports this proposal is one where there are twoBLOCKs   (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangably,signalling an error in this situation would be inappropriate. Guy Steele:"We have here a classic case of the irresistible force (QUIT, dammit!)versus the immovable mountain (UNWIND-PROTECT).  I find that thesuggestion that situation 1 produce an error, but one that IGNORE-ERRORSwon't ignore, to be at least one level of epicycle too many.Which mechanism are to we regard as primitive: the error system or thecatch/throw system?  Or are they disjoint?  I prefer, for simplicity, amodel in which the error system can be explained. as much as possible, as acomplex thing built on top of catch, throw, and unwind-protect."David Moon:"Of the several alternative proposals for this issue, the only onethat seemed appropriate to me has been removed. After re-reading the12 messages on the topic that I thought were worth saving, I get thefeeling that the issues have not really been clarified and that thediscussion is largely dealing with strawmen.  It seems like thecleanup committee is heading towards making a serious mistake here.Consider the form  (loop    (catch 'foo      (unwind-protect (loop)        (throw 'foo t))))With the proposed semantics, it is impossible to stop this programexcept by hitting it with two throws in rapid succession, with exactlythe right amount of delay between them so that the catch andunwind-protect have not yet been re-established when the second throwstrikes.  Consider any program-stopping operation that aborts executionby throwing to a catch in the top-level read-eval-print loop (control-Gin Maclisp or c-Abort in Genera; most other systems have their ownequivalent of this).  With the proposed semantics, when this throwexecutes the unwind-protect cleanup handler, as it must, the throw willbe abandoned and execution will resume looping.To me, the inability to stop a program is a much worse problem thanproviding so-called correct semantics for a contrived program thatdoesn't correspond to any real application.  It was suggested that theerror system might depend on the ability to abort throws like this.  Ifthat were demonstrated, I would change my tune, but until it'sdemonstrated I am completely skeptical of the notion that any errorsystem would do this."*start*03371 00024 US Return-Path: <edsel!jonl@labrea.stanford.edu>Received: from labrea.stanford.edu by Xerox.COM ; 24 MAY 88 03:14:33 PDTReceived: by labrea.stanford.edu; Tue, 24 May 88 03:14:20 PDTReceived: from bhopal.lucid.com by edsel id AA04759g; Tue, 24 May 88 02:57:06 PDTReceived: by bhopal id AA04953g; Tue, 24 May 88 03:00:59 PDTDate: Tue, 24 May 88 03:00:59 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805241000.AA04953@bhopal.lucid.com>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 23 May 88 13:35 PDT <880523-133528-5237@Xerox>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)I'm sorry I haven't had time to relay the commentary that we've come upwith here at Lucid.  Mostly we want to specify that the following situationis an error; and in fact I think it is reasonable to signal an error:    During the execution of the cleanup forms of an UNWIND-PROTECT a non-local    exit to a point outside of the [dynamic] scope of the UNWIND-PROTECT, but     still within the dynamic scope of of the target of the original non-local     exit succeeds, and the original pending exit is discarded. For example, in     Situation 1, the pending seek for tag FOO is discarded by the second THROW    to BAR and the value 4 is transfered to (CATCH 'BAR ...), which returns 4.    The (CATCH 'FOO ...) then returns the 4 because its first argument has     returned normally. XXX is not printed.That is, we don't want this case to "succeed", but rather to signal an error.When we had the discussion at Fort Collins, it was just this point that Iknew moon and I agreed on, and everyone else present disagreed.  In fact,now, there is some more argumentation based on our QLISP implementation that almost requires this to be "an error" at least.The operative phrase we have come up with is that    THROW "commits"That is, when a THROW decides that there is a catch-tag somewhere up thereto catch it, then no intervening UNWIND-PROTECT can function like acatch barrier.  That THROW is "committed" to unwinding the stack at leastup to the tagged point.  I think VAX/NIL or MacLisp had such a primitive called CATCH-BARRIER, or CATCHALL, that would stop any THROW of any tag namewhatsoever; this was considered and rejected for Common Lisp, and forgood reason.  Thus is is OK to "extend the THROW"; meaning that when a THROW to a tag HIGH is executing, and some unwind-protect cleanup form executes a THROW to tagHIGHER that is outside the dynamic scope of the catch on tag HIGH, thenthat cleanup form code will:    (1) abort it's own local processing     (2) indicate that the throw to tag HIGH will now be extended to HIGHER    (3) continue with the unwinding, up to the next unwind-protect cleanup        or to the final destination HIGHER.What's not OK is to block a "committed" THROW.  Without this restriction,for example, an "abort" to top-level while runnining the application evaluatornoted below would never succeed; the THROW to FOO from within the cleanupform would serve as an effect barrier such that no throw can go past it.      (loop	(catch 'foo	  (unwind-protect 		(Run-application-evaluator)	    (throw 'foo t))))We have actually programmed this up, but it is not in Lucid's currentproduct.-- JonL --*start*03500 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 03:14:48 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 24 May 88  03:13:48 PDTReceived: by labrea.stanford.edu; Tue, 24 May 88 03:13:52 PDTReceived: from bhopal.lucid.com by edsel id AA04759g; Tue, 24 May 88 02:57:06 PDTReceived: by bhopal id AA04953g; Tue, 24 May 88 03:00:59 PDTDate: Tue, 24 May 88 03:00:59 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805241000.AA04953@bhopal.lucid.com>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 23 May 88 13:35 PDT <880523-133528-5237@Xerox>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)I'm sorry I haven't had time to relay the commentary that we've come upwith here at Lucid.  Mostly we want to specify that the following situationis an error; and in fact I think it is reasonable to signal an error:    During the execution of the cleanup forms of an UNWIND-PROTECT a non-local    exit to a point outside of the [dynamic] scope of the UNWIND-PROTECT, but     still within the dynamic scope of of the target of the original non-local     exit succeeds, and the original pending exit is discarded. For example, in     Situation 1, the pending seek for tag FOO is discarded by the second THROW    to BAR and the value 4 is transfered to (CATCH 'BAR ...), which returns 4.    The (CATCH 'FOO ...) then returns the 4 because its first argument has     returned normally. XXX is not printed.That is, we don't want this case to "succeed", but rather to signal an error.When we had the discussion at Fort Collins, it was just this point that Iknew moon and I agreed on, and everyone else present disagreed.  In fact,now, there is some more argumentation based on our QLISP implementation that almost requires this to be "an error" at least.The operative phrase we have come up with is that    THROW "commits"That is, when a THROW decides that there is a catch-tag somewhere up thereto catch it, then no intervening UNWIND-PROTECT can function like acatch barrier.  That THROW is "committed" to unwinding the stack at leastup to the tagged point.  I think VAX/NIL or MacLisp had such a primitive called CATCH-BARRIER, or CATCHALL, that would stop any THROW of any tag namewhatsoever; this was considered and rejected for Common Lisp, and forgood reason.  Thus is is OK to "extend the THROW"; meaning that when a THROW to a tag HIGH is executing, and some unwind-protect cleanup form executes a THROW to tagHIGHER that is outside the dynamic scope of the catch on tag HIGH, thenthat cleanup form code will:    (1) abort it's own local processing     (2) indicate that the throw to tag HIGH will now be extended to HIGHER    (3) continue with the unwinding, up to the next unwind-protect cleanup        or to the final destination HIGHER.What's not OK is to block a "committed" THROW.  Without this restriction,for example, an "abort" to top-level while runnining the application evaluatornoted below would never succeed; the THROW to FOO from within the cleanupform would serve as an effect barrier such that no throw can go past it.      (loop	(catch 'foo	  (unwind-protect 		(Run-application-evaluator)	    (throw 'foo t))))We have actually programmed this up, but it is not in Lucid's currentproduct.-- JonL --*start*01715 00024 US Return-Path: <gls@Think.COM>Received: from Think.COM by Xerox.COM ; 24 MAY 88 07:45:58 PDTReturn-Path: <gls@Think.COM>Received: from kali.think.com by Think.COM; Tue, 24 May 88 10:43:38 EDTReceived: by kali.think.com; Tue, 24 May 88 10:43:34 EDTDate: Tue, 24 May 88 10:43:34 EDTFrom: gls@Think.COMMessage-Id: <8805241443.AA10546@kali.think.com>To: edsel!jonl@labrea.stanford.eduCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Tue, 24 May 88 03:00:59 PDT <8805241000.AA04953@bhopal.lucid.com>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)   Date: Tue, 24 May 88 03:00:59 PDT   From: Jon L White <edsel!jonl@labrea.stanford.edu>   ...   What's not OK is to block a "committed" THROW.  Without this restriction,   for example, an "abort" to top-level while runnining the application evaluator   noted below would never succeed; the THROW to FOO from within the cleanup   form would serve as an effect barrier such that no throw can go past it.	 (loop	   (catch 'foo	     (unwind-protect 		   (Run-application-evaluator)	       (throw 'foo t))))   ...But the very fact that you can run an arbitrary computation implies thatyou can effectively block a THROW.  For example, I can rewrite the loopshown above as:	(labels ((again () (unwind-protect				(Run-application-evaluator)				(again))))	  (again))Admittedly this is likely to cause net stack growth in any implementationI can think of, but semantically it is equivalent.Another point: what good is signalling an error?  It will give handlers achance to run, but is the error allowed to break out without invoking thecleanup forms anyway?--Guy*start*01415 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 MAY 88 07:49:38 PDTReceived: from hudson.dec.com by SAIL.Stanford.EDU with TCP; 25 May 88  07:47:36 PDTDate: 25 May 88 10:45:00 EDTFrom: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>Subject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)To: "cl-cleanup" <cl-cleanup@sail.stanford.edu>cc: vanroggen@hudson.dec.com Reply-To: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>I'm in favor of the proposal.I don't understand these arguments about "unstoppable" loops.  SinceCommon Lisp doesn't address asynchronous operations, it seems to mejust plain (LOOP) is an "unstoppable" loop.  Let each implementationhave additional means of handling these cases; they would want to beimplementation-dependent anyway, since I don't think anyone is aboutto agree on any particular set of "debugging" primitives.Another thing that bothers me about trying to declare either situations1 or 2 as errors is that whether or not "it is an error" depends onwhether there was a THROW in progress from the protected-form of theUNWIND-PROTECT.  Unless there's a way for the clean-up code to tellif it is being executed due to a THROW rather than a return, I don'tsee how reliable code can be written.			---Walter------*start*03287 00024 US Return-Path: <edsel!jonl@labrea.stanford.edu>Received: from labrea.stanford.edu by Xerox.COM ; 25 MAY 88 12:02:46 PDTReceived: by labrea.stanford.edu; Wed, 25 May 88 12:02:36 PDTReceived: from bhopal.lucid.com by edsel id AA11835g; Wed, 25 May 88 11:50:03 PDTReceived: by bhopal id AA01088g; Wed, 25 May 88 11:54:01 PDTDate: Wed, 25 May 88 11:54:01 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805251854.AA01088@bhopal.lucid.com>To: gls@think.comCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: gls@Think.COM's message of Tue, 24 May 88 10:43:34 EDT <8805241443.AA10546@kali.think.com>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)re: re: But the very fact that you can run an arbitrary computation implies     that you can effectively block a THROW.  For example, I can rewrite the     loop shown above as:	    (labels ((again () (unwind-protect				    (Run-application-evaluator)				    (again))))	      (again))No, this isn't true.  If you interrupt out of AGAIN and "abort" to toplevel, the the barrier is broken.  The part of my emmendation to the proposal that makes this clear is:    ". . . that cleanup form code will:        (1) abort it's own local processing      . . ."As a previous example on this topic showed, unless an implementation just happened to have an "interrupt exposed" critical section, it would be possible that every attempt to interupt the computation and "abort" toa higher level would be blocked and cause re-entry into the cleanupform again.As someone has said previously, this proposal isn't about proscriptions against writing looping code -- e.g., (prog () A (go A)) -- but about thedynamic scoping relations between THROW and UNWIND-PROTECT cleanups.  [Well,if they didn't say exactly that, they should have!]re: Another point: what good is signalling an error?  It will give handlers a    chance to run, but is the error allowed to break out without invoking the    cleanup forms anyway?The main reason for signalling an error is to help the luser find a possiblyvery obscure error that isn't syntatically visible.  The presentations of sample losing code have all been lexically in the same scope; but the erroris one of poor intermixture of dynamic components.But back to your point: "... but is the error allowed to break out without invoking the cleanup forms anyway?".  Yes, most certainly.  This suggestsan implementation technique, which I would have described in more detailhad there been time (and space!).  That is, an "unwind-protect frame,on a stack" is converted into a "cleanup-form frame" during the executionof its cleanup forms; if that execution completes normally, then the"cleanup-form frame" is simply popped off the stack, and the next unwind-protect frame is found and "serviced"; but an attempt to throw throughthat "cleanup-form frame" [a non-local exit, in the original terminologyof this proposal] will either (1) simply flush the frame, thereby effectinga "break out" of the "cleanup-form frame", because the throw target is merely extending a previously "committed" throw, or (2) signal an error because the throw target is scoped erroneously as described in my addendum.-- JonL --*start*03629 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 JUN 88 10:16:14 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 1 Jun 88  10:13:55 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 413221; Wed 1-Jun-88 13:13:56 EDTDate: Wed, 1 Jun 88 13:14 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)To: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880523-133528-5237@Xerox>,             <8805241000.AA04953@bhopal.lucid.com>,             <8805241443.AA10546@kali.think.com>,             The message of 25 May 88 10:45 EDT from "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>,             <8805251854.AA01088@bhopal.lucid.com>,             <880531160736.4.KMP@PEWEE.SCRC.Symbolics.COM>,             <8806010051.AA20825@bhopal.lucid.com>,             <880531-221036-4393@Xerox>,             <8806010813.AA00363@blacksox.lucid.com>Message-ID: <19880601171408.6.MOON@EUPHRATES.SCRC.Symbolics.COM>The inclusion of situation 2 distracts from the issue, since as far as Iknow there is no controversy over situation 2, only over situation 1.  Alsothere is at least one typo where the proposal says 2 where I think it means1, which detracts from its understandability.The attempt to explain UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:CONTINUATION-MODELin terms of continuations explains nothing, since Scheme's continuationsemantics says nothing about dynamic lifetime and indeed assumes indefinitelifetime for continuations.  Since the controversy revolves entirely aroundprecisely when the dynamic (as prescribed by Common Lisp) lifetime of acontinuation ends, appeals to a semantics with indefinite lifetimes cannotshed any light on the issue.In retrospect, all the stuff about looping and unstoppable programs was adistraction from the real issue, which only enables people to flame insteadof thinking about the real issue.  I'm sorry I brought it up, and I wishit were removed from the proposal and people would stop talking about it.The real issue is very simple: CLtL pages 120 and 139 say that blocks andcatches have dynamic lifetime and can only be exited once.  When it isexited, the dynamic lifetime of a block or catch ends.  Furthermore,although CLtL does not actually say so, it surely means to imply thatwhen a block or catch is exited, the dynamic lifetime of any blocks orcatches dynamically nested inside it also ends.Here's the issue: can a portable program assume that the lifetime of ablock or catch ends at the last possible moment, when control reachesthe caller of the block or catch?  Or must portable programs assume thatthis lifetime ends at the first possible moment, when THROW has decidednot to signal the error mentioned in the last sentence (outside ofnotes) on CLtL p.142?  I maintain that the semantics should be definedin the way which is most restrictive on portable programs and leastrestrictive on implementations, that is, portable programs must assumethat the lifetime ends at the first possible moment that CLtL allows itto end.I suppose if I want anyone to listen to me, I have to find the time towrite up an alternative proposal.  I will try to find that time in thenext couple of days, but can't promise anything.  Fortunately, my alternative proposal will be much shorter, as it will not be paddedout with things I consider digressions.*start*02208 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 JUN 88 11:04:11 PDTReceived: from Riverside.SCRC.Symbolics.COM (SCRC-RIVERSIDE.ARPA) by SAIL.Stanford.EDU with TCP; 1 Jun 88  10:37:03 PDTReceived: from PEWEE.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 261236; Wed 1-Jun-88 13:36:39 EDTDate: Wed, 1 Jun 88 13:36 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19880601171408.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <880601133626.3.KMP@PEWEE.SCRC.Symbolics.COM>    Date: Wed, 1 Jun 88 13:14 EDT    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    ...    Here's the issue: can a portable program assume that the lifetime of a    block or catch ends at the last possible moment, when control reaches    the caller of the block or catch?  Or must portable programs assume that    this lifetime ends at the first possible moment, when THROW has decided    not to signal the error mentioned in the last sentence (outside of    notes) on CLtL p.142?  I maintain that the semantics should be defined    in the way which is most restrictive on portable programs and least    restrictive on implementations, that is, portable programs must assume    that the lifetime ends at the first possible moment that CLtL allows it    to end.    ...My "naive model" has always been that an unwind-protect happens "as" (not"after") an unwind occurs. I believe that this model is consistent only withthe idea that the dynamic state is retained until the last possible moment,not the first. A major driving force in my reasoning is the fact that specialvariable bindings have been partly unwound at the time the cleanup form isrun -- I find it more consistent to have all dynamic state unwinding at thesame time than to have the hairy N-pass unwinding strategy which seems to resultfrom the model you're suggesting. I hope that your proposal will address thisissue.*start*02966 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 JUN 88 14:04:54 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 1 Jun 88  14:01:26 PDTReturn-Path: <gls@Think.COM>Received: from kali.think.com by Think.COM; Wed, 1 Jun 88 16:58:04 EDTReceived: by kali.think.com; Wed, 1 Jun 88 16:57:58 EDTDate: Wed, 1 Jun 88 16:57:58 EDTFrom: gls@Think.COMMessage-Id: <8806012057.AA22284@kali.think.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 1 Jun 88 13:14 EDT <19880601171408.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)I think Moon has been put off by the word "continuation", and perhapsrightly so.  Let me appeal to yet another model.Unwinding is not an atomic process, because UNWIND-PROTECT allows arbitraryuser code to step in and execute in the middle of an unwinding.  How can wecharacterize the state of the computation when that user code is running?In what ways can the user code examine, or even alter, that state?It may help to consider the PDP-10 instruction set.  BLT is not an atomicoperation, but rather an interruptible one.  Therefore its interface wascarefully arranged so that its intermediate state could be easilysummarized.  This intermediate state was part of the advertised interfaceto the user.  While I think very few programs actually checked thisintermediate state, or tried to alter it in mid-BLT, in principle itwas possible.Conversely, consider the INTPRO (interrupt protect) macros we used in thesource code of PDP-10 MacLisp.  The problem here was that it was essentialthat certain crucial instruction sequences be regarded as atomic (such asthe guts of CONS), and yet there was a provision for running arbitrary usercode during an interrupt.  The game here was that the interrupt traphandler checked the PC, and if the PC was in a crucial interval then somecleanup routine was performed, and *the interrupt state was then modifiedto return to a PC other than where the interrupt had occurred*.  As Irecall, this was trivial under ITS, as the state was accessible to the userprogram, but very difficult under TENEX, as the relevant state was notaccessible: the only way to get rid of the state "you're in an interrupthandler" was to return to the very PC where you took the interrupt, and noother, and this was a real pain.  I think this situation is very similar toan UNWIND-PROTECT taking a look at the state of a Lisp data structure,discovering that it is inconsistent, and deciding to THROW elsewhereinstead.  Now maybe a previous THROW should not be forgotten, but thenthere must be some explanation of how that state information is remembered,how it interacts with other control actions over time, and whether itcan be queried.--Guy*start*06098 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 31 MAY 88 13:10:50 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 31 May 88  13:08:03 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 412646; Tue 31-May-88 16:07:50 EDTDate: Tue, 31 May 88 16:07 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)To: edsel!jonl@LaBrea.Stanford.EDUcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8805241000.AA04953@bhopal.lucid.com>References: The message of 25 May 88 10:45 EDT from "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>,            <880523-133528-5237@Xerox>Message-ID: <880531160736.4.KMP@PEWEE.SCRC.Symbolics.COM>Ok, I've caught up on my reading on this one...    Date: Tue, 24 May 88 03:00:59 PDT    From: Jon L White <edsel!jonl@labrea.stanford.edu>    ...    The operative phrase we have come up with is that	THROW "commits"    That is, when a THROW decides that there is a catch-tag somewhere up    there to catch it, then no intervening UNWIND-PROTECT can function like    a catch barrier.    ...I just don't believe any of this. You can say "THROW commits", I can sayit doesn't.  You assert it as if it were true and then try to derive asemantics based on that unsupported presupposition. We all agree thatTHROW commits to the extent that it chooses where it wants to unwind to.What we don't agree on is whether it is well-defined, is an error, orsignals an error if you try to keep THROW from doing what it had set outto do.On a recent invitation to a marriage ceremony, I was asked to say (in additionto whether I'd be attending) what my definition of "commitment" was. I thoughtabout this a long while and finally decided that the word is misleading andthat I would attack its usage as an absolute. One does not commit in the absolute,one commits relatively. It's meaningless to say "I'm absolutely committed tothis person" or "I'm absolutely committed to this project" because (as Steelepoints out in the Discussion section for this issue) you immediately run intoproblems of conflicting absolutes (irresistable forces and immovable mountains)When making a statement of commitment, you must say what your priorities are,relative to other things which might come into conflict.Consider the case of (DOTIMES (I (* A B)) ...)Certainly we must say that this DOTIMES "commits" to doing some number ofiterations, but all that means is that it has decided it's going to do thatand no modification of A or B is going to change that. But it doesn't mean thatsomething can't come along to shake it free -- its level of commitment is low.It should not be said that this loop is a "failure" if a RETURN is executed.Rather, we should just identify that its initial level of commitment to executingall A*B steps is lower than its commitment to stopping the loop if a RETURN isexecuted.Ditto for THROW. I'm happy to say "THROW commits". I'm just not happy to say thatthere is nothing in the language which might not have higher priority. Further,but independently, I personally wish that another THROW should have such higherpriority.    What's not OK is to block a "committed" THROW.  Without this restriction,    for example, an "abort" to top-level while runnining the application    evaluator noted below would never succeed; the THROW to FOO from within    the cleanup form would serve as an effect barrier such that no throw can    go past it.	  (loop	    (catch 'foo	      (unwind-protect 		    (Run-application-evaluator)		(throw 'foo t))))That's right! It WOULD serve as a barrier that no one can go past. Butdid it occur to you that someone might want that? People have pulled alot of wild cases out of the air, but the only non-contrived situationwe have in this entire conversation is the one that I brought in fromMacsyma when I introduced this situation. I wanted to make a newtoplevel on top of Lisp's so that I could not get back to Lisp. I wrotejust the piece of code that you see above (exceptRUN-APPLICATION-EVALUATOR was called something like MACSYMA-TOPLEVEL)with certain expectations that you are claiming would not be wanted, andyet I know for a fact that they are exactly what are wanted.  Can youcite any other real world examples of anyone getting involved in this?I agree with Walter that the issue of an "unstoppable" loop is so muchbigger than this problem that we just shouldn't get involved in thathere. Every implementation should provide a way to unwind the stackwithout running the unwind protects and everyone's debugger should offeran interactive entry point to that mechanism for cases where you getwedged and need to stop a program. Beyond that, I don't see that more isrequired.I think GLS says it best in the discussion on the proposal as currentlywritten: ``Which mechanism are to we regard as primitive: the error system or the   catch/throw system?  Or are they disjoint?  I prefer, for simplicity, a   model in which the error system can be explained. as much as possible,   as a complex thing built on top of catch, throw, and unwind-protect.''I shudder to think about a system whose control semantics must appeal to thecondition system. I side with GLS in preferring to think of the errorsystem as a user program layered atop a simple set of control primitives.I [still] support UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:CONTINUATION-MODEL(now version 4).Having been the self-righteous underdog in some of these other battles,I'm very concerned about not seeing legitimate points of views stifled.Remarks by Moon and JonL should be duly noted at least in the discussionand, if they desire, as a competing proposal. It's clear we're not goingto get closure within this group since we have no voting authority. Let'stake it to the full community.*start*00905 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 31 MAY 88 22:13:24 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 31 May 88  22:11:28 PDTReceived: from Burger.ms by ArpaGateway.ms ; 31 MAY 88 22:10:36 PDTFrom: masinter.paDate: 31 May 88 22:10:07 PDTSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)In-reply-to: edsel!jlm@labrea.stanford.edu's message of Tue, 31 May 88 17:51:51 PDT, <8806010051.AA20825@bhopal.lucid.com>To: Jim McDonald <edsel!jlm@labrea.stanford.edu>cc: KMP@stony-brook.scrc.symbolics.com, CL-Cleanup@sail.stanford.eduMessage-ID: <880531-221036-4393@Xerox>Its late enough in the game, and I'm enough behind in the mail, to want somebriefer summaries of positions on this issue. We've been round it lots. Are yefer it or agin it?*start*01060 00024 US Return-Path: <edsel!eb@labrea.stanford.edu>Received: from labrea.stanford.edu by Xerox.COM ; 01 JUN 88 01:20:47 PDTReceived: by labrea.stanford.edu; Wed, 1 Jun 88 01:20:49 PDTReceived: from blacksox.lucid.com by edsel id AA11274g; Wed, 1 Jun 88 01:08:44 PDTReceived: by blacksox id AA00363g; Wed, 1 Jun 88 01:13:01 pdtDate: Wed, 1 Jun 88 01:13:01 pdtFrom: Eric Benson <edsel!eb@labrea.stanford.edu>Message-Id: <8806010813.AA00363@blacksox.lucid.com>To: masinter.paCc: edsel!jlm@labrea.stanford.edu, KMP@stony-brook.scrc.symbolics.com, CL-Cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 31 May 88 22:10:07 PDT <880531-221036-4393@Xerox>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)   From: masinter.pa@Xerox.COM   Date: 31 May 88 22:10:07 PDT   Its late enough in the game, and I'm enough behind in the mail, to want some   briefer summaries of positions on this issue. We've been round it lots. Are ye   fer it or agin it?Along with KMP, I favor the continuation model.*start*01069 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 JUN 88 07:13:22 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 1 Jun 88  07:11:46 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU;  1 Jun 88 10:11:57 EDTTo: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4) In-reply-to: Your message of 31 May 88 22:10:07 -0700.             <880531-221036-4393@Xerox> Date: Wed, 01 Jun 88 10:11:52 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUThe continuation model still looks best to me.  One can create screw casesfor either version, so I'm inclined to favor the solution that provides acleaner and more intuitive model of what is going on.  For me,continuation seems much simpler and clearer than "throw commits".  Somesystems may choose to provide a way of breaking out of the kind of trapthat people have described here; I think that is an environment issue.-- Scott*start*03995 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 JUN 88 21:43:30 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 2 Jun 88  21:40:46 PDTReceived: by labrea.stanford.edu; Thu, 2 Jun 88 21:41:08 PDTReceived: from bhopal.lucid.com by edsel id AA04051g; Thu, 2 Jun 88 20:01:29 PDTReceived: by bhopal id AA28862g; Thu, 2 Jun 88 19:59:29 PDTDate: Thu, 2 Jun 88 19:59:29 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8806030259.AA28862@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 1 Jun 88 13:14 EDT <19880601171408.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)re: Here's the issue: can a portable program assume that the lifetime of a    block or catch ends at the last possible moment, when control reaches    the caller of the block or catch?  Or must portable programs assume that    this lifetime ends at the first possible moment, when THROW has decided    not to signal the error mentioned in the last sentence (outside of    notes) on CLtL p.142? This is exactly what Ron Goldman (of Lucid's QLISP project) and I meanby "THROW commits"  -- that you execute the cleanup forms pending on theunwind-protect frames, but you are "committed" _not_ to re-enter the bodieswithout first exiting the CATCH to which you were throwing.  [But the localvariable environments are still guaranteed in existence during the cleanup-form execution, since they can make reference to those variables.  Do I needto be more specific here?]I rather like your phraseology above -- using terms like "lifetime of a CATCH" etc.Mabye the right approach to this miasma is to delete situation (1) from the current proposal, and then let it be passed; for we all seem to be inagreement that it should be possible to "extend" a THROW in progress,while aborting out of one particular cleanup-form execution.  Then, submit another proposal for the same issue which addresses only the situation (1) part.  Could you possibly take a stab at doing this before Larry's deadline?re: In retrospect, all the stuff about looping and unstoppable programs was a    distraction from the real issue, which only enables people to flame instead    of thinking about the real issue.  I'm sorry I brought it up, and I wish    it were removed from the proposal and people would stop talking about it.I didn't realize you were the guilty party here. I think a lot of other people independently fell into this pit because of the obvious "re-entering the body without ever exiting the CATCH" capability, which would exist if situation (1) weren't proscribed.  My previous msg described it thus:    "As someone has said previously, this proposal isn't about proscriptions      against writing looping code -- e.g., (prog () A (go A)) -- but about the     dynamic scoping relations between THROW and UNWIND-PROTECT cleanups.       [Well, if they didn't say exactly that, they should have!]"Also, I think a proposal about case (1) will have to address the CATCH-BARRIER implication, if for no other reason than that someone actually claimed that he wanted to erect a barrier using the mechanism of situation (1) scoping.  At the very least -- if it is such good idea to permit catch barriers -- then an explicit proposal for CATCH-BARRIER (or CATCHALL, or whatever) should be put forward (and hopefully defeated);otherwise one is subject to the _unintentional_ falling into an unseen barrier simply because of poor scoping on THROW's.  Jim MacDonald's reply to KMP seems to me to show that an unrestricted CATCH-BARRIER really isn't needed for an sensibly-written program; and whatever arguments kept CATCH-BARRIER out of Common Lisp in 1983 are probably still relevant today.-- JonL --*start*02396 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 02 JUN 88 21:43:32 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 2 Jun 88  21:41:12 PDTReceived: by labrea.stanford.edu; Thu, 2 Jun 88 21:41:34 PDTReceived: from bhopal.lucid.com by edsel id AA04439g; Thu, 2 Jun 88 21:16:55 PDTReceived: by bhopal id AA29028g; Thu, 2 Jun 88 21:14:52 PDTDate: Thu, 2 Jun 88 21:14:52 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8806030414.AA29028@bhopal.lucid.com>To: gls@think.comCc: Moon@stony-brook.scrc.symbolics.com, cl-cleanup@sail.stanford.eduIn-Reply-To: gls@Think.COM's message of Wed, 1 Jun 88 16:57:58 EDT <8806012057.AA22284@kali.think.com>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)re: Conversely, consider the INTPRO (interrupt protect) macros we used in the    source code of PDP-10 MacLisp.  The problem here was that it was essential    that certain crucial instruction sequences be regarded as atomic (such as    the guts of CONS), and yet there was a provision for running arbitrary user    code during an interrupt.  The game here was that the interrupt trap    handler checked the PC, and if the PC was in a crucial interval then some    cleanup routine was performed, and *the interrupt state was then modified    to return to a PC other than where the interrupt had occurred*. . . .      I think this situation is very similar to    an UNWIND-PROTECT taking a look at the state of a Lisp data structure,    discovering that it is inconsistent, and deciding to THROW elsewhere    instead.  Now maybe a previous THROW should not be forgotten, . . . I believe the analogy you are making here supports the notion of "extending"the throw, but not one of "barricading" it; it worst, it would "extend"the PC to a point a little beyond where the interrupt really happend.It was like retroactively masking out interrupts during the intervalbetween the two PC's.To the extent that this analogy has any relevance at all for the CL dynamic scoping problem, then one should note that the "cleanup" routine for the INTPRO hack was completely "dynamically" scoped;  that is, it is like "Situation 0" of the the proposal under discussion, rather than the disputed "Situation 1".-- JonL --*start*02681 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 JUN 88 10:51:00 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 3 Jun 88  10:48:45 PDTReturn-Path: <gls@Think.COM>Received: from kali.think.com by Think.COM; Fri, 3 Jun 88 11:38:53 EDTReceived: by kali.think.com; Fri, 3 Jun 88 11:38:47 EDTDate: Fri, 3 Jun 88 11:38:47 EDTFrom: gls@Think.COMMessage-Id: <8806031538.AA24924@kali.think.com>To: edsel!jonl@labrea.stanford.eduCc: gls@Think.COM, Moon@stony-brook.scrc.symbolics.com, cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Thu, 2 Jun 88 21:14:52 PDT <8806030414.AA29028@bhopal.lucid.com>Subject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4)   Date: Thu, 2 Jun 88 21:14:52 PDT   From: Jon L White <edsel!jonl@labrea.stanford.edu>   re: Conversely, consider the INTPRO (interrupt protect) macros we used in the       source code of PDP-10 MacLisp.  The problem here was that it was essential       that certain crucial instruction sequences be regarded as atomic (such as       the guts of CONS), and yet there was a provision for running arbitrary user       code during an interrupt.  The game here was that the interrupt trap       handler checked the PC, and if the PC was in a crucial interval then some       cleanup routine was performed, and *the interrupt state was then modified       to return to a PC other than where the interrupt had occurred*. . . . 	I think this situation is very similar to       an UNWIND-PROTECT taking a look at the state of a Lisp data structure,       discovering that it is inconsistent, and deciding to THROW elsewhere       instead.  Now maybe a previous THROW should not be forgotten, . . .    I believe the analogy you are making here supports the notion of "extending"   the throw, but not one of "barricading" it; it worst, it would "extend"   the PC to a point a little beyond where the interrupt really happend.   It was like retroactively masking out interrupts during the interval   between the two PC's.   To the extent that this analogy has any relevance at all for the CL dynamic    scoping problem, then one should note that the "cleanup" routine for the    INTPRO hack was completely "dynamically" scoped;  that is, it is like    "Situation 0" of the the proposal under discussion, rather than the    disputed "Situation 1".   -- JonL --Indeed.  I am more sympathetic to the "THROW commits" notion afterfurther pondering this analogy.  My main point is that the nature ofthe intermediate state needs to be made clear.--Guy*start*01685 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 JUN 88 11:36:14 PDTReceived: from FRED.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 3 Jun 88  11:34:06 PDTReceived: from FRED.SLISP.CS.CMU.EDU by FRED.SLISP.CS.CMU.EDU;  3 Jun 88 14:34:23 EDTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 4) In-reply-to: Your message of Wed, 01 Jun 88 13:14:00 -0400.             <19880601171408.6.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Fri, 03 Jun 88 14:33:42 EDTFrom: Rob.MacLachlan@WB1.CS.CMU.EDUIn previous iterations of this proposal, I was one of the people whoforcefully argued for the "continuation model".  My primary concern wasthat, as a compiler writer, my life would be substantially complicated byproposals that required an error *to be signalled* when the appropriatemetaphysical violation of the dynamic extent of a lexical control construct(i.e. BLOCK) happened.  This was where this example came from:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))It is useful for a compiler to be able to have internal representationswhich treat the same continuation as the same continuation, with FOO andBAR just being different names for this.  Too many people out there arewandering around thinking "BLOCK is the same as CATCH (and presumablyimplemented using it.)"I don't care if anyone wants case one to "be an error", I just don't wantit to be required to be signalled.  Rob*start*12082 00024 US Date:  7 Jun 88 17:55 PDTFrom: Masinter.pato: masinterSubject: Issue: UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT (Version 5)not ready yetTo: cl-cleanup@sail.stanford.educc: MasinterThis proposal will go out asDRAFT: for discussion at X3J13Issue:          UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXITReferences:     UNWIND-PROTECT (p140, p142, p39)                Issue IGNORE-ERRORS, Draft error proposal.Category:       CLARIFICATION/CHANGEEdit history:   Version 1 by Pitman   27-Feb-87                Version 2 by Masinter 24-Oct-87                Version 3 by Masinter 27-Oct-87                Version 4 by Masinter 13-Feb-88                Version 5 by Masinter 23-May-88Problem Description:If a non-local return is done while in the cleanup form of an UNWIND-PROTECT, the behavior is not always well-defined.There are three basic cases:Situation 0. Transfer to another point within the cleanup form.   (UNWIND-PROTECT 3 (BLOCK NIL (RETURN 4)) (PRINT 'XXX))There is no ambiguity about how this form is to be interpreted.Effectively:       . 3 evaluates to itself, which is queued for return        from the UNWIND-PROTECT.       . The BLOCK expression is entered, 4 is returned to	it and discarded because this is a not-for-value 	situation.      . XXX is printed, XXX is returned by the PRINT and	that value is discarded because this is a not-for-value	situation.      . The 3 which was yielded earlier is retrieved and	returned as the value of the UNWIND-PROTECT.Situation 1. Transfer to a point inside the point to which control     would have transferred.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found within the scope of the target of the       pending THROW (to FOO).Situation 2. Transfer to a point outside the point to which control would    already have been given. For example:    (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))    This is a subject of controversy because:    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . Disagreement exists as to whether it is an error if the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW (to FOO).What is the appropriate behavior for situation 1 and situation 2 and similar ones? For example, suppose that when WITH-OPEN-FILE tries to close the file upon unwinding, it signals an error, and the condition handler also attempts to throw? The question applies to all non-local transfers, whether performed by THROW, RETURN-FROM, RETURN, GO.This issue has two proposals. There is some disagreement as to what should happen in Situation 2.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:OVERRIDES):In all cases, a transfer of control within an UNWIND-PROTECT cleanup form to a point outside of the UNWIND-PROTECT causes the original control transfer which initiated the execution of the cleanup forms to be abandonded.During the execution of the cleanup forms of an UNWIND-PROTECT a non-local exit to a point outside of the scope of the UNWIND-PROTECT, but still within the dynamic scope of of the target of the original non-local exit succeeds, and the original pending exit is discarded. For example, in Situation 1, the pending seek for tag FOO is discarded by the second THROW to BAR and the value 4 is transfered to (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...) then returns the 4 because its first argument has returned normally. XXX is not printed.Where an UNWIND-PROTECT cleanup form attempts a non-local exit to a point outside the original non-local exit, control is passed to the outer exit (and the pending original non-local exit is discarded.) For example, in Situation 2, the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.In no case will UNWIND-PROTECT cleanup forms ever be attempted more than once.Proposal (UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT:OVERRIDE-IS-ERROR):The code in Situation 1 "is an error"; that is, it is an error for a cleanup clause of an UNWIND-PROTECT to perform a non-local exit to a point outside of the scope of the UNWIND-PROTECT, but still within the dynamic scope of of the target of the original non-local exit.  There is no error in Situation 2.Rationale:The issue has to do with whether a THROW can commit that the intermediate state between the CATCH will be discarded without ever being reexecuted.Current Practice:Some implementations generate garbage code in situations 1 and 2.  Some have differing behavior compiled and interpreted.Most that have implementations seem to implement the proposed semantics for situation 2, but there is some divergence in Situation 1. For example, Spice Lisp and Xerox implement OVERRIDES while Symbolics Genera signals an error. Cost to Implementors:OVERRIDES may have high cost in some implementations. OVERRIDE-IS-ERROR, since it specifies "is an error", can effectively be ignored by implementors.Cost to Users:Most user programs don't do this, so there is likely little cost of converting existing code. OVERRIDE-IS-ERROR allows a subtle situation which is not portable across implementations.Benefits:Clarifying situation 0 and 2 is clearly beneficial. OVERRIDE-IS-ERROR makes it clear that situation 1 is an error, while OVERRIDES gives a portable meaning. OVERRIDE-IS-ERROR gives more implementation flexibility. Programs that do this on purpose generally are trying to do something fairly intricate and really need to be able to depend on it being uniformly treated. A portable error/signal system and debugger may be among these. For example, one programmer created his own "top level", to which the system "abort" character would return, by doing: (DEFUN MY-TOPLEVEL ()   (TAGBODY LOOP (UNWIND-PROTECT (REALLY-MY-TOPLEVEL)			      (GO LOOP))))Aesthetics:This proposal is more intuitive to programmers who reason about programs in terms of continuation passing. It falls out of the normal scoping rules as a consequence of the fact that the cleaup code is evaluated in the lexical and dynamic environment in which the UNWIND-PROTECT form appears. The action of THROW is usefully described by saying that it is just like any other function. It happens to discard the current continuation,  run some cleanup things (like variable unbindings and UNWIND-PROTECT actions), and transfer control elsewhere in the program. In doing so, the function uses data structure primitives not generally available to other programs, but it is not linguistically different and receives no special exemption with regard to THROWs or other non-local transfers of control done within its execution. A THROW from within an UNWIND-PROTECT cleanup is not different than one in any other code; it discards the ongoing action (stack unwinding) and replaces it by another action (as it happens, another stack unwinding). The previous unwind is never resumed.Discussion:This issue is controversial. While the proposal included here had a number of strong endorsements, there were also some strenuous objections. Two alternatives for situation 2 were seriously considered: that it should signal an error, and that it the second non-local exit instead continues the original (more extensive) one; e.g., in Situation 1, the second THROW to BAR would be discarded in lieu of continuing the THROW to FOO.Either of these alternatives would help prevent users from (either intentionally or unintentionally) creating situations where it is impossible to abort a computation with a THROW or other non-local return (e.g., an interrupt implemented via THROW.)For example,  given  (LOOP    (CATCH 'FOO      (UNWIND-PROTECT (LOOP ... )        (THROW 'FOO T))))With this proposal there is no way of exiting such a form. Signalling an error would prevent programmers from getting into this unfortunate situation.However, similar "unstoppable" loops can be created, without resorting to non-nested non-local transfers within UNWIND-PROTECT clauses; for example:(LABELS ((HA () (UNWIND-PROTECT (LOOP) (HA)))) (HA))While it would be unfortunate for a programmer to accidentally create such an unstoppable loop, the user has pretty clearly asked to have a loop that cannot be exited and deserves to have that request carried out.One implication is that it is likely that programming environments need to provide some mechanism other than THROW to stop a truly run-away computation.An interesting example which supports this proposal is one where there are two BLOCKs   (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangably, signalling an error in this situation would be inappropriate. Guy Steele:"We have here a classic case of the irresistible force (QUIT, dammit!)versus the immovable mountain (UNWIND-PROTECT).  I find that thesuggestion that situation 1 produce an error, but one that IGNORE-ERRORSwon't ignore, to be at least one level of epicycle too many.Which mechanism are to we regard as primitive: the error system or thecatch/throw system?  Or are they disjoint?  I prefer, for simplicity, amodel in which the error system can be explained. as much as possible, as acomplex thing built on top of catch, throw, and unwind-protect."David Moon:"Of the several alternative proposals for this issue, the only onethat seemed appropriate to me has been removed. After re-reading the12 messages on the topic that I thought were worth saving, I get thefeeling that the issues have not really been clarified and that thediscussion is largely dealing with strawmen.  It seems like thecleanup committee is heading towards making a serious mistake here.Consider the form  (loop    (catch 'foo      (unwind-protect (loop)        (throw 'foo t))))With the proposed semantics, it is impossible to stop this programexcept by hitting it with two throws in rapid succession, with exactlythe right amount of delay between them so that the catch andunwind-protect have not yet been re-established when the second throwstrikes.  Consider any program-stopping operation that aborts executionby throwing to a catch in the top-level read-eval-print loop (control-Gin Maclisp or c-Abort in Genera; most other systems have their ownequivalent of this).  With the proposed semantics, when this throwexecutes the unwind-protect cleanup handler, as it must, the throw willbe abandoned and execution will resume looping.To me, the inability to stop a program is a much worse problem thanproviding so-called correct semantics for a contrived program thatdoesn't correspond to any real application.  It was suggested that theerror system might depend on the ability to abort throws like this.  Ifthat were demonstrated, I would change my tune, but until it'sdemonstrated I am completely skeptical of the notion that any errorsystem would do this."        TITAN 
          TITAN 
         
TIMESROMAN 
                         &              \                                         
t       =                          D      6                           c                                   
                   6                   - z*start*07114 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 16:50:11 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Sep 88  16:34:00 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 455890; Wed 7-Sep-88 19:33:12 EDTDate: Wed, 7 Sep 88 19:32 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENT (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <19880907233254.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Here's the issue writeup that I promised months ago, but never had timeto do.  I hope it's not too late to be of any use to anyone.Issue:         EXIT-EXTENTReferences:    CATCH, THROW,               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).               Cleanup issue UNWIND-PROTECT-NON-LOCAL-EXIT is superseded               by this one.Category:      CLARIFICATIONEdit history:  Version 1, 5-Sep-88, by Moon, for discussionProblem description:CLtL does not specify precisely when the dynamic extent (aka lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends.There are three cases of interest:(1) Normal exit from a CATCH, BLOCK, TAGBODY, or equivalent such as PROG.(2) Nonlocal exit from the target of a THROW or RETURN.(3) Abandonment of an exit passed over by THROW, RETURN, or GO.The terms "normal exit", "target", and "passed over" will be used withthese meanings for the remainder of the discussion.CLtL is unambiguous about case 1.  In cases 2 and 3, the extent couldend anywhere from the time the THROW, RETURN, or GO commences, until thetime the transfer of control is completed.  In case 2, it is clear thatthe extent of the target ends before the transfer of control completes,since a block cannot be exited twice, but it is not made clear whetherthe extent ends before or after execution of UNWIND-PROTECT cleanupforms.  CLtL says nothing about case 3, although a note on p.38 impliesthat the extent of a passed-over exit should end no later than the endof the extent of the target exit.Proposal (EXIT-EXTENT:MINIMAL):The dynamic extent of an exit, whether target or passed-over, ends assoon as the THROW, RETURN, or GO commences.  In the language of theimplementation note on p.142, the extent ends at the beginning of thesecond pass.  It is an error for an UNWIND-PROTECT cleanup form executedduring a nonlocal transfer of control to attempt to use an exit whosedynamic extent ended when the nonlocal transfer of control commenced.This proposal is called "minimal" because it gives exits the shortestextent consistent with CLtL.Test Cases/Examples:Each of the following programs is an error:(funcall (block nil #'(lambda () (return))))		;case 1(block nil						;case 2  (unwind-protect (return)    (return)))(block a						;case 3  (block b    (unwind-protect (return-from a)      (return-from b))))(let ((a nil))						;case 1  (tagbody t (setq a #'(lambda () (go t))))  (funcall a))(funcall (block nil					;case 3	   (tagbody a (return #'(lambda () (go a))))))(catch nil						;case 2  (unwind-protect (throw nil t)    (throw nil t)))(catch 'a						;case 3  (catch 'b    (unwind-protect (throw 'a t)      (throw 'b t))))The above program is an error because the catch of b is passed over bythe first throw, hence portable programs must assume its dynamic extentis terminated.  The catch is not yet disestablished and therefore itis the target of the second throw.The following program is not an error.  It returns 10.  The innercatch of a is passed over, but this is not case 3 because that catchis disestablished before the throw to a is executed.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))))Rationale:Giving exits the shortest extent consistent with CLtL maximizes freedomfor implementations and takes away no useful capability from users.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target exit at the moment the values are returned, and end theextent of a passed-over exit at the moment the THROW, RETURN, or GOcommences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.I have not surveyed any other implementations.Cost to Implementors:There is no cost to implementors, as no currently valid implementationwill be made invalid by this proposal.Cost to Users:There is no cost to users, as no existing portable program is made invalidby this proposal.  This proposal will clarify why some existing nonportableprograms are nonportable, which could be viewed as either a cost or a benefitto users.Cost of non-adoption:The semantics of exits will remain ambiguous.Benefits:Common Lisp will be more precisely defined, and the precise definition willbe consistent with current practice in a way that has no cost for implementorsnor for users.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:The goal of this proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation.  An alternative proposalwould define the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  That alternative wouldhave a cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal would duck theissue by outlawing all nonlocal exits from UNWIND-PROTECT cleanup forms.That alternative would have a substantial cost to some users.Scheme is cleaner: it ducks this issue by specifying that the extentof an exit never ends.CLtL never says in what dynamic environment cleanup forms ofUNWIND-PROTECT are executed.  The implementation note on p.142 may havebeen intended to cover this, but since it doesn't define the term"frame" that it uses, it doesn't actually say anything.  This proposalcould be expanded to cover that issue by discussing the extent ofdynamic-extent entities other than exits, or that issue could be thesubject of a separate proposal.*start*01284 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 15 SEP 88 12:58:20 PDTMessage-ID: <1Sc9sb@SAIL.Stanford.EDU>Date: 15 Sep 88 10:29 PDTFrom: System Files <SYS@SAIL.Stanford.EDU>Subject: Re: Issue: EXIT-EXTENT (Version 1)  Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Sep 88  10:28:50 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 459750; Thu 15-Sep-88 13:17:59 EDTDate: Thu, 15 Sep 88 13:17 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: EXIT-EXTENT (Version 1)To: masinter.pa@Xerox.COMcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880914-230125-1950@Xerox>Message-ID: <19880915171725.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 14 Sep 88 23:01 PDT    From: masinter.pa@Xerox.COM    My problem with this writeup is that it does not mention the numerous points for    the alternative proposalI think someone else will have to do that, as I found those pointsunconvincing and in some cases incomprehensible.  I don't think Icould do justice to them in a paraphrase.*start*00974 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 15 SEP 88 10:17:58 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 459750; Thu 15-Sep-88 13:17:59 EDTDate: Thu, 15 Sep 88 13:17 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: EXIT-EXTENT (Version 1)To: masinter.pacc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880914-230125-1950@Xerox>Message-ID: <19880915171725.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 14 Sep 88 23:01 PDT    From: masinter.pa@Xerox.COM    My problem with this writeup is that it does not mention the numerous points for    the alternative proposalI think someone else will have to do that, as I found those pointsunconvincing and in some cases incomprehensible.  I don't think Icould do justice to them in a paraphrase.*start*08108 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 16:11:52 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 1 Oct 88  16:08:01 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 01 OCT 88 16:06:30 PDTDate: 1 Oct 88 16:06 PDTFrom: masinter.paSubject: Issue: EXIT-EXTENT (Version 2)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <881001-160630-2212@Xerox>Sigh, I started to edit this with the idea that there were some minoredits, and I discovered that the wording at least is awkward because GOdoes a non-local transfer of control that is not an "exit" per se.  (Thereis something unnamed that GO exits, but to talk about the extent of it onealmost has to name it.)It uses the phrase "The terms "normal exit", "target", and "passed over"will be used withthese meanings for the remainder of the discussion." but doesn't reallyever say what "these meanings" are. I started to edit it, but I'm afraid it needs more work than I have timefor right now. David, can you give it another shot? You can either startwith your version or this one. (I think I changed "Scheme ducks" to "Schemeavoids" and made a few other conciliatory edits....)!Issue:         EXIT-EXTENTReferences:    CATCH, THROW,               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).               Cleanup issue UNWIND-PROTECT-NON-LOCAL-EXIT is superseded               by this one.Category:      CLARIFICATIONEdit history:  Version 1, 5-Sep-88, by Moon, for discussion			Version 2,  1-Oct-88, by Masinter				minor edits.Problem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends.There are three cases of interest:(1) Normal exit from a CATCH, BLOCK or TAGBODY,	or equivalent such as PROG. (2) Nonlocal exit from the target of a THROW or RETURN or to     the target of a GO.(3) Abandonment of an exit passed over by THROW, RETURN, or GO.The terms "normal exit", "target", and "passed over" will be used withthese meanings for the remainder of the discussion.CLtL is unambiguous about case 1.  In cases 2 and 3, the extent couldend anywhere from the time the THROW, RETURN, or GO commences, until thetime the transfer of control is completed.  In case 2, it is clear thatthe extent of the target ends before the transfer of control completes,since a block cannot be exited twice, but it is not made clear whetherthe extent ends before or after execution of UNWIND-PROTECT cleanupforms.  CLtL says nothing about case 3, although a note on p.38 impliesthat the extent of a passed-over exit should end no later than the endof the extent of the target exit.Proposal (EXIT-EXTENT:MINIMAL):The dynamic extent of an exit, whether target or passed-over, ends assoon as the THROW, RETURN, or GO commences.  In the language of theimplementation note on p.142, the extent ends at the beginning of thesecond pass.  It is an error for an UNWIND-PROTECT cleanup form executedduring a nonlocal transfer of control to attempt to use an exit whosedynamic extent ended when the nonlocal transfer of control commenced.This proposal is called "minimal" because it gives exits the shortestextent consistent with CLtL.Test Cases/Examples:Each of the following programs is an error:(funcall (block nil #'(lambda () (return))))		;case 1(block nil						;case 2  (unwind-protect (return)    (return)))(block a						;case 3  (block b    (unwind-protect (return-from a)      (return-from b))))(let ((a nil))						;case 1  (tagbody t (setq a #'(lambda () (go t))))  (funcall a))(funcall (block nil					;case 3	   (tagbody a (return #'(lambda () (go a))))))(catch nil						;case 2  (unwind-protect (throw nil t)    (throw nil t)))(catch 'a						;case 3  (catch 'b    (unwind-protect (throw 'a t)      (throw 'b t))))The above program is an error because the catch of b is passed over bythe first throw, hence portable programs must assume its dynamic extentis terminated.  The catch is not yet disestablished and therefore itis the target of the second throw.The following program is not an error.  It returns 10.  The innercatch of a is passed over, but this is not case 3 because that catchis disestablished before the throw to a is executed.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))))Rationale:Giving exits the shortest extent consistent with CLtL maximizes freedomfor implementations; there are few applications for allowing a longerextent.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target exit at the moment the values are returned, and end theextent of a passed-over exit at the moment the THROW, RETURN, or GOcommences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, the extent of a target exit lasts until theexit has been completed; in those implementations, it is possible fora throw or non-local exit to be effectively "stopped" by a UNWIND-PROTECTclause. Cost to Implementors:No currently valid implementation will be made invalid by this proposal.Some implementors may wish to add error checks if they do not alreadyhave them.Cost to Users:Since this is a clarification and current implementations differ, thisissueostensibly does not affect current portable programs.Cost of non-adoption:The semantics of exits will remain ambiguous.Benefits:Common Lisp will be more precisely defined, and the precise definition willbe consistent with current practice in a way that has no cost forimplementorsnor for users.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:One aspect of this issue, namely the particular behavior of non-localexits from unwind protect cleanup clauses, was discussed at greatlength. Some of that discussion centered around the possibility ofcreating "unstoppable loops" that could not be exited by constructslike     (tagbody retry (unwind-protect ....  (go retry))). The goal of this proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation.  An alternative proposalwould define the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  That alternative wouldhave a cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal would duck theissue by outlawing all nonlocal exits from UNWIND-PROTECT cleanup forms.That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.CLtL never says in what dynamic environment cleanup forms ofUNWIND-PROTECT are executed.  The implementation note on p.142 may havebeen intended to cover this, but since it doesn't define the term"frame" that it uses, it doesn't actually say anything.  The extent ofdynamic-extent entities other than exits should be thesubject of a separate proposal.*start*00930 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 06 OCT 88 20:46:09 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472345; Thu 6-Oct-88 23:46:08 EDTDate: Thu, 6 Oct 88 23:45 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENT (Version 2)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Masinter.PAReferences: <881001-160630-2212@Xerox>,            <880914-230125-1950@Xerox>,            <19880907233254.5.MOON@EUPHRATES.SCRC.Symbolics.COM>,            <19880915171725.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <881006234555.8.KMP@BOBOLINK.SCRC.Symbolics.COM>Masinter says he asked if you could update some things in this and senda new version. I told him I'd bug you about it...*start*01052 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 06 OCT 88 21:28:45 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472360; Fri 7-Oct-88 00:28:57 EDTDate: Fri, 7 Oct 88 00:28 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENT (Version 2)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.PAIn-Reply-To: <881006234555.8.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19881007042828.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Thu, 6 Oct 88 23:45 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    Masinter says he asked if you could update some things in this and send    a new version. I told him I'd bug you about it...Yeah, yeah, I know.  I was going to do it tonight, but by the time I gotthat far I was too tired to undertake it.  It's on my list, and prettyclose to the top now.*start*09419 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 11:45:36 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  11:44:15 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472637; Fri 7-Oct-88 14:42:51 EDTDate: Fri, 7 Oct 88 14:42 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENT (Version 3)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <881001-160630-2212@Xerox>Message-ID: <19881007184224.3.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 1 Oct 88 16:06 PDT    From: masinter.pa@Xerox.COM        Sigh, I started to edit this....but I'm afraid it needs more work    than I have time for right now.Okay, here's a revision with some wording changes.  I included most ofyour edits, except for a few that simply messed up the formatting andone that was based on a misunderstanding.  I've made the terminologydefinitions much more explicit, and I hope much clearer.Issue:         EXIT-EXTENTReferences:    CATCH, THROW,               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).               Cleanup issue UNWIND-PROTECT-NON-LOCAL-EXIT is superseded               by this one.Category:      CLARIFICATIONEdit history:  Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvementsProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends.There are three cases of interest:(1) Normal exit from a CATCH, BLOCK, or TAGBODY, or equivalent such asPROG.  A normal exit occurs when the last form in the body of one ofthese constructs completes its evaluation without performing a transferof control.  (According to CLtL p.125, there is no possibility of anormal exit from DO.)(2) Nonlocal exit from the target of a THROW or RETURN.  A nonlocal exitoccurs when control is transferred by THROW, RETURN, or RETURN-FROM.The CATCH or BLOCK named in the THROW, RETURN, or RETURN-FROM isreferred to as the target.  The TAGBODY containing the tag named by aGO is also referred to as the target, but GO differs from the othernonlocal control transfer operators because GO does not exit its target.(3) Abandonment of an exit passed over by THROW, RETURN, or GO.  ACATCH, BLOCK, or TAGBODY that is dynamically nested inside the target ofa nonlocal transfer of control is said to be passed over when control istransferred to the target.  The target itself is not said to be passedover.The terms "normal exit", "target", and "passed over" will be used withthese meanings for the remainder of the discussion.CLtL is unambiguous about case 1.  In case 2, the extent could endanywhere from the time the THROW or RETURN commences, until the time thetransfer of control is completed.  In case 3, the extent could endanywhere from the time the THROW, RETURN, or GO commences, until thetime the transfer of control is completed.  In case 2, it is clear thatthe extent of the target ends before the transfer of control completes,since a block cannot be exited twice, but it is not made clear whetherthe extent ends before or after execution of UNWIND-PROTECT cleanupforms.  CLtL says nothing about case 3, although a note on p.38 impliesthat the extent of a passed-over exit should end no later than the endof the extent of the target exit.  It would make sense for the extentof an exit passed-over by GO to end no later than when the transfer ofcontrol is completed, but CLtL says nothing about this.Proposal (EXIT-EXTENT:MINIMAL):The dynamic extent of an exit, whether target or passed-over, ends assoon as the THROW, RETURN, or GO commences.  In the language of theimplementation note on p.142, the extent ends at the beginning of thesecond pass.  It is an error for an UNWIND-PROTECT cleanup form executedduring a nonlocal transfer of control to attempt to use an exit whosedynamic extent ended when the nonlocal transfer of control commenced.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL.Test Cases/Examples:Each of the following programs is an error:(funcall (block nil #'(lambda () (return))))            ;case 1(block nil                                              ;case 2  (unwind-protect (return)    (return)))(block a                                                ;case 3  (block b    (unwind-protect (return-from a)      (return-from b))))(let ((a nil))                                          ;case 1  (tagbody t (setq a #'(lambda () (go t))))  (funcall a))(funcall (block nil                                     ;case 3           (tagbody a (return #'(lambda () (go a))))))(catch nil                                              ;case 2  (unwind-protect (throw nil t)    (throw nil t)))(catch 'a                                               ;case 3  (catch 'b    (unwind-protect (throw 'a t)      (throw 'b t))))The above program is an error because the catch of b is passed over bythe first throw, hence portable programs must assume its dynamic extentis terminated.  The catch is not yet disestablished and therefore itis the target of the second throw.The following program is not an error.  It returns 10.  The innercatch of a is passed over, but this is not case 3 because that catchis disestablished before the throw to a is executed.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))))Rationale:Giving exits the smallest extent consistent with CLtL maximizes freedomfor implementations; there are few applications, if any, that require alonger extent.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target block or catch at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, the extent of a target exit lasts until theexit has been completed; in those implementations, it is possible for athrow or non-local exit to be effectively "stopped" by an UNWIND-PROTECTcleanup clause that performs a nonlocal transfer of control to apassed-over exit.Cost to Implementors:No currently valid implementation will be made invalid by this proposal.Some implementors may wish to add error checks if they do not alreadyhave them.Cost to Users:Since this is a clarification and current implementations differ, thisissue ostensibly does not affect current portable programs.Cost of non-adoption:The semantics of exits will remain ambiguous.Benefits:Common Lisp will be more precisely defined, and the precise definitionwill be consistent with current practice in a way that has no cost forimplementors nor for users.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:One aspect of this issue, namely the particular behavior of non-localexits from unwind protect cleanup clauses, was discussed at greatlength. Some of that discussion centered around the possibility ofcreating "unstoppable loops" that could not be exited, by constructslike     (tagbody retry (unwind-protect ....  (go retry)))The goal of this proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation.  An alternative proposalwould define the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  That alternative wouldhave a cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal would duck theissue by outlawing all nonlocal exits from UNWIND-PROTECT cleanup forms.That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.CLtL never says in what dynamic environment cleanup forms ofUNWIND-PROTECT are executed.  The implementation note on p.142 may havebeen intended to cover this, but since it doesn't define the term"frame" that it uses, it doesn't actually say anything.  The extent ofdynamic-extent entities other than exits should be thesubject of a separate proposal.*start*08914 00024 USfDate:  8 Oct 88 16:45 PDTSender: masinter.paSubject: Issue: EXIT-EXTENT (Version 3)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterI think it is unlikely that the cleanup committee willhave much more to say on the issue.Issue:         EXIT-EXTENTReferences:    CATCH, THROW,               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).               Cleanup issue UNWIND-PROTECT-NON-LOCAL-EXIT is superseded               by this one.Category:      CLARIFICATIONEdit history:  Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvementsProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends.There are three cases of interest:(1) Normal exit from a CATCH, BLOCK, or TAGBODY, or equivalent such asPROG.  A normal exit occurs when the last form in the body of one ofthese constructs completes its evaluation without performing a transferof control.  (According to CLtL p.125, there is no possibility of anormal exit from DO.)(2) Nonlocal exit from the target of a THROW or RETURN.  A nonlocal exitoccurs when control is transferred by THROW, RETURN, or RETURN-FROM.The CATCH or BLOCK named in the THROW, RETURN, or RETURN-FROM isreferred to as the target.  The TAGBODY containing the tag named by aGO is also referred to as the target, but GO differs from the othernonlocal control transfer operators because GO does not exit its target.(3) Abandonment of an exit passed over by THROW, RETURN, or GO.  ACATCH, BLOCK, or TAGBODY that is dynamically nested inside the target ofa nonlocal transfer of control is said to be passed over when control istransferred to the target.  The target itself is not said to be passedover.The terms "normal exit", "target", and "passed over" will be used withthese meanings for the remainder of the discussion.CLtL is unambiguous about case 1.  In case 2, the extent could endanywhere from the time the THROW or RETURN commences, until the time thetransfer of control is completed.  In case 3, the extent could endanywhere from the time the THROW, RETURN, or GO commences, until thetime the transfer of control is completed.  In case 2, it is clear thatthe extent of the target ends before the transfer of control completes,since a block cannot be exited twice, but it is not made clear whetherthe extent ends before or after execution of UNWIND-PROTECT cleanupforms.  CLtL says nothing about case 3, although a note on p.38 impliesthat the extent of a passed-over exit should end no later than the endof the extent of the target exit.  It would make sense for the extentof an exit passed-over by GO to end no later than when the transfer ofcontrol is completed, but CLtL says nothing about this.Proposal (EXIT-EXTENT:MINIMAL):The dynamic extent of an exit, whether target or passed-over, ends assoon as the THROW, RETURN, or GO commences.  In the language of theimplementation note on p.142, the extent ends at the beginning of thesecond pass.  It is an error for an UNWIND-PROTECT cleanup form executedduring a nonlocal transfer of control to attempt to use an exit whosedynamic extent ended when the nonlocal transfer of control commenced.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL.Test Cases/Examples:Each of the following programs is an error:(funcall (block nil #'(lambda () (return))))            ;case 1(block nil                                              ;case 2  (unwind-protect (return)    (return)))(block a                                                ;case 3  (block b    (unwind-protect (return-from a)      (return-from b))))(let ((a nil))                                          ;case 1  (tagbody t (setq a #'(lambda () (go t))))  (funcall a))(funcall (block nil                                     ;case 3           (tagbody a (return #'(lambda () (go a))))))(catch nil                                              ;case 2  (unwind-protect (throw nil t)    (throw nil t)))(catch 'a                                               ;case 3  (catch 'b    (unwind-protect (throw 'a t)      (throw 'b t))))The above program is an error because the catch of b is passed over bythe first throw, hence portable programs must assume its dynamic extentis terminated.  The catch is not yet disestablished and therefore itis the target of the second throw.The following program is not an error.  It returns 10.  The innercatch of a is passed over, but this is not case 3 because that catchis disestablished before the throw to a is executed.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))))Rationale:Giving exits the smallest extent consistent with CLtL maximizes freedomfor implementations; there are few applications, if any, that require alonger extent.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target block or catch at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, the extent of a target exit lasts until theexit has been completed; in those implementations, it is possible for athrow or non-local exit to be effectively "stopped" by an UNWIND-PROTECTcleanup clause that performs a nonlocal transfer of control to apassed-over exit.Cost to Implementors:No currently valid implementation will be made invalid by this proposal.Some implementors may wish to add error checks if they do not alreadyhave them.Cost to Users:Since this is a clarification and current implementations differ, thisissue ostensibly does not affect current portable programs.Cost of non-adoption:The semantics of exits will remain ambiguous.Benefits:Common Lisp will be more precisely defined, and the precise definitionwill be consistent with current practice in a way that has no cost forimplementors nor for users.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:One aspect of this issue, namely the particular behavior of non-localexits from unwind protect cleanup clauses, was discussed at greatlength. Some of that discussion centered around the possibility ofcreating "unstoppable loops" that could not be exited, by constructslike     (tagbody retry (unwind-protect ....  (go retry)))The goal of this proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation.  An alternative proposalwould define the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  That alternative wouldhave a cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal would duck theissue by outlawing all nonlocal exits from UNWIND-PROTECT cleanup forms.That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.CLtL never says in what dynamic environment cleanup forms ofUNWIND-PROTECT are executed.  The implementation note on p.142 may havebeen intended to cover this, but since it doesn't define the term"frame" that it uses, it doesn't actually say anything.  The extent ofdynamic-extent entities other than exits should be thesubject of a separate proposal.        TITAN 
         TITAN 
          6                                                                                               d                           U                                          0       
                    c             B      !m z*start*01336 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:49:51 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:49:54 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475845; Thu 13-Oct-88 16:48:32 EDTDate: Thu, 13 Oct 88 16:48 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENT (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013164824.7.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Deferred for everyone to have time to study it more.X3J13 meeting: RWK: Proposal is not readable.      for example, but not exclusively, there's a phrase      "when the value is returned" which is used where it isn't clear      which of several times might be being referred to (before, during,      or after). Sandra: Couldn't read the problem description. Barmar: Supports this proposal. Considerable concern among numerous people about relation of this to UNWIND-PROTECT-NON-LOCAL-EXIT and why the proposal accompanying that has no relation to the proposal accompanying this.*start*01419 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:54:26 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:54:22 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA19676; Thu, 13 Oct 88 14:52:46 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19858; Thu, 13 Oct 88 14:52:43 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132052.AA19858@defun.utah.edu>Date: Thu, 13 Oct 88 14:52:42 MDTSubject: issue EXIT-EXTENTTo: cl-cleanup@sail.stanford.eduI don't understand the "problem description" section of this proposalwell enough to comment on the remainder.  Specifically.... (1) I don't understand what the phrase "extent of an exit" means, orwhat it means for the extent to end.  Could you put in a paragraph orso at the beginning to explain this further? (2) Please give examples of each of the three situations.  I know thereare some in the test cases section, but those are all error situations.Are there any non-error situations?(3) If CLtL is unambiguous about case 1, please state how it resolvesthe problem because it's not obvious to me.If I'm having so much trouble understanding this, I really hate to thinkof how confused naive readers of the standard are going to be.  -Sandra-------*start*02601 00024 USaReturn-Path: <sandra%defun@cs.utah.edu>Received: from cs.utah.edu ([128.110.4.21]) by Xerox.COM ; 31 OCT 88 13:59:50 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.0-cs)	id AA04617; Mon, 31 Oct 88 14:58:31 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA02796; Mon, 31 Oct 88 14:58:28 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810312158.AA02796@defun.utah.edu>Date: Mon, 31 Oct 88 14:58:26 MSTSubject: Re: issue EXIT-EXTENTTo: masinter.paCc: sandra%defun@cs.ARPA (Sandra J Loosemore), cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM, 31 Oct 88 12:25 PSTOK, it's starting to make some sense now.  I think the thing that wasconfusing me the most was the use of the noun "exit" to refer to thething that is being exited *from*, while I was interpreting it as itsdictionary definition as "the act of leaving".  Things would be muchmore understandable if the writeup avoided this terminology and justtalked about the dynamic extent of CATCH, BLOCK, and TAGBODY forms.Now that I think I understand the proposal, I see a serious problem.In the implementation I did for the Atari ST, UNWIND-PROTECT cleanupforms are executed with all outer CATCHes still in place.  It seems tome like this falls into the category of the second paragraph in the"Current Practice" section, and that this is legal according to CLtL.Consider the case:(defun test ()    (catch 'foo	(format t "The inner catch returns ~s.~%"		(catch 'foo		    (unwind-protect (throw 'foo :first-throw)			(throw 'foo :second-throw))))	:outer-catch))In my implementation, the THROW in the cleanup form of theUNWIND-PROTECT happens when the inner CATCH (that is the target of thefirst throw) is still in effect.  This means that the inner catchreturns :SECOND-THROW and the outer CATCH returns :OUTER-CATCH.  (Thisis also the behavior exhibited by Lucid.)However, under the proposal EXIT-EXTENT:MINIMAL, the dynamic extent ofthe inner CATCH must end as soon as the first THROW begins.  Thereforethe target of the second THROW must be the outer CATCH.  According tothis proposal, the inner CATCH would never return and the outer onemust return :SECOND-THROW.  Right? This leads me to conclude that in spite of what the "Cost toImplementors" section says, currently valid implementations *will* bemade invalid by this proposal, and that it would not be legitimate forimplementations to implement longer extents (as mentioned in the"Esthetics" section).  Or am I still misunderstanding something?-Sandra-------*start*00851 00024 US Date: 31 Oct 88 14:47 PSTFrom: masinter.paSubject: Re: issue EXIT-EXTENTIn-reply-to: sandra%defun@cs.utah.edu (Sandra J Loosemore)'s message of Mon, 31 Oct 88 14:58:26 MSTTo: sandra%defun@cs.utah.edu (Sandra J Loosemore)cc: masinter.pa, sandra%defun@cs.ARPA (Sandra J Loosemore), cl-cleanup@sail.stanford.eduThe proposal would separate the extent of the visibility of the CATCH tag from the actual extent of the exit. The CATCH tag would still be visible to the THROW inside the UNWIND-PROTECT cleanup clause, it would merely be an "error" to execute that THROW. This is similar to the situation with BLOCK tags, where(FUNCALL (BLOCK FOO #'(LAMBDA () (RETURN-FROM FOO 3))))is an error because, while the scope FOO in the RETURN-FROM allows the FOO returned from to name the one in the BLOCK, the extent has ended.*start*02991 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 31 OCT 88 19:00:57 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 31 Oct 88  18:43:27 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 31 OCT 88 12:25:55 PSTDate: 31 Oct 88 12:25 PSTFrom: masinter.paSubject: Re: issue EXIT-EXTENTIn-reply-to: sandra%defun@cs.utah.edu (Sandra J Loosemore)'s message of Thu, 13 Oct 88 14:52:42 MDTTo: sandra%defun@cs.utah.edu (Sandra J Loosemore)cc: cl-cleanup@sail.stanford.eduMessage-ID: <881031-122555-6154@Xerox>I think it is unfortunately the case that my original estimate "I think it is unlikely that the cleanup committee willhave much more to say on the issue." is unfortunately untrue.I'll try to answer your questions, and hope that I can get a volunteer other than myself to produce a new writeup.(1) What does "extent of an exit" mean?An "exit" is something you can RETURN from, or that GO implicitly canreturn from, or that THROW will return from. So its either a BLOCK body, atop level form of a TAGBODY, or a CATCH.  CLtL makes it clear that "exit"shave dynamic extent. For example, attempting to funcall the value of  (block frob #'(lambda () (return-from frob 3)) ) )is an error, in that the "extent" the block  to which the return-fromreturns from has elapsed since the block has been exited. On the otherhand,(block frob (let ((a #'(lambda () (return-from frob 3)))) (funcall a )))is not an error; the extent of the frob block has not elapsed when thereturn-from is invoked.The ambiguity only arised because of unwind-protect. (I can't think of anyother situations, although the condition proposal might introduce someunwind-protect equivalents.)While "exits" have dynamic extent,  the exact boundary of when that dynamicextent ends is fuzzy, primarily because of UNWIND-PROTECT.Given a block (block frob ...) which contains a (return-from frob ...) init, we normally think of (return-from frob ...) as a "instantaneous"operation. However, if there's an UNWIND-PROTECT in between, user code anexecute between the "start" of (RETURN-FROM FROB ...) and when the (BLOCKFROB ...) is actually exited. Is the extent of (BLOCK FROB ...) over when(RETURN-FROM FROB ...) starts, or is it over when it ends? If the extent is over only when the block is exited, then the followingcases would *not* be an error:(block nil                                              ;case 2  (unwind-protect (return)    (return)))(block a                                                ;case 3  (block b    (unwind-protect (return-from a)      (return-from b))))(catch nil                                              ;case 2  (unwind-protect (throw nil t)    (throw nil t)))(catch 'a                                               ;case 3  (catch 'b    (unwind-protect (throw 'a t)      (throw 'b t))))*start*01325 00024 US Return-Path: <sandra%defun@cs.utah.edu>Received: from cs.utah.edu ([128.110.4.21]) by Xerox.COM ; 31 OCT 88 15:17:36 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.0-cs)	id AA07883; Mon, 31 Oct 88 16:17:18 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA02896; Mon, 31 Oct 88 16:17:14 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810312317.AA02896@defun.utah.edu>Date: Mon, 31 Oct 88 16:17:12 MSTSubject: Re: issue EXIT-EXTENTTo: masinter.paCc: sandra%defun@cs.ARPA (Sandra J Loosemore), cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM, 31 Oct 88 14:47 PST> Date: 31 Oct 88 14:47 PST> From: masinter.pa@Xerox.COM> > The proposal would separate the extent of the visibility of the CATCH tag> from the actual extent of the exit. The CATCH tag would still be visible to> the THROW inside the UNWIND-PROTECT cleanup clause, it would merely be an> "error" to execute that THROW.That doesn't seem very satisfying or useful.  My reading of theproposal is that the dynamic extent of the CATCH definitely ends assoon as the THROW commences.  If the intent is really to make it "anerror" to depend on this behavior, then why doesn't the proposal justsay that the dynamic extent of the CATCH is unspecified?-Sandra-------*start*05818 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 21:23:17 PSTReceived: from ECLC.USC.EDU by SAIL.Stanford.EDU with TCP; 10 Nov 88  21:21:02 PSTDate: Thu, 10 Nov 88 12:42:59 PSTFrom: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>Subject: Issue: EXIT-EXTENTTo: cl-cleanup@SAIL.STANFORD.EDUcc: iim%ECLA@ECLC.USC.EDUMessage-ID: <12445512677.29.IIM@ECLA.USC.EDU>I have several problems with the proposal for this issue.  Date: 31 Oct 88 12:25 PST  From: masinter.pa@Xerox.COM    ...  The ambiguity only arised because of unwind-protect.Agreed.    ...  Given a block (block frob ...) which contains a (return-from frob ...) in it,  we normally think of (return-from frob ...) as a "instantaneous" operation.I don't agree with this at all.  I have never thought of the invocation of anexit to be an "instantaneous" operation, due to the possible presence ofunwind-protects.  This part of my mental model for Lisp execution dates to wellbefore I ever got involved in implementation, so I don't think it is biased byany particular implementation.  If I had encountered the behavior SymbolicsGenera exhibits without having seen the proposal, I would have submitted a bugreport.     ...  If the extent is over only when the block is exited, then the following cases  would *not* be an error:     < several examples >This is the interpretation which I believe is correct.  The extent of an objectwith dynamic extent is the extent of the form which created it.  Code which isexecuted "within" that form is within the extent of the object(s).  Thisapplies to all dynamic objects, such as special variable bindings, not justexits.  Actually, I think the intent of the implementation note on p.142 isfairly clear and supports this interpretation.  The supposedly ambiguoususe of "frame" should be read as something like "form which establishes adynamic extent".  It might be clearer if the last sentence were changed toread something like:"On the second pass the stack is actually unwound.  Each form which establishesa dynamic extent is undone in reverse order of creation until the matchingcatch is reached.  The meaning of undoing a form depends on the type of form.For unwind-protect, it means executing the cleanup forms.  For catch it meansremoving the catch tag.  For dynamic bindings it means undoing the binding,restoring the previous saved value. {This is not an exhaustive listing of thepossibilities.}"One of the alternatives mentioned in the proposal would be to "duck the issueby outlawing all nonlocal exits from UNWIND-PROTECT cleanup forms".  As noted,this alternative might have a substantial cost to some users.  However, itseems to me that the proposal just about collapses to this alternative, sincethere is in general no way to determine the target of the nonlocal exit, so thecleanup forms usually cannot safely do any nonlocal exits without extra code toin some way record the target.  In fact, in many implementations, due to thepresence of things like ABORT interrupts and such, it is probably almostimpossible to be certain of the target for a nonlocal exit.I find it disturbing that the current dynamic environment of a cleanup formdepends on how the unwind-protect was exited.  This problem is even moreapparent if you extend the proposal to also apply to special variable bindingsin a manner similar to the way catch is specified in the proposal.  (Of course,doing so would violate the implementation note on p.142).  I don't think youcan talk about the dynamic extent of exits in the way the proposal does withoutalso talking about the dynamic extent of other forms under the same situations.And I think if you extend the proposal to other forms, the results begin tolook more and more strange.  For example,    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect (return)          (print x))))				;is this an error?    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect            (if (test) (return))          (print x))))				;is this an error?In the first example, if the dynamic extent of special variables is similar tocatchers, then under the proposal it is an error.  Similarly, in the secondexample it is an error if (test) returns true, but might be ok if (test)returns false.  It demonstrates an example of the problem I mentioned earlier,of determining what things are dynamically available in the unwind-protectcleanup forms.And now for a slightly less contrived example which would probably be in errorunder the proposal.  This is boiled down to mostly the essentials to keep fromcluttering it up, but I think it should be apparent that this is not a totallyunreasonable code fragment.    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).I understand the desire expressed in the proposal to avoid changing thelanguage in a way which invalidates certain implementation techniques, andagree wholeheartedly with this desire.  However, I believe that the proposalis in fact a change, rather than a clarification (as the proposal claims), andthat it is a change for the worse.kab-------*start*14883 00024 USfDate:  7 Dec 88 20:42 PSTFrom: masinter.paSubject: Issue: EXIT-EXTENT (Version 4)To: cl-cleanup@sail.stanford.educc: sandra%defun@cs.utah.edu, Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>line-fold: NOcc: MasinterMy previous attempt at merging the alternate proposals forSETF-FUNCTION-VS-MACRO and SETF-PLACES aroused some ire.Undaunted, this is my attempt to merge EXIT-EXIT andUNWIND-PROTECT-NON-LOCAL-EXIT into one Issue with twoproposals. I've tried to respond to and incorporatethe comments from Sandra Loosemore and Kim Barrett.Issue:         EXIT-EXTENTReferences:    CATCH, THROW,               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded                by this one.Category:      CLARIFICATIONEdit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...               Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvements               Version 4,  7-Dec-88, by Masinter, add MEDIUM from					UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.Problem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends. For example, at what point is it no longer possible to RETURN-FROMa particular BLOCK?(Terminology: In this issue writeup, the noun "exit" isrefera to the thing that can be exited from, rather than theact of exiting. When the extent of an exit has ended, it isno longer legal to exit from it. This is different fromthe scope of the exit. For example, a BLOCK has lexicalscope but dynamic extent; a the scope of a CATCH--the visibility of the CATCH tag to corresponding THROWs--could differ from the extent of the CATCH.)The problem arises when there are nonlocal exits from the "cleanup" clauses of an UNWIND-PROTECT.There are three cases of interest:(1) Normal exit from a CATCH, BLOCK, or TAGBODY, or equivalent such asPROG.  A normal exit occurs when the last form in the body of one ofthese constructs completes its evaluation without performing a transferof control.(2) Nonlocal exit from the target of a THROW or RETURN.  A nonlocal exitoccurs when control is transferred by THROW, RETURN, or RETURN-FROM.The CATCH or BLOCK named in the THROW, RETURN, or RETURN-FROM isreferred to as the target.  The TAGBODY containing the tag named by aGO is also referred to as the target, but GO differs from the othernonlocal control transfer operators because GO does not exit its target.For example,(3) Abandonment of an exit passed over by THROW, RETURN, or GO.  ACATCH, BLOCK, or TAGBODY that is dynamically nested inside the target ofa nonlocal transfer of control is said to be passed over when control istransferred to the target.  The target itself is not said to be passedover.For example, in   (block testem      (when (zilched) (return-from testem nil))      (when (zorked) (throw 'uh-oh))      (format t "Neither zilched nor zorked."))if (zilched) returns true, the block testem is exited via a 'nonlocal exit'. If (zorked) returns true, the block testemis 'passed over'. Otherwise, the block is exited normally.The terms "normal exit", "target", and "passed over" will be used withthese meanings for the remainder of the discussion.CLtL is unambiguous about case 1.  In case 2, the extent could endanywhere from the time the THROW or RETURN commences, until the time thetransfer of control is completed.  In case 3, the extent could endanywhere from the time the THROW, RETURN, or GO commences, until thetime the transfer of control is completed.  In case 2, it is clear thatthe extent of the target ends before the transfer of control completes,since a block cannot be exited twice, but it is not made clear whetherthe extent ends before or after execution of UNWIND-PROTECT cleanupforms.  CLtL says nothing about case 3, although a note on p.38 impliesthat the extent of a passed-over exit should end no later than the endof the extent of the target exit.  It would make sense for the extentof an exit passed-over by GO to end no later than when the transfer ofcontrol is completed, but CLtL says nothing about this.Proposal (EXIT-EXTENT:MINIMAL):The dynamic extent of an exit, whether target or passed-over, ends assoon as the THROW, RETURN, or GO commences.  In the language of theimplementation note on p.142, the extent ends at the beginning of thesecond pass.  It is an error for an UNWIND-PROTECT cleanup form executedduring a nonlocal transfer of control to attempt to use an exit whosedynamic extent ended when the nonlocal transfer of control commenced.Note that this does not affect the extent of the binding of CATCHtags; that is, under this proposal, a THROW to a CATCH which wasalready in the process of being exited would be an error.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL.Proposal (EXIT-EXTENT:MEDIUM):The dynamic extent of an exit, whether target or passed-over, endsonly after the exit is complete. A transfer of control from within an UNWIND-PROTECT cleanup formto a point outside of the UNWIND-PROTECT causes the original controltransfer which initiated the execution of the cleanup forms to beabandonded.During the execution of the cleanup forms of an UNWIND-PROTECT anon-local exit to a point outside of the scope of the UNWIND-PROTECT,but still within the dynamic scope of of the target of the originalnon-local exit succeeds, and the original pending exit is discarded.Where an UNWIND-PROTECT cleanup form attempts a non-local exit to apoint outside the original non-local exit, control is passed to theouter exit (and the pending original non-local exit is discarded.) In no case will UNWIND-PROTECT cleanup forms ever be attempted morethan once.Examples:Each of the following programs are an error under eitherproposal:;; Error: BLOCK has normal exit before RETURN(funcall (block nil #'(lambda () (return))));; Error: normal exit before GO(let ((a nil))   (tagbody t (setq a #'(lambda () (go t))))  (funcall a));; Error: TAGBODY is passed over, before GO(funcall (block nil           (tagbody a (return #'(lambda () (go a))))))Each of these programs are an error under MINIMAL, butnot under MEDIUM:;;returns 2 under MEDIUM, is error under MINIMAL(block nil     (unwind-protect (return 1)    (return 2)));;returns 2 under MEDIUM, is error under MINIMAL(block a      (block b    (unwind-protect (return-from a 1)      (return-from b 2))));; returns 2 under MEDIUM, is error under MINIMAL(catch nil   (unwind-protect (throw nil 1)    (throw nil 2)));; returns 2 under MEDIUM, is error under MINIMAL(catch 'a  (catch 'b    (unwind-protect (throw 'a 1)      (throw 'b 2))));; An error under MINIMAL because the catch of b is passed over by;; the first throw, hence portable programs must assume its dynamic extent;; is terminated.  The catch is not yet disestablished and therefore it;; is the target of the second throw.;; the following is an error under MINIMAL; the extent of the;; inner catch terminates as soon as the throw commences, even;; though it remains in scope. Thus, the throw of :second-throw;; sees the inner catch, but its extent has ended.;; under MEDIUM, it prints "The inner catch returns :second-throw";; and then returns :outer-catch.(catch 'foo	(format t "The inner catch returns ~s.~%"		(catch 'foo		    (unwind-protect (throw 'foo :first-throw)			(throw 'foo :second-throw))))	:outer-catch))The following program is not an error.  It returns 10.  The innercatch of a is passed over, but this is not case 3 because that catchis disestablished before the throw to a is executed.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))))The following cases are errors under MINIMAL, and havethe following interpretation under MEDIUM:In     (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))the pending exit to tag FOO is discarded by the second THROW to BAR and the value 4 is transfered to (CATCH 'BAR ...),which returns 4. The (CATCH 'FOO ...) then returns the 4because its first argument has returned normally.XXX is not printed.In     (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . It is not an error, even though the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW to FOO.Rationale:For MINIMAL: Giving exits the smallest extent consistent with CLtLmaximizes freedom for implementations; there are few applications,if any, that require a longer extent.For MEDIUM: Giving exits a longer exent has cleaner semantics.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target block or catch at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, the extent of a target exit lasts until theexit has been completed; in those implementations, it is possible for athrow or non-local exit to be effectively "stopped" by an UNWIND-PROTECTcleanup clause that performs a nonlocal transfer of control to apassed-over exit.Some implementations crash or otherwise generate garbage code fornon-local exits from cleanup clauses of UNWIND-PROTECT.Cost to Implementors:No currently valid implementation will be made invalid by the MINIMALproposal. Some implementors may wish to add error checks if theydo not already have them.MEDIUM would have a high cost for those implementations that currentlyhave shorter exent.Cost to Users:Most user programs don't do this, so there is likely little costof converting existing code in any case. In any case, current implementationsdiffer enough that this issue ostensibly does notaffect current portable programs. Some users might have code thatrelies on the "unstoppable loops" that can be created with the MEDIUMproposal.Benefits:Either proposal would make Common Lisp more precisely defined.Cost of non-adoption :The semantics of exits will remain ambiguous.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:This issue is controversial. It was first discussed under the issue named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast asthe more global one of "extent of exits" rather than the specific one of "what happens if a cleanup in an UNWIND-PROTECT does a non-local exit", but the problem cases for both topics are the same.The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation. The MEDIUM proposaldefines the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  It hasa cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal, not consideredhere, would duck the issue by outlawing all nonlocal exits from UNWIND-PROTECTcleanup forms. That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.An argument for the MEDIUM proposal was made based on the example:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangably,calling this an error would be inappropriate. It was argued that the MINIMAL proposal is equivalent to practicallyoutlawing non-local exits from UNWIND-PROTECT cleanup clauses, becausethere is no general way to determine the target of the nonlocal exitthat caused the cleanup clause to be invoked. CLtL never says in what dynamic environment cleanup forms ofUNWIND-PROTECT are executed.  The implementation note on p.142 may havebeen intended to cover this, but since it doesn't define the term"frame" that it uses, it doesn't actually say anything.  The extent ofdynamic-extent entities other than exits should be thesubject of a separate proposal. It was argued that the likelyresolution of those issues would be more consistent with theMEDIUM proposal than MINIMAL.The following example was offered as an argument against MINIMAL. Given:    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).        TITAN 
         TITAN 
          "                           h              J                           l             0                            f                           -                           b             h             k                                                      U       
       A              1             c             
l      8@ -z*start*14788 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 21:07:22 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Dec 88  20:58:42 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 07 DEC 88 20:42:42 PSTDate: 7 Dec 88 20:42 PSTFrom: masinter.paSubject: Issue: EXIT-EXTENT (Version 4)To: cl-cleanup@sail.stanford.educc: sandra%defun@cs.utah.edu, Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>line-fold: NOcc: Masinter.paMessage-ID: <881207-204242-2654@Xerox>My previous attempt at merging the alternate proposals forSETF-FUNCTION-VS-MACRO and SETF-PLACES aroused some ire.Undaunted, this is my attempt to merge EXIT-EXIT andUNWIND-PROTECT-NON-LOCAL-EXIT into one Issue with twoproposals. I've tried to respond to and incorporatethe comments from Sandra Loosemore and Kim Barrett.!Issue:         EXIT-EXTENTReferences:    CATCH, THROW,               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded                by this one.Category:      CLARIFICATIONEdit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...               Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvements               Version 4,  7-Dec-88, by Masinter, add MEDIUM from					UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.Problem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends. For example, at what point is it no longer possible to RETURN-FROMa particular BLOCK?(Terminology: In this issue writeup, the noun "exit" isrefera to the thing that can be exited from, rather than theact of exiting. When the extent of an exit has ended, it isno longer legal to exit from it. This is different fromthe scope of the exit. For example, a BLOCK has lexicalscope but dynamic extent; a the scope of a CATCH--the visibility of the CATCH tag to corresponding THROWs--could differ from the extent of the CATCH.)The problem arises when there are nonlocal exits from the "cleanup" clauses of an UNWIND-PROTECT.There are three cases of interest:(1) Normal exit from a CATCH, BLOCK, or TAGBODY, or equivalent such asPROG.  A normal exit occurs when the last form in the body of one ofthese constructs completes its evaluation without performing a transferof control.(2) Nonlocal exit from the target of a THROW or RETURN.  A nonlocal exitoccurs when control is transferred by THROW, RETURN, or RETURN-FROM.The CATCH or BLOCK named in the THROW, RETURN, or RETURN-FROM isreferred to as the target.  The TAGBODY containing the tag named by aGO is also referred to as the target, but GO differs from the othernonlocal control transfer operators because GO does not exit its target.For example,(3) Abandonment of an exit passed over by THROW, RETURN, or GO.  ACATCH, BLOCK, or TAGBODY that is dynamically nested inside the target ofa nonlocal transfer of control is said to be passed over when control istransferred to the target.  The target itself is not said to be passedover.For example, in   (block testem      (when (zilched) (return-from testem nil))      (when (zorked) (throw 'uh-oh))      (format t "Neither zilched nor zorked."))if (zilched) returns true, the block testem is exited via a 'nonlocal exit'. If (zorked) returns true, the block testemis 'passed over'. Otherwise, the block is exited normally.The terms "normal exit", "target", and "passed over" will be used withthese meanings for the remainder of the discussion.CLtL is unambiguous about case 1.  In case 2, the extent could endanywhere from the time the THROW or RETURN commences, until the time thetransfer of control is completed.  In case 3, the extent could endanywhere from the time the THROW, RETURN, or GO commences, until thetime the transfer of control is completed.  In case 2, it is clear thatthe extent of the target ends before the transfer of control completes,since a block cannot be exited twice, but it is not made clear whetherthe extent ends before or after execution of UNWIND-PROTECT cleanupforms.  CLtL says nothing about case 3, although a note on p.38 impliesthat the extent of a passed-over exit should end no later than the endof the extent of the target exit.  It would make sense for the extentof an exit passed-over by GO to end no later than when the transfer ofcontrol is completed, but CLtL says nothing about this.!Proposal (EXIT-EXTENT:MINIMAL):The dynamic extent of an exit, whether target or passed-over, ends assoon as the THROW, RETURN, or GO commences.  In the language of theimplementation note on p.142, the extent ends at the beginning of thesecond pass.  It is an error for an UNWIND-PROTECT cleanup form executedduring a nonlocal transfer of control to attempt to use an exit whosedynamic extent ended when the nonlocal transfer of control commenced.Note that this does not affect the extent of the binding of CATCHtags; that is, under this proposal, a THROW to a CATCH which wasalready in the process of being exited would be an error.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL.Proposal (EXIT-EXTENT:MEDIUM):The dynamic extent of an exit, whether target or passed-over, endsonly after the exit is complete. A transfer of control from within an UNWIND-PROTECT cleanup formto a point outside of the UNWIND-PROTECT causes the original controltransfer which initiated the execution of the cleanup forms to beabandonded.During the execution of the cleanup forms of an UNWIND-PROTECT anon-local exit to a point outside of the scope of the UNWIND-PROTECT,but still within the dynamic scope of of the target of the originalnon-local exit succeeds, and the original pending exit is discarded.Where an UNWIND-PROTECT cleanup form attempts a non-local exit to apoint outside the original non-local exit, control is passed to theouter exit (and the pending original non-local exit is discarded.) In no case will UNWIND-PROTECT cleanup forms ever be attempted morethan once.!Examples:Each of the following programs are an error under eitherproposal:;; Error: BLOCK has normal exit before RETURN(funcall (block nil #'(lambda () (return))));; Error: normal exit before GO(let ((a nil))   (tagbody t (setq a #'(lambda () (go t))))  (funcall a));; Error: TAGBODY is passed over, before GO(funcall (block nil           (tagbody a (return #'(lambda () (go a))))))Each of these programs are an error under MINIMAL, butnot under MEDIUM:;;returns 2 under MEDIUM, is error under MINIMAL(block nil     (unwind-protect (return 1)    (return 2)));;returns 2 under MEDIUM, is error under MINIMAL(block a      (block b    (unwind-protect (return-from a 1)      (return-from b 2))));; returns 2 under MEDIUM, is error under MINIMAL(catch nil   (unwind-protect (throw nil 1)    (throw nil 2)));; returns 2 under MEDIUM, is error under MINIMAL(catch 'a  (catch 'b    (unwind-protect (throw 'a 1)      (throw 'b 2))));; An error under MINIMAL because the catch of b is passed over by;; the first throw, hence portable programs must assume its dynamic extent;; is terminated.  The catch is not yet disestablished and therefore it;; is the target of the second throw.;; the following is an error under MINIMAL; the extent of the;; inner catch terminates as soon as the throw commences, even;; though it remains in scope. Thus, the throw of :second-throw;; sees the inner catch, but its extent has ended.;; under MEDIUM, it prints "The inner catch returns :second-throw";; and then returns :outer-catch.(catch 'foo	(format t "The inner catch returns ~s.~%"		(catch 'foo		    (unwind-protect (throw 'foo :first-throw)			(throw 'foo :second-throw))))	:outer-catch))The following program is not an error.  It returns 10.  The innercatch of a is passed over, but this is not case 3 because that catchis disestablished before the throw to a is executed.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))))The following cases are errors under MINIMAL, and havethe following interpretation under MEDIUM:In     (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))the pending exit to tag FOO is discarded by the second THROW to BAR and the value 4 is transfered to (CATCH 'BAR ...),which returns 4. The (CATCH 'FOO ...) then returns the 4because its first argument has returned normally.XXX is not printed.In     (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . It is not an error, even though the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW to FOO.Rationale:For MINIMAL: Giving exits the smallest extent consistent with CLtLmaximizes freedom for implementations; there are few applications,if any, that require a longer extent.For MEDIUM: Giving exits a longer exent has cleaner semantics.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target block or catch at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, the extent of a target exit lasts until theexit has been completed; in those implementations, it is possible for athrow or non-local exit to be effectively "stopped" by an UNWIND-PROTECTcleanup clause that performs a nonlocal transfer of control to apassed-over exit.Some implementations crash or otherwise generate garbage code fornon-local exits from cleanup clauses of UNWIND-PROTECT.Cost to Implementors:No currently valid implementation will be made invalid by the MINIMALproposal. Some implementors may wish to add error checks if theydo not already have them.MEDIUM would have a high cost for those implementations that currentlyhave shorter exent.Cost to Users:Most user programs don't do this, so there is likely little costof converting existing code in any case. In any case, current implementationsdiffer enough that this issue ostensibly does notaffect current portable programs. Some users might have code thatrelies on the "unstoppable loops" that can be created with the MEDIUMproposal.Benefits:Either proposal would make Common Lisp more precisely defined.Cost of non-adoption :The semantics of exits will remain ambiguous.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:This issue is controversial. It was first discussed under the issue named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast asthe more global one of "extent of exits" rather than the specific one of "what happens if a cleanup in an UNWIND-PROTECT does a non-local exit", but the problem cases for both topics are the same.The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation. The MEDIUM proposaldefines the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  It hasa cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal, not consideredhere, would duck the issue by outlawing all nonlocal exits from UNWIND-PROTECTcleanup forms. That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.An argument for the MEDIUM proposal was made based on the example:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangably,calling this an error would be inappropriate. It was argued that the MINIMAL proposal is equivalent to practicallyoutlawing non-local exits from UNWIND-PROTECT cleanup clauses, becausethere is no general way to determine the target of the nonlocal exitthat caused the cleanup clause to be invoked. CLtL never says in what dynamic environment cleanup forms ofUNWIND-PROTECT are executed.  The implementation note on p.142 may havebeen intended to cover this, but since it doesn't define the term"frame" that it uses, it doesn't actually say anything.  The extent ofdynamic-extent entities other than exits should be thesubject of a separate proposal. It was argued that the likelyresolution of those issues would be more consistent with theMEDIUM proposal than MINIMAL.The following example was offered as an argument against MINIMAL. Given:    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).*start*02065 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 17:46:28 PSTReceived: from RELAY.CS.NET (GW1.CS.NET) by SAIL.Stanford.EDU with TCP; 8 Dec 88  17:44:47 PSTReceived: from relay2.cs.net by RELAY.CS.NET id ad05194; 8 Dec 88 17:10 ESTReceived: from draper.com by RELAY.CS.NET id aa00694; 8 Dec 88 16:18 ESTDate: Thu, 8 Dec 88 14:24 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: EXIT-EXTENT (Version 4)To: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525I am strongly in favor of EXIT-EXTENT:MEDIUM, since this is how my implementation works.  Normally that would not be reason enough, but theimplementational details are not limited to THROW's stack-combing.  GO andRETURN-FROM in compiled code, for example, in conjunction with CATCH andUNWIND-PROTECT, require a lot of careful planning to unwind the correctexit environments, which is done in a semi-static way for maximumefficiency - no THROWing around underlying tags here!   I don't agree with your statement that "all currently valid implementationswill continue to be valid with the MINIMAL proposal", or whatever it wasthat you said.  Perhaps that is true in a very limited sense - i.e. thatif it "is an error" to THROW out of a cleanup form in one of those screw-case examples, having the implementation do the "other" thing isone manifestation of "is an error"... but what about cases where thereis a further-outlying environment which can get exited to?  Or is thetalk about a CATCH tag being valid but inactivated, like a BLOCK name.supposed to prevent any nonlocal exit from a cleanup form from everworking without error?  In any case, I have a lot of trouble with thenotion of an inactive CATCH tag, both conceptually and implementationally. Please clarfify:  If an implementation conforms to EXIT-EXTENT:MEDIUM, thenif EXIT-EXTENT:MINIMAL is adopted will said implementation be correct orin error?*start*01702 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 21:17:41 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  21:16:22 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 DEC 88 21:15:37 PSTDate: 8 Dec 88 21:15 PSTFrom: masinter.paSubject: Re: Issue: EXIT-EXTENT (Version 4)In-reply-to: "Steve Bacher (Batchman)" <SEB1525@draper.com>'s message of Thu, 8 Dec 88 14:24 ESTTo: "Steve Bacher (Batchman)" <SEB1525@draper.com>cc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <881208-211537-5338@Xerox>I was pretty sure I could derive "If an implementation conforms toEXIT-EXTENT:MEDIUM, thenif EXIT-EXTENT:MINIMAL is adopted will said implementation be correct orin error?" from "all currently valid implementationswill continue to be valid with the MINIMAL proposal".My derivation presumes that MEDIUM is already currently valid, which I caninfer from the "Cost to users" section.We have and will continue to take "is an error" in the narrow sense thatall bets are off, that the standard makes no constraints on whatimplementations do in such a situation, and that no valid program will dosuch a thing. This has been an assumption in most of the cleanups.Do you think we need a new writeup? How should it change?I was thinking I could add to "All currently valid implementationswill continue to be valid with the MINIMAL proposal." the assertion thatthis includes implementations that conform to MEDIUM. I'm running out of time to produce new versions of writeups; does this needchange to be clear to people voting on it?*start*00695 00024 US Return-Path: <@RELAY.CS.NET:SEB1525@draper.com>Received: from RELAY.CS.NET ([10.4.0.5]) by Xerox.COM ; 09 DEC 88 08:39:47 PSTReceived: from relay2.cs.net by RELAY.CS.NET id cj18256; 9 Dec 88 9:17 ESTReceived: from draper.com by RELAY.CS.NET id ac07191; 9 Dec 88 8:21 ESTDate: Fri, 9 Dec 88 08:23 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: RE: Re: Issue: EXIT-EXTENT (Version 4)To: masinter.paX-VMS-To: IN%"masinter.pa@XEROX.COM",SEB1525I think that, yes, it would be better explicitly to say that "All..."includes implementations that conform to MEDIUM.  If so, I will find itacceptable to go with MINIMAL (acceptable, but not pleasant).*start*00806 00024 US Return-Path: <sandra%defun@cs.utah.edu>Received: from cs.utah.edu ([128.110.4.21]) by Xerox.COM ; 10 DEC 88 08:16:08 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.1-cs)	id AA17448; Sat, 10 Dec 88 09:15:16 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA02013; Sat, 10 Dec 88 09:15:12 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8812101615.AA02013@defun.utah.edu>Date: Sat, 10 Dec 88 09:15:11 MSTSubject: Re: Issue: EXIT-EXTENT (Version 4)To: masinter.paCc: cl-cleanup@sail.stanford.edu, sandra%defun@cs.utah.edu, Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>, Masinter.paIn-Reply-To: masinter.pa@Xerox.COM, 7 Dec 88 20:42 PSTThis version of the writeup was much easier to understand than thelast one.  Thanks.-Sandra-------*start*15005 00024 USfDate: 12 Dec 88 10:37 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: EXIT-EXTENT (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noIssue:         EXIT-EXTENTReferences:    CATCH, THROW,               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded                by this one.Category:      CLARIFICATIONEdit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...               Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvements               Version 4,  7-Dec-88, by Masinter, add MEDIUM from					UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.               Version 5, 12-Dec-88, Masinter, clarify MINIMAL allows MEDIUMProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends. For example, at what point is it no longer possible to RETURN-FROMa particular BLOCK?(Terminology: In this issue writeup, the noun "exit" isrefera to the thing that can be exited from, rather than theact of exiting. When the extent of an exit has ended, it isno longer legal to exit from it. This is different fromthe scope of the exit. For example, a BLOCK has lexicalscope but dynamic extent; a the scope of a CATCH--the visibility of the CATCH tag to corresponding THROWs--could differ from the extent of the CATCH.)The problem arises when there are nonlocal exits from the "cleanup" clauses of an UNWIND-PROTECT.There are three cases of interest:(1) Normal exit from a CATCH, BLOCK, or TAGBODY, or equivalent such asPROG.  A normal exit occurs when the last form in the body of one ofthese constructs completes its evaluation without performing a transferof control.(2) Nonlocal exit from the target of a THROW or RETURN.  A nonlocal exitoccurs when control is transferred by THROW, RETURN, or RETURN-FROM.The CATCH or BLOCK named in the THROW, RETURN, or RETURN-FROM isreferred to as the target.  The TAGBODY containing the tag named by aGO is also referred to as the target, but GO differs from the othernonlocal control transfer operators because GO does not exit its target.For example,(3) Abandonment of an exit passed over by THROW, RETURN, or GO.  ACATCH, BLOCK, or TAGBODY that is dynamically nested inside the target ofa nonlocal transfer of control is said to be passed over when control istransferred to the target.  The target itself is not said to be passedover.For example, in   (block testem      (when (zilched) (return-from testem nil))      (when (zorked) (throw 'uh-oh))      (format t "Neither zilched nor zorked."))if (zilched) returns true, the block testem is exited via a 'nonlocal exit'. If (zorked) returns true, the block testemis 'passed over'. Otherwise, the block is exited normally.The terms "normal exit", "target", and "passed over" will be used withthese meanings for the remainder of the discussion.CLtL is unambiguous about case 1.  In case 2, the extent could endanywhere from the time the THROW or RETURN commences, until the time thetransfer of control is completed.  In case 3, the extent could endanywhere from the time the THROW, RETURN, or GO commences, until thetime the transfer of control is completed.  In case 2, it is clear thatthe extent of the target ends before the transfer of control completes,since a block cannot be exited twice, but it is not made clear whetherthe extent ends before or after execution of UNWIND-PROTECT cleanupforms.  CLtL says nothing about case 3, although a note on p.38 impliesthat the extent of a passed-over exit should end no later than the endof the extent of the target exit.  It would make sense for the extentof an exit passed-over by GO to end no later than when the transfer ofcontrol is completed, but CLtL says nothing about this.Proposal (EXIT-EXTENT:MINIMAL):The dynamic extent of an exit, whether target or passed-over, ends assoon as the THROW, RETURN, or GO commences.  In the language of theimplementation note on p.142, the extent ends at the beginning of thesecond pass.  It is an error for an UNWIND-PROTECT cleanup form executedduring a nonlocal transfer of control to attempt to use an exit whosedynamic extent ended when the nonlocal transfer of control commenced.Note that this does not affect the extent of the binding of CATCHtags; that is, under this proposal, a THROW to a CATCH which wasalready in the process of being exited would be an error.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL. A program that presumed a longer extentwould be in error. Implementations may support longer extents forexits than is required by this proposal; in particular, an implementation which allowed the larger extent of the MEDIUMproposal below would still conform.Proposal (EXIT-EXTENT:MEDIUM):The dynamic extent of an exit, whether target or passed-over, endsonly after the exit is complete. A transfer of control from within an UNWIND-PROTECT cleanup formto a point outside of the UNWIND-PROTECT causes the original controltransfer which initiated the execution of the cleanup forms to beabandonded.During the execution of the cleanup forms of an UNWIND-PROTECT anon-local exit to a point outside of the scope of the UNWIND-PROTECT,but still within the dynamic scope of of the target of the originalnon-local exit succeeds, and the original pending exit is discarded.Where an UNWIND-PROTECT cleanup form attempts a non-local exit to apoint outside the original non-local exit, control is passed to theouter exit (and the pending original non-local exit is discarded.) In no case will UNWIND-PROTECT cleanup forms ever be attempted morethan once.Examples:Each of the following programs are an error under eitherproposal:;; Error: BLOCK has normal exit before RETURN(funcall (block nil #'(lambda () (return))));; Error: normal exit before GO(let ((a nil))   (tagbody t (setq a #'(lambda () (go t))))  (funcall a));; Error: TAGBODY is passed over, before GO(funcall (block nil           (tagbody a (return #'(lambda () (go a))))))Each of these programs are an error under MINIMAL, butnot under MEDIUM:;;returns 2 under MEDIUM, is error under MINIMAL(block nil     (unwind-protect (return 1)    (return 2)));;returns 2 under MEDIUM, is error under MINIMAL(block a      (block b    (unwind-protect (return-from a 1)      (return-from b 2))));; returns 2 under MEDIUM, is error under MINIMAL(catch nil   (unwind-protect (throw nil 1)    (throw nil 2)));; returns 2 under MEDIUM, is error under MINIMAL(catch 'a  (catch 'b    (unwind-protect (throw 'a 1)      (throw 'b 2))));; An error under MINIMAL because the catch of b is passed over by;; the first throw, hence portable programs must assume its dynamic extent;; is terminated.  The catch is not yet disestablished and therefore it;; is the target of the second throw.;; the following is an error under MINIMAL; the extent of the;; inner catch terminates as soon as the throw commences, even;; though it remains in scope. Thus, the throw of :second-throw;; sees the inner catch, but its extent has ended.;; under MEDIUM, it prints "The inner catch returns :second-throw";; and then returns :outer-catch.(catch 'foo	(format t "The inner catch returns ~s.~%"		(catch 'foo		    (unwind-protect (throw 'foo :first-throw)			(throw 'foo :second-throw))))	:outer-catch))The following program is not an error.  It returns 10.  The innercatch of a is passed over, but this is not case 3 because that catchis disestablished before the throw to a is executed.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))))The following cases are errors under MINIMAL, and havethe following interpretation under MEDIUM:In     (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))the pending exit to tag FOO is discarded by the second THROW to BAR and the value 4 is transfered to (CATCH 'BAR ...),which returns 4. The (CATCH 'FOO ...) then returns the 4because its first argument has returned normally.XXX is not printed.In     (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . It is not an error, even though the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW to FOO.Rationale:For MINIMAL: Giving exits the smallest extent consistent with CLtLmaximizes freedom for implementations; there are few applications,if any, that require a longer extent.For MEDIUM: Giving exits a longer exent has cleaner semantics.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target block or catch at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, the extent of a target exit lasts until theexit has been completed; in those implementations, it is possible for athrow or non-local exit to be effectively "stopped" by an UNWIND-PROTECTcleanup clause that performs a nonlocal transfer of control to apassed-over exit.Some implementations crash or otherwise generate garbage code fornon-local exits from cleanup clauses of UNWIND-PROTECT.Cost to Implementors:No currently valid implementation will be made invalid by the MINIMALproposal. Some implementors may wish to add error checks if theydo not already have them.MEDIUM would have a high cost for those implementations that currentlyhave shorter exent.Cost to Users:Most user programs don't do this, so there is likely little costof converting existing code in any case. In any case, current implementationsdiffer enough that this issue ostensibly does notaffect current portable programs. Some users might have code thatrelies on the "unstoppable loops" that can be created with the MEDIUMproposal.Benefits:Either proposal would make Common Lisp more precisely defined.Cost of non-adoption :The semantics of exits will remain ambiguous.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:This issue is controversial. It was first discussed under the issue named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast asthe more global one of "extent of exits" rather than the specific one of "what happens if a cleanup in an UNWIND-PROTECT does a non-local exit", but the problem cases for both topics are the same.The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation. The MEDIUM proposaldefines the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  It hasa cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal, not consideredhere, would duck the issue by outlawing all nonlocal exits from UNWIND-PROTECTcleanup forms. That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.An argument for the MEDIUM proposal was made based on the example:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangably,calling this an error would be inappropriate. It was argued that the MINIMAL proposal is equivalent to practicallyoutlawing non-local exits from UNWIND-PROTECT cleanup clauses, becausethere is no general way to determine the target of the nonlocal exitthat caused the cleanup clause to be invoked. CLtL never says in what dynamic environment cleanup forms ofUNWIND-PROTECT are executed.  The implementation note on p.142 may havebeen intended to cover this, but since it doesn't define the term"frame" that it uses, it doesn't actually say anything.  The extent ofdynamic-extent entities other than exits should be thesubject of a separate proposal. It was argued that the likelyresolution of those issues would be more consistent with theMEDIUM proposal than MINIMAL.The following example was offered as an argument against MINIMAL. Given:    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).     ----- End Forwarded Messages -----        TITAN 
         TITAN 
         ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))            Z                                  h              J                                        /                            f                           -                           b             h             k                                                      U       
       A              1             c             
      8v .z*start*14804 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 11:11:54 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  10:53:55 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 10:39:04 PSTDate: 12 Dec 88 10:37 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: EXIT-EXTENT (Version 5)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-103904-4431@Xerox>!Issue:         EXIT-EXTENTReferences:    CATCH, THROW,               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded                by this one.Category:      CLARIFICATIONEdit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...               Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvements               Version 4,  7-Dec-88, by Masinter, add MEDIUM from					UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.               Version 5, 12-Dec-88, Masinter, clarify MINIMAL allows MEDIUMProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends. For example, at what point is it no longer possible to RETURN-FROMa particular BLOCK?(Terminology: In this issue writeup, the noun "exit" isrefera to the thing that can be exited from, rather than theact of exiting. When the extent of an exit has ended, it isno longer legal to exit from it. This is different fromthe scope of the exit. For example, a BLOCK has lexicalscope but dynamic extent; a the scope of a CATCH--the visibility of the CATCH tag to corresponding THROWs--could differ from the extent of the CATCH.)The problem arises when there are nonlocal exits from the "cleanup" clauses of an UNWIND-PROTECT.There are three cases of interest:(1) Normal exit from a CATCH, BLOCK, or TAGBODY, or equivalent such asPROG.  A normal exit occurs when the last form in the body of one ofthese constructs completes its evaluation without performing a transferof control.(2) Nonlocal exit from the target of a THROW or RETURN.  A nonlocal exitoccurs when control is transferred by THROW, RETURN, or RETURN-FROM.The CATCH or BLOCK named in the THROW, RETURN, or RETURN-FROM isreferred to as the target.  The TAGBODY containing the tag named by aGO is also referred to as the target, but GO differs from the othernonlocal control transfer operators because GO does not exit its target.For example,(3) Abandonment of an exit passed over by THROW, RETURN, or GO.  ACATCH, BLOCK, or TAGBODY that is dynamically nested inside the target ofa nonlocal transfer of control is said to be passed over when control istransferred to the target.  The target itself is not said to be passedover.For example, in   (block testem      (when (zilched) (return-from testem nil))      (when (zorked) (throw 'uh-oh))      (format t "Neither zilched nor zorked."))if (zilched) returns true, the block testem is exited via a 'nonlocal exit'. If (zorked) returns true, the block testemis 'passed over'. Otherwise, the block is exited normally.The terms "normal exit", "target", and "passed over" will be used withthese meanings for the remainder of the discussion.CLtL is unambiguous about case 1.  In case 2, the extent could endanywhere from the time the THROW or RETURN commences, until the time thetransfer of control is completed.  In case 3, the extent could endanywhere from the time the THROW, RETURN, or GO commences, until thetime the transfer of control is completed.  In case 2, it is clear thatthe extent of the target ends before the transfer of control completes,since a block cannot be exited twice, but it is not made clear whetherthe extent ends before or after execution of UNWIND-PROTECT cleanupforms.  CLtL says nothing about case 3, although a note on p.38 impliesthat the extent of a passed-over exit should end no later than the endof the extent of the target exit.  It would make sense for the extentof an exit passed-over by GO to end no later than when the transfer ofcontrol is completed, but CLtL says nothing about this.!Proposal (EXIT-EXTENT:MINIMAL):The dynamic extent of an exit, whether target or passed-over, ends assoon as the THROW, RETURN, or GO commences.  In the language of theimplementation note on p.142, the extent ends at the beginning of thesecond pass.  It is an error for an UNWIND-PROTECT cleanup form executedduring a nonlocal transfer of control to attempt to use an exit whosedynamic extent ended when the nonlocal transfer of control commenced.Note that this does not affect the extent of the binding of CATCHtags; that is, under this proposal, a THROW to a CATCH which wasalready in the process of being exited would be an error.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL. A program that presumed a longer extentwould be in error. Implementations may support longer extents forexits than is required by this proposal; in particular, an implementation which allowed the larger extent of the MEDIUMproposal below would still conform.Proposal (EXIT-EXTENT:MEDIUM):The dynamic extent of an exit, whether target or passed-over, endsonly after the exit is complete. A transfer of control from within an UNWIND-PROTECT cleanup formto a point outside of the UNWIND-PROTECT causes the original controltransfer which initiated the execution of the cleanup forms to beabandonded.During the execution of the cleanup forms of an UNWIND-PROTECT anon-local exit to a point outside of the scope of the UNWIND-PROTECT,but still within the dynamic scope of of the target of the originalnon-local exit succeeds, and the original pending exit is discarded.Where an UNWIND-PROTECT cleanup form attempts a non-local exit to apoint outside the original non-local exit, control is passed to theouter exit (and the pending original non-local exit is discarded.) In no case will UNWIND-PROTECT cleanup forms ever be attempted morethan once.!Examples:Each of the following programs are an error under eitherproposal:;; Error: BLOCK has normal exit before RETURN(funcall (block nil #'(lambda () (return))));; Error: normal exit before GO(let ((a nil))   (tagbody t (setq a #'(lambda () (go t))))  (funcall a));; Error: TAGBODY is passed over, before GO(funcall (block nil           (tagbody a (return #'(lambda () (go a))))))Each of these programs are an error under MINIMAL, butnot under MEDIUM:;;returns 2 under MEDIUM, is error under MINIMAL(block nil     (unwind-protect (return 1)    (return 2)));;returns 2 under MEDIUM, is error under MINIMAL(block a      (block b    (unwind-protect (return-from a 1)      (return-from b 2))));; returns 2 under MEDIUM, is error under MINIMAL(catch nil   (unwind-protect (throw nil 1)    (throw nil 2)));; returns 2 under MEDIUM, is error under MINIMAL(catch 'a  (catch 'b    (unwind-protect (throw 'a 1)      (throw 'b 2))));; An error under MINIMAL because the catch of b is passed over by;; the first throw, hence portable programs must assume its dynamic extent;; is terminated.  The catch is not yet disestablished and therefore it;; is the target of the second throw.;; the following is an error under MINIMAL; the extent of the;; inner catch terminates as soon as the throw commences, even;; though it remains in scope. Thus, the throw of :second-throw;; sees the inner catch, but its extent has ended.;; under MEDIUM, it prints "The inner catch returns :second-throw";; and then returns :outer-catch.(catch 'foo	(format t "The inner catch returns ~s.~%"		(catch 'foo		    (unwind-protect (throw 'foo :first-throw)			(throw 'foo :second-throw))))	:outer-catch))The following program is not an error.  It returns 10.  The innercatch of a is passed over, but this is not case 3 because that catchis disestablished before the throw to a is executed.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))))The following cases are errors under MINIMAL, and havethe following interpretation under MEDIUM:In     (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX))))the pending exit to tag FOO is discarded by the second THROW to BAR and the value 4 is transfered to (CATCH 'BAR ...),which returns 4. The (CATCH 'FOO ...) then returns the 4because its first argument has returned normally.XXX is not printed.In     (CATCH 'BAR      (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))))the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.    . 3 evaluates to itself and is saved by THROW which begins      searching for tag FOO.     . 4 evaluates to iself and is saved by THROW which begins      searching for tag BAR.    . It is not an error, even though the      BAR tag is not found within the local dynamic scope of      the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)      but is found outside the scope of the target of the       pending THROW to FOO.Rationale:For MINIMAL: Giving exits the smallest extent consistent with CLtLmaximizes freedom for implementations; there are few applications,if any, that require a longer extent.For MEDIUM: Giving exits a longer exent has cleaner semantics.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target block or catch at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, the extent of a target exit lasts until theexit has been completed; in those implementations, it is possible for athrow or non-local exit to be effectively "stopped" by an UNWIND-PROTECTcleanup clause that performs a nonlocal transfer of control to apassed-over exit.Some implementations crash or otherwise generate garbage code fornon-local exits from cleanup clauses of UNWIND-PROTECT.Cost to Implementors:No currently valid implementation will be made invalid by the MINIMALproposal. Some implementors may wish to add error checks if theydo not already have them.MEDIUM would have a high cost for those implementations that currentlyhave shorter exent.Cost to Users:Most user programs don't do this, so there is likely little costof converting existing code in any case. In any case, current implementationsdiffer enough that this issue ostensibly does notaffect current portable programs. Some users might have code thatrelies on the "unstoppable loops" that can be created with the MEDIUMproposal.Benefits:Either proposal would make Common Lisp more precisely defined.Cost of non-adoption :The semantics of exits will remain ambiguous.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:This issue is controversial. It was first discussed under the issue named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast asthe more global one of "extent of exits" rather than the specific one of "what happens if a cleanup in an UNWIND-PROTECT does a non-local exit", but the problem cases for both topics are the same.The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation. The MEDIUM proposaldefines the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  It hasa cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal, not consideredhere, would duck the issue by outlawing all nonlocal exits from UNWIND-PROTECTcleanup forms. That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.An argument for the MEDIUM proposal was made based on the example:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangably,calling this an error would be inappropriate. It was argued that the MINIMAL proposal is equivalent to practicallyoutlawing non-local exits from UNWIND-PROTECT cleanup clauses, becausethere is no general way to determine the target of the nonlocal exitthat caused the cleanup clause to be invoked. CLtL never says in what dynamic environment cleanup forms ofUNWIND-PROTECT are executed.  The implementation note on p.142 may havebeen intended to cover this, but since it doesn't define the term"frame" that it uses, it doesn't actually say anything.  The extent ofdynamic-extent entities other than exits should be thesubject of a separate proposal. It was argued that the likelyresolution of those issues would be more consistent with theMEDIUM proposal than MINIMAL.The following example was offered as an argument against MINIMAL. Given:    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).     ----- End Forwarded Messages -----*start*19816 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 DEC 88 18:02:00 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Dec 88  18:00:01 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 508169; Tue 13-Dec-88 20:59:28 ESTDate: Tue, 13 Dec 88 20:59 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENT (Version 5)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881212-103904-4431@Xerox>Message-ID: <19881214015936.4.MOON@EUPHRATES.SCRC.Symbolics.COM>I'm sorry I got behind reading the mail on this topic.  There are enoughmistakes in this released-to-X3J13 version (even though it isconsiderably improved over my last version) that a line by linecommentary seems necessary.  Sorry about the length.  I've avoidedcommenting on typos that don't affect the meaning, except to put -> inthe margin, to save space.I'd volunteer to fix the writeup except that, as noted below, I can'tthink of any implementation-independent way to say what I think theMEDIUM proposal was intended to say, but does not actually say.    Issue:         EXIT-EXTENT    References:    CATCH, THROW,		   BLOCK, RETURN, RETURN-FROM,		   TAGBODY, GO, UNWIND-PROTECT,		   Dynamic extent (CLtL p.37),		   Nested dynamic extents (CLtL p.38),		   Blocks can only be exited once (CLtL p.120),		   Catch is disestablished just before the values 		   are returned (CLtL p.139).    Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded		    by this one.    Category:      CLARIFICATION    Edit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...		   Version 1, 5-Sep-88, by Moon, for discussion		   Version 2, 1-Oct-88, by Masinter, minor edits		   Version 3, 7-Oct-88, by Moon, wording improvements		   Version 4,  7-Dec-88, by Masinter, add MEDIUM from					    UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.		   Version 5, 12-Dec-88, Masinter, clarify MINIMAL allows MEDIUM    Problem description:    CLtL does not specify precisely when the dynamic extent (lifetime)    of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends.     For example, at what point is it no longer possible to RETURN-FROM    a particular BLOCK?    (Terminology: In this issue writeup, the noun "exit" is->  refera to the thing that can be exited from, rather than the    act of exiting. That would be a good idea, but in fact the writeup still uses the word"exit" to refer both to the door and to the act of walking out the door.I guess the sentence is technically true, since the latter use is a verbrather than a noun.  It would be better to use only "transfer of control"to refer to the act of walking out the door.		    When the extent of an exit has ended, it is    no longer legal to exit from it. This is different from    the scope of the exit. For example, a BLOCK has lexical->  scope but dynamic extent; a the scope of a CATCH--the     visibility of the CATCH tag to corresponding THROWs--    could differ from the extent of the CATCH.)    The problem arises when there are nonlocal exits from the     "cleanup" clauses of an UNWIND-PROTECT.    There are three cases of interest:    (1) Normal exit from a CATCH, BLOCK, or TAGBODY, or equivalent such as    PROG.  A normal exit occurs when the last form in the body of one of    these constructs completes its evaluation without performing a transfer    of control.    (2) Nonlocal exit from the target of a THROW or RETURN.  A nonlocal exit    occurs when control is transferred by THROW, RETURN, or RETURN-FROM.    The CATCH or BLOCK named in the THROW, RETURN, or RETURN-FROM is    referred to as the target.  The TAGBODY containing the tag named by a    GO is also referred to as the target, but GO differs from the other    nonlocal control transfer operators because GO does not exit its target.->  For example,    (3) Abandonment of an exit passed over by THROW, RETURN, or GO.  A    CATCH, BLOCK, or TAGBODY that is dynamically nested inside the target of    a nonlocal transfer of control is said to be passed over when control is    transferred to the target.  The target itself is not said to be passed    over.    For example, in       (block testem	  (when (zilched) (return-from testem nil))	  (when (zorked) (throw 'uh-oh))	  (format t "Neither zilched nor zorked."))    if (zilched) returns true, the block testem is exited via a     'nonlocal exit'. If (zorked) returns true, the block testem    is 'passed over'. Otherwise, the block is exited normally.    The terms "normal exit", "target", and "passed over" will be used with    these meanings for the remainder of the discussion.    CLtL is unambiguous about case 1.  In case 2, the extent could end    anywhere from the time the THROW or RETURN commences, until the time the    transfer of control is completed.  In case 3, the extent could end    anywhere from the time the THROW, RETURN, or GO commences, until the    time the transfer of control is completed.  In case 2, it is clear that    the extent of the target ends before the transfer of control completes,    since a block cannot be exited twice, but it is not made clear whether    the extent ends before or after execution of UNWIND-PROTECT cleanup    forms.  CLtL says nothing about case 3, although a note on p.38 implies    that the extent of a passed-over exit should end no later than the end    of the extent of the target exit.  It would make sense for the extent    of an exit passed-over by GO to end no later than when the transfer of    control is completed, but CLtL says nothing about this.    !    Proposal (EXIT-EXTENT:MINIMAL):    The dynamic extent of an exit, whether target or passed-over, ends as    soon as the THROW, RETURN, or GO commences.  In the language of the    implementation note on p.142, the extent ends at the beginning of the    second pass.  It is an error for an UNWIND-PROTECT cleanup form executed    during a nonlocal transfer of control to attempt to use an exit whose    dynamic extent ended when the nonlocal transfer of control commenced.Actually this should just say "It is an error to attempt a transfer ofcontrol to an exit whose dynamic extent has ended."  It doesn't reallymatter when it ended nor exactly who attempts the transfer of control.    Note that this does not affect the extent of the binding of CATCH    tags; that is, under this proposal, a THROW to a CATCH which was    already in the process of being exited would be an error.I think the word "extent" in the first line of this paragraph shouldhave been "scope", but I can see how reasonable people might disagree.A couple of places later in the writeup use "scope" in that way inconnection with CATCH, though.    This proposal is called "minimal" because it gives exits the smallest    extent consistent with CLtL. A program that presumed a longer extent    would be in error. Implementations may support longer extents for    exits than is required by this proposal; in particular, an     implementation which allowed the larger extent of the MEDIUM    proposal below would still conform.    Proposal (EXIT-EXTENT:MEDIUM):    The dynamic extent of an exit, whether target or passed-over, ends    only after the exit is complete. I doubt that that is what you intended to say.  For example,  (block one     (let ((f nil))       (unwind-protect           (block two	     (flet ((g () (return-from two 2)))	       (setq f #'g)	       (return-from one 1)))	 (funcall f))))Under MINIMAL, this is an error because the block named two is passedover by the return-from one before the return-from two is executed.Under MEDIUM, this is not an error because at the time of the funcall f,the exit is not complete and so the dynamic extent of the block namedtwo has not yet ended.  It either returns 2 or goes into an infiniteloop, depending on what it means to exit twice out of an UNWIND-PROTECT.Probably this intended to say something about how the dynamic extent ofa passed-over exit ends when control reaches a frame that wasestablished before the exit was established.  I don't know how to saythat in an implementation-independent way.  This difficulty in defininga clear semantics for passed-over exits is exactly why I have alwaysfavored MINIMAL, which constrains portable programs maximally andconstrains implementations minimally (which allows us to say as littleas possible about the implementation).I think we must only vote on what proposals actually say, not on what weguess they might have been intended to say.  We can of course amend themto say something different and then vote on them.    A transfer of control from within an UNWIND-PROTECT cleanup form    to a point outside of the UNWIND-PROTECT causes the original control    transfer which initiated the execution of the cleanup forms to be->  abandonded.    During the execution of the cleanup forms of an UNWIND-PROTECT a    non-local exit to a point outside of the scope of the UNWIND-PROTECT,->  but still within the dynamic scope of of the target of the original    non-local exit succeeds, and the original pending exit is discarded.    Where an UNWIND-PROTECT cleanup form attempts a non-local exit to a    point outside the original non-local exit, control is passed to the    outer exit (and the pending original non-local exit is discarded.)     In no case will UNWIND-PROTECT cleanup forms ever be attempted more    than once.This can't be true, since everyone agrees that  (unwind-protect nil    (loop (print 1)))prints 1 more than once.  Also if the UNWIND-PROTECT is entered morethan once, it cleanup forms can of course be called more than once.I think I know what you intended to say, but that isn't what youactually said.  I'm not sure why this needs to be in the proposal at allonce the problem I pointed out above is fixed, so maybe it would besimpler just to remove it.    !    Examples:->  Each of the following programs are an error under either    proposal:    ;; Error: BLOCK has normal exit before RETURN    (funcall (block nil #'(lambda () (return))))    ;; Error: normal exit before GO    (let ((a nil))       (tagbody t (setq a #'(lambda () (go t))))      (funcall a))    ;; Error: TAGBODY is passed over, before GO    (funcall (block nil	       (tagbody a (return #'(lambda () (go a))))))->  Each of these programs are an error under MINIMAL, but    not under MEDIUM:    ;;returns 2 under MEDIUM, is error under MINIMAL    (block nil         (unwind-protect (return 1)	(return 2)))    ;;returns 2 under MEDIUM, is error under MINIMAL    (block a          (block b	(unwind-protect (return-from a 1)	  (return-from b 2))))    ;; returns 2 under MEDIUM, is error under MINIMAL    (catch nil       (unwind-protect (throw nil 1)	(throw nil 2)))    ;; returns 2 under MEDIUM, is error under MINIMAL    (catch 'a      (catch 'b	(unwind-protect (throw 'a 1)	  (throw 'b 2))))    ;; An error under MINIMAL because the catch of b is passed over by    ;; the first throw, hence portable programs must assume its dynamic extent    ;; is terminated.  The catch is not yet disestablished and therefore it    ;; is the target of the second throw.    ;; the following is an error under MINIMAL; the extent of the    ;; inner catch terminates as soon as the throw commences, even    ;; though it remains in scope. Thus, the throw of :second-throw    ;; sees the inner catch, but its extent has ended.    ;; under MEDIUM, it prints "The inner catch returns :second-throw"    ;; and then returns :outer-catch.    (catch 'foo	    (format t "The inner catch returns ~s.~%"		    (catch 'foo			(unwind-protect (throw 'foo :first-throw)			    (throw 'foo :second-throw))))	    :outer-catch))    The following program is not an error.  It returns 10.  The inner    catch of a is passed over, but this is not case 3 because that catch    is disestablished before the throw to a is executed.    (catch 'a      (catch 'b	(unwind-protect (1+ (catch 'a (throw 'b 1)))	  (throw 'a 10))))The way MEDIUM is actually written, this seems to return 11 underMEDIUM, because the throw to a goes to the inner catch.  But I think youintended for it to return 10.    The following cases are errors under MINIMAL, and have    the following interpretation under MEDIUM:The second case is not an error under MINIMAL.  It behavesidentically in MINIMAL and MEDIUM.    In 	(CATCH 'FOO	  (CATCH 'BAR	      (UNWIND-PROTECT (THROW 'FOO 3)		(THROW 'BAR 4)		(PRINT 'XXX))))    the pending exit to tag FOO is discarded by the second THROW     to BAR and the value 4 is transfered to (CATCH 'BAR ...),    which returns 4. The (CATCH 'FOO ...) then returns the 4    because its first argument has returned normally.    XXX is not printed.    In 	(CATCH 'BAR	  (CATCH 'FOO	    (UNWIND-PROTECT (THROW 'FOO 3)	      (THROW 'BAR 4)	      (PRINT 'XXX))))    the value 4 is returned from the (CATCH 'BAR ...); XXX is not printed.	. 3 evaluates to itself and is saved by THROW which begins	  searching for tag FOO. 	. 4 evaluates to iself and is saved by THROW which begins	  searching for tag BAR.	. It is not an error, even though the	  BAR tag is not found within the local dynamic scope ofI don't know what a "local dynamic scope" is.	  the UNWIND-PROTECT cleanup form containing (THROW 'BAR 4)	  but is found outside the scope of the target of the 	  pending THROW to FOO.    Rationale:    For MINIMAL: Giving exits the smallest extent consistent with CLtL    maximizes freedom for implementations; there are few applications,    if any, that require a longer extent.->  For MEDIUM: Giving exits a longer exent has cleaner semantics.    Current practice:    Both implementations of Symbolics Genera (3600 and Ivory) end the extent    of a target block or catch at the moment the values are returned, and    end the extent of a passed-over exit at the moment the THROW, RETURN, or    GO commences.  This choice of extent maximizes efficiency within the    particular stack structure used by these implementations, by avoiding    the need to retain the control information needed to use a passed over    exit through the transfer of control.  Genera signals an error if an    attempt is made to use an exit that has been passed over.    In some implementations, the extent of a target exit lasts until the    exit has been completed; in those implementations, it is possible for a    throw or non-local exit to be effectively "stopped" by an UNWIND-PROTECT    cleanup clause that performs a nonlocal transfer of control to a    passed-over exit.    Some implementations crash or otherwise generate garbage code for    non-local exits from cleanup clauses of UNWIND-PROTECT.    Cost to Implementors:    No currently valid implementation will be made invalid by the MINIMAL    proposal. Some implementors may wish to add error checks if they    do not already have them.    MEDIUM would have a high cost for those implementations that currently    have shorter exent.    Cost to Users:    Most user programs don't do this, so there is likely little cost    of converting existing code in any case. In any case, current implementations    differ enough that this issue ostensibly does not    affect current portable programs. Some users might have code that    relies on the "unstoppable loops" that can be created with the MEDIUM    proposal.    Benefits:    Either proposal would make Common Lisp more precisely defined.    Cost of non-adoption :    The semantics of exits will remain ambiguous.    Esthetics:    Precisely specifying the meaning of dynamic extent improves the language.    Leaving implementations free to implement a longer extent if they choose    can be regarded as unesthetic, but consistent with Common Lisp philosophy.    Having a CATCH that is in scope even though its extent has ended may    seem unesthetic, but it is consistent with how BLOCK behaves.    Discussion:    This issue is controversial. It was first discussed under the issue     named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast as    the more global one of "extent of exits" rather than the specific     one of "what happens if a cleanup in an UNWIND-PROTECT does a non-    local exit", but the problem cases for both topics are the same.    The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL while    minimizing changes to the current situation. The MEDIUM proposal    defines the extent of an exit to end at the last moment possible    within some particular reference implementation.  It has    a cost to implementors whose implementation is not identical to the    reference implementation.  Another alternative proposal, not considered    here, would duck the issue by outlawing all nonlocal exits from UNWIND-PROTECT    cleanup forms. That alternative would have a substantial cost to some users.    Scheme is cleaner: it avoids this issue by specifying that the extent    of an exit never ends.    An argument for the MEDIUM proposal was made based on the example:      (block foo	(block bar	  (unwind-protect	      (return-from foo 'foo)	    (return-from bar 'bar))))    Since there is no reason for FOO and BAR not to be treated interchangably,    calling this an error would be inappropriate. This is no argument against the MINIMAL proposal.  Suppose FOO and BARare to be treated interchangeably.  Then the above example should beequivalent to      (block foo	(unwind-protect	    (return-from foo 'foo)	  (return-from foo 'bar)))In fact these two examples are equivalent under both proposals.  UnderMEDIUM they both return BAR.  Under MINIMAL they are both errors.    It was argued that the MINIMAL proposal is equivalent to practically    outlawing non-local exits from UNWIND-PROTECT cleanup clauses, because    there is no general way to determine the target of the nonlocal exit    that caused the cleanup clause to be invoked.     CLtL never says in what dynamic environment cleanup forms of    UNWIND-PROTECT are executed.  The implementation note on p.142 may have    been intended to cover this, but since it doesn't define the term    "frame" that it uses, it doesn't actually say anything.  The extent of    dynamic-extent entities other than exits should be the    subject of a separate proposal. It was argued that the likely    resolution of those issues would be more consistent with the    MEDIUM proposal than MINIMAL.    The following example was offered as an argument against MINIMAL. Given:	(block nil	  (handler-case	      (unwind-protect (return)		(error "foo"))             ;probably an error, under the proposal	    (error ()	      (print "foo"))))    If the ERROR handler has the same scope and extent a CATCH in the same place    would have (and that seems reasonable, though I'm not certain that the    condition system specifically requires that interpretation), then the handler    will be apparent to the call to ERROR, but will no longer be a valid target    (its extent was exited by the RETURN in the UNWIND-PROTECT body)."exited" in the preceding line should be "ended" or "passed over".This is true, but interchanging the first two lines of the example would fix it.It is quite intentional that the MINIMAL proposal says this style of codingis non-portable.  In current practice it is non-portable.*start*01402 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 DEC 88 22:04:47 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 15 Dec 88  22:03:41 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00902g; Thu, 15 Dec 88 22:00:41 PSTReceived: by bhopal id AA20824g; Thu, 15 Dec 88 22:02:42 PSTDate: Thu, 15 Dec 88 22:02:42 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812160602.AA20824@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 13 Dec 88 20:59 EST <19881214015936.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENT (Version 5)I wanted to recommend against accepting this proposal in its currentformat; it looked like to me that a lot more work was needed to makeit both accurate and comprehensible.  Since I don't have the time towork one it before the January meeting, I won't be able to explainmy objections in much better detail (without, in fact, going to thetrouble to prepare the necessary revised proposal, which I don'thave time to do!)What would you like to see happen?  If you think you can do it in time before the January meeting, could you _please_ make the revision, andmail that out?  to X3J13 as well?-- JonL --*start*02825 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 DEC 88 17:11:22 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Dec 88  17:09:53 PSTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 510806; 20 Dec 88 20:08:36 ESTDate: Tue, 20 Dec 88 20:14 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENT (Version 5)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8812160602.AA20824@bhopal>Message-ID: <19881221011406.6.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>    Date: Thu, 15 Dec 88 22:02:42 PST    From: Jon L White <jonl@lucid.com>    I wanted to recommend against accepting this proposal in its current    format; it looked like to me that a lot more work was needed to make    it both accurate and comprehensible.  I agree with that for version 5.  I'm not sure whether I agree with thatfor the earlier versions, I would have to go back and re-read them.					  Since I don't have the time to    work on it before the January meeting, I won't be able to explain    my objections in much better detail (without, in fact, going to the    trouble to prepare the necessary revised proposal, which I don't    have time to do!)    What would you like to see happen?  If you think you can do it in time     before the January meeting, could you _please_ make the revision, and    mail that out?  to X3J13 as well?I'd help if I could, but I cannot revise the proposal in its currenttwo-proposal form, because I cannot think of any coherent, unambiguous,implementation-independent way to say what I think the second proposal istrying to say.  At this point it wouldn't surprise me if it turns out to beimpossible to specify it in any acceptable way.  If someone else can comeup with it, fine, I'd love to be proved wrong.If that doesn't happen, I'd like to see either the first proposal (the onethat ends the dynamic extent of an exit sooner) accepted or retain thestatus quo.  I think the status quo, which is vague, ambiguous, andincoherent, would still be better than adopting a new proposal that (Ifeel) is still ambiguous and incoherent, and at the same time isincompatible with current practice.  As I commented earlier, I thinkversion 5 of the second proposal (the one that ends the dynamic extent ofan exit later) is in fact incompatible with all current implementations,and may not be implementable at all.  I don't think that was what wasintended, but even what was probably intended is incompatible with somecurrent implementations (Genera is the one I know about).*start*02274 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 31 DEC 88 20:20:44 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 31 Dec 88  20:01:14 PSTDate: Sat, 31 Dec 88 19:48:58 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue EXIT-EXTENT, v5To: cl-cleanup@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUMessage-ID: <12458959570.23.IIM@ECLA.USC.EDU>MINIMAL: I don't agree with this, for reasons I have already discussedsomewhat.  Basically, I feel this seriously damages the semantics of thelanguage, playing havoc with both UNWIND-PROTECT and the definition ofdynamic-scope. MEDIUM: Even though the intent of this proposal is what I want, I don't believeit is really ready for voting yet because the current proposal is poorlywritten.  I agree with Moon's comment that this may be hard to write in areasonably implementation-independent way.  My intuition is based on thenesting of forms, but I'm not sure how constraining a writup based on thatwould be (though obviously somewhat, since the technique Symbolic's uses wouldseem to be invalidated by acceptence of something like this proposal).This is a hard issue.  Some people feel that MINIMAL is essential becauseMEDIUM is too expensive/restrictive for implementors, while other people feelthat (a cleaned up) MEDIUM is essential because MINIMAL is tooexpensive/restrictive for users.  Since I favor MEDIUM I would hate to seethis issue die with nothing at all being said, since that can be interpreted asdefacto MINIMAL.  I don't know if I'm going to be able to find the time towrite up anything more coherent though.  Part of the problem I've encounteredwhen I've tried to do so, is that I think this whole issue is sort ofmisdirected.  The problem that needs clarification isn't the extent of exits,its the dynamic environment in which cleanup forms are executed (in spite ofthe fact that the proposal says the extent of other dynamic-extent entitiesshould be the subject of seperate proposal(s), a claim which I totally disagreewith).  UNWIND-PROTECT cleanup forms are the only place where these proposalsmake a difference (to the user).kab-------*start*01292 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 15:18:03 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  15:17:47 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 15:16:42 PSTDate: 2 Jan 89 15:16 PSTSender: masinter.paSubject: re: Issue: EXIT-EXTENT (Version 5)To: cl-cleanup@sail.stanford.eduFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Message-ID: <890102-151642-1725@Xerox>MINIMAL:  NO, for reasons I have discussed on the mailing list.  Basically, Ifeel this seriously damages the semantics of the language, playing havoc withboth UNWIND-PROTECT and the definition of dynamic-scope.MEDIUM:  Currently NO, even though the intent of this proposal is what I want,because the current proposal is poorly written.  I don't believe it is reallyready for voting yet.  I agree with Moon's comment that this may be hard towrite in a reasonably implementation-independent way.  My intuition is based onthe nesting of forms, but I'm not sure how constraining a writup based on thatwould be (though obviously somewhat, since the technique Symbolic's uses isinvalidated by acceptence of something like this proposal).*start*15281 00024 USfDate:  8 Jan 89 22:47 PSTFrom: masinter.paTo: cl-cleanup@sail.stanford.educc: Moon@STONY-BROOK.SCRC.Symbolics.COM, jonl@lucid.com, IIM@ECLA.USC.EDUline-fold: NOSubject: Issue: EXIT-EXTENT (Version 6)cc: masinterI'm hoping we can get this one voted on, at least to the intent. It is probably true that an exact definition of what we mean will be difficult to express without a formal semantics, but I think it is clear that -- by now -- we actually know what the proposals are trying to say, evenwhen more precision would be welcome. I've tried to shorten the issue writeup by removing some of the discussion of cases for which the semantics was not ambiguous while still defining terms. I am sick of this issue, even with only 331K bytes ofmail on it.Issue:         EXIT-EXTENTReferences:    CATCH, THROW (p 142),               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).             Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded                by this one.Category:      CLARIFICATIONEdit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...               Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvements               Version 4,  7-Dec-88, by Masinter, add MEDIUM from					UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.               Version 5, 12-Dec-88, Masinter, clarify MINIMAL allows MEDIUM               Version 6,  8-Jan-89, Masinter, fix some bugsProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends. For example, at what point is it no longer possible to RETURN-FROMa particular BLOCK?An "exit" refers to a point from which control can be transferred.For a THROW or RETURN-FROM, the "exit" is the corresponding CATCHor BLOCK body. For a GO, the "exit" is the form within the TAGBODYwhich was being executed at the time the GO is performed.The extent of an exit is dynamic; it is not indefinite. The extentof an exit begins when the corresponding form (CATCH, BLOCK or TAGBODYclause) is entered.  When the extent of an exit has ended, it is nolonger legal to return from it.The extent of an exit is not the same thing as the scope of thedesignator by which the exit is identified. For example, a BLOCKname has lexical scope but the extent of its exit is dynamic; thescope of a CATCH tag could differ from the extent of the CATCH'sreturn point. (That's part of what is at issue here.)The ambiguity at issue arises for the case where there are transfersof control from the cleanup clauses of an UNWIND-PROTECT.When a transfer of control is initiated by GO, RETURN-FROM or THROW,a variety of events occur before the transfer of control is complete.In particular, (a) the cleanup clauses of any intervening UNWIND-PROTECT clauses    are evaluated,(b) intervening dynamic bindings of special variables and catch tags    are undone,(c) intervening exits are "abandoned", i.e., their extent ends and it    is no longer legal to attempt to transfer control through them,(d) the extent of the exit being invoked ends,(e) control is finally passed to the target.The order of these events is not explicit in CLtL, however. The implementation note on p.142 gives a clue about the interweavingof (a) and (b), but there are differing opinions about the timesat which (c) and (d) may occur. In particular,Is it legal for an implementation to end the extent of all intervening exits before processing the cleanup clauses of intervening UNWIND-PROTECTs?What is the dynamic context at the time UNWIND-PROTECT clauses are evaluated: how is the unwinding of dynamic bindings intertwined with evaluation of UNWIND-PROTECT cleanup clauses? Proposal (EXIT-EXTENT:MINIMAL):The extent of an exit--whether it is being "abandoned" because it is being passed over, or it is itself the target exit--ends as soon as the transfer of control is initiated. That is, the events (c) and (d) at the beginning of the initiation of the transfer of control. In the language of the implementation note on p.142, the extent ends at the beginning of the second pass.  It is an error to attempt a transfer of control to an exit whose dynamic extent has ended.Otherwise, events (a) and (b)--the undoing of dynamic binding of specialvariables and CATCH tags, and the execution of UNWIND-PROTECT cleanupclauses--are performed in the order corresponding to the reverse orderin which they were established, as implied by the implementation noteon p.142. The effect of this is that the cleanup clauses of an UNWIND-PROTECTwill see the same dynamic bindings of variables and CATCH tags as werevisible when the UNWIND-PROTECT was entered.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL. A program that presumed a longer extentwould be in error. Implementations may support longer extents forexits than is required by this proposal; in particular, an implementation which allowed the larger extent of the MEDIUMproposal below would still conform.Proposal (EXIT-EXTENT:MEDIUM):The events of (a), (b), (c) and (d) are interwoven in the reverse order in which they were established. In particular, the extent of a passed-over exit ends when control reaches a frame that was established before the exit was established.  In particular, it is legal, during the evaluation of an UNWIND-PROTECT cleanup form executed because of a non-local transfer of control, toinitiate a new transfer of control to an exit intervening between the UNWIND-PROTECT and the original target; the original processing of transfer of control is abandoned.  Examples:;; Error under either proposal: BLOCK exits normally before RETURN(funcall (block nil #'(lambda () (return))));; Error under either proposal: normal exit before GO(let ((a nil))   (tagbody t (setq a #'(lambda () (go t))))  (funcall a));; Error under either proposal: TAGBODY is passed over, before GO(funcall (block nil           (tagbody a (return #'(lambda () (go a))))));;returns 2 under MEDIUM, is error under MINIMAL(block nil     (unwind-protect (return 1)    (return 2)));;returns 2 under MEDIUM, is error under MINIMAL(block a      (block b    (unwind-protect (return-from a 1)      (return-from b 2))));; returns 2 under MEDIUM, is error under MINIMAL(catch nil   (unwind-protect (throw nil 1)    (throw nil 2)));; returns 2 under MEDIUM, is error under MINIMAL;; because the catch of B is passed over by;; the first THROW, hence portable programs must assume its dynamic extent;; is terminated.  The binding of the catch tag is not yet disestablished;; and therefore it is the target of the second throw.(catch 'a  (catch 'b    (unwind-protect (throw 'a 1)      (throw 'b 2))));; the following is an error under MINIMAL; the extent of the;; inner catch terminates as soon as the THROW commences, even;; though it remains in scope. Thus, the THROW of :SECOND-THROW;; sees the inner CATCH, but its extent has ended.;; under MEDIUM, it prints "The inner catch returns :SECOND-THROW";; and then returns :OUTER-CATCH.(catch 'foo	(format t "The inner catch returns ~s.~%"		(catch 'foo		    (unwind-protect (throw 'foo :first-throw)			(throw 'foo :second-throw))))	:outer-catch));; Following returns 10 under either proposal.  The inner;; CATCH of A is passed over, but because that CATCH;; is disestablished before the THROW to A is executed,;; it isn't seen.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))));; Following is an error under MINIMAL because the extent of;; the (CATCH 'FOO ...) exit ends when the (THROW 'FOO ...);; commences.;; Under MEDIUM, the pending exit to tag FOO is discarded by the;; second THROW to BAR and the value 4 is transferred to;; (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...);; then returns the 4 because its first argument has returned;; normally.  XXX is not printed.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX)))) ;; Following returns 4 under either proposal; XXX is not printed.;; The (THROW 'FOO ...) has no effect on the scope of the BAR;; catch tag or the extent of the (CATCH 'BAR ...) exit.(CATCH 'BAR    (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))));;The following are legal and print 5 under either proposal:    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect (return)          (print x))))		    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect            (if (test) (return))          (print x))))	Rationale:For MINIMAL: Giving exits the smallest extent consistent with CLtLmaximizes freedom for implementations; there are few applications,if any, that require a longer extent.For MEDIUM: Giving exits a longer extent has cleaner semantics.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target BLOCK or CATCH at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, it is possible for a throw or non-local exitto be effectively "stopped" by an UNWIND-PROTECT cleanup clause thatperforms a non-local transfer of control to a passed-over exit.Some implementations crash or otherwise generate garbage code fornon-local exits from cleanup clauses of UNWIND-PROTECT.Cost to Implementors:No currently valid implementation will be made invalid by the MINIMALproposal. Some implementors may wish to add error checks if theydo not already have them.MEDIUM would have a high cost for those implementations that currentlyhave shorter extent.Cost to Users:Most user programs don't do this, so there is likely little costof converting existing code in any case. In any case, current implementationsdiffer enough that this issue ostensibly does notaffect current portable programs. Some users might have code thatrelies on the "unstoppable loops" that can be created with the MEDIUMproposal.Benefits:Either proposal would make Common Lisp more precisely defined.Cost of non-adoption :The semantics of exits will remain ambiguous.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:This issue is controversial. It was first discussed under the issue named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast asthe more global one of "extent of exits" rather than the specific one of "what happens if a cleanup in an UNWIND-PROTECT does a non-local exit", but the problem cases for both topics are the same.The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation. The MEDIUM proposaldefines the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  It hasa cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal, not consideredhere, would duck the issue by outlawing all non-local exits from UNWIND-PROTECTcleanup forms. That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.An argument for the MEDIUM proposal was made based on the example:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangeably,calling this an error would be inappropriate. It was argued that the MINIMAL proposal is equivalent to practicallyoutlawing non-local exits from UNWIND-PROTECT cleanup clauses, becausethere is no general way to determine the target of the non-local exitthat caused the cleanup clause to be invoked. The following example was offered as an argument against MINIMAL. Given:    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).The extent of an object with dynamic extent is the extent of the form which created it.  Code which is executed "within" that form is withinthe extent of the object(s).  This applies to all dynamic objects, suchas special variable bindings, not just exits.  Actually, I think the intentof the implementation note on p.142 is fairly clear and supports thisinterpretation.  The supposedly ambiguous use of "frame" should be readas something like "form which establishes a dynamic extent".  It might beclearer if the last sentence were changed to read something like:"On the second pass the stack is actually unwound.  Each form which establishesa dynamic extent is undone in reverse order of creation until the matchingCATCH is reached.  The meaning of undoing a form depends on the type of form.For UNWIND-PROTECT, it means executing the cleanup forms.  For CATCH it meansremoving the CATCH tag.  For dynamic bindings it means undoing the binding,restoring the previous saved value. {This is not an exhaustive listing of thepossibilities.}"        
TIMESROMAN           TITAN 
          TITAN 
        ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))            Q       #                                                V                    ~              J                                                      &             4       
      }             t                           r                           U       
       A              0             c                   9 ,z*start*15112 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JAN 89 22:53:07 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Jan 89  22:51:15 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 JAN 89 22:48:45 PSTDate: 8 Jan 89 22:47 PSTFrom: masinter.paTo: cl-cleanup@sail.stanford.educc: Moon@STONY-BROOK.SCRC.Symbolics.COM, jonl@lucid.com, IIM@ECLA.USC.EDUline-fold: NOSubject: Issue: EXIT-EXTENT (Version 6)cc: masinter.paMessage-ID: <890108-224845-3526@Xerox>I'm hoping we can get this one voted on, at least to the intent. It is probably true that an exact definition of what we mean will be difficult to express without a formal semantics, but I think it is clear that -- by now -- we actually know what the proposals are trying to say, evenwhen more precision would be welcome. I've tried to shorten the issue writeup by removing some of the discussion of cases for which the semantics was not ambiguous while still defining terms. I am sick of this issue, even with only 331K bytes ofmail on it.!Issue:         EXIT-EXTENTReferences:    CATCH, THROW (p 142),               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).             Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded                by this one.Category:      CLARIFICATIONEdit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...               Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvements               Version 4,  7-Dec-88, by Masinter, add MEDIUM from					UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.               Version 5, 12-Dec-88, Masinter, clarify MINIMAL allows MEDIUM               Version 6,  8-Jan-89, Masinter, fix some bugsProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends. For example, at what point is it no longer possible to RETURN-FROMa particular BLOCK?An "exit" refers to a point from which control can be transferred.For a THROW or RETURN-FROM, the "exit" is the corresponding CATCHor BLOCK body. For a GO, the "exit" is the form within the TAGBODYwhich was being executed at the time the GO is performed.The extent of an exit is dynamic; it is not indefinite. The extentof an exit begins when the corresponding form (CATCH, BLOCK or TAGBODYclause) is entered.  When the extent of an exit has ended, it is nolonger legal to return from it.The extent of an exit is not the same thing as the scope of thedesignator by which the exit is identified. For example, a BLOCKname has lexical scope but the extent of its exit is dynamic; thescope of a CATCH tag could differ from the extent of the CATCH'sreturn point. (That's part of what is at issue here.)The ambiguity at issue arises for the case where there are transfersof control from the cleanup clauses of an UNWIND-PROTECT.When a transfer of control is initiated by GO, RETURN-FROM or THROW,a variety of events occur before the transfer of control is complete.In particular, (a) the cleanup clauses of any intervening UNWIND-PROTECT clauses    are evaluated,(b) intervening dynamic bindings of special variables and catch tags    are undone,(c) intervening exits are "abandoned", i.e., their extent ends and it    is no longer legal to attempt to transfer control through them,(d) the extent of the exit being invoked ends,(e) control is finally passed to the target.The order of these events is not explicit in CLtL, however. The implementation note on p.142 gives a clue about the interweavingof (a) and (b), but there are differing opinions about the timesat which (c) and (d) may occur. In particular,Is it legal for an implementation to end the extent of all intervening exits before processing the cleanup clauses of intervening UNWIND-PROTECTs?What is the dynamic context at the time UNWIND-PROTECT clauses are evaluated: how is the unwinding of dynamic bindings intertwined with evaluation of UNWIND-PROTECT cleanup clauses? Proposal (EXIT-EXTENT:MINIMAL):The extent of an exit--whether it is being "abandoned" because it is being passed over, or it is itself the target exit--ends as soon as the transfer of control is initiated. That is, the events (c) and (d) at the beginning of the initiation of the transfer of control. In the language of the implementation note on p.142, the extent ends at the beginning of the second pass.  It is an error to attempt a transfer of control to an exit whose dynamic extent has ended.Otherwise, events (a) and (b)--the undoing of dynamic binding of specialvariables and CATCH tags, and the execution of UNWIND-PROTECT cleanupclauses--are performed in the order corresponding to the reverse orderin which they were established, as implied by the implementation noteon p.142. The effect of this is that the cleanup clauses of an UNWIND-PROTECTwill see the same dynamic bindings of variables and CATCH tags as werevisible when the UNWIND-PROTECT was entered.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL. A program that presumed a longer extentwould be in error. Implementations may support longer extents forexits than is required by this proposal; in particular, an implementation which allowed the larger extent of the MEDIUMproposal below would still conform.Proposal (EXIT-EXTENT:MEDIUM):The events of (a), (b), (c) and (d) are interwoven in the reverse order in which they were established. In particular, the extent of a passed-over exit ends when control reaches a frame that was established before the exit was established.  In particular, it is legal, during the evaluation of an UNWIND-PROTECT cleanup form executed because of a non-local transfer of control, toinitiate a new transfer of control to an exit intervening between the UNWIND-PROTECT and the original target; the original processing of transfer of control is abandoned.  Examples:;; Error under either proposal: BLOCK exits normally before RETURN(funcall (block nil #'(lambda () (return))));; Error under either proposal: normal exit before GO(let ((a nil))   (tagbody t (setq a #'(lambda () (go t))))  (funcall a));; Error under either proposal: TAGBODY is passed over, before GO(funcall (block nil           (tagbody a (return #'(lambda () (go a))))));;returns 2 under MEDIUM, is error under MINIMAL(block nil     (unwind-protect (return 1)    (return 2)));;returns 2 under MEDIUM, is error under MINIMAL(block a      (block b    (unwind-protect (return-from a 1)      (return-from b 2))));; returns 2 under MEDIUM, is error under MINIMAL(catch nil   (unwind-protect (throw nil 1)    (throw nil 2)));; returns 2 under MEDIUM, is error under MINIMAL;; because the catch of B is passed over by;; the first THROW, hence portable programs must assume its dynamic extent;; is terminated.  The binding of the catch tag is not yet disestablished;; and therefore it is the target of the second throw.(catch 'a  (catch 'b    (unwind-protect (throw 'a 1)      (throw 'b 2))));; the following is an error under MINIMAL; the extent of the;; inner catch terminates as soon as the THROW commences, even;; though it remains in scope. Thus, the THROW of :SECOND-THROW;; sees the inner CATCH, but its extent has ended.;; under MEDIUM, it prints "The inner catch returns :SECOND-THROW";; and then returns :OUTER-CATCH.(catch 'foo	(format t "The inner catch returns ~s.~%"		(catch 'foo		    (unwind-protect (throw 'foo :first-throw)			(throw 'foo :second-throw))))	:outer-catch));; Following returns 10 under either proposal.  The inner;; CATCH of A is passed over, but because that CATCH;; is disestablished before the THROW to A is executed,;; it isn't seen.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))));; Following is an error under MINIMAL because the extent of;; the (CATCH 'FOO ...) exit ends when the (THROW 'FOO ...);; commences.;; Under MEDIUM, the pending exit to tag FOO is discarded by the;; second THROW to BAR and the value 4 is transferred to;; (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...);; then returns the 4 because its first argument has returned;; normally.  XXX is not printed.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX)))) ;; Following returns 4 under either proposal; XXX is not printed.;; The (THROW 'FOO ...) has no effect on the scope of the BAR;; catch tag or the extent of the (CATCH 'BAR ...) exit.(CATCH 'BAR    (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))));;The following are legal and print 5 under either proposal:    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect (return)          (print x))))		    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect            (if (test) (return))          (print x))))	Rationale:For MINIMAL: Giving exits the smallest extent consistent with CLtLmaximizes freedom for implementations; there are few applications,if any, that require a longer extent.For MEDIUM: Giving exits a longer extent has cleaner semantics.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target BLOCK or CATCH at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, it is possible for a throw or non-local exitto be effectively "stopped" by an UNWIND-PROTECT cleanup clause thatperforms a non-local transfer of control to a passed-over exit.Some implementations crash or otherwise generate garbage code fornon-local exits from cleanup clauses of UNWIND-PROTECT.Cost to Implementors:No currently valid implementation will be made invalid by the MINIMALproposal. Some implementors may wish to add error checks if theydo not already have them.MEDIUM would have a high cost for those implementations that currentlyhave shorter extent.Cost to Users:Most user programs don't do this, so there is likely little costof converting existing code in any case. In any case, current implementationsdiffer enough that this issue ostensibly does notaffect current portable programs. Some users might have code thatrelies on the "unstoppable loops" that can be created with the MEDIUMproposal.Benefits:Either proposal would make Common Lisp more precisely defined.Cost of non-adoption :The semantics of exits will remain ambiguous.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:This issue is controversial. It was first discussed under the issue named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast asthe more global one of "extent of exits" rather than the specific one of "what happens if a cleanup in an UNWIND-PROTECT does a non-local exit", but the problem cases for both topics are the same.The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation. The MEDIUM proposaldefines the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  It hasa cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal, not consideredhere, would duck the issue by outlawing all non-local exits from UNWIND-PROTECTcleanup forms. That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.An argument for the MEDIUM proposal was made based on the example:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangeably,calling this an error would be inappropriate. It was argued that the MINIMAL proposal is equivalent to practicallyoutlawing non-local exits from UNWIND-PROTECT cleanup clauses, becausethere is no general way to determine the target of the non-local exitthat caused the cleanup clause to be invoked. The following example was offered as an argument against MINIMAL. Given:    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).The extent of an object with dynamic extent is the extent of the form which created it.  Code which is executed "within" that form is withinthe extent of the object(s).  This applies to all dynamic objects, suchas special variable bindings, not just exits.  Actually, I think the intentof the implementation note on p.142 is fairly clear and supports thisinterpretation.  The supposedly ambiguous use of "frame" should be readas something like "form which establishes a dynamic extent".  It might beclearer if the last sentence were changed to read something like:"On the second pass the stack is actually unwound.  Each form which establishesa dynamic extent is undone in reverse order of creation until the matchingCATCH is reached.  The meaning of undoing a form depends on the type of form.For UNWIND-PROTECT, it means executing the cleanup forms.  For CATCH it meansremoving the CATCH tag.  For dynamic bindings it means undoing the binding,restoring the previous saved value. {This is not an exhaustive listing of thepossibilities.}"*start*01440 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 11:19:39 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Jan 89  11:18:53 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 JAN 89 11:06:54 PSTDate: 9 Jan 89 11:01 PSTFrom: masinter.paSubject: Re: Issue: EXIT-EXTENT (Version 6)In-reply-to: masinter.pa's message of 8 Jan 89 22:47 PSTTo: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: cl-cleanup@sail.stanford.eduMessage-ID: <890109-110654-4306@Xerox>I guess I want to add my personal feeling on this issue:I'm willing to vote for MINIMAL on the grounds that, although it isn't thecleanest semantics, it is consistent with the goal of allowinghigh-performance implementations, and we have ample documentation that someimplementations benefit considerably by this; secondarily on the groundsthat MEDIUM would be a serious incompatibility for some implementations. Iwasn't willing to vote for MINIMAL on the grounds that MEDIUM couldn't bedescribed or understood, which is why I put effort into describing MEDIUMeven though I'm willing to vote for MINIMAL.Maybe I wasted my time as far as the outcome is concerned, but I thinkwe'll have to defend the positions we take well into the future, that theywere well-considered and that decisions were made on technical grounds.*start*01288 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 15:35:09 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  15:33:53 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 11 JAN 89 15:32:33 PSTDate: 11 Jan 89 15:32 PSTFrom: masinter.paSubject: Issue: EXIT-EXTENT (Version 6)To: cl-cleanup@sail.stanford.eduMessage-ID: <890111-153233-10914@Xerox>N    EXIT-EXTENT:MINIMALY    EXIT-EXTENT:MEDIUM	    Version 5, 12-Dec-88, Mailed 12-Dec-88Reason: MEDIUM provides more useful semantics in one important case: ifan application has a top-level catch tag, and a cleanup handler does a(throw 'top-level ...) while cleaning up during such a throw.  Lack ofthese semantics in Maclisp results in problems in Multics Emacs, whoseerror handler prints a minibuffer message and then throws to the toplevel, but if an error happens during a cleanup, the top-level catch isno longer available, resulting in an infinite loop of "throw tononexistent tag" errors.  This seems like it would be a common paradigm,but unless there is a way for a cleanup handler to determine the contextof its invocation, MINIMAL makes this non-portable.*start*00284 00024 US Date: 11 Jan 89 15:52 PSTFrom: masinter.paSubject: Re: Issue: EXIT-EXTENT (Version 6)In-reply-to: masinter.pa's message of 11 Jan 89 15:32 PSTTo: masinter.pacc: cl-cleanup@sail.stanford.eduThat message should have been marked "From: Barmar@think.com"*start*14797 00024 US GV-Info: masinter.pa at 16-Mar-89 20:53:11 from massunterDate: 16 Mar 89 20:52 PSTFrom: masinter.paSubject: Issue: EXIT-EXTENT, v.6to: X3J13@sail.stanford.educc: masinterline-fold: NOThis version was distributed in hardcopy form at theJanuary 1989 meeting, but was tabled.There are two proposals.Issue:         EXIT-EXTENTReferences:    CATCH, THROW (p 142),               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).             Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded                by this one.Category:      CLARIFICATIONEdit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...               Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvements               Version 4,  7-Dec-88, by Masinter, add MEDIUM from					UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.               Version 5, 12-Dec-88, Masinter, clarify MINIMAL allows MEDIUM               Version 6,  8-Jan-89, Masinter, fix some bugsProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends. For example, at what point is it no longer possible to RETURN-FROMa particular BLOCK?An "exit" refers to a point from which control can be transferred.For a THROW or RETURN-FROM, the "exit" is the corresponding CATCHor BLOCK body. For a GO, the "exit" is the form within the TAGBODYwhich was being executed at the time the GO is performed.The extent of an exit is dynamic; it is not indefinite. The extentof an exit begins when the corresponding form (CATCH, BLOCK or TAGBODYclause) is entered.  When the extent of an exit has ended, it is nolonger legal to return from it.The extent of an exit is not the same thing as the scope of thedesignator by which the exit is identified. For example, a BLOCKname has lexical scope but the extent of its exit is dynamic; thescope of a CATCH tag could differ from the extent of the CATCH'sreturn point. (That's part of what is at issue here.)The ambiguity at issue arises for the case where there are transfersof control from the cleanup clauses of an UNWIND-PROTECT.When a transfer of control is initiated by GO, RETURN-FROM or THROW,a variety of events occur before the transfer of control is complete.In particular, (a) the cleanup clauses of any intervening UNWIND-PROTECT clauses    are evaluated,(b) intervening dynamic bindings of special variables and catch tags    are undone,(c) intervening exits are "abandoned", i.e., their extent ends and it    is no longer legal to attempt to transfer control through them,(d) the extent of the exit being invoked ends,(e) control is finally passed to the target.The order of these events is not explicit in CLtL, however. The implementation note on p.142 gives a clue about the interweavingof (a) and (b), but there are differing opinions about the timesat which (c) and (d) may occur. In particular,Is it legal for an implementation to end the extent of all intervening exits before processing the cleanup clauses of intervening UNWIND-PROTECTs?What is the dynamic context at the time UNWIND-PROTECT clauses are evaluated: how is the unwinding of dynamic bindings intertwined with evaluation of UNWIND-PROTECT cleanup clauses? Proposal (EXIT-EXTENT:MINIMAL):The extent of an exit--whether it is being "abandoned" because it is being passed over, or it is itself the target exit--ends as soon as the transfer of control is initiated. That is, the events (c) and (d) at the beginning of the initiation of the transfer of control. In the language of the implementation note on p.142, the extent ends at the beginning of the second pass.  It is an error to attempt a transfer of control to an exit whose dynamic extent has ended.Otherwise, events (a) and (b)--the undoing of dynamic binding of specialvariables and CATCH tags, and the execution of UNWIND-PROTECT cleanupclauses--are performed in the order corresponding to the reverse orderin which they were established, as implied by the implementation noteon p.142. The effect of this is that the cleanup clauses of an UNWIND-PROTECTwill see the same dynamic bindings of variables and CATCH tags as werevisible when the UNWIND-PROTECT was entered.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL. A program that presumed a longer extentwould be in error. Implementations may support longer extents forexits than is required by this proposal; in particular, an implementation which allowed the larger extent of the MEDIUMproposal below would still conform.Proposal (EXIT-EXTENT:MEDIUM):The events of (a), (b), (c) and (d) are interwoven in the reverse order in which they were established. In particular, the extent of a passed-over exit ends when control reaches a frame that was established before the exit was established.  In particular, it is legal, during the evaluation of an UNWIND-PROTECT cleanup form executed because of a non-local transfer of control, toinitiate a new transfer of control to an exit intervening between the UNWIND-PROTECT and the original target; the original processing of transfer of control is abandoned.  Examples:;; Error under either proposal: BLOCK exits normally before RETURN(funcall (block nil #'(lambda () (return))));; Error under either proposal: normal exit before GO(let ((a nil))   (tagbody t (setq a #'(lambda () (go t))))  (funcall a));; Error under either proposal: TAGBODY is passed over, before GO(funcall (block nil           (tagbody a (return #'(lambda () (go a))))));;returns 2 under MEDIUM, is error under MINIMAL(block nil     (unwind-protect (return 1)    (return 2)));;returns 2 under MEDIUM, is error under MINIMAL(block a      (block b    (unwind-protect (return-from a 1)      (return-from b 2))));; returns 2 under MEDIUM, is error under MINIMAL(catch nil   (unwind-protect (throw nil 1)    (throw nil 2)));; returns 2 under MEDIUM, is error under MINIMAL;; because the catch of B is passed over by;; the first THROW, hence portable programs must assume its dynamic extent;; is terminated.  The binding of the catch tag is not yet disestablished;; and therefore it is the target of the second throw.(catch 'a  (catch 'b    (unwind-protect (throw 'a 1)      (throw 'b 2))));; the following is an error under MINIMAL; the extent of the;; inner catch terminates as soon as the THROW commences, even;; though it remains in scope. Thus, the THROW of :SECOND-THROW;; sees the inner CATCH, but its extent has ended.;; under MEDIUM, it prints "The inner catch returns :SECOND-THROW";; and then returns :OUTER-CATCH.(catch 'foo	(format t "The inner catch returns ~s.~%"		(catch 'foo		    (unwind-protect (throw 'foo :first-throw)			(throw 'foo :second-throw))))	:outer-catch));; Following returns 10 under either proposal.  The inner;; CATCH of A is passed over, but because that CATCH;; is disestablished before the THROW to A is executed,;; it isn't seen.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))));; Following is an error under MINIMAL because the extent of;; the (CATCH 'FOO ...) exit ends when the (THROW 'FOO ...);; commences.;; Under MEDIUM, the pending exit to tag FOO is discarded by the;; second THROW to BAR and the value 4 is transferred to;; (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...);; then returns the 4 because its first argument has returned;; normally.  XXX is not printed.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX)))) ;; Following returns 4 under either proposal; XXX is not printed.;; The (THROW 'FOO ...) has no effect on the scope of the BAR;; catch tag or the extent of the (CATCH 'BAR ...) exit.(CATCH 'BAR    (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))));;The following are legal and print 5 under either proposal:    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect (return)          (print x))))		    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect            (if (test) (return))          (print x))))	Rationale:For MINIMAL: Giving exits the smallest extent consistent with CLtLmaximizes freedom for implementations; there are few applications,if any, that require a longer extent.For MEDIUM: Giving exits a longer extent has cleaner semantics.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target BLOCK or CATCH at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, it is possible for a throw or non-local exitto be effectively "stopped" by an UNWIND-PROTECT cleanup clause thatperforms a non-local transfer of control to a passed-over exit.Some implementations crash or otherwise generate garbage code fornon-local exits from cleanup clauses of UNWIND-PROTECT.Cost to Implementors:No currently valid implementation will be made invalid by the MINIMALproposal. Some implementors may wish to add error checks if theydo not already have them.MEDIUM would have a high cost for those implementations that currentlyhave shorter extent.Cost to Users:Most user programs don't do this, so there is likely little costof converting existing code in any case. In any case, current implementationsdiffer enough that this issue ostensibly does notaffect current portable programs. Some users might have code thatrelies on the "unstoppable loops" that can be created with the MEDIUMproposal.Benefits:Either proposal would make Common Lisp more precisely defined.Cost of non-adoption :The semantics of exits will remain ambiguous.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:This issue is controversial. It was first discussed under the issue named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast asthe more global one of "extent of exits" rather than the specific one of "what happens if a cleanup in an UNWIND-PROTECT does a non-local exit", but the problem cases for both topics are the same.The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation. The MEDIUM proposaldefines the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  It hasa cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal, not consideredhere, would duck the issue by outlawing all non-local exits from UNWIND-PROTECTcleanup forms. That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.An argument for the MEDIUM proposal was made based on the example:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangeably,calling this an error would be inappropriate. It was argued that the MINIMAL proposal is equivalent to practicallyoutlawing non-local exits from UNWIND-PROTECT cleanup clauses, becausethere is no general way to determine the target of the non-local exitthat caused the cleanup clause to be invoked. The following example was offered as an argument against MINIMAL. Given:    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).The extent of an object with dynamic extent is the extent of the form which created it.  Code which is executed "within" that form is withinthe extent of the object(s).  This applies to all dynamic objects, suchas special variable bindings, not just exits.  Actually, I think the intentof the implementation note on p.142 is fairly clear and supports thisinterpretation.  The supposedly ambiguous use of "frame" should be readas something like "form which establishes a dynamic extent".  It might beclearer if the last sentence were changed to read something like:"On the second pass the stack is actually unwound.  Each form which establishesa dynamic extent is undone in reverse order of creation until the matchingCATCH is reached.  The meaning of undoing a form depends on the type of form.For UNWIND-PROTECT, it means executing the cleanup forms.  For CATCH it meansremoving the CATCH tag.  For dynamic bindings it means undoing the binding,restoring the previous saved value. {This is not an exhaustive listing of thepossibilities.}"     ----- End Forwarded Messages -----        TITAN 
          TITAN 
        9 +(DEFAULTFONT 1 (GACHA 12) NIL (TERMINAL 8))            :       <                                  ~              J                                                      &             4       
      }             t                           r                           U       
       A              0             c                    )      7 (z*start*14664 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Mar-89 21:12:17 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 21:12:07 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  21:03:05 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 16 MAR 89 21:00:49 PSTDate: 16 Mar 89 20:52 PSTFrom: masinter.paSubject: Issue: EXIT-EXTENT, v.6to: X3J13@sail.stanford.educc: masinter.paline-fold: NOMessage-ID: <890316-210049-6699@Xerox>This version was distributed in hardcopy form at theJanuary 1989 meeting, but was tabled.There are two proposals.!Issue:         EXIT-EXTENTReferences:    CATCH, THROW (p 142),               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).             Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded                by this one.Category:      CLARIFICATIONEdit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...               Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvements               Version 4,  7-Dec-88, by Masinter, add MEDIUM from					UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.               Version 5, 12-Dec-88, Masinter, clarify MINIMAL allows MEDIUM               Version 6,  8-Jan-89, Masinter, fix some bugsProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends. For example, at what point is it no longer possible to RETURN-FROMa particular BLOCK?An "exit" refers to a point from which control can be transferred.For a THROW or RETURN-FROM, the "exit" is the corresponding CATCHor BLOCK body. For a GO, the "exit" is the form within the TAGBODYwhich was being executed at the time the GO is performed.The extent of an exit is dynamic; it is not indefinite. The extentof an exit begins when the corresponding form (CATCH, BLOCK or TAGBODYclause) is entered.  When the extent of an exit has ended, it is nolonger legal to return from it.The extent of an exit is not the same thing as the scope of thedesignator by which the exit is identified. For example, a BLOCKname has lexical scope but the extent of its exit is dynamic; thescope of a CATCH tag could differ from the extent of the CATCH'sreturn point. (That's part of what is at issue here.)The ambiguity at issue arises for the case where there are transfersof control from the cleanup clauses of an UNWIND-PROTECT.When a transfer of control is initiated by GO, RETURN-FROM or THROW,a variety of events occur before the transfer of control is complete.In particular, (a) the cleanup clauses of any intervening UNWIND-PROTECT clauses    are evaluated,(b) intervening dynamic bindings of special variables and catch tags    are undone,(c) intervening exits are "abandoned", i.e., their extent ends and it    is no longer legal to attempt to transfer control through them,(d) the extent of the exit being invoked ends,(e) control is finally passed to the target.The order of these events is not explicit in CLtL, however. The implementation note on p.142 gives a clue about the interweavingof (a) and (b), but there are differing opinions about the timesat which (c) and (d) may occur. In particular,Is it legal for an implementation to end the extent of all intervening exits before processing the cleanup clauses of intervening UNWIND-PROTECTs?What is the dynamic context at the time UNWIND-PROTECT clauses are evaluated: how is the unwinding of dynamic bindings intertwined with evaluation of UNWIND-PROTECT cleanup clauses? Proposal (EXIT-EXTENT:MINIMAL):The extent of an exit--whether it is being "abandoned" because it is being passed over, or it is itself the target exit--ends as soon as the transfer of control is initiated. That is, the events (c) and (d) at the beginning of the initiation of the transfer of control. In the language of the implementation note on p.142, the extent ends at the beginning of the second pass.  It is an error to attempt a transfer of control to an exit whose dynamic extent has ended.Otherwise, events (a) and (b)--the undoing of dynamic binding of specialvariables and CATCH tags, and the execution of UNWIND-PROTECT cleanupclauses--are performed in the order corresponding to the reverse orderin which they were established, as implied by the implementation noteon p.142. The effect of this is that the cleanup clauses of an UNWIND-PROTECTwill see the same dynamic bindings of variables and CATCH tags as werevisible when the UNWIND-PROTECT was entered.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL. A program that presumed a longer extentwould be in error. Implementations may support longer extents forexits than is required by this proposal; in particular, an implementation which allowed the larger extent of the MEDIUMproposal below would still conform.Proposal (EXIT-EXTENT:MEDIUM):The events of (a), (b), (c) and (d) are interwoven in the reverse order in which they were established. In particular, the extent of a passed-over exit ends when control reaches a frame that was established before the exit was established.  In particular, it is legal, during the evaluation of an UNWIND-PROTECT cleanup form executed because of a non-local transfer of control, toinitiate a new transfer of control to an exit intervening between the UNWIND-PROTECT and the original target; the original processing of transfer of control is abandoned.  Examples:;; Error under either proposal: BLOCK exits normally before RETURN(funcall (block nil #'(lambda () (return))));; Error under either proposal: normal exit before GO(let ((a nil))   (tagbody t (setq a #'(lambda () (go t))))  (funcall a));; Error under either proposal: TAGBODY is passed over, before GO(funcall (block nil           (tagbody a (return #'(lambda () (go a))))));;returns 2 under MEDIUM, is error under MINIMAL(block nil     (unwind-protect (return 1)    (return 2)));;returns 2 under MEDIUM, is error under MINIMAL(block a      (block b    (unwind-protect (return-from a 1)      (return-from b 2))));; returns 2 under MEDIUM, is error under MINIMAL(catch nil   (unwind-protect (throw nil 1)    (throw nil 2)));; returns 2 under MEDIUM, is error under MINIMAL;; because the catch of B is passed over by;; the first THROW, hence portable programs must assume its dynamic extent;; is terminated.  The binding of the catch tag is not yet disestablished;; and therefore it is the target of the second throw.(catch 'a  (catch 'b    (unwind-protect (throw 'a 1)      (throw 'b 2))));; the following is an error under MINIMAL; the extent of the;; inner catch terminates as soon as the THROW commences, even;; though it remains in scope. Thus, the THROW of :SECOND-THROW;; sees the inner CATCH, but its extent has ended.;; under MEDIUM, it prints "The inner catch returns :SECOND-THROW";; and then returns :OUTER-CATCH.(catch 'foo	(format t "The inner catch returns ~s.~%"		(catch 'foo		    (unwind-protect (throw 'foo :first-throw)			(throw 'foo :second-throw))))	:outer-catch));; Following returns 10 under either proposal.  The inner;; CATCH of A is passed over, but because that CATCH;; is disestablished before the THROW to A is executed,;; it isn't seen.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))));; Following is an error under MINIMAL because the extent of;; the (CATCH 'FOO ...) exit ends when the (THROW 'FOO ...);; commences.;; Under MEDIUM, the pending exit to tag FOO is discarded by the;; second THROW to BAR and the value 4 is transferred to;; (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...);; then returns the 4 because its first argument has returned;; normally.  XXX is not printed.    (CATCH 'FOO      (CATCH 'BAR	  (UNWIND-PROTECT (THROW 'FOO 3)	    (THROW 'BAR 4)	    (PRINT 'XXX)))) ;; Following returns 4 under either proposal; XXX is not printed.;; The (THROW 'FOO ...) has no effect on the scope of the BAR;; catch tag or the extent of the (CATCH 'BAR ...) exit.(CATCH 'BAR    (CATCH 'FOO	(UNWIND-PROTECT (THROW 'FOO 3)	  (THROW 'BAR 4)	  (PRINT 'XXX))));;The following are legal and print 5 under either proposal:    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect (return)          (print x))))		    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect            (if (test) (return))          (print x))))	Rationale:For MINIMAL: Giving exits the smallest extent consistent with CLtLmaximizes freedom for implementations; there are few applications,if any, that require a longer extent.For MEDIUM: Giving exits a longer extent has cleaner semantics.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target BLOCK or CATCH at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, it is possible for a throw or non-local exitto be effectively "stopped" by an UNWIND-PROTECT cleanup clause thatperforms a non-local transfer of control to a passed-over exit.Some implementations crash or otherwise generate garbage code fornon-local exits from cleanup clauses of UNWIND-PROTECT.Cost to Implementors:No currently valid implementation will be made invalid by the MINIMALproposal. Some implementors may wish to add error checks if theydo not already have them.MEDIUM would have a high cost for those implementations that currentlyhave shorter extent.Cost to Users:Most user programs don't do this, so there is likely little costof converting existing code in any case. In any case, current implementationsdiffer enough that this issue ostensibly does notaffect current portable programs. Some users might have code thatrelies on the "unstoppable loops" that can be created with the MEDIUMproposal.Benefits:Either proposal would make Common Lisp more precisely defined.Cost of non-adoption :The semantics of exits will remain ambiguous.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:This issue is controversial. It was first discussed under the issue named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast asthe more global one of "extent of exits" rather than the specific one of "what happens if a cleanup in an UNWIND-PROTECT does a non-local exit", but the problem cases for both topics are the same.The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation. The MEDIUM proposaldefines the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  It hasa cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal, not consideredhere, would duck the issue by outlawing all non-local exits from UNWIND-PROTECTcleanup forms. That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.An argument for the MEDIUM proposal was made based on the example:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)	(return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangeably,calling this an error would be inappropriate. It was argued that the MINIMAL proposal is equivalent to practicallyoutlawing non-local exits from UNWIND-PROTECT cleanup clauses, becausethere is no general way to determine the target of the non-local exitthat caused the cleanup clause to be invoked. The following example was offered as an argument against MINIMAL. Given:    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).The extent of an object with dynamic extent is the extent of the form which created it.  Code which is executed "within" that form is withinthe extent of the object(s).  This applies to all dynamic objects, suchas special variable bindings, not just exits.  Actually, I think the intentof the implementation note on p.142 is fairly clear and supports thisinterpretation.  The supposedly ambiguous use of "frame" should be readas something like "form which establishes a dynamic extent".  It might beclearer if the last sentence were changed to read something like:"On the second pass the stack is actually unwound.  Each form which establishesa dynamic extent is undone in reverse order of creation until the matchingCATCH is reached.  The meaning of undoing a form depends on the type of form.For UNWIND-PROTECT, it means executing the cleanup forms.  For CATCH it meansremoving the CATCH tag.  For dynamic bindings it means undoing the binding,restoring the previous saved value. {This is not an exhaustive listing of thepossibilities.}"     ----- End Forwarded Messages -----*start*01654 00024 UU?Date:  4 Apr 89 11:37 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: EXIT-EXTENTTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENTTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 11:27:36 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:16:19 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571091; Tue 4-Apr-89 14:16:18 EDTOriginal-Date: Tue, 4 Apr 89 14:15 EDTMessage-ID: <890404141553.8.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis was characterized by someone as ``the unstoppable throw meeting theimmovable catch.''I offered a "one time only" offer to support option MINIMAL if we couldjust get this off the table this week and not keep deferring it.Moon offered some amendments the effect of which were to allow you to throw againto the same tag as you were already throwing to; specifically:In the first paragraph of the MINIMAL proposal, delete "or is itself thetarget exit" and change "events (c) and (d) at" to "event (c) occurs at".After the first paragraph add a new paragraph "The event (d) occurs at theend of the transfer of control."The proposal was amended, and the amended option MINIMAL passed 11-5.*start*15772 00024 US Date:  4 Apr 89 13:25 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: EXIT-EXTENT (version 7)To: CL-Cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: EXIT-EXTENT (version 7)To: CL-Cleanup@sail.stanford.eduReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 13:07:47 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  13:01:17 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571323; Tue 4-Apr-89 16:01:09 EDTOriginal-Date: Tue, 4 Apr 89 16:00 EDTMessage-ID: <19890404200056.5.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis contains the amendments that were voted in at the X3J13 meeting last week.I also edited the rationale and the examples to make them consistent with theamended proposal.  The MINIMAL proposal here passed 11-5.Issue:         EXIT-EXTENTReferences:    CATCH, THROW (p 142),               BLOCK, RETURN, RETURN-FROM,               TAGBODY, GO, UNWIND-PROTECT,               Dynamic extent (CLtL p.37),               Nested dynamic extents (CLtL p.38),               Blocks can only be exited once (CLtL p.120),               Catch is disestablished just before the values                are returned (CLtL p.139).             Related issues: UNWIND-PROTECT-NON-LOCAL-EXIT is superseded                by this one.Category:      CLARIFICATIONEdit history:  ... Version 5 of UNWIND-PROTECT-NON-LOCAL-EXIT, 23-May-88 ...               Version 1, 5-Sep-88, by Moon, for discussion               Version 2, 1-Oct-88, by Masinter, minor edits               Version 3, 7-Oct-88, by Moon, wording improvements               Version 4,  7-Dec-88, by Masinter, add MEDIUM from                                        UNWIND-PROTECT-NON-LOCAL-EXIT, discussion.               Version 5, 12-Dec-88, Masinter, clarify MINIMAL allows MEDIUM               Version 6,  8-Jan-89, Masinter, fix some bugs               Version 7,  4-Apr-89, Moon, amend per X3J13 Mar-89, and make                                rationale and examples consistent with thatProblem description:CLtL does not specify precisely when the dynamic extent (lifetime)of a nonlocal exit such as a CATCH, BLOCK, or TAGBODY ends. For example, at what point is it no longer possible to RETURN-FROMa particular BLOCK?An "exit" refers to a point from which control can be transferred.For a THROW or RETURN-FROM, the "exit" is the corresponding CATCHor BLOCK body. For a GO, the "exit" is the form within the TAGBODYwhich was being executed at the time the GO is performed.The extent of an exit is dynamic; it is not indefinite. The extentof an exit begins when the corresponding form (CATCH, BLOCK or TAGBODYclause) is entered.  When the extent of an exit has ended, it is nolonger legal to return from it.The extent of an exit is not the same thing as the scope of thedesignator by which the exit is identified. For example, a BLOCKname has lexical scope but the extent of its exit is dynamic; thescope of a CATCH tag could differ from the extent of the CATCH'sreturn point. (That's part of what is at issue here.)The ambiguity at issue arises for the case where there are transfersof control from the cleanup clauses of an UNWIND-PROTECT.When a transfer of control is initiated by GO, RETURN-FROM or THROW,a variety of events occur before the transfer of control is complete.In particular, (a) the cleanup clauses of any intervening UNWIND-PROTECT clauses    are evaluated,(b) intervening dynamic bindings of special variables and catch tags    are undone,(c) intervening exits are "abandoned", i.e., their extent ends and it    is no longer legal to attempt to transfer control through them,(d) the extent of the exit being invoked ends,(e) control is finally passed to the target.The order of these events is not explicit in CLtL, however. The implementation note on p.142 gives a clue about the interweavingof (a) and (b), but there are differing opinions about the timesat which (c) and (d) may occur. In particular,Is it legal for an implementation to end the extent of all intervening exits before processing the cleanup clauses of intervening UNWIND-PROTECTs?What is the dynamic context at the time UNWIND-PROTECT clauses are evaluated: how is the unwinding of dynamic bindings intertwined with evaluation of UNWIND-PROTECT cleanup clauses? Proposal (EXIT-EXTENT:MINIMAL):The extent of an exit being "abandoned" because it is being passed overends as soon as the transfer of control is initiated. That is, theevent (c) occurs at the beginning of the initiation of the transfer ofcontrol. In the language of the implementation note on p.142, theextent ends at the beginning of the second pass.  It is an error toattempt a transfer of control to an exit whose dynamic extent hasended.The event (d) occurs at the end of the transfer of control.Otherwise, events (a) and (b)--the undoing of dynamic binding of specialvariables and CATCH tags, and the execution of UNWIND-PROTECT cleanupclauses--are performed in the order corresponding to the reverse orderin which they were established, as implied by the implementation noteon p.142. The effect of this is that the cleanup clauses of an UNWIND-PROTECTwill see the same dynamic bindings of variables and CATCH tags as werevisible when the UNWIND-PROTECT was entered.This proposal is called "minimal" because it gives exits the smallestextent consistent with CLtL, except that event (d) occurs later thanCLtL requires.  A program that presumed a longer extent would be inerror. Implementations may support longer extents for exits than isrequired by this proposal; in particular, an implementation whichallowed the larger extent of the MEDIUM proposal below would stillconform.Proposal (EXIT-EXTENT:MEDIUM):The events of (a), (b), (c) and (d) are interwoven in the reverse order in which they were established. In particular, the extent of a passed-over exit ends when control reaches a frame that was established before the exit was established.  In particular, it is legal, during the evaluation of an UNWIND-PROTECT cleanup form executed because of a non-local transfer of control, toinitiate a new transfer of control to an exit intervening between the UNWIND-PROTECT and the original target; the original processing of transfer of control is abandoned.  Examples:;; Error under either proposal: BLOCK exits normally before RETURN(funcall (block nil #'(lambda () (return))));; Error under either proposal: normal exit before GO(let ((a nil))   (tagbody t (setq a #'(lambda () (go t))))  (funcall a));; Error under either proposal: TAGBODY is passed over, before GO(funcall (block nil           (tagbody a (return #'(lambda () (go a))))));;returns 2 under MEDIUM and MINIMAL, was error under MINIMAL version 6(block nil     (unwind-protect (return 1)    (return 2)));;returns 2 under MEDIUM, is error under MINIMAL(block a      (block b    (unwind-protect (return-from a 1)      (return-from b 2))));; returns 2 under MEDIUM and MINIMAL, was error under MINIMAL version 6(catch nil   (unwind-protect (throw nil 1)    (throw nil 2)));; returns 2 under MEDIUM, is error under MINIMAL;; because the catch of B is passed over by;; the first THROW, hence portable programs must assume its dynamic extent;; is terminated.  The binding of the catch tag is not yet disestablished;; and therefore it is the target of the second throw.(catch 'a  (catch 'b    (unwind-protect (throw 'a 1)      (throw 'b 2))));; the following was an error under MINIMAL version 6; the extent of;; the inner catch terminates as soon as the THROW commences, even;; though it remains in scope. Thus, the THROW of :SECOND-THROW;; sees the inner CATCH, but its extent has ended.;; under MEDIUM and MINIMAL version 7,;; it prints "The inner catch returns :SECOND-THROW";; and then returns :OUTER-CATCH.(catch 'foo        (format t "The inner catch returns ~s.~%"                (catch 'foo                    (unwind-protect (throw 'foo :first-throw)                        (throw 'foo :second-throw))))        :outer-catch));; Following returns 10 under either proposal.  The inner;; CATCH of A is passed over, but because that CATCH;; is disestablished before the THROW to A is executed,;; it isn't seen.(catch 'a  (catch 'b    (unwind-protect (1+ (catch 'a (throw 'b 1)))      (throw 'a 10))));; Following is an error under MINIMAL because the extent of;; the (CATCH 'BAR ...) exit ends when the (THROW 'FOO ...);; commences.;; Under MEDIUM, the pending exit to tag FOO is discarded by the;; second THROW to BAR and the value 4 is transferred to;; (CATCH 'BAR ...), which returns 4. The (CATCH 'FOO ...);; then returns the 4 because its first argument has returned;; normally.  XXX is not printed.    (CATCH 'FOO      (CATCH 'BAR          (UNWIND-PROTECT (THROW 'FOO 3)            (THROW 'BAR 4)            (PRINT 'XXX)))) ;; Following returns 4 under either proposal; XXX is not printed.;; The (THROW 'FOO ...) has no effect on the scope of the BAR;; catch tag or the extent of the (CATCH 'BAR ...) exit.(CATCH 'BAR    (CATCH 'FOO        (UNWIND-PROTECT (THROW 'FOO 3)          (THROW 'BAR 4)          (PRINT 'XXX))));;The following are legal and print 5 under either proposal:    (block nil      (let ((x 5))        (declare (special x))        (unwind-protect (return)          (print x))))              (block nil      (let ((x 5))        (declare (special x))        (unwind-protect            (if (test) (return))          (print x))))  Rationale:For MINIMAL: Giving exits the smallest extent consistent with CLtLmaximizes freedom for implementations; there are few applications,if any, that require a longer extent.  Delaying event (d) untilthe transfer of control is completed allows multiple attempts toexit from a single exit, if the first attempt is interrupted,possibly by an error.For MEDIUM: Giving exits a longer extent has cleaner semantics.Current practice:Both implementations of Symbolics Genera (3600 and Ivory) end the extentof a target BLOCK or CATCH at the moment the values are returned, andend the extent of a passed-over exit at the moment the THROW, RETURN, orGO commences.  This choice of extent maximizes efficiency within theparticular stack structure used by these implementations, by avoidingthe need to retain the control information needed to use a passed overexit through the transfer of control.  Genera signals an error if anattempt is made to use an exit that has been passed over.In some implementations, it is possible for a throw or non-local exitto be effectively "stopped" by an UNWIND-PROTECT cleanup clause thatperforms a non-local transfer of control to a passed-over exit.Some implementations crash or otherwise generate garbage code fornon-local exits from cleanup clauses of UNWIND-PROTECT.Cost to Implementors:No currently valid implementation will be made invalid by the MINIMALproposal. Some implementors may wish to add error checks if theydo not already have them.MEDIUM would have a high cost for those implementations that currentlyhave shorter extent.Cost to Users:Most user programs don't do this, so there is likely little costof converting existing code in any case. In any case, current implementationsdiffer enough that this issue ostensibly does notaffect current portable programs. Some users might have code thatrelies on the "unstoppable loops" that can be created with the MEDIUMproposal.Benefits:Either proposal would make Common Lisp more precisely defined.Cost of non-adoption :The semantics of exits will remain ambiguous.Esthetics:Precisely specifying the meaning of dynamic extent improves the language.Leaving implementations free to implement a longer extent if they choosecan be regarded as unesthetic, but consistent with Common Lisp philosophy.Having a CATCH that is in scope even though its extent has ended mayseem unesthetic, but it is consistent with how BLOCK behaves.Discussion:This issue is controversial. It was first discussed under the issue named UNWIND-PROTECT-CLEANUP-NON-LOCAL-EXIT. The issue was recast asthe more global one of "extent of exits" rather than the specific one of "what happens if a cleanup in an UNWIND-PROTECT does a non-local exit", but the problem cases for both topics are the same.The goal of the MINIMAL proposal is to clarify the ambiguity in CLtL whileminimizing changes to the current situation. The MEDIUM proposaldefines the extent of an exit to end at the last moment possiblewithin some particular reference implementation.  It hasa cost to implementors whose implementation is not identical to thereference implementation.  Another alternative proposal, not consideredhere, would duck the issue by outlawing all non-local exits from UNWIND-PROTECTcleanup forms. That alternative would have a substantial cost to some users.Scheme is cleaner: it avoids this issue by specifying that the extentof an exit never ends.An argument for the MEDIUM proposal was made based on the example:  (block foo    (block bar      (unwind-protect          (return-from foo 'foo)        (return-from bar 'bar))))Since there is no reason for FOO and BAR not to be treated interchangeably,calling this an error would be inappropriate. It was argued that the MINIMAL proposal is equivalent to practicallyoutlawing non-local exits from UNWIND-PROTECT cleanup clauses, becausethere is no general way to determine the target of the non-local exitthat caused the cleanup clause to be invoked. The following example was offered as an argument against MINIMAL. Given:    (block nil      (handler-case          (unwind-protect (return)            (error "foo"))             ;probably an error, under the proposal        (error ()          (print "foo"))))If the ERROR handler has the same scope and extent a CATCH in the same placewould have (and that seems reasonable, though I'm not certain that thecondition system specifically requires that interpretation), then the handlerwill be apparent to the call to ERROR, but will no longer be a valid target(its extent was exited by the RETURN in the UNWIND-PROTECT body).The extent of an object with dynamic extent is the extent of the form which created it.  Code which is executed "within" that form is withinthe extent of the object(s).  This applies to all dynamic objects, suchas special variable bindings, not just exits.  Actually, I think the intentof the implementation note on p.142 is fairly clear and supports thisinterpretation.  The supposedly ambiguous use of "frame" should be readas something like "form which establishes a dynamic extent".  It might beclearer if the last sentence were changed to read something like:"On the second pass the stack is actually unwound.  Each form which establishesa dynamic extent is undone in reverse order of creation until the matchingCATCH is reached.  The meaning of undoing a form depends on the type of form.For UNWIND-PROTECT, it means executing the cleanup forms.  For CATCH it meansremoving the CATCH tag.  For dynamic bindings it means undoing the binding,restoring the previous saved value. {This is not an exhaustive listing of thepossibilities.}" 