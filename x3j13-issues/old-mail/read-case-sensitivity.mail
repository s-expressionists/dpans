*start*07638 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 FEB 89 12:44:06 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 15 Feb 89  12:42:51 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa09338; 15 Feb 89 20:12 GMTDate: Wed, 15 Feb 89 20:34:12 GMTMessage-Id: <4922.8902152034@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Issue: READ-CASE-SENSITIVITY (Version 1)To: CL-Cleanup@sail.stanford.eduCc: richard%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKIt may be rather late for new issues, but I think this one shouldstill be considered.  The proposal below is fairly minimal.  Morefar-reaching proposals, or ones that are better in other ways, arealso possible; but this seems a good place to start.A longstanding problem in Common Lisp is that the reader alwaysconverts unescaped characters in symbol names to upper case.This makes a number of applications more difficult than theyshould be and looks like an oversight (especially given theexistence of *PRINT-CASE*).This problem is an easy target for critics of Common Lisp andtends to imflame opinion.  Here are three comments I have seenrecently in the UK:   [...] particular small lunacies (e.g. the printer can be parameterised   to case fold everything to lower case, but the reader ALWAYS folds   to upper case, which is a real nasty for people who would like   to write their own code in case sensitive styles with Car, CAR and car   baing different.  E.g. it means that using the Lisp reader to accept   (as a cheap way of so doing) natural language stuff from the user   necessarily loses capitalisation, which is STUPID.  I also happen to   consider it ill-judged and a throw-back the TTY33s and punched cards   to work in UPPER CASE FOR ALL LISP INTERNAL DATASTRUCTURES, SINCE I   RATHER EXPECT MOST CURRENT PROGRAMMING STYLE IS BASED AROUND USE OF   LOWER OR MIXED CASE.   I also have a feeling the it is perpetuating the punched card era to   have a so called modern language work entirely in upper case inside   itself, and amazing to go to the trouble for case folding on both   input and output to paper over this, and even more bizzare to make the   output folding optional but not the input...)   The single thing which is left which most upsets me is the bloody   upper-case only reader - I *can't believe* that anyone thinks that's   a good idea.Of course, it is not just to answer such criticism that I proposethis change.-----Issue:        READ-CASE-SENSITIVITYForum:	      CleanupReferences:   CLtL p 334 ff: What the Read Function Accepts;                especially p 337.              *PRINT-CASE* (CLtL, p 372)Category:     ADDITION/CHANGEEdit history: 15-Feb-89, Version 1 by DaltonStatus:	      For Internal DiscussionProblem Description:  The Common Lisp reader always converts unescaped constituent  characters to upper case.  (See CLtL, p 337, step 8, point 1.)Proposal (READ-CASE-SENSITIVITY:LIKE-PRINT-CASE)  Add a new read parameter, *READ-CASE*, to control case  sensitivity.  By analogy with *PRINT-CASE*, it may take the  following values:    :UPCASE   --  convert unescaped characters to upper-case, as now.    :DOWNCASE --  don't convert, leaving lower-case letters in lower                  case.  This proposal does not provide a way to tell the reader to convert  upper-case letters to lower-case.  This is consistent with *PRINT-  CASE*, which does not provide a way to print lower-case letters in  upper-case.  Note that an isomorphic proposal that would not emphasise an  analogy with *PRINT-CASE* would be to add a parameter called  *READ-CASE-SENSITIVE*, taking the values T (to preserve case)  or NIL (to convert to upper case).  Yet another proposal might  be to add a function READ-PRESERVING-CASE (hee hee).Rationale:  There are several reasons for this proposal.  1.  Lisp applications often use the Lisp reader to read their data.  This is often significantly easier than writing input routines  from scratch, especially if the input can be structured as lists.  However, certain applications want to make use of case distinctions,  and Common Lisp makes this unreasonably difficult.  (You must define  every letter as a read macro and have the macro function read the  rest of the symbol.)  2.  Some programming languages distinguish between upper and lower  case in identifiers, and useful conventions are often built around  such distinctions.  For example, in C, constants are often written  in upper case and variables in lower.  In Mesa(?) and Smalltalk(?),  a capital letter is used to indicate the beginning of a new word  in identifiers made up of several words.  In Edinburgh Prolog,  variables begin with upper-case letters and constant symbols do  not.  The case-insensitivity of the Common Lisp reader makes  it difficult to use conventions of this sort.  3.  Among Lisp dialects, Common Lisp gives an unusual degree of  control over the case of output.  However, there is no control over  the treatment of case on input.  This makes the language unbalanced.  We live in a mixed-case world, and it should be possible to make use  of case distinctions in Common Lisp.Test Case:  (let ((*read-case* :downcase))    (read-from-string "Zebra"))  = ZEBRA     ;under CLtL  = |Zebra|   ;under this proposalCurrent Practice:  I do not know of any implementation that implements this proposal.  Franz Inc's ExCL has (or at least had) a function, excl:set-case-mode,  that set both the "preferred case" (the case of character in the print  names of standard symbols such as CAR) and whether or not the reader  was case-sensitive.Cost to Implementors:  Fairly small.Cost to Users:  None, this is a compatible change from the user's standpoint.Cost of Non-Adoption:  Applications that want to read mixed-case expressions will not  be able to use the Common Lisp reader to do so (except, perhaps,  by tortuous use of read macros).  Programming styles that rely on case distinctions (without escape  characters) will be impossible.Benefits:  Applications will be able to read mixed-case expressions.  Programmers will be able to make use of case distinctions.Aesthetics:  For the proposal:  The language will have greater symmetry.  The language will look less old-fashioned.  Against the proposal:  The addition of another global parameter to control yet another  aspect of I/O is inelegant and increases clutter.  In favor of additional or more far-reaching changes:  Anyone wishing to make use of case distinctons in Lisp programs  will have to write the names of symbols in the "LISP" package in  upper case.Discussion:  Larry Masinter suggested at one point that case sensitivity could  be an aspect of read tables rather than a separate parameter.  There may be several ways of doing this.  For example, it might  be a property of each character or of the table as a whole.  An interesting possibility would be to disguise the preferred  internal case by defining a value for *READ-CASE* called :INVERT.  If the value were :INVERT, mixed-case symbols would remain the same  (or perhaps they would be inverted too) but all upper case input  would specify a lower-case name internally, and vice versa.  You may recall that something similar was suggested for pathnames.  Dalton supports the proposal LIKE-PRINT-CASE.*start*07666 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 FEB 89 13:31:21 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Feb 89  13:31:01 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 539857; Wed 15-Feb-89 16:28:54 ESTDate: Wed, 15 Feb 89 16:28 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: READ-CASE-SENSITIVITY (Version 1)To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKcc: CL-Cleanup@sail.stanford.edu, richard%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKIn-Reply-To: <4922.8902152034@subnode.aiai.ed.ac.uk>Message-ID: <890215162833.3.KMP@BOBOLINK.SCRC.Symbolics.COM>I appreciate your good intentions in writing this proposal, however Ido not agree that the proposal satisfies its stated goals withoutintruding.I will begin by making a few remarks about case-sensitivity, how (bymy recollection) we came to the state that we're in, and why I don'tthink the state is as bad as portrayed. Then I'll move to criticismsof the proposal itself, and finally to suggestions about alternateways to proceed if you want to pursue this further.EQ symbols cannot print differently in different places without helpfrom some global context switch.  *PRINT-CASE* is such a switch.If case is -ever- to be signficant, case must be preserved internally.That is, to even accomodate the idea that |CAR| and |car| might denotedifferent symbols, it is necessary to define that the internalrepresentation distinguishes |CAR| from |car|.  CLtL indicates that thisis true.If case is significant internally, then every symbol must have awell-defined internal casing in order to be found. That is, since by theprevious paragraph |CAR| is distinct from |car|, we must say whether CARdenotes the former or the latter.An arbitrary choice must be made between whether CAR maps to |CAR| or|car|. Otherwise, when you do (DEFUN CAR ...), you have to createsymbols |CAR|, |CAr|, |CaR|, |Car|, |cAR|, |cAr|, |caR|, and |car| andput the definition in all of them in order to not cause confusion whenyou later do (Car x).Some case had to be chosen. The arbitrary choice made was uppercase.Personally I think this was the right choice, but I recognize that otherswould have preferred lower. In any case, the operative word is "arbitrary".Any change at this point would be de-stabilizing to no good end.If lowercase had been chosen, we might be listening to uppercase enthusiastscomplain that lowercase looks dumb. In the end, that form of argument hasto be discounted as useless because it cannot lead to a resolution that willbe happy for all.What should be the issue is: what options and tools can we provide thatallow as wide a variety of user programming styles as possible withoutbreaking the ability to load code written by different programmers intothe same environment.*PRINT-CASE* was very carefully chosen after a -huge- amount ofdiscussion to permit flexibility -without- affecting the semanticcorrectness of code. That is, if you set *PRINT-CASE* globally, youdon't interfere with the correct operation of libraries that othershave written, regardless of whether their original program orruntime data is uppercase, lowercase, or mixed case. On the other hand, your proposed *READ-CASE* does not have this property.You could not set it reliably because you would never know when somemacro or some data-manipulating utility would call something likeREAD-FROM-STRING behind your back and get screwed because you'd changedthe semantics of that operation. It would therefore not contribute tomodularity.In spite of what I would characterize as superficial criticisms frompeople about Common Lisp and/or *PRINT-CASE*, I think that in fact wehave made a very reasonable compromise between flexible style and theneed for programs to snap together reliably.  Your *READ-CASE* proposalis incomplete because the test case does not show the calling of abuilt-in function. Leaving aside issues of what would out and out breakif you set *READ-CASE* to :DOWNCASE, you'd end up having to write  (CAR Zebra)rather than being able to write (as you already can) (Car Zebra)for example. I personally think this is ugly, and I think many noviceswould mis-read the documentation and believe that if they set thisvariable, they could use lowercase ... only to find that they got confusing undefined-function warnings which they do not currently get.A more technically reasonable alternate solution might be to extend*PRINT-CASE* to take a sort of alist as a value. Eg, consider: ((ZEBRA . "Zebra") :UPCASE)so that you could override the casification of some words on a case-by-case basis and then fall through to a general rule. However,my guess is that while this is technically workable, it would betoo tedious in practice (and perhaps to computationally expensivefor the printer if the alist got very long).I am also ammenable to the idea of creating a portable way to modifythe readtable to turn off case translation. We should strongly discouragepeople from doing this to the default readtable because it would have aninvasive effect on programs they didn't control and perhaps didn't evenrealize existed, but the idea of constructing private readtables thatdon't case-translate for whatever purposes seems highly reasonable.This would address points #1 and #2 in your rationale, which I agree isan excellent point. [Btw, that sort of thing should be in the problemdescription.]Point #3 of the Rationale is, as I've discussed, not a problem but afeature. It's perhaps not as strongly motivated in the writeup as itmight be, but I stand by it strongly.Regarding your final `Rationale' statement: ``We live in a mixed-caseworld, and it should be possible to make use of case distinctions inCommon Lisp.'' I agree only to the extent that it does not harm program modularity. My two counter-suggestions above are intended tohelp clarify the point that I am not objecting to your problem description as unreasonable but rather to your solution as overly naive.Also, following directly from my above remarks, your Cost of Users isdrastically understated. The feature is not compatible since the verypresence of *READ-CASE* would mean that programs would not snap togetherreliably if this variable were ever set. In practice, this would meanthat any call to READ would have to be surrounded by a binding of*READ-CASE* just in case.  Rather than your whimsy suggesting ofREAD-PRESERVING-CASE, you'd end up with a desperate need forREAD-IGNORING-CASE all over the place just in case you ever loaded intoa hostile environment where READ did not behave as expected.Regarding your statement of Aesthetics, I certainly don't think theaddition of another switch would be a big deal if it would buy somethinguseful in a non-invasive way.One parting remark, I think the proposal name LIKE-PRINT-CASE is confusing.I would have expected that to mean `things typed in get downcased.' Onlypragmatics would tell me this is ludicrous. Since I sometimes suspectthat some people don't really read much if any of these writeups and thatthese proposal names end up having undue weight, I'd prefer something else.Ok, two parting remarks, :DOWNCASE should really be :DONT-UPCASE since itdoesn't really distinguish :CAPITALIZE from :DOWNCASE.Anyway, as it stands, Pitman is steadfastly opposed to LIKE-PRINT-CASEfor the stated reasons.*start*02243 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 FEB 89 14:35:50 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 15 Feb 89  14:35:41 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 15 FEB 89 13:53:33 PSTDate: 15 Feb 89 13:53 PSTFrom: cutting.paSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 15 Feb 89 16:28 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: jeff@aiai.edinburgh.ac.uk, CL-Cleanup@sail.stanford.edu, richard@aiai.edinburgh.ac.ukMessage-ID: <890215-135333-1329@Xerox>  Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 FEB 8913:31:21 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) bySAIL.Stanford.EDU with TCP; 15 Feb 89  13:31:01 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM bySTONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 539857; Wed15-Feb-89 16:28:54 ESTDate: Wed, 15 Feb 89 16:28 EST  From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>  *PRINT-CASE* was very carefully chosen after a -huge- amount of  discussion to permit flexibility -without- affecting the semantic  correctness of code. That is, if you set *PRINT-CASE* globally, you  don't interfere with the correct operation of libraries that others  have written, regardless of whether their original program or  runtime data is uppercase, lowercase, or mixed case.   On the other hand, your proposed *READ-CASE* does not have this property.  You could not set it reliably because you would never know when some  macro or some data-manipulating utility would call something like  READ-FROM-STRING behind your back and get screwed because you'd changed  the semantics of that operation. It would therefore not contribute to  modularity.How is *READ-CASE* any different than *PACKAGE*, *READ-BASE* and*READTABLE* in this respect?  They all change the semantics ofREAD-FROM-STRING, occasionally even screwing things up.  There isprecedent.*start*03374 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 FEB 89 15:09:18 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Feb 89  15:09:31 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 539957; Wed 15-Feb-89 18:07:11 ESTDate: Wed, 15 Feb 89 18:06 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)To: cutting.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COM, jeff@aiai.edinburgh.ac.uk, CL-Cleanup@sail.stanford.edu, richard@aiai.edinburgh.ac.ukIn-Reply-To: <890215-135333-1329@Xerox>Message-ID: <890215180644.6.KMP@BOBOLINK.SCRC.Symbolics.COM>That's quite a reasonable point -- for *READ-BASE* especially --however, I am not devoid of remarks to make... 1. It is arguably necessary to vary *PACKAGE* in order to    achieve a certain kind of modularity. Indeed, a certain amount    of confusion is almost intentional in the package system in    this regard. There is `deliberate ambiguity' in unqualified    symbols, you might almost say. I certainly grant you that    it leads to troubles every now and then, though. 2. Of late I've been seriously questioning whether anything so    important as the base ought to be allowed to fluctuate. We    certainly pay a big price for that flexibility. Nevertheless,    both this and *READTABLE* do indeed provide creative ways for    modules to screw each other. 3. *READTABLE* is already powerful enough to provide what you need    if only there were a way of suitably modifying a readtable. 4. One of the reasons we can survive at all with *PACKAGE*, etc.    is that good programmers know there is a finite set and they    carefully bind the ones that matter around individual calls to    READ, or around module boundaries, or whatever. To introduce    a new one at this point is the same kind of destabilizing thing    as introducing a new special form. (Of course, since we've recently    introduced some new special forms, this isn't a hard and fast    argument, but it is a moral dilemma we had to contend with when    adding those special forms and I think we should have to wrestle    with it here anyway.) 5. Just because there is precedent for problem doesn't mean we should    invite more problems based on that precedent. You yourself admit    that *PACKAGE* and friends invite problems.1 and 2 are just my personal thoughts and I don't expect them tocarry any argumentative weight.4 and 5 are issues I think we can't ignore.The option of doing 3 is compelling to me. I think this is the pastof least resistance. I think it is just complicated enough that naiveusers will not do it accidentally and then run into problems, yetstraightforward enough that no one who needs case preservation willhave any trouble figuring out what to do.I think someone should therefore instead propose that we introduce someoperation like SET-CHARACTER-CASE-TRANSLATION (or perhaps something more general like Genera's SET-CHARACTER-TRANSLATION, which I think -- I didn'tlook up its documentation recently -- allows you to say that arbitrarychars are translated to arbitrary others).*start*01695 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 FEB 89 12:41:06 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 16 Feb 89  12:41:26 PSTReceived: from relay2.cs.net by RELAY.CS.NET id as04062; 16 Feb 89 14:41 ESTReceived: from draper.com by RELAY.CS.NET id ab10531; 16 Feb 89 14:37 ESTDate: Thu, 16 Feb 89 08:08 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)To: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525Re KMP's reply to jeff:  Without disagreeing with those arguments, I wouldpoint out that much of the problem Kent finds with the use of *READ-CASE*applies equally well to *PACKAGE*.  (The main difference is that you normallyexpect symbols like CAR to be "already around" and therefore not interned inthe "wrong" package - but this is analogous to typing CAR in uppercase underthe proposal.)  Users already have to beware of some random piece of codechanging the value of *PACKAGE* and affecting the way symbols get read in.Is this so different? Also, the horror of having to type CAR instead of car doesn't bother folkswho are used to UNIX and C.   A similar topic raged on the common-lisp list several years back, as I recall,with the upshot being that only the franz community wanted or cared aboutcase sensitivity (or was it forced downcasing?) in the reader, and everyoneelse thought it was a bad idea.  This may still be true, but (a) Jeff'sproposal seems more well thought out, and (b) UNIX isn't as much of an alienforce as it once was.*start*04241 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 FEB 89 07:59:18 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 16 Feb 89  07:56:58 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06670; 16 Feb 89 15:18 GMTDate: Thu, 16 Feb 89 15:41:29 GMTMessage-Id: <6347.8902161541@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)To: Kent M Pitman <KMP@scrc-stony-brook.arpa>, cutting.paCc: CL-Cleanup@sail.stanford.edu, richard%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>  3. *READTABLE* is already powerful enough to provide what you need>    if only there were a way of suitably modifying a readtable.>> I think someone should therefore instead propose that we introduce some> operation like SET-CHARACTER-CASE-TRANSLATION (or perhaps something more > general like Genera's SET-CHARACTER-TRANSLATION, which I think -- I didn't> look up its documentation recently -- allows you to say that arbitrary> chars are translated to arbitrary others).I would be perfectly happy with such a proposal.  I am surprised,though, that my suggestion is as controversial as it seems to be.Right now I can change the operations of READ in lots of ways, bysetting the input base, by defining macro characters, and so on.  Idon't see why a simple thing like case sensitivity is such a problem.Indeed, you don't really seem to think it is, for you seem willing tohave it done by the read table, just not by a new parameter.Some of your arguments are against the whole idea of case-sensitivity,others against the addition of *READ-CASE*, and others against theadmittedly somewhat peculiar interpretation of :UPCASE and :DOWNCASE(but I think the interpretation of these values for *PRINT-CASE* isalso not what one would immediately expect).  This mixture isconfusing.  At some times, it seems that you hate every aspect of theproposal, but at others that all you really dislike is the theaddition of a new parameter (admittedly a problem that is not justaesthetic) and the particular keyword values I propose.One reason I proposed a parameter rather than a readtable operationwas that it seemed more consistent with the way the rest of CommonLisp worked.  (And, I suppose, because some other Lisps worked thatway.)  BUT, I don't really want to argue this point.  Indeed, I nowwould say I was wrong.However, I had to pick one of the many possible proposals as astarting point, and the addition of a new parameter looked simplerthat trying to handle all the versions of readtable operations.I tried to at least hint at other possibilities at variouspoints, but I didn't want to write a complicated proposal thatconsidered everything until I had some feedback.As for the issue of case distinctions in code, I did expect that tobe controversial.  But I don't want disputes of that sort to dooma facility that is also useful in applications.I do not actually find the arguments for using case distinctions inLisp code all that important (perhaps because I don't expect to do itmyself), but it is definitely useful for applications to be able touse READ in a case-sensitive way.  The difficulty of doing this hascome up again and again (at least here), and it is difficult toexplain why Common Lisp does not provide this capability in anyreasonable way, especially since it provides much more powerfulthings such as character macros.However, one of my reasons for submitting this proposal was simply tomake the rationale explicit.  And there your messages are veryhelpful.  I didn't try to make every point for and against myself,because I hoped the discussion would do some of it for me.  I don'tthink I completely overlooked the points you've raised, but I didn'ttry to put them all in the proposal, and we obviously assign themdifferent weights.  Now I'd like to revise and try again.  (Well,actually I'll wait 'till the dust settles a bit.)Although this issue is in some ways trivial, I do think it isimportant.-- Jeff*start*06219 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 FEB 89 08:56:44 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 16 Feb 89  08:56:50 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 540363; Thu 16-Feb-89 11:54:05 ESTDate: Thu, 16 Feb 89 11:53 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, cutting.pa, CL-Cleanup@sail.stanford.edu, richard%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKIn-Reply-To: <6347.8902161541@subnode.aiai.ed.ac.uk>Message-ID: <890216115342.1.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Thu, 16 Feb 89 15:41:29 GMT    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>    ... Right now I can change the operations of READ in lots of ways, by    setting the input base, by defining macro characters, and so on.  I    don't see why a simple thing like case sensitivity is such a problem. ...Actually, this makes me all the more certain that the readtable is theright way to go. The reason is that you can imagine a world in which Ihave hacked the readtable to get me case sensitivity but you have bound*READ-CASE* to ignore case sensitivity. This is something of an invincibleforce and an impentrable barrier problem -- two conflicting goals usingorthogonal mechanisms such that it's impossible to weigh their importanceadequately. By forcing us to use the same mechanism, we see that we eitheruse your readtable or mine, or that both readtables are the same and you'vemucked up mine or I've mucked up yours. This reduces the problem from oneof the system trying to arbitrate a situation it cannot hope to settle fairlyto a simple program bug -- one or the other of us will send nasty mail tothe other and the system won't be caught in the middle.By the way, as a slightly tangential remark, I think that *READTABLE* ismisnamed. I really think it should be called *SYNTAX*, or perhaps even*LANGUAGE*.  The reason is that the printer needs to be affected inlockstep when you bind the reader in order to preserve PRINT/READconsistency. So if I change my backslash character to slash in SymbolicsCommon Lisp, the printer must know to write /a rather than \a. Callingit *SYNTAX* would divorce you from the idea of READ-only effects, sincesyntax can address printing as well. Once you study the issue a bitmore, you realize there are other dynamic properties of a languagewhich it is -also- useful to bind when running programs from one orthe other language which have nothing to do with PRINT/READ. If youallow them to be bound separately, you get in weird situations whereyou have hybrid environments that have `Common Lisp syntax' but`the Zetalisp package system' but ... Almost never do these things turnout to be useful. Usually they are the result of binding too few variablesin lockstep. If *SYNTAX* were further generalized to encompass non-print-read kinds of things, you might call it *LANGUAGE*. By having asingle variable, it would always get bound consistently. (If you reallystill wanted a new language, you could make a new object which had thesame blends of things, but you could not do it by accidentally bindingone too few variables.)    ... At some times, it seems that you hate every aspect of the    proposal, but at others that all you really dislike is the the    addition of a new parameter (admittedly a problem that is not just    aesthetic) and the particular keyword values I propose.People are complex entities. They must weigh the realities of the world,which are rarely black and white. My message may have drifted back andforth but was intended to expose the basis for my reasoning, which I mustultimately boil down to a single recommendation. If I choose to say justmy opinion, you'd think me stubbornly dogmatic. At least with the additionalinformation you know I've given the issue some thought.    ... I had to pick one of the many possible proposals as a    starting point ...I'm glad you did. If you're happy with the readtable solution, I thinkthere's a good chance you'll come up with something I can endorse.I thought more about the analogy to adding special forms last nightand decided that the analogy is slightly misaligned -- the real truthis that the `fixed number of special forms' only affects people writingcode-walkers. Adding special forms isn't so good, but affects only a few programs. Adding a new variable of this type would break a huge numberof Common Lisp programs because a huge number call READ and becauseCL programs are assumed to `act defensively' (bind variables they worrymight be wrong). Since no existing program can have anticipated the needto defend itself against this `problem,' no program will be ready andthe Cost To Users is (as I said) large. I think this consideration hasto be overriding.I admit that if we were starting anew, compatibility would not be anissue and I could not argue against *READ-CASE* on the basis of compatibilty.But if we were really starting anew, I would argue for *SYNTAX* or*LANGUAGE* in order to accomodate the bundling of linguistic featuresas a unit. And READ-CASE then would be likely be a slot in that structure,just as it's conceptually a slot in your `frame' for computer languagesin general. And I would argue that you should not set the slot, or any slot,because changing any named language only gratuitously breaks those programswhich thought they knew what the semantics were at the time when they wrotethem. There's never really any problem about just spawning a new languagebecause no matter what syntax/semantics you give it, you never break programsin other languages.I'll stop here before I start to question why we're changing a single letterof CLtL in order to produce ANSI CL and to ask why we don't just call thelanguage we're designing something else so we don't break programs... :-)*start*08788 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 FEB 89 11:04:41 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 16 Feb 89  11:01:58 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa09136; 16 Feb 89 18:53 GMTDate: Thu, 16 Feb 89 18:49:52 GMTMessage-Id: <7024.8902161849@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)To: Kent M Pitman <KMP@scrc-stony-brook.arpa>In-Reply-To: Kent M Pitman's message of Wed, 15 Feb 89 16:28 ESTCc: CL-Cleanup@sail.stanford.edu, richard%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK> I appreciate your good intentions in writing this proposal, [...]It's sometimes difficult to reply to a long message, for the reply maybe long as well, an no-one really wants to read a bunch of longmessages.  So I will try to keep this as short as possible.First, I think we should separate some issues:  0. Lower-case vs. upper-case.  1. Case-sensitivity in code (as a style or convention).  2. Case-sensitivity as an option when reading.  3. The addition of a new parameter vs. an operation on readtables.  4. The particular choice of *READ-CASE*, :UPCASE, and :DOWNCASE.I, personally, do not want to argue about whether (1) is a good idea.It's the sort of thing about which people can endlessly disagree.  Thesame goes for (0).  I don't have any particular attachment to (5) andam willing to revise the proposal or to see an alternative fromsomeone else.  That leaves (2) and (4).     Should Common Lisp support case-sensitive reading?There are a number of applications that could make good use of theCommon Lisp reader except for one thing: the reader does not preservecase.  I would like to help these applications.  In addition,programmers who wanted to wanted to use case distinctions in codewould find it easier to do so.  You can regard this as an applicationif you wish: there is a language very like Common Lisp only...Common Lisp already allows the user to change the meaning ofcharacters by defining character macros, by changing the baseof numbers, and so on.  While some of these may be a bad idea,character macros (at least) can be defended.  So I don't thinkany arguments that apply just as well to character macros arevery compelling.     New parameter or readtable operation?Kent has argued well against the addition of a new parameter.Any code that thinks it already takes all read parameters intoaccount would have to change.  So there is a potentially highcost to users.A readtable operation would involve only an existing parameter,*READTABLE*.  However, if all we want is to set whether the reader iscase-sensitive or not, something that lets us have any charactertranslated to any other is arguably too powerful.  I don't want tohave a long debate about whether or not it's a good thing; and I canimagine that some people might feel quite strongly that it is not.Also, it's not a particularly convenient way to change casesensitivity (though it's not all that hard).  However, a read tableoperation that just changed case sensitivity seems strange.  Thenumber base isn't part of the readtable, so why should this be?And should it be a keyword argument to COPY-READTABLE?  I wanted(at least initially) to avoid such questions and to present aproposal that seemed simpler (think, e.g., of what it would taketo write the test case).I am willing to go either way, but I would like to know whatpeople think.  I would have presented more options in the initialproposal, but I think it's best to have one option if we know it'sthe only one we really want.                    -----Responses to specific points follow:> If case is -ever- to be significant, case must be preserved internally.> [...]  CLtL indicates that this is true.> If case is significant internally, then every symbol must have a> well-defined internal casing in order to be found.> An arbitrary choice must be made between whether CAR maps to |CAR| or> |car|.I agree.> Some case had to be chosen. The arbitrary choice made was uppercase.> Personally I think this was the right choice, but I recognize that others> would have preferred lower.The general trend is towards writing code in lower case.  The Tsources are now in lower case, Winston and Horn 3e uses lower case.Both used to be upper.  I think it may have been shown that lower caseis easier (for most people?) to read.  Still, this is to a large extenta matter of taste and not something that this proposal would change.> [...] if you set *PRINT-CASE* globally, you don't interfere with the> correct operation of libraries that others have written, That is true, but setting *READTABLE* does interfere with the correctoperation.  So this is not something Common Lisp has carefully avoidedso far.  Indeed, I think it is a good thing that the reader can beused to read in other than the standard way, though perhaps not a goodthing that it is controlled by global parameters.This line of argument would be better if the read table were one ofthe arguments to read rather than controlled by a special variable.> In spite of what I would characterize as superficial criticisms from> people about Common Lisp and/or *PRINT-CASE*,The criticism issue is a fairly complex one.  Some people makewild claims about Common Lisp and cite "easy targets" such as FORMAT.Often there is something reasonable behind the complaints, but it isoften difficult to find it out.  With fewer easy targets it would beeasier to get at the real problems, and wild claims would be harderto make.  People would have to think harder.Anyway, a number of reasonable people who are quite willing to useCommon Lisp have applications in which they could use a case-sensitivereader.  They are often surprised to find that there's no way to doit.> Your *READ-CASE* proposal is incomplete because the test case does> not show the calling of a built-in function.OK.  I'm not sure how much test cases have to cover.  There arecertainly other proposals that do not test every consequence.Anyway, since it's dangerous to set *READ-CASE*, I rebound itinstead, since that is what I think people will do.> Leaving aside issues of what would out and out break> if you set *READ-CASE* to :DOWNCASE, you'd end up having to write >  (CAR Zebra)That one must write CAR is mentioned in the aesthetics.> A more technically reasonable alternate solution might be to extend> *PRINT-CASE* to take a sort of alist as a value. Eg, consider:>  ((ZEBRA . "Zebra") :UPCASE)That seems to address a completely different issue (something aboutoutput rather than input, it appears).> I am also amenable to the idea of creating a portable way to modify> the readtable to turn off case translation.I am also amenable to that idea.> Point #3 of the Rationale is, as I've discussed, not a problem but a> feature. It's perhaps not as strongly motivated in the writeup as it> might be, but I stand by it strongly.I'm not sure what you mean here.  I don't think it's a problem thatCommon Lisp has *PRINT-CASE*, but I do think it's a problem thatthere's no way to control the way the reader treats case.> My two counter-suggestions above are intended to> help clarify the point that I am not objecting to your problem > description as unreasonable but rather to your solution as overly> naive.What I think is most suspect about my proposal is the attempt toparallel *PRINT-CASE*.  I do not think the addition of a new variableis necessarily unreasonable, since it is in some ways the simplestsolution.> Also, following directly from my above remarks, your Cost of Users is> drastically understated.Very true.  I was not thinking clearly.> The feature is not compatible since the very> presence of *READ-CASE* would mean that programs would not snap together> reliably if this variable were ever set. In practice, this would mean> that any call to READ would have to be surrounded by a binding of> *READ-CASE* just in case.I think that's going a bit far.  After all, it's not now the case thatevery call to READ is surrounded by a binding of *READTABLE*.> One parting remark, I think the proposal name LIKE-PRINT-CASE is confusing.> I would have expected that to mean `things typed in get downcased.' Only> pragmatics would tell me this is ludicrous. I would have used NEW-PARAMETER (which is also perhaps ambiguous,since it might mean an argument to PRINT) except that there wereseveral possible new-parameter proposals.-- Jeff*start*04254 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 FEB 89 12:15:14 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 16 Feb 89  12:15:29 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA21232; Thu, 16 Feb 89 12:13:52 PSTReceived: from denali.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA03738; Thu, 16 Feb 89 12:10:25 PSTReceived: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA05969; Thu, 16 Feb 89 12:13:18 PSTMessage-Id: <8902162013.AA05969@denali.sun.com>To: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Cc: Kent M Pitman <KMP@scrc-stony-brook.arpa>Cc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 1) In-Reply-To: Your message of Thu, 16 Feb 89 18:49:52 +0000;	<7024.8902161849@subnode.aiai.ed.ac.uk> .Date: Thu, 16 Feb 89 12:13:17 PSTFrom: peck@Sun.COMSome random thoughts on READ-CASE-SENSITIVITY.First let's remember that we're not asking for more functionality,in this issue, we're looking for a way to make READ do *less*.In the naive world, strings would read as they were written,and, oops, symbols naively interned would choke on mixed case.Two alternatives have been mentioned so far:  1. Change the code in READ to not coerce to uppercase (controlled somehow)  2. Use *readtable* to produce the new effect. There is another possible solution:  3. Introduce a new function to provide what you want.Kent states that the status quo was done so that programs wouldbe more portable (or portable at all) among uppercase sourceand lower or mixed case source files.Kent further suggests that using *readtable* would be an appropriate way to avoid upcasing.  [if using readtables to control casing behavior is sostraight forward, why was the status quo implemented as a change to READ,rather that as a change to *readtable*?  ;-]  [[no flames please, I answer this for myself three paragraphs down...]]Plenty of discussion about the danger of reading code when *read-base* or*readtable* is set inappropriately.  Also, plenty of discussion thatPROVIDE/REQUIRE don't port. Really, portable code should come withits own loader which rebinds reader controls and loads its files as needed.Dalton states:>There are a number of applications that could make good use of the>Common Lisp reader except for one thing: the reader does not preserve>case.  I would like to help these applications.  In addition,>						  ^^^^^^^^^^^>programmers who wanted to wanted to use case distinctions in code>would find it easier to do so.  You can regard this as an application>if you wish: there is a language very like Common Lisp only...I'm all for mixed/lower case (I like Franz's  solution) but let's face it:*** READ is designed for reading programs (symbols, lists, structs, etc). ***It sounds like you are not primarily concerned with wanting"to use case distinctions in code". So, READ should not be changed.Dalton, about these large bodies of code which could use READ, exceptfor the caseing behavior:  can they survive what READ will do withchars like #\# #\: #\\ #\| #\` #\( #\) when they are read?If you are not using READ for code or symbol and package rules,the what do you get from READ?  the *readtable*?To read text you really need to use READ-CHAR or READ-LINE.Even if READ can be used, is it really a good idea? Do you really want to cons a symbol for everything that READ would break into a token?Maybe you should suggest a READ-TOKEN or READ-SYMBOL functionthat parses like READ (if your really want that) and returnsa symbol (interned where?) or maybe just a READ-WORD thatdoes READ-CHAR up to the next whitespace and interns the string?Given READ-LINE and READ-CHAR and the multiple interpretations ofwhat and when should you break symbols out of text, why/how should this be standardized?  [Better Lisp environments come with an Emacs (or whatever), that is maybe the correct place for text processing Upcase/mixed-case word parsing, etc.]Whatever we decide about this, lets make sure it makes sense with thenewly proposed internationalize character operations.*start*03911 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 FEB 89 10:30:47 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 17 Feb 89  10:30:30 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa09986; 17 Feb 89 18:07 GMTDate: Fri, 17 Feb 89 18:04:32 GMTMessage-Id: <9819.8902171804@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1) To: peck@sun.com, CL-Cleanup@sail.stanford.eduIn-Reply-To: peck@com.sun's message of Thu, 16 Feb 89 12:13:17 PSTCc: Kent M Pitman <KMP@scrc-stony-brook.arpa>> I'm all for mixed/lower case (I like Franz's  solution)But it's hard to make their change over a single call to read.> but let's face it:> *** READ is designed for reading programs (symbols, lists, structs, etc).> *** It sounds like you are not primarily concerned with wanting> "to use case distinctions in code". So, READ should not be changed.READ is not just for reading programs, it is for reading data too.Lists, symbols, etc. are used outside of source code, after all.Is this really a controversial point?The whole readtable mechanism is there so that the behavior ofREAD can be modified.  And it is not unusual for READ to be usedto parse things that are not standard-syntax Common Lisp sourcecode.> Dalton, about these large bodies of code which could use READ, except> for the casing behavior:  can they survive what READ will do with> chars like #\# #\: #\\ #\| #\` #\( #\) when they are read?Well, I don't know about "large bodies of code".  But certainlya number of people just here at Edinburgh have wanted to use READ,but case-sensitive.  They have wanted to read expressions thatwere sufficiently like Lisp's that a good way to read them wasto modify the readtable a bit.  But they also wanted to preservecase distinctions. The reason they can't "use READ" is that the readtable mechanism,and the other ways to affect READ's behavior, still fall short.You are right to note that it is difficult to change the behavior of#\: in certain ways, and that one might want to do so.  This can be apain (though I'm sure there's a good reason for it somewhere), butmost of the changes one might want to make can be done by definingit as a macro.(BTW, if anyone wonders, the none of the critical comments Iquoted before the start of the proposal were from Edinburgh.)> If you are not using READ for code or symbol and package rules,> the what do you get from READ?  the *readtable*?The read base too.> To read text you really need to use READ-CHAR or READ-LINE.I agree completely.> Even if READ can be used, is it really a good idea? Do you really want > to cons a symbol for everything that READ would break into a token?Sometimes a symbol is exactly what I want.  Symbols are a useful,after all.> Maybe you should suggest a READ-TOKEN or READ-SYMBOL function> that parses like READ (if your really want that) and returns> a symbol (interned where?) or maybe just a READ-WORD that> does READ-CHAR up to the next whitespace and interns the string?Some Lisps do have something like READ-TOKEN, and it can be useful;but in these Lisps, it's essentially part of READ that happens to beavailable separately.  And Common Lisp has PARSE-INTEGER.But sometimes, I actually want to read lists and have case-sensitivityset.  Really.  (Maybe I want to read Franz Lisp code, say.)> Given READ-LINE and READ-CHAR and the multiple interpretations of> what and when should you break symbols out of text, why/how should > this be standardized?  Why should the readtable be modifiable at all?  Why should I beable to define character macros?  SET-SYNTAX-FROM-CHAR?-- Jeff*start*02395 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 FEB 89 10:49:32 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 17 Feb 89  10:48:57 PSTReceived: from mist.encore.COM by multimax.encore.com with SMTP (5.61/25-eef)	id AA04129; Fri, 17 Feb 89 13:47:30 -0500Received: from localhost by mist. (4.0/SMI-4.0)	id AA00492; Fri, 17 Feb 89 13:45:33 ESTMessage-Id: <8902171845.AA00492@mist.>To: Jeff Dalton <"jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK"@multimax.encore.com>Cc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 1) In-Reply-To: Your message of Fri, 17 Feb 89 18:04:32 +0000.             <9819.8902171804@subnode.aiai.ed.ac.uk> Date: Fri, 17 Feb 89 13:45:31 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>    Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)     To: peck@sun.com, CL-Cleanup@sail.stanford.edu        > but let's face it:    > *** READ is designed for reading programs (symbols, lists, structs, etc).    > *** It sounds like you are not primarily concerned with wanting    > "to use case distinctions in code". So, READ should not be changed.        READ is not just for reading programs, it is for reading data too.    Lists, symbols, etc. are used outside of source code, after all.    Is this really a controversial point?    I don't think so at all.  The following is from page 365 of CLtL:    "The user is encouraged to turn off most macro characters, turn others     into simgle-character-object-macros, and then use READ purely as a     lexical analyzer on top of which to build a parser.  It is     unnecesary, however, to cater to more complex lexical analysis or     parsing than that needed for Common Lisp."The intent that READ be useful as a lexer for data or embeddedlanguages is clear.  It's also clear that you're asking for anextension to the lexer's power that is not required for Common Lisp.I think that it is a reasonable and useful extension if properlydefined.  You can put me down as likely to support a readtable-based casecontrol extension, however Peck's point that such an extension mustnot conflict with the new character proposal is important.    *start*02181 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 FEB 89 09:44:14 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 20 Feb 89  09:43:21 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa04231; 20 Feb 89 17:27 GMTDate: Mon, 20 Feb 89 17:25:45 GMTMessage-Id: <13322.8902201725@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1) To: pierson <@multimax.encore.com:pierson@mist.encore.com>Cc: CL-Cleanup@sail.stanford.edu, KMP@scrc-stony-brook.arpa> The intent that READ be useful as a lexer for data or embedded> languages is clear.  It's also clear that you're asking for an> extension to the lexer's power that is not required for Common Lisp.Sure, but character macros aren't required for reading standard-syntaxCommon Lisp either.> I think that it is a reasonable and useful extension if properly> defined.  Thanks.> You can put me down as likely to support a readtable-based case> control extension, however Peck's point that such an extension must> not conflict with the new character proposal is important.Hummm.  I don't think it should be hard to be compatible.  Automaticcase conversion seems more likely to run into trouble when there arelots of different character sets (some, presumably, without a notionof case).But it's nontrivial to design something of this sort.  The options seemto be:  * some way just to turn case concersion on and off  * a way to specify a conversion for every character    (normally, some would be converted to upper case)    [I can imagine lots of objections to this since    it would make readtables bigger, it would have to    say what happens when one of the characters is    defined as a macro, etc.]  * define some way for character macro functions to return    a substitute character (or characters?).  * [maybe] specify an alternative character set that doesn't    have case conversion.Any preferences?-- Jeff*start*02452 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 FEB 89 10:37:00 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 22 Feb 89  10:36:05 PSTReceived: by ti.com id AA04862; Wed, 22 Feb 89 12:34:27 CSTReceived: from Kelvin by tilde id AA18010; Wed, 22 Feb 89 12:26:38 CSTMessage-Id: <2813163955-1290904@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 22 Feb 89 12:25:55 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Cc: pierson <@multimax.encore.com:pierson@mist.encore.com>, KMP@scrc-stony-brook.arpa, CL-Cleanup@sail.stanford.eduSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 1) In-Reply-To: Msg of Mon, 20 Feb 89 17:25:45 GMT from Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>> But it's nontrivial to design something of this sort.  The options seem> to be:> >   * some way just to turn case concersion on and off>   * a way to specify a conversion for every character>     (normally, some would be converted to upper case)>     [I can imagine lots of objections to this since>     it would make readtables bigger, it would have to>     say what happens when one of the characters is>     defined as a macro, etc.]>   * define some way for character macro functions to return>     a substitute character (or characters?).>   * [maybe] specify an alternative character set that doesn't>     have case conversion.> > Any preferences?I notice that our reader calls CHAR-UPCASE on characters which the readtable defines as possible constituents of a symbol name.  Suppose thatinstead of a hard-coded call to CHAR-UPCASE, it FUNCALLed a functioncontained in the read table, with #'CHAR-UPCASE being the initial valuein the standard read table.  That would be a very simple change, but wouldgive you all the flexibility you might want.  The only drawback is that itcould slow the reader down, since our call to CHAR-UPCASE is actuallyexpanded inline now.I like the idea of doing things like this as keyword arguments toCOPY-READTABLE, both to avoid inventing new function names and to protectthe standard readtable from alteration.  For example:  (DEFPARAMETER *CASE-SENSITIVE-READTABLE*                 (COPY-READTABLE *READTABLE* NIL                                 :SYMBOL-CHAR-TRANSLATION #'IDENTITY))*start*02114 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 FEB 89 11:18:24 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Feb 89  11:16:56 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 543681; Wed 22-Feb-89 14:13:26 ESTDate: Wed, 22 Feb 89 14:13 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)To: Gray@DSG.CSC.TI.COMcc: jeff%aiai.edinburgh.ac.uk@nss.cs.ucl.ac.uk, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <2813163955-1290904@Kelvin>Message-ID: <890222141309.5.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Wed, 22 Feb 89  12:25:55 CST    From: David N Gray <Gray@DSG.csc.ti.com>    ... Suppose ... it FUNCALLed a function contained in the read table ...    ... (COPY-READTABLE *READTABLE* NIL :SYMBOL-CHAR-TRANSLATION ...) ...I would support such a proposal.However, I would prefer to see CHARACTER spelled out. This won't be usedoften enough to justify abbreviation.  Also, I'm not sure that the `SYMBOL'part of the name is warranted or even a good idea. For example, thisoption might control whether you had to write #\Control-\a or could getaway with #\Control-a. Obviously, that's a matter to be decided by theCharacters committee, but if we choose an overly specific name, we'll makeit harder for them to explain.  Symbolics has used the function nameSET-CHARACTER-TRANSLATION for a while and to my knowledge no one has complained that it did not affect (for example) strings. As such, I'd prefer (COPY-READTABLE *READTABLE* NIL :CHARACTER-TRANSLATION ...)Providing no way to modify a readtable's character translation functionwould avoid the problem of people modifying the standard readtable, butit would probably also be a nuisance in other situations. My vote would befor adding a setf-able function READTABLE-CHARACTER-TRANSLATION as well.Hope this info is helpful.*start*03806 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 MAR 89 10:47:34 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 7 Mar 89  10:45:21 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06887; 7 Mar 89 18:04 GMTDate: Tue, 7 Mar 89 18:32:46 GMTMessage-Id: <22896.8903071832@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1) To: David N Gray <Gray%dsg.csc.ti.com@NSS.Cs.Ucl.AC.UK>Cc: pierson <@multimax.encore.com:pierson@mist.encore.com>, KMP@scrc-stony-brook.arpa, CL-Cleanup@sail.stanford.edu> I notice that our reader calls CHAR-UPCASE on characters which the read> table defines as possible constituents of a symbol name.  Suppose that> instead of a hard-coded call to CHAR-UPCASE, it FUNCALLed a function> contained in the read table, with #'CHAR-UPCASE being the initial value> in the standard read table.  That would be a very simple change, but would> give you all the flexibility you might want.  The only drawback is that it> could slow the reader down, since our call to CHAR-UPCASE is actually> expanded inline now.Hummm.  I like this approach, but I'm not sure people will be happywith a slower reader.  Of course, the function call might skippedin the "normal" case, and CHAR-UPCASE called in-line; and that maybe good enough.I'm also somewhat uneasy about allowing arbitrary translations.Suppose "a" is translated to "b".  Does that mean PRINT shouldescape any "a"s in print names?  DO we have to restrict the setof valid functions?> I like the idea of doing things like this as keyword arguments to> COPY-READTABLE, both to avoid inventing new function names and to protect> the standard readtable from alteration.  For example:> >   (DEFPARAMETER *CASE-SENSITIVE-READTABLE* >                 (COPY-READTABLE *READTABLE* NIL >                                 :SYMBOL-CHAR-TRANSLATION #'IDENTITY))KMP writes;   Date: Wed, 22 Feb 89 14:13 EST   From: Kent M Pitman <KMP@arpa.scrc-stony-brook>   I would support such a proposal.   However, I would prefer to see CHARACTER spelled out. This won't be used   often enough to justify abbreviation. OK.  However, there are lots of "CHAR-" functions in Common Lisp,so it could go either way.   Also, I'm not sure that the `SYMBOL' part of the name is warranted   or even a good idea. For example, this option might control whether   you had to write #\Control-\a or could get away with #\Control-a.   Obviously, that's a matter to be decided by the Characters   committee, but if we choose an overly specific name, we'll make   it harder for them to explain.I'm happy to see the "SYMBOL" go, but I don't want to end upcreating confusion about when the translation occurs.  I wasexpecting it to happen at step 8, point 1 (CLtL, page 337).Is that ok?  Symbolics has used the function name SET-CHARACTER-TRANSLATION for a  while and to my knowledge no one has complained that it did not  affect (for example) strings. As such, I'd prefer    (COPY-READTABLE *READTABLE* NIL :CHARACTER-TRANSLATION ...)Good.   Providing no way to modify a readtable's character translation function   would avoid the problem of people modifying the standard readtable, but   it would probably also be a nuisance in other situations. My vote would be   for adding a setf-able function READTABLE-CHARACTER-TRANSLATION as well.I prefer being able to set things when it's reasonable to do so,and I'd like to have the function anyway so that I can call iton a readtable and see what its translation function is.-- Jeff*start*03832 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 MAR 89 14:37:34 PSTReceived: from ucbarpa.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 8 Mar 89  14:37:27 PSTReceived: from franz.UUCP by ucbarpa.Berkeley.EDU (5.61/1.33)	id AA02242; Wed, 8 Mar 89 14:24:29 -0800Received: from frisky by franz (3.2/3.14)	id AA04190; Wed, 8 Mar 89 10:18:33 PSTReceived: by frisky (3.2/3.14)	id AA07089; Wed, 8 Mar 89 10:18:07 PSTFrom: franz!frisky!jkf@ucbarpa.Berkeley.EDU (John Foderaro)Return-Path: <frisky!jkf>Message-Id: <8903081818.AA07089@frisky>To: franz!sail.stanford.edu!cl-cleanup@ucbarpa.Berkeley.EDUSubject: case sensitive readersDate: Wed, 08 Mar 89 10:18:04 PST  Jeff Dalton brought up the problem of the Lisp reader not being casesensitive.  His application was to read text in which case matters.I think that we would be better served in solving the global problem ofa solely case insensitive reader, and once this is solved Jeff's problemdisappears.  As a user of Lisp on Unix-based workstations the fact that Common Lispis not case-sensitive is a major annoyance.  [While Allegro Common Lispwill run in a case-sensitive mode, the fact that most of what I writegets shipped to customers means that I have to limit my use ofcase-sensitivity].   Clearly many people find case-sensitivity a usefultool for increasing program readability (if you don't believe this, look at large C programs and remind yourself that C doesn't impose anycase conventions on the user so that all use of case is strictlyvoluntary).   Furthermore many people use Lisp on Unix-based workstationsto interface with C, and the fact that there isn't a nice way towrite dual-cased C symbols as Lisp symbols is a major drawback toseamless integration.  If you now want to reply to this letter letting me know how much you hatecase-sensitive programming languages, please don't bother.  It justdoesn't matter what you dislike.  What matters is that theredo exist a significant number people for whom the case-sensitivityis important (unfortunately they are probably under-represented in this forum).  It is possible to come up with a solution that also satisfies peoplewho are used to using case freely in their programs(e.g.   (Defun Foo (x) (Cond (X :BaR))))and who want all characters mapped to one case.   This is done bysome mechanism that lets the reader know when it should map allunescaped characters to one case.  Furthermore I'd expect that all symbols defined in the standard beof a single case so that people using Lisp in the single-case modewould have access to everything without using escape characters.  Now for the big change:  If Common Lisp is to support a case-sensitivereader for programs, the 'standard' case for symbol names must belower case.   This is very important because having to use theshift key to type in most symbol names would make thecase-sensitive mode too painful to be useful.  Allegro Common Lisp can switch at runtime between the standardCommon Lisp case-insensitive upper-case-preferred mode andthe case-sensitive lower-case-preferred mode I've suggested here,however this is a 'violent' change that isn't necessarily reverseableand I wouldn't suggest this kind of thing for the standard. It is trivial to switch between the case-insensitive lower-case-preferred andcase-sensitive lower-case-preferred modes and these are the two modesI'd suggest be supported in Common Lisp.   I don't care how the switch is done(whether by global variable, readtable-based flag, or function).  I believethat the first step is deciding that the mode switch is necessary andthen the design can be done.- john foderaro  Franz Inc.    				*start*02209 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 11:19:35 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 9 Mar 89  11:19:14 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa09234; 9 Mar 89 18:22 GMTDate: Thu, 9 Mar 89 18:51:47 GMTMessage-Id: <29883.8903091851@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: case sensitive readersTo: John Foderaro <@NSS.Cs.Ucl.AC.UK,@aiai.edinburgh.ac.uk,@ucbarpa.berkeley.edu,@franz.uucp:jkf@frisky>, cl-cleanup@sail.stanford.eduIn-Reply-To: John Foderaro's message of Wed, 08 Mar 89 10:18:04 PST>   Jeff Dalton brought up the problem of the Lisp reader not being case> sensitive.  His application was to read text in which case matters.> I think that we would be better served in solving the global problem of> a solely case insensitive reader, and once this is solved Jeff's problem> disappears.Actually, I was proposing a way to get a switchable, case-sensitivereader.  I mentioned it's use for code and for reading list-structuredata.However, I thought it will be very difficult to change the internalcase of Common Lisp to be lower case, so I didn't try to do that.  I'dprefer lower case, I think it has been shown that lower case is easierto read, I would find lower case easier to use, and I think it reallywill be too late to change after we have a standard.  But I'm suremany will argue that it's already too late now, and since I thinkcase-sensitivity has some value on its own, I didn't want to combineit with something more controversial.> As a user of Lisp on Unix-based workstations the fact that Common Lisp> is not case-sensitive is a major annoyance.I think it's worth pointing out that this isn't just a Unix issue.Lower case has been used on other systems as well.And in general Lisp seems to be moving towards lower case.  Mosttextbooks seems to use lower case these days, and I've seen code(such as the T sources) that's lower case now when it used to beupper.*start*01570 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 16:34:39 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 9 Mar 89  16:34:45 PSTReceived: by ti.com id AA01060; Thu, 9 Mar 89 18:18:09 CSTReceived: from Kelvin by tilde id AA29442; Thu, 9 Mar 89 18:01:54 CSTMessage-Id: <2814480087-16198566@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Thu, 9 Mar 89 18:01:27 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Jeff Dalton <jeff@aiai.edinburgh.ac.uk>Cc: pierson <@multimax.encore.com:pierson@mist.encore.com>, KMP@scrc-stony-brook.arpa, CL-Cleanup@sail.stanford.eduSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 1) In-Reply-To: Msg of Tue, 7 Mar 89 18:32:46 GMT from Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>>    Providing no way to modify a readtable's character translation function>    would avoid the problem of people modifying the standard readtable, but>    it would probably also be a nuisance in other situations. My vote would be>    for adding a setf-able function READTABLE-CHARACTER-TRANSLATION as well.> > I prefer being able to set things when it's reasonable to do so,> and I'd like to have the function anyway so that I can call it> on a readtable and see what its translation function is.There isn't any point in having both an accessor function and aCOPY-READTABLE option.  Since other people want to have the function, Iwithdraw my suggestion of modifying COPY-READTABLE.*start*01833 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 14-Mar-89 17:30:13 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 17:30:11 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Mar 89  17:30:51 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 14 MAR 89 14:18:15 PSTDate: 14 Mar 89 14:17 PSTFrom: masinter.paSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 1) In-reply-to: David N Gray <Gray@DSG.csc.ti.com>'s message of Thu, 9 Mar 89 18:01:27 CSTTo: David N Gray <Gray@DSG.csc.ti.com>, Jeff Dalton <jeff@aiai.edinburgh.ac.uk>cc: cl-cleanup@sail.stanford.eduMessage-ID: <890314-141815-1956@Xerox>I have 15 replies to version 1, but no version 2.Personally, I think adding a character translation table is overkill if allthat's wanted is case sensitive or no, and the performance cost unwieldy."Gilding the lilly."Why not just (READTABLE-CASE <readtable>) that accepts/returns :UPCASE (thedefault) or :DOWNCASE.Note that the setting of the READTABLE-CASE in *READTABLE* should affectprinting: if (READTABLE-CASE *READTABLE*) is :DOWNCASE, then *PRINT-CASE*is ignored; symbols should be printed with the same case as their internalname.This is effectively what Medley does; it was necessary to supportreadtables with a case sensitive "bit" so that the same environment couldsimultaneously support Interlisp (which is case sensitive) and Common Lisp.If this is going to go anywhere, we'll need a version 2. If you want toproceed with just the READTABLE-CHARACTER-TRANSLATION, I won't squawk tooloudly (but I think I would vote against all of the proposals, even the oneI outline above, on the grounds that they are 'unnecessary' complications.)*start*01609 00024 US GV-Info: KMP@PORSCHE.SCRC.Symbolics.COM at 16-Mar-89 11:05:27 from AGReturn-Path: <KMP@PORSCHE.SCRC.Symbolics.COM>Received: from PORSCHE.SCRC.Symbolics.COM ([128.81.41.69]) by Xerox.COM ; 16 MAR 89 10:54:34 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by PORSCHE.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 6566; Tue 14-Mar-89 20:43:54 ESTDate: Tue, 14 Mar 89 20:43 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890314-141815-1956@Xerox>Message-ID: <890314204336.9.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 14 Mar 89 14:17 PST    From: masinter.pa@Xerox.COM    Why not just (READTABLE-CASE <readtable>) that accepts/returns :UPCASE (the    default) or :DOWNCASE.This would be fine, but I would prefer :PRESERVE rather than :DOWNCASE for thealternate value. One might legitimately want :DOWNCASE as well (although itwould be near useless for CL, it might be useful for other things) so I wouldn'twant to lock down that name.All in all, though, I like somebody's (Gray's?) suggestion of a function ratherthan a table. The default being #'CHAR-UPCASE, and #'IDENTITY being anotherobvious choice.The reason I like the function rather than the keyword is that you don't haveto initially provide the alternate functionality -- user's can add it. In thecase of the keyword, it has to be given by the system so you're at the mercyof the implementors as to which options you get. I think this feature is worththe added complexity.*start*01760 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 14-Mar-89 18:11:15 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 18:11:14 PSTReceived: from PORSCHE.SCRC.Symbolics.COM ([128.81.41.69]) by SAIL.Stanford.EDU with TCP; 14 Mar 89  18:11:58 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by PORSCHE.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 6566; Tue 14-Mar-89 20:43:54 ESTDate: Tue, 14 Mar 89 20:43 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890314-141815-1956@Xerox>Message-ID: <890314204336.9.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 14 Mar 89 14:17 PST    From: masinter.pa@Xerox.COM    Why not just (READTABLE-CASE <readtable>) that accepts/returns :UPCASE (the    default) or :DOWNCASE.This would be fine, but I would prefer :PRESERVE rather than :DOWNCASE for thealternate value. One might legitimately want :DOWNCASE as well (although itwould be near useless for CL, it might be useful for other things) so I wouldn'twant to lock down that name.All in all, though, I like somebody's (Gray's?) suggestion of a function ratherthan a table. The default being #'CHAR-UPCASE, and #'IDENTITY being anotherobvious choice.The reason I like the function rather than the keyword is that you don't haveto initially provide the alternate functionality -- user's can add it. In thecase of the keyword, it has to be given by the system so you're at the mercyof the implementors as to which options you get. I think this feature is worththe added complexity.*start*01845 00024 USaGV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 12:31:24 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 12:29:00 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 15 Mar 89  12:27:33 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa09545; 15 Mar 89 15:59 GMTDate: Wed, 15 Mar 89 15:57:02 GMTMessage-Id: <1423.8903151557@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)To: Kent M Pitman <KMP@scrc-stony-brook.arpa>, Masinter.PAIn-Reply-To: Kent M Pitman's message of Tue, 14 Mar 89 20:43 ESTCc: CL-Cleanup@sail.stanford.edu> All in all, though, I like somebody's (Gray's?) suggestion of a> function rather than a table. The default being #'CHAR-UPCASE, and> #'IDENTITY being another obvious choice.It was indeed Gray's suggestion.I also prefer the function to the keyword.  However, can we allowarbitrary functions or would that cause problems for the printer?> The reason I like the function rather than the keyword is that you> don't have to initially provide the alternate functionality -- user's> can add it.Can they or do the functions have to be from a set known to theprinter?> In the case of the keyword, it has to be given by the system so you're> at the mercy of the implementors as to which options you get.  I think> this feature is worth the added complexity.I am somewhat uneasy about allowing arbitrary translations ratherthan just having a case switch.  I would rather have the generalmechanism but not if it would cause prople to oppose an issue theywould otherwise support.-- Jeff*start*01082 00024 US GV-Info: masinter.pa at 17-Mar-89 21:50:27 from massunterDate: 17 Mar 89 21:50 PSTFrom: masinter.paSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 1)In-reply-to: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>'s message of Wed, 15 Mar 89 15:57:02 GMTTo: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>cc: Kent M Pitman <KMP@scrc-stony-brook.arpa>, Masinter.PA, CL-Cleanup@sail.stanford.eduI think the issue is the handling of the printer. PRINT, when *PRINT-ESCAPE* is set. needs to look at the case of the readtable to know how to print out things so they will read in correctly.Take symbols with symbol-name "Frob" and "FROB" respectively.	               print	            printSymbol-name    case-sensitive    case-insensitiveFrob	            Frob	               |Frob|FROB	            FROB	               frob, Frob, or FROB	            	                     (depending on *PRINT-CASE*)     I think this is a "cleanup" issue, since it is a minor extensionto the feature of readtables and is upward compatible. *start*10385 00024 US GV-Info: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK at 23-Mar-89 15:19:46 from AGReturn-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 23 MAR 89 15:18:29 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa11717; 23 Mar 89 23:10 GMTDate: Thu, 23 Mar 89 23:11:13 GMTMessage-Id: <2240.8903232311@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Issue: READ-CASE-SENSITIVITY (Version 2)To: CL-Cleanup@sail.stanford.eduCc: Kent M Pitman <KMP@scrc-stony-brook.arpa>, Masinter.PA, richard%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKIt's very late, but here it is.Issue:        READ-CASE-SENSITIVITYForum:	      CleanupReferences:   CLtL p 334 ff: What the Read Function Accepts,                especially p 337, step 8, point 1.              CLtL p 360 ff: The Readtable              COPY-READTABLE (CLtL, p 361)              *PRINT-CASE* (CLtL, p 372)Category:     ADDITION/CHANGEEdit history: Version 1, 15-Feb-89, by Dalton              Version 2, 23-Mar-89, by Dalton,                (completely new proposal after comments from                 Pitman, Gray, Masinter, and R.Tobin@uk.ac.ed)Problem Description:  The Common Lisp reader always converts unescaped constituent  characters to upper case.  (See CLtL, p 337, step 8, point 1.)  This behavior is not always desirable.  1.  Lisp applications often use the Lisp reader to read their data.  This is often significantly easier than writing input routines  from scratch, especially if the input can be structured as lists.  However, certain applications want to make use of case distinctions,  and Common Lisp makes this unreasonably difficult.  (You must define  every letter as a read macro and have the macro function read the  rest of the symbol, or else you must write a reader from scratch.)  2.  Some programming languages distinguish between upper and lower  case in identifiers, and useful conventions are often built around  such distinctions.  For example, in C, constants are often written  in upper case and variables in lower.  In Mesa(?) and Smalltalk(?),  a capital letter is used to indicate the beginning of a new word  in identifiers made up of several words.  In Edinburgh Prolog,  variables begin with upper-case letters and constant symbols do  not.  The case-insensitivity of the Common Lisp reader makes  it difficult to use conventions of this sort.Proposal (READ-CASE-SENSITIVITY:READTABLE-KEYWORDS)  Define a new settable function, (READTABLE-CASE <readtable>) to  control the reader's interpretation of case.  The following values  may be given:    :UPCASE   --  convert unescaped characters to upper-case, as now.    :DOWNCASE --  convert unescaped characters to lower-case.    :PRESERVE --  don't convert, leaving lower-case letters in lower                  case and upper-case characters in upper case.    :INVERT   --  convert lower-case to upper and upper-case to lower.  COPY-READTABLE copies the setting of READTABLE-CASE.  The value of  READTABLE-CASE for the standard readtable is :UPCASE.  The READTABLE-CASE of a readtable also has significance when  printing.  The case in which letters are printed is determined as  follows:    When READ-CASE is :UPCASE, upper-case letters are printed in the    case specified by *PRINT-CASE*.    When READ-CASE is :DOWNCASE, lower-case letters are printed in    the case specified by *PRINT-CASE*.    When READ-CASE is :PRESERVE, letters are printed in their own    case.    When READ-CASE is :INVERT, the case of all letters is inverted.  (The behavior when *PRINT-CASE* is :CAPITALIZE is like :UPCASE for  the first character and :DOWNCASE for the rest.)  The rules for escaping letters are also affected by the READTABLE-CASE.  If *PRINT-ESCAPE* is true, letters are escaped as follows:    When READ-CASE is :UPCASE, all lower-case letters must be escaped.    When READ-CASE is :DOWNCASE, all upper-case letters must be escaped.    Otherwise, no letters need be escaped.Proposal (READ-CASE-SENSITIVITY:READTABLE-FUNCTION)  Define a new settable function (READTABLE-CHARACTER-TRANSLATION  <readtable>) to control the reader's interpretation of unescaped  constituent characters.  The value may be any function of type  (FUNCTION (CHARACTER) CHARACTER).  Where the reader now converts  such characters to upper case it should instead call the function  that is the value of READTABLE-CHARACTER-TRANSLATION for the current  readtable.  (See CLtL, page 337, step 8, point 1.)  COPY-READTABLE copies the setting of READTABLE-CHARACTER-TRANSLATION.  The value for the standard readtable is CHAR-UPCASE.  The READTABLE-CHARACTER-TRANSLATION of a readtable also has  significance when printing.  The reader recognizes certain functions  which control the reader's interpretation of case and alters its  behavior accordingly.  This behavior is given by the following  correspondence between functions and the keywords described above.  [This is just to avoid repeating a lot of text.]    function           keyword    CHAR-UPCASE        :UPCASE    CHAR-DOWNCASE      :DOWNCASE    IDENTITY           :PRESERVE    CHAR-INVERT-CASE   :INVERT  The function can be given either as a symbol or as one of the values  #'CHAR-UPCASE, #'CHAR-DOWNCASE, #'IDENTITY, #'CHAR-INVERT-CASE.  If the READTABLE-CHARACTER-TRANSLATION is not one of the functions  listed above, letters are always printed in their own case (in  particular, *PRINT-CASE* has no effect), and all characters in  symbol names are escaped if *PRINT-ESCAPE* is true.  Define a new function CHAR-INVERT-CASE of type (FUNCTION (CHARACTER)  CHARACTER) analogous to CHAR-UPCASE and CHAR-DOWNCASE.  It attempts  to convert its argument to upper-case if the argument is lower-case  and to lower-case if the argument is upper-case.Rationale:  There are a number of different ways to achieve case-sensitivity.  These proposals are fairly simple but provide all of the  functionality that one could reasonably expect.  By using a property of the readtable, we avoid introducing a new  special variable.  Any code that wishes to control all of the  reader's parameters already takes *READTABLE* into account.  A new  special variable would require such code to change.  :DOWNCASE is included for symmetry with :UPCASE.  :INVERT is  included so that case conventions could be used in Common Lisp code  without requiring that the names symbols in the "LISP" package be  written in upper case.  (Opinions vary as to whether is is advisable  to use such conventions, but this proposal leaves that choice to the  user.)  In order to avoid complex interactions between the case setting of  the readtable and *PRINT-CASE*, this proposal specifies a  significance for *PRINT-CASE* only when the case setting is :UPCASE  or :DOWNCASE.  The meaning of *PRINT-CASE* when the readtable  setting is :DOWNCASE was chosen for its simplicity and for symmetry  with :UPCASE while still being useful.Test Case:  ;; keyword version  (let ((rt (copy-readtable nil)))    (mapcar      #'(lambda (case)          (setf (readtable-case rt) case)          (read-from-string "Zebra"))      '(:upcase :downcase :preserve :invert)))    => (ZEBRA |zebra| |Zebra| |zEBRA|) ;as printed with the standard                                       ;readtable and *print-case* :upcaseCurrent Practice:  While there may not be any current implementation that supports  exactly this proposal, several implementations provide some means  for changing case sensitivity.  Franz Inc's ExCL has a function, EXCL:SET-CASE-MODE, that sets both  the "preferred case" (the case of character in the print names of  standard symbols such as CAR) and whether or not the reader is case-  sensitive.  In Symbolics Common Lisp, the function SET-CHARACTER-TRANSLATION  can be used to make the translation of a letter be that same letter,  thus achieving case-sensitivity.  Xerox Medley has a function for setting a readtable flag that  determines case sensitivity.Cost to Implementors:  Fairly small.  The reader will be slightly slower and readtables  will be slightly more complex.Cost to Users:  Slight.  Programmers must already take into account the possibility  that *READTABLE* will be a non-standard readtable.  Case-sensitivity  is no worse than character macros in this respect.Cost of Non-Adoption:  Applications that want to read mixed-case expressions will not  be able to use the Common Lisp reader to do so (except, perhaps,  by tortuous use of read macros).  Programming styles that rely on case distinctions (without escape  characters) will be effectively impossible in Common Lisp.Benefits:  Applications will be able to read mixed-case expressions.  Programmers will be able to make use of case distinctions.Aesthetics:  For the proposals:     The language will have greater symmetry, because it will be    possible to control the treatment of case on both input and output    instead of only on output (as is now the case).    The language will look less old-fashioned.  Against the proposals:      It is, perhaps, inconsistent to control case-sensitivity by a    readtable operation when other aspects of the reader, such as the    input base and the default float format (not to mention the    package), are controlled by special variables.  However, it can be    argued that character-level syntax is determined chiefly by the    readtable.  Case-sensitivity can be seen as analogous to character    macros in this respect.  Keywords vs function    The keyword proposal is somewhat simpler and avoids raising the    possibility of character translation that applies in general and    not just for unescaped constituents.    The function proposal is perhaps more elegant.Discussion:  Dalton supports both proposals but slightly prefers READTABLE-CASE.  Version 1 of the proposal suggested a new global variable rather  than a property of the readtable.  Pitman was strongly opposed to  that proposal and gave convincing arguments that it should be  dropped.  Gray suggested that the readtable property should be a  function.*start*02457 00024 US GV-Info: KMP@STONY-BROOK.SCRC.Symbolics.COM at 23-Mar-89 15:58:28 from AGReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 23 MAR 89 15:57:13 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 564146; Thu 23-Mar-89 18:56:34 ESTDate: Thu, 23 Mar 89 18:56 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: READ-CASE-SENSITIVITY (Version 2)To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKcc: CL-Cleanup@sail.stanford.edu, KMP@STONY-BROOK.SCRC.Symbolics.COM, Masinter.PA, richard%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKIn-Reply-To: <2240.8903232311@subnode.aiai.ed.ac.uk>Message-ID: <890323185605.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Thu, 23 Mar 89 23:11:13 GMT    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>    It's very late, but here it is.    Issue:        READ-CASE-SENSITIVITY    ...The write-up looks quite good to me.  Even though it's late, I plan tosupport it.I prefer option READTABLE-KEYWORDS for two reasons:(1) your recent arguments about printer issues being simpler that way(2) the lack of need to add CHAR-INVERT-CASE (which I don't think is very     useful outside of this context).I do want to mention that I think having an arbitrary function is not ashard on the printer as you might expect, so I'm not sure READTABLE-FUNCTIONreally needs to restrict its inputs.  When the system sees an unknownfunction, it could iterate over both-case-p characters, calling the functionand figuring out the mappings. Since we're talking about the system, it willknow which chars those are even in the face of international char sets.It can determine from such a table whether the mapping is one-to-one fora particular character (so it will know if escaping is needed) as well aswhether the mapping is case-preserving for any given character.  However,even though I think this is possible, I admit it is a pain and probablyjust plain not worth the effort so I don't think it's the way to go. Basedon this, I don't really oppose READTABLE-FUNCTION, but I'd much prefer thesimpler READTABLE-KEYWORDS proposal anyway.Btw, there may be some overlap between this and PRINT-CASE-PRINT-ESCAPE-INTERACTION. I don't have time to check this to besure, but you might want to double-check to avoid last-minute snags.*start*01914 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-Mar-89 18:16:38 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 18:16:31 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 23 Mar 89  18:13:26 PSTReceived: from snail.Sun.COM (snail.Corp.Sun.COM) by Sun.COM (4.1/SMI-4.0)	id AA08865; Thu, 23 Mar 89 18:15:31 PSTReceived: from denali.sun.com by snail.Sun.COM (4.1/SMI-4.1)	id AA14491; Thu, 23 Mar 89 18:11:37 PSTReceived: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA04765; Thu, 23 Mar 89 18:14:55 PSTMessage-Id: <8903240214.AA04765@denali.sun.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKCc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 2) In-Reply-To: Your message of Thu, 23 Mar 89 18:56:00 -0500;	<890323185605.7.KMP@BOBOLINK.SCRC.Symbolics.COM> .Date: Thu, 23 Mar 89 18:14:53 PSTFrom: peck@Sun.COM>(2) the lack of need to add CHAR-INVERT-CASE (which I don't think is very >    useful outside of this context). I guess i don't see how this is useful even in this context.Is this a Symbolics'ism?If :preserve is an option, why would someone want :INVERT?dOES SOMEONE THINK :invert IS EASIER TO TYPE THAN eSCAPES or vERTICAL-bARS?dO YOU HAVE files WRITTEN WITH :invert?How about throwing out :INVERT *and* CHAR-INVERT-CASE?Which of READTABLE-KEYWORDS or READTABLE-FUNCTIONS would you prefer then?  [given a sufficiently powerful Emacs that can escape the chars before   passing them to the Lisp reader, does any of this matter to X3J13?]  While we are busy trying to be KSR33 compatible, the rest of the world  may zoom on by.  The Japanese won't be interested in much of this code.  Oops, sorry, that is not a cleanup issue.*start*05021 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-Mar-89 20:52:02 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 20:52:00 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Mar 89  20:50:36 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 564301; Thu 23-Mar-89 23:49:43 ESTDate: Thu, 23 Mar 89 23:49 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 2) To: peck@Sun.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK, CL-Cleanup@sail.stanford.eduIn-Reply-To: <8903240214.AA04765@denali.sun.com>Message-ID: <890323234914.8.KMP@BOBOLINK.SCRC.Symbolics.COM>I shouldn't even be bothering to reply to a message like this at this latedate.  I have better things to be doing.  However, I'll let this be my onefor the day -- if only to lend a little support to Jeff because I thinkthe tone of ridicule in your message to be somewhat out of line. In spiteof this, I've tried to keep my tone constructive and to answer your questionsin earnest.    Date: Thu, 23 Mar 89 18:14:53 PST    From: peck@Sun.COM    >(2) the lack of need to add CHAR-INVERT-CASE (which I don't think is very     >    useful outside of this context).     I guess i don't see how this is useful even in this context.    Is this a Symbolics'ism?I didn't find this remark to be particularly professional. I wish we couldjust avoid that kind of thing.The answer happens to be "no", it is not something we use here.It's something Jeff dreamed up, I guess.I didn't oppose it because I'm not in the habit of out-of-hand opposingthings just because I personally don't see as having practical value. Ithink the real acid test of willingness to cooperate on compatibility isa willingness to tolerate noops and useless features because they turnout to be useful to someone else.My offhand guess is that it is in fact useful in some implementations.Your example below which uses mixed case doesn't give it fair play.Suppose there's an intermediate situation where you implement an embeddedlanguage in which you can only use all-uppercase or all-lowercase names.Suppose you want the all-lowercase names to be the ones that correspond toLisp names. I don't happen to want to do that, but it seemed plausible tome that someone might -- and it might be what Jeff had in mind.The cost of the feature he's asking for is very small, especially if youconsider the hair someone would have to go through to write that embeddedlanguage portably if you didn't offer the feature.    If :preserve is an option, why would someone want :INVERT?    dOES SOMEONE THINK :invert IS EASIER TO TYPE THAN eSCAPES or vERTICAL-bARS?    dO YOU HAVE files WRITTEN WITH :invert?    How about throwing out :INVERT *and* CHAR-INVERT-CASE?How about being civil and first asking Jeff politely why he wanted the feature.    Which of READTABLE-KEYWORDS or READTABLE-FUNCTIONS would you prefer then?It doesn't affect my vote. I still prefer the former over the latter, and Istill don't seriously oppose the latter.      [given a sufficiently powerful Emacs that can escape the chars before       passing them to the Lisp reader, does any of this matter to X3J13?]The issue is not text editors. Given a sufficiently powerful Emacs, you couldcode in C and still pass your information off to Lisp.  ``It's only software''as they say. The issue is that the language must be defined as the interfacebetween the outside world and Lisp. The language is exactly what you can expectto be held constant as you move from system to system, text editor to text editor.Either the language handles case conversion or the text editor does.Jeff is suggesting that he would like the text editor to do so. I don't happento want to do that, but I can't deny that he is making a fair request.      While we are busy trying to be KSR33 compatible, the rest of the world      may zoom on by. I have never used a KSR33. I think I've seen one. I have no particular desireto be compatible with one. I can't imagine why this remark is relevant here.      The Japanese won't be interested in much of this code.      Oops, sorry, that is not a cleanup issue.In my mind, it is not our purpose to design a language suitable for the Japanese.It is our purpose to design a language suitable for us, and to try to listento the Japanese (and anyone else) about problems what we do might cause. Whilethis feature might not be interesting to them, it's hard to see how it could cause them any problem.The Japanese will have their opportunity to speak, and I will pay close attention.If you say what you personally want and why, sans ridicule, I will try to payclose attention to that, too.*start*02658 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 24-Mar-89 10:25:51 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAR 89 10:25:52 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 24 Mar 89  10:24:32 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa03359; 24 Mar 89 15:59 GMTDate: Fri, 24 Mar 89 16:01:12 GMTMessage-Id: <2935.8903241601@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 2) To: Kent M Pitman <KMP@scrc-stony-brook.arpa>, peck@sun.comCc: CL-Cleanup@sail.stanford.eduI do not understand why this proposal causes such confusion.  Perhapsmy writing isn't as clear as it might be, but I don't think it's thatbad.> >(2) the lack of need to add CHAR-INVERT-CASE (which I don't think is very > >    useful outside of this context).>  I guess i don't see how this is useful even in this context.> Is this a Symbolics'ism?No.> If :preserve is an option, why would someone want :INVERT?It's in the rationale.  If I set the readtable to :PRESERVE andthen want to use it to keep case distinctions in my Lisp code --some people do want to do this -- I may also want to type the namesof symbols in the "LISP" package in lower case rather than upper.There are two ways to get that: change the internal case to loweror invert what's typed in.> dOES SOMEONE THINK :invert IS EASIER TO TYPE THAN eSCAPES or vERTICAL-bARS?> dO YOU HAVE files WRITTEN WITH :invert?No, someone thinks (car x) is nicer than (CAR x).One may well have files written in :INVERT.  Any file that uses onlylower case for Lisp code relies on case-insensitivity to convert thenames to upper case.  Those same files could just as well be readwith :INVERT.>   [given a sufficiently powerful Emacs that can escape the chars before>    passing them to the Lisp reader, does any of this matter to X3J13?]Given sufficiently powerful tools other than Lisp, why does anythingmatter to X3J13?Besides, is Emacs going to read all of my streams for me?>   While we are busy trying to be KSR33 compatible, the rest of the world>   may zoom on by.  The Japanese won't be interested in much of this code.>   Oops, sorry, that is not a cleanup issue.The only thing in any of this that's could reasonably be called KSR33compatible is the choice of upper case for the internal preferredcase.  This proposal is trying to make that choice less significant.-- Jeff*start*01073 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 24-Mar-89 10:18:12 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAR 89 10:16:29 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 24 Mar 89  10:14:11 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa03563; 24 Mar 89 16:30 GMTDate: Fri, 24 Mar 89 16:32:37 GMTMessage-Id: <3273.8903241632@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 2) To: Kent M Pitman <KMP@scrc-stony-brook.arpa>, peck@sun.comCc: CL-Cleanup@sail.stanford.edu> How about throwing out :INVERT *and* CHAR-INVERT-CASE?> Which of READTABLE-KEYWORDS or READTABLE-FUNCTIONS would you prefer then?Probably FUNCTIONS.  But then for a random function (e.g., aCHAR-INVERT-CASE defined by me), I'd want output to leave caseintact, without escapes.-- Jeff*start*03308 00024 US Date: 24 Mar 89 13:45 PSTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: peck%Sun:COM:XeroxSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 2)In-Reply-to: Your message of Fri, 24 Mar 89 16:01:12 +0000;	<2935.8903241601@subnode.aiai.ed.ac.uk> .To: "jeff%aiai.edinburgh.ac.uk%NSS.Cs.Ucl.AC.UK":GV:Xeroxcc: CL-Cleanup%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Cc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: READ-CASE-SENSITIVITY (Version 2)In-Reply-To: Your message of Fri, 24 Mar 89 16:01:12 +0000;	<2935.8903241601@subnode.aiai.ed.ac.uk> .From: peck@Sun.COMReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAR 89 13:45:56 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 24 Mar 89  13:44:38 PSTReceived: from snail.Sun.COM (snail.Corp.Sun.COM) by Sun.COM (4.1/SMI-4.0)	id AA00368; Fri, 24 Mar 89 13:46:08 PSTReceived: from denali.sun.com by snail.Sun.COM (4.1/SMI-4.1)	id AA19874; Fri, 24 Mar 89 13:42:14 PSTReceived: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA07858; Fri, 24 Mar 89 13:45:29 PSTMessage-Id: <8903242145.AA07858@denali.sun.com>Original-Date: Fri, 24 Mar 89 13:45:27 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVAssuming that my confusion about :invert is resolved offline,I have another, more positive suggestion for getting CommonLispinto the case-sensitive world: The biggest block that i've found to writting portable codein the mixed/preserve case world is those times when you wantintern a symbol from a string.  If the string is either hard-coded(as a prefix string or :conc-name) or as entered from a user witha readline equivalent, then the application should have a meansof converting the string as the reader would.  I have found usefor the function (CASE-CONVERT-NAME <string>) which returns a string which would be the name of a symbol if <string> were readby the reader.;;; This definition returns mostly the correct value,;;; but has numerous unwanted side-effects, ;;; I.E. creates and interns a symbol, chokes on by colons, etc.  (defun CASE-CONVERT-NAME (string)    (symbol-name (read-from-string string)));;; this is much closer, with READTABLE-CASE-SENSITIVITY:READTABLE-KEYWORDS  (defun CASE-CONVERT-NAME (string)    (case (readtable-case-sensitivity *readtable*)      (:preserve string)      (:upcase  (string-upcase string))      (:downcase (string-downcase string))      (:invert  (string-invertcase string)) ;; uses char-invert-case?    ));;; or this, with READTABLE-CASE-SENSITIVITY:READTABLE-FUNCTIONS   (defun CASE-CONVERT-NAME (string)      (map 'string (readtable-case-sensitivity *readtable*) string))If we could have a function such as this in the, maybe folkswould use it: (intern (concatentate 'string			(case-convert-name "foo-")			(case-convert-name sym) )		     pkg)Instead of: (intern (concatentate 'string "FOO-" sym) pkg)With this extra layer, writing protable code to case-sensitive lisp is very much easier.  The version i use even has an extra arguementto control whether destructive (in-place) or copying conversion is done.*start*10933 00024 US Date: 25 Mar 89 22:45 PSTSender: X3J13-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: **DRAFT** Issue: READ-CASE-SENSITIVITY (Version 2)To: X3J13%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: **DRAFT** Issue: READ-CASE-SENSITIVITY (Version 2)To: X3J13@SAIL.Stanford.EDUReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAR 89 22:45:40 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 25 Mar 89  22:31:39 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 565470; Sun 26-Mar-89 01:31:28 ESTOriginal-Date: Sun, 26 Mar 89 01:30 ESTMessage-ID: <890326013058.8.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV	>>> PLEASE DO -NOT- REPLY TO THIS ISSUE <<<This is just for the reference of anyone still reading mail this closeto the meeting, so that you will have seen it in case it (or some furtherrevision) comes up at the meeting.  If you have any comments, just bringthem to the meeting. Thanks. -kmp-----Issue:        READ-CASE-SENSITIVITYForum:	      CleanupReferences:   CLtL p 334 ff: What the Read Function Accepts,                especially p 337, step 8, point 1.              CLtL p 360 ff: The Readtable              COPY-READTABLE (CLtL, p 361)              *PRINT-CASE* (CLtL, p 372)Category:     ADDITION/CHANGEEdit history: Version 1, 15-Feb-89, by Dalton              Version 2, 23-Mar-89, by Dalton,                (completely new proposal after comments from                 Pitman, Gray, Masinter, and R.Tobin@uk.ac.ed)Problem Description:  The Common Lisp reader always converts unescaped constituent  characters to upper case.  (See CLtL, p 337, step 8, point 1.)  This behavior is not always desirable.  1.  Lisp applications often use the Lisp reader to read their data.  This is often significantly easier than writing input routines  from scratch, especially if the input can be structured as lists.  However, certain applications want to make use of case distinctions,  and Common Lisp makes this unreasonably difficult.  (You must define  every letter as a read macro and have the macro function read the  rest of the symbol, or else you must write a reader from scratch.)  2.  Some programming languages distinguish between upper and lower  case in identifiers, and useful conventions are often built around  such distinctions.  For example, in C, constants are often written  in upper case and variables in lower.  In Mesa(?) and Smalltalk(?),  a capital letter is used to indicate the beginning of a new word  in identifiers made up of several words.  In Edinburgh Prolog,  variables begin with upper-case letters and constant symbols do  not.  The case-insensitivity of the Common Lisp reader makes  it difficult to use conventions of this sort.Proposal (READ-CASE-SENSITIVITY:READTABLE-KEYWORDS)  Define a new settable function, (READTABLE-CASE <readtable>) to  control the reader's interpretation of case.  The following values  may be given:    :UPCASE   --  convert unescaped characters to upper-case, as now.    :DOWNCASE --  convert unescaped characters to lower-case.    :PRESERVE --  don't convert, leaving lower-case letters in lower                  case and upper-case characters in upper case.    :INVERT   --  convert lower-case to upper and upper-case to lower.  COPY-READTABLE copies the setting of READTABLE-CASE.  The value of  READTABLE-CASE for the standard readtable is :UPCASE.  The READTABLE-CASE of a readtable also has significance when  printing.  The case in which letters are printed is determined as  follows:    When READ-CASE is :UPCASE, upper-case letters are printed in the    case specified by *PRINT-CASE*.    When READ-CASE is :DOWNCASE, lower-case letters are printed in    the case specified by *PRINT-CASE*.    When READ-CASE is :PRESERVE, letters are printed in their own    case.    When READ-CASE is :INVERT, the case of all letters is inverted.  (The behavior when *PRINT-CASE* is :CAPITALIZE is like :UPCASE for  the first character and :DOWNCASE for the rest.)  The rules for escaping letters are also affected by the READTABLE-CASE.  If *PRINT-ESCAPE* is true, letters are escaped as follows:    When READ-CASE is :UPCASE, all lower-case letters must be escaped.    When READ-CASE is :DOWNCASE, all upper-case letters must be escaped.    Otherwise, no letters need be escaped.Proposal (READ-CASE-SENSITIVITY:READTABLE-FUNCTION)  Define a new settable function (READTABLE-CHARACTER-TRANSLATION  <readtable>) to control the reader's interpretation of unescaped  constituent characters.  The value may be any function of type  (FUNCTION (CHARACTER) CHARACTER).  Where the reader now converts  such characters to upper case it should instead call the function  that is the value of READTABLE-CHARACTER-TRANSLATION for the current  readtable.  (See CLtL, page 337, step 8, point 1.)  COPY-READTABLE copies the setting of READTABLE-CHARACTER-TRANSLATION.  The value for the standard readtable is CHAR-UPCASE.  The READTABLE-CHARACTER-TRANSLATION of a readtable also has  significance when printing.  The reader recognizes certain functions  which control the reader's interpretation of case and alters its  behavior accordingly.  This behavior is given by the following  correspondence between functions and the keywords described above.  [This is just to avoid repeating a lot of text.]    function           keyword    CHAR-UPCASE        :UPCASE    CHAR-DOWNCASE      :DOWNCASE    IDENTITY           :PRESERVE    CHAR-INVERT-CASE   :INVERT  The function can be given either as a symbol or as one of the values  #'CHAR-UPCASE, #'CHAR-DOWNCASE, #'IDENTITY, #'CHAR-INVERT-CASE.  If the READTABLE-CHARACTER-TRANSLATION is not one of the functions  listed above, letters are always printed in their own case (in  particular, *PRINT-CASE* has no effect), and all characters in  symbol names are escaped if *PRINT-ESCAPE* is true.  Define a new function CHAR-INVERT-CASE of type (FUNCTION (CHARACTER)  CHARACTER) analogous to CHAR-UPCASE and CHAR-DOWNCASE.  It attempts  to convert its argument to upper-case if the argument is lower-case  and to lower-case if the argument is upper-case.Rationale:  There are a number of different ways to achieve case-sensitivity.  These proposals are fairly simple but provide all of the  functionality that one could reasonably expect.  By using a property of the readtable, we avoid introducing a new  special variable.  Any code that wishes to control all of the  reader's parameters already takes *READTABLE* into account.  A new  special variable would require such code to change.  :DOWNCASE is included for symmetry with :UPCASE.  :INVERT is  included so that case conventions could be used in Common Lisp code  without requiring that the names symbols in the "LISP" package be  written in upper case.  (Opinions vary as to whether is is advisable  to use such conventions, but this proposal leaves that choice to the  user.)  In order to avoid complex interactions between the case setting of  the readtable and *PRINT-CASE*, this proposal specifies a  significance for *PRINT-CASE* only when the case setting is :UPCASE  or :DOWNCASE.  The meaning of *PRINT-CASE* when the readtable  setting is :DOWNCASE was chosen for its simplicity and for symmetry  with :UPCASE while still being useful.Test Case:  ;; keyword version  (let ((rt (copy-readtable nil)))    (mapcar      #'(lambda (case)          (setf (readtable-case rt) case)          (read-from-string "Zebra"))      '(:upcase :downcase :preserve :invert)))    => (ZEBRA |zebra| |Zebra| |zEBRA|) ;as printed with the standard                                       ;readtable and *print-case* :upcaseCurrent Practice:  While there may not be any current implementation that supports  exactly this proposal, several implementations provide some means  for changing case sensitivity.  Franz Inc's ExCL has a function, EXCL:SET-CASE-MODE, that sets both  the "preferred case" (the case of character in the print names of  standard symbols such as CAR) and whether or not the reader is case-  sensitive.  In Symbolics Common Lisp, the function SET-CHARACTER-TRANSLATION  can be used to make the translation of a letter be that same letter,  thus achieving case-sensitivity.  Xerox Medley has a function for setting a readtable flag that  determines case sensitivity.Cost to Implementors:  Fairly small.  The reader will be slightly slower and readtables  will be slightly more complex.Cost to Users:  Slight.  Programmers must already take into account the possibility  that *READTABLE* will be a non-standard readtable.  Case-sensitivity  is no worse than character macros in this respect.Cost of Non-Adoption:  Applications that want to read mixed-case expressions will not  be able to use the Common Lisp reader to do so (except, perhaps,  by tortuous use of read macros).  Programming styles that rely on case distinctions (without escape  characters) will be effectively impossible in Common Lisp.Benefits:  Applications will be able to read mixed-case expressions.  Programmers will be able to make use of case distinctions.Aesthetics:  For the proposals:     The language will have greater symmetry, because it will be    possible to control the treatment of case on both input and output    instead of only on output (as is now the case).    The language will look less old-fashioned.  Against the proposals:      It is, perhaps, inconsistent to control case-sensitivity by a    readtable operation when other aspects of the reader, such as the    input base and the default float format (not to mention the    package), are controlled by special variables.  However, it can be    argued that character-level syntax is determined chiefly by the    readtable.  Case-sensitivity can be seen as analogous to character    macros in this respect.  Keywords vs function    The keyword proposal is somewhat simpler and avoids raising the    possibility of character translation that applies in general and    not just for unescaped constituents.    The function proposal is perhaps more elegant.Discussion:  Dalton supports both proposals but slightly prefers READTABLE-CASE.  Version 1 of the proposal suggested a new global variable rather  than a property of the readtable.  Pitman was strongly opposed to  that proposal and gave convincing arguments that it should be  dropped.  Gray suggested that the readtable property should be a  function. *start*01092 00024 US Date:  4 Apr 89 12:48 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: READ-CASE-SENSITIVITYTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: READ-CASE-SENSITIVITYTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:40:30 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:38:11 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571263; Tue 4-Apr-89 15:37:46 EDTOriginal-Date: Tue, 4 Apr 89 15:37 EDTMessage-ID: <890404153716.1.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis was deferred to the next meeting by a 13-3 vote.The drafters were requested to present only a single alternative.*start*12063 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Jun-89 12:09:58 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 JUN 89 12:09:58 PDTReceived: from NSFnet-Relay.AC.UK by SAIL.Stanford.EDU with TCP; 16 Jun 89  12:07:22 PDTReceived: from aiai.edinburgh.ac.uk by NSFnet-Relay.AC.UK   via Janet with NIFTP           id aa09199; 16 Jun 89 19:29 BSTDate: Fri, 16 Jun 89 19:35:44 BSTMessage-Id: <19558.8906161835@aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>Subject: Issue: READ-CASE-SENSITIVITY (Version 3)To: cl-cleanup@sail.stanford.eduI am not going to be able to come to the meeting but wouldstill like to see this issue considered.  I wasn't presentfor the discussion at the last meeting, but my understandingis that the committee wanted to see the issue again withonly a single proposal.  Unfortunately, I don't know whichproposal (keyword or function) most people prefer.It has also been remarked that :INVERT is somewhat strange in that itwould have Zebra read as zEBRA; and it was suggested that inversionshould happen only if the entire name were single-case.Unfortunately, the processing has to happen a character at a time,because READ has to do it only for characters that are not escaped.For example, |zebra| should always read as zebra.Apart from that, very little has been said about this proposal.I hope that anyone who does have objections will be able to raisethem by mail before the meeting.Issue:        READ-CASE-SENSITIVITYForum:	      CleanupReferences:   CLtL p 334 ff: What the Read Function Accepts,                especially p 337, step 8, point 1.              CLtL p 360 ff: The Readtable              COPY-READTABLE (CLtL, p 361)              *PRINT-CASE* (CLtL, p 372)Category:     ADDITION/CHANGEEdit history: Version 1, 15-Feb-89, by Dalton              Version 2, 23-Mar-89, by Dalton,                (completely new proposal after comments from                 Pitman, Gray, Masinter, and R.Tobin@uk.ac.ed)              Version 3, 16-Jun-89, by Dalton                (very minor changes in presentation                 and some additions to the discussion)Problem Description:  The Common Lisp reader always converts unescaped constituent  characters to upper case.  (See CLtL, p 337, step 8, point 1.)  This behavior is not always desirable.  1.  Lisp applications often use the Lisp reader to read their data.  This is often significantly easier than writing input routines  from scratch, especially if the input can be structured as lists.  However, certain applications want to make use of case distinctions,  and Common Lisp makes this unreasonably difficult.  (You must define  every letter as a read macro and have the macro function read the  rest of the symbol, or else you must write a reader from scratch.)  2.  Some programming languages distinguish between upper and lower  case in identifiers, and useful conventions are often built around  such distinctions.  For example, in C, constants are often written  in upper case and variables in lower.  In Mesa(?) and Smalltalk(?),  a capital letter is used to indicate the beginning of a new word  in identifiers made up of several words.  In Edinburgh Prolog,  variables begin with upper-case letters and constant symbols do  not.  The case-insensitivity of the Common Lisp reader makes  it difficult to use conventions of this sort.Proposal (READ-CASE-SENSITIVITY:READTABLE-KEYWORDS)  Define a new settable function, (READTABLE-CASE <readtable>) to  control the reader's interpretation of case.  The following values  may be given:    :UPCASE   --  convert unescaped characters to upper-case, as now.    :DOWNCASE --  convert unescaped characters to lower-case.    :PRESERVE --  don't convert, leaving lower-case letters in lower                  case and upper-case characters in upper case.    :INVERT   --  convert lower-case to upper and upper-case to lower.  COPY-READTABLE copies the setting of READTABLE-CASE.  The value of  READTABLE-CASE for the standard readtable is :UPCASE.  The READTABLE-CASE of a readtable also has significance when  printing.  The case in which letters are printed is determined as  follows:    When READ-CASE is :UPCASE, upper-case letters are printed in the    case specified by *PRINT-CASE*.    When READ-CASE is :DOWNCASE, lower-case letters are printed in    the case specified by *PRINT-CASE*.    When READ-CASE is :PRESERVE, letters are printed in their own    case.    When READ-CASE is :INVERT, the case of all letters is inverted.  (The behavior when *PRINT-CASE* is :CAPITALIZE is like :UPCASE for  the first character and :DOWNCASE for the rest.)  The rules for escaping letters are also affected by the READTABLE-CASE.  If *PRINT-ESCAPE* is true, letters are escaped as follows:    When READ-CASE is :UPCASE, all lower-case letters must be escaped.    When READ-CASE is :DOWNCASE, all upper-case letters must be escaped.    Otherwise, no letters need be escaped.Proposal (READ-CASE-SENSITIVITY:READTABLE-FUNCTION)  Define a new settable function (READTABLE-CHARACTER-TRANSLATION  <readtable>) to control the reader's interpretation of unescaped  constituent characters.  The value may be any function of type  (FUNCTION (CHARACTER) CHARACTER).  Where the reader now converts  such characters to upper case it should instead call the function  that is the value of READTABLE-CHARACTER-TRANSLATION for the current  readtable.  (See CLtL, page 337, step 8, point 1.)  COPY-READTABLE copies the setting of READTABLE-CHARACTER-TRANSLATION.  The value for the standard readtable is CHAR-UPCASE.  The READTABLE-CHARACTER-TRANSLATION of a readtable also has  significance when printing.  The reader recognizes certain functions  which control the reader's interpretation of case and alters its  behavior accordingly.  This behavior is given by the following  correspondence between functions and the keywords described above.  [This is just to avoid repeating a lot of text.]    function           keyword    CHAR-UPCASE        :UPCASE    CHAR-DOWNCASE      :DOWNCASE    IDENTITY           :PRESERVE    CHAR-INVERT-CASE   :INVERT  The function can be given either as a symbol or as one of the values  #'CHAR-UPCASE, #'CHAR-DOWNCASE, #'IDENTITY, #'CHAR-INVERT-CASE.  If the READTABLE-CHARACTER-TRANSLATION is not one of the functions  listed above, letters are always printed in their own case (in  particular, *PRINT-CASE* has no effect), and all characters in  symbol names are escaped if *PRINT-ESCAPE* is true.  Define a new function CHAR-INVERT-CASE of type (FUNCTION (CHARACTER)  CHARACTER) analogous to CHAR-UPCASE and CHAR-DOWNCASE.  It attempts  to convert its argument to upper-case if the argument is lower-case  and to lower-case if the argument is upper-case.Rationale:  There are a number of different ways to achieve case-sensitivity.  These proposals are fairly simple but provide all of the  functionality that one could reasonably expect.  By using a property of the readtable, we avoid introducing a new  special variable.  Any code that wishes to control all of the  reader's parameters already takes *READTABLE* into account.  A new  special variable would require such code to change.  :DOWNCASE is included for symmetry with :UPCASE.  :INVERT is  included so that case conventions could be used in Common Lisp code  without requiring that the names symbols in the "LISP" package be  written in upper case.  (Opinions vary as to whether is is advisable  to use such conventions, but this proposal leaves that choice to the  user.)  In order to avoid complex interactions between the case setting of  the readtable and *PRINT-CASE*, this proposal specifies a  significance for *PRINT-CASE* only when the case setting is :UPCASE  or :DOWNCASE.  The meaning of *PRINT-CASE* when the readtable  setting is :DOWNCASE was chosen for its simplicity and for symmetry  with :UPCASE while still being useful.Test Case:  ;; keyword version  (let ((rt (copy-readtable nil)))    (mapcar      #'(lambda (case)          (setf (readtable-case rt) case)          (read-from-string "Zebra"))      '(:upcase :downcase :preserve :invert)))    => (ZEBRA |zebra| |Zebra| |zEBRA|) ;as printed with the standard                                       ;readtable and *print-case* :upcaseCurrent Practice:  While there may not be any current implementation that supports  exactly this proposal, several implementations provide some means  for changing case sensitivity.  Franz Inc's ExCL has a function, EXCL:SET-CASE-MODE, that sets both  the "preferred case" (the case of characters in the print names of  standard symbols such as CAR) and whether or not the reader is case-  sensitive.  In Symbolics Common Lisp, the function SET-CHARACTER-TRANSLATION  can be used to make the translation of a letter be that same letter,  thus achieving case-sensitivity.  Xerox Medley has a function for setting a readtable flag that  determines case sensitivity.Cost to Implementors:  Fairly small.  The reader will be slightly slower and readtables  will be slightly more complex.Cost to Users:  Slight.  Programmers must already take into account the possibility  that *READTABLE* will be a non-standard readtable.  Case-sensitivity  is no worse than character macros in this respect.Cost of Non-Adoption:  Applications that want to read mixed-case expressions will not  be able to use the Common Lisp reader to do so (except, perhaps,  by tortuous use of read macros).  Programming styles that rely on case distinctions (without escape  characters) will be effectively impossible in Common Lisp.Benefits:  Applications will be able to read mixed-case expressions.  Programmers will be able to make use of case distinctions.Aesthetics:  For the proposals:     The language will have greater symmetry, because it will be    possible to control the treatment of case on both input and output    instead of only on output (as is now the case).    The language will look less old-fashioned.  Against the proposals:      It is, perhaps, inconsistent to control case-sensitivity by a    readtable operation when other aspects of the reader, such as the    input base and the default float format (not to mention the    package), are controlled by special variables.  However, it can be    argued that character-level syntax is determined chiefly by the    readtable.  Case-sensitivity can be seen as analogous to character    macros in this respect.  Keywords vs function    The keyword proposal is somewhat simpler and, by being less    powerful, avoids suggesting the possibility of more general    character translation (for every charcater, say, rather than    just for unescaped constituents).    The function proposal is perhaps more elegant.Discussion:  Dalton supports both proposals but slightly prefers READTABLE-KEYWORDS.  Version 1 of the proposal suggested a new global variable rather  than a property of the readtable.  Pitman was strongly opposed to  that proposal and gave convincing arguments that it should be  dropped.  Gray suggested that the readtable property should be a  function.  It has been remarked that :INVERT produces somewhat strange  results.  For example, Zebra reads as zEBRA.  It was suggested  that inversion should happen only if the entire token was single-  case.  However, READ has to take escape characters into account (so that,  for example, |zebra| always reads as zebra), and then it is  difficult to know what rules to apply to the entire token.  Moreover, the description of READ in CLtL does not provide a  convenient place to insert processing of that sort (by the time  the full token is considered, the escape characters have been  forgotten).*start*04079 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Jun-89 16:18:52 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 JUN 89 16:18:49 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 16 Jun 89  16:17:11 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 612361; 16 Jun 89 19:19:03 EDTDate: Fri, 16 Jun 89 19:19 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: READ-CASE-SENSITIVITY (Version 3)To: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <19558.8906161835@aiai.ed.ac.uk>Message-ID: <19890616231919.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 16 Jun 89 19:35:44 BST    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>    I am not going to be able to come to the meeting but would    still like to see this issue considered.  I wasn't present    for the discussion at the last meeting, but my understanding    is that the committee wanted to see the issue again with    only a single proposal.  Yes, a single proposal is much better.  I'd very much like to seethis considered, and a single proposal will make that much easier.			     Unfortunately, I don't know which    proposal (keyword or function) most people prefer.I don't either, but I know that at Symbolics we strongly preferthe keyword proposal.  Since the discussion section says you preferthe keyword proposal, perhaps as the author you could use yourdiscretion to opt for that proposal and send out a version 4omitting the function proposal and the discussion of the relativemerits of the two proposals.    It has also been remarked that :INVERT is somewhat strange in that it    would have Zebra read as zEBRA; and it was suggested that inversion    should happen only if the entire name were single-case.    Unfortunately, the processing has to happen a character at a time,    because READ has to do it only for characters that are not escaped.I don't believe that the conclusion follows from the premise.    For example, |zebra| should always read as zebra.    However, READ has to take escape characters into account (so that,    for example, |zebra| always reads as zebra), and then it is    difficult to know what rules to apply to the entire token.    Moreover, the description of READ in CLtL does not provide a    convenient place to insert processing of that sort (by the time    the full token is considered, the escape characters have been    forgotten).The parenthesized clause is clearly false, since escapedness isremembered for purposes of package syntax and number/potential numbersyntax.  I believe it would be possible to make :INVERT apply only ifthe entire name is single-case.  It remains true that we have to decidewhether "the entire name" includes escaped characters or not (in eithercase, only the unescaped characters would be inverted).  The Generareader does case processing character at a time, as you outlined, butcould very easily implement :INVERT based on either the escapedcharacters or all the characters, so that's an existence proof (hint:one state in its finite state machine would be split into four states,depending on whether any letters have been seen so far and on whetherthey are all upper case, all lower case, or mixed case).  Unless someonecleverer than me comes up with an algorithm, it would be necessary toretain the symbol-name in both inverted and uninverted form untilthe entire token has been parsed, but the cost of that is negligible.I think it would be best to base the decision on only the unescapedcharacters.  That just seems more consistent with the rest of the reader.Can you / will you write a version 4 that contains only the keywordsproposal and that specifies :INVERT to invert case only when all theunescaped letters are in a single case?*start*05167 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Jun-89 08:52:49 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 JUN 89 08:52:48 PDTReceived: from NSFnet-Relay.AC.UK by SAIL.Stanford.EDU with TCP; 17 Jun 89  08:51:12 PDTReceived: from aiai.edinburgh.ac.uk by NSFnet-Relay.AC.UK   via Janet with NIFTP           id aa05325; 17 Jun 89 16:43 BSTDate: Sat, 17 Jun 89 16:50:44 BSTMessage-Id: <22133.8906171550@aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 3)To: "David A. Moon" <Moon@stony-brook.scrc.symbolics.com>In-Reply-To: David A. Moon's message of Fri, 16 Jun 89 19:19 EDTCc: cl-cleanup@sail.stanford.edu> 			     Unfortunately, I don't know which>     proposal (keyword or function) most people prefer.> > I don't either, but I know that at Symbolics we strongly prefer> the keyword proposal.  Since the discussion section says you prefer> the keyword proposal, perhaps as the author you could use your> discretion to opt for that proposal and send out a version 4> omitting the function proposal and the discussion of the relative> merits of the two proposals.OK, I'll do that unless people start speaking up for the functionproposal.>     It has also been remarked that :INVERT is somewhat strange in that it>     would have Zebra read as zEBRA; and it was suggested that inversion>     should happen only if the entire name were single-case.> >     Unfortunately, the processing has to happen a character at a time,>     because READ has to do it only for characters that are not escaped.> > I don't believe that the conclusion follows from the premise.You're probably right, since it looks like you have a betterunderstanding of this that I do.What I wanted to do was just to change point 1 of step 8 on page 337of CLtL, which is where unescaped constituents are converted to uppercase.  At that point, characters are being considered one at a time.If :INVERT's going to work on entire extended tokens, it looks like itrequires a more complicated change to the specification of READ.>     For example, |zebra| should always read as zebra.>     However, READ has to take escape characters into account (so that,>     for example, |zebra| always reads as zebra), and then it is>     difficult to know what rules to apply to the entire token.>     Moreover, the description of READ in CLtL does not provide a>     convenient place to insert processing of that sort (by the time>     the full token is considered, the escape characters have been>     forgotten).> > The parenthesized clause is clearly false, since escapedness is> remembered for purposes of package syntax and number/potential number> syntax.How it seemed to me was that escapedness was remembered only to theextent that escaped characters were considered to have only theattribute alphabetic.  But maybe that's enough, since lettersnormally have the attribute alphadigit.  But then, strictlyspeaking, that attribute depends on the setting of *READ-BASE*.> I believe it would be possible to make :INVERT apply only if> the entire name is single-case.  It remains true that we have to decide> whether "the entire name" includes escaped characters or not (in either> case, only the unescaped characters would be inverted).  The Genera> reader does case processing character at a time, as you outlined, but> could very easily implement :INVERT based on either the escaped> characters or all the characters, so that's an existence proof (hint:> one state in its finite state machine would be split into four states,> depending on whether any letters have been seen so far and on whether> they are all upper case, all lower case, or mixed case).  Unless someone> cleverer than me comes up with an algorithm, it would be necessary to> retain the symbol-name in both inverted and uninverted form until> the entire token has been parsed, but the cost of that is negligible.> I think it would be best to base the decision on only the unescaped> characters.  That just seems more consistent with the rest of the> reader.The CLtL model seems to be that the characters are accumulated thenprocessed as a "extended token".  So the rule would be something likethis:   If the read case of the current readtable is :INVERT and   if if all of the unescaped letters in the extended token are   of the same case, those letters are converted to the opposite   case.I'm a bit worried about the use of "unescaped" at this point,since the other parts of the processing of extended token dependonly on attributes such as alphabetic or digit.  I'm also a bit worried about things like this:  \abc reads as aBC, but prints as Abc> Can you / will you write a version 4 that contains only the keywords> proposal and that specifies :INVERT to invert case only when all the> unescaped letters are in a single case?Yes to at least the first.  I'd like to have some more feedback on thesecond.-- Jeff*start*02095 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 19-Jun-89 10:08:58 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 10:08:59 PDTReceived: from NSFnet-Relay.AC.UK by SAIL.Stanford.EDU with TCP; 19 Jun 89  10:06:52 PDTReceived: from aiai.edinburgh.ac.uk by NSFnet-Relay.AC.UK   via Janet with NIFTP           id aa07405; 19 Jun 89 17:45 BSTDate: Mon, 19 Jun 89 17:53:54 BSTMessage-Id: <877.8906191653@aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>Subject: mail lossage (and Issue: READ-CASE-SENSITIVITY (Version 3))To: "David A. Moon" <Moon@stony-brook.scrc.symbolics.com>In-Reply-To: David A. Moon's message of Fri, 16 Jun 89 19:19 EDTCc: cl-cleanup@sail.stanford.eduI did get this>     Date: Fri, 16 Jun 89 19:35:44 BST>     From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>> >     I am not going to be able to come to the meeting but would>     still like to see this issue considered.  I wasn't present>     for the discussion at the last meeting, but my understanding>     is that the committee wanted to see the issue again with>     only a single proposal.  > > Yes, a single proposal is much better.  I'd very much like to see> this considered, and a single proposal will make that much easier.> > 			     Unfortunately, I don't know which>     proposal (keyword or function) most people prefer.> > I don't either, but I know that at Symbolics we strongly prefer> the keyword proposal.  Since the discussion section says you prefer> the keyword proposal, perhaps as the author you could use your> discretion to opt for that proposal and send out a version 4> omitting the function proposal and the discussion of the relative> merits of the two proposals.> [etc.]If anyone sent me mail this weekend (or mail that may have arrivedbefore this afternoon (UK time), I probably didn't get it, becausethe machine that receives my CL mail was very broken.-- Jeff*start*05166 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 19-Jun-89 10:49:35 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 10:49:12 PDTReceived: from NSFnet-Relay.AC.UK by SAIL.Stanford.EDU with TCP; 19 Jun 89  10:46:28 PDTReceived: from aiai.edinburgh.ac.uk by NSFnet-Relay.AC.UK   via Janet with NIFTP           id ab07945; 19 Jun 89 18:32 BSTDate: Mon, 19 Jun 89 18:40:14 BSTMessage-Id: <1097.8906191740@aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 3)To: "David A. Moon" <Moon@stony-brook.scrc.symbolics.com>In-Reply-To: David A. Moon's message of Fri, 16 Jun 89 19:19 EDTCc: cl-cleanup@sail.stanford.edu> 			     Unfortunately, I don't know which>     proposal (keyword or function) most people prefer.> > I don't either, but I know that at Symbolics we strongly prefer> the keyword proposal.  Since the discussion section says you prefer> the keyword proposal, perhaps as the author you could use your> discretion to opt for that proposal and send out a version 4> omitting the function proposal and the discussion of the relative> merits of the two proposals.OK, I'll do that unless people start speaking up for the functionproposal.>     It has also been remarked that :INVERT is somewhat strange in that it>     would have Zebra read as zEBRA; and it was suggested that inversion>     should happen only if the entire name were single-case.> >     Unfortunately, the processing has to happen a character at a time,>     because READ has to do it only for characters that are not escaped.> > I don't believe that the conclusion follows from the premise.You're probably right, since it looks like you have a betterunderstanding of this that I do.What I wanted to do was just to change point 1 of step 8 on page 337of CLtL, which is where unescaped constituents are converted to uppercase.  At that point, characters are being considered one at a time.If :INVERT's going to work on entire extended tokens, it looks like itrequires a more complicated change to the specification of READ.>     For example, |zebra| should always read as zebra.>     However, READ has to take escape characters into account (so that,>     for example, |zebra| always reads as zebra), and then it is>     difficult to know what rules to apply to the entire token.>     Moreover, the description of READ in CLtL does not provide a>     convenient place to insert processing of that sort (by the time>     the full token is considered, the escape characters have been>     forgotten).> > The parenthesized clause is clearly false, since escapedness is> remembered for purposes of package syntax and number/potential number> syntax.How it seemed to me was that escapedness was remembered only to theextent that escaped characters were considered to have only theattribute alphabetic.  But maybe that's enough, since lettersnormally have the attribute alphadigit.  But then, strictlyspeaking, that attribute depends on the setting of *READ-BASE*.> I believe it would be possible to make :INVERT apply only if> the entire name is single-case.  It remains true that we have to decide> whether "the entire name" includes escaped characters or not (in either> case, only the unescaped characters would be inverted).  The Genera> reader does case processing character at a time, as you outlined, but> could very easily implement :INVERT based on either the escaped> characters or all the characters, so that's an existence proof (hint:> one state in its finite state machine would be split into four states,> depending on whether any letters have been seen so far and on whether> they are all upper case, all lower case, or mixed case).  Unless someone> cleverer than me comes up with an algorithm, it would be necessary to> retain the symbol-name in both inverted and uninverted form until> the entire token has been parsed, but the cost of that is negligible.> I think it would be best to base the decision on only the unescaped> characters.  That just seems more consistent with the rest of the> reader.The CLtL model seems to be that the characters are accumulated thenprocessed as a "extended token".  So the rule would be something likethis:   If the read case of the current readtable is :INVERT and   if if all of the unescaped letters in the extended token are   of the same case, those letters are converted to the opposite   case.I'm a bit worried about the use of "unescaped" at this point,since the other parts of the processing of extended token dependonly on attributes such as alphabetic or digit.  I'm also a bit worried about things like this:  \abc reads as aBC, but prints as Abc> Can you / will you write a version 4 that contains only the keywords> proposal and that specifies :INVERT to invert case only when all the> unescaped letters are in a single case?Yes to at least the first.  I'd like to have some more feedback on thesecond.-- Jeff*start*03825 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 21-Jun-89 15:15:05 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 15:15:12 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 21 Jun 89  15:08:10 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 614692; 21 Jun 89 16:53:52 EDTDate: Wed, 21 Jun 89 16:54 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: READ-CASE-SENSITIVITY (Version 3)To: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <22133.8906171550@aiai.ed.ac.uk>Supersedes: <19890621205241.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Comments: Didn't look carefully enough at your \abc example the first time.Message-ID: <19890621205432.4.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sat, 17 Jun 89 16:50:44 BST    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>    What I wanted to do was just to change point 1 of step 8 on page 337    of CLtL, which is where unescaped constituents are converted to upper    case.  At that point, characters are being considered one at a time.    If :INVERT's going to work on entire extended tokens, it looks like it    requires a more complicated change to the specification of READ.Right.  But the specification of READ should be how it behaves, nota program-written-in-English.       If the read case of the current readtable is :INVERT and       if if all of the unescaped letters in the extended token are       of the same case, those letters are converted to the opposite       case.Agreed.  I think that's a good way to phrase it, too.    I'm a bit worried about the use of "unescaped" at this point,    since the other parts of the processing of extended token depend    only on attributes such as alphabetic or digit.  How about changing the places where it says escaped characters are giventhe attribute alphabetic, and the places that say characters like ! and= have the attribute alphabetic (obvious nonsense, eh?) to use the newattribute name "ordinary".  In fact there will no longer be analphabetic attribute, because all the letters have the alphadigitattribute instead.  But you'd have to switch 0 through 9 from alphadigitto digit.  Let's gloss over the impact, if any, on bases less than 10(in octal, is 9 alphabetic?), otherwise we'd have to invent an"ordinadigit" attribute for 0 through 9 to have.So you could rephrase the rule:       If the read case of the current readtable is :INVERT and       if all of the alphabetic characters in the extended token are       of the same case, those characters are converted to the opposite       case.That seems neater.    I'm also a bit worried about things like this:      \abc reads as aBC, but prints as AbcThis is inherent in the idea of escape characters, so you shouldn'tworry about it.  Anyone who uses it to attack your proposal isn'tplaying fair, they should be attacking CLtL Common Lisp for thisif they don't like it.Oh excuse me, it can't print as Abc since that reads as Abc.It has to print as aBC or |aBC|.  Any printer has to be able tofigure out whether it has to put in escapes to make the readerread it back correctly, so that's no problem.    > Can you / will you write a version 4 that contains only the keywords    > proposal and that specifies :INVERT to invert case only when all the    > unescaped letters are in a single case?    Yes to at least the first.  I'd like to have some more feedback on the    second.I hope this is enough feedback.  The amount of mail seems to be dying down.*start*06342 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 22-Jun-89 14:04:38 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 JUN 89 14:04:26 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 22 Jun 89  14:02:50 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 615489; 22 Jun 89 17:04:24 EDTDate: Thu, 22 Jun 89 17:04 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: READ-CASE-SENSITIVITY (Version 4)To: jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UKcc: Moon@STONY-BROOK.SCRC.Symbolics.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: <23126.8906221832@subnode.aiai.ed.ac.uk>Message-ID: <19890622210419.9.KMP@BOBOLINK.SCRC.Symbolics.COM>Mostly this still looks ok to me.  I will certainly encourage Moon tovote Yes on it. But I do have a few comments which I think would bothimprove the presentation and would help us avoid confusions down theroad...    Date: Thu, 22 Jun 89 19:32:17 BST    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>    Maybe this is OK.  If anyone has objections, I'd really like to hear    them before everyone goes off to the meeting.  (Um, I know it's rather    late.)    Issue:        READ-CASE-SENSITIVITY    ...    Proposal (READ-CASE-SENSITIVITY:READTABLE-KEYWORDS)    ...      The READTABLE-CASE of a readtable also has significance when      printing.  The case in which letters are printed is determined as      follows:        When READTABLE-CASE is :UPCASE, upper-case letters are printed        in the case specified by *PRINT-CASE*, and lower-case letters        are printed in their own case.        When READTABLE-CASE is :DOWNCASE, lower-case letters are printed        in the case specified by *PRINT-CASE*, and upper-case letters        are printed in their own case.        When READTABLE-CASE is :PRESERVE, all letters are printed in their        own case.        When READTABLE-CASE is :INVERT, the case of all letters in single-        case symbol names is inverted.  Mixed-case symbol names are printed        as-is.      (The behavior when *PRINT-CASE* is :CAPITALIZE is like :UPCASE for      the first character and :DOWNCASE for the rest.)      ...I think this parenthetic remark is more confusing than helpful.For example, it only applies in the cases of READTABLE-CASEbeing :UPCASE or :DOWNCASE, right? Strictly, I think it is notnecessary because the phrase "in the case specified by *PRINT-CASE*"means this. If you really feel the remark is needed, I suggest thenotation:  The READTABLE-CASE of a readtable also has significance when  printing.  The case in which letters are printed is determined as  follows:    When READTABLE-CASE is :UPCASE, upper-case letters are printed    in the case specified by *PRINT-CASE* [1], and lower-case letters    are printed in their own case.    When READTABLE-CASE is :DOWNCASE, lower-case letters are printed    in the case specified by *PRINT-CASE* [1], and upper-case letters    are printed in their own case.    When READTABLE-CASE is :PRESERVE, all letters are printed in their    own case.    When READTABLE-CASE is :INVERT, the case of all letters in single-    case symbol names is inverted.  Mixed-case symbol names are printed    as-is.  [1] That is, :UPCASE means uppercase, :DOWNCASE means lowercase,      and :CAPITALIZE means uppercase for the first character and      lowercase for the rest of the characters.  ...   -----    Test Case:       (let ((rt (copy-readtable nil)))        (mapcar          #'(lambda (case)              (setf (readtable-case rt) case)              (read-from-string "Zebra"))          '(:upcase :downcase :preserve :invert)))        => (ZEBRA |zebra| |Zebra| |zEBRA|) ;as printed with the standard                                           ;readtable and *print-case* :upcaseThis example is buggy, of course, because you need to bind *READTABLE*, not RT.It's also incomplete because it doesn't explain the interaction with *PRINT-CASE*.It would be better if we had a test case which at least did:(let ((*readtable* (copy-readtable nil))      (*print-case* *print-case*)      (readtable-cases '(:upcase :downcase :preserve :invert))      (print-cases '(:upcase :downcase :capitalize)))  (format t "READTABLE-CASE *PRINT-CASE*        ZEBRA Zebra zebra zEBRA~	   ~%----------------------------------------------------------~	   ~%")  (dolist (readtable-case readtable-cases)    (dolist (print-case print-cases)      (let ((data '()))	(setf (readtable-case *readtable*) readtable-case)	(setq *print-case* print-case)	(dolist (string '("ZEBRA" "Zebra" "zebra" "zEBRA"))	  (push (read-from-string string) data))	(setq data (nreverse data))	(setf (readtable-case *readtable*) readtable-case)	(format t "~&:~A~16T:~A~32T   ~{~A~^ ~}"		(string-upcase readtable-case)		(string-upcase print-case)		data)))))Actually, a full table like the following might be even clearer, but maybethat's overkill...(let ((*readtable* (copy-readtable nil))      (*print-case* *print-case*)      (readtable-cases '(:upcase :downcase :preserve :invert))      (print-cases '(:upcase :downcase :capitalize)))  (format t "READTABLE-CASE          *PRINT-CASE*   Input:~           ~%Read        Print       Print          ZEBRA Zebra zebra zEBRA~	   ~%--------------------------------------------------------------~	   ~%")  (dolist (readtable-case-for-read-time readtable-cases)    (dolist (readtable-case-for-print-time readtable-cases)      (dolist (print-case-for-print-time print-cases)	(let ((data '()))	  (setf (readtable-case *readtable*) readtable-case-for-read-time)	  (dolist (string '("ZEBRA" "Zebra" "zebra" "zEBRA"))	    (push (read-from-string string) data))	  (setq data (nreverse data))	  (setf (readtable-case *readtable*) readtable-case-for-print-time)	  (setq *print-case* print-case-for-print-time)                	  (format t "~&:~A~12T:~A~24T:~A~36T   ~{~A~^ ~}"		  (string-upcase readtable-case-for-read-time)		  (string-upcase readtable-case-for-print-time)		  (string-upcase print-case-for-print-time)		  data))))))*start*10405 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 22-Jun-89 11:35:52 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 JUN 89 11:33:56 PDTReceived: from NSFnet-Relay.AC.UK by SAIL.Stanford.EDU with TCP; 22 Jun 89  11:31:29 PDTReceived: from aiai.edinburgh.ac.uk by NSFnet-Relay.AC.UK   via Janet with NIFTP           id aa08257; 22 Jun 89 19:21 BSTDate: Thu, 22 Jun 89 19:32:17 BSTMessage-Id: <23126.8906221832@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>Subject: Issue: READ-CASE-SENSITIVITY (Version 4)To: "David A. Moon" <Moon@stony-brook.scrc.symbolics.com>In-Reply-To: David A. Moon's message of Wed, 21 Jun 89 16:54 EDTCc: cl-cleanup@sail.stanford.eduMaybe this is OK.  If anyone has objections, I'd really like to hearthem before everyone goes off to the meeting.  (Um, I know it's ratherlate.)Issue:        READ-CASE-SENSITIVITYForum:	      CleanupReferences:   CLtL p 334 ff: What the Read Function Accepts,                especially p 337, step 8, point 1.              CLtL p 360 ff: The Readtable              COPY-READTABLE (CLtL, p 361)              *PRINT-CASE* (CLtL, p 372)Category:     ADDITION/CHANGEEdit history: Version 1, 15-Feb-89, by Dalton              Version 2, 23-Mar-89, by Dalton,                (completely new proposal after comments from                 Pitman, Gray, Masinter, and R.Tobin@uk.ac.ed)              Version 3, 16-Jun-89, by Dalton                (very minor changes in presentation                 and some additions to the discussion)              Version 4, 22-Jun-89, by Dalton                (removal of the FUNCTION proposal and a different                 specification for :INVERT after discussion with Moon)Problem Description:  The Common Lisp reader always converts unescaped constituent  characters to upper case.  (See CLtL, p 337, step 8, point 1.)  This behavior is not always desirable.  1.  Lisp applications often use the Lisp reader to read their data.  This is often significantly easier than writing input routines  from scratch, especially if the input can be structured as lists.  However, certain applications want to make use of case distinctions,  and Common Lisp makes this unreasonably difficult.  (You must define  every letter as a read macro and have the macro function read the  rest of the symbol, or else you must write a reader from scratch.)  2.  Some programming languages distinguish between upper and lower  case in identifiers, and useful conventions are often built around  such distinctions.  For example, in C, constants are often written  in upper case and variables in lower.  In Mesa(?) and Smalltalk(?),  a capital letter is used to indicate the beginning of a new word  in identifiers made up of several words.  In Edinburgh Prolog,  variables begin with upper-case letters and constant symbols do  not.  The case-insensitivity of the Common Lisp reader makes  it difficult to use conventions of this sort.Proposal (READ-CASE-SENSITIVITY:READTABLE-KEYWORDS)  Define a new settable function, (READTABLE-CASE <readtable>) to  control the reader's interpretation of case.  The following values  may be given: :UPCASE, :DOWNCASE, :PRESERVE, and :INVERT.    When the value is :UPCASE, unescaped constituent characters    are converted to upper-case, as specified by CLtL on page 337.    When the value is :DOWNCASE, unescaped constituent characters    are converted to lower-case.    When the value is :PRESERVE, the case of all characters remains    unchanged.    When the value is :INVERT, then if if all of the unescaped letters    in the extended token are of the same case, those (unescaped)    letters are converted to the opposite case.  COPY-READTABLE copies the setting of READTABLE-CASE.  The value of  READTABLE-CASE for the standard readtable is :UPCASE.  The READTABLE-CASE of a readtable also has significance when  printing.  The case in which letters are printed is determined as  follows:    When READTABLE-CASE is :UPCASE, upper-case letters are printed    in the case specified by *PRINT-CASE*, and lower-case letters    are printed in their own case.    When READTABLE-CASE is :DOWNCASE, lower-case letters are printed    in the case specified by *PRINT-CASE*, and upper-case letters    are printed in their own case.    When READTABLE-CASE is :PRESERVE, all letters are printed in their    own case.    When READTABLE-CASE is :INVERT, the case of all letters in single-    case symbol names is inverted.  Mixed-case symbol names are printed    as-is.  (The behavior when *PRINT-CASE* is :CAPITALIZE is like :UPCASE for  the first character and :DOWNCASE for the rest.)  The rules for escaping letters in symbol names are also affected by  the READTABLE-CASE.  If *PRINT-ESCAPE* is true, letters are escaped  as follows:    When READTABLE-CASE is :UPCASE, all lower-case letters must be    escaped.    When READTABLE-CASE is :DOWNCASE, all upper-case letters must be    escaped.    When READTABLE-CASE is :PRESERVE, no letters need be escaped.    When READTABLE-CASE is :INVERT, all letters in all single-case    symbol names must be escaped.    Rationale:  There are a number of different ways to achieve case-sensitivity.  This proposal is fairly simple but provides all of the functionality  that one could reasonably expect.  By using a property of the readtable, we avoid introducing a new  special variable.  Any code that wishes to control all of the  reader's parameters already takes *READTABLE* into account.  A new  special variable would require such code to change.  :DOWNCASE is included for symmetry with :UPCASE.    :INVERT is included so that case conventions can be used in Common  Lisp code without requiring that the names of symbols in the "LISP"  package be written in upper case.  (Opinions vary as to whether is  is advisable to use such conventions, but this proposal leaves that  choice to the user.)  :INVERT has an effect only for single-case names so that mixed-  case names can be interpreted in a more straightforward way.  In order to avoid complex interactions between the case setting of  the readtable and *PRINT-CASE*, this proposal specifies a  significance for *PRINT-CASE* only when the case setting is :UPCASE  or :DOWNCASE.  The meaning of *PRINT-CASE* when the readtable  setting is :DOWNCASE was chosen for its simplicity and for symmetry  with :UPCASE while still being useful.Test Case:   (let ((rt (copy-readtable nil)))    (mapcar      #'(lambda (case)          (setf (readtable-case rt) case)          (read-from-string "Zebra"))      '(:upcase :downcase :preserve :invert)))    => (ZEBRA |zebra| |Zebra| |zEBRA|) ;as printed with the standard                                       ;readtable and *print-case* :upcaseCurrent Practice:  While there may not be any current implementation that supports  exactly this proposal, several implementations provide some means  for changing case sensitivity.  Franz Inc's ExCL has a function, EXCL:SET-CASE-MODE, that sets both  the "preferred case" (the case of characters in the print names of  standard symbols such as CAR) and whether or not the reader is case-  sensitive.  In Symbolics Common Lisp, the function SET-CHARACTER-TRANSLATION  can be used to make the translation of a letter be that same letter,  thus achieving case-sensitivity.  Xerox Medley has a function for setting a readtable flag that  determines case sensitivity.Cost to Implementors:  Fairly small.  The reader will be slightly slower and readtables  will be slightly more complex.Cost to Users:  Slight.  Programmers must already take into account the possibility  that *READTABLE* will be a non-standard readtable.  Case-sensitivity  is no worse than character macros in this respect.Cost of Non-Adoption:  Applications that want to read mixed-case expressions will not  be able to use the Common Lisp reader to do so (except, perhaps,  by tortuous use of read macros).  Programming styles that rely on case distinctions (without escape  characters) will effectively be impossible in Common Lisp.Benefits:  Applications will be able to read mixed-case expressions.  Programmers will be able to make use of case distinctions.Aesthetics:  For the proposal:     The language will have greater symmetry, because it will be    possible to control the treatment of case on both input and output    instead of only on output (as is now the case).    The language will look less old-fashioned.  Against the proposal:      It is, perhaps, inconsistent to control case-sensitivity by a    readtable operation when other aspects of the reader, such as the    input base and the default float format (not to mention the    package), are controlled by special variables.  However, it can be    argued that character-level syntax is determined chiefly by the    readtable.  Case-sensitivity can be seen as analogous to character    macros in this respect.Discussion:  Dalton supports the proposal READTABLE-KEYWORDS.  Version 1 of the proposal suggested a new global variable rather  than a property of the readtable.  Pitman was strongly opposed to  that proposal and gave convincing arguments that it should be  dropped.  Gray suggested that the readtable property should be a  function.  Versions 2 and 3 included a FUNCTION proposal as well  as the KEYWORD one.  But at the March 1989 X3J13 meeting it was  felt that there should be only a single proposal and, since  opinion seemed to favor the KEYWORD proposal, the FUNCTION  proposal was dropped.  In earlier versions of the proposal, :INVERT worked a letter at  a time (rather than operating on extended tokens) so that, for  example, Zebra read as zEBRA.  However, the purpose of :INVERT  is to let the programmer get the standard internal case (ie,  upper case) by writing lower case rather than upper.  This  matters when referring to single-case symbols such as those  in the LISP package.  But, in most cases, mixed-case identifiers  will already have the right case.  For example, one would use  TheNextWindow to get TheNextWindow, not tHEnEXTwINDOW.*start*13827 00024 UU?GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-Jun-89 18:45:42 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 JUN 89 18:45:37 PDTReceived: from NSFnet-Relay.AC.UK by SAIL.Stanford.EDU with TCP; 23 Jun 89  18:40:19 PDTReceived: from aiai.edinburgh.ac.uk by NSFnet-Relay.AC.UK   via Janet with NIFTP           id aa09938; 23 Jun 89 21:20 BSTDate: Fri, 23 Jun 89 21:30:23 BSTMessage-Id: <3406.8906232030@aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSFnet-Relay.AC.UK>Subject: Issue: READ-CASE-SENSITIVITY (Version 5)To: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>In-Reply-To: Kent M Pitman's message of Thu, 22 Jun 89 17:04 EDTCc: Moon@stony-brook.scrc.symbolics.com, cl-cleanup@sail.stanford.eduIssue:        READ-CASE-SENSITIVITYForum:	      CleanupReferences:   CLtL p 334 ff: What the Read Function Accepts,                especially p 337, step 8, point 1.              CLtL p 360 ff: The Readtable              COPY-READTABLE (CLtL, p 361)              *PRINT-CASE* (CLtL, p 372)Category:     ADDITION/CHANGEEdit history: Version 1, 15-Feb-89, by Dalton              Version 2, 23-Mar-89, by Dalton,                (completely new proposal after comments from                 Pitman, Gray, Masinter, and R.Tobin@uk.ac.ed)              Version 3, 16-Jun-89, by Dalton                (very minor changes in presentation                 and some additions to the discussion)              Version 4, 22-Jun-89, by Dalton                (removal of the FUNCTION proposal and a different                 specification for :INVERT after discussion with Moon)              Version 5, 23-Jun-89, by Dalton                (minor revisions in presentation and better test case,                 as suggested by Pitman; also fixed some other errors)Problem Description:  The Common Lisp reader always converts unescaped constituent  characters to upper case.  (See CLtL, p 337, step 8, point 1.)  This behavior is not always desirable.  1.  Lisp applications often use the Lisp reader to read their data.  This is often significantly easier than writing input routines  from scratch, especially if the input can be structured as lists.  However, certain applications want to make use of case distinctions,  and Common Lisp makes this unreasonably difficult.  (You must define  every letter as a read macro and have the macro function read the  rest of the symbol, or else you must write a reader from scratch.)  2.  Some programming languages distinguish between upper and lower  case in identifiers, and useful conventions are often built around  such distinctions.  For example, in C, constants are often written  in upper case and variables in lower.  In Mesa(?) and Smalltalk(?),  a capital letter is used to indicate the beginning of a new word  in identifiers made up of several words.  In Edinburgh Prolog,  variables begin with upper-case letters and constant symbols do  not.  The case-insensitivity of the Common Lisp reader makes  it difficult to use conventions of this sort.Proposal (READ-CASE-SENSITIVITY:READTABLE-KEYWORDS)  Define a new settable function, (READTABLE-CASE <readtable>) to  control the reader's interpretation of case.  The following values  may be given: :UPCASE, :DOWNCASE, :PRESERVE, and :INVERT.    When the value is :UPCASE, unescaped constituent characters    are converted to upper-case, as specified by CLtL on page 337.    When the value is :DOWNCASE, unescaped constituent characters    are converted to lower-case.    When the value is :PRESERVE, the case of all characters remains    unchanged.    When the value is :INVERT, then if all of the unescaped letters    in the extended token are of the same case, those (unescaped)    letters are converted to the opposite case.  COPY-READTABLE copies the setting of READTABLE-CASE.  The value of  READTABLE-CASE for the standard readtable is :UPCASE.  The READTABLE-CASE of a readtable also has significance when printing  The case in which letters are printed, when vertical-bar syntax is not  used, is determined as follows:    When READTABLE-CASE is :UPCASE, upper-case letters are printed    in the case specified by *PRINT-CASE*, and lower-case letters    are printed in their own case.    When READTABLE-CASE is :DOWNCASE, lower-case letters are printed    in the case specified by *PRINT-CASE*, and upper-case letters    are printed in their own case.    When READTABLE-CASE is :PRESERVE, all letters are printed in their    own case.    When READTABLE-CASE is :INVERT, the case of all letters in single-    case symbol names is inverted.  Mixed-case symbol names are printed    as-is.  The rules for escaping letters in symbol names are also affected by  the READTABLE-CASE.  If *PRINT-ESCAPE* is true, letters are escaped  as follows:    When READTABLE-CASE is :UPCASE, all lower-case letters must be    escaped.    When READTABLE-CASE is :DOWNCASE, all upper-case letters must be    escaped.    When READTABLE-CASE is :PRESERVE, no letters need be escaped.    When READTABLE-CASE is :INVERT, all letters in all single-case    symbol names must be escaped.    Rationale:  There are a number of different ways to achieve case-sensitivity.  This proposal is fairly simple but provides all of the functionality  that one could reasonably expect.  By using a property of the readtable, we avoid introducing a new  special variable.  Any code that wishes to control all of the  reader's parameters already takes *READTABLE* into account.  A new  special variable would require such code to change.  :DOWNCASE is included for symmetry with :UPCASE.    :INVERT is included so that case conventions can be used in Common  Lisp code without requiring that the names of symbols in the "LISP"  package be written in upper case.  (Opinions vary as to whether is  is advisable to use such conventions, but this proposal leaves that  choice to the user.)  :INVERT has an effect only for single-case names so that mixed-  case names can be interpreted in a more straightforward way.  In order to avoid complex interactions between the case setting of  the readtable and *PRINT-CASE*, this proposal specifies a  significance for *PRINT-CASE* only when the case setting is :UPCASE  or :DOWNCASE.  The meaning of *PRINT-CASE* when the readtable  setting is :DOWNCASE was chosen for its simplicity and for symmetry  with :UPCASE while still being useful.Test Cases:  ;;; Test 1 -- reading  (defun test1 ()    (let ((*readtable* (copy-readtable nil)))      (format t "READTABLE-CASE  Input   Symbol-name~	       ~%-----------------------------------~	       ~%")      (dolist (readtable-case '(:upcase :downcase :preserve :invert))	(setf (readtable-case *readtable*) readtable-case)	(dolist (input '("ZEBRA" "Zebra" "zebra"))	  (format t "~&:~A~16T~A~24T~A"		  (string-upcase readtable-case)		  input		  (symbol-name (read-from-string input)))))))  The output from (TEST1) should be as follows:    READTABLE-CASE  Input   Symbol-name    -----------------------------------    :UPCASE         ZEBRA   ZEBRA    :UPCASE         Zebra   ZEBRA    :UPCASE         zebra   ZEBRA    :DOWNCASE       ZEBRA   zebra    :DOWNCASE       Zebra   zebra    :DOWNCASE       zebra   zebra    :PRESERVE       ZEBRA   ZEBRA    :PRESERVE       Zebra   Zebra    :PRESERVE       zebra   zebra    :INVERT         ZEBRA   zebra    :INVERT         Zebra   Zebra    :INVERT         zebra   ZEBRA  ;;; Test 2 -- printing  (defun test2 ()    (let ((*readtable* (copy-readtable nil))	  (*print-case* *print-case*))      (format t "READTABLE-CASE *PRINT-CASE*  Symbol-name  Output~	       ~%--------------------------------------------------~	       ~%")      (dolist (readtable-case '(:upcase :downcase :preserve :invert))	(setf (readtable-case *readtable*) readtable-case)	(dolist (print-case '(:upcase :downcase :capitalize))	  (dolist (symbol '(|ZEBRA| |Zebra| |zebra|))	    (setq *print-case* print-case)	    (format t "~&:~A~15T:~A~29T~A~42T~A"		    (string-upcase readtable-case)		    (string-upcase print-case)		    (symbol-name symbol)		    (prin1-to-string symbol)))))))  The putput from (TEST2) should be as follows:    READTABLE-CASE *PRINT-CASE*  Symbol-name  Output    --------------------------------------------------    :UPCASE        :UPCASE       ZEBRA        ZEBRA    :UPCASE        :UPCASE       Zebra        |Zebra|    :UPCASE        :UPCASE       zebra        |zebra|    :UPCASE        :DOWNCASE     ZEBRA        zebra    :UPCASE        :DOWNCASE     Zebra        |Zebra|    :UPCASE        :DOWNCASE     zebra        |zebra|    :UPCASE        :CAPITALIZE   ZEBRA        Zebra    :UPCASE        :CAPITALIZE   Zebra        |Zebra|    :UPCASE        :CAPITALIZE   zebra        |zebra|    :DOWNCASE      :UPCASE       ZEBRA        |ZEBRA|    :DOWNCASE      :UPCASE       Zebra        |Zebra|    :DOWNCASE      :UPCASE       zebra        ZEBRA    :DOWNCASE      :DOWNCASE     ZEBRA        |ZEBRA|    :DOWNCASE      :DOWNCASE     Zebra        |Zebra|    :DOWNCASE      :DOWNCASE     zebra        zebra    :DOWNCASE      :CAPITALIZE   ZEBRA        |ZEBRA|    :DOWNCASE      :CAPITALIZE   Zebra        |Zebra|    :DOWNCASE      :CAPITALIZE   zebra        Zebra    :PRESERVE      :UPCASE       ZEBRA        ZEBRA    :PRESERVE      :UPCASE       Zebra        Zebra    :PRESERVE      :UPCASE       zebra        zebra    :PRESERVE      :DOWNCASE     ZEBRA        ZEBRA    :PRESERVE      :DOWNCASE     Zebra        Zebra    :PRESERVE      :DOWNCASE     zebra        zebra    :PRESERVE      :CAPITALIZE   ZEBRA        ZEBRA    :PRESERVE      :CAPITALIZE   Zebra        Zebra    :PRESERVE      :CAPITALIZE   zebra        zebra    :INVERT        :UPCASE       ZEBRA        zebra    :INVERT        :UPCASE       Zebra        Zebra    :INVERT        :UPCASE       zebra        ZEBRA    :INVERT        :DOWNCASE     ZEBRA        zebra    :INVERT        :DOWNCASE     Zebra        Zebra    :INVERT        :DOWNCASE     zebra        ZEBRA    :INVERT        :CAPITALIZE   ZEBRA        zebra    :INVERT        :CAPITALIZE   Zebra        Zebra    :INVERT        :CAPITALIZE   zebra        ZEBRACurrent Practice:  While there may not be any current implementation that supports  exactly this proposal, several implementations provide some means  for changing case sensitivity.  Franz Inc's ExCL has a function, EXCL:SET-CASE-MODE, that sets both  the "preferred case" (the case of characters in the print names of  standard symbols such as CAR) and whether or not the reader is case-  sensitive.  In Symbolics Common Lisp, the function SET-CHARACTER-TRANSLATION  can be used to make the translation of a letter be that same letter,  thus achieving case-sensitivity.  Xerox Medley has a function for setting a readtable flag that  determines case sensitivity.Cost to Implementors:  Fairly small.  The reader will be slightly slower and readtables  will be slightly more complex.Cost to Users:  Slight.  Programmers must already take into account the possibility  that *READTABLE* will be a non-standard readtable.  Case-sensitivity  is no worse than character macros in this respect.Cost of Non-Adoption:  Applications that want to read mixed-case expressions will not  be able to use the Common Lisp reader to do so (except, perhaps,  by tortuous use of read macros).  Programming styles that rely on case distinctions (without escape  characters) will effectively be impossible in Common Lisp.Benefits:  Applications will be able to read mixed-case expressions.  Programmers will be able to make use of case distinctions.Aesthetics:  For the proposal:     The language will have greater symmetry, because it will be    possible to control the treatment of case on both input and output    instead of only on output (as is now the case).    The language will look less old-fashioned.  Against the proposal:      It is, perhaps, inconsistent to control case-sensitivity by a    readtable operation when other aspects of the reader, such as the    input base and the default float format (not to mention the    package), are controlled by special variables.  However, it can be    argued that character-level syntax is determined chiefly by the    readtable.  Case-sensitivity can be seen as analogous to character    macros in this respect.Discussion:  Dalton supports the proposal READTABLE-KEYWORDS.  Version 1 of the proposal suggested a new global variable rather  than a property of the readtable.  Pitman was strongly opposed to  that proposal and gave convincing arguments that it should be  dropped.  Gray suggested that the readtable property should be a  function.  Versions 2 and 3 included a FUNCTION proposal as well  as the KEYWORD one.  But at the March 1989 X3J13 meeting it was  felt that there should be only a single proposal and, since  opinion seemed to favor the KEYWORD proposal, the FUNCTION  proposal was dropped.  In earlier versions of the proposal, :INVERT worked a letter at  a time (rather than operating on extended tokens) so that, for  example, Zebra read as zEBRA.  However, the purpose of :INVERT  is to let the programmer get the standard internal case (ie,  upper case) by writing lower case rather than upper.  This  matters when referring to single-case symbols such as those  in the LISP package.  But, in most cases, mixed-case identifiers  will already have the right case.  For example, one would use  TheNextWindow to get TheNextWindow, not tHEnEXTwINDOW.