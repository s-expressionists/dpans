*start*07991 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 DEC 88 11:32:22 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Dec 88  11:27:34 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 511418; Thu 22-Dec-88 14:03:31 ESTDate: Thu, 22 Dec 88 14:03 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LISP-PACKAGE-NAME (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881222140316.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Issue:        LISP-PACKAGE-NAMEReferences:   11.6 Built-in Packages (pp181-182)Category:     CHANGEEdit history: 22-Dec-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  Since ANSI Common Lisp will differ from the Common Lisp described by CLtL,  it will not be possible to have support for both in the same Lisp image  if ANSI Common Lisp insists on placing its functionality in the package  named LISP.  Further, use of the name unqualified name LISP by the ANSI Common Lisp  community is inconsistent with ANSI's expressed position to ISO that   the term "LISP" names a language family rather than a specific dialect  within that family.Proposal (LISP-PACKAGE-NAME:COMMON-LISP):  Define that ANSI Common Lisp uses the package name COMMON-LISP, not LISP.  Define that the COMMON-LISP package has nickname CL.  Since some symbols (e.g., T, NIL, and LAMBDA) might have to be shared  between COMMON-LISP and LISP in implementations simultaneously supporting  both, clarify that the initial symbols specified by ANSI Common Lisp as  belonging in the COMMON-LISP package need not have a home package of   Common-Lisp.Test Case:  In an implementation supporting CLtL's LISP package and   the ANSI Common Lisp CL package proposed here:  (EQ 'LISP:T 'CL:T)  => not specified, due to this proposal, but probably T  (EQ 'LISP:CAR 'CL:CAR)  => not specified, due to this proposal, but probably T  (EQ 'LISP:FUNCTIONP 'CL:FUNCTIONP)  => not specified, due to this proposal, but since FUNCTIONP is     changed incompatibly between CLtL (LISP) and CL (ANSI), there     are good reasons why this might return NIL.  (SYMBOL-PACKAGE 'CL:T)  => not specified, due to this proposal. Perhaps #<Package CL>,      perhaps #<Package LISP>, or perhaps something implementation-specific.  (SYMBOL-PACKAGE 'LISP:T)  => not specified, not due to this proposal, but because CLtL didn't     specify this explicitly.Rationale:  In practice, some implementations will have very legitimate reasons for   wanting to Lisp dialects to be coresident. As it stands, they will have  little other choice than to make the two use different packages, and so  will be forced to be incompatible with one or the other dialect unless  we choose a different package name for the one dialect for which there  is currently no existing code.  Not only is this important the CLtL and ANSI Common Lisp communities, but  also, if we continue to use the name LISP, it sends a signal to the ISO  Lisp community that the "latest and greatest" Lisp should use the generic  name LISP, and they may try to use it as well. If ISO Lisp turns out to  be very different than ANSI Common Lisp, there may be motivation down the  line for having ISO Lisp and ANSI Common Lisp co-resident, and conflicts  will inevitably arise if both want to use the name LISP. This will almost  certainly lead to a confrontation where one Lisp dialect tries to force  the other out by the artificial means of asserting its right to this  generic name. Choosing a name which compatibly admits the option of  introducing other dialects into the environment at a later date without  conflict is a good way to avoid a class of potential problems.  Although there are a few problems which could come up due to the symbol  package of initial symbols being unspecified, experience with   implementations that do this suggests that they are very few.  Problems occur only in the rare circumstance that all of the following  conditions are met:   - A symbol S on the LISP package but with home package H (that is not "LISP")     is shadowed in some package P of implementation A.   - A program F in package P uses the shadowed symbol H:S by an explicit     LISP: or H: package qualification. (Only the case of using "LISP:" is     interesting, of course, since if H were named explicitly, we would be     outside the bounds of portable code).   - The program F, referring to H:S, is printed out in implementation A      while using package P (or some other package that shadows S, so that     the H package qualifier appears explicitly) and an attempt is made to     re-read it in implementation B.   - Implementation B has no package named H, has a package named H but no     external symbol named S, or has a package named H with external symbol     S but the symbol H:S has different semantics in implementation B than     it did in implementation A.  In practice, this hardly ever happens. It would happen even less if   programmers were explicitly alerted that it was a potential problem they  needed to guard against.Current Practice:  Symbolics Genera already has a package named COMMON-LISP with nicknames  CL and LISP. As such, this would be an incompatible change for Genera.Cost to Implementors:  Small.  In some cases, this may even have `negative cost' because it will provide  implementors a way of avoiding incompatible changes to released operators.Cost to Users:  Small.  In some cases, this may even have `negative cost' because existing code  would be able to continue to run in implementations which chose to support  both CLtL's LISP and ANSI Common Lisp's CL packages, thereby allowing  developers to put off a massover changeover, perhaps doing the transition  more incrementally.Cost of Non-Adoption:  Implementations trying to support multiple dialects in the same environment  would be forced to violate one or the other spec.  Worse, different implementations faced with the same set of hard choices  about which spec to violate in order to concurrently support two dialects  might not make the same choices, leading to even more gratuitous   incompatibility.  ANSI's position in ISO that we are not trying to legislate the meaning of  -the- LISP dialect would be weakened.Benefits:  Needless incompatibility would be avoided in a variety of situations.Aesthetics:  Failing to specify the home package of symbols in the LISP and CL packages  seems unaesthetic because it appears to diminish print/read invertability,  but as observed above, that case is rare.  Failiing to specify a way in which lisp dialects can be co-resident is also  unaesthetic because in practice implementors with a need to do this will do  so whether the standard allows them or not, and it will be a source of   severe divergence among implementations.Discussion:  Symbolics Genera offers two co-resident dialects of Lisp: Zetalisp and  Symbolics Common Lisp. The Symbolics Cloe development environment adds  a third co-resident dialect, making an environment in which two differing  Common Lisp dialects (Symbolics Common Lisp and Cloe) must cooperate.  Already in Cloe it is not possible for the home package to contain   package "LISP" since Cloe's concept of what the "LISP" package is differs  from Genera's concept of what the "LISP" package is, yet they are forced  by efficiency constraints to share the same symbol. It is Pitman's belief,  based on extensive experience with Cloe, that failure to pass this proposal  (or something very like it) will lead to all sorts of trouble for Common  Lisp users and implementors down the road.  Pitman strongly supports this proposal.*start*02231 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 DEC 88 13:51:19 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 22 Dec 88  13:49:53 PSTReceived: by ti.com id AA09673; Thu, 22 Dec 88 15:48:59 CSTReceived: from Kelvin by tilde id AA24814; Thu, 22 Dec 88 15:35:10 CSTMessage-Id: <2807818509-4565574@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Thu, 22 Dec 88 15:35:09 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.Stanford.EDU, X3J13@DSG.csc.ti.comSubject: Re: Issue: LISP-PACKAGE-NAME (Version 1)In-Reply-To: Msg of Thu, 22 Dec 88 14:03 EST from Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>> Proposal (LISP-PACKAGE-NAME:COMMON-LISP):> >   Define that ANSI Common Lisp uses the package name COMMON-LISP, not LISP.>   Define that the COMMON-LISP package has nickname CL.> >   Since some symbols (e.g., T, NIL, and LAMBDA) might have to be shared>   between COMMON-LISP and LISP in implementations simultaneously supporting>   both, clarify that the initial symbols specified by ANSI Common Lisp as>   belonging in the COMMON-LISP package need not have a home package of >   Common-Lisp.I like this.  I wonder, though, if you might want to add that it would bepermissible for implementations to define "LISP" as a nickname for thispackage, for the sake of backwards compatibility in new implementationsthat wouldn't otherwise have a "LISP" package?> Cost to Implementors:> >   Small.> >   In some cases, this may even have `negative cost' because it will provide>   implementors a way of avoiding incompatible changes to released operators.I agree; this approach will make it much easier for us to support thestandard with minimal incompatibility for existing programs.  Trying tosupport Zetalisp and Common Lisp sharing the same LISP package has beenenough of a headache without having to try to support two dialects ofCommon Lisp that way.Now we just need something in the *FEATURES* list to enable easydistinction between standard-conforming and pre-standard implementations.*start*04965 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 DEC 88 16:15:59 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Dec 88  16:14:46 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 511685; 22 Dec 88 19:13:34 ESTDate: Thu, 22 Dec 88 19:13 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: LISP-PACKAGE-NAME (Version 1)To: Gray@DSG.csc.ti.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU, X3J13@DSG.csc.ti.comIn-Reply-To: <2807818509-4565574@Kelvin>Message-ID: <881222191318.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Thu, 22 Dec 88  15:35:09 CST    From: David N Gray <Gray@DSG.csc.ti.com>    > Proposal (LISP-PACKAGE-NAME:COMMON-LISP):    >     >   Define that ANSI Common Lisp uses the package name COMMON-LISP, not LISP.    >   Define that the COMMON-LISP package has nickname CL.    >     >   Since some symbols (e.g., T, NIL, and LAMBDA) might have to be shared    >   between COMMON-LISP and LISP in implementations simultaneously supporting    >   both, clarify that the initial symbols specified by ANSI Common Lisp as    >   belonging in the COMMON-LISP package need not have a home package of     >   Common-Lisp.    I like this.  I wonder, though, if you might want to add that it would be    permissible for implementations to define "LISP" as a nickname for this    package, for the sake of backwards compatibility in new implementations    that wouldn't otherwise have a "LISP" package?Anyone wanting to make LISP a nickname could just as well create a LISPpackage which simply imported the appropriate symbols from the CL package.With only modest additional effort, they could try to make new symbols wherefeasable (especially for most functions) and put borrowed functions ploppedin their function cells. The amount of additional storage is small (comparedto implementing a whole new lisp), but it would leave open the possibility forusers upgrading the level of compatibility without hurting the coresystem. eg, if I wanted APPEND to signal an error on dotted lists, Iwould not consider redefining the system's APPEND for fear of breakingthe world, but if they told me that nothing depended on LISP other thancompatibility code, I might feel ok about redefining (or doingSHADOWING-IMPORT of LISP:APPEND on a per-implementation basis (withappropriate sharp conditionals)) in order to up the level ofcompatibility.In fact, though, my guess is that implementations which are not going todo a serious compatibility effort are better off leaving the packagemissing. My experience has been that customers are often happier growingtheir own compatibility [or getting it from a public library] than beingstuck with something which really doesn't do what they want but whichseals off the place in the namespace which they needed in order to dotheir own thing.For this reason, I think we should discourage or prohibit the placementof a LISP nickname on the CL package.Besides, ANSI CL supersedes CLtL, but ISO Lisp may not. Depending on howit turns out, I could see people considering them siblings rather thanmother/daughter. I really believe the bit about not wanting to lock downthe name LISP for a dialect that may not be the unique favorite.    > Cost to Implementors:    >     >   Small.    >     >   In some cases, this may even have `negative cost' because it will provide    >   implementors a way of avoiding incompatible changes to released operators.    I agree; this approach will make it much easier for us to support the    standard with minimal incompatibility for existing programs.  Trying to    support Zetalisp and Common Lisp sharing the same LISP package has been    enough of a headache without having to try to support two dialects of    Common Lisp that way.    Now we just need something in the *FEATURES* list to enable easy    distinction between standard-conforming and pre-standard implementations.In Cloe, we use a separate readtable for the different dialects, and each dialecthas its own *FEATURES* list. Although this seems like it would be confusing, itworks out pretty well in practice once you've made all the system tools understandit. If we specified that CLtL and ANSI CL could have similar readtables but thatthey must not be EQ (for the sake of #+ and #-), and if we defined that (NOT (EQ 'CL:*FEATURES* 'LISP:*FEATURES*)), then we could indeed have such a feature.If I get a little time (worn out joke), I'll see about see about spinning off anissue to deal with that and see if it flies. I know it's last minute, but I agreewith you that it would really grease the wheels of transition, so hopefully peoplewill find it palatable.*start*09411 00024 US Date: 11 Jan 89 16:52 PSTSender: masinter.paSubject: Issue: LISP-PACKAGE-NAME, (Version 1)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinterline-fold: NoIssue:        LISP-PACKAGE-NAMEReferences:   11.6 Built-in Packages (pp181-182)Category:     CHANGEEdit history: 22-Dec-88, Version 1 by PitmanProblem Description:  Since ANSI Common Lisp will differ from the Common Lisp described by CLtL,  it will not be possible to have support for both in the same Lisp image  if ANSI Common Lisp insists on placing its functionality in the package  named LISP.  Further, use of the name unqualified name LISP by the ANSI Common Lisp  community is inconsistent with ANSI's expressed position to ISO that   the term "LISP" names a language family rather than a specific dialect  within that family.Proposal (LISP-PACKAGE-NAME:COMMON-LISP):  Define that ANSI Common Lisp uses the package name COMMON-LISP, not LISP.  Define that the COMMON-LISP package has nickname CL.  Since some symbols (e.g., T, NIL, and LAMBDA) might have to be shared  between COMMON-LISP and LISP in implementations simultaneously supporting  both, clarify that the initial symbols specified by ANSI Common Lisp as  belonging in the COMMON-LISP package need not have a home package of   Common-Lisp.Test Case:  In an implementation supporting CLtL's LISP package and   the ANSI Common Lisp CL package proposed here:  (EQ 'LISP:T 'CL:T)  => not specified, due to this proposal, but probably T  (EQ 'LISP:CAR 'CL:CAR)  => not specified, due to this proposal, but probably T  (EQ 'LISP:FUNCTIONP 'CL:FUNCTIONP)  => not specified, due to this proposal, but since FUNCTIONP is     changed incompatibly between CLtL (LISP) and CL (ANSI), there     are good reasons why this might return NIL.  (SYMBOL-PACKAGE 'CL:T)  => not specified, due to this proposal. Perhaps #<Package CL>,      perhaps #<Package LISP>, or perhaps something implementation-specific.  (SYMBOL-PACKAGE 'LISP:T)  => not specified, not due to this proposal, but because CLtL didn't     specify this explicitly.Rationale:  In practice, some implementations will have very legitimate reasons for   wanting to Lisp dialects to be coresident. As it stands, they will have  little other choice than to make the two use different packages, and so  will be forced to be incompatible with one or the other dialect unless  we choose a different package name for the one dialect for which there  is currently no existing code.  Not only is this important the CLtL and ANSI Common Lisp communities, but  also, if we continue to use the name LISP, it sends a signal to the ISO  Lisp community that the "latest and greatest" Lisp should use the generic  name LISP, and they may try to use it as well. If ISO Lisp turns out to  be very different than ANSI Common Lisp, there may be motivation down the  line for having ISO Lisp and ANSI Common Lisp co-resident, and conflicts  will inevitably arise if both want to use the name LISP. This will almost  certainly lead to a confrontation where one Lisp dialect tries to force  the other out by the artificial means of asserting its right to this  generic name. Choosing a name which compatibly admits the option of  introducing other dialects into the environment at a later date without  conflict is a good way to avoid a class of potential problems.  Although there are a few problems which could come up due to the symbol  package of initial symbols being unspecified, experience with   implementations that do this suggests that they are very few.  Problems occur only in the rare circumstance that all of the following  conditions are met:   - A symbol S on the LISP package but with home package H (that is not "LISP")     is shadowed in some package P of implementation A.   - A program F in package P uses the shadowed symbol H:S by an explicit     LISP: or H: package qualification. (Only the case of using "LISP:" is     interesting, of course, since if H were named explicitly, we would be     outside the bounds of portable code).   - The program F, referring to H:S, is printed out in implementation A      while using package P (or some other package that shadows S, so that     the H package qualifier appears explicitly) and an attempt is made to     re-read it in implementation B.   - Implementation B has no package named H, has a package named H but no     external symbol named S, or has a package named H with external symbol     S but the symbol H:S has different semantics in implementation B than     it did in implementation A.  In practice, this hardly ever happens. It would happen even less if   programmers were explicitly alerted that it was a potential problem they  needed to guard against.Current Practice:  Symbolics Genera already has a package named COMMON-LISP with nicknames  CL and LISP. As such, this would be an incompatible change for Genera.Cost to Implementors:  Small.  In some cases, this may even have `negative cost' because it will provide  implementors a way of avoiding incompatible changes to released operators.Cost to Users:  Small.  In some cases, this may even have `negative cost' because existing code  would be able to continue to run in implementations which chose to support  both CLtL's LISP and ANSI Common Lisp's CL packages, thereby allowing  developers to put off a massover changeover, perhaps doing the transition  more incrementally.Cost of Non-Adoption:  Implementations trying to support multiple dialects in the same environment  would be forced to violate one or the other spec.  Worse, different implementations faced with the same set of hard choices  about which spec to violate in order to concurrently support two dialects  might not make the same choices, leading to even more gratuitous   incompatibility.  ANSI's position in ISO that we are not trying to legislate the meaning of  -the- LISP dialect would be weakened.Benefits:  Needless incompatibility would be avoided in a variety of situations.Aesthetics:  Failing to specify the home package of symbols in the LISP and CL packages  seems unaesthetic because it appears to diminish print/read invertability,  but as observed above, that case is rare.  Failiing to specify a way in which lisp dialects can be co-resident is also  unaesthetic because in practice implementors with a need to do this will do  so whether the standard allows them or not, and it will be a source of   severe divergence among implementations.Discussion:  Symbolics Genera offers two co-resident dialects of Lisp: Zetalisp and  Symbolics Common Lisp. The Symbolics Cloe development environment adds  a third co-resident dialect, making an environment in which two differing  Common Lisp dialects (Symbolics Common Lisp and Cloe) must cooperate.  Already in Cloe it is not possible for the home package to contain   package "LISP" since Cloe's concept of what the "LISP" package is differs  from Genera's concept of what the "LISP" package is, yet they are forced  by efficiency constraints to share the same symbol. It is Pitman's belief,  based on extensive experience with Cloe, that failure to pass this proposal  (or something very like it) will lead to all sorts of trouble for Common  Lisp users and implementors down the road.  Pitman strongly supports this proposal.Additional comments:Is it permissible for implementations to define"LISP" as a nickname for this package, for thesake of backward compatibility?Anyone wanting to make LISP a nickname could just as well create a LISPpackage which simply imported the appropriate symbols from the CL package.With only modest additional effort, they could try to make new symbols wherefeasable (especially for most functions) and put borrowed functions ploppedin their function cells. The amount of additional storage is small (comparedto implementing a whole new lisp), but it would leave open the possibility forusers upgrading the level of compatibility without hurting the coresystem. eg, if I wanted APPEND to signal an error on dotted lists, Iwould not consider redefining the system's APPEND for fear of breakingthe world, but if they told me that nothing depended on LISP other thancompatibility code, I might feel ok about redefining (or doingSHADOWING-IMPORT of LISP:APPEND on a per-implementation basis (withappropriate sharp conditionals)) in order to up the level ofcompatibility.In fact, though, my guess is that implementations which are not going todo a serious compatibility effort are better off leaving the packagemissing. My experience has been that customers are often happier growingtheir own compatibility [or getting it from a public library] than beingstuck with something which really doesn't do what they want but whichseals off the place in the namespace which they needed in order to dotheir own thing.        TITAN 
         TITAN 
           >              ¡                     &                                          â       *      »                          
~              •              ¥             M             è       
       J             Ú             C             ð      #C "zº*start*09377 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 17:35:44 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  17:03:01 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 11 JAN 89 16:52:58 PSTDate: 11 Jan 89 16:52 PSTSender: masinter.paSubject: Issue: LISP-PACKAGE-NAME, (Version 1)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinter.paline-fold: NoMessage-ID: <890111-165258-11168@Xerox>!Issue:        LISP-PACKAGE-NAMEReferences:   11.6 Built-in Packages (pp181-182)Category:     CHANGEEdit history: 22-Dec-88, Version 1 by PitmanProblem Description:  Since ANSI Common Lisp will differ from the Common Lisp described by CLtL,  it will not be possible to have support for both in the same Lisp image  if ANSI Common Lisp insists on placing its functionality in the package  named LISP.  Further, use of the name unqualified name LISP by the ANSI Common Lisp  community is inconsistent with ANSI's expressed position to ISO that   the term "LISP" names a language family rather than a specific dialect  within that family.Proposal (LISP-PACKAGE-NAME:COMMON-LISP):  Define that ANSI Common Lisp uses the package name COMMON-LISP, not LISP.  Define that the COMMON-LISP package has nickname CL.  Since some symbols (e.g., T, NIL, and LAMBDA) might have to be shared  between COMMON-LISP and LISP in implementations simultaneously supporting  both, clarify that the initial symbols specified by ANSI Common Lisp as  belonging in the COMMON-LISP package need not have a home package of   Common-Lisp.Test Case:  In an implementation supporting CLtL's LISP package and   the ANSI Common Lisp CL package proposed here:  (EQ 'LISP:T 'CL:T)  => not specified, due to this proposal, but probably T  (EQ 'LISP:CAR 'CL:CAR)  => not specified, due to this proposal, but probably T  (EQ 'LISP:FUNCTIONP 'CL:FUNCTIONP)  => not specified, due to this proposal, but since FUNCTIONP is     changed incompatibly between CLtL (LISP) and CL (ANSI), there     are good reasons why this might return NIL.  (SYMBOL-PACKAGE 'CL:T)  => not specified, due to this proposal. Perhaps #<Package CL>,      perhaps #<Package LISP>, or perhaps something implementation-specific.  (SYMBOL-PACKAGE 'LISP:T)  => not specified, not due to this proposal, but because CLtL didn't     specify this explicitly.Rationale:  In practice, some implementations will have very legitimate reasons for   wanting to Lisp dialects to be coresident. As it stands, they will have  little other choice than to make the two use different packages, and so  will be forced to be incompatible with one or the other dialect unless  we choose a different package name for the one dialect for which there  is currently no existing code.  Not only is this important the CLtL and ANSI Common Lisp communities, but  also, if we continue to use the name LISP, it sends a signal to the ISO  Lisp community that the "latest and greatest" Lisp should use the generic  name LISP, and they may try to use it as well. If ISO Lisp turns out to  be very different than ANSI Common Lisp, there may be motivation down the  line for having ISO Lisp and ANSI Common Lisp co-resident, and conflicts  will inevitably arise if both want to use the name LISP. This will almost  certainly lead to a confrontation where one Lisp dialect tries to force  the other out by the artificial means of asserting its right to this  generic name. Choosing a name which compatibly admits the option of  introducing other dialects into the environment at a later date without  conflict is a good way to avoid a class of potential problems.  Although there are a few problems which could come up due to the symbol  package of initial symbols being unspecified, experience with   implementations that do this suggests that they are very few.  Problems occur only in the rare circumstance that all of the following  conditions are met:   - A symbol S on the LISP package but with home package H (that is not "LISP")     is shadowed in some package P of implementation A.   - A program F in package P uses the shadowed symbol H:S by an explicit     LISP: or H: package qualification. (Only the case of using "LISP:" is     interesting, of course, since if H were named explicitly, we would be     outside the bounds of portable code).   - The program F, referring to H:S, is printed out in implementation A      while using package P (or some other package that shadows S, so that     the H package qualifier appears explicitly) and an attempt is made to     re-read it in implementation B.   - Implementation B has no package named H, has a package named H but no     external symbol named S, or has a package named H with external symbol     S but the symbol H:S has different semantics in implementation B than     it did in implementation A.  In practice, this hardly ever happens. It would happen even less if   programmers were explicitly alerted that it was a potential problem they  needed to guard against.Current Practice:  Symbolics Genera already has a package named COMMON-LISP with nicknames  CL and LISP. As such, this would be an incompatible change for Genera.Cost to Implementors:  Small.  In some cases, this may even have `negative cost' because it will provide  implementors a way of avoiding incompatible changes to released operators.Cost to Users:  Small.  In some cases, this may even have `negative cost' because existing code  would be able to continue to run in implementations which chose to support  both CLtL's LISP and ANSI Common Lisp's CL packages, thereby allowing  developers to put off a massover changeover, perhaps doing the transition  more incrementally.Cost of Non-Adoption:  Implementations trying to support multiple dialects in the same environment  would be forced to violate one or the other spec.  Worse, different implementations faced with the same set of hard choices  about which spec to violate in order to concurrently support two dialects  might not make the same choices, leading to even more gratuitous   incompatibility.  ANSI's position in ISO that we are not trying to legislate the meaning of  -the- LISP dialect would be weakened.Benefits:  Needless incompatibility would be avoided in a variety of situations.Aesthetics:  Failing to specify the home package of symbols in the LISP and CL packages  seems unaesthetic because it appears to diminish print/read invertability,  but as observed above, that case is rare.  Failiing to specify a way in which lisp dialects can be co-resident is also  unaesthetic because in practice implementors with a need to do this will do  so whether the standard allows them or not, and it will be a source of   severe divergence among implementations.Discussion:  Symbolics Genera offers two co-resident dialects of Lisp: Zetalisp and  Symbolics Common Lisp. The Symbolics Cloe development environment adds  a third co-resident dialect, making an environment in which two differing  Common Lisp dialects (Symbolics Common Lisp and Cloe) must cooperate.  Already in Cloe it is not possible for the home package to contain   package "LISP" since Cloe's concept of what the "LISP" package is differs  from Genera's concept of what the "LISP" package is, yet they are forced  by efficiency constraints to share the same symbol. It is Pitman's belief,  based on extensive experience with Cloe, that failure to pass this proposal  (or something very like it) will lead to all sorts of trouble for Common  Lisp users and implementors down the road.  Pitman strongly supports this proposal.Additional comments:Is it permissible for implementations to define"LISP" as a nickname for this package, for thesake of backward compatibility?Anyone wanting to make LISP a nickname could just as well create a LISPpackage which simply imported the appropriate symbols from the CL package.With only modest additional effort, they could try to make new symbols wherefeasable (especially for most functions) and put borrowed functions ploppedin their function cells. The amount of additional storage is small (comparedto implementing a whole new lisp), but it would leave open the possibility forusers upgrading the level of compatibility without hurting the coresystem. eg, if I wanted APPEND to signal an error on dotted lists, Iwould not consider redefining the system's APPEND for fear of breakingthe world, but if they told me that nothing depended on LISP other thancompatibility code, I might feel ok about redefining (or doingSHADOWING-IMPORT of LISP:APPEND on a per-implementation basis (withappropriate sharp conditionals)) in order to up the level ofcompatibility.In fact, though, my guess is that implementations which are not going todo a serious compatibility effort are better off leaving the packagemissing. My experience has been that customers are often happier growingtheir own compatibility [or getting it from a public library] than beingstuck with something which really doesn't do what they want but whichseals off the place in the namespace which they needed in order to dotheir own thing.*start*01383 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 JAN 89 18:06:28 PSTReceived: from moon.src.honeywell.com (ALTURA.HONEYWELL.COM) by SAIL.Stanford.EDU with TCP; 27 Jan 89  18:05:03 PSTReturn-Path: <alarson@src.honeywell.com>Received: from pavo.SRC.Honeywell.COM by moon.src.honeywell.com (5.59/smail2.6.3/06-17-88);	Fri, 27 Jan 89 20:03:20 CST id AA07228 for cl-cleanup@sail.stanford.eduPosted-Date: Fri, 27 Jan 89 20:01:47 CSTReceived: by pavo.src.honeywell.com (3.2/SMI-3.2)	id AA03960; Fri, 27 Jan 89 20:01:47 CSTDate: Fri, 27 Jan 89 20:01:47 CSTFrom: alarson@src.honeywell.com (Aaron Larson)Message-Id: <8901280201.AA03960@pavo.src.honeywell.com>To: cl-cleanup@sail.stanford.eduIn-Reply-To: cl-cleanup@sail.stanford.edu's message of 11 Jan 89 16:52 PST <890111-165258-11168@Xerox>Subject: Issue: LISP-PACKAGE-NAME, (Version 1)I have two comments with regard to this proposal; first, it should mentionthe user package (perhaps cl-user), secondly there is a much simpler way toget print/read inconsistency than that described in the proposal, just have*PACKAGE* bound to a package that does not use CL be current when printing.I would feel better requiring CL:SYMBOL-PACKAGE returning the CL packagefor symbols defined in the spec.*start*06071 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 JAN 89 09:03:14 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 30 Jan 89  09:02:59 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 529971; Mon 30-Jan-89 12:00:57 ESTDate: Mon, 30 Jan 89 12:00 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LISP-PACKAGE-NAME, (Version 1)To: alarson@src.honeywell.comcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8901280201.AA03960@pavo.src.honeywell.com>Message-ID: <890130120046.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri, 27 Jan 89 20:01:47 CST    From: alarson@src.honeywell.com (Aaron Larson)    I have two comments with regard to this proposal;    first, it should mention the user package (perhaps cl-user),You're a little vague. I guess you mean it should say that the USER packageis called CL-USER and not USER.I guess I think this is probably the right thing, since there is a contractalready in CLtL that USER should use LISP, and compatibility would be bestbe maintained by making CL-USER, which must use CL, be different.(None of this is compatible for Symbolics systems, of course, since CL is already a nickname for LISP, and CL-USER is already a nickname for USER. But personally think that's a problem we can ultimately dig our way out of.)    secondly there is a much simpler way to get print/read inconsistency than    that described in the proposal, just have *PACKAGE* bound to a package    that does not use CL be current when printing.I agree this is an issue, and should be documented, although in spite of itssimplicity, again I don't think it's a common event. The only time I've everdone it has been in routines where I wanted to expose the home package. Ifwe document that the home package is not something you depend on, then portableprograms will not try to expose the home package, so I think the situationwill continue to be quite rare.    I would feel better requiring CL:SYMBOL-PACKAGE returning the CL package    for symbols defined in the spec.The problem here is that CL:SYMBOL-PACKAGE may fail to be predictive of whatthe printer will do. Supposing that you have a symbol SI:NIL which must bethe false value for Zetalisp, CLtL, and ANSI Common Lisp. If  (ZL:SYMBOL-PACKAGE   'SI:NIL) must return #<Package ZETALISP>  (LISP:SYMBOL-PACKAGE 'SI:NIL) must return #<Package LISP> (CL:SYMBOL-PACKAGE   'SI:NIL) must return #<Package COMMON-LISP>then how will the symbol print? That is, what if I do (ZL:PRINT 'LISP:NIL)or (LISP:PRINT 'CL:NIL)? It looks to me like the possibilities are: 1. You must never share code between lisp dialects.    This would be very sad. Important things can come from an ability to    co-exist, and it's very easy to accidentally constrain things so that    co-existing dialects only really work if you violate one or the other's    spec. 2. You should assume that ZL:PRINT will somehow pass information through    to the symbol printer to say to print ZL:NIL and not CL:NIL or LISP:NIL.    Analogously for CL:PRINT, etc.. Analogously for CL:SYMBOL-PACKAGE, etc.    This would make CL:SYMBOL-PACKAGE and CL:PRINT internally consistent,    at the cost of slowing down PRINT and SYMBOL-PACKAGE. 3. You should assume that ZL:PRINT, CL:PRINT, and LISP:PRINT are really    the same function, and that ZL:SYMBOL-PACKAGE, CL:SYMBOL-PACKAGE, and    LISP:SYMBOL-PACKAGE are really the same function, and that some magic    undocumented internal dynamic switch controls what `language' you are    really in at any given time. This addresses the question of whether     (CL:DEFUN LISP:IDENTITY (ZL:X) ZL:X)    is a CLtL, Zetalisp, or Ansi Common Lisp program by defining that the    answer is context-dependent. Also, this is less complicated than explicit    data flow and still achieves internal consistency, but the dynamic     nature of the switch makes programs hard to prove correct. Binding the    `current language' might affect things you didn't intend to affect, as    is always the problem with dynamic switches. 4. You should assume the home package for initial symbols in package     COMMON-LISP is not reliable, and assure that the binding of *PACKAGE* is    appropriate if you plan to do code interchange between implementations.    For example, (LET ((*PACKAGE* (FIND-PACKAGE "COMMON-LISP"))) (PRINT ...))    will do exactly the right thing for code interchange.I've oversimplified a bunch of things here, but I hope you can get thebasic idea from this presentation. As you can probably see, only option 4seems suitably efficient to me, which is why I proposed it.Keep in mind, too, that in these options we're really only free tochange what ANSI CL does. What Zetalisp and CLtL (and perhaps otherdialects to come, such as ISO) say really must be just taken as fixed.I have to emphasize that I don't make this recommendation lightly. Ihave worked for many years in the Symbolics environment, which must dealusefully with Zetalisp and Common Lisp in the same environment. Also, myLast two years I have been intensely involved in the design of Cloe, athird implementation of Lisp which co-exists in the same environment undera completely different set of restrictions than the other two.In my work with Cloe, I initially tried to make SYMBOL-PACKAGE do asyou suggest and I found it leads to a house of cards which is doomedto eventually topple. My suggestions about what to leave undefined aremotivated out of practical respect for the number of legitimate concernson all sides.Moral: Better for programmers to understand that there are things onwhich they cannot rely and against which they must program defensivelythan for them to believe there are things upon which they can rely andto have that belief turn out to have been a mirage.*start*01409 00024 US Date:  4 Apr 89 12:13 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: LISP-PACKAGE-NAMETo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LISP-PACKAGE-NAMETo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 11:58:12 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:56:22 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571175; Tue 4-Apr-89 14:56:13 EDTOriginal-Date: Tue, 4 Apr 89 14:55 EDTMessage-ID: <890404145549.7.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say... Steele suggested amending this to rename package USER to COMMON-LISP-USER. The amendment was accepted as a friendly amendment. The proposal was passed 12-4. Barry Margolin wanted the package COMMON-LISP-USER to have nickname CL-USER. Amendment accepted (after the original proposal was approved) 11-0-n.The net effect is that this passed with amendment to rename package USER to COMMON-LISP-USER with nickname CL-USER.