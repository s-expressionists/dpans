*start*11203 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 JUN 88 11:16:12 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 24 Jun 88  10:58:26 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 424262; Fri 24-Jun-88 13:58:12 EDTDate: Fri, 24 Jun 88 13:57 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 4)To: CL-Cleanup@SAIL.STANFORD.EDUcc: DICK@WHEATIES.AI.MIT.EDUMessage-ID: <880624135739.7.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Don't panic -- Versions 1-3 were circulated between Dick Waters and myselfand did not reach this list. This is the first version CL-Cleanup shouldhave seen.Also, please be sure to cc Dick@WHEATIES.AI.MIT.EDU in any correspondenceon this issue since he's not on CL-Cleanup. -kmp----------Issue:        STREAM-INFOReferences:   FORMAT ~T (pp398-9) and ~<...~> (pp404-6), PPRINT (p383)Category:     ADDITIONEdit history: 22-Jun-88, Version 1 by Pitman (2d model)	      23-Jun-88, Version 2 by Waters (1d model, modified 2d model)	      24-Jun-88, Version 3 by Pitman (minor reformatting)	      24-Jun-88, Version 4 by Pitman (remove 2d model for submission)Status:	      For Internal DiscussionProblem Description:  Currently, there is no portable way to inquire about the line width  of an output stream, the current character position on a line  or the amount of space that the display of a string will take up.  This makes it essentially impossible to write a portable  implementation of a pretty printer.Proposal (STREAM-INFO: ONE-DIMENSIONAL-FUNCTIONS):  Introduce four new functions:   OUTPUT-WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)       [Function]    Returns the maximum line width that can be printed on the    OUTPUT-STREAM without causing truncation or wraparound.  The    result is returned as a non-negative integer, or NIL if the stream    has no meaningful width (or the width cannot be computed).  The    unit of width is arbitrary, however, given a particular output    stream, the unit must have some fixed value.   OUTPUT-POSITION &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)    [Function]    Returns the current horizontal position of the cursor on the given    OUTPUT-STREAM as a non-negative integer, or NIL if it cannot be    computed.  (The position is the position of the distance of the    left edge of the cursor from the left margin.  I.e., 0 means    cursor is at the left end of a line.)  The units are arbitrary,    but for a given stream, they must be the same as the units used by    OUTPUT-WIDTH.   STRING-WIDTH STRING &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)		       &key (START 0) (END NIL) 		  [Function]    The START and END parameters delimit a substring of string in the    usual manner.  STRING-WIDTH returns the change in output position    that would occur if STRING were written to OUTPUT-STREAM using    (WRITE-STRING STRING OUTPUT-STREAM :start START :end END) given    the current state of OUTPUT-STREAM or NIL if the change cannot be    computed.  The returned value is an integer.  The units are    arbitrary, but for a given stream, they must be the same as the    units used by OUTPUT-WIDTH.  STRING-WIDTH satisfies the following    constraint.    (LET* ((STREAM ...)           (STRING ...)           (CURRENT-X (OUTPUT-POSITION STREAM)))      (= (STRING-WIDTH STRING STREAM)         (- (PROGN (WRITE-STRING STRING STREAM)                    (OUTPUT-POSITION STREAM))            CURRENT-X)))    STRING-WIDTH does not return any indication of the vertical    distance required when printing string.  Merely the difference in    horizontal position before and after printing.  This difference    may be negative (e.g., if STRING contains backspace or newline    characters.)  It is possible that the width of a string will    depend on the horizontal position where output begins (e.g., if    the string contains tab characters.)  If this is the case, the    width returned assumes that the output occurs starting at the    current horizontal position in the stream.  Similarly, the width    of string may depend on other aspects of the state of    OUTPUT-STREAM (e.g., the font being used).  In all respects the    width is computed based on the current state of the stream.    STRING-WIDTH never causes any change in the state of OUTPUT-STREAM.   OUTPUT-SPACE WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*) [function]    This function causes blank space to be inserted in OUTPUT-STREAM    so that the output position is increased by WIDTH.  WIDTH is an    integer.  The units are arbitrary, but for a given stream, they    must be the same as the units used by OUTPUT-WIDTH.  A negative    WIDTH parameter indicates backspacing.  The unit of WIDTH should    be chosen so that it is possible to move the output position left    and right by a single unit.  OUTPUT-SPACE satisfies the following    constraint.    (LET* ((STREAM ...)           (N ...))      (= (+ (OUTPUT-POSITION STREAM) N)         (PROGN (OUTPUT-SPACE N STREAM)                (OUTPUT-POSITION STREAM))))    OUTPUT-SPACE returns T if the spacing operation has been achieved    and NIL otherwise (e.g., if the requested spacing would move off    of the end of the line or if the the operation cannot be supported    for the given stream.)   A key motivation behind the functions above is dealing with   output streams that support variable length fonts.  The unit of   width is allowed to vary from stream to stream in order to allow   for differences between output devices.  The only thing that   matters is that the four functions above operate on the same units   when given the same stream.   If an output stream only supports a single fixed width font, the   logical choice of width unit is the length of a single character.   In this situation (and ignoring characters such as tab, newline,   and other control characters that do not have an output width of   one) the functions above have the following simple meanings.   OUTPUT-WIDTH returns the maximum number of characters which can be   printed on a single line.  OUTPUT-POSITION returns the number of   characters which have already been printed on the current line.   STRING-LENGTH returns the number of characters in the string.   OUTPUT-SPACE prints the specified number of space, or backspace,   characters.   Another key feature of the functions above is that they are all   permitted to return NIL without performing any action.  This is to   allow for the fact that the required operations might not be   supported for every kind of stream.  However, it is hoped that the   functions would in fact be supported for most kinds of streams.Test Case:  Suppose that S is an output stream that supports a single fixed  width font which can display 72 characters on a line and that the  associated width unit is the width of one character.  Evaluating the  following will produce the results shown.  (output-width S) => 72  (terpri S)  (output-position S) => 0  (string-width "testing: " S) => 9  (write-string "testing: " S)  (output-position S) => 9  (write-string "foo" S)  (terpri S)  (output-space 9 S) => T  (write-string "bar" S)  The output produced istesting: foo	 barRationale:  Pretty printing requires the function OUTPUT-WIDTH in order to know  how wide the output it produces can be.  Pretty printing requires  OUTPUT-POSITION in order to determine where on the line output is  when pretty printing starts.  Pretty printing requires STRING-WIDTH  in order to determine how much space things will take in the output.  (If a variable width font is being used, this cannot be determined  without a detailed knowledge of the font being used.)  Pretty  printing requires OUTPUT-SPACE in order to get proper indentations.  (If a variable width font is being used, indentations may be  required that cannot be obtained by outputting spaces.)Current Practice:  Essentially every implementation of Common Lisp must support the  functionality above internally in order to support PPRINT and the  FORMAT directives ~T and ~<...~>.  However, there is no documented  interface to this functionality in CLTL.  As a result, while some  implementations of Common Lisp make this functionality available to  users, some do not.  Further, the implementations that do provide  this functionality do so in a variety of incompatible ways.Cost to Implementors:  This proposal is written in such a way as to allow implementations which  do not have the ability to compute difficult values to just return NIL.  Very little work is forced. The idea is to offer implementors a common way  to provide this useful information to portable programs where possible.  Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Complex output programs such as pretty printers cannot be written portably.Benefits:  A wide range of programs can gain better control of the format of output.Aesthetics:  No significant aesthetic impact other than a slight increase in the  number of functions defined.Discussion:  Dick Waters submitted a request for changes along the line of the  horizontal aspects of these functions in a letter to X3J13 dated  June 14, 1988.  Pitman and Waters wrote up the request formally.  STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS is the minimum which is  required in order to support pretty printing into a stream which  displays output using a variable width font.  We drafted an alternate proposal, STREAM-INFO:TWO-DIMENSIONAL-FUNCTIONS,  which goes significantly beyond what is needed merely for pretty printing  and provides primitives OUTPUT-DIMENSIONS, OUTPUT-POSITION,  STRING-DIMENSIONS, and OUTPUT-SPACE but it is not included here.  A key point of contention which would be likely to swamp the 2d proposal  is the age old question of how to handle the issue of vertical distance  (where is the origin, which way do you count, ...). If anyone would  prefer to see larger problem 2d proposal, it could be circulated, but at  the last minute Pitman got worried that even the 1d version was going to  be controversial enough and decided to keep things focused on that.  For his own needs, Waters is strongly interested in having either  ONE-DIMENSIONAL-FUNCTIONS or TWO-DIMENSIONAL-FUNCTIONS proposal accepted,  but does not care which. Pitman concurs.  One variation of the 1d proposal might be useful to consider:   STRING-WIDTH could return two additional values: the number of newlines    that WRITE-STRING of the string would execute and the maximum X position    encountered (which might differ from the first value if the number of    newlines was non-zero).  This feature wasn't necessary for Waters' minimalist proposal, but Pitman  would be willing to write it in here if people thought it would be useful  enough for other purposes.*start*11203 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 JUN 88 11:16:12 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 24 Jun 88  10:58:26 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 424262; Fri 24-Jun-88 13:58:12 EDTDate: Fri, 24 Jun 88 13:57 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 4)To: CL-Cleanup@SAIL.STANFORD.EDUcc: DICK@WHEATIES.AI.MIT.EDUMessage-ID: <880624135739.7.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Don't panic -- Versions 1-3 were circulated between Dick Waters and myselfand did not reach this list. This is the first version CL-Cleanup shouldhave seen.Also, please be sure to cc Dick@WHEATIES.AI.MIT.EDU in any correspondenceon this issue since he's not on CL-Cleanup. -kmp----------Issue:        STREAM-INFOReferences:   FORMAT ~T (pp398-9) and ~<...~> (pp404-6), PPRINT (p383)Category:     ADDITIONEdit history: 22-Jun-88, Version 1 by Pitman (2d model)	      23-Jun-88, Version 2 by Waters (1d model, modified 2d model)	      24-Jun-88, Version 3 by Pitman (minor reformatting)	      24-Jun-88, Version 4 by Pitman (remove 2d model for submission)Status:	      For Internal DiscussionProblem Description:  Currently, there is no portable way to inquire about the line width  of an output stream, the current character position on a line  or the amount of space that the display of a string will take up.  This makes it essentially impossible to write a portable  implementation of a pretty printer.Proposal (STREAM-INFO: ONE-DIMENSIONAL-FUNCTIONS):  Introduce four new functions:   OUTPUT-WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)       [Function]    Returns the maximum line width that can be printed on the    OUTPUT-STREAM without causing truncation or wraparound.  The    result is returned as a non-negative integer, or NIL if the stream    has no meaningful width (or the width cannot be computed).  The    unit of width is arbitrary, however, given a particular output    stream, the unit must have some fixed value.   OUTPUT-POSITION &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)    [Function]    Returns the current horizontal position of the cursor on the given    OUTPUT-STREAM as a non-negative integer, or NIL if it cannot be    computed.  (The position is the position of the distance of the    left edge of the cursor from the left margin.  I.e., 0 means    cursor is at the left end of a line.)  The units are arbitrary,    but for a given stream, they must be the same as the units used by    OUTPUT-WIDTH.   STRING-WIDTH STRING &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)		       &key (START 0) (END NIL) 		  [Function]    The START and END parameters delimit a substring of string in the    usual manner.  STRING-WIDTH returns the change in output position    that would occur if STRING were written to OUTPUT-STREAM using    (WRITE-STRING STRING OUTPUT-STREAM :start START :end END) given    the current state of OUTPUT-STREAM or NIL if the change cannot be    computed.  The returned value is an integer.  The units are    arbitrary, but for a given stream, they must be the same as the    units used by OUTPUT-WIDTH.  STRING-WIDTH satisfies the following    constraint.    (LET* ((STREAM ...)           (STRING ...)           (CURRENT-X (OUTPUT-POSITION STREAM)))      (= (STRING-WIDTH STRING STREAM)         (- (PROGN (WRITE-STRING STRING STREAM)                    (OUTPUT-POSITION STREAM))            CURRENT-X)))    STRING-WIDTH does not return any indication of the vertical    distance required when printing string.  Merely the difference in    horizontal position before and after printing.  This difference    may be negative (e.g., if STRING contains backspace or newline    characters.)  It is possible that the width of a string will    depend on the horizontal position where output begins (e.g., if    the string contains tab characters.)  If this is the case, the    width returned assumes that the output occurs starting at the    current horizontal position in the stream.  Similarly, the width    of string may depend on other aspects of the state of    OUTPUT-STREAM (e.g., the font being used).  In all respects the    width is computed based on the current state of the stream.    STRING-WIDTH never causes any change in the state of OUTPUT-STREAM.   OUTPUT-SPACE WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*) [function]    This function causes blank space to be inserted in OUTPUT-STREAM    so that the output position is increased by WIDTH.  WIDTH is an    integer.  The units are arbitrary, but for a given stream, they    must be the same as the units used by OUTPUT-WIDTH.  A negative    WIDTH parameter indicates backspacing.  The unit of WIDTH should    be chosen so that it is possible to move the output position left    and right by a single unit.  OUTPUT-SPACE satisfies the following    constraint.    (LET* ((STREAM ...)           (N ...))      (= (+ (OUTPUT-POSITION STREAM) N)         (PROGN (OUTPUT-SPACE N STREAM)                (OUTPUT-POSITION STREAM))))    OUTPUT-SPACE returns T if the spacing operation has been achieved    and NIL otherwise (e.g., if the requested spacing would move off    of the end of the line or if the the operation cannot be supported    for the given stream.)   A key motivation behind the functions above is dealing with   output streams that support variable length fonts.  The unit of   width is allowed to vary from stream to stream in order to allow   for differences between output devices.  The only thing that   matters is that the four functions above operate on the same units   when given the same stream.   If an output stream only supports a single fixed width font, the   logical choice of width unit is the length of a single character.   In this situation (and ignoring characters such as tab, newline,   and other control characters that do not have an output width of   one) the functions above have the following simple meanings.   OUTPUT-WIDTH returns the maximum number of characters which can be   printed on a single line.  OUTPUT-POSITION returns the number of   characters which have already been printed on the current line.   STRING-LENGTH returns the number of characters in the string.   OUTPUT-SPACE prints the specified number of space, or backspace,   characters.   Another key feature of the functions above is that they are all   permitted to return NIL without performing any action.  This is to   allow for the fact that the required operations might not be   supported for every kind of stream.  However, it is hoped that the   functions would in fact be supported for most kinds of streams.Test Case:  Suppose that S is an output stream that supports a single fixed  width font which can display 72 characters on a line and that the  associated width unit is the width of one character.  Evaluating the  following will produce the results shown.  (output-width S) => 72  (terpri S)  (output-position S) => 0  (string-width "testing: " S) => 9  (write-string "testing: " S)  (output-position S) => 9  (write-string "foo" S)  (terpri S)  (output-space 9 S) => T  (write-string "bar" S)  The output produced istesting: foo	 barRationale:  Pretty printing requires the function OUTPUT-WIDTH in order to know  how wide the output it produces can be.  Pretty printing requires  OUTPUT-POSITION in order to determine where on the line output is  when pretty printing starts.  Pretty printing requires STRING-WIDTH  in order to determine how much space things will take in the output.  (If a variable width font is being used, this cannot be determined  without a detailed knowledge of the font being used.)  Pretty  printing requires OUTPUT-SPACE in order to get proper indentations.  (If a variable width font is being used, indentations may be  required that cannot be obtained by outputting spaces.)Current Practice:  Essentially every implementation of Common Lisp must support the  functionality above internally in order to support PPRINT and the  FORMAT directives ~T and ~<...~>.  However, there is no documented  interface to this functionality in CLTL.  As a result, while some  implementations of Common Lisp make this functionality available to  users, some do not.  Further, the implementations that do provide  this functionality do so in a variety of incompatible ways.Cost to Implementors:  This proposal is written in such a way as to allow implementations which  do not have the ability to compute difficult values to just return NIL.  Very little work is forced. The idea is to offer implementors a common way  to provide this useful information to portable programs where possible.  Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Complex output programs such as pretty printers cannot be written portably.Benefits:  A wide range of programs can gain better control of the format of output.Aesthetics:  No significant aesthetic impact other than a slight increase in the  number of functions defined.Discussion:  Dick Waters submitted a request for changes along the line of the  horizontal aspects of these functions in a letter to X3J13 dated  June 14, 1988.  Pitman and Waters wrote up the request formally.  STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS is the minimum which is  required in order to support pretty printing into a stream which  displays output using a variable width font.  We drafted an alternate proposal, STREAM-INFO:TWO-DIMENSIONAL-FUNCTIONS,  which goes significantly beyond what is needed merely for pretty printing  and provides primitives OUTPUT-DIMENSIONS, OUTPUT-POSITION,  STRING-DIMENSIONS, and OUTPUT-SPACE but it is not included here.  A key point of contention which would be likely to swamp the 2d proposal  is the age old question of how to handle the issue of vertical distance  (where is the origin, which way do you count, ...). If anyone would  prefer to see larger problem 2d proposal, it could be circulated, but at  the last minute Pitman got worried that even the 1d version was going to  be controversial enough and decided to keep things focused on that.  For his own needs, Waters is strongly interested in having either  ONE-DIMENSIONAL-FUNCTIONS or TWO-DIMENSIONAL-FUNCTIONS proposal accepted,  but does not care which. Pitman concurs.  One variation of the 1d proposal might be useful to consider:   STRING-WIDTH could return two additional values: the number of newlines    that WRITE-STRING of the string would execute and the maximum X position    encountered (which might differ from the first value if the number of    newlines was non-zero).  This feature wasn't necessary for Waters' minimalist proposal, but Pitman  would be willing to write it in here if people thought it would be useful  enough for other purposes.*start*01142 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 JUN 88 11:54:44 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 24 Jun 88  11:49:38 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 24 JUN 88 11:42:59 PDTDate: 23 Jun 88 00:53 PDTFrom: Masinter.paSubject: Re: Issue: STREAM-INFO (Version 4)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 24 Jun 88 13:57 EDTTo: KMP@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDU, DICK@WHEATIES.AI.MIT.EDUMessage-ID: <880624-114259-5815@Xerox>"Returns the current horizontal position of the cursor..."The word "cursor" is unfortunately overused and not defined here or elsewhere inCLtL. What is 	(with-output-to-string (x ) (princ "a test") (output-position x))?Is it implementation dependent?What is (output-position *terminal-io*)? What is the relation between(output-position (make-broadcast-stream a b)) and (output-position a) and(output-position b)?I'm sure I can think of more questions given time...*start*00934 00024 US Date: 24 Jun 88 12:17 PDTFrom: Masinter.paSubject: Re: Issue: STREAM-INFO (Version 4)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 24 Jun 88 15:08 EDTTo: KMP@STONY-BROOK.SCRC.Symbolics.COMcc: Masinter.PA, CL-Cleanup@SAIL.Stanford.EDU, Dick@WHEATIES.AI.MIT.EDUWhile relying on implementation-specific heuristics for implementation-specific streams seems right to me, it seems less clear for streams that are created using otherwise portable mechanisms. For example, we could define that for string streams created , the line width is the value of *string-stream-width* (and encapsulated in the stream), where NIL means infinite,  and that the unit of width is 1 and that every character takes exactly 1 character, that two-way-streams and echo-streams inherit the position and width of their output streams, that broadcast streams inherit from their first component. *start*00915 00024 US From: masinter.paDate: 29-Jun-88 23:32:43 PDTSubject: Re: Issue: STREAM-INFO (Version 4)In-reply-to: KMP@STONY-BROOK.SCRC.Symbolics.COM's message of Mon, 27 Jun 88 10:48 EDT, <880627104822.3.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter, CL-Cleanup@SAIL.Stanford.EDU, Dick@WHEATIES.AI.MIT.EDUHow 'bout just making it explicit that this things are intentionally left undefined, with some of the reasons you gave?I'm a little leary of adding a function where the requirements on the output values are not spelled out. Is the width of "froboznick" guaranteed to be the sum of the widths of "frob" and "oznick"? Greater than the width of "frob"? Of "foo"? What about kerning?If we can't guarantee anything about these functions, can programmers really write portable programs? Or would a hack with #+ and #- be more honest?*start*05161 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 30 JUN 88 07:34:41 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 427060; Thu 30-Jun-88 10:34:33 EDTDate: Thu, 30 Jun 88 10:34 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: STREAM-INFO (Version 4)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU, Dick@WHEATIES.AI.MIT.EDUIn-Reply-To: <880629-233315-4002@Xerox>Message-ID: <880630103421.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 29 Jun 88 23:32:43 PDT    From: masinter.pa@Xerox.COM    How 'bout just making it explicit that this things are intentionally left    undefined, with some of the reasons you gave?    I'm a little leary of adding a function where the requirements on the output    values are not spelled out. Is the width of "froboznick" guaranteed to be the    sum of the widths of "frob" and "oznick"? Greater than the width of "frob"? Of    "foo"? What about kerning?Dick spelled out the requirement. He doesn't need an algebra on these values.The only need he has, and it's quite legitimate, is to ask "If I were to outputthis, where would I end up." If there's something that will, in the same units,tell him where the margin is, he can at least know if he's passing an interestingboundary.Kerning is not really relevant. Either the implementation looks at kerning whendeciding if a line is too long or it doesn't. The thing which returns the marginposition and the thing which returns the string width can easily conspire to dothe right thing without prejudice to whether kerning is involved.Dick could have just as well asked for a primitive that would have said(OUTPUT-FITS-P string stream) and returns T or NIL saying whether the string willfit on the stream without running into the margin, but that would have been solimited to his application that it would have served no useful extension purposesin implementations that did want to extend it.    If we can't guarantee anything about these functions, can programmers really    write portable programs? Or would a hack with #+ and #- be more honest?The issue is not honesty. The issue is one of codifying existingpractice. Dick Waters has done a lot of really interesting work onpretty printers over the years. That work has been of tremendous benefitto the Lisp community.  In Maclisp, he could essentially tell where theend of the line was. We took away that capability in Common Lisp.  InCommon Lisp, you can't even clear the screen. I personally think thatwas ridulous, and I'm surprised that the user community put up with it.But the world was more complicated with fancy displays and fancy fontsand all, and people were tolerant for a while.But we've had our time to play and it's really time we came up withsomething useful so people can get on with their work if at allpossible.  The set of primitives proposed is a subset of what is in useon a major Lisp workstation and it has been demonstrated to be useful.If it has problems to do with kerning (things have to be rounded off),output will look no stupider than it will look if we don't allow peopleto have pretty printed output at all. More likely, it will work justfine because most applications are very fault tolerant -- in the worstcase, you might get some line wraparound and yucky looking typeout. Butyou'll get line wraparound a LOT more in portable programs if you offerpeople no way at all to detect the edge of the line.  We should just warnpeople that the process is heuristic and people who are building weaponssystems or real time medical systems can avoid using it.Common Lisp is not an exercise in doing everything right the first time.It is an exercise in trying to satisfy the commercial needs of a lot ofLisp users for the next few years. My condition system has its problems,too, but the important point in both cases is that it is an improvementover what is there if you don't have it. Sometimes when you don't fullyunderstand an issue, you just have to go with your best guess and beprepared to have problems result.  As embarrassing as it is to have yourmistakes noticed later, it's sometimes better than not taking any actionat all.  And after using for a few years, you'll have a user communitywho can make informed decisions about whether they like what they gotand what they want next.  If you don't offer them anything at all, thenin five more years you'll have no one who's any more informed on theissues than you have now and you'll end up having to make the samearbitrary decision as you're making now.Also, this problem is not like characters or pathnames where we areforcing a representation. If necessary, a particular vendor with specialneeds can have these primitives can work completely independently of howthe rest of system represents width, position, etc.  on the screen -- orit can just return NIL all over the place saying it's not willing toplay the game.*start*04192 00024 US Return-Path: <dick@wheaties.ai.mit.edu>Received: from rice-chex.ai.mit.edu ([128.52.38.46]) by Xerox.COM ; 30 JUN 88 11:44:38 PDTReceived: by rice-chex.ai.mit.edu; Thu, 30 Jun 88 14:47:06 EDTDate: Thu, 30 Jun 88 14:47:06 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8806301847.AA07038@rice-chex.ai.mit.edu>To: masinter.paIn-Reply-To: masinter.pa@xerox.com's message of 29 Jun 88 23:32:43 PDT <880629-233315-4002@Xerox>Subject: Issue: STREAM-INFO (Version 4)Cc: dick@wheaties.ai.mit.edu, CL-Cleanup@sail.stanford.edu  How 'bout just making it explicit that these things are intentionally left  undefined, with some of the reasons you gave?  I'm a little leary of adding a function where the requirements on  the output values are not spelled out. Is the width of "froboznick"  guaranteed to be the sum of the widths of "frob" and "oznick"?  Greater than the width of "frob"? Of "foo"? What about kerning?I think that there are some very specific things that we can say.  Thekey thing is that we have to make it clear exactly what is beingspecified.  In particular, the actual numerical values areimplementation specific and do not matter much.  However, there areseveral key RELATIVE properties which are the whole point.In the following, suppose that N is a positive integer, X and Y arestrings, and S is a stream that fully supports all four functionsOUTPUT-WIDTH, OUTPUT-POSITION, STRING-WIDTH, OUTPUT-SPACE; i.e., NIL isnever returned when any of these functions is called on S.First, there are three minimal properties of OUTPUT-POSITION.(1) (NOT (MINUSP (OUTPUT-POSITION S)))(2) (ZEROP (OUTPUT-POSITION (PROGN (TERPRI S) S)))(3) If something is at an output position of N on one line, andsomething else is at an output position of N on another line, andassuming that wraparound truncation etc. have not occured on eitherline (see (5) below), then the two things are lined up vertically oneunder the other.Second, there are two properties that defineSTRING-WIDTH and OUTPUT-SPACE in terms of OUTPUT-POSITION.(3) (= (+ (OUTPUT-POSITION S) (STRING-WIDTH X S))       (OUTPUT-POSITION (PROGN (WRITE-STRING X S) S)))(4) (= (+ (OUTPUT-POSITION S) N)       (OUTPUT-POSITION (PROGN (OUTPUT-SPACE N S) S)))and OUTPUT-SPACE has no effect on S other than introducing blank spacethat changes the output position.For the following properties it must be assumed that X and Y consistsolely of standard characters as defined on CLTL pp20-21 and that Xand Y do not contain any #\newline characters.The following property defines the meaning of OUTPUT-WIDTH.(5) Assuming that one has just done (TERPRI S),If (< (STRING-WIDTH X S) (OUTPUT-WIDTH S))then (WRITE-STRING X S) is guaranteed to output the string on one linewithout any truncation or wraparound.  [If the condition above is not satisfied, then the exact result ofthe output is not specified.  However, It is assumed that eachimplementation will do something reasonable, e.g., use wraparound.  Itmight also be the case that the output width was pessimistic and thatthe string might fit on the end of the line.  The point ofOUTPUT-WIDTH is that it returns a guaranteed safe width.]  This property must hold no matter what characters are in X as longas none of these characters cause a reduction in output position.I.e., it is alright for X to contain tabs and many other weirdcharacters, but the property may be violated if X contains newlines orbackspaces.(6) (= (STRING-WIDTH (CONCATENATE 'STRING X Y) S)       (+ (STRING-WIDTH X S) (STRING-WIDTH Y S)))  This property is violated for many kinds of nonstandard characters,notably tabs and newlines.  It could also fail if the strings hadligatures or font change characters or other wierd things.Nevertheless, this property is very useful.  The efficiency of mypretty printer is significantly improved by assuming that thisproperty holds.			Dick WatersPS  I agree with KMPs basic comment that although this is indeed afuzzy area, it is better to get information which may in manysituations only be approximate than not to be able to get anyinformation at all.*start*00676 00024 US From: masinter.paDate: 30-Jun-88 15:56:48 PDTSubject: Re: Issue: STREAM-INFO (Version 4)In-reply-to: KMP@STONY-BROOK.SCRC.Symbolics.COM's message of Thu, 30 Jun 88 10:34 EDT, <880630103421.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter, CL-Cleanup@SAIL.Stanford.EDU, Dick@WHEATIES.AI.MIT.EDUI guess I wasn't clear. I understand your point, and see that it is probably not a good idea to be more explicit about what the functions you propose should do. However, I think the proposal needs to be really explicit that there are no such contracts, lest users mistakenly assume there are.*start*01146 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 01 JUL 88 07:02:40 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 1 Jul 88  07:01:11 PDTReturn-Path: <gls@Think.COM>Received: from brigit.think.com by Think.COM; Fri, 1 Jul 88 10:00:24 EDTReceived: by brigit.think.com; Fri, 1 Jul 88 09:59:34 EDTDate: Fri, 1 Jul 88 09:59:34 EDTFrom: gls@Think.COMMessage-Id: <8807011359.AA10552@brigit.think.com>To: dick@wheaties.ai.mit.eduCc: masinter.pa, dick@wheaties.ai.mit.edu, CL-Cleanup@sail.stanford.eduIn-Reply-To: Richard C. Waters's message of Thu, 30 Jun 88 14:47:06 EDT <8806301847.AA07038@rice-chex.ai.mit.edu>Subject: Issue: STREAM-INFO (Version 4)Dick,  Does your pretty printer depend crucially on the equality inproperties (3) and (6), or can they be relaxed to inequalities   (3) (<= (+ (OUTPUT-POSITION S) (STRING-WIDTH X S))	   (OUTPUT-POSITION (PROGN (WRITE-STRING X S) S)))   (6) (<= (STRING-WIDTH (CONCATENATE 'STRING X Y) S)	   (+ (STRING-WIDTH X S) (STRING-WIDTH Y S)))?--Guy*start*03542 00024 USaReturn-Path: <dick@wheaties.ai.mit.edu>Received: from rice-chex.ai.mit.edu ([128.52.38.46]) by Xerox.COM ; 05 JUL 88 08:54:20 PDTReceived: by rice-chex.ai.mit.edu; Tue, 5 Jul 88 11:55:44 EDTDate: Tue, 5 Jul 88 11:55:44 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8807051555.AA03348@rice-chex.ai.mit.edu>To: gls@think.comCc: masinter.pa, CL-Cleanup@sail.stanford.eduIn-Reply-To: gls@think.com's message of Fri, 1 Jul 88 09:59:34 EDT <8807011359.AA10552@brigit.think.com>Subject: Issue: STREAM-INFO (Version 4)      Does your pretty printer depend crucially on the equality in    properties (3) and (6), or can they be relaxed to inequalities       (3) (<= (+ (OUTPUT-POSITION S) (STRING-WIDTH X S))	       (OUTPUT-POSITION (PROGN (WRITE-STRING X S) S)))Several points here;  First, the pretty printer does crucially dependon the fact that if there is any significant inequality, then it must gothe other way.  I.e. (=> (+ (OUTPUT-POSITION S) (STRING-WIDTH X S))     (OUTPUT-POSITION (PROGN (WRITE-STRING X S) S)))The pretty printer has to be able to make a guaranteed pesimisticprediction of what the output position will be without actuallyprinting anything.  If the inequality went the way you suggest, Icould not be sure that printing the string would not go off of the endof a line.  Second, having it be an equality is not TOTALLY crucial, but withoutit, I would have to query the stream for the resulting output positionevery time I sent a string to it.  With the equality, the streamalmost never has to be queried---A significant saving in time.  Third, it is true however, that it is not going to make anydifference to the pretty printer if the equality is off slightly.  Themost aesthetic way for an implementation to deal with this case is tomake the horizontal unit returned by the functions course rather than fine.  Fourth, if there is a fear that the property above would make it toohard to implement STRING-WIDTH, then one might only require that theproperty hold if the string contains standard characters, and allowimplementations to vary as to how close they come to the ideal ingeneral.  (Note that with this weak a restriction, and assuming afixed width font, the function STRING-WIDTH could be implementedmerely as LENGTH.  This is the way the pretty printer works now, andit doesn't seem to be causing any problems.)  Fifth, the bottom line here is that pretty printing will work betteror worse based on how accurately STRING-WIDTH is implemented.However, there is nothing for the pretty printer to do, but simplyassume that the information is accurate.       (6) (<= (STRING-WIDTH (CONCATENATE 'STRING X Y) S)	       (+ (STRING-WIDTH X S) (STRING-WIDTH Y S)))Here, the comments are much the same.  First, this time the inequality as stated is in the proper direction.  Second, having the inequality is not totally crucial, but itsignificantly reduces the number of times OUTPUT-POSITION and/orSTRING-LENGTH have to be called.  Third, it is not going to make any difference to the pretty printerif the equality is off slightly.  Fourth, note that the equality is only required when the stringcontains standard characters.  If a fixed width font is in use, thisis consistent with implementing STRING-WIDTH as length.I strongly suggest supporting both of the above as eqaulities at leastfor standard characters.  Since in the fixed width font case this istrivial to do, I see no argument against it.			Dick*start*01592 00024 USaReturn-Path: <@STONY-BROOK.SCRC.Symbolics.COM,@RIO-DE-JANEIRO.SCRC.Symbolics.COM:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 24 JUN 88 12:08:39 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 424326; 24 Jun 88 15:08:21 EDTDate: Fri, 24 Jun 88 15:08 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: STREAM-INFO (Version 4)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDU, Dick@WHEATIES.AI.MIT.EDUIn-Reply-To: <880624-114259-5815@Xerox>Message-ID: <880624150813.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>We'll see if we can add enough description of a cursor to makethe proposal more clear.It's good to have the hard issues listed out, and they should probably bein the discussion section, but since you're permitted to return NIL on anycase you think is too hard, I hope the proposal doesn't get stalled on that.The important point here is that many implementations -do- have a theoryof where the cursor is in some or all of those situations, and if theimplementation has a theory, Dick just wants to be able to access that info.The idea isn't to make more work for implementors -- only to make a commoninterface to this facility where it does exist. As it is, you have touse a lot of #+ and #- stuff to deal with this -- and every time a newimplementation comes along, it has to decide which existing implementationto use as a pattern or whether to make up its own protocol.*start*02754 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 27 JUN 88 07:53:08 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 425042; Mon 27-Jun-88 10:48:33 EDTDate: Mon, 27 Jun 88 10:48 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: STREAM-INFO (Version 4)To: Masinter.pacc: CL-Cleanup@SAIL.Stanford.EDU, Dick@WHEATIES.AI.MIT.EDUIn-Reply-To: <880624-121812-5897@Xerox>Message-ID: <880627104822.3.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 24 Jun 88 12:17 PDT    From: Masinter.pa@Xerox.COM    While relying on implementation-specific heuristics for implementation-specific    streams seems right to me, it seems less clear for streams that are created    using otherwise portable mechanisms. For example, we could define that for    string streams created , the line width is the value of *string-stream-width*    (and encapsulated in the stream), where NIL means infinite,  and that the unit    of width is 1 and that every character takes exactly 1 character, This might be useful. It should be clear that you mean string streams createdby a CL primitive and not arbitrary string streams, though, since implementationsmight have other theories on other streams. Also, actually, I think it shouldsomehow be streams of STRING-CHAR only, since arbitrary chars may have fontinginformation and it may in some cases be clear to an implementor that this portablemodel is not appropriate. I'd hate to tie an implementor's hands....    that two-way-streams and echo-streams inherit the position and width of their    output streams,Ok since they have a unique output stream (no ambiguity).    that broadcast streams inherit from their first component.Perhaps, but this I'm less sure of and might be inclined to leave asundefined.  It might, for example, make more sense for an implementationto use the MIN of the width of the streams. Also, it might make sensefor an implementation to canonicalize the units so if stream1 were fixedwidth (char=1) and stream2 were pixel-based, the merged stream mightreport in pixels so even if it used stream1's information, it might not-look- like stream1's information, so it might be misleading to say itwas.I'm ammenable to a rewrite of this proposal per these suggestions if youwanted to do that (and if no one else had a dissenting opinion). Theoriginal intent (and the reason I didn't mail out the 2d proposal) wasto keep things simple. I don't want to add any hair that will make itharder for this to pass x3j13, but things that seem reasonable toeveryone are ok by me...*start*00956 00024 US Return-Path: <dick@wheaties.ai.mit.edu>Received: from rice-chex.ai.mit.edu ([128.52.38.46]) by Xerox.COM ; 27 JUN 88 08:08:24 PDTReceived: by rice-chex.ai.mit.edu; Mon, 27 Jun 88 11:11:00 EDTDate: Mon, 27 Jun 88 11:11:00 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8806271511.AA01487@rice-chex.ai.mit.edu>To: Masinter.paIn-Reply-To: Masinter.pa@xerox.com's message of 23 Jun 88 00:53 PDT <880624-114259-5815@Xerox>Subject: Issue: STREAM-INFO (Version 4)    "Returns the current horizontal position of the cursor..."    The word "cursor" is unfortunately overused and not defined here or    elsewhere in CLtL.I agree that CURSOR is a confusing word.  Perhaps we could just say:HORIZONTAL-POSITION returns the total net width of all of thecharacters written to the stream since the last <newline> character,(or if no <newline> has yet been written, since the stream wascreated).				Dick*start*01776 00024 US Return-Path: <dick@wheaties.ai.mit.edu>Received: from rice-chex.ai.mit.edu ([128.52.38.46]) by Xerox.COM ; 27 JUN 88 08:16:37 PDTReceived: by rice-chex.ai.mit.edu; Mon, 27 Jun 88 11:19:15 EDTDate: Mon, 27 Jun 88 11:19:15 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8806271519.AA01551@rice-chex.ai.mit.edu>To: Masinter.paCc: CL-Cleanup@sail.stanford.edu, KMP@stony-brook.scrc.symbolics.comIn-Reply-To: Masinter.pa@xerox.com's message of 24 Jun 88 12:17 PDT <880624-121812-5897@Xerox>Subject: Issue: STREAM-INFO (Version 4)    While relying on implementation-specific heuristics for    implementation-specific streams seems right to me, it seems less clear    for streams that are created using otherwise portable mechanisms. This is a good point.  However, I agree with KMP that we do not want to loadthis proposal up with a lot of baggage.								          For example, we could define that for string streams created, the line    width is the value of *string-stream-width* (and encapsulated in the    stream), where NIL means infinite, and that the unit of width is 1 and    that every character takes exactly 1 character,Here, it seems to me that that logical width of a string stream isinfinity.  I would not add any extra hair.  It is the user whopresumably has some theory about how wide the stream should be.  Anyreasonable pretty printer or the like will have a way for the user tooverride the inherent width of a stream.    that two-way-streams and echo-streams inherit the position and    width of their output streams,This sounds good to me.    that broadcast streams inherit from their first component.I agree with KMP's comments on this.  Things do not seem all that simple.			Dick*start*02226 00024 US Return-Path: <dick@wheaties.ai.mit.edu>Received: from rice-chex.ai.mit.edu ([128.52.38.46]) by Xerox.COM ; 27 JUN 88 08:33:28 PDTReceived: by rice-chex.ai.mit.edu; Mon, 27 Jun 88 11:35:44 EDTDate: Mon, 27 Jun 88 11:35:44 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8806271535.AA01655@rice-chex.ai.mit.edu>To: Masinter.paCc: KMP@stony-brook.scrc.symbolics.com, CL-Cleanup@sail.stanford.eduIn-Reply-To: Masinter.pa@xerox.com's message of 23 Jun 88 00:53 PDT <880624-114259-5815@Xerox>Subject: Issue: STREAM-INFO (Version 4)      "Returns the current horizontal position of the cursor..."    The word "cursor" is unfortunately overused and not defined here or    elsewhere in CLtL.Cursor is indeed a vague word.  Perhaps we could just say THAT"OUTPUT-POSITION returns the total net width of all of thecharacters written to the stream since that last <newline> character(or since the creation of the stream if no <newlines> have ever beenwritten).    What is (with-output-to-string (x) (princ "a test") (output-position x))?    Is it implementation dependent?There is really a key point here.  Yes it is implementation dependent.In particular, the values returned cannot be used for anything butcomparing with each other.  For example, if the output-width is notnil, then the value of output-position can be compared with it todetermine how close you are to the end of the line (in percent, butnot by any absolute measure.)  [With a string-stream the logicaloutput-width is assumedly nil.]Another use of output-position is that no matter what numberoutput-position returns, sending a <newline> to the stream and thencalling output-space with the same number will get you back to thesame horizontal place.The proposal is carefully crafted to give you these two capabilitieswhile adding as few other constraints as possible.----------------------------------------------------------------------NOTE, a broadcast stream must keep track of the relationships betweenthe units of width used by the actual target streams so thatoutput-space requests can be translated correctly when they arebroadcast to all of the actual targets.  				Dick*start*03150 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 28 JUN 88 09:44:11 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Jun 88  09:43:29 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 425840; Tue 28-Jun-88 12:39:35 EDTDate: Tue, 28 Jun 88 12:38 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 4)To: vanroggen%bach.decnet@hudson.dec.comcc: cl-cleanup@sail.stanford.edu, Dick@WHEATIES.AI.MIT.EDUIn-Reply-To: The message of 28 Jun 88 12:04 EDT from "BACH::VANROGGEN" <vanroggen%bach.decnet@hudson.dec.com>Message-ID: <880628123845.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>[Added Dick@WHEATIES.AI.MIT.EDU -- He's not on CL-Cleanup. Please remember to CC him explicitly. -kmp]    Date: 28 Jun 88 12:04:00 EDT    From: "BACH::VANROGGEN" <vanroggen%bach.decnet@hudson.dec.com>    I dislike the names OUTPUT-WIDTH and OUTPUT-POSITION for several reasons:    (1) It's ambiguous--the "position" could be for the whole stream output    so far instead of just the current line.    (2) VAX LISP already has exactly the functionality of OUTPUT-POSITION but    with the name LINE-POSITION.LINE-POSITION is ok by me.    VAX LISP also has a function called RIGHT-MARGIN, which might be the same    as OUTPUT-WIDTH, but I'm not sure.I tried not to call it anything with the word "right" in it for the sake ofanyone who might get ambitious and want to do a Hebrew implementation thatwent right to left. The text descriptions probably mention left/right allover the place, but I felt that was less critical and easier to work aroundthan having the language primitives themselves be biased.LINE-WIDTH would be consistent and ok with me, though.    Is the intent of OUTPUT-WIDTH to provide an indication to the pretty    printer of how far it knows it can print towards the side?  Is it meant    to be an absolute limit, in that printing beyond that point is undefined?The point beyond which things get ugly or wrap or truncated or whatever.Undefined, I guess.    What should the OUTPUT-WIDTH of string streams be?Someone proposed NIL, which seemed right to me.    In VAX LISP, the RIGHT-MARGIN of string streams is 80, but we allow    users to override how far the printer goes before inserting newlines.It's so easy to do (OR (OUTPUT-WIDTH ...) 80) that I think it's a bad ideato return a number if you don't mean it. If you do, it's hard to tell thedifference between an intentional and an accidental number. In the worst case,there should be a DEFAULT argument, which defaults but can be overridden.I doubt we'd all be able to agree on a number to which it should default,though, so its value probably couldn't be relied upon portably.    A lesser name complaint is OUTPUT-SPACE might be better named WRITE-SPACE    to match the other WRITE-xxx functions.			    ---Walter    ------WRITE-SPACE sounds ok to me.*start*00669 00024 US Date: 20 Sep 88 11:35 PDTFrom: masinter.paSubject: Re: Issue: STREAM-INFO (Version 4)In-reply-to: dick@wheaties.ai.mit.edu (Richard C. Waters)'s message of Tue, 5 Jul 88 11:55:44 EDTTo: dick@wheaties.ai.mit.edu (Richard C. Waters)cc: gls@think.com, masinter.pa, CL-Cleanup@sail.stanford.eduAfter the discussion on this issue in late June and early July, it seemed like it was time for us to get a revised proposal, at least mentioning the things that came up in discussion. Is there any chance of getting something like that from you this week? Sorry for the late notice, but we're trying to prepare for the October meeting of X3J13.*start*00560 00024 US Return-Path: <dick@wheaties.ai.mit.edu>Received: from rice-chex.ai.mit.edu ([128.52.38.46]) by Xerox.COM ; 21 SEP 88 10:01:58 PDTReceived: by rice-chex.ai.mit.edu; Wed, 21 Sep 88 13:03:14 EDTDate: Wed, 21 Sep 88 13:03:14 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8809211703.AA09548@rice-chex.ai.mit.edu>To: masinter.paIn-Reply-To: masinter.pa@xerox.com's message of 20 Sep 88 11:35 PDT <880920-113534-4339@Xerox>Subject: Issue: STREAM-INFO (Version 4)I will get a new proposal to you in a day or two.*start*16077 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 SEP 88 10:27:12 PDTReceived: from rice-chex.ai.mit.edu by SAIL.Stanford.EDU with TCP; 23 Sep 88  09:13:34 PDTReceived: by rice-chex.ai.mit.edu; Fri, 23 Sep 88 12:12:45 EDTDate: Fri, 23 Sep 88 12:12:45 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8809231612.AA00588@rice-chex.ai.mit.edu>To: masinter.paCc: gls@think.com, CL-Cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@xerox.com's message of 20 Sep 88 11:35 PDT <880920-113534-4339@Xerox>Subject: Issue: STREAM-INFO (Version 4)----------Issue:        STREAM-INFOReferences:   FORMAT ~T (pp398-9) and ~<...~> (pp404-6), PPRINT (p383)Category:     ADDITIONEdit history: 22-Jun-88, Version 1 by Pitman (2d model)	      23-Jun-88, Version 2 by Waters (1d model, modified 2d model)	      24-Jun-88, Version 3 by Pitman (minor reformatting)	      24-Jun-88, Version 4 by Pitman (remove 2d model for submission)              23-Sep-88, Version 5 by Waters (cleaned up in response to discussion)Status:	      For Internal DiscussionProblem Description:  Currently, there is no portable way to inquire about the line width of  an output stream, the current position on a line, or the amount of  space that the display of a string will take up.  This makes it  essentially impossible to write a portable implementation of a pretty  printer.Proposal (STREAM-INFO: ONE-DIMENSIONAL-FUNCTIONS):  Introduce four new functions.       These functions are carefully designed with an eye to the way they  interact.  As a result, they can only be defined fully in terms of  each other.  The presentation below first gives a very brief  definition of each function and then gives detailed specifications of  their relationships.   LINE-WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)       [Function]    Returns a non-negative integer representing the line width available    when printing to OUTPUT-STREAM.  If the stream has no meaningful    width (or the width cannot be computed) then NIL is returned.   LINE-POSITION &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)    [Function]    Returns a non-negative integer representing the current horizontal    position on the current output line, or NIL if the position cannot    be computed.   WRITE-SPACE WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*) [function]    Inserts blank space of length WIDTH into OUTPUT-STREAM.  WIDTH must    be a non-negative integer.  WRITE-SPACE returns T if the operation    is successful and NIL otherwise (e.g., if the operation is not    supported by OUTPUT-STREAM).   PRINTED-WIDTH STRING &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)		        &key (START 0) (END NIL)                [Function]      Returns an integer representing the horizontal width that would be    required to display STRING if it were written at the current moment    to OUTPUT-STREAM using (WRITE-STRING STRING OUTPUT-STREAM :start    START :end END), or NIL if this width cannot be computed.  The width    may be negative (e.g., if STRING contains backspace or newline    characters.)      PRINTED-WIDTH does not return any indication of the vertical    distance required when printing STRING.  The START and END    parameters delimit a substring of STRING in the usual manner.    PRINTED-WIDTH never causes any change in the state of OUTPUT-STREAM.      The width returned may well depend on the current state of    OUTPUT-STREAM (e.g., the width of tabs depends on the line position    and the width of characters depends on the font in use.)  In all    respects the width is computed based on the current state of the    stream.  However, the width returned always assumes that the total    line width is infinite---i.e., does not reflect any wraparound or    truncation which might occur.  -The difficulties of a full specification:    The functions above are intended to solve a specific current problem    in CL.  To serve this purpose, they must have reasonably precise    specifications.  However, there are several things which make it    desirable to have specifications which allow for significant    variability between implementations.  First, current implementations    of CL differ greatly in the way IO is supported, and overly strict    specifications might make things very difficult for certain    implementations.  Second, CL places no limits on the kinds of    idiosyncratic characters which can be supported by particular    implementations.  Third, while many CL implementations only support    the printing of characters in fixed width fonts, it is desirable to    allow for output streams that support variable width fonts.    Finally, it is desirable to leave room to move for the future.  -Operations on standard characters where the line-width has not yet been exceeded.    To deal with the problems above, a layered specification is    provided.   The lowest level specification is given in terms of    constraints between the four functions above.  In this lowest level    specification, two key simplifying assumptions are made.  First, it    is assumed that at the time the constraint applies, none of the    previous operations on the stream S in question have caused output    to go beyond the physical horizontal limits of the output device on    the output lines relevant to the constraints.  I.e., it is assumed    that truncation and or wraparound of the output has not occurred on    these lines.  Second, it is assumed that all of the characters    output to the stream on the output lines relevant to the constraints    are standard characters as defined in CLTL pp 20-21.  The    non-standard character #\newline may have been used to end one line    and start the next.  (Note that standard characters are all simple    characters such as A-Z.  Particularly, #\tab, #\backspace,    #\newline, are NOT standard characters.)  It is further assumed that    the strings (X and Y) referred to in the constraints consist solely    of standard characters.    Basic properties of LINE-POSITION:    1- For all S, (not (minusp (line-position S)).    2- For all S, (zerop (line-position (progn (terpri S) S))).    3- For all S, If something is at line position N on one line and       something else is at line position N on another line, then the       two things are lined up vertically one under the other.          Defining property of WRITE-SPACE    4- For all N,S, let M = (+ (line-position S) N)         if M <= (line-width S), then            (= (line-position (progn (write-space N S) S)) M)    Defining property of PRINTED-WIDTH    5- For all X,S, let M = (+ (line-position S) (printed-width X))         if 0 <= M <= (line-width S), then            (= (line-position (progn (write-string X S) S)) M)    Basic property of LINE-WIDTH    6- For all N,S, let P = (line-position S)        If (+ P N) <= (line-width S) then           (write-space N S) is guaranteed to output space on the end of           the current line without any truncation of wraparound occurring.    7- For all X,S, let P = (line-position S)        If 0 <= (+ P (printed-width X)) <= (line-width S) then           (write-string X S) is guaranteed to output X on the end of           the current line without any truncation of wraparound occurring.    Additional properties of PRINTED-WIDTH    8-  For all X,Y (= (printed-width (concatenate 'string X Y) S)		       (+ (printed-width X S) (printed-width Y S)))    9-  For all X,Z (= (printed-width X S)		       (+ (printed-width X (write-string Z S))))  -Support for varying width fonts.    A key motivation behind the functions above is dealing with    arbitrary kinds of output devices and output streams that support    variable width fonts.  To provide for this, the properties above    place no absolute constraints on the units used for the width    values.  In fact, the units can vary from stream to stream.  The    only thing that is required is that for a given stream, the units    must be a constant throughout the life of the stream, and the four    functions above must all operate in terms of the same units.  The    units should be chosen to be small enough to represent the minimum    possible difference in the length of two strings and large enough    that it is possible to perform (write-space 1).  (I.e., a single    pixel is a logical choice.)    If an output stream only supports a single fixed width font, then    the logical width unit to choose is the width of a single character.    Given this choice, the following is a minimal implementation of the    four functions that meets the requirements above.	    LINE-WIDTH returns the maximum number of characters which can be    printed on a single line.  LINE-POSITION returns the number of    characters output since the last #\newline (or since the creation of    the stream if no #\newlines have been output).  (WRITE-SPACE N S)    outputs N #\space characters.  Finally, (PRINTED-LENGTH X S) =    (length X).  -Support for non-standard characters and situations where line width    has been exceeded.    In the main, the properties above can be supported even if the line    width has been exceeded and even when non-standard charactres are    involved.  However, characters such as #\tab and #\newline can make    it impossible to support properties 7 and 8.  In addition, when the    line width is exceeded, property 3 may not hold.  It is hoped that    implementors will make a good faith effort to support the functions    in the full range of situations which can be encountered in their CL    implementations.  However, the simple implementation suggested above    will probably provide at least 80% of the benefits intended.  As a    result, it is important that people not allow the potential    difficulties of a full implementation deter them from making a    minimal implementation.  -Support for derivative streams.      Intentionally, very little is said about what the width units should    be or exactly what LINE-WIDTH should return.  The only key criterion    is that LINE-WIDTH should return a result that is pessimistic enough    to ensure proper printing.  However, it is useful to make some    comments about these matters with regard to certain types of    derivative streams.    If a synonym stream, two way stream, or echo stream is created, it should    have the same line-width and width unit as the base output stream.    A string output stream should have a line-width of NIL and probably    should be treated as supporting a fixed width font and having an    output width unit so that each character has a printed-width of 1.    If a broadcast stream is created, then LINE-LENGTH, LINE-POSITION,    and PRINTED-WIDTH should be be supported by reflecting them through    to the FIRST base stream.  (There is no guarantee that anything    reasonable can be done with the streams as a set.  For example, one    might support a varying length font while the others don't.)  An    attempt should be made to send WRITE-SPACE requests to all of the    base streams.  However, they may not come out right on other than    the first base stream.Test Case:  Suppose that S is an output stream that supports a single fixed  width font which can display 72 characters on a line and that the  associated width unit is the width of one character.  Evaluating the  following will produce the results shown.  (line-width S) => 72  (terpri S) => nil  (output-position S) => 0  (printed-width "testing: " S) => 9  (write-string "testing: " S) => "testing: "  (line-position S) => 9  (write-string "foo" S) => "foo"  (terpri S) => nil  (write-space 9 S) => T  (write-string "bar" S) => "bar"  The output produced istesting: foo	 barRationale:  Pretty printing requires the function LINE-WIDTH to know how wide the  output it produces can be.  Pretty printing requires LINE-POSITION to  determine where on the line output is when pretty printing starts.  Pretty printing requires PRINTED-WIDTH to determine how much space  things will take in the output.  (If a variable width font is being  used, this cannot be determined without a detailed knowledge of the  font being used.)  (Properties 7 & 8 greatly reduce the number of  times PRINTED-WIDTH has to be called.)  Pretty printing requires  WRITE-SPACE to get proper indentations.  (If a variable width font is  being used, indentations may be required that cannot be obtained by  outputting spaces.)Current Practice:  Essentially every implementation of Common Lisp must support the  minimal functionality above internally in order to support PPRINT and  the FORMAT directives ~T and ~<...~>.  However, there is no documented  interface to this functionality in CLTL.  As a result, while some  implementations of Common Lisp make this functionality available to  users, some do not.  Further, the implementations that do provide  this functionality do so in a variety of incompatible ways.Cost to Implementors:  This proposal is written in such a way as to allow implementations  which do not have the ability to compute difficult values to just  return NIL.  Very little work is forced.  The idea is to offer  implementors a common way to provide this useful information to  portable programs where possible.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Complex output programs such as pretty printers cannot be written portably.Benefits:  A wide range of programs can gain better control of the format of output.Aesthetics:  No significant aesthetic impact other than a slight increase in the  number of functions defined.Discussion:  Dick Waters submitted a request for changes along the line of the  horizontal aspects of these functions in a letter to X3J13 dated  June 14, 1988.  Pitman and Waters wrote up the request formally.  STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS is the minimum which is  required to support pretty printing into a stream which  displays output using a variable width font.  We drafted an alternate proposal, STREAM-INFO:TWO-DIMENSIONAL-FUNCTIONS,  which goes significantly beyond what is needed merely for pretty printing  and provides primitives LINE-DIMENSIONS, LINE-POSITION,  PRINTED-DIMENSIONS, and WRITE-SPACE but it is not included here.  A key point of contention which would be likely to swamp the 2d proposal  is the age old question of how to handle the issue of vertical distance  (where is the origin, which way do you count, ...). If anyone would  prefer to see larger problem 2d proposal, it could be circulated, but at  the last minute Pitman got worried that even the 1d version was going to  be controversial enough and decided to keep things focused on that.  For his own needs, Waters is strongly interested in having either  ONE-DIMENSIONAL-FUNCTIONS or TWO-DIMENSIONAL-FUNCTIONS proposal accepted,  but does not care which. Pitman concurs.  One variation of the 1d proposal might be useful to consider:   PRINTED-WIDTH could return two additional values: the number of newlines    that WRITE-STRING of the string would execute and the maximum X position    encountered (which might differ from the first value if the number of    newlines was non-zero).  This feature wasn't necessary for Waters' minimalist proposal, but Pitman  would be willing to write it in here if people thought it would be useful  enough for other purposes.  The 5th version was changed from the 4th by responding to suggestions  about better names for the functions, including a discussion of how  line-width should apply to various kinds of derivative streams, and  most importantly, by including a much more precise specification for  what the minimal capabilities of the functions should be.*start*00929 00024 US Date: 23 Sep 88 13:47 PDTFrom: masinter.paSubject: Re: Issue: STREAM-INFO (Version 4)In-reply-to: dick@wheaties.ai.mit.edu (Richard C. Waters)'s message of Fri, 23 Sep 88 12:12:45 EDTTo: dick@wheaties.ai.mit.edu (Richard C. Waters)cc: masinter.pa, gls@think.com, CL-Cleanup@sail.stanford.eduI can think of several reasons for allowing these functions to return rationals rather than integers. For example, if I have a mainly-fixed-width font, except with a couple of oddball characters. It may be difficult and computationally expensive to compute the lcm of the denominators of all of the rational widths in a given postscript font -- especially if font metrics are normally demand-loaded. It would be more useful to remove any requirement on the scaling of the values; if you want to print a short space, you can (let((dot (printed-width ".")))  	(if dot  (write-space dot) (princ " ")))*start*01293 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 SEP 88 13:54:34 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Sep 88  13:53:27 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 SEP 88 13:47:24 PDTDate: 23 Sep 88 13:47 PDTFrom: masinter.paSubject: Re: Issue: STREAM-INFO (Version 4)In-reply-to: dick@wheaties.ai.mit.edu (Richard C. Waters)'s message of Fri, 23 Sep 88 12:12:45 EDTTo: dick@wheaties.ai.mit.edu (Richard C. Waters)cc: masinter.pa, gls@think.com, CL-Cleanup@sail.stanford.eduMessage-ID: <880923-134724-1961@Xerox>I can think of several reasons for allowing these functions to return rationalsrather than integers. For example, if I have a mainly-fixed-width font, exceptwith a couple of oddball characters. It may be difficult and computationallyexpensive to compute the lcm of the denominators of all of the rational widthsin a given postscript font -- especially if font metrics are normallydemand-loaded. It would be more useful to remove any requirement on the scaling of the values;if you want to print a short space, you can (let((dot (printed-width ".")))  	(if dot  (write-space dot) (princ " ")))*start*00717 00024 US Return-Path: <dick@wheaties.ai.mit.edu>Received: from rice-chex.ai.mit.edu ([128.52.38.46]) by Xerox.COM ; 23 SEP 88 19:43:35 PDTReceived: by rice-chex.ai.mit.edu; Fri, 23 Sep 88 22:44:51 EDTDate: Fri, 23 Sep 88 22:44:51 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8809240244.AA03833@rice-chex.ai.mit.edu>To: masinter.paIn-Reply-To: masinter.pa@xerox.com's message of 23 Sep 88 13:47 PDT <880923-134724-1961@Xerox>Subject: Issue: STREAM-INFO (Version 4)Cc: gls@think.com, CL-Cleanup@sail.stanford.eduRe letting the functions return rationals.  That is fine with me.I was just trying to think of efficiency in the programs that callthese functions.			Dick*start*00924 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 21:38:55 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Sep 88  21:38:51 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 466144; Tue 27-Sep-88 00:37:24 EDTDate: Tue, 27 Sep 88 00:37 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 5)To: Richard C. Waters <dick@wheaties.ai.mit.edu>, CL-Cleanup@sail.stanford.eduIn-Reply-To: <8809231612.AA00588@rice-chex.ai.mit.edu>Message-ID: <19880927043729.6.MOON@EUPHRATES.SCRC.Symbolics.COM>I approve STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS in version 5.Your property 9 appears to have been garbled by an editing error.*start*01342 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 05:04:30 PDTReceived: from rice-chex.ai.mit.edu ([128.52.38.46]) by SAIL.Stanford.EDU with TCP; 27 Sep 88  05:04:40 PDTReceived: by rice-chex.ai.mit.edu; Tue, 27 Sep 88 08:04:30 EDTDate: Tue, 27 Sep 88 08:04:30 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8809271204.AA11669@rice-chex.ai.mit.edu>To: CL-Cleanup@sail.stanford.eduSubject: Moon@stony-brook.scrc.symbolics.comProperty 9 should read as follows.    9-  For all X,Z (= (printed-width X S)		       (progn (write-string Z S) (printed-width X S)))I.E. the printed-width of a string of simple characters does not vary based on line position.More thoughts on whether printed-width etc. should be able to returnrational numbers instead of just integers.  This is certainly logical,however, it seems to me to be unreasonably in the inefficiency it forceson the users of these functions.  Note that in order to get the units right,you would not have to figure out the least common denominator in the widthsof the characters in a font.  It should be sufficient to simply pick theresolution of the output device (e.g., 72 pixels per inch or whatever).			Dick*start*00883 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 07:28:08 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 27 Sep 88  07:28:10 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 27 Sep 88 10:24:16 EDTTo: dick@wheaties.ai.mit.edu (Richard C. Waters)cc: CL-Cleanup@sail.stanford.eduSubject: Re: Moon@stony-brook.scrc.symbolics.com In-reply-to: Your message of Tue, 27 Sep 88 08:04:30 -0400.             <8809271204.AA11669@rice-chex.ai.mit.edu> Date: Tue, 27 Sep 88 10:23:46 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUMy vote is that we stick with integers, more as a matter of user-sanitythan on grounds of efficiency.  The implementation can pick quantum unitsthat are appropriately small.-- Scott*start*01041 00024 US Return-Path: <Scott.Fahlman@sef1.slisp.cs.cmu.edu>Received: from SEF1.SLISP.CS.CMU.EDU ([128.2.218.13]) by Xerox.COM ; 06 OCT 88 16:48:07 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU;  6 Oct 88 19:46:58 EDTTo: masinter.pacc: dick@wheaties.ai.mit.edu (Richard C. Waters), CL-Cleanup@sail.stanford.eduSubject: Re: Issue: STREAM-INFO (Version 5) In-reply-to: Your message of 06 Oct 88 16:16:00 -0700.             <881006-161656-1634@Xerox> Date: Thu, 06 Oct 88 19:46:23 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUWell, if there really are useful real-world cases where it makes sense tohave most characters be of width R except a couple that are R*732/539, thenI guess it is necessary to go with rational widths, despite the cost inperformance and added confusion.  (I'm assuming that you're notexaggerating -- if the case is really R*3/2 then the decision is much lessclear.)I don't violently object to the added complexity.  I just didn't want toadd it for no good reason.-- Scott*start*01164 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 16:49:40 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 6 Oct 88  16:49:12 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU;  6 Oct 88 19:46:58 EDTTo: masinter.pacc: dick@wheaties.ai.mit.edu (Richard C. Waters), CL-Cleanup@sail.stanford.eduSubject: Re: Issue: STREAM-INFO (Version 5) In-reply-to: Your message of 06 Oct 88 16:16:00 -0700.             <881006-161656-1634@Xerox> Date: Thu, 06 Oct 88 19:46:23 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUWell, if there really are useful real-world cases where it makes sense tohave most characters be of width R except a couple that are R*732/539, thenI guess it is necessary to go with rational widths, despite the cost inperformance and added confusion.  (I'm assuming that you're notexaggerating -- if the case is really R*3/2 then the decision is much lessclear.)I don't violently object to the added complexity.  I just didn't want toadd it for no good reason.-- Scott*start*02240 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 16:20:29 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Oct 88  16:19:22 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 06 OCT 88 16:16:56 PDTDate: 6 Oct 88 16:16 PDTFrom: masinter.paSubject: Issue: STREAM-INFO (Version 5) In-reply-to: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Tue, 27 Sep 88 10:23:46 EDTTo: Scott.Fahlman@B.GP.CS.CMU.EDUcc: dick@wheaties.ai.mit.edu (Richard C. Waters), CL-Cleanup@sail.stanford.eduMessage-ID: <881006-161656-1634@Xerox>I have a stream that prints characters to a printer-independent file format(think Postscript). I run in a system that admits 16-bit characters. Thecharacter widths are cached, and loaded on demand. Character widths areexpressed in rationals. In advance of printing, I don't know what thewidths will be.  Different type faces will have different units ofquantization. As with postscript, the widths are expressed in absolutes independent ofthe resolution of the printer -- the printer will perform "best effort" toprint things the same sizes as specified. Suppose that I am using a style in which most characters are size R (whereR is an integer), but there are a few special symbols that are of sizeR*732/539 .  I'd prefer to normally use a scale where R is a small integerrather than have to reduce everything to a scale where, in order toaccomodate the possibility of an unusual character, the scale has to bloatto be unusually large.Allowing sizes to be rational instead of integer is a performanceimprovement; in a world where there are fairly arbitrary outline-definedcharacters of arbitrary sizes, it might be necessary to resort to bignumsto accomodate the least common denominator of all of their sizes. Rational numbers might drive some users insane, but I think for the mostpart you want to allow the implementation to pick the appropriate scale.My only thought is that, having thought that far, there is no reason to notextend the range of character widths to allow for floating point, i.e., theresults is a (non-complex) number. *start*00987 00024 US Date:  7 Oct 88 23:01 PDTFrom: masinter.paSubject: Re: Issue: STREAM-INFO (Version 5) In-reply-to: masinter.pa's message of 6 Oct 88 16:16 PDTTo: masinter.pacc: Scott.Fahlman@B.GP.CS.CMU.EDU, dick@wheaties.ai.mit.edu (Richard C. Waters), CL-Cleanup@sail.stanford.eduThere's a bit about this proposal that bothers me, but it mainly has to do with the interactions with the changes that the character committee is thinking about with regard to extended character sets.What is the relationship between graphic-char-p and the notion that the printed width of the character is non-NIL (and non-zero?). As a matter of form, the writeup commits the sin of arguing for the proposal in the middle of describing it; the proposal name is too generic and not really appropriate to the problem. The Problem is PRETTY-PRINT-WIDTH-SUPPORT or some such. Its important to bring this up at the meeting because of the interaction with the character proposal, however.*start*16287 00024 USfReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 22:23:02 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  21:59:37 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 08 OCT 88 21:55:17 PDTDate: 8 Oct 88 21:55 PDTFrom: masinter.paSubject: DRAFT Issue: STREAM-INFO (Version 5)To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-215517-2573@Xerox>This issue has some interactions with the character proposal.There has been a recommendation (from me) that the functionsbe allowed to return/accept non-complex numbers rather thanintegers where possible, given the possibilities of outputstreams that can do arbitrary scaling.Perhaps this issue should have been calledPRETTY-PRINT-WIDTH-SUPPORT!Status:	DRAFTIssue:        STREAM-INFOReferences:   FORMAT ~T (pp398-9) and ~<...~> (pp404-6), PPRINT (p383)Category:     ADDITIONEdit history: 22-Jun-88, Version 1 by Pitman (2d model)	      23-Jun-88, Version 2 by Waters (1d model, modified 2d model)	      24-Jun-88, Version 3 by Pitman (minor reformatting)	      24-Jun-88, Version 4 by Pitman (remove 2d model for submission)              23-Sep-88, Version 5 by Waters (cleaned up in response to discussion)Problem Description:  Currently, there is no portable way to inquire about the line width of  an output stream, the current position on a line, or the amount of  space that the display of a string will take up.  This makes it  essentially impossible to write a portable implementation of a pretty  printer.Proposal (STREAM-INFO: ONE-DIMENSIONAL-FUNCTIONS):  Introduce four new functions.       These functions are carefully designed with an eye to the way they  interact.  As a result, they can only be defined fully in terms of  each other.  The presentation below first gives a very brief  definition of each function and then gives detailed specifications of  their relationships.   LINE-WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)       [Function]    Returns a non-negative integer representing the line width available    when printing to OUTPUT-STREAM.  If the stream has no meaningful    width (or the width cannot be computed) then NIL is returned.   LINE-POSITION &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)    [Function]    Returns a non-negative integer representing the current horizontal    position on the current output line, or NIL if the position cannot    be computed.   WRITE-SPACE WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*) [function]    Inserts blank space of length WIDTH into OUTPUT-STREAM.  WIDTH must    be a non-negative integer.  WRITE-SPACE returns T if the operation    is successful and NIL otherwise (e.g., if the operation is not    supported by OUTPUT-STREAM).   PRINTED-WIDTH STRING &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)		        &key (START 0) (END NIL)                [Function]      Returns an integer representing the horizontal width that would be    required to display STRING if it were written at the current moment    to OUTPUT-STREAM using (WRITE-STRING STRING OUTPUT-STREAM :start    START :end END), or NIL if this width cannot be computed.  The width    may be negative (e.g., if STRING contains backspace or newline    characters.)      PRINTED-WIDTH does not return any indication of the vertical    distance required when printing STRING.  The START and END    parameters delimit a substring of STRING in the usual manner.    PRINTED-WIDTH never causes any change in the state of OUTPUT-STREAM.      The width returned may well depend on the current state of    OUTPUT-STREAM (e.g., the width of tabs depends on the line position    and the width of characters depends on the font in use.)  In all    respects the width is computed based on the current state of the    stream.  However, the width returned always assumes that the total    line width is infinite---i.e., does not reflect any wraparound or    truncation which might occur.  -The difficulties of a full specification:    The functions above are intended to solve a specific current problem    in CL.  To serve this purpose, they must have reasonably precise    specifications.  However, there are several things which make it    desirable to have specifications which allow for significant    variability between implementations.  First, current implementations    of CL differ greatly in the way IO is supported, and overly strict    specifications might make things very difficult for certain    implementations.  Second, CL places no limits on the kinds of    idiosyncratic characters which can be supported by particular    implementations.  Third, while many CL implementations only support    the printing of characters in fixed width fonts, it is desirable to    allow for output streams that support variable width fonts.    Finally, it is desirable to leave room to move for the future.  -Operations on standard characters where the line-width has not yet been exceeded.    To deal with the problems above, a layered specification is    provided.   The lowest level specification is given in terms of    constraints between the four functions above.  In this lowest level    specification, two key simplifying assumptions are made.  First, it    is assumed that at the time the constraint applies, none of the    previous operations on the stream S in question have caused output    to go beyond the physical horizontal limits of the output device on    the output lines relevant to the constraints.  I.e., it is assumed    that truncation and or wraparound of the output has not occurred on    these lines.  Second, it is assumed that all of the characters    output to the stream on the output lines relevant to the constraints    are standard characters as defined in CLTL pp 20-21.  The    non-standard character #\newline may have been used to end one line    and start the next.  (Note that standard characters are all simple    characters such as A-Z.  Particularly, #\tab, #\backspace,    #\newline, are NOT standard characters.)  It is further assumed that    the strings (X and Y) referred to in the constraints consist solely    of standard characters.    Basic properties of LINE-POSITION:    1- For all S, (not (minusp (line-position S)).    2- For all S, (zerop (line-position (progn (terpri S) S))).    3- For all S, If something is at line position N on one line and       something else is at line position N on another line, then the       two things are lined up vertically one under the other.          Defining property of WRITE-SPACE    4- For all N,S, let M = (+ (line-position S) N)         if M <= (line-width S), then            (= (line-position (progn (write-space N S) S)) M)    Defining property of PRINTED-WIDTH    5- For all X,S, let M = (+ (line-position S) (printed-width X))         if 0 <= M <= (line-width S), then            (= (line-position (progn (write-string X S) S)) M)    Basic property of LINE-WIDTH    6- For all N,S, let P = (line-position S)        If (+ P N) <= (line-width S) then           (write-space N S) is guaranteed to output space on the end of           the current line without any truncation of wraparound occurring.    7- For all X,S, let P = (line-position S)        If 0 <= (+ P (printed-width X)) <= (line-width S) then           (write-string X S) is guaranteed to output X on the end of           the current line without any truncation of wraparound occurring.    Additional properties of PRINTED-WIDTH    8-  For all X,Y (= (printed-width (concatenate 'string X Y) S)		       (+ (printed-width X S) (printed-width Y S)))    9-  For all X,Z (= (printed-width X S)		       (progn (write-string Z S) (printed-width X S)))  -Support for varying width fonts.    A key motivation behind the functions above is dealing with    arbitrary kinds of output devices and output streams that support    variable width fonts.  To provide for this, the properties above    place no absolute constraints on the units used for the width    values.  In fact, the units can vary from stream to stream.  The    only thing that is required is that for a given stream, the units    must be a constant throughout the life of the stream, and the four    functions above must all operate in terms of the same units.  The    units should be chosen to be small enough to represent the minimum    possible difference in the length of two strings and large enough    that it is possible to perform (write-space 1).  (I.e., a single    pixel is a logical choice.)    If an output stream only supports a single fixed width font, then    the logical width unit to choose is the width of a single character.    Given this choice, the following is a minimal implementation of the    four functions that meets the requirements above.	    LINE-WIDTH returns the maximum number of characters which can be    printed on a single line.  LINE-POSITION returns the number of    characters output since the last #\newline (or since the creation of    the stream if no #\newlines have been output).  (WRITE-SPACE N S)    outputs N #\space characters.  Finally, (PRINTED-LENGTH X S) =    (length X).  -Support for non-standard characters and situations where line width    has been exceeded.    In the main, the properties above can be supported even if the line    width has been exceeded and even when non-standard charactres are    involved.  However, characters such as #\tab and #\newline can make    it impossible to support properties 7 and 8.  In addition, when the    line width is exceeded, property 3 may not hold.  It is hoped that    implementors will make a good faith effort to support the functions    in the full range of situations which can be encountered in their CL    implementations.  However, the simple implementation suggested above    will probably provide at least 80% of the benefits intended.  As a    result, it is important that people not allow the potential    difficulties of a full implementation deter them from making a    minimal implementation.  -Support for derivative streams.      Intentionally, very little is said about what the width units should    be or exactly what LINE-WIDTH should return.  The only key criterion    is that LINE-WIDTH should return a result that is pessimistic enough    to ensure proper printing.  However, it is useful to make some    comments about these matters with regard to certain types of    derivative streams.    If a synonym stream, two way stream, or echo stream is created, it should    have the same line-width and width unit as the base output stream.    A string output stream should have a line-width of NIL and probably    should be treated as supporting a fixed width font and having an    output width unit so that each character has a printed-width of 1.    If a broadcast stream is created, then LINE-LENGTH, LINE-POSITION,    and PRINTED-WIDTH should be be supported by reflecting them through    to the FIRST base stream.  (There is no guarantee that anything    reasonable can be done with the streams as a set.  For example, one    might support a varying length font while the others don't.)  An    attempt should be made to send WRITE-SPACE requests to all of the    base streams.  However, they may not come out right on other than    the first base stream.Test Case:  Suppose that S is an output stream that supports a single fixed  width font which can display 72 characters on a line and that the  associated width unit is the width of one character.  Evaluating the  following will produce the results shown.  (line-width S) => 72  (terpri S) => nil  (output-position S) => 0  (printed-width "testing: " S) => 9  (write-string "testing: " S) => "testing: "  (line-position S) => 9  (write-string "foo" S) => "foo"  (terpri S) => nil  (write-space 9 S) => T  (write-string "bar" S) => "bar"  The output produced istesting: foo	 barRationale:  Pretty printing requires the function LINE-WIDTH to know how wide the  output it produces can be.  Pretty printing requires LINE-POSITION to  determine where on the line output is when pretty printing starts.  Pretty printing requires PRINTED-WIDTH to determine how much space  things will take in the output.  (If a variable width font is being  used, this cannot be determined without a detailed knowledge of the  font being used.)  (Properties 7 & 8 greatly reduce the number of  times PRINTED-WIDTH has to be called.)  Pretty printing requires  WRITE-SPACE to get proper indentations.  (If a variable width font is  being used, indentations may be required that cannot be obtained by  outputting spaces.)Current Practice:  Essentially every implementation of Common Lisp must support the  minimal functionality above internally in order to support PPRINT and  the FORMAT directives ~T and ~<...~>.  However, there is no documented  interface to this functionality in CLTL.  As a result, while some  implementations of Common Lisp make this functionality available to  users, some do not.  Further, the implementations that do provide  this functionality do so in a variety of incompatible ways.Cost to Implementors:  This proposal is written in such a way as to allow implementations  which do not have the ability to compute difficult values to just  return NIL.  Very little work is forced.  The idea is to offer  implementors a common way to provide this useful information to  portable programs where possible.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Complex output programs such as pretty printers cannot be written portably.Benefits:  A wide range of programs can gain better control of the format of output.Aesthetics:  No significant aesthetic impact other than a slight increase in the  number of functions defined.Discussion:  Dick Waters submitted a request for changes along the line of the  horizontal aspects of these functions in a letter to X3J13 dated  June 14, 1988.  Pitman and Waters wrote up the request formally.  STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS is the minimum which is  required to support pretty printing into a stream which  displays output using a variable width font.  We drafted an alternate proposal, STREAM-INFO:TWO-DIMENSIONAL-FUNCTIONS,  which goes significantly beyond what is needed merely for pretty printing  and provides primitives LINE-DIMENSIONS, LINE-POSITION,  PRINTED-DIMENSIONS, and WRITE-SPACE but it is not included here.  A key point of contention which would be likely to swamp the 2d proposal  is the age old question of how to handle the issue of vertical distance  (where is the origin, which way do you count, ...). If anyone would  prefer to see larger problem 2d proposal, it could be circulated, but at  the last minute Pitman got worried that even the 1d version was going to  be controversial enough and decided to keep things focused on that.  For his own needs, Waters is strongly interested in having either  ONE-DIMENSIONAL-FUNCTIONS or TWO-DIMENSIONAL-FUNCTIONS proposal accepted,  but does not care which. Pitman concurs.  One variation of the 1d proposal might be useful to consider:   PRINTED-WIDTH could return two additional values: the number of newlines    that WRITE-STRING of the string would execute and the maximum X position    encountered (which might differ from the first value if the number of    newlines was non-zero).  This feature wasn't necessary for Waters' minimalist proposal, but Pitman  would be willing to write it in here if people thought it would be useful  enough for other purposes.  The 5th version was changed from the 4th by responding to suggestions  about better names for the functions, including a discussion of how  line-width should apply to various kinds of derivative streams, and  most importantly, by including a much more precise specification for  what the minimal capabilities of the functions should be.     ----- End Forwarded Messages -----*start*01285 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:11:53 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  18:06:28 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476139; Thu 13-Oct-88 19:25:50 EDTDate: Thu, 13 Oct 88 19:25 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 5)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013192542.3.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Masinter: Printer scaling points to allowing non-integers.	   Eg, you might want to say make my output 12% bigger, and there	   might be no easy way to come up with a good set of units on the	   fly without considerably complicated understanding of how the	   device will deal with that request. Should maybe even allow floats	   (ie, non-negative, non-complex numbers). Masinter said he'd return the issue to Waters for rewrite.X3J13 meeting: Interacts with Character Proposal. RWK: Want less generic names. eg, maybe STREAM-xxx.*start*01084 00024 US Return-Path: <dick@wheaties.ai.mit.edu>Received: from rice-chex.ai.mit.edu ([128.52.38.46]) by Xerox.COM ; 09 OCT 88 19:00:47 PDTReceived: by rice-chex.ai.mit.edu; Sun, 9 Oct 88 22:01:43 EDTDate: Sun, 9 Oct 88 22:01:43 EDTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8810100201.AA13115@rice-chex.ai.mit.edu>To: masinter.paCc: masinter.pa, Scott.Fahlman@b.gp.cs.cmu.edu, CL-Cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@xerox.com's message of 7 Oct 88 23:01 PDT <881007-230055-1825@Xerox>Subject: Issue: STREAM-INFO (Version 5) The name can be changed any way you want.  I will work to change theform any way you want too, if you give me a bit of guidance.As for graphic characters.  I do not see that they should be anyproblem. the printed width is simply the change in horizontal positionwithout regard to any vertical changes.  The printed width can be zeroif that is what is happening, or negative for that matter.  As long as itis deterministic what the character will do, I do not see the problem.			Dick Waters*start*15157 00024 US Date: 30 Nov 88 18:10 PSTFrom: masinter.paSubject: Issue: STREAM-INFO (Version 6)To: cl-cleanup@sail.stanford.educc: dick@wheaties.ai.mit.edu (Richard C. Waters)REPLY-TO: cl-cleanup@sail.stanford.educc: Masinter.paWe have not yet responded to RWK's comment, viz "Want less generic names. eg, maybe STREAM-xxx". What do you think about STREAM-LINE-WIDTH, STREAM-WRITE-SPACE, etc?Status:	DRAFTIssue:        STREAM-INFOReferences:   FORMAT ~T (pp398-9) and ~<...~> (pp404-6), PPRINT (p383)Category:     ADDITIONEdit history: 22-Jun-88, Version 1 by Pitman (2d model)	      23-Jun-88, Version 2 by Waters (1d model, modified 2d model)	      24-Jun-88, Version 3 by Pitman (minor reformatting)	      24-Jun-88, Version 4 by Pitman (remove 2d model for submission)              23-Sep-88, Version 5 by Waters (cleaned up in response to discussion)             30-Nov-88, Version 6 by Masinter (add discussion)Problem Description:  Currently, there is no portable way to inquire about the line width of  an output stream, the current position on a line, or the amount of  space that the display of a string will take up.  This makes it  essentially impossible to write a portable implementation of a pretty  printer.Proposal STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS:  Introduce four new functions.       These functions are carefully designed with an eye to the way they  interact.  As a result, they can only be defined fully in terms of  each other.  The presentation below first gives a very brief  definition of each function and then gives detailed specifications of  their relationships.   LINE-WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)       [Function]    Returns a number representing the line width available    when printing to OUTPUT-STREAM.  If the stream has no meaningful    width (or the width cannot be computed) then NIL is returned.   LINE-POSITION &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)    [Function]    Returns a number representing the current horizontal    position on the current output line, or NIL if the position cannot    be computed.   WRITE-SPACE WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*) [function]    Inserts blank space of length WIDTH into OUTPUT-STREAM.  WIDTH must    be a non-negative number.  WRITE-SPACE returns T if the operation    is successful and NIL otherwise (e.g., if the operation is not    supported by OUTPUT-STREAM).   PRINTED-WIDTH STRING &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)		        &key (START 0) (END NIL)                [Function]      Returns a number representing the horizontal width that would be    required to display STRING if it were written at the current moment    to OUTPUT-STREAM using (WRITE-STRING STRING OUTPUT-STREAM :start    START :end END), or NIL if this width cannot be computed.  The width    may be negative (e.g., if STRING contains backspace or newline    characters.)      PRINTED-WIDTH does not return any indication of the vertical    distance required when printing STRING.  The START and END    parameters delimit a substring of STRING in the usual manner.    PRINTED-WIDTH never causes any change in the state of OUTPUT-STREAM.      The width returned may well depend on the current state of    OUTPUT-STREAM (e.g., the width of tabs depends on the line position    and the width of characters depends on the font in use.)  In all    respects the width is computed based on the current state of the    stream.  However, the width returned always assumes that the total    line width is infinite---i.e., does not reflect any wraparound or    truncation which might occur.  -The difficulties of a full specification:    The functions above are intended to solve a specific current problem    in CL.  To serve this purpose, they must have reasonably precise    specifications.  However, there are several things which make it    desirable to have specifications which allow for significant    variability between implementations.  First, current implementations    of CL differ greatly in the way IO is supported, and overly strict    specifications might make things very difficult for certain    implementations.  Second, CL places no limits on the kinds of    idiosyncratic characters which can be supported by particular    implementations.  Third, while many CL implementations only support    the printing of characters in fixed width fonts, it is desirable to    allow for output streams that support variable width fonts.    Finally, it is desirable to leave room to move for the future.  -Operations on standard characters where the line-width has not yet been exceeded.    To deal with the problems above, a layered specification is    provided.   The lowest level specification is given in terms of    constraints between the four functions above.  In this lowest level    specification, two key simplifying assumptions are made.  First, it    is assumed that at the time the constraint applies, none of the    previous operations on the stream S in question have caused output    to go beyond the physical horizontal limits of the output device on    the output lines relevant to the constraints.  I.e., it is assumed    that truncation and or wraparound of the output has not occurred on    these lines.  Second, it is assumed that all of the characters    output to the stream on the output lines relevant to the constraints    are standard characters as defined in CLTL pp 20-21.  The    non-standard character #\newline may have been used to end one line    and start the next.  (Note that standard characters are all simple    characters such as A-Z.  Particularly, #\tab, #\backspace,    #\newline, are NOT standard characters.)  It is further assumed that    the strings (X and Y) referred to in the constraints consist solely    of standard characters.    Basic properties of LINE-POSITION:    1- For all S, (not (minusp (line-position S)).    2- For all S, (zerop (line-position (progn (terpri S) S))).    3- For all S, If something is at line position N on one line and       something else is at line position N on another line, then the       two things are lined up vertically one under the other.          Defining property of WRITE-SPACE    4- For all N,S, let M = (+ (line-position S) N)         if M <= (line-width S), then            (= (line-position (progn (write-space N S) S)) M)    Defining property of PRINTED-WIDTH    5- For all X,S, let M = (+ (line-position S) (printed-width X))         if 0 <= M <= (line-width S), then            (= (line-position (progn (write-string X S) S)) M)    Basic property of LINE-WIDTH    6- For all N,S, let P = (line-position S)        If (+ P N) <= (line-width S) then           (write-space N S) is guaranteed to output space on the end of           the current line without any truncation of wraparound occurring.    7- For all X,S, let P = (line-position S)        If 0 <= (+ P (printed-width X)) <= (line-width S) then           (write-string X S) is guaranteed to output X on the end of           the current line without any truncation of wraparound occurring.    Additional properties of PRINTED-WIDTH    8-  For all X,Y (= (printed-width (concatenate 'string X Y) S)		       (+ (printed-width X S) (printed-width Y S)))    9-  For all X,Z (= (printed-width X S)		       (progn (write-string Z S) (printed-width X S)))  -Support for varying width fonts.    A key motivation behind the functions above is dealing with    arbitrary kinds of output devices and output streams that support    variable width fonts.  To provide for this, the properties above    place no absolute constraints on the units used for the width    values.  In fact, the units can vary from stream to stream.  The    only thing that is required is that for a given stream, the units    must be a constant throughout the life of the stream, and the four    functions above must all operate in terms of the same units.  The    units should be chosen to be small enough to represent the minimum    possible difference in the length of two strings and large enough    that it is possible to perform (write-space 1).  (I.e., a single    pixel is a logical choice.)    If an output stream only supports a single fixed width font, then    the logical width unit to choose is the width of a single character.    Given this choice, the following is a minimal implementation of the    four functions that meets the requirements above.	    LINE-WIDTH returns the maximum number of characters which can be    printed on a single line.  LINE-POSITION returns the number of    characters output since the last #\newline (or since the creation of    the stream if no #\newlines have been output).  (WRITE-SPACE N S)    outputs N #\space characters.  Finally, (PRINTED-LENGTH X S) =    (length X).  -Support for non-standard characters and situations where line width    has been exceeded.    In the main, the properties above can be supported even if the line    width has been exceeded and even when non-standard charactres are    involved.  However, characters such as #\tab and #\newline can make    it impossible to support properties 7 and 8.  In addition, when the    line width is exceeded, property 3 may not hold.  It is hoped that    implementors will make a good faith effort to support the functions    in the full range of situations which can be encountered in their CL    implementations.  However, the simple implementation suggested above    will probably provide at least 80% of the benefits intended.  As a    result, it is important that people not allow the potential    difficulties of a full implementation deter them from making a    minimal implementation.  -Support for derivative streams.      Intentionally, very little is said about what the width units should    be or exactly what LINE-WIDTH should return.  The only key criterion    is that LINE-WIDTH should return a result that is pessimistic enough    to ensure proper printing.  However, it is useful to make some    comments about these matters with regard to certain types of    derivative streams.    If a synonym stream, two way stream, or echo stream is created, it should    have the same line-width and width unit as the base output stream.    A string output stream should have a line-width of NIL and probably    should be treated as supporting a fixed width font and having an    output width unit so that each character has a printed-width of 1.    If a broadcast stream is created, then LINE-LENGTH, LINE-POSITION,    and PRINTED-WIDTH should be be supported by reflecting them through    to the FIRST base stream.  (There is no guarantee that anything    reasonable can be done with the streams as a set.  For example, one    might support a varying length font while the others don't.)  An    attempt should be made to send WRITE-SPACE requests to all of the    base streams.  However, they may not come out right on other than    the first base stream.Test Case:  Suppose that S is an output stream that supports a single fixed  width font which can display 72 characters on a line and that the  associated width unit is the width of one character.  Evaluating the  following will produce the results shown.  (line-width S) => 72  (terpri S) => nil  (output-position S) => 0  (printed-width "testing: " S) => 9  (write-string "testing: " S) => "testing: "  (line-position S) => 9  (write-string "foo" S) => "foo"  (terpri S) => nil  (write-space 9 S) => T  (write-string "bar" S) => "bar"  The output produced istesting: foo	 barRationale:  Pretty printing requires the function LINE-WIDTH to know how wide the  output it produces can be.  Pretty printing requires LINE-POSITION to  determine where on the line output is when pretty printing starts.  Pretty printing requires PRINTED-WIDTH to determine how much space  things will take in the output.  (If a variable width font is being  used, this cannot be determined without a detailed knowledge of the  font being used.)  (Properties 7 & 8 greatly reduce the number of  times PRINTED-WIDTH has to be called.)  Pretty printing requires  WRITE-SPACE to get proper indentations.  (If a variable width font is  being used, indentations may be required that cannot be obtained by  outputting spaces.)Current Practice:  Essentially every implementation of Common Lisp must support the  minimal functionality above internally in order to support PPRINT and  the FORMAT directives ~T and ~<...~>.  However, there is no documented  interface to this functionality in CLTL.  As a result, while some  implementations of Common Lisp make this functionality available to  users, some do not.  Further, the implementations that do provide  this functionality do so in a variety of incompatible ways.Cost to Implementors:  This proposal is written in such a way as to allow implementations  which do not have the ability to compute difficult values to just  return NIL.  Very little work is forced.  The idea is to offer  implementors a common way to provide this useful information to  portable programs where possible.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Complex output programs such as pretty printers cannot be written portably.Benefits:  A wide range of programs can gain better control of the format of output.Aesthetics:  No significant aesthetic impact other than a slight increase in the  number of functions defined.Discussion:This issue probably should have been called PRETTY-PRINT-WIDTH-SUPPORT.Dick Waters (author of GPRINT, a portable pretty printer), originally   raised this issue.STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS is the minimum required to support pretty printing into a stream which displays output using a variable width font.Originally the functions were defined to return integers; however, there are some output devices (e.g., those that have arbitrary scaling operations), for which it would be difficult to find a reasonable least-common-denominator for line-width.We considered an alternate proposal which goes significantly beyond what is needed merely for pretty printing   and provides primitives LINE-DIMENSIONS, LINE-POSITION,   PRINTED-DIMENSIONS, and WRITE-SPACE but it is not included here. A key point of contention was the question of how to handle the issue of vertical distance   (where is the origin, which way do you count, ...).We considered requiring   PRINTED-WIDTH to return two additional values: the number of newlines that WRITE-STRING of the string would execute and the maximum X position encountered (which might differ from the first value if the number of newlines was non-zero).This feature wasn't strictly necessary for pretty-printing, and so was omitted.Some of the draft proposals from the character committee contained some proposed functions that were attempting to solve the same problem. Conflicting proposals should be avoided.*start*15518 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 NOV 88 18:40:52 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Nov 88  18:36:32 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 30 NOV 88 18:15:26 PSTDate: 30 Nov 88 18:10 PSTFrom: masinter.paSubject: Issue: STREAM-INFO (Version 6)To: cl-cleanup@sail.stanford.educc: dick@wheaties.ai.mit.edu (Richard C. Waters)REPLY-TO: cl-cleanup@sail.stanford.educc: Masinter.paMessage-ID: <881130-181526-3544@Xerox>We have not yet responded to RWK's comment, viz "Want less generic names.eg, maybe STREAM-xxx". What do you think about STREAM-LINE-WIDTH, STREAM-WRITE-SPACE, etc?!Status:	DRAFTIssue:        STREAM-INFOReferences:   FORMAT ~T (pp398-9) and ~<...~> (pp404-6), PPRINT (p383)Category:     ADDITIONEdit history: 22-Jun-88, Version 1 by Pitman (2d model)	      23-Jun-88, Version 2 by Waters (1d model, modified 2d model)	      24-Jun-88, Version 3 by Pitman (minor reformatting)	      24-Jun-88, Version 4 by Pitman (remove 2d model for submission)              23-Sep-88, Version 5 by Waters (cleaned up in response todiscussion)             30-Nov-88, Version 6 by Masinter (add discussion)Problem Description:  Currently, there is no portable way to inquire about the line width of  an output stream, the current position on a line, or the amount of  space that the display of a string will take up.  This makes it  essentially impossible to write a portable implementation of a pretty  printer.Proposal STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS:  Introduce four new functions.       These functions are carefully designed with an eye to the way they  interact.  As a result, they can only be defined fully in terms of  each other.  The presentation below first gives a very brief  definition of each function and then gives detailed specifications of  their relationships.   LINE-WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)       [Function]    Returns a number representing the line width available    when printing to OUTPUT-STREAM.  If the stream has no meaningful    width (or the width cannot be computed) then NIL is returned.   LINE-POSITION &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)    [Function]    Returns a number representing the current horizontal    position on the current output line, or NIL if the position cannot    be computed.   WRITE-SPACE WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*) [function]    Inserts blank space of length WIDTH into OUTPUT-STREAM.  WIDTH must    be a non-negative number.  WRITE-SPACE returns T if the operation    is successful and NIL otherwise (e.g., if the operation is not    supported by OUTPUT-STREAM).   PRINTED-WIDTH STRING &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)		        &key (START 0) (END NIL)                [Function]      Returns a number representing the horizontal width that would be    required to display STRING if it were written at the current moment    to OUTPUT-STREAM using (WRITE-STRING STRING OUTPUT-STREAM :start    START :end END), or NIL if this width cannot be computed.  The width    may be negative (e.g., if STRING contains backspace or newline    characters.)      PRINTED-WIDTH does not return any indication of the vertical    distance required when printing STRING.  The START and END    parameters delimit a substring of STRING in the usual manner.    PRINTED-WIDTH never causes any change in the state of OUTPUT-STREAM.      The width returned may well depend on the current state of    OUTPUT-STREAM (e.g., the width of tabs depends on the line position    and the width of characters depends on the font in use.)  In all    respects the width is computed based on the current state of the    stream.  However, the width returned always assumes that the total    line width is infinite---i.e., does not reflect any wraparound or    truncation which might occur.  -The difficulties of a full specification:    The functions above are intended to solve a specific current problem    in CL.  To serve this purpose, they must have reasonably precise    specifications.  However, there are several things which make it    desirable to have specifications which allow for significant    variability between implementations.  First, current implementations    of CL differ greatly in the way IO is supported, and overly strict    specifications might make things very difficult for certain    implementations.  Second, CL places no limits on the kinds of    idiosyncratic characters which can be supported by particular    implementations.  Third, while many CL implementations only support    the printing of characters in fixed width fonts, it is desirable to    allow for output streams that support variable width fonts.    Finally, it is desirable to leave room to move for the future.  -Operations on standard characters where the line-width has not yet beenexceeded.    To deal with the problems above, a layered specification is    provided.   The lowest level specification is given in terms of    constraints between the four functions above.  In this lowest level    specification, two key simplifying assumptions are made.  First, it    is assumed that at the time the constraint applies, none of the    previous operations on the stream S in question have caused output    to go beyond the physical horizontal limits of the output device on    the output lines relevant to the constraints.  I.e., it is assumed    that truncation and or wraparound of the output has not occurred on    these lines.  Second, it is assumed that all of the characters    output to the stream on the output lines relevant to the constraints    are standard characters as defined in CLTL pp 20-21.  The    non-standard character #\newline may have been used to end one line    and start the next.  (Note that standard characters are all simple    characters such as A-Z.  Particularly, #\tab, #\backspace,    #\newline, are NOT standard characters.)  It is further assumed that    the strings (X and Y) referred to in the constraints consist solely    of standard characters.    Basic properties of LINE-POSITION:    1- For all S, (not (minusp (line-position S)).    2- For all S, (zerop (line-position (progn (terpri S) S))).    3- For all S, If something is at line position N on one line and       something else is at line position N on another line, then the       two things are lined up vertically one under the other.          Defining property of WRITE-SPACE    4- For all N,S, let M = (+ (line-position S) N)         if M <= (line-width S), then            (= (line-position (progn (write-space N S) S)) M)    Defining property of PRINTED-WIDTH    5- For all X,S, let M = (+ (line-position S) (printed-width X))         if 0 <= M <= (line-width S), then            (= (line-position (progn (write-string X S) S)) M)    Basic property of LINE-WIDTH    6- For all N,S, let P = (line-position S)        If (+ P N) <= (line-width S) then           (write-space N S) is guaranteed to output space on the end of           the current line without any truncation of wraparound occurring.    7- For all X,S, let P = (line-position S)        If 0 <= (+ P (printed-width X)) <= (line-width S) then           (write-string X S) is guaranteed to output X on the end of           the current line without any truncation of wraparound occurring.    Additional properties of PRINTED-WIDTH    8-  For all X,Y (= (printed-width (concatenate 'string X Y) S)		       (+ (printed-width X S) (printed-width Y S)))    9-  For all X,Z (= (printed-width X S)		       (progn (write-string Z S) (printed-width X S)))  -Support for varying width fonts.    A key motivation behind the functions above is dealing with    arbitrary kinds of output devices and output streams that support    variable width fonts.  To provide for this, the properties above    place no absolute constraints on the units used for the width    values.  In fact, the units can vary from stream to stream.  The    only thing that is required is that for a given stream, the units    must be a constant throughout the life of the stream, and the four    functions above must all operate in terms of the same units.  The    units should be chosen to be small enough to represent the minimum    possible difference in the length of two strings and large enough    that it is possible to perform (write-space 1).  (I.e., a single    pixel is a logical choice.)    If an output stream only supports a single fixed width font, then    the logical width unit to choose is the width of a single character.    Given this choice, the following is a minimal implementation of the    four functions that meets the requirements above.	    LINE-WIDTH returns the maximum number of characters which can be    printed on a single line.  LINE-POSITION returns the number of    characters output since the last #\newline (or since the creation of    the stream if no #\newlines have been output).  (WRITE-SPACE N S)    outputs N #\space characters.  Finally, (PRINTED-LENGTH X S) =    (length X).  -Support for non-standard characters and situations where line width    has been exceeded.    In the main, the properties above can be supported even if the line    width has been exceeded and even when non-standard charactres are    involved.  However, characters such as #\tab and #\newline can make    it impossible to support properties 7 and 8.  In addition, when the    line width is exceeded, property 3 may not hold.  It is hoped that    implementors will make a good faith effort to support the functions    in the full range of situations which can be encountered in their CL    implementations.  However, the simple implementation suggested above    will probably provide at least 80% of the benefits intended.  As a    result, it is important that people not allow the potential    difficulties of a full implementation deter them from making a    minimal implementation.  -Support for derivative streams.      Intentionally, very little is said about what the width units should    be or exactly what LINE-WIDTH should return.  The only key criterion    is that LINE-WIDTH should return a result that is pessimistic enough    to ensure proper printing.  However, it is useful to make some    comments about these matters with regard to certain types of    derivative streams.    If a synonym stream, two way stream, or echo stream is created, itshould    have the same line-width and width unit as the base output stream.    A string output stream should have a line-width of NIL and probably    should be treated as supporting a fixed width font and having an    output width unit so that each character has a printed-width of 1.    If a broadcast stream is created, then LINE-LENGTH, LINE-POSITION,    and PRINTED-WIDTH should be be supported by reflecting them through    to the FIRST base stream.  (There is no guarantee that anything    reasonable can be done with the streams as a set.  For example, one    might support a varying length font while the others don't.)  An    attempt should be made to send WRITE-SPACE requests to all of the    base streams.  However, they may not come out right on other than    the first base stream.Test Case:  Suppose that S is an output stream that supports a single fixed  width font which can display 72 characters on a line and that the  associated width unit is the width of one character.  Evaluating the  following will produce the results shown.  (line-width S) => 72  (terpri S) => nil  (output-position S) => 0  (printed-width "testing: " S) => 9  (write-string "testing: " S) => "testing: "  (line-position S) => 9  (write-string "foo" S) => "foo"  (terpri S) => nil  (write-space 9 S) => T  (write-string "bar" S) => "bar"  The output produced istesting: foo	 barRationale:  Pretty printing requires the function LINE-WIDTH to know how wide the  output it produces can be.  Pretty printing requires LINE-POSITION to  determine where on the line output is when pretty printing starts.  Pretty printing requires PRINTED-WIDTH to determine how much space  things will take in the output.  (If a variable width font is being  used, this cannot be determined without a detailed knowledge of the  font being used.)  (Properties 7 & 8 greatly reduce the number of  times PRINTED-WIDTH has to be called.)  Pretty printing requires  WRITE-SPACE to get proper indentations.  (If a variable width font is  being used, indentations may be required that cannot be obtained by  outputting spaces.)Current Practice:  Essentially every implementation of Common Lisp must support the  minimal functionality above internally in order to support PPRINT and  the FORMAT directives ~T and ~<...~>.  However, there is no documented  interface to this functionality in CLTL.  As a result, while some  implementations of Common Lisp make this functionality available to  users, some do not.  Further, the implementations that do provide  this functionality do so in a variety of incompatible ways.Cost to Implementors:  This proposal is written in such a way as to allow implementations  which do not have the ability to compute difficult values to just  return NIL.  Very little work is forced.  The idea is to offer  implementors a common way to provide this useful information to  portable programs where possible.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Complex output programs such as pretty printers cannot be writtenportably.Benefits:  A wide range of programs can gain better control of the format of output.Aesthetics:  No significant aesthetic impact other than a slight increase in the  number of functions defined.Discussion:This issue probably should have been called PRETTY-PRINT-WIDTH-SUPPORT.Dick Waters (author of GPRINT, a portable pretty printer), originallyraised this issue.STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS is the minimum required to supportpretty printing into a stream which displays output using a variable widthfont.Originally the functions were defined to return integers; however, thereare some output devices (e.g., those that have arbitrary scalingoperations), for which it would be difficult to find a reasonableleast-common-denominator for line-width.We considered an alternate proposal which goes significantly beyond what isneeded merely for pretty printing   and provides primitivesLINE-DIMENSIONS, LINE-POSITION,   PRINTED-DIMENSIONS, and WRITE-SPACE butit is not included here. A key point of contention was the question of howto handle the issue of vertical distance   (where is the origin, which waydo you count, ...).We considered requiring   PRINTED-WIDTH to return two additional values:the number of newlines that WRITE-STRING of the string would execute andthe maximum X position encountered (which might differ from the first valueif the number of newlines was non-zero).This feature wasn't strictly necessary for pretty-printing, and so wasomitted.Some of the draft proposals from the character committee contained someproposed functions that were attempting to solve the same problem.Conflicting proposals should be avoided.*start*01273 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 DEC 88 12:17:59 PSTReceived: from rice-chex.ai.mit.edu ([128.52.38.46]) by SAIL.Stanford.EDU with TCP; 1 Dec 88  12:16:31 PSTReceived: by rice-chex.ai.mit.edu; Thu, 1 Dec 88 15:15:56 ESTDate: Thu, 1 Dec 88 15:15:56 ESTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8812012015.AA08590@rice-chex.ai.mit.edu>To: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@xerox.com's message of 30 Nov 88 18:10 PST <881130-181526-3544@Xerox>Subject: Issue: STREAM-INFO (Version 6)      Return-Path: <masinter.pa@xerox.com>      Date: 30 Nov 88 18:10 PST      From: masinter.pa@xerox.com      Subject: Issue: STREAM-INFO (Version 6)      To: cl-cleanup@sail.stanford.edu      Cc: dick@wheaties.ai.mit.edu (Richard C. Waters)      Reply-To: cl-cleanup@sail.stanford.edu      Cc: Masinter.pa@xerox.com      Issue:        STREAM-INFO      We have not yet responded to RWK's comment, viz "Want less generic names.      eg, maybe STREAM-xxx".       What do you think about STREAM-LINE-WIDTH, STREAM-WRITE-SPACE, etc?Prefixing the names with "STREAM-" is fine with me.*start*01417 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 30 NOV 88 22:52:38 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 500534; Thu 1-Dec-88 01:53:17 ESTDate: Thu, 1 Dec 88 01:53 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 6)To: Masinter.pacc: Dick@Wheaties.AI.MIT.EDU, CL-Cleanup@sail.stanford.eduIn-Reply-To: <881130-181526-3544@Xerox>Message-ID: <881201015306.8.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 30 Nov 88 18:10 PST    From: masinter.pa@Xerox.COM    We have not yet responded to RWK's comment, viz "Want less generic names.    eg, maybe STREAM-xxx".     What do you think about STREAM-LINE-WIDTH, STREAM-WRITE-SPACE, etc?I don't really like the STREAM-xxx but can live with it as a compromise if itwill get this thing passed.STREAM-LINE-WIDTH is ok with me.STREAM-WRITE-SPACE seems redundant since WRITE is already a stream operation. I guess I'd prefer just WRITE-SPACE.LINE-POSITION could be STREAM-LINE-POSITION, conforming to the STREAM-xxx idea.PRINTED-WIDTH is misleadingly named (in my opinion) because the function PRINT is not involved. Since I think STREAM-WRITTEN-WIDTH looks a little weird, I guess I'd like something like STREAM-STRING-WIDTH better.*start*15743 00024 US Date:  9 Dec 88 10:02 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: STREAM-INFO (Version 6)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noAn amendment to this proposal is under consideration, to changethe following names:LINE-WIDTH   ==> STREAM-LINE-WIDTHLINE-POSITION ==> STREAM-LINE-POSITIONPRINTED-WIDTH ==> STREAM-STRING-WIDTH("PRINTED-WIDTH is misleadingly named (in my opinion) because the function PRINT is not involved. STREAM-WRITTEN-WIDTH looks a little weird.)Forum:        CleanupIssue:        STREAM-INFOReferences:   FORMAT ~T (pp398-9) and ~<...~> (pp404-6), PPRINT (p383)Category:     ADDITIONEdit history: 22-Jun-88, Version 1 by Pitman (2d model)              23-Jun-88, Version 2 by Waters (1d model, modified 2d model)              24-Jun-88, Version 3 by Pitman (minor reformatting)              24-Jun-88, Version 4 by Pitman (remove 2d model for submission)              23-Sep-88, Version 5 by Waters (cleaned up in response to								discussion)             30-Nov-88, Version 6 by Masinter (add discussion)Problem Description:  Currently, there is no portable way to inquire about the line width of  an output stream, the current position on a line, or the amount of  space that the display of a string will take up.  This makes it  essentially impossible to write a portable implementation of a pretty  printer.Proposal STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS:  Introduce four new functions.       These functions are carefully designed with an eye to the way they  interact.  As a result, they can only be defined fully in terms of  each other.  The presentation below first gives a very brief  definition of each function and then gives detailed specifications of  their relationships.   LINE-WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)       [Function]    Returns a number representing the line width available    when printing to OUTPUT-STREAM.  If the stream has no meaningful    width (or the width cannot be computed) then NIL is returned.   LINE-POSITION &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)    [Function]    Returns a number representing the current horizontal    position on the current output line, or NIL if the position cannot    be computed.   WRITE-SPACE WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*) [function]    Inserts blank space of length WIDTH into OUTPUT-STREAM.  WIDTH must    be a non-negative number.  WRITE-SPACE returns T if the operation    is successful and NIL otherwise (e.g., if the operation is not    supported by OUTPUT-STREAM).   PRINTED-WIDTH STRING &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)		        &key (START 0) (END NIL)                [Function]      Returns a number representing the horizontal width that would be    required to display STRING if it were written at the current moment    to OUTPUT-STREAM using (WRITE-STRING STRING OUTPUT-STREAM :start    START :end END), or NIL if this width cannot be computed.  The width    may be negative (e.g., if STRING contains backspace or newline    characters.)      PRINTED-WIDTH does not return any indication of the vertical    distance required when printing STRING.  The START and END    parameters delimit a substring of STRING in the usual manner.    PRINTED-WIDTH never causes any change in the state of OUTPUT-STREAM.      The width returned may well depend on the current state of    OUTPUT-STREAM (e.g., the width of tabs depends on the line position    and the width of characters depends on the font in use.)  In all    respects the width is computed based on the current state of the    stream.  However, the width returned always assumes that the total    line width is infinite---i.e., does not reflect any wraparound or    truncation which might occur.  -The difficulties of a full specification:    The functions above are intended to solve a specific current problem    in CL.  To serve this purpose, they must have reasonably precise    specifications.  However, there are several things which make it    desirable to have specifications which allow for significant    variability between implementations.  First, current implementations    of CL differ greatly in the way IO is supported, and overly strict    specifications might make things very difficult for certain    implementations.  Second, CL places no limits on the kinds of    idiosyncratic characters which can be supported by particular    implementations.  Third, while many CL implementations only support    the printing of characters in fixed width fonts, it is desirable to    allow for output streams that support variable width fonts.    Finally, it is desirable to leave room to move for the future.  -Operations on standard characters where the line-width has not yet been    exceeded.    To deal with the problems above, a layered specification is    provided.   The lowest level specification is given in terms of    constraints between the four functions above.  In this lowest level    specification, two key simplifying assumptions are made.  First, it    is assumed that at the time the constraint applies, none of the    previous operations on the stream S in question have caused output    to go beyond the physical horizontal limits of the output device on    the output lines relevant to the constraints.  I.e., it is assumed    that truncation and or wraparound of the output has not occurred on    these lines.  Second, it is assumed that all of the characters    output to the stream on the output lines relevant to the constraints    are standard characters as defined in CLTL pp 20-21.  The    non-standard character #\newline may have been used to end one line    and start the next.  (Note that standard characters are all simple    characters such as A-Z.  Particularly, #\tab, #\backspace,    #\newline, are NOT standard characters.)  It is further assumed that    the strings (X and Y) referred to in the constraints consist solely    of standard characters.    Basic properties of LINE-POSITION:    1- For all S, (not (minusp (line-position S)).    2- For all S, (zerop (line-position (progn (terpri S) S))).    3- For all S, If something is at line position N on one line and       something else is at line position N on another line, then the       two things are lined up vertically one under the other.          Defining property of WRITE-SPACE    4- For all N,S, let M = (+ (line-position S) N)         if M <= (line-width S), then            (= (line-position (progn (write-space N S) S)) M)    Defining property of PRINTED-WIDTH    5- For all X,S, let M = (+ (line-position S) (printed-width X))         if 0 <= M <= (line-width S), then            (= (line-position (progn (write-string X S) S)) M)    Basic property of LINE-WIDTH    6- For all N,S, let P = (line-position S)        If (+ P N) <= (line-width S) then           (write-space N S) is guaranteed to output space on the end of           the current line without any truncation of wraparound occurring.    7- For all X,S, let P = (line-position S)        If 0 <= (+ P (printed-width X)) <= (line-width S) then           (write-string X S) is guaranteed to output X on the end of           the current line without any truncation of wraparound occurring.    Additional properties of PRINTED-WIDTH    8-  For all X,Y (= (printed-width (concatenate 'string X Y) S)		       (+ (printed-width X S) (printed-width Y S)))    9-  For all X,Z (= (printed-width X S)		       (progn (write-string Z S) (printed-width X S)))  -Support for varying width fonts.    A key motivation behind the functions above is dealing with    arbitrary kinds of output devices and output streams that support    variable width fonts.  To provide for this, the properties above    place no absolute constraints on the units used for the width    values.  In fact, the units can vary from stream to stream.  The    only thing that is required is that for a given stream, the units    must be a constant throughout the life of the stream, and the four    functions above must all operate in terms of the same units.  The    units should be chosen to be small enough to represent the minimum    possible difference in the length of two strings and large enough    that it is possible to perform (write-space 1).  (I.e., a single    pixel is a logical choice.)    If an output stream only supports a single fixed width font, then    the logical width unit to choose is the width of a single character.    Given this choice, the following is a minimal implementation of the    four functions that meets the requirements above.	    LINE-WIDTH returns the maximum number of characters which can be    printed on a single line.  LINE-POSITION returns the number of    characters output since the last #\newline (or since the creation of    the stream if no #\newlines have been output).  (WRITE-SPACE N S)    outputs N #\space characters.  Finally, (PRINTED-LENGTH X S) =    (length X).  -Support for non-standard characters and situations where line width    has been exceeded.    In the main, the properties above can be supported even if the line    width has been exceeded and even when non-standard charactres are    involved.  However, characters such as #\tab and #\newline can make    it impossible to support properties 7 and 8.  In addition, when the    line width is exceeded, property 3 may not hold.  It is hoped that    implementors will make a good faith effort to support the functions    in the full range of situations which can be encountered in their CL    implementations.  However, the simple implementation suggested above    will probably provide at least 80% of the benefits intended.  As a    result, it is important that people not allow the potential    difficulties of a full implementation deter them from making a    minimal implementation.  -Support for derivative streams.      Intentionally, very little is said about what the width units should    be or exactly what LINE-WIDTH should return.  The only key criterion    is that LINE-WIDTH should return a result that is pessimistic enough    to ensure proper printing.  However, it is useful to make some    comments about these matters with regard to certain types of    derivative streams.    If a synonym stream, two way stream, or echo stream is created, it    should have the same line-width and width unit as the base output    stream.    A string output stream should have a line-width of NIL and probably    should be treated as supporting a fixed width font and having an    output width unit so that each character has a printed-width of 1.    If a broadcast stream is created, then LINE-LENGTH, LINE-POSITION,    and PRINTED-WIDTH should be be supported by reflecting them through    to the FIRST base stream.  (There is no guarantee that anything    reasonable can be done with the streams as a set.  For example, one    might support a varying length font while the others don't.)  An    attempt should be made to send WRITE-SPACE requests to all of the    base streams.  However, they may not come out right on other than    the first base stream.Test Case:  Suppose that S is an output stream that supports a single fixed  width font which can display 72 characters on a line and that the  associated width unit is the width of one character.  Evaluating the  following will produce the results shown.  (line-width S) => 72  (terpri S) => nil  (output-position S) => 0  (printed-width "testing: " S) => 9  (write-string "testing: " S) => "testing: "  (line-position S) => 9  (write-string "foo" S) => "foo"  (terpri S) => nil  (write-space 9 S) => T  (write-string "bar" S) => "bar"  The output produced istesting: foo	 barRationale:  Pretty printing requires the function LINE-WIDTH to know how wide the  output it produces can be.  Pretty printing requires LINE-POSITION to  determine where on the line output is when pretty printing starts.  Pretty printing requires PRINTED-WIDTH to determine how much space  things will take in the output.  (If a variable width font is being  used, this cannot be determined without a detailed knowledge of the  font being used.)  (Properties 7 & 8 greatly reduce the number of  times PRINTED-WIDTH has to be called.)  Pretty printing requires  WRITE-SPACE to get proper indentations.  (If a variable width font is  being used, indentations may be required that cannot be obtained by  outputting spaces.)Current Practice:  Essentially every implementation of Common Lisp must support the  minimal functionality above internally in order to support PPRINT and  the FORMAT directives ~T and ~<...~>.  However, there is no documented  interface to this functionality in CLTL.  As a result, while some  implementations of Common Lisp make this functionality available to  users, some do not.  Further, the implementations that do provide  this functionality do so in a variety of incompatible ways.Cost to Implementors:  This proposal is written in such a way as to allow implementations  which do not have the ability to compute difficult values to just  return NIL.  Very little work is forced.  The idea is to offer  implementors a common way to provide this useful information to  portable programs where possible.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Complex output programs such as pretty printers cannot be written  portably.Benefits:  A wide range of programs can gain better control of the format of output.Aesthetics:  No significant aesthetic impact other than a slight increase in the  number of functions defined.Discussion:This issue probably should have been called PRETTY-PRINT-WIDTH-SUPPORT.Dick Waters (author of GPRINT, a portable pretty printer), originallyraised this issue.STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS is the minimum required to supportpretty printing into a stream which displays output using a variable widthfont.Originally the functions were defined to return integers; however, thereare some output devices (e.g., those that have arbitrary scalingoperations), for which it would be difficult to find a reasonableleast-common-denominator for line-width.We considered an alternate proposal which goes significantly beyond what isneeded merely for pretty printing   and provides primitivesLINE-DIMENSIONS, LINE-POSITION,   PRINTED-DIMENSIONS, and WRITE-SPACE butit is not included here. A key point of contention was the question of howto handle the issue of vertical distance   (where is the origin, which waydo you count, ...).We considered requiring   PRINTED-WIDTH to return two additional values:the number of newlines that WRITE-STRING of the string would execute andthe maximum X position encountered (which might differ from the first valueif the number of newlines was non-zero).This feature wasn't strictly necessary for pretty-printing, and so wasomitted.Some of the draft proposals from the character committee contained someproposed functions that were attempting to solve the same problem.Conflicting proposals should be avoided.        TITAN 
         TITAN 
           Z              s      U                                          9              	                          &       0      &l             L                                       2              ,              R       
       N              g                   ; $z*start*15689 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 10:27:11 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  10:07:50 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 10:03:19 PSTDate: 9 Dec 88 10:02 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: STREAM-INFO (Version 6)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881209-100319-6354@Xerox>An amendment to this proposal is under consideration, to changethe following names:LINE-WIDTH   ==> STREAM-LINE-WIDTHLINE-POSITION ==> STREAM-LINE-POSITIONPRINTED-WIDTH ==> STREAM-STRING-WIDTH("PRINTED-WIDTH is misleadingly named (in my opinion) because the function PRINT is not involved. STREAM-WRITTEN-WIDTH looks a little weird.)!Forum:        CleanupIssue:        STREAM-INFOReferences:   FORMAT ~T (pp398-9) and ~<...~> (pp404-6), PPRINT (p383)Category:     ADDITIONEdit history: 22-Jun-88, Version 1 by Pitman (2d model)              23-Jun-88, Version 2 by Waters (1d model, modified 2d model)              24-Jun-88, Version 3 by Pitman (minor reformatting)              24-Jun-88, Version 4 by Pitman (remove 2d model for submission)              23-Sep-88, Version 5 by Waters (cleaned up in response to								discussion)             30-Nov-88, Version 6 by Masinter (add discussion)Problem Description:  Currently, there is no portable way to inquire about the line width of  an output stream, the current position on a line, or the amount of  space that the display of a string will take up.  This makes it  essentially impossible to write a portable implementation of a pretty  printer.Proposal STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS:  Introduce four new functions.       These functions are carefully designed with an eye to the way they  interact.  As a result, they can only be defined fully in terms of  each other.  The presentation below first gives a very brief  definition of each function and then gives detailed specifications of  their relationships.   LINE-WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)       [Function]    Returns a number representing the line width available    when printing to OUTPUT-STREAM.  If the stream has no meaningful    width (or the width cannot be computed) then NIL is returned.   LINE-POSITION &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)    [Function]    Returns a number representing the current horizontal    position on the current output line, or NIL if the position cannot    be computed.   WRITE-SPACE WIDTH &optional (OUTPUT-STREAM *STANDARD-OUTPUT*) [function]    Inserts blank space of length WIDTH into OUTPUT-STREAM.  WIDTH must    be a non-negative number.  WRITE-SPACE returns T if the operation    is successful and NIL otherwise (e.g., if the operation is not    supported by OUTPUT-STREAM).   PRINTED-WIDTH STRING &optional (OUTPUT-STREAM *STANDARD-OUTPUT*)		        &key (START 0) (END NIL)                [Function]      Returns a number representing the horizontal width that would be    required to display STRING if it were written at the current moment    to OUTPUT-STREAM using (WRITE-STRING STRING OUTPUT-STREAM :start    START :end END), or NIL if this width cannot be computed.  The width    may be negative (e.g., if STRING contains backspace or newline    characters.)      PRINTED-WIDTH does not return any indication of the vertical    distance required when printing STRING.  The START and END    parameters delimit a substring of STRING in the usual manner.    PRINTED-WIDTH never causes any change in the state of OUTPUT-STREAM.      The width returned may well depend on the current state of    OUTPUT-STREAM (e.g., the width of tabs depends on the line position    and the width of characters depends on the font in use.)  In all    respects the width is computed based on the current state of the    stream.  However, the width returned always assumes that the total    line width is infinite---i.e., does not reflect any wraparound or    truncation which might occur.  -The difficulties of a full specification:    The functions above are intended to solve a specific current problem    in CL.  To serve this purpose, they must have reasonably precise    specifications.  However, there are several things which make it    desirable to have specifications which allow for significant    variability between implementations.  First, current implementations    of CL differ greatly in the way IO is supported, and overly strict    specifications might make things very difficult for certain    implementations.  Second, CL places no limits on the kinds of    idiosyncratic characters which can be supported by particular    implementations.  Third, while many CL implementations only support    the printing of characters in fixed width fonts, it is desirable to    allow for output streams that support variable width fonts.    Finally, it is desirable to leave room to move for the future.  -Operations on standard characters where the line-width has not yet been    exceeded.    To deal with the problems above, a layered specification is    provided.   The lowest level specification is given in terms of    constraints between the four functions above.  In this lowest level    specification, two key simplifying assumptions are made.  First, it    is assumed that at the time the constraint applies, none of the    previous operations on the stream S in question have caused output    to go beyond the physical horizontal limits of the output device on    the output lines relevant to the constraints.  I.e., it is assumed    that truncation and or wraparound of the output has not occurred on    these lines.  Second, it is assumed that all of the characters    output to the stream on the output lines relevant to the constraints    are standard characters as defined in CLTL pp 20-21.  The    non-standard character #\newline may have been used to end one line    and start the next.  (Note that standard characters are all simple    characters such as A-Z.  Particularly, #\tab, #\backspace,    #\newline, are NOT standard characters.)  It is further assumed that    the strings (X and Y) referred to in the constraints consist solely    of standard characters.    Basic properties of LINE-POSITION:    1- For all S, (not (minusp (line-position S)).    2- For all S, (zerop (line-position (progn (terpri S) S))).    3- For all S, If something is at line position N on one line and       something else is at line position N on another line, then the       two things are lined up vertically one under the other.          Defining property of WRITE-SPACE    4- For all N,S, let M = (+ (line-position S) N)         if M <= (line-width S), then            (= (line-position (progn (write-space N S) S)) M)    Defining property of PRINTED-WIDTH    5- For all X,S, let M = (+ (line-position S) (printed-width X))         if 0 <= M <= (line-width S), then            (= (line-position (progn (write-string X S) S)) M)    Basic property of LINE-WIDTH    6- For all N,S, let P = (line-position S)        If (+ P N) <= (line-width S) then           (write-space N S) is guaranteed to output space on the end of           the current line without any truncation of wraparound occurring.    7- For all X,S, let P = (line-position S)        If 0 <= (+ P (printed-width X)) <= (line-width S) then           (write-string X S) is guaranteed to output X on the end of           the current line without any truncation of wraparound occurring.    Additional properties of PRINTED-WIDTH    8-  For all X,Y (= (printed-width (concatenate 'string X Y) S)		       (+ (printed-width X S) (printed-width Y S)))    9-  For all X,Z (= (printed-width X S)		       (progn (write-string Z S) (printed-width X S)))  -Support for varying width fonts.    A key motivation behind the functions above is dealing with    arbitrary kinds of output devices and output streams that support    variable width fonts.  To provide for this, the properties above    place no absolute constraints on the units used for the width    values.  In fact, the units can vary from stream to stream.  The    only thing that is required is that for a given stream, the units    must be a constant throughout the life of the stream, and the four    functions above must all operate in terms of the same units.  The    units should be chosen to be small enough to represent the minimum    possible difference in the length of two strings and large enough    that it is possible to perform (write-space 1).  (I.e., a single    pixel is a logical choice.)    If an output stream only supports a single fixed width font, then    the logical width unit to choose is the width of a single character.    Given this choice, the following is a minimal implementation of the    four functions that meets the requirements above.	    LINE-WIDTH returns the maximum number of characters which can be    printed on a single line.  LINE-POSITION returns the number of    characters output since the last #\newline (or since the creation of    the stream if no #\newlines have been output).  (WRITE-SPACE N S)    outputs N #\space characters.  Finally, (PRINTED-LENGTH X S) =    (length X).  -Support for non-standard characters and situations where line width    has been exceeded.    In the main, the properties above can be supported even if the line    width has been exceeded and even when non-standard charactres are    involved.  However, characters such as #\tab and #\newline can make    it impossible to support properties 7 and 8.  In addition, when the    line width is exceeded, property 3 may not hold.  It is hoped that    implementors will make a good faith effort to support the functions    in the full range of situations which can be encountered in their CL    implementations.  However, the simple implementation suggested above    will probably provide at least 80% of the benefits intended.  As a    result, it is important that people not allow the potential    difficulties of a full implementation deter them from making a    minimal implementation.  -Support for derivative streams.      Intentionally, very little is said about what the width units should    be or exactly what LINE-WIDTH should return.  The only key criterion    is that LINE-WIDTH should return a result that is pessimistic enough    to ensure proper printing.  However, it is useful to make some    comments about these matters with regard to certain types of    derivative streams.    If a synonym stream, two way stream, or echo stream is created, it    should have the same line-width and width unit as the base output    stream.    A string output stream should have a line-width of NIL and probably    should be treated as supporting a fixed width font and having an    output width unit so that each character has a printed-width of 1.    If a broadcast stream is created, then LINE-LENGTH, LINE-POSITION,    and PRINTED-WIDTH should be be supported by reflecting them through    to the FIRST base stream.  (There is no guarantee that anything    reasonable can be done with the streams as a set.  For example, one    might support a varying length font while the others don't.)  An    attempt should be made to send WRITE-SPACE requests to all of the    base streams.  However, they may not come out right on other than    the first base stream.Test Case:  Suppose that S is an output stream that supports a single fixed  width font which can display 72 characters on a line and that the  associated width unit is the width of one character.  Evaluating the  following will produce the results shown.  (line-width S) => 72  (terpri S) => nil  (output-position S) => 0  (printed-width "testing: " S) => 9  (write-string "testing: " S) => "testing: "  (line-position S) => 9  (write-string "foo" S) => "foo"  (terpri S) => nil  (write-space 9 S) => T  (write-string "bar" S) => "bar"  The output produced istesting: foo	 barRationale:  Pretty printing requires the function LINE-WIDTH to know how wide the  output it produces can be.  Pretty printing requires LINE-POSITION to  determine where on the line output is when pretty printing starts.  Pretty printing requires PRINTED-WIDTH to determine how much space  things will take in the output.  (If a variable width font is being  used, this cannot be determined without a detailed knowledge of the  font being used.)  (Properties 7 & 8 greatly reduce the number of  times PRINTED-WIDTH has to be called.)  Pretty printing requires  WRITE-SPACE to get proper indentations.  (If a variable width font is  being used, indentations may be required that cannot be obtained by  outputting spaces.)Current Practice:  Essentially every implementation of Common Lisp must support the  minimal functionality above internally in order to support PPRINT and  the FORMAT directives ~T and ~<...~>.  However, there is no documented  interface to this functionality in CLTL.  As a result, while some  implementations of Common Lisp make this functionality available to  users, some do not.  Further, the implementations that do provide  this functionality do so in a variety of incompatible ways.Cost to Implementors:  This proposal is written in such a way as to allow implementations  which do not have the ability to compute difficult values to just  return NIL.  Very little work is forced.  The idea is to offer  implementors a common way to provide this useful information to  portable programs where possible.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Complex output programs such as pretty printers cannot be written  portably.Benefits:  A wide range of programs can gain better control of the format of output.Aesthetics:  No significant aesthetic impact other than a slight increase in the  number of functions defined.Discussion:This issue probably should have been called PRETTY-PRINT-WIDTH-SUPPORT.Dick Waters (author of GPRINT, a portable pretty printer), originallyraised this issue.STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS is the minimum required to supportpretty printing into a stream which displays output using a variable widthfont.Originally the functions were defined to return integers; however, thereare some output devices (e.g., those that have arbitrary scalingoperations), for which it would be difficult to find a reasonableleast-common-denominator for line-width.We considered an alternate proposal which goes significantly beyond what isneeded merely for pretty printing   and provides primitivesLINE-DIMENSIONS, LINE-POSITION,   PRINTED-DIMENSIONS, and WRITE-SPACE butit is not included here. A key point of contention was the question of howto handle the issue of vertical distance   (where is the origin, which waydo you count, ...).We considered requiring   PRINTED-WIDTH to return two additional values:the number of newlines that WRITE-STRING of the string would execute andthe maximum X position encountered (which might differ from the first valueif the number of newlines was non-zero).This feature wasn't strictly necessary for pretty-printing, and so wasomitted.Some of the draft proposals from the character committee contained someproposed functions that were attempting to solve the same problem.Conflicting proposals should be avoided.*start*01433 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 28 JUN 88 09:22:30 PDTReceived: from hudson.dec.com by SAIL.Stanford.EDU with TCP; 28 Jun 88  09:19:22 PDTDate: 28 Jun 88 12:04:00 EDTFrom: "BACH::VANROGGEN" <vanroggen%bach.decnet@hudson.dec.com>To: "cl-cleanup" <cl-cleanup@sail.stanford.edu>Reply-To: "BACH::VANROGGEN" <vanroggen%bach.decnet@hudson.dec.com>I dislike the names OUTPUT-WIDTH and OUTPUT-POSITION for several reasons:(1) It's ambiguous--the "position" could be for the whole stream outputso far instead of just the current line.(2) VAX LISP already has exactly the functionality of OUTPUT-POSITION butwith the name LINE-POSITION.  VAX LISP also has a function calledRIGHT-MARGIN, which might be the same as OUTPUT-WIDTH, but I'm not sure.Is the intent of OUTPUT-WIDTH to provide an indication to the prettyprinter of how far it knows it can print towards the side?  Is it meantto be an absolute limit, in that printing beyond that point is undefined?What should the OUTPUT-WIDTH of string streams be?  In VAX LISP, theRIGHT-MARGIN of string streams is 80, but we allow users to override howfar the printer goes before inserting newlines.A lesser name complaint is OUTPUT-SPACE might be better named WRITE-SPACEto match the other WRITE-xxx functions.			---Walter------*start*01030 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 20:21:09 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 12 Dec 88  20:19:36 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 507662; Mon 12-Dec-88 23:18:59 ESTDate: Mon, 12 Dec 88 23:19 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 6)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881209-100319-6354@Xerox>Message-ID: <19881213041909.9.MOON@EUPHRATES.SCRC.Symbolics.COM>[X3J13 removed]Approved only if the name-changing amendment mentioned in the mail passes.The writeup incorrectly states that Newline is not a standard character; Isuspect someone has confused "standard" with "graphic".  If for some reasonthe proposal is edited again, this should be fixed.*start*01433 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 28 JUN 88 09:22:30 PDTReceived: from hudson.dec.com by SAIL.Stanford.EDU with TCP; 28 Jun 88  09:19:22 PDTDate: 28 Jun 88 12:04:00 EDTFrom: "BACH::VANROGGEN" <vanroggen%bach.decnet@hudson.dec.com>To: "cl-cleanup" <cl-cleanup@sail.stanford.edu>Reply-To: "BACH::VANROGGEN" <vanroggen%bach.decnet@hudson.dec.com>I dislike the names OUTPUT-WIDTH and OUTPUT-POSITION for several reasons:(1) It's ambiguous--the "position" could be for the whole stream outputso far instead of just the current line.(2) VAX LISP already has exactly the functionality of OUTPUT-POSITION butwith the name LINE-POSITION.  VAX LISP also has a function calledRIGHT-MARGIN, which might be the same as OUTPUT-WIDTH, but I'm not sure.Is the intent of OUTPUT-WIDTH to provide an indication to the prettyprinter of how far it knows it can print towards the side?  Is it meantto be an absolute limit, in that printing beyond that point is undefined?What should the OUTPUT-WIDTH of string streams be?  In VAX LISP, theRIGHT-MARGIN of string streams is 80, but we allow users to override howfar the printer goes before inserting newlines.A lesser name complaint is OUTPUT-SPACE might be better named WRITE-SPACEto match the other WRITE-xxx functions.			---Walter------*start*01081 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JAN 89 14:06:07 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 8 Jan 89  14:05:22 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA29037; Sun, 8 Jan 89 14:07:13 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA05255; Sun, 8 Jan 89 14:03:54 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA11210; Sun, 8 Jan 89 14:04:58 PSTDate: Sun, 8 Jan 89 14:04:58 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8901082204.AA11210@clam.sun.com>To: cl-cleanup@sail.stanford.eduSubject: Re: BallotI voted conditionally in favor of STREAM-INFO:ONE-DIMENSIONAL-FUNCTIONS.I wish to add another comment to my vote in favor.  This is a relativelycomplex proposal, and I expect that some changes in details willturn out to be desirable after there is experience with implementations.X3J13 should expect to revisit this issue later to perfect the specification.*start*02238 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 00:24:07 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 10 Jan 89  00:23:57 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 10 JAN 89 00:22:51 PSTDate: 10 Jan 89 00:22 PSTSender: masinter.paSubject: Issue: STREAM-INFO (Version 6)To: cl-cleanup@sail.stanford.eduFrom: gz@spt.entity.com (Gail Zacharias)Message-ID: <890110-002251-5597@Xerox>Our opposition is based on the following points:1) The defining property of WRITE-SPACE (that it must write exactly the numberof units given) is too restrictive.  For example it may not be possible towrite whitespace to a stream in units smaller than a #\space character, if thestream is associated with a (multi-font) ascii file or editor buffer (sincethere may be no ascii character available that can be inserted in thefile/buffer to represent the whitespace).  An implementation cannot simplymake the unit size equal to the width of a #\space character, because asubsequent increase in font-size would again make the unit smaller than acurrent #\space character.2) The "additional properties" of PRINTED-WIDTH (i.e. 8 and 9, stating thatprinted-widths are additive) are incompatible with some non-Roman scripts. Forexample, in the Arabic language the glyphs used for characters are dependenton the surrounding characters: in our Arabic implementation of Object Logo,editing causes surrounding characters to change shape (and width) according totheir new context.  The restrictions on PRINTED-WIDTH would make it difficultto similarly incorporate the context-sensitive character portrayal features ofthe Macintosh into our Common Lisp implementation.3) In general we feel that the proposal is premature, given the current stateof i/o standards.  We would prefer to wait for a complete solution (i.e. areal graphics standard and extended characters set standard).  We feel thatthe current proposal is too specific and problematical for a proper place inCommon Lisp.  For now, the desired features are probably best obtained viaimplementation-specific functions.*start*02767 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 07:33:28 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Jan 89  07:33:07 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 518365; Tue 10-Jan-89 10:31:24 ESTDate: Tue, 10 Jan 89 10:31 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 6)To: gz@spt.entity.comcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <890110-002251-5597@Xerox>Message-ID: <890110103117.3.KMP@BOBOLINK.SCRC.Symbolics.COM>    From: gz@spt.entity.com (Gail Zacharias)    Date: 10 Jan 89 00:22 PST    ... it may not be possible to write whitespace to a stream in units    smaller than a #\space character, if the stream is associated with a    (multi-font) ascii file or editor buffer (since there may be no ascii    character available that can be inserted in the file/buffer to    represent the whitespace). ...This is a good point. I think the wording should be loosened to indicatethe obvious -- that an implementation should not be branded non-conformingif it does the closest approximation to the right thing for the stream,font, device, operating system, etc. that it is dealing with.To the extent that this hook is primarily to support portable prettyprinters My belief is that people would quickly learn to use a fixedwidth font for pretty printed code if the approximate behavior botheredthem, but those who insisted on using bold would be happier with anapproximation to pretty printing than none at all. Of course, nothingprevents a particular vendor in this mess from providing a proprietarypretty printer which deals better -- and I'm sure people would use it --but the idea is to provide a means to save a lot of vendors that work.How about if the function returned information saying whether itbelieved it had correctly achieved its stated goal?    ... In general we feel that the proposal is premature, given the    current state of i/o standards. ...This is the sort of reasoning that led us to not have a way to clearthe screen in portable code under CLtL. [A situation we should probablyrectify even now...]My belief is that the needs of the Common Lisp community are betterserved by a slightly faulty implementation that tries to win as muchas it can than by no implementation.If and when a better solution exists (eg, some window system spec),the window system spec can contain advice to its users that they shouldno longer use the clumsy primitives provided by ANSI Common Lisp.*start*02406 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 10:51:03 PSTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 10 Jan 89  10:50:07 PSTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA13470@EDDIE.MIT.EDU>; Tue, 10 Jan 89 13:48:01 ESTReceived: by spt.entity.com (smail2.5); 10 Jan 89 12:58:22 EST (Tue)To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Tue, 10 Jan 89 10:31 EST <890110103117.3.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 6)Message-Id: <8901101258.AA10804@spt.entity.com>Date: 10 Jan 89 12:58:22 EST (Tue)From: gz@spt.entity.com (Gail Zacharias)   Date: Tue, 10 Jan 89 10:31 EST   From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>   To the extent that this hook is primarily to support portable pretty   printers My belief is that people would quickly learn to use a fixed   width font for pretty printed code if the approximate behavior bothered   them, but those who insisted on using bold would be happier with an   approximation to pretty printing than none at all. Of course, nothing   prevents a particular vendor in this mess from providing a proprietary   pretty printer which deals better -- and I'm sure people would use it --   but the idea is to provide a means to save a lot of vendors that work.Then vendors who wish to do so, and who find a model such as presented by thisproposal appropriate for their implementation, can provide the hooks asimplementation-dependent extensions.  The simple fact is that this proposal isnot universally implementable as stated, and loosening the restrictions wouldmean that you still cannot write a portable pretty printer, i.e. one thatworks correctly in all conforming implementations.A pretty printer which assumes fixed width fonts by default, but allowscustomization in ways appropriate for the text display model used by specificimplementations, is a better solution to this problem than putting functionsin the standard which are already known to be inappropriate for some existingdisplay models.  I don't think it's the responsibility of the standard toprovide hooks that give the illusion of portability to non-portable programs.*start*01325 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 15:28:00 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 10 Jan 89  15:26:47 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 10 JAN 89 15:23:04 PSTDate: 10 Jan 89 15:22 PSTFrom: masinter.paSubject: Re: Issue: STREAM-INFO (Version 6)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 10 Jan 89 17:26 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: gz@spt.entity.com, cl-cleanup@sail.stanford.eduMessage-ID: <890110-152304-6870@Xerox>Maybe these belong in a category of "optional extensions", i.e., you eitherprovide them all or don't. We've avoided options so far, because wecouldn't see any good reason for providing them, but this seems like itmight be a good reason.I'm of the mind, though, that streams for which this is not a good modelshould behave exactly like the default implementation "fixed-width"implementation:  every graphic character is of width 1 and the line widthis 80.I'd think that would be more appropriate for a Mac implementation where itis possible to change the font after-the-fact than actually payingattention to the "real" width.*start*04144 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 14:29:39 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Jan 89  14:28:55 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 518773; 10 Jan 89 17:26:38 ESTDate: Tue, 10 Jan 89 17:26 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STREAM-INFO (Version 6)To: gz@spt.entity.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: <8901101258.AA10804@spt.entity.com>Message-ID: <890110172620.2.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 10 Jan 89 12:58:22 EST (Tue)    From: gz@spt.entity.com (Gail Zacharias)    ...    Then vendors who wish to do so, and who find a model such as presented    by this proposal appropriate for their implementation, can provide the    hooks as implementation-dependent extensions.In practice, vendors don't do this. They each think their own theory of howto provide the hooks is best, each insisting that other vendors' views ofthe world are wrong. In the absence of an external agency (like ANSI) to force agreement, each feels entitled to disagree, believing it is right.The advantage of a standard is that it enforces a little agreement.    The simple fact is that this proposal is    not universally implementable as stated, and loosening the restrictions would    mean that you still cannot write a portable pretty printer, i.e. one that    works correctly in all conforming implementations.Technically, no, but for the universe of programmers we can reasonablyexpect to sell to in the commercial community which ANSI influences, youcan do awfully good. If someone has a CL that supports Hebrew, let themwrite their own pretty printer. I'd be surprised if they didn't plan todo so anyway, so I doubt I'm asking them to do extra work. On the other hand, experience shows that Dick Water's very interestingpretty printer did not reach all the target audiences that would have likedto have it because he didn't have the time to adapt it to everyone'sidiosyncratic view of thew world, and they didn't have enough time to look over his code and realize how little work it would take to get it upand running.That's a real shame. This change comes to us from the CL user communityfrom Waters himself, who tried to use those hooks which you asserteveryone has, and who found it too much work. I think it's our obligationto try to address his need in some way if we can.    A pretty printer which assumes fixed width fonts by default, but allows    customization in ways appropriate for the text display model used by specific    implementations, is a better solution to this problem than putting functions    in the standard which are already known to be inappropriate for some existing    display models.  I don't think it's the responsibility of the standard to    provide hooks that give the illusion of portability to non-portable programs.How about if we permit an ERROR-P argument which controls whether you signalan error or just continue if you are in a variable width font and can't supportthe indicated operation. That way you'd get the benefits of your supposedimprovement (which is that fixed-width fonts would work) and implementationswhich supported variable width fonts and arbitrary addressing would not be penalized. In a few years, we could take some polls and find out if peoplewere mostly willing to set ERROR-P to T and let their application fall on thefloor when it ran up against a hard problem, or if they were mostly willingto set ERROR-P NIL, so that their application would do the best it could dorather than just falling apart in an obviously difficult situation. This wouldhave no illusion of portability since in reading about the ERROR-P argument anddeciding what to set it to, it would be clear to the programmer how the behaviormight vary between implementations.