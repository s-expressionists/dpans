*start*04899 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Jun-89 13:31:32 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 JUN 89 13:31:25 PDTReceived: from argus.Stanford.EDU by SAIL.Stanford.EDU with TCP; 16 Jun 89  13:29:06 PDTReceived: from STONY-BROOK.SCRC.SYMBOLICS.COM by argus.Stanford.EDU with TCP; Fri, 16 Jun 89 13:14:15 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 612167; 16 Jun 89 16:30:13 EDTDate: Fri, 16 Jun 89 16:30 EDTFrom: David A. Moon <Moon@stony-brook.scrc.symbolics.com>Subject: Issue: SEQUENCE-TYPE-LENGTH (version 1)         Coercing sequences to vectors of different sizesTo: CL-Cleanup@sail.stanford.eduReferences: <19890605191434.7.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>Message-Id: <19890616203028.3.MOON@EUPHRATES.SCRC.Symbolics.COM>I hate to bring up a new issue so late, but maybe this one can be addressedvery quickly, or maybe somebody on the CL-Cleanup list will tell me that ithas already been addressed and I just overlooked it, which would be idealas far as I am concerned.Issue:         SEQUENCE-TYPE-LENGTHReferences:    CLtL p.51, p.249, p.260               CONCATENATE, COERCE, MAKE-SEQUENCE, MAP, MERGECategory:      CLARIFICATIONEdit history:  16-Jun-89, version 1, by MoonProblem description:  In several functions that take a type specifier as an argument and create  a sequence of the specified type, it isn't clear what happens if the type  specifier has an explicit length that doesn't match the length implied by  the other arguments.Proposal (SEQUENCE-TYPE-LENGTH:MUST-MATCH):  COERCE should signal an error if the new sequence type specifies the  number of elements and the old sequence has a different length.  MAKE-SEQUENCE should signal an error if the sequence type specifies the  number of elements and the size argument is different.  CONCATENATE should signal an error if the sequence type specifies the  number of elements and the sum of the argument lengths is different.  MAP should signal an error if the sequence type specifies the number of  elements and the minimum of the argument lengths is different.  MERGE should signal an error if the sequence type specifies the number of  elements and the sum of the lengths of the two sequence arguments is  different.Examples:  ;; All of the following forms should signal an error  (coerce '(a b c) '(vector * 4))  (coerce #(a b c) '(vector * 4))  (coerce '(a b c) '(vector * 2))  (coerce #(a b c) '(vector * 2))  (coerce "foo" '(string 2))  (coerce #(#\a #\b #\c) '(string 2))  (coerce '(0 1) '(simple-bit-vector 3))  (make-sequence '(vector * 2) 3)  (make-sequence '(vector * 4) 3)  (concatenate '(vector * 2) "a" "bc")  (map '(vector * 4) #'cons "abc" "de")  (merge '(vector * 4) '(1 5) '(2 4 6) #'<)Rationale:  If CLtL hadn't overlooked this situation, it's likely that it would have  said it "is an error".  The best translation of that to ANSI CL error  terminology seemed to be "should signal".  There doesn't seem to be any  reason to require signalling this error even in unsafe code.  There  doesn't seem to be any reason to define this situation to do something  other than signalling an error, such as ignoring the length in the  type specifier or forcing the sequence to have the correct length by  truncating or extending it with elements of implementation-dependent  value.Current practice:  Symbolics Genera 7.2 and 7.4 usually ignore the length in the type  specifier in the above situations, but sometimes signal an error.  The type of error signalled is sometimes somewhat random.  Other implementations were not surveyed.Cost to Implementors:  This does not seem like difficult checking to add.  I have not examined  the code in any implementation to try to evaluate what it would cost.Cost to Users:  None.Cost of non-adoption:  Aesthetic.Performance impact:  Probably small, just have to keep track of the length when dealing  with sequence type specifiers in safe code.  I have not attempted to  evaluate the exact impact.Benefits:  Less ambiguity in the language specification.  Less deviation among  implementations, hence fewer porting problems.Esthetics:  Since the length field is present in sequence type specifiers, it  seems unesthetic to ignore it, and even more unesthetic not to say  what is done with it.Discussion:  Moon doesn't know what error condition is appropriate.  TYPE-ERROR  doesn't seem quite appropriate here.  One idea is not to say, just let it  be any subtype of ERROR.  Another idea is to produce the result object  and then signal a TYPE-ERROR that this object doesn't match the  type-specifier for the result type.*start*05489 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Jun-89 13:37:50 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 JUN 89 13:37:51 PDTReceived: from argus.Stanford.EDU by SAIL.Stanford.EDU with TCP; 16 Jun 89  13:34:22 PDTReceived: from STONY-BROOK.SCRC.SYMBOLICS.COM by argus.Stanford.EDU with TCP; Fri, 16 Jun 89 13:19:11 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 612181; 16 Jun 89 16:35:05 EDTDate: Fri, 16 Jun 89 16:35 EDTFrom: David A. Moon <Moon@stony-brook.scrc.symbolics.com>Subject: Issue: SEQUENCE-TYPE-LENGTH (version 1)         Coercing sequences to vectors of different sizesTo: CL-Cleanup@sail.stanford.eduReferences: <19890605191434.7.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>Supersedes: <19890616203028.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Comments: The first transmission forgot to include part of the discussion.          Sorry about that.Message-Id: <19890616203524.4.MOON@EUPHRATES.SCRC.Symbolics.COM>I hate to bring up a new issue so late, but maybe this one can be addressedvery quickly, or maybe somebody on the CL-Cleanup list will tell me that ithas already been addressed and I just overlooked it, which would be idealas far as I am concerned.Issue:         SEQUENCE-TYPE-LENGTHReferences:    CLtL p.51, p.249, p.260, p.252, p.354               CONCATENATE, COERCE, MAKE-SEQUENCE, MAP, MERGECategory:      CLARIFICATIONEdit history:  16-Jun-89, version 1, by MoonProblem description:  In several functions that take a type specifier as an argument and create  a sequence of the specified type, it isn't clear what happens if the type  specifier has an explicit length that doesn't match the length implied by  the other arguments.Proposal (SEQUENCE-TYPE-LENGTH:MUST-MATCH):  COERCE should signal an error if the new sequence type specifies the  number of elements and the old sequence has a different length.  MAKE-SEQUENCE should signal an error if the sequence type specifies the  number of elements and the size argument is different.  CONCATENATE should signal an error if the sequence type specifies the  number of elements and the sum of the argument lengths is different.  MAP should signal an error if the sequence type specifies the number of  elements and the minimum of the argument lengths is different.  MERGE should signal an error if the sequence type specifies the number of  elements and the sum of the lengths of the two sequence arguments is  different.Examples:  ;; All of the following forms should signal an error  (coerce '(a b c) '(vector * 4))  (coerce #(a b c) '(vector * 4))  (coerce '(a b c) '(vector * 2))  (coerce #(a b c) '(vector * 2))  (coerce "foo" '(string 2))  (coerce #(#\a #\b #\c) '(string 2))  (coerce '(0 1) '(simple-bit-vector 3))  (make-sequence '(vector * 2) 3)  (make-sequence '(vector * 4) 3)  (concatenate '(vector * 2) "a" "bc")  (map '(vector * 4) #'cons "abc" "de")  (merge '(vector * 4) '(1 5) '(2 4 6) #'<)Rationale:  If CLtL hadn't overlooked this situation, it's likely that it would have  said it "is an error".  The best translation of that to ANSI CL error  terminology seemed to be "should signal".  There doesn't seem to be any  reason to require signalling this error even in unsafe code.  There  doesn't seem to be any reason to define this situation to do something  other than signalling an error, such as ignoring the length in the  type specifier or forcing the sequence to have the correct length by  truncating or extending it with elements of implementation-dependent  value.Current practice:  Symbolics Genera 7.2 and 7.4 usually ignore the length in the type  specifier in the above situations, but sometimes signal an error.  The type of error signalled is sometimes somewhat random.  Other implementations were not surveyed.Cost to Implementors:  This does not seem like difficult checking to add.  I have not examined  the code in any implementation to try to evaluate what it would cost.Cost to Users:  None.Cost of non-adoption:  Aesthetic.Performance impact:  Probably small, just have to keep track of the length when dealing  with sequence type specifiers in safe code.  I have not attempted to  evaluate the exact impact.Benefits:  Less ambiguity in the language specification.  Less deviation among  implementations, hence fewer porting problems.Esthetics:  Since the length field is present in sequence type specifiers, it  seems unesthetic to ignore it, and even more unesthetic not to say  what is done with it.Discussion:  Moon doesn't know what error condition is appropriate.  TYPE-ERROR  doesn't seem quite appropriate here.  One idea is not to say, just let it  be any subtype of ERROR.  Another idea is to produce the result object  and then signal a TYPE-ERROR that this object doesn't match the  type-specifier for the result type.  Cassels points out that two similar operations are defined in CLtL to be  inconsistent with each other:  (replace (make-array 4) #(1 2 3)) just picks the shortest length, and     "the extra elements near the end of the longer subsequence are not     involved in the operation" so the result is #(1 2 3 NIL)  #4(1 2 3) duplicates the last element, so it's like #(1 2 3 3)  #2(1 2 3) "is an error".*start*01148 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Jun-89 14:00:23 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 JUN 89 14:00:18 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 20 Jun 89  13:56:47 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 614088; 20 Jun 89 16:58:39 EDTDate: Tue, 20 Jun 89 16:59 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SEQUENCE-TYPE-LENGTH (version 1)         Coercing sequences to vectors of different sizesTo: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890616203524.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19890620205907.0.MOON@EUPHRATES.SCRC.Symbolics.COM>No one has commented on this yet.How about if using a sequence type-specifier with a length or anumeric type-specifier with a subrange (the latter in COERCE only)was defined to be not allowed?  It could be "should signal an error"or "the consequences are unspecified".