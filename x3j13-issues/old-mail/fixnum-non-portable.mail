*start*01941 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 JUL 88 12:16:09 PDTReceived: from FRED.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 12 Jul 88  11:52:42 PDTReceived: from FRED.SLISP.CS.CMU.EDU by FRED.SLISP.CS.CMU.EDU; 12 Jul 88 14:51:44 EDTTo: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UKcc: sandra <@cs.utah.edu:sandra@cdr>, cl-cleanup@sail.stanford.eduSubject: Re: issue BOGUS-FIXNUMS (initial draft) In-reply-to: Your message of Tue, 12 Jul 88 10:33:24 -0000.Date: Tue, 12 Jul 88 14:49:53 EDTFrom: Rob.MacLachlan@WB1.CS.CMU.EDUStriking the FIXNUM type specifier doesn't mean fixnums cease to exist: itjust means this implementation detail is somewhat better hidden.  Therewould be nothing to prevent an application that currently uses FIXNUM fromdoing:    (deftype fixnum () '(signed-byte 16))Or whatever property the program was assuming that FIXNUM had.Any compiler that can't recognize this deftype as a subtype of its internalfixnum type (if it in fact is) is broken (not to say that there aren't lotsof broken compilers).But I think that the issue isn't quite as clear-cut as the anti-fixnums aremaking it.  In many implementations, a fixnum type constraint results in a>10x performance improvement.  People tuning programs for theseimplementations cannot ignore this reality, and need some kind of handle ona "good" integer subrange.Even if the FIXNUM type specified were flushed, the constants delimitingthe implementation fixnum range should remain.  Of course, with theseconstants, once can always:    (deftype fixnum () `(integer ,most-negative-fixnum ,most-positive-fixnum))And of course, people will do this.  And their programs will still runfast, and will still run with no problem on the vast majority ofimplementations with a reasonable fixnum size.   Rob*start*01234 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 JUL 88 02:48:28 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 12 Jul 88  02:46:39 PDTReceived: from maths.bath.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa03327; 12 Jul 88 10:12 BSTReceived: from xenakis by mordell.maths.bath.AC.UK id aa04851;          12 Jul 88 10:33 BSTTo: sandra <@cs.utah.edu:sandra@cdr>CC: cl-cleanup@sail.stanford.eduIn-reply-to: sandra (Sandra J Loosemore)'s message of Mon, 11 Jul 88 11:28:42 MDT <8807111728.AA22729@cdr.utah.edu>Subject: issue BOGUS-FIXNUMS (initial draft)Date: Tue, 12 Jul 88 10:33:24 BSTFrom: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UKSender: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UKThis looks like a giant step backwards.  Some of us are interested inwriting efficient code.  Even if some machines only have onerepresentation I find it hard to believe that there are not a subsetwhich are more efficient.  Are you seriously suggesting that LISPshould counternance numbers not being arbitary precision?Anyway KCL has fixnum, bignum and short fixnum.==John*start*02670 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 11 JUL 88 14:19:21 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 11 Jul 88  14:18:00 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 431776; Mon 11-Jul-88 17:16:39 EDTDate: Mon, 11 Jul 88 17:16 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue BOGUS-FIXNUMS (initial draft)To: sandra%cdr@cs.utah.educc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8807111728.AA22729@cdr.utah.edu>Message-ID: <880711171627.4.KMP@PEWEE.SCRC.Symbolics.COM>This proposal might go over better if we replaced the feature withanother, more portable, feature addressing a similar need. eg, FIXNUM could be left undefined as proposed, and then implementations could support it as a non-portable extensionbut also SMALL-INTEGER could be defined as some range of integers which we think most implementations can support efficiently (but with the understanding that the important thing is to support it correctly rather than efficiently). For example, maybe SMALL-INTEGER could be defined as (INTEGER -2^30 (2^30)). [The specific bounds is open to discussion, of course, I'm just proposing ``something like this''.] As a corollary, MOST-POSITIVE-EFFICIENTLY-REPRESENTABLE-INTEGER, etc might hold an integer (or NIL, if the concept made no sense for some reason in a particular implementation -- eg, all numbers were bignums) with no necessary relation to the type SMALL-INTEGER. Maybe it could just be MOST-POSITIVE-EFFICIENT-INTEGER.That way, people could declare known-to-be-small integers withoutbeing concerned that some pathological implementation would screw themby having an ultra-tiny range.Note also that there'd be a slight two's-complement bias there, but thealternative seems to be to offer nothing, and I'm not sure that that'sbetter.Does anyone think this is worth trying to incorporate with this proposalto make it more palatable to those who are worried that striking FIXNUMwill lose them functionality. (I don't dispute Sandra's claim that almostno one knows how to use FIXNUM portably. There are a few, but only veryfew, portable uses, and I think not enough to worry about. I'm justconcerned that people use FIXNUM because it's all we offer and that perhaps what that really means is not that we should give up on thefeature, but rather that there's such severe need for it that we shouldcome up with something better.)*start*03159 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 11 JUL 88 14:38:33 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 11 Jul 88  14:36:20 PDTReceived: from aiva.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06788; 11 Jul 88 22:07 BSTFrom: Jeff Dalton <jeff%aiva.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Mon, 11 Jul 88 21:32:31 bstMessage-Id: <5509.8807112032@aiva.ed.ac.uk>To: cl-cleanup@sail.stanford.edu, sandra <@cs.utah.edu:sandra@cdr>Subject: Re:  issue BOGUS-FIXNUMS (initial draft)> Date: Mon, 11 Jul 88 11:28:42 MDT> From: sandra <(Sandra J Loosemore)sandra%cdr@edu.utah.cs>Do I understand this?  You are proposing to eliminate fixnums fromthe language?I would certainly oppose such a change.  Even though fixnums maydiffer from implementation to implementation, I want a standardway to use them when they exist rather than allow implementationsto diverge (so that some call them fixnums, others something else,and so on).> Rationale:> Since CLtL does not guarantee anything about the range of fixnums> (saying only that they will *typically* be between -2**n and 2**n - 1,> for n not less than 15), any user program that uses FIXNUM or BIGNUM> declarations is already nonportable.This depends on what you count as portable.  There may be no gainin efficiency, but the program will still work if care is takento check the range and in many cases even if not.  Moreover, Ican know that this kind of thing is called "fixnum" and notsomething else.> Current Practice:> KCL has only a single representation for integers,It has two -- or three: see Franz below.> Franz Lisp [has] three different integer representations.You might say Franz has three, but small fixnums have the same formatas larger ones; the difference is that they live in a known part ofmemory and new ones are never allocated.  If you count this as three,KCL also has three.> Cost to users:> Slight, at least in portable code.  If implementors continue to> support the FIXNUM and BIGNUM type specifiers, existing (nonportable)> user code that relies on them would continue to work in those> implementations.I think it is a mistake to think that "nonportable" code does not count.It is useful to have a standard way to do something even if it does notwork everywhere, and the optimizations for fixnums are important enoughthat most implementations provide some.I do not accept the argument that it doesn't matter because everyone whoprovides fixnums can still provide them.  If they're not in the standard,users cannot in fact rely on them being provided in a standard way.Indeed, if we decide to allow only standard symbols in the LISP package,users would have to type LUCID:FIXNUM, EXCL:FIXNUM, etc. rather than justFIXNUM as they can now.Jeff Dalton,                      JANET: J.Dalton@uk.ac.ed             AI Applications Institute,        ARPA:  J.Dalton%uk.ac.ed@nss.cs.ucl.ac.ukEdinburgh University.             UUCP:  ...!ukc!ed.ac.uk!J.Dalton*start*04101 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 11 JUL 88 10:29:44 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 11 Jul 88  10:29:05 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA09454; Mon, 11 Jul 88 11:28:48 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA22729; Mon, 11 Jul 88 11:28:44 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807111728.AA22729@cdr.utah.edu>Date: Mon, 11 Jul 88 11:28:42 MDTSubject: issue BOGUS-FIXNUMS (initial draft)To: cl-cleanup@sail.stanford.eduIssue:		BOGUS-FIXNUMSReferences:	CLtL p. 14, 34, 43, 231Category:	CHANGEEdit History:   Version 1, 11 Jul 1988 (Sandra Loosemore)Problem Description: Implementations of Common Lisp are required to support two disjointsubsets of integers, fixnums and bignums.  While in manyimplementations these correspond to different internalrepresentations, some implementations may support only a singlerepresentation for all integers.  In such a case, arbitrarilydesignating some subrange of integers as "fixnums" becomes anartificial contrivance which is more likely to confuse users than toensure portability of code.Proposal: BOGUS-FIXNUMS:ELIMINATE-DISTINCTION(1) Remove all references to the partitioning of the type INTEGER intoFIXNUM and BIGNUM.  Remove FIXNUM and BIGNUM from the table of standardtype specifier symbols on page 43 of CLtL.(2) Remove the constants MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUMfrom the language.  (3) Introduce a new constant, MAX-INTEGER-LENGTH.  This is the maximumnumber of bits appearing in any integer; therefore, it is an upperbound on the INTEGER-LENGTH function.  The value can be NIL if thereare no limits short of memory availability.Rationale:Since CLtL does not guarantee anything about the range of fixnums(saying only that they will *typically* be between -2**n and 2**n - 1,for n not less than 15), any user program that uses FIXNUM or BIGNUMdeclarations is already nonportable.  Using these type specifiers fordiscrimination is also of questionable utility in portable code.  Inremoving these type specifiers from the language standard, this proposal hasno effect on portability.Current Practice:KCL has only a single representation for integers, as do a number ofCommon Lisp subsets (including XLisp and A-Lisp).  Some Lisps havemore than two representations for integers; PSL, for example, hasthree different representations, similar to Lisp 1.6.  Franz Lisp andInterlisp also have three different integer representations.Implementations do not necessarily limit bignum size only by the amount of"available memory" (which is a rather vague concept anyway).  For example,many implementations restrict the length of the bignum to be representablein a fixed-length field.Cost to implementors:Slight.  Implementations that support different representations for fixnumsand bignums can continue to do so and provide the type specifiers as acompatible extension.Cost to users:Slight, at least in portable code.  If implementors continue tosupport the FIXNUM and BIGNUM type specifiers, existing (nonportable)user code that relies on them would continue to work in thoseimplementations.  It's possible that some portable user programsactually use the value of MOST-POSITIVE-FIXNUM or MOST-NEGATIVE-FIXNUM(for example, to scale fixed-point values to fit in a fixnum).Benefits:Removing the distinction between fixnums and bignums simplifies thelanguage.  It reduces ambiguity in the case where there are more thantwo integer representations. Introducing a new constant to describe the maximum size of integers makesit possible to describe an implementation's exact limitations on the rangeof integers it supports.  This constant would also be useful for thedescription of subset implementations.Discussion:Addition of the MAX-INTEGER-LENGTH constant was suggested by Stan Shebs,who supports this proposal.-------*start*01077 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 JUL 88 15:45:46 PDTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 12 Jul 88  15:44:43 PDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA07536@EDDIE.MIT.EDU>; Tue, 12 Jul 88 18:43:48 EDTReceived: by spt.entity.com (smail2.5); 12 Jul 88 18:01:06 EDT (Tue)To: sandra%cdr@cs.utah.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8807111728.AA22729@cdr.utah.edu>Subject: issue BOGUS-FIXNUMS (initial draft) Message-Id: <8807121801.AA06063@spt.entity.com>Date: 12 Jul 88 18:01:06 EDT (Tue)From: gz@spt.entity.com (Gail Zacharias)It is not uncommon for a program to find itself with an object which is knownto be either a small integer or, say, a string or a list.  In such cases(typep x 'fixnum) is likely to more efficient than either (typep x 'integer)or (typep x '(integer 0 1000)), and it's an optimization that a compiler can'tdo for you.*start*01875 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 JUL 88 15:56:33 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Jul 88  15:55:31 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 12 JUL 88 15:28:16 PDTDate: 12 Jul 88 15:28 PDTFrom: Masinter.paSubject: Re: issue BOGUS-FIXNUMS (initial draft)In-reply-to: sandra%cdr@cs.utah.edu (Sandra J Loosemore)'s message of Mon, 11 Jul 88 11:28:42 MDTTo: sandra%cdr@cs.utah.edu (Sandra J Loosemore)cc: cl-cleanup@sail.stanford.eduMessage-ID: <880712-152816-1764@Xerox>I can't see getting entirely rid of FIXNUMs and adding something else justbecause FIXNUMs aren't really portable. I think it might be more reasonable tobe more explicit about how unportable FIXNUMs are. Certainly implementations that have only one representation can arbitrarilydeftype FIXNUM to be SIGNED-BYTE 32 and leave it at that. To put it in terms of the proposal: I don't think that the problem statement aswritten establishes that there is a significant problem with the language; theremay be a problem with CLtL and with CL programming texts and lots of the CL coderunning around, but I think it is OK for the language to have some portable wayof talking about the "most efficient number range". All computers that I knowabout have word sizes. I certainly would like to discourage programmers from using FIXNUM fordiscrimination when they really don't mean it, and from using FIXNUMdeclarations when they really mean a given number range, but I don't thinktaking FIXNUM out of the language is the proper way to do it. I don't see how MAX-INTEGER-LENGTH has anything to do with the problem asstated. I think it is a separate proposal, if you want to allow for limits onbignum size.*start*00972 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 JUL 88 16:30:55 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Jul 88  16:29:54 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 12 JUL 88 16:01:35 PDTDate: 12 Jul 88 16:00 PDTFrom: Masinter.paSubject: Re: issue BOGUS-FIXNUMS (initial draft) In-reply-to: gz@spt.entity.com (Gail Zacharias)'s message of 12 Jul 88 18:01:06 EDT (Tue)To: gz@spt.entity.com (Gail Zacharias)cc: sandra%cdr@cs.utah.edu, cl-cleanup@sail.stanford.eduMessage-ID: <880712-160135-1829@Xerox>Sigh, that's just the kind of code that is very non-portable and that I'd liketo discourage programmers from writing. I've tried to import stuff from a CLthat had 31 bit FIXNUMs into a system that had 17-bit FIXNUMs and, out of sheerlaziness, they said FIXNUM when they really meant (signed-byte 24).*start*03023 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 JUL 88 11:47:56 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 14 Jul 88  11:42:40 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06067; 14 Jul 88 19:12 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Thu, 14 Jul 88 19:36:00 BSTMessage-Id: <13739.8807141836@subnode.aiai.ed.ac.uk>To: sandra <@cs.utah.edu:sandra@cdr>Subject: Re:  an alternate BOGUS-FIXNUMS proposalCc: cl-cleanup@sail.stanford.eduSandra:   Forcing users to DEFTYPE their own integer subrange types instead   would encourage better use of data abstraction.  I've noticed that   Lisp programs are typically much sloppier about this than programs   written in strongly typed languages such as C or Pascal.Me: There are certainly many programs that use "int" or "long", and   those are analogous to FIXNUM, not to explicit ranges of integers   or numbers of bits.Sandra:   Yes, people do declare things as "int" in C code without giving a   great deal of thought to how big an "int" really is.  But in my mind,   not being guaranteed anything about integer sizes in C (and not being   able to define subrange types as you can in Pascal) is a misfeature.   I don't think its presence in C is a valid justification for including   it in Lisp.  [Followed by example of program that avoids using int or   long directly by using system-specific typedefs.]My point was that C (and Pascal) programs do use "int", and that this isanalogous to FIXNUM.  While some C programs take more care (if they areconcerned about portability to a wide range of machines), so do some Lispprograms.  I do not agree that C programs typically show more care thanLisp programs about this particular issue (though they must, of course, bemore careful about types in general): a great many C programs simply use"int" or "long".  Nor it is the case that C and Pascal *force* users todefine their own integer subrange types.  And, well, all this is not toshow that "int" in C justifies FIXNUM in Lisp but only that your argumentin favor of "forcing users", etc. does not have the support from C andPascal that you suggest.One the contrary, C and Pascal show that "int" is useful and that forcingusers to define subranges is not necessary.  This point is valid, becauseis shows that such ill-defined types are nonetheless useful.  Perhaps itwould not be enough to justify adding FIXNUM to Lisp, but since you aresuggesting a change to CL, the burden of proof is on you to show thatFIXNUM should be removed and that its utility is outweighed by otherfactors.Jeff Dalton,                      JANET: J.Dalton@uk.ac.ed             AI Applications Institute,        ARPA:  J.Dalton%uk.ac.ed@nss.cs.ucl.ac.ukEdinburgh University.             UUCP:  ...!ukc!ed.ac.uk!J.Dalton*start*03897 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 JUL 88 22:15:18 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 14 Jul 88  22:14:39 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA06686; Thu, 14 Jul 88 23:14:13 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA25613; Thu, 14 Jul 88 23:14:09 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807150514.AA25613@cdr.utah.edu>Date: Thu, 14 Jul 88 23:14:07 MDTSubject: BOGUS-FIXNUMS, againTo: cl-cleanup@sail.stanford.eduSince it appears that nobody besides me (and Stan) likes my previousproposal on this issue and that I'll have to come up with somethingless radical that is more acceptable to the rest of the committee, Ithought it would be useful to enumerate some of the possibilities.  Irealize there are still two other issues which would still have to beaddressed when turning any of these into a real proposal, namelywhether to retain MOST-BLETCHEROUS-FIXNUM :-), and whether the BIGNUMtype specifier should remain and whether it must still be a non-emptyset which is disjoint from FIXNUM. #0 (what CLtL says):    - there is no particular type specifier defined for "small integers".    - the FIXNUM type specifier is defined but nothing is said about its      range.    - FIXNUMs are required to have a more efficient representation than      non-FIXNUMs.#1 (my original proposal):    - there is no particular type specifier defined for "small integers".    - the FIXNUM type specifier goes away.    - user-defined integer subrange types use the most efficient       representation possible in a given implementation.#2 (Gail Zacharias's counter-proposal):    - there is no particular type specifier defined for "small integers".    - the FIXNUM type specifier is defined to be a superset of      (SIGNED-BYTE n), for some value of "n" which has yet to be      decided but that we all agree upon.    - FIXNUMs are not required to coincide with or be a subset of the      set of integers which are represented most efficiently.#3 (change CLtL's "typically" to a firm requirement):    - there is no particular type specifier defined for "small integers".    - FIXNUMs must be a supertype of (SIGNED-BYTE n).    - FIXNUMs are defined to be the set of integers which are represented      most efficiently.#4 (dumb, but here for completeness):    - there is no particular type specifier defined for "small integers".    - the FIXNUM type specifier is defined to be equivalent to      (SIGNED-BYTE n).    - FIXNUMs are required to be a subset of the integers which are      represented most efficiently.#5: (Kent Pitman's suggestion):    - a new SMALL-INTEGER type specifier is introduced which is equivalent      to (SIGNED-BYTE n).    - the FIXNUM type specifier goes away.    - nothing is guaranteed about the efficiency of representation of      SMALL-INTEGERs.#6 (similar to #3):    - a new SMALL-INTEGER type specifier is introduced which is equivalent      to (SIGNED-BYTE n).    - the set of FIXNUMs is required to be a superset of SMALL-INTEGERs.    - FIXNUMs are defined as the set of integers with the most efficient      representation.  (This implies that SMALL-INTEGERS are also      guaranteed to be efficient.)#7 (a cross between #0 and #5):    - a new SMALL-INTEGER type specifier is introduced which is equivalent      to (SIGNED-BYTE n).    - the FIXNUM type specifier remains but the range of FIXNUMs is left      undefined, as is the relationship between FIXNUM and SMALL-INTEGER.    - FIXNUMs are defined as the set of integers with the most efficient      representation.  Nothing is guaranteed about the efficiency of       SMALL-INTEGERs.Comments, anyone?  -Sandra-------*start*03563 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 15 JUL 88 00:13:49 PDTReceived: from rutgers.edu ([128.6.21.9]) by SAIL.Stanford.EDU with TCP; 15 Jul 88  00:13:30 PDTReceived: by rutgers.edu (5.59/1.15) with UUCP 	id AA08860; Fri, 15 Jul 88 01:42:49 EDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA01559@EDDIE.MIT.EDU>; Wed, 13 Jul 88 23:06:58 EDTReceived: by spt.entity.com (smail2.5); 13 Jul 88 20:29:39 EDT (Wed)To: sandra%cdr@cs.utah.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Wed, 13 Jul 88 09:52:31 MDT <8807131552.AA24171@cdr.utah.edu>Subject: an alternate BOGUS-FIXNUMS proposalMessage-Id: <8807132029.AA10252@spt.entity.com>Date: 13 Jul 88 20:29:39 EDT (Wed)From: gz@spt.entity.com (Gail Zacharias)   From: sandra%cdr@cs.utah.edu (Sandra J Loosemore)   Date: Wed, 13 Jul 88 09:52:31 MDT   - It does not address the issue of what happens to the BIGNUM type     specifier.I wouldn't be adverse to removing BIGNUM as a type specifier altogether.   - Programmers would still be able to put FIXNUM declarations in their     code, but under this proposal FIXNUMs would not necessarily guarantee     the most efficient representation (which appears to be the main reason     why people are so anxious to preserve the FIXNUM type in the first     place).It would guarantee an efficient representation in all cases where it can bereasonably expected to do so.  That is, in all implementations which have asufficiently large range of efficient integers.   Also, note that if users specify a smaller subrange of integers than   the nominal FIXNUM size in their declarations, it may be possible to   get even more improvements in performance.That's right.  Users can always take the extra time and effort needed to do amore detailed range analysis in especially critical sections of code.Use of FIXNUM's is not always prompted by programmers' laziness in analyzingtheir code.  The problem is that in those implementations which do supportfixnums, the efficiency difference between fixnums and bignums is usuallyfairly large.  It's large enough that users are willing to structure theircode to take note of it.  Different algorithms (e.g. different space/speedtradeoffs) might be appropriate for fixnums and bignums.  In Macsyma, thereare a number of instances where an argument is checked for being a fixnum,and different code is used if it is (actually it's often the same code,but full of fixnum declarations for all the intermediate results).  Thisis not something that can be done with range declarations.  The following pieceof code is also from Macsyma:   (DO ((I 0 (1+ I))        (P MOST-POSITIVE-FIXNUM (NEWPRIME P)))    ((= I 20.)))This makes a table of the 20 largest primes which fit in a fixnum.  The tableis used to good effect by various algorithms within Macsyma.  Do you reallywish to disallow these kinds of optimizations?Common Lisp goes to some trouble to provide for the needs of people writingserious numerical floating point code.  I think recognizing the (possibilityof the) FIXNUM/BIGNUM distinction is the minimum that can be done for peoplewriting serious numerical integer code.  There may be a problem with the more"casual" use of FIXNUM declarations for loop counters and such, but I don'tthink that the way to address that problem is to pretend the distinctiondoesn't exist.*start*03347 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 15 JUL 88 01:11:04 PDTReceived: from ucbvax.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 15 Jul 88  01:10:48 PDTReceived: by ucbvax.Berkeley.EDU (5.59/1.28)	id AA02152; Fri, 15 Jul 88 01:08:33 PDTFrom: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUReceived: by trwrb (5.51/1.36)	id AA07355; Thu, 14 Jul 88 12:51:45 PDTDate: Thu, 14 Jul 88 12:51:45 PDTMessage-Id: <8807141951.AA07355@trwrb>To: cl-cleanup@sail.stanford.eduSubject: re: issue BOGUS-FIXNUMSI believe it is imperative for Common Lisp to support a portable meansof declaring the range of integers to be handled ina particular operationis within that range efficiently supported by the underlying hardwarearchitecture.  This is what I mean when I say (declare (fixnum x)) in aprogram.  I understand that this limits the portability or usefulness ofmy program after porting.  But I believe this limitation is more funda-mentally imposed by the underlying hardware architecture than by myfixnum declaration -- the performance of operations involving "fixnums"is critical to many programs.When a Common Lisp provides only one integer representation, that maylimit the portability of my program, depending on the representation.I may need large range; I may need the fastest possible integer operationsrestricted to the range efficiently supported.  A representation thatlimits range to a fixed range is a bogus bignum implementation, in my book.A representation that does not take advantage of fast integer arithmeticperformance for a restricted range of integers has a bogus fixnum implementa-tion, similarly.  That is assuming, of course, that there is only that onerepresentation.When a Common Lisp provides more than two representations, it is alsolimiting portability in some way.  Let's say there are three representations.Let's further say that one corresponds to the accepted definition of fixnumand another to the accepted definition of bignum.  Then use of the thirdwill likely limit portability, if my declarations are intended to be forsake of efficiency.  Use of (declare ((integer n0 n1) x)), could, ofcourse, be useful and portable given three representations.  But theywould not be used for the same purpose as a fixnum or bignum declaration.I guess my point is that the portability of my program is something Idetermine based on the power of the hardware architecture and the qualityof the Lisp implementation.  Given that the architecture is powerfulenough (has a wide enough word size, for example), I can port to it.But my fixnum declarations are for performance.  If it were not importantfor that declaration to be made for efficiency, I likely wouldn't make itat all.  This may reflect a difference in philosophy between those whodeclare everything for sake of program clarity or readability and me, Isuspect.  Those who make declarations for other-than-performance likely findmy fixnum declarations utterly detestable.  I'm not arguing one philosphyversus the other; I assuming a sizeable set of programmers who use declara-tions similarly to how I use them.  Taking away the fixnum/bignum distinctiontakes away a valuable and well-used tool.--Joe*start*04050 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 15 JUL 88 05:56:01 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Jul 88  05:55:11 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 433676; Fri 15-Jul-88 08:54:52 EDTDate: Fri, 15 Jul 88 08:54 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: BOGUS-FIXNUMSTo: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880715085441.8.KMP@PEWEE.SCRC.Symbolics.COM>Perhaps the real cause of trouble here is that we have only one type, FIXNUM,for two purposes -- (a) `machine precision' of either non-portable or hyper-optimized programs like Macsyma (b) `small integers' desiring efficiency.The reason I suggested SMALL-INTEGER is that I think that's what some peoplereally want to say. I'm much less strong on elminating FIXNUM than I am onproviding a useful alternative. As it is now, if you want efficient code butalso want it to be portable, you have nothing to say beyond a cumbersomesigned-byte or bounded integer range. Just as we provide the `common' sequence operations because it saves everyone from writing them over andover, so too we should provide the common declarations to save everyone fromwriting them.I think what Sandra is saying is not argued. FIXNUM declarations are veryseldom portable. Even in Macsyma, the alternate fixnum declared code mightsometimes be gone into on the basis of inputs being fixnums, sometimes notworrying as carefully as it might about whether intermediate values oroutputs will all be fixnums. And every now and then you might lose unlessyou've done some careful checking. GZ, JDalton, etc. are saying they'rewilling to do such checking sometimes.The problem is that naive users will see FIXNUM and mentally relate it tosmall integers when it's really quite different. Surely, I can imagine sucha user saying, there is at least the concept of a small integer. Since there's only one type even remotely like that, it must be it. In fact, thatwould be a wrong assumption. My reading of CLtL says the fixnum subrangeneed not even include zero. It might be (INTEGER 5 25), for example. Theremight, therefore, be integers smaller than FIXNUMs. We might want to justplain fix that. It might also include no numbers (though that leaves animplementation in a quandry about what to put in MOST-POSITIVE-FIXNUM, etc.)I think some CDC CL had this problem. As best I remember from a manual I sawa couple years ago, they had set the MOST-xxx vars to NIL because they hadthe same representation for all numbers and had chosen them to either allbe fixnums or all be bignums, I don't recall. All of this is bound to confusea novice who may just be seeking a simple, efficient type declaration.My revised view is that we leave FIXNUM and its associated vars be, andadd SMALL-INTEGER. We should choose the range of SMALL-INTEGER such that,then clearly document that, SMALL-INTEGER is a portable concept whichmight lead to inefficiency in an occasional implementation, but in mostimplementations it will be suitably fast. We should document that FIXNUMis intended to denote an implementation-specific type which is notportable, but which is useful in certain applications, like Macsyma, whichhave need to take the fullest advantage of whatever machine they're on, evenat the price of dealing more carefully with portability issues.I think the availability of a pre-defined and usefully sized type such asSMALL-INTEGER will make this explanation of FIXNUM much more palatable.I would remove the type BIGNUM. I think everyone expects it to mean(AND INTEGER (NOT FIXNUM)) anyway. I bet any implementation where it doesn'tmean this violates user expectations. Given that, one could just DEFTYPEit for compatibility if it was really used heavily in some particular case.*start*03020 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 14:34:24 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 18 Jul 88  14:33:27 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 434816; Mon 18-Jul-88 17:32:09 EDTDate: Mon, 18 Jul 88 17:31 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue BOGUS-FIXNUMS (initial draft)To: sandra%cdr@cs.utah.educc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880718173159.5.KMP@PEWEE.SCRC.Symbolics.COM>The problem I have with being told I should DEFTYPE my own SMALL-INTEGER is thefollowing:I believe that one of Lisp's greatest strengths (which is one of the things settingit apart from Pascal, for example) is not just that it has the potential forrepresenting and defining things, but that it is gutsy enough to actually predefinea set of things which people are likely to find useful.Most languages can, for example, represent their own programs. eg, you could createa PL/I program which constructed representations of other PL/I programs. Theimportant thing about Lisp is not that it can represent itself, but that thereis a common agreement about -how- to do such representation, so that non-cooperatingparties can agree.I think this is at the heart of why jpff and jeff don't want to get rid of fixnum.I'm happy with that.It's just a pain for programmers to have to write the DEFTYPE. DEFTYPE is hard tounderstand for a naive user. Using it involves at least a strong understanding ofthe type system, a thorough enough knowledge of CL to know that DEFTYPE exists atall, and a knowledge of how to use cons/list/backquote well enough to constructa new specifier. On the other hand, if some arbitrary type were predefined, thenmany people who understood only numerical programming could just go ahead and useit. It might not serve all their needs, but it would get them started. And it wouldget them used to the idea of a restricted range. Once you know the range is-2^16 to 2^16 or whatever, it's easier to know to ask how to declare a differentrange than it is to know to ask how to restrict the range if all you know is thatthere is an unrestricted range initially.Further, if we can agree on any range which makes us generally happy for a numberof small programs, then even if it's not -guaranteed- that it will be efficient,then it will be -likely- that it will be efficient if only because people tendto optimize things that have names much more than they optimized things you haveto compose, on the assumption that it's easier for users to trip over named thingsand so such optmizations will have higher visibility.So I think that saying that I should define my own type SMALL-INTEGER doesn'tsatsify my need and I stand by my suggestions of my previous message.*start*05109 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 15:54:07 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 18 Jul 88  15:49:52 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa04367; 18 Jul 88 16:31 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Mon, 18 Jul 88 16:52:03 BSTMessage-Id: <2479.8807181552@subnode.aiai.ed.ac.uk>To: cl-cleanup@sail.stanford.edu, sandra <@cs.utah.edu:sandra@cdr>Subject: Re: issue BOGUS-FIXNUMS (initial draft)Cc: jpff <@NSS.Cs.Ucl.AC.UK:jpff@maths.bath.ac.uk>> Date: Tue, 12 Jul 88 09:08:25 MDT> From: sandra <(Sandra J Loosemore)sandra%cdr@edu.utah.cs>What I want to establish is: [1] Fixnums are about as useful as, say,int or long in C (or if not can be made so rather than be eliminated),In KCL, fixnums can actually be compiled as ints.  [2] It's nice to havea standard name for efficient integers, and a standard name has to be inthe standard.  [3] Explicit subranges are not necessarily efficient andare often less convenient to use.Moreover, GZ has provided some examples from Macsyma that show thatfixnums can be used with a considerable degree of portability even asnow defined.In short, the argument for eliminating fixnums seems to be based on anoveremphasis on one aspect of portability rather than a considerationof what programmers actually do and want.> > From: Jeff Dalton <jeff%aiva.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>> > Date: Mon, 11 Jul 88 21:32:31 bst> > > > Even though fixnums may differ from implementation to> > implementation, I want a standard way to use them when they exist> > rather than allow implementations to diverge (so that some call> > them fixnums, others something else, and so on).> > Having a standard name is of little use unless it is tied to some> standard semantics.  The problem is that there is no guarantee what> you get when you say "fixnum".  There is currently no absolute> prohibition against defining the range of fixnums to be something> like 100,000 to 100,010.Well, then perhaps int and long in C are of "little use".  They arenot guaranteed to be the same size everywhere.Note too that your argument is for reforming fixnums, not foreliminating them, and I am not arguing against reform.> If you want "small integer", then by all means define your own small> integer type using DEFTYPE.  That way you're guaranteed to have it> mean exactly the same thing in all implementations. You may want it to mean "exactly the same thing" (meaning exactly thesame size); that is not what I am asking for.  Besides I don't want a small integer, I want an efficient one.  Asubrange is not guaranteed to be efficient, and so does not replaceFIXNUM.> > I do not accept the argument that it doesn't matter because everyone who> > provides fixnums can still provide them.  If they're not in the standard,> > users cannot in fact rely on them being provided in a standard way.Note that your response about packages below does not answer this.> > Indeed, if we decide to allow only standard symbols in the LISP package,> > users would have to type LUCID:FIXNUM, EXCL:FIXNUM, etc. rather than just> > FIXNUM as they can now.> Why not just import the appropriate symbol into the package you're using> once, and be done with it?This is still not providing fixnums in a standard way.  I still haveto add some conditional code for each implementation.> > Date: Tue, 12 Jul 88 10:33:24 BST> > From: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK> If your implementation supports a range of small integers> that are more efficient than larger integers, there is already a portable> way to declare them as such.  The range gets ported, but the efficiency may not.  Fixnums workadequately over a wide range of implementations without requiringimplementation-specific customization of my types.  I am even willing tohave some programs not work in implementations that have a sufficientlylosing notion of fixnums, just as I am willing to do this in otherlangauges.> To draw an analogy, small bignums are likely to be considerably faster and> more efficient than large bignums.  Should we assign a special name to> bignums with less than N "bigits" simply because they're faster than bignums> that are larger than that?That we do not want a name for every class of more efficient numberdoes not show we do not want a name for any such class.Moreover, compilers can (or at least do) get more in the way ofoptimization from fixnums than they would from "small bignums".> It appears I was misinformed on this point -- I was under the impression> that KCL boxed all integers and simply preallocated a range of small> integers.It does "box" all integers (though fixnum declarations may avoid this incompiled code).  But the representation of fixnums is simpler thanthat for bignums.  It is very much like Franz in this respect.-- Jeff*start*01616 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 15:56:17 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 18 Jul 88  15:54:37 PDTReceived: from maths.bath.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06386; 18 Jul 88 21:20 BSTReceived: from xenakis by mordell.maths.bath.AC.UK id aa27619;          18 Jul 88 21:45 BSTTo: sandra <@cs.utah.edu:sandra@cdr>CC: cl-cleanup@sail.stanford.edu, KMP@scrc-stony-brook.arpa, jeff <@NSS.Cs.Ucl.AC.UK:jeff@aiva.edinburgh.ac.uk>, jpff <@NSS.Cs.Ucl.AC.UK:jpff@maths.bath.ac.uk>In-reply-to: sandra (Sandra J Loosemore)'s message of Tue, 12 Jul 88 09:08:25 MDT <8807121508.AA23357@cdr.utah.edu>Subject: issue BOGUS-FIXNUMS (initial draft)Date: Mon, 18 Jul 88 21:44:49 BSTFrom: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UKSender: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK>>To draw an analogy, small bignums are likely to be considerably faster and>>more efficient than large bignums.  Should we assign a special name to>>bignums with less than N "bigits" simply because they're faster than bignums>>that are larger than that?  How useful would having such a special name be>>when both N and the size of the "bigit" vary from implementation to>>implementation? But the factors are much much bigger.  I still am not conmvinced byyour arguments for getting rid of FIXNUMS.  Maybe they should bebetter defined, but I cannot see a portable way of getting the effectI get in FORTRAN, C, etc etc==John*start*01056 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 15:57:18 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 18 Jul 88  15:56:28 PDTReceived: from maths.bath.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa07064; 18 Jul 88 23:11 BSTReceived: from xenakis by mordell.maths.bath.AC.UK id aa28020;          18 Jul 88 23:36 BSTTo: KMP@scrc-stony-brook.arpaCC: sandra <@cs.utah.edu:sandra@cdr>, CL-Cleanup@sail.stanford.eduIn-reply-to: Kent M Pitman's message of Mon, 18 Jul 88 17:31 EDT <880718173159.5.KMP@PEWEE.SCRC.Symbolics.COM>Subject: issue BOGUS-FIXNUMS (initial draft)Date: Mon, 18 Jul 88 23:36:04 BSTFrom: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UKSender: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK>>   The problem I have with being told I should DEFTYPE my own SMALL-INTEGER is the>>   following:That is well put; I think that is what I was trying to say.  Thankyou.==John*start*04147 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 19 JUL 88 13:51:19 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 19 Jul 88  13:49:52 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA27381; Tue, 19 Jul 88 14:49:30 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA00305; Tue, 19 Jul 88 14:49:26 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807192049.AA00305@cdr.utah.edu>Date: Tue, 19 Jul 88 14:49:19 MDTSubject: more on BOGUS-FIXNUMSTo: cl-cleanup@sail.stanford.eduApologies if this is a repeat -- I sent this message out a few daysago but it seems to have dropped into the bit bucket.  I'm willing towrite up a new proposal on this issue, but I'm not sure what directionthe committee wants it to go in.----Since it appears that nobody besides me (and Stan) likes my previousproposal on this issue and that I'll have to come up with somethingless radical that is more acceptable to the rest of the committee, Ithought it would be useful to enumerate some of the possibilities.  Irealize there are still two other issues which would still have to beaddressed when turning any of these into a real proposal, namelywhether to retain MOST-BLETCHEROUS-FIXNUM :-), and whether the BIGNUMtype specifier should remain and whether it must still be a non-emptyset which is disjoint from FIXNUM. #0 (what CLtL says):    - there is no particular type specifier defined for "small integers".    - the FIXNUM type specifier is defined but nothing is said about its      range.    - FIXNUMs are required to have a more efficient representation than      non-FIXNUMs.#1 (my original proposal):    - there is no particular type specifier defined for "small integers".    - the FIXNUM type specifier goes away.    - user-defined integer subrange types use the most efficient       representation possible in a given implementation.#2 (Gail Zacharias's counter-proposal):    - there is no particular type specifier defined for "small integers".    - the FIXNUM type specifier is defined to be a superset of      (SIGNED-BYTE n), for some value of "n" which has yet to be      decided but that we all agree upon.    - FIXNUMs are not required to coincide with or be a subset of the      set of integers which are represented most efficiently.#3 (change CLtL's "typically" to a firm requirement):    - there is no particular type specifier defined for "small integers".    - FIXNUMs must be a supertype of (SIGNED-BYTE n).    - FIXNUMs are defined to be the set of integers which are represented      most efficiently.#4 (dumb, but here for completeness):    - there is no particular type specifier defined for "small integers".    - the FIXNUM type specifier is defined to be equivalent to      (SIGNED-BYTE n).    - FIXNUMs are required to be a subset of the integers which are      represented most efficiently.#5: (Kent Pitman's suggestion):    - a new SMALL-INTEGER type specifier is introduced which is equivalent      to (SIGNED-BYTE n).    - the FIXNUM type specifier goes away.    - nothing is guaranteed about the efficiency of representation of      SMALL-INTEGERs.#6 (similar to #3):    - a new SMALL-INTEGER type specifier is introduced which is equivalent      to (SIGNED-BYTE n).    - the set of FIXNUMs is required to be a superset of SMALL-INTEGERs.    - FIXNUMs are defined as the set of integers with the most efficient      representation.  (This implies that SMALL-INTEGERS are also      guaranteed to be efficient.)#7 (a cross between #0 and #5):    - a new SMALL-INTEGER type specifier is introduced which is equivalent      to (SIGNED-BYTE n).    - the FIXNUM type specifier remains but the range of FIXNUMs is left      undefined, as is the relationship between FIXNUM and SMALL-INTEGER.    - FIXNUMs are defined as the set of integers with the most efficient      representation.  Nothing is guaranteed about the efficiency of       SMALL-INTEGERs.Comments, anyone?  -Sandra-------*start*00800 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 19 JUL 88 14:54:13 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 19 Jul 88  14:53:08 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 435456; Tue 19-Jul-88 17:52:04 EDTDate: Tue, 19 Jul 88 17:51 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: more on BOGUS-FIXNUMSTo: sandra%cdr@cs.utah.educc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8807192049.AA00305@cdr.utah.edu>Message-ID: <880719175155.9.KMP@PEWEE.SCRC.Symbolics.COM>I'd like to see a full blown proposal based around #7.*start*01655 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 20 JUL 88 12:19:22 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 20 Jul 88  12:17:00 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06991; 20 Jul 88 20:01 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Wed, 20 Jul 88 19:55:54 BSTMessage-Id: <8564.8807201855@subnode.aiai.ed.ac.uk>To: KMP@scrc-stony-brook.arpa, sandra <@cs.utah.edu:sandra@cdr>Subject: Re:  more on BOGUS-FIXNUMSCc: cl-cleanup@sail.stanford.edu> Date: Tue, 19 Jul 88 17:51 EDT> From: Kent M Pitman <KMP@arpa.scrc-stony-brook>> I'd like to see a full blown proposal based around #7.It might be interesting to see one, but #7 has small-integers, which haveat least a certain size but may be inefficient, and fixnums, which areefficient (if anything is) but may have (or not have) any size.  I am notsure why anyone would want to use these small integers rather than specifyexactly what range/size they want.  Are we supposed to imagine they mightvery well be efficient just as fixnums might very well be a reasonablesize?  The only definite advantage to small integers is that they'reportable, but they're portable in a sense I'm not sure anyone cares about.A definite disadvantage, however, is to create confusion between fixnumsand small integers, and also confusion between these small integers andwhat some Lisps have called small integers, namely the ones represented"directly by pointers".*start*01913 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 12:05:33 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 21 Jul 88  12:04:07 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06633; 21 Jul 88 19:56 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Thu, 21 Jul 88 19:52:13 BSTMessage-Id: <10668.8807211852@subnode.aiai.ed.ac.uk>To: Masinter.pa, sandra <@cs.utah.edu:sandra@cdr>Subject: Re: more on BOGUS-FIXNUMSCc: cl-cleanup@sail.stanford.edu> Date: 21 Jul 88 07:59 PDT> From: Masinter.pa@com.xerox> I like #3; there's some precedent for turning a ClTl's "typically" to> a firm requirement where it encourages portability and there doesn't> seem to be any reason to avoid it. We must be specific about the "n".> I'd propose "14", i.e., FIXNUMs must be a supertype of (SIGNED-BYTE> 14).It may seem perverse to say so, but I'm not sure this would be animprovement, for it would provide an implementation with 14-bitfixnums with what they might regard as sufficient defense: theystrictly conform to the standard.  I have similar fears about the 1024minimum for array-dimension-limit and array-total-size limit.  I don'tusually make sure my CL programs will run in a system where arrayscan't have more than 1024 elements, and if I did want to be sure I'dlook at the actual limit, not 1024.  But I'd probably complain if thelimit really were so low, and it somehow seems easier to say animplementation's low limit is pretty rediculous when it isn'texplicitly sanctioned by the standard.  Perhaps if the minimumswere a little bigger...Anyway, I favor a consistent policy on limits of this sort.  If wehave them for arrays, we can (should?) have them for fixnums.*start*00388 00024 US Date: 21 Jul 88 12:56 PDTFrom: masinter.paSubject: Re: more on BOGUS-FIXNUMSIn-reply-to: sandra%cdr@cs.utah.edu (Sandra J Loosemore)'s message of Thu, 21 Jul 88 10:35:52 MDTTo: sandra%cdr@cs.utah.educc: Masinter.pa, cl-cleanup@sail.stanford.eduXerox Common Lisp has 17-bit fixnums. LISP:MOST-POSITIVE-FIXNUM = 65535, LISP:MOST-NEGATIVE-FIXNUM = -65536.*start*00750 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 13:08:56 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Jul 88  13:07:56 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 21 JUL 88 12:55:03 PDTDate: 21 Jul 88 12:56 PDTFrom: masinter.paSubject: Re: more on BOGUS-FIXNUMSIn-reply-to: sandra%cdr@cs.utah.edu (Sandra J Loosemore)'s message of Thu, 21 Jul 88 10:35:52 MDTTo: sandra%cdr@cs.utah.educc: Masinter.pa, cl-cleanup@sail.stanford.eduMessage-ID: <880721-125503-4335@Xerox>Xerox Common Lisp has 17-bit fixnums. LISP:MOST-POSITIVE-FIXNUM = 65535,LISP:MOST-NEGATIVE-FIXNUM = -65536.*start*05109 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 09:16:11 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 18 Jul 88  09:09:22 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa04367; 18 Jul 88 16:31 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Mon, 18 Jul 88 16:52:03 BSTMessage-Id: <2479.8807181552@subnode.aiai.ed.ac.uk>To: cl-cleanup@sail.stanford.edu, sandra <@cs.utah.edu:sandra@cdr>Subject: Re: issue BOGUS-FIXNUMS (initial draft)Cc: jpff <@NSS.Cs.Ucl.AC.UK:jpff@maths.bath.ac.uk>> Date: Tue, 12 Jul 88 09:08:25 MDT> From: sandra <(Sandra J Loosemore)sandra%cdr@edu.utah.cs>What I want to establish is: [1] Fixnums are about as useful as, say,int or long in C (or if not can be made so rather than be eliminated),In KCL, fixnums can actually be compiled as ints.  [2] It's nice to havea standard name for efficient integers, and a standard name has to be inthe standard.  [3] Explicit subranges are not necessarily efficient andare often less convenient to use.Moreover, GZ has provided some examples from Macsyma that show thatfixnums can be used with a considerable degree of portability even asnow defined.In short, the argument for eliminating fixnums seems to be based on anoveremphasis on one aspect of portability rather than a considerationof what programmers actually do and want.> > From: Jeff Dalton <jeff%aiva.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>> > Date: Mon, 11 Jul 88 21:32:31 bst> > > > Even though fixnums may differ from implementation to> > implementation, I want a standard way to use them when they exist> > rather than allow implementations to diverge (so that some call> > them fixnums, others something else, and so on).> > Having a standard name is of little use unless it is tied to some> standard semantics.  The problem is that there is no guarantee what> you get when you say "fixnum".  There is currently no absolute> prohibition against defining the range of fixnums to be something> like 100,000 to 100,010.Well, then perhaps int and long in C are of "little use".  They arenot guaranteed to be the same size everywhere.Note too that your argument is for reforming fixnums, not foreliminating them, and I am not arguing against reform.> If you want "small integer", then by all means define your own small> integer type using DEFTYPE.  That way you're guaranteed to have it> mean exactly the same thing in all implementations. You may want it to mean "exactly the same thing" (meaning exactly thesame size); that is not what I am asking for.  Besides I don't want a small integer, I want an efficient one.  Asubrange is not guaranteed to be efficient, and so does not replaceFIXNUM.> > I do not accept the argument that it doesn't matter because everyone who> > provides fixnums can still provide them.  If they're not in the standard,> > users cannot in fact rely on them being provided in a standard way.Note that your response about packages below does not answer this.> > Indeed, if we decide to allow only standard symbols in the LISP package,> > users would have to type LUCID:FIXNUM, EXCL:FIXNUM, etc. rather than just> > FIXNUM as they can now.> Why not just import the appropriate symbol into the package you're using> once, and be done with it?This is still not providing fixnums in a standard way.  I still haveto add some conditional code for each implementation.> > Date: Tue, 12 Jul 88 10:33:24 BST> > From: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK> If your implementation supports a range of small integers> that are more efficient than larger integers, there is already a portable> way to declare them as such.  The range gets ported, but the efficiency may not.  Fixnums workadequately over a wide range of implementations without requiringimplementation-specific customization of my types.  I am even willing tohave some programs not work in implementations that have a sufficientlylosing notion of fixnums, just as I am willing to do this in otherlangauges.> To draw an analogy, small bignums are likely to be considerably faster and> more efficient than large bignums.  Should we assign a special name to> bignums with less than N "bigits" simply because they're faster than bignums> that are larger than that?That we do not want a name for every class of more efficient numberdoes not show we do not want a name for any such class.Moreover, compilers can (or at least do) get more in the way ofoptimization from fixnums than they would from "small bignums".> It appears I was misinformed on this point -- I was under the impression> that KCL boxed all integers and simply preallocated a range of small> integers.It does "box" all integers (though fixnum declarations may avoid this incompiled code).  But the representation of fixnums is simpler thanthat for bignums.  It is very much like Franz in this respect.-- Jeff*start*01472 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 22 JUL 88 10:01:57 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 22 Jul 88  09:57:07 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA26690; Fri, 22 Jul 88 10:56:43 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA02382; Fri, 22 Jul 88 10:56:41 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807221656.AA02382@cdr.utah.edu>Date: Fri, 22 Jul 88 10:56:40 MDTSubject: Re: more on BOGUS-FIXNUMSTo: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@nss.cs.ucl.ac.uk>Cc: cl-cleanup@sail.stanford.eduIn-Reply-To: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, Fri, 22 Jul 88 17:04:31 BSTI think this is probably just a misunderstanding of terminology --what Stan Shebs described to me as being "fixnums" are clearly not thesame beasties that you call "fixnums".  I could play devil's advocate here and point out that the confusionover terminology tends to support my argument for getting rid of thename "fixnum" from the language entirely; when an implementation hasseveral different classes of numbers, which one(s) do you call"fixnum"?  In PSL and its derivatives, for example, the class ofnumbers which are called "inums" (represented as immediate data) aremore "fixnum"ish than the class of numbers called "fixnums"!-Sandra-------*start*00388 00024 US Date: 21 Jul 88 12:56 PDTFrom: masinter.paSubject: Re: more on BOGUS-FIXNUMSIn-reply-to: sandra%cdr@cs.utah.edu (Sandra J Loosemore)'s message of Thu, 21 Jul 88 10:35:52 MDTTo: sandra%cdr@cs.utah.educc: Masinter.pa, cl-cleanup@sail.stanford.eduXerox Common Lisp has 17-bit fixnums. LISP:MOST-POSITIVE-FIXNUM = 65535, LISP:MOST-NEGATIVE-FIXNUM = -65536.*start*02207 00024 US Return-Path: <sandra%cdr@cs.utah.edu>Received: from cs.utah.edu ([10.0.0.4]) by Xerox.COM ; 21 JUL 88 09:35:55 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA24684; Thu, 21 Jul 88 10:35:57 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA01506; Thu, 21 Jul 88 10:35:53 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807211635.AA01506@cdr.utah.edu>Date: Thu, 21 Jul 88 10:35:52 MDTSubject: Re: more on BOGUS-FIXNUMSTo: Masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Masinter.pa@Xerox.COM, 21 Jul 88 07:59 PDT> Date: 21 Jul 88 07:59 PDT> From: Masinter.pa@Xerox.COM> > I like #3; there's some precedent for turning a ClTl's "typically" to> a firm requirement where it encourages portability and there doesn't> seem to be any reason to avoid it. We must be specific about the "n".> I'd propose "14", i.e., FIXNUMs must be a supertype of (SIGNED-BYTE> 14). That's small enough not to give even today's micros heartburn,> and large enough to avoid having people squawk too much.  It is> consistent with current practice, and removes some of the potential> portability requirements.This is also my favorite alternative (next to removing FIXNUMs entirely, that is).Actually, I don't think we have to worry particularly about supportingmicros.  According to Stan, it appears that the Lisp with the smallestfixnum range is actually Franz Lisp, which uses a separate spacesimplementation with fixnums in the range [-1024, 1023].  Here are somefixnum sizes for Lisp implementations that run on micros or otherwiseclaim to be "small":    Cambridge Lisp	24 bits    PC Scheme		15 bits    XLisp		C "long" (boxed, no bignums)    VT-Lisp		no integers, all numbers are Pascal "real"s    A-Lisp		30 bits  (immediate, no bignums)Stan says Gold Hill would not disclose information about theirimplementation.  It looks like all of other Lisp implementations hewas able to gather information on which claim to be Common Lisps (oreven subsets of Common Lisp) have fixnums at least 24 bits long.Therefore, unless somebody comes up with a counterexample, I think wecould safely retain the N=16 from CLtL.-Sandra-------*start*02346 00024 UU?Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 09:37:25 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 21 Jul 88  09:36:18 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA24684; Thu, 21 Jul 88 10:35:57 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA01506; Thu, 21 Jul 88 10:35:53 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807211635.AA01506@cdr.utah.edu>Date: Thu, 21 Jul 88 10:35:52 MDTSubject: Re: more on BOGUS-FIXNUMSTo: Masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Masinter.pa@Xerox.COM, 21 Jul 88 07:59 PDT> Date: 21 Jul 88 07:59 PDT> From: Masinter.pa@Xerox.COM> > I like #3; there's some precedent for turning a ClTl's "typically" to> a firm requirement where it encourages portability and there doesn't> seem to be any reason to avoid it. We must be specific about the "n".> I'd propose "14", i.e., FIXNUMs must be a supertype of (SIGNED-BYTE> 14). That's small enough not to give even today's micros heartburn,> and large enough to avoid having people squawk too much.  It is> consistent with current practice, and removes some of the potential> portability requirements.This is also my favorite alternative (next to removing FIXNUMs entirely, that is).Actually, I don't think we have to worry particularly about supportingmicros.  According to Stan, it appears that the Lisp with the smallestfixnum range is actually Franz Lisp, which uses a separate spacesimplementation with fixnums in the range [-1024, 1023].  Here are somefixnum sizes for Lisp implementations that run on micros or otherwiseclaim to be "small":    Cambridge Lisp	24 bits    PC Scheme		15 bits    XLisp		C "long" (boxed, no bignums)    VT-Lisp		no integers, all numbers are Pascal "real"s    A-Lisp		30 bits  (immediate, no bignums)Stan says Gold Hill would not disclose information about theirimplementation.  It looks like all of other Lisp implementations hewas able to gather information on which claim to be Common Lisps (oreven subsets of Common Lisp) have fixnums at least 24 bits long.Therefore, unless somebody comes up with a counterexample, I think wecould safely retain the N=16 from CLtL.-Sandra-------*start*01747 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 08:04:26 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Jul 88  08:03:34 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 21 JUL 88 07:59:17 PDTDate: 21 Jul 88 07:59 PDTFrom: Masinter.paSubject: Re: more on BOGUS-FIXNUMSIn-reply-to: sandra%cdr@cs.utah.edu (Sandra J Loosemore)'s message of Tue, 19 Jul 88 14:49:19 MDTTo: sandra%cdr@cs.utah.educc: cl-cleanup@sail.stanford.eduMessage-ID: <880721-075917-3637@Xerox>I think the SIGNED-INTEGER stuff is a little like PROCEDURE; there seems to besome sentiment for just patching what we have rather than introducing new names,especially where they are close.I like #3; there's some precedent for turning a ClTl's "typically" to a firmrequirement where it encourages portability and there doesn't seem to be anyreason to avoid it. We must be specific about the "n". I'd propose "14", i.e.,FIXNUMs must be a supertype of (SIGNED-BYTE 14). That's small enough not to giveeven today's micros heartburn, and large enough to avoid having people squawktoo much.  It is consistent with current practice, and removes some of thepotential portability requirements. While we're at it, let's make FIXNUM a built-in class for CLOS? If its usefulfor discrimination, and implementations have 'em, then why not be able to CLOSthem too?If you want to get rid of something, get rid of BIGNUM. It doesn't fit into theclass hierarchy as nicely, you don't want to use it for class discrimination(since it is (AND INTEGER (NOT FIXNUM)) and might really represent severalimplementation types.)*start*01913 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 12:05:33 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 21 Jul 88  12:04:07 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06633; 21 Jul 88 19:56 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Thu, 21 Jul 88 19:52:13 BSTMessage-Id: <10668.8807211852@subnode.aiai.ed.ac.uk>To: Masinter.pa, sandra <@cs.utah.edu:sandra@cdr>Subject: Re: more on BOGUS-FIXNUMSCc: cl-cleanup@sail.stanford.edu> Date: 21 Jul 88 07:59 PDT> From: Masinter.pa@com.xerox> I like #3; there's some precedent for turning a ClTl's "typically" to> a firm requirement where it encourages portability and there doesn't> seem to be any reason to avoid it. We must be specific about the "n".> I'd propose "14", i.e., FIXNUMs must be a supertype of (SIGNED-BYTE> 14).It may seem perverse to say so, but I'm not sure this would be animprovement, for it would provide an implementation with 14-bitfixnums with what they might regard as sufficient defense: theystrictly conform to the standard.  I have similar fears about the 1024minimum for array-dimension-limit and array-total-size limit.  I don'tusually make sure my CL programs will run in a system where arrayscan't have more than 1024 elements, and if I did want to be sure I'dlook at the actual limit, not 1024.  But I'd probably complain if thelimit really were so low, and it somehow seems easier to say animplementation's low limit is pretty rediculous when it isn'texplicitly sanctioned by the standard.  Perhaps if the minimumswere a little bigger...Anyway, I favor a consistent policy on limits of this sort.  If wehave them for arrays, we can (should?) have them for fixnums.*start*00388 00024 US Date: 21 Jul 88 12:56 PDTFrom: masinter.paSubject: Re: more on BOGUS-FIXNUMSIn-reply-to: sandra%cdr@cs.utah.edu (Sandra J Loosemore)'s message of Thu, 21 Jul 88 10:35:52 MDTTo: sandra%cdr@cs.utah.educc: Masinter.pa, cl-cleanup@sail.stanford.eduXerox Common Lisp has 17-bit fixnums. LISP:MOST-POSITIVE-FIXNUM = 65535, LISP:MOST-NEGATIVE-FIXNUM = -65536.*start*00750 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 13:08:56 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Jul 88  13:07:56 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 21 JUL 88 12:55:03 PDTDate: 21 Jul 88 12:56 PDTFrom: masinter.paSubject: Re: more on BOGUS-FIXNUMSIn-reply-to: sandra%cdr@cs.utah.edu (Sandra J Loosemore)'s message of Thu, 21 Jul 88 10:35:52 MDTTo: sandra%cdr@cs.utah.educc: Masinter.pa, cl-cleanup@sail.stanford.eduMessage-ID: <880721-125503-4335@Xerox>Xerox Common Lisp has 17-bit fixnums. LISP:MOST-POSITIVE-FIXNUM = 65535,LISP:MOST-NEGATIVE-FIXNUM = -65536.*start*00575 00024 US Return-Path: <Scott.Fahlman@sef1.slisp.cs.cmu.edu>Received: from SEF1.SLISP.CS.CMU.EDU ([128.2.218.13]) by Xerox.COM ; 21 JUL 88 13:51:34 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 21 Jul 88 16:50:13 EDTTo: Masinter.pacc: sandra%cdr@cs.utah.edu, cl-cleanup@sail.stanford.eduSubject: Re: more on BOGUS-FIXNUMS In-reply-to: Your message of 21 Jul 88 07:59:00 -0700.             <880721-075917-3637@Xerox> Date: Thu, 21 Jul 88 16:49:53 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUI agree with Larry and GZ on this.-- Scott*start*00697 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 13:52:34 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 21 Jul 88  13:51:20 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 21 Jul 88 16:50:13 EDTTo: Masinter.pacc: sandra%cdr@cs.utah.edu, cl-cleanup@sail.stanford.eduSubject: Re: more on BOGUS-FIXNUMS In-reply-to: Your message of 21 Jul 88 07:59:00 -0700.             <880721-075917-3637@Xerox> Date: Thu, 21 Jul 88 16:49:53 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUI agree with Larry and GZ on this.-- Scott*start*02906 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 22 JUL 88 19:11:45 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 22 Jul 88  19:08:37 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06384; 22 Jul 88 19:23 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Fri, 22 Jul 88 19:19:28 BSTMessage-Id: <23965.8807221819@aiai.ed.ac.uk>To: jeff <@NSS.Cs.Ucl.AC.UK:jeff@aiai.edinburgh.ac.uk>, sandra <@cs.utah.edu:sandra@cdr>Subject: Re: more on BOGUS-FIXNUMSCc: cl-cleanup@sail.stanford.edu> From: sandra <(Sandra J Loosemore)sandra%cdr@edu.utah.cs>> Date: Fri, 22 Jul 88 10:56:40 MDT> I think this is probably just a misunderstanding of terminology --> what Stan Shebs described to me as being "fixnums" are clearly not the> same beasties that you call "fixnums".  Yes, but the advantage of my position is that the beasties I call"fixnums" are the same beasties Franz, MacLisp, and most CL's call"fixnums".  (So there.)> I could play devil's advocate here and point out that the confusion> over terminology tends to support my argument for getting rid of the> name "fixnum" from the language entirely;No, it supports clarification of the terminology, not its elimination.> when an implementation has several different classes of numbers,> which one(s) do you call "fixnum"?The ones that are like "ints" (or maybe "longs"): that is, the onesthat are like machine integers (modulo type tags).  Of course, wealready know an implementation might pick a losing implementation offixnums, but there are lots of ways a CL can lose and still be CL.> In PSL and its derivatives, for example, the class of> numbers which are called "inums" (represented as immediate data) are> more "fixnum"ish than the class of numbers called "fixnums"!Actually (looking at PSL documentation), I suppose either could becalled fixnums if PSL were a Common Lisp; but PSL's "fixnums" arecloser to what I mean by "fixnums", espectially where inums are 19 bitand fixnums are 36 (DEC-20).What I want from fixnums is that proper declarations will get mecompiled code not much less efficient than for other languages onthe same machine, and using numbers with similar range.  (I'm willingto allow type information and for fixnums to be immediate.)Perhaps we should add somethng to CL for integers are are representedimmediately.  In some implementations, this would be the same set asfixnums, but would not have to be.BTW, my "real" address is below.Cheers,JeffJeff Dalton,                      JANET: J.Dalton@uk.ac.ed             AI Applications Institute,        ARPA:  J.Dalton%uk.ac.ed@nss.cs.ucl.ac.ukEdinburgh University.             UUCP:  ...!ukc!ed.ac.uk!J.Dalton*start*01796 00024 US Return-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 23 JUL 88 01:17:35 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06633; 21 Jul 88 19:56 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Thu, 21 Jul 88 19:52:13 BSTMessage-Id: <10668.8807211852@subnode.aiai.ed.ac.uk>To: Masinter.pa, sandra <@cs.utah.edu:sandra@cdr>Subject: Re: more on BOGUS-FIXNUMSCc: cl-cleanup@sail.stanford.edu> Date: 21 Jul 88 07:59 PDT> From: Masinter.pa@com.xerox> I like #3; there's some precedent for turning a ClTl's "typically" to> a firm requirement where it encourages portability and there doesn't> seem to be any reason to avoid it. We must be specific about the "n".> I'd propose "14", i.e., FIXNUMs must be a supertype of (SIGNED-BYTE> 14).It may seem perverse to say so, but I'm not sure this would be animprovement, for it would provide an implementation with 14-bitfixnums with what they might regard as sufficient defense: theystrictly conform to the standard.  I have similar fears about the 1024minimum for array-dimension-limit and array-total-size limit.  I don'tusually make sure my CL programs will run in a system where arrayscan't have more than 1024 elements, and if I did want to be sure I'dlook at the actual limit, not 1024.  But I'd probably complain if thelimit really were so low, and it somehow seems easier to say animplementation's low limit is pretty rediculous when it isn'texplicitly sanctioned by the standard.  Perhaps if the minimumswere a little bigger...Anyway, I favor a consistent policy on limits of this sort.  If wehave them for arrays, we can (should?) have them for fixnums.*start*01576 00024 US Return-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 23 JUL 88 01:34:38 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa05507; 22 Jul 88 17:08 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Fri, 22 Jul 88 17:04:31 BSTMessage-Id: <23641.8807221604@aiai.ed.ac.uk>To: Masinter.pa, sandra <@cs.utah.edu:sandra@cdr>Subject: Re: more on BOGUS-FIXNUMSCc: cl-cleanup@sail.stanford.edu> Date: Thu, 21 Jul 88 10:35:52 MDT> From: sandra <(Sandra J Loosemore)sandra%cdr@edu.utah.cs>> Subject: Re: more on BOGUS-FIXNUMS> Actually, I don't think we have to worry particularly about supporting> micros.  According to Stan, it appears that the Lisp with the smallest> fixnum range is actually Franz Lisp, which uses a separate spaces> implementation with fixnums in the range [-1024, 1023].That is not correct.  Fixnums in Franz are 32 bits, or at least theyare on VAX or 68k.  Look at any Franz manual or write some Franz codethat declares fixnums or uses fixed-type arithmetic if you want tocheck this.The [-1024, 1023] is for *small fixnums*.  They are just like normalfixnums but preallocated.  The "separate space" notion is sometimesused to check whether an integer is in the range of preallocated ones,but Franz in general uses bibop (the high order bits of the addressare an index into a type table).BTW, as I have mentioned before, Franz and KCL are vary similar inthis respect.-- Jeff*start*01693 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 22 JUL 88 09:30:38 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 22 Jul 88  09:24:11 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa05507; 22 Jul 88 17:08 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Fri, 22 Jul 88 17:04:31 BSTMessage-Id: <23641.8807221604@aiai.ed.ac.uk>To: Masinter.pa, sandra <@cs.utah.edu:sandra@cdr>Subject: Re: more on BOGUS-FIXNUMSCc: cl-cleanup@sail.stanford.edu> Date: Thu, 21 Jul 88 10:35:52 MDT> From: sandra <(Sandra J Loosemore)sandra%cdr@edu.utah.cs>> Subject: Re: more on BOGUS-FIXNUMS> Actually, I don't think we have to worry particularly about supporting> micros.  According to Stan, it appears that the Lisp with the smallest> fixnum range is actually Franz Lisp, which uses a separate spaces> implementation with fixnums in the range [-1024, 1023].That is not correct.  Fixnums in Franz are 32 bits, or at least theyare on VAX or 68k.  Look at any Franz manual or write some Franz codethat declares fixnums or uses fixed-type arithmetic if you want tocheck this.The [-1024, 1023] is for *small fixnums*.  They are just like normalfixnums but preallocated.  The "separate space" notion is sometimesused to check whether an integer is in the range of preallocated ones,but Franz in general uses bibop (the high order bits of the addressare an index into a type table).BTW, as I have mentioned before, Franz and KCL are vary similar inthis respect.-- Jeff*start*05344 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 17 JUL 88 08:21:31 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 17 Jul 88  08:20:24 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA03839; Sun, 17 Jul 88 09:19:07 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA23357; Tue, 12 Jul 88 09:08:27 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807121508.AA23357@cdr.utah.edu>Date: Tue, 12 Jul 88 09:08:25 MDTSubject: Re: issue BOGUS-FIXNUMS (initial draft)To: cl-cleanup@sail.stanford.eduCc: KMP@stony-brook.scrc.symbolics.com, jeff%aiva.edinburgh.ac.uk@nss.cs.ucl.ac.uk, jpff%maths.bath.ac.uk@nss.cs.ucl.ac.ukIn-Reply-To: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK, Tue, 12 Jul 88 10:33:24 BSTWell, I thought this issue would generate some flamage....  But before thisgets any farther, let me make one thing clear:  This proposal *is* *not*(read my lips!  IS NOT!) an attempt to do away with either efficient "fixnum"arithmetic or arbitrary precision arithmetic!  It is merely an attempt toget rid of some unfortunate and nonportable terminology from the languagestandard.> Date: Mon, 11 Jul 88 17:16 EDT> From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>> > This proposal might go over better if we replaced the feature with> another, more portable, feature addressing a similar need. eg,> >  SMALL-INTEGER could be defined as some range of integers which we>  think most implementations can support efficiently (but with the>  understanding that the important thing is to support it correctly>  rather than efficiently). For example, maybe SMALL-INTEGER could>  be defined as (INTEGER -2^30 (2^30)). [The specific bounds is open>  to discussion, of course, I'm just proposing ``something like this''.]Users can already define such a type (or types) on their own.  This techniqueis used quite extensively in CLX, where there are about a dozen typesdefined like:    (deftype int8 () '(signed-byte 8))    (deftype card16 () '(unsigned-byte 16))    (deftype array-index () `(integer 0 ,array-dimension-limit))Unlike "fixnum", these type specifiers have uniform semantics across allimplementations.  One would hope that in those implementations where theyare subtypes of "fixnum", the compiler would be smart enough to recognizethem as such.(As an aside, there is a precedent for doing this in other languagesas well.  Many Pascal compilers, for example, only have one size ofinteger that is allocated if you just say "integer".  But, if youdefine a subrange type like 0..255 instead, they'll only allocate an8-bit byte for it.)> From: Jeff Dalton <jeff%aiva.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>> Date: Mon, 11 Jul 88 21:32:31 bst> > Even though fixnums may> differ from implementation to implementation, I want a standard> way to use them when they exist rather than allow implementations> to diverge (so that some call them fixnums, others something else,> and so on).Having a standard name is of little use unless it is tied to somestandard semantics.  The problem is that there is no guarantee whatyou get when you say "fixnum".  There is currently no absoluteprohibition against defining the range of fixnums to be something like100,000 to 100,010.  If you want "small integer", then by all meansdefine your own small integer type using DEFTYPE.  That way you'reguaranteed to have it mean exactly the same thing in allimplementations. > I do not accept the argument that it doesn't matter because everyone who> provides fixnums can still provide them.  If they're not in the standard,> users cannot in fact rely on them being provided in a standard way.> Indeed, if we decide to allow only standard symbols in the LISP package,> users would have to type LUCID:FIXNUM, EXCL:FIXNUM, etc. rather than just> FIXNUM as they can now.Why not just import the appropriate symbol into the package you're usingonce, and be done with it?> Date: Tue, 12 Jul 88 10:33:24 BST> From: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK> > This looks like a giant step backwards.  Some of us are interested in> writing efficient code.  Even if some machines only have one> representation I find it hard to believe that there are not a subset> which are more efficient.  Are you seriously suggesting that LISP> should counternance numbers not being arbitary precision?Once again, I AM NOT PROPOSING TO GET RID OF ARBITRARY PRECISIONARITHMETIC.  If your implementation supports a range of small integersthat are more efficient than larger integers, there is already a portableway to declare them as such.  To draw an analogy, small bignums are likely to be considerably faster andmore efficient than large bignums.  Should we assign a special name tobignums with less than N "bigits" simply because they're faster than bignumsthat are larger than that?  How useful would having such a special name bewhen both N and the size of the "bigit" vary from implementation toimplementation? > Anyway KCL has fixnum, bignum and short fixnum.It appears I was misinformed on this point -- I was under the impressionthat KCL boxed all integers and simply preallocated a range of smallintegers.-Sandra-------*start*05109 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 09:16:11 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 18 Jul 88  09:09:22 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa04367; 18 Jul 88 16:31 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Mon, 18 Jul 88 16:52:03 BSTMessage-Id: <2479.8807181552@subnode.aiai.ed.ac.uk>To: cl-cleanup@sail.stanford.edu, sandra <@cs.utah.edu:sandra@cdr>Subject: Re: issue BOGUS-FIXNUMS (initial draft)Cc: jpff <@NSS.Cs.Ucl.AC.UK:jpff@maths.bath.ac.uk>> Date: Tue, 12 Jul 88 09:08:25 MDT> From: sandra <(Sandra J Loosemore)sandra%cdr@edu.utah.cs>What I want to establish is: [1] Fixnums are about as useful as, say,int or long in C (or if not can be made so rather than be eliminated),In KCL, fixnums can actually be compiled as ints.  [2] It's nice to havea standard name for efficient integers, and a standard name has to be inthe standard.  [3] Explicit subranges are not necessarily efficient andare often less convenient to use.Moreover, GZ has provided some examples from Macsyma that show thatfixnums can be used with a considerable degree of portability even asnow defined.In short, the argument for eliminating fixnums seems to be based on anoveremphasis on one aspect of portability rather than a considerationof what programmers actually do and want.> > From: Jeff Dalton <jeff%aiva.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>> > Date: Mon, 11 Jul 88 21:32:31 bst> > > > Even though fixnums may differ from implementation to> > implementation, I want a standard way to use them when they exist> > rather than allow implementations to diverge (so that some call> > them fixnums, others something else, and so on).> > Having a standard name is of little use unless it is tied to some> standard semantics.  The problem is that there is no guarantee what> you get when you say "fixnum".  There is currently no absolute> prohibition against defining the range of fixnums to be something> like 100,000 to 100,010.Well, then perhaps int and long in C are of "little use".  They arenot guaranteed to be the same size everywhere.Note too that your argument is for reforming fixnums, not foreliminating them, and I am not arguing against reform.> If you want "small integer", then by all means define your own small> integer type using DEFTYPE.  That way you're guaranteed to have it> mean exactly the same thing in all implementations. You may want it to mean "exactly the same thing" (meaning exactly thesame size); that is not what I am asking for.  Besides I don't want a small integer, I want an efficient one.  Asubrange is not guaranteed to be efficient, and so does not replaceFIXNUM.> > I do not accept the argument that it doesn't matter because everyone who> > provides fixnums can still provide them.  If they're not in the standard,> > users cannot in fact rely on them being provided in a standard way.Note that your response about packages below does not answer this.> > Indeed, if we decide to allow only standard symbols in the LISP package,> > users would have to type LUCID:FIXNUM, EXCL:FIXNUM, etc. rather than just> > FIXNUM as they can now.> Why not just import the appropriate symbol into the package you're using> once, and be done with it?This is still not providing fixnums in a standard way.  I still haveto add some conditional code for each implementation.> > Date: Tue, 12 Jul 88 10:33:24 BST> > From: jpff%maths.bath.ac.uk@NSS.Cs.Ucl.AC.UK> If your implementation supports a range of small integers> that are more efficient than larger integers, there is already a portable> way to declare them as such.  The range gets ported, but the efficiency may not.  Fixnums workadequately over a wide range of implementations without requiringimplementation-specific customization of my types.  I am even willing tohave some programs not work in implementations that have a sufficientlylosing notion of fixnums, just as I am willing to do this in otherlangauges.> To draw an analogy, small bignums are likely to be considerably faster and> more efficient than large bignums.  Should we assign a special name to> bignums with less than N "bigits" simply because they're faster than bignums> that are larger than that?That we do not want a name for every class of more efficient numberdoes not show we do not want a name for any such class.Moreover, compilers can (or at least do) get more in the way ofoptimization from fixnums than they would from "small bignums".> It appears I was misinformed on this point -- I was under the impression> that KCL boxed all integers and simply preallocated a range of small> integers.It does "box" all integers (though fixnum declarations may avoid this incompiled code).  But the representation of fixnums is simpler thanthat for bignums.  It is very much like Franz in this respect.-- Jeff*start*06244 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 28 JUL 88 16:30:23 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 28 Jul 88  12:01:26 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA06896; Thu, 28 Jul 88 13:00:51 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA05586; Thu, 28 Jul 88 13:00:48 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807281900.AA05586@cdr.utah.edu>Date: Thu, 28 Jul 88 13:00:46 MDTSubject: Issue BOGUS-FIXNUMS (Version 2)To: cl-cleanup@sail.stanford.eduIssue:		BOGUS-FIXNUMSReferences:	CLtL p. 14, 34, 43, 231Category:	CHANGE, CLARIFICATIONEdit History:   Version 1, 11 Jul 1988, Sandra Loosemore                Version 2, 27 Jul 1988, Sandra Loosemore (change direction)Problem Description: Implementations of Common Lisp are required to support two disjointsubsets of integers, fixnums and bignums, with the promise thatfixnums have a more efficient representation.  However, nothing isguaranteed about the range of integers which are fixnums: "Exactlywhich integers are fixnums is implementation-dependent; typically theywill be those integers in the range -2**n to 2**n - 1, inclusive, forsome n not less than 15."There are few uses of the fixnum type that are portable, given thecurrent definition.  In particular, many programmers use FIXNUM typedeclarations where they really mean "small integer".Furthermore, it is conceivable that an implementation could supportonly a single internal representation for integers, and someimplementations do support more than two representations with varyingranges and degrees of "efficiency".  In such a case, arbitrarilypartitioning integers into "fixnums" and "bignums" becomes anartificial contrivance which is more likely to confuse users than toensure portability of code.Proposal: BOGUS-FIXNUMS:TIGHTEN-DEFINITION(1) Change the wording at the top of page 14 of CLtL:  In most Common Lisp implementations, there is a range of integers that  are represented or operated on more efficiently than others; each such  integer is called a FIXNUM.  Common Lisp is designed to hide this  distinction as much as possible; the distinction between fixnums and  non-fixnums is visible to the user in only a few places where the  efficiency of representation or operation is important.  Exactly which  integers are fixnums is implementation-dependent.  However, it is  required that (SIGNED-BYTE 16) be a subtype of FIXNUM in every  implementation of Common Lisp.  If an implementation does not provide  a distinguished representation for small integers in this range, then  the types INTEGER and FIXNUM are considered equivalent in that  implementation.  See MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUM.(2) Change the wording at the top of page 34 of CLtL to indicate thatFIXNUM is a subtype of INTEGER (removing the reference to BIGNUM).(3) Remove BIGNUM from the table of standard type specifier symbols onpage 43 of CLtL.(4) State that the constants MOST-POSITIVE-FIXNUM andMOST-NEGATIVE-FIXNUM are allowed to have a value of NIL to indicatethat the implementation does not have a particular FIXNUMrepresentation distinct from other integers. (5) Introduce a new constant, MAX-INTEGER-LENGTH.  This is the maximumnumber of bits appearing in any integer; therefore, it is an upperbound on the INTEGER-LENGTH function.  The value can be NIL if thereare no limits short of memory availability.Rationale:Many programmers already use FIXNUM to mean "small integer"; thisproposal makes this usage portable, and allows programmers to use theFIXNUM type specifier in a way similar to how the "int" type is usedin C. Current Practice:Xerox Common Lisp has 17-bit fixnums.  I know of no other Lisp whichclaims to be an implementation or subset of Common Lisp that hasfixnums less than 24 bits long.Several existing Lisps have more than two representations forintegers, including Lisp 1.6 and Portable Standard Lisp.  The onlyLisps that exist now that have a single integer representation appearto be subsets that do not support infinite-precision arithmetic (forexample, XLisp and A-Lisp).A number of implementations place constraints on the size of integersapart from memory availability.  For example, the maximum number ofbits may be constrained to fit in a fixed-length field. Cost to implementors:Slight.  All implementations I know of already define FIXNUMs to be atleast 16 bits and would only have to remove the BIGNUM type specifier(or document it as an extension to the language) to be in compliancewith the proposal.Cost to users:Slight.  The removal of the BIGNUM type specifier will affect user codebut it appears to be little-used.  Code which assumes that the values ofthe constants MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUM are fixnumswould have to be changed to allow for the fact that they might be NIL.Benefits:The FIXNUM type specifier would have a portable interpretation.Introducing a new constant to describe the maximum size of integers makesit possible to describe an implementation's exact limitations on the rangeof integers it supports.  This constant would also be useful for thedescription of subset implementations.Discussion:An earlier proposal on this issue to remove the FIXNUM type specifierentirely was almost universally hated.Masinter and Fahlman expressed agreement with the general direction ofthe current proposal.  Pitman would like to see the range of FIXNUMsremain undefined and a SMALL-INTEGER type with a fixed range (but nopromises about efficiency) introduced.  JonL would like to see aguarantee that the value of the constant ARRAY-TOTAL-SIZE-LIMIT be afixnum (for efficient array addressing on stock hardware). Dalton suggests that the FIXNUM type should be made analagous to the"int" type in C.  While the original K&R definition of C didn'tguarantee anything about integer sizes, the ANSI C standard requiresints to be at least 16 bits long.Addition of the MAX-INTEGER-LENGTH constant was suggested by Stan Shebs.-------*start*01036 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 28 JUL 88 21:11:00 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 28 Jul 88  21:09:35 PDTReceived: from Burger.ms by ArpaGateway.ms ; 28 JUL 88 21:08:41 PDTFrom: masinter.paDate: 28 Jul 88 21:07:35 PDTSubject: Re: Issue BOGUS-FIXNUMS (Version 2)In-reply-to: sandra%cdr@cs.utah.edu's message of Thu, 28 Jul 88 13:00:46 MDT, <8807281900.AA05586@cdr.utah.edu>To: sandra%cdr@cs.utah.edu (Sandra J Loosemore)cc: cl-cleanup@sail.stanford.eduMessage-ID: <880728-210841-4619@Xerox>I'm sorry I didn't do this sooner, but I think the issue name should beFIXNUM-NONPORTABLE instead of BOGUS-FIXNUMS. It is less emotionally loaded, andfollows the convention that issue names start with terms that can be found inCLtI (Common Lisp the Index.) I'm not sure if "Bogus" is there, but I doubt thatthe index entry would lead you to FIXNUMs if it were.*start*00691 00024 USfReturn-Path: <sandra%cdr@cs.utah.edu>Received: from cs.utah.edu ([10.0.0.4]) by Xerox.COM ; 29 JUL 88 07:39:28 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA27381; Fri, 29 Jul 88 08:39:38 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA06093; Fri, 29 Jul 88 08:39:36 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807291439.AA06093@cdr.utah.edu>Date: Fri, 29 Jul 88 08:39:34 MDTSubject: Re: Issue BOGUS-FIXNUMS (Version 2)To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM, 28 Jul 88 21:07:35 PDTI'm sorry, I wasn't aware that such a convention existed.  By CLtI do youmean the index at the back of CLtL?-Sandra-------*start*04951 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 31 JUL 88 13:41:42 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 31 Jul 88  13:40:37 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 440629; Sun 31-Jul-88 16:39:34 EDTDate: Sun, 31 Jul 88 16:39 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue BOGUS-FIXNUMS (Version 2)To: Sandra J Loosemore <sandra%cdr@cs.utah.edu>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8807281900.AA05586@cdr.utah.edu>Message-ID: <19880731203905.4.MOON@EUPHRATES.SCRC.Symbolics.COM>I approve of BOGUS-FIXNUMS:TIGHTEN-DEFINITION for the most part, butI have a few comments and doubts to offer.    (3) Remove BIGNUM from the table of standard type specifier symbols on    page 43 of CLtL.I don't approve or disapprove of this part; I'm of two minds about it.  Itmay be an unnecessary incompatible change.  If anyone opposes it, I willgo along with them.    (4) State that the constants MOST-POSITIVE-FIXNUM and    MOST-NEGATIVE-FIXNUM are allowed to have a value of NIL to indicate    that the implementation does not have a particular FIXNUM    representation distinct from other integers. I don't think that allowing these constants to be NIL enhances portability.That means a lot of "gratuitous" checking for NIL would be required.  Ithink a better idea is to require that these constants always have integervalues, and that if an implementation really cannot identify any efficientrange of integers, it should set these constants to arbitrary valuesconsistent with the requirement that (SIGNED-BYTE 16) is a subtype ofFIXNUM.  Think about a program that would use these constants toparameterize an algorithm, as in the example taken from Macsyma that doesmodular arithmetic using the largest prime modulus that fits in a FIXNUM.What does such a program gain by allowing NIL here?In fact I would think that an implementation with only one representationfor integers could define integers represented in a single bignum-digit tobe its fixnums; those are more efficient than larger integers, just not byas large a factor as in some other implementations.    (5) Introduce a new constant, MAX-INTEGER-LENGTH.  This is the maximum    number of bits appearing in any integer; therefore, it is an upper    bound on the INTEGER-LENGTH function.  The value can be NIL if there    are no limits short of memory availability.Again I don't think allowing this constant to be NIL makes sense.  Yousurely aren't saying that if this constant is non-NIL, the implementationguarantees that there is enough memory to create at least one integer ofthe specified length, let alone as many integers of that length as theprogram might need.  Thus memory availability is always a limitation, andimplementations that truly have no representation limit on the number ofbits in an integer should set this constant to a value that is guaranteedto be higher than the memory limit.Possibly what I just said is an argument that this constant should not exist,because there is no correct way to use it.  It tells a portable programnothing about what it can or cannot do.Or possibly it's an argument that under your definition, any implementationwith a non-NIL MAX-INTEGER-LENGTH would be in violation of the bottom ofCLtL page 13, which says there is no limit on the magnitude of an integerother than storage.  By that reasoning the Symbolics 3600 would be inviolation, since its address space exceeds its bignum representation limit.However, the bignum representation limit is large enough that numbers ofthat size become impracticably slow [see, memory isn't the limit either,the real limit can be asymptotic speed of arithmetic algorithms] and Idoubt that Symbolics would care to change their bignum representationto allow larger bignums which no one could actually use.    Introducing a new constant to describe the maximum size of integers makes    it possible to describe an implementation's exact limitations on the range    of integers it supports.  This constant would also be useful for the    description of subset implementations.It's true that it's useful to describe these aspects of an implementation.I'm not sure that that justifies putting the description into the CommonLisp language, rather than English.  On the whole, I weakly oppose part 5.    Rationale:    Many programmers already use FIXNUM to mean "small integer"; this    proposal makes this usage portable, and allows programmers to use the    FIXNUM type specifier in a way similar to how the "int" type is used    in C. I.e. as an unending source of bugs and portability problems.  :-(Maybe I'm just down on C today.*start*02331 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 29 JUL 88 23:08:09 PDTReceived: from ucbvax.berkeley.edu by SAIL.Stanford.EDU with TCP; 29 Jul 88  23:06:49 PDTReceived: by ucbvax.berkeley.edu (5.59/1.28)	id AA15744; Fri, 29 Jul 88 23:03:47 PDTFrom: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUReceived: by trwrb.TRW.COM (5.51/1.36)	id AA26084; Fri, 29 Jul 88 19:07:48 PDTDate: Fri, 29 Jul 88 19:07:48 PDTMessage-Id: <8807300207.AA26084@trwrb.TRW.COM>To: cl-cleanup@sail.stanford.eduSubject: bignumsI'm disappointed if implementations without bignums are considered to be incompliance with the specification of Common Lisp.  The term "bignum" reallydoes have a meaning: integers whose range is limited only by available memoryand that lie outside of the fixnum range.  If implementations have "bignums"that are limited to a bit field length, then they don't really have bignums.The term "bignum" typically implies other pieces of info about the integersthat it labels: bignums cons and arithmetic on them is not as efficient asthat performed on fixnums.While I applaud the effort to provide truely portable type specifiers, I donot agree with the sentiment for removing from Common Lisp type specificationsthat are not portably defined in so far as the range of values contained inthe type varies from implementation to implementation.  The type of programmingthat you do when you use "fixnums" is very different from what you do usinga specific integer range.  Retaining the term "bignum" to denote that type ofintegers that I described above, even as varying from implementation toimplementation seems useful to me.  Sometimes, you want to program in amostly portable way that takes into account the underlying system for sakeof efficiency.  I see no reason why the type specifiers "fixnum" and even"bignum" are not useful identifiers for often-used concepts in this sort ofprogramming.  So, I advocate leaving "fixnum" and "bignum" as type identifiersin Common Lisp.  I'd also advocate further specifying that "bignums" reallyshould have range limited only my memory space and that using a fixed bit-fieldsize is NOT an appropriate implementation of "bignums".--Joe Ginder*start*02662 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 04 AUG 88 23:50:08 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 4 Aug 88  23:49:47 PDTReceived: by labrea.stanford.edu; Thu, 4 Aug 88 23:48:34 PDTReceived: from bhopal.lucid.com by edsel id AA10028g; Thu, 4 Aug 88 22:30:50 PDTReceived: by bhopal id AA15094g; Thu, 4 Aug 88 22:32:30 PDTDate: Thu, 4 Aug 88 22:32:30 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8808050532.AA15094@bhopal.lucid.com>To: trwrb!smpvax1!jrg@ucbvax.berkeley.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDU's message of Fri, 29 Jul 88 19:07:48 PDT <8807300207.AA26084@trwrb.TRW.COM>Subject: bignumsre:  I'd also advocate further specifying that "bignums" really    should have range limited only my memory space and that using a fixed     bit-field size is NOT an appropriate implementation of "bignums".Have you considered the possibility that for even moderately small "fixed bit-field" sizes, the range of bignums specified is larger than any reasonable amount of virtual memory that your operating system will allow you to have (and garbage collect)?Seriously, I have advocated a minimum size for most-positive-fixnum asabout 2^24-1, which I think is defensible in terms of hardware to do"efficient" arithmetic.  Do you feel like proposing (and defending) a minimum size for most-positive-bignum?Two interesing stories (really true!): (1) During the days that Bill Gosper was computing larger and larger      decimal expansions of pi, he happened upon a huge bignum on the 3600      that caused it to "die of constipation".  It seems that sufficient     space had been allocated for it, but at the time of a GC flip, there     wasn't sufficient space to copy it.  [This was about 1984 I think.] (2) A similar thing actually happened to me later, on a 3600.  Suspecting     that I knew about a "bit-field size", I was intending to compute      log2(most-positive-bignum); but unfortunately a typo put in some extra     shifting steps, so that I actually computed something close to      most-positive-bignum.  As in RWG's case, I finally got caught by the      GC-flip, and fell into some sort of debugger loop.  I intercepted it      a couple days later in a state of catatonia -- apparently it was trying     to print out the arguments in the frame that had caused the death, and      printing most-positive-bignum in base 10 appeared to be taking some time     . . . -- JonL --*start*01668 00024 US Return-Path: <spt!gz@EDDIE.MIT.EDU>
Received: from EDDIE.MIT.EDU ([18.62.0.6]) by Xerox.COM ; 13 JUL 88 15:42:46 PDT
Received: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA04393@EDDIE.MIT.EDU>; Wed, 13 Jul 88 18:41:56 EDT
Received: by spt.entity.com (smail2.5); 13 Jul 88 18:22:03 EDT (Wed)
To: Masinter.pa
Cc: sandra%cdr@cs.utah.edu, cl-cleanup@sail.stanford.edu
In-Reply-To: Masinter.pa@Xerox.COM's message of 12 Jul 88 16:00 PDT <880712-160135-1829@Xerox>
Subject: issue BOGUS-FIXNUMS (initial draft) 
Message-Id: <8807131822.AA09967@spt.entity.com>
Date: 13 Jul 88 18:22:03 EDT (Wed)
From: gz@spt.entity.com (Gail Zacharias)

   Date: 12 Jul 88 16:00 PDT
   From: Masinter.pa@Xerox.COM

   Sigh, that's just the kind of code that is very non-portable and that I'd
   like to discourage programmers from writing. I've tried to import stuff
   from a CL that had 31 bit FIXNUMs into a system that had 17-bit FIXNUMs
   and, out of sheer laziness, they said FIXNUM when they really meant
   (signed-byte 24).

It's only non-portable if used on values which are not guaranteed to to be
within the FIXNUM range.  If FIXNUMs were guaranteed to be at least
(signed-byte 24), it would be a perfectly valid program.  Since they're not,
you just had the misfortune of working with buggy code.  Buggy code can be
written using all sorts of otherwise-useful CL constructs.

The problem is of course that currently nothing is guaranteed to be in the
fixnum range, so even programs that use FIXNUM for numbers between -1 and
1 are nominally buggy.  I think the solution is to guarantee some reasonable
range and be done with it.
*start*01961 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 JUL 88 12:24:42 PDT
Received: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 13 Jul 88  12:19:23 PDT
Received: from aiva.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP
           id aa07416; 13 Jul 88 19:54 BST
From: Jeff Dalton <jeff%aiva.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>
Date: Wed, 13 Jul 88 20:16:02 bst
Message-Id: <847.8807131916@aiva.ed.ac.uk>
To: gz%spt.entity.com@NSS.Cs.Ucl.AC.UK, sandra <@cs.utah.edu:sandra@cdr>
Subject: Re:  an alternate BOGUS-FIXNUMS proposal
Cc: cl-cleanup@sail.stanford.edu

Date: Wed, 13 Jul 88 09:52:31 MDT
From: sandra <(Sandra J Loosemore)sandra%cdr@edu.utah.cs>

> Gail Zacharias has suggested an alternate proposal on this issue.

> I suppose a proposal along these lines would be a better than the
> status quo.  However, I do see some problems:

I don't mind proposals that make fixnums more portable.  Do you still
think they should be eliminated instead?  Perhaps we should look at
what languages like C say about "short", "int", and "long".  (Very
little is promised, as I recall.)

> - Forcing users to DEFTYPE their own integer subrange types instead
>   would encourage better use of data abstraction.  I've noticed that 
>   Lisp programs are typically much sloppier about this than programs
>   written in strongly typed languages such as C or Pascal.

Well, I for one do not want to figure out exactly what range I need in
every case.  And in some cases I may not know an exact range.  What I
want is more or less soemthing that says "give me an int (as in C,
say), not a BIGNUM".

I'm not sure just what aspects of C and Pascal programs you have in
mind.  There are certainly many programs that use "int" or "long", and
those are analogous to FIXNUM, not to explicit ranges of integers or
numbers of bits.

-- Jeff

*start*03474 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>
Redistributed: xerox-cl-cleanup^.pa
Received: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 JUL 88 10:26:42 PDT
Received: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Jul 88  08:53:30 PDT
Received: by cs.utah.edu (5.54/utah-2.0-cs)
	id AA12244; Wed, 13 Jul 88 09:53:13 MDT
Received: by cdr.utah.edu (5.54/utah-2.0-leaf)
	id AA24171; Wed, 13 Jul 88 09:52:32 MDT
From: sandra%cdr@cs.utah.edu (Sandra J Loosemore)
Message-Id: <8807131552.AA24171@cdr.utah.edu>
Date: Wed, 13 Jul 88 09:52:31 MDT
Subject: an alternate BOGUS-FIXNUMS proposal
To: cl-cleanup@sail.stanford.edu, gz@spt.entity.com (Gail Zacharias)
In-Reply-To: gz@spt.entity.com (Gail Zacharias), 12 Jul 88 18:30:10 EDT (Tue)

Gail Zacharias has suggested an alternate proposal on this issue.  The
relevant parts are:

> Proposal:	BOGUS-FIXNUMS:SET-MINIMUM
> 
> (1) Require that (SIGNED-BYTE 15) must be a subtype of FIXNUM.
> 
> (2) Specify that MOST-POSITIVE-FIXNUM and/or MOST-NEGATIVE-FIXNUM may be
> NIL to indicate no limit aside from any placed on the size of integers.
> That is, the FIXNUM type is equivalent to
>    `(INTEGER ,(OR MOST-NEGATIVE-FIXNUM '*) ,(OR MOST-POSITIVE-FIXNUM '*))
>
> Implementations which do not have fixnums (or do not wish to advertise them
> as such) should make the FIXNUM type be the same as INTEGER and set the
> MOST-POSITIVE/NEGATIVE-FIXNUM constants to NIL.
> 
> Implementations which have fixnums of less than 15 bits would become
> implementations without fixnums.  They would have to make FIXNUM be the
> same as INTEGER and pick a different name for their small integers.
> The efficient integers of such implementations cannot be taken advantage of
> by portable programs by means of FIXNUM declarations.


I suppose a proposal along these lines would be a better than the
status quo.  However, I do see some problems:

- It does not address the issue of what happens to the BIGNUM type
  specifier.  If it remains in the language, are BIGNUM and FIXNUM still
  required to be disjoint?  If an implementation has only a single
  representation for integers and FIXNUM == INTEGER, would the set of
  BIGNUMs be empty?  Or would it be similar to how the different types
  of floats are handled if an implementation does not support all 4
  distinct representations?

- Programmers would still be able to put FIXNUM declarations in their
  code, but under this proposal FIXNUMs would not necessarily guarantee
  the most efficient representation (which appears to be the main reason
  why people are so anxious to preserve the FIXNUM type in the first
  place).

- Forcing users to DEFTYPE their own integer subrange types instead
  would encourage better use of data abstraction.  I've noticed that 
  Lisp programs are typically much sloppier about this than programs
  written in strongly typed languages such as C or Pascal. 

Also, note that if users specify a smaller subrange of integers than
the nominal FIXNUM size in their declarations, it may be possible to
get even more improvements in performance.  For example, a Lisp
implementation on a M68000 typically sizes fixnums to fit in a 32-bit
longword, but if enough type information is available to deduce that
the integers will fit in 16 bits (including perhaps 2 or 3 low tag
bits), it would be possible to use the significantly faster word-sized
arithmetic operations instead of longword operations.

-Sandra
-------

*start*05025 00024 US Return-Path: <edsel!jonl@labrea.stanford.edu>Received: from labrea.stanford.edu ([36.8.0.47]) by Xerox.COM ; 22 JUL 88 06:48:57 PDTReceived: by labrea.stanford.edu; Fri, 22 Jul 88 06:48:19 PDTReceived: from bhopal.lucid.com by edsel id AA07179g; Fri, 22 Jul 88 06:39:24 PDTReceived: by bhopal id AA04492g; Fri, 22 Jul 88 06:40:17 PDTDate: Fri, 22 Jul 88 06:40:17 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8807221340.AA04492@bhopal.lucid.com>To: masinter.paCc: jeff%aiai.edinburgh.ac.uk@nss.cs.ucl.ac.uk, sandra%cdr@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 21 Jul 88 12:56 PDT <880721-125503-4335@Xerox>Subject: FIXNUM's aren't Bogus!re: Xerox Common Lisp has 17-bit fixnums. LISP:MOST-POSITIVE-FIXNUM = 65535,    LISP:MOST-NEGATIVE-FIXNUM = -65536.This choice is quite arbitrary.  FIXNUM is not constrained to mean"immediate" data type (indeed it was NOT an immediate in PDP10 MacLisp), and Xerox Lisp's FIXP could just have well been included in its FIXNUMtype; that would have yielded a range of 32 bits rather than 17.  At one time, at least some implementations of Interlisp-D had microcode to cover the case of FIXP's; so it was a relatively efficient type.MacLisp may be considered to be the father of the modern FIXNUM -- it originated the trick of reserving a couple pages of write-protected memory filled in with a dense neighborhood of integers centered around 0; thus "consing" a small fixnum didn't require new storage allocations.  The critical meaning for FIXNUM's, however, is not merely that they be "small",nor that basic operations on them not consume storage, but that they be operable in a few, fixed number of steps.  In fact, in compiled code, the basic operations (on fixnums) were always one PDP10 instruction [including the four rationals, shifting, and even HAULONG, the predecessor of CL's INTEGER-LENGTH.  Love that JFFO!]  A *uniform* representation for fixnums was the critical factor in compiling these operations into one machine instruction.The opposite of FIXNUM is thus a datum that falls into the asymptotic algorithms of "bignums", whose operational timing is proportional to the length of the numbers involved. I propose this meaning for FIXNUM: that the basic integer operationsuse algorithms that are not proportional to the size of the data;  it should be just about as fast to add numbers in the middle of the fixnum range as it is to add, say, 10 and 11.I would _prefer_ that the range of positive FIXNUM's be at least as large ARRAY-TOTAL-SIZE-LIMIT, so that one can be assured that any legitimate array index is a FIXNUM.  However, I'll admit that this is of moreconcern to an implementation on "stock" hardware with "general purpose"indexing registers.Regarding the portability issues raised by differing FIXNUM ranges --I agree with all of Jeff Dalton's comments.  Championing portabilityhere is making a mountain of a molehill.-- JonL --P.S.  A candidate for early fixnums might also be Interlisp-10's assymetric      representation, wherein very small integers were "immediate" and      medium-sized integers fit into one word (maybe Lisp1.5 had a similar      scheme too?).  Although operating on such a representation did not      require use of an "asymptotic" algorithm, it did require so much more      time than the PDP10 MacLisp scheme that they were not considered      particularly "efficient" by the relevant community of users.  In fact,     just decoding the representation cost a subroutine call.  [Who among      us remembers (JSP T, NUMVAL)?] P.P.S.  The more common technique now for representing fixnums is to     notice that on byte-addressed machines (like VAX, MC68000 series,     INTEL 80386, most Risc-type machines, etc.) the low-order two bits      or more of an address are redundant (cons cells requiring at least 4     and probably 8 bytes of memory).  So the low-order two or three bits      can be used arbitrarily as datatype tag information, and a prudent      choice of the tag code leads to a very efficient FIXNUM implementation.     Let fixnums have all "low-order" bits zero; thus data in a format like:                          sxxx...xx0...0     (where "s" is a sign bit and the "x"'s are arbitrary bits) will still     be in that format after a machine "longword" addition or subtraction;     and multiplication and division require at most a pre- or post- shift     by a couple bits to retain that format.  Hence basic fixnum operations     can still be done in about one machine instruction. [I credit Stallman      with first noticing the immense utility of this fact, back in 1978      when we were brainstorming the design of VAX/NIL].  Despite the vast      difference in implementational "tricks", PDP10 MacLisp and VAX/NIL     share what I condsider to be the fundamental feature: low, constant-     time value for basic operations costs.    *start*01148 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 SEP 88 14:18:48 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 12 Sep 88  14:18:24 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA15705; Mon, 12 Sep 88 14:17:02 PDTMessage-Id: <8809122117.AA15705@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comDate: 12 Sep 88 16:39To: cl-cleanup@sail.stanford.eduSubject: Issue: BOGUS-FIXNUMSIs there still a proposal here?  If so, could someone (Sandra?!) updatethe proposal to address all the concerns brought out in the mail.There's too much there for me to assimilate in one sitting.Thanks			---WalterPS  Actually, maybe every ought to be updating their proposals so we cancut down on the work Larry has to do and so that we can get as manyproposals ready in time for the next meeting.PPS  When/where is the next cleanup subcommittee meeting?  I'd preferMonday morning early, to avoid conflict with the editorial mtg, butsuch a time might be difficult for people on west-coast time.*start*03677 00024 US Date: 15 Sep 88 01:15 PDTFrom: masinter.paSubject: Re: Issue FIXNUM-NONPORTABLE (Version 1) to: cl-cleanup@sail.stanford.educc: MasinterI separated this issue from BOGUS-FIXNUM. Why don't we get this one out of the way and then see what we have left?Issue:		FIXNUM-NON-PORTABLEReferences:	CLtL p. 14, 34, 43, 231Category:	CHANGE, CLARIFICATIONEdit History:   Version 1, 15-Sep-88, Masinter	based on BOGUS-FIXNUM by Sandra LoosemoreProblem Description: Implementations of Common Lisp are required to support two disjointsubsets of integers, fixnums and bignums, with the promise thatfixnums have a more efficient representation.  However, nothing isguaranteed about the range of integers which are fixnums: "Exactlywhich integers are fixnums is implementation-dependent; typically theywill be those integers in the range -2**n to 2**n - 1, inclusive, forsome n not less than 15."There are few uses of the fixnum type that are portable, given thecurrent definition.  In particular, many programmers use FIXNUM typedeclarations where they really mean "small integer".While most Common Lisp implementations have a FIXNUM rangewhich is a subset of integers represeted and operated on mostefficiently, many also have several other subranges.  Thepartitioning of INTEGER into BIGNUM and FIXNUM is merelyconfusing in these implementations, and not useful.Proposal: FIXNUM-NONPORTABLE:TIGHTEN-DEFINITION(1) Change the description of the type FIXNUM to reflect that it is required to be a supertype of (SIGNED-BYTE 16).(2) remove the type BIGNUM from the language.Rationale:Many programmers already use FIXNUM to mean "small integer"; thisproposal makes this usage portable, and allows programmers to use theFIXNUM type specifier in a way similar to how the "int" type is usedin C. Current Practice:Xerox Common Lisp has 17-bit fixnums.  Most other Common Lisp implementations have  fixnum ranges of 24 bits or larger. We knowof no implementation that currently violates the proposed minimum size.Several existing Common Lisp implementations have more than two representations for integers, such that the FIXNUM/BIGNUM distinctionis confusing.Cost to implementors:Slight.  All implementations I know of already define FIXNUMs to be atleast 16 bits and would only have to remove the BIGNUM type specifierto be in compliance with the proposal.Cost to users:Slight.  The removal of the BIGNUM type specifier will affect user codebut it appears to be little-used. Benefits:The FIXNUM type specifier would have a portable interpretation.The language would be less confusing.Discussion:Earlier versions of this proposal contained several other more controversialcomponents (adding a constant MAX-INTEGER-LENGTH, allowing MOST-POSITIVE-FIXNUM to be NIL as well as an integer.) This proposalis an attempt to address the part that cleanup committee seemed to agree on.It is possible that an implementation have a single  representation for allintegers, and no way to identify any efficient range of integers. Those implementationsmight need to set MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUMto arbitrary values, consistent with the requirement that (SIGNED-BYTE 16) is a subtype ofFIXNUM.Other alternatives considered (and not necessarly mutually exclusivewith this proposal):  remove the FIXNUM type specifier entirely   leave the range of FIXNUMs unconstrained  and a SMALL-INTEGER type  with a fixed range (but no promises about efficiency) introduced.   guarantee that the value of the constant ARRAY-TOTAL-SIZE-LIMIT be a  fixnum (for efficient array addressing)*start*00658 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 15 SEP 88 12:26:24 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 459868; Thu 15-Sep-88 15:25:55 EDTDate: Thu, 15 Sep 88 15:26 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: FIXNUM-NONPORTABLE vs FIXNUM-NON-PORTABLETo: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <uc18Q@SAIL.Stanford.EDU>Message-ID: <880915152605.6.KMP@GRYPHON.SCRC.Symbolics.COM>Your subject line doesn't match the issue name.*start*01086 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 18 SEP 88 12:39:40 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 461255; Sun 18-Sep-88 15:38:57 EDTDate: Sun, 18 Sep 88 15:38 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue FIXNUM-NONPORTABLE (Version 1) To: masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <880915-011455-2083@Xerox>Message-ID: <19880918193859.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI'm neutral on FIXNUM-NONPORTABLE:TIGHTEN-DEFINITION.  I'd be equallyhappy with such alternatives as retaining the status quo or eliminatingthe FIXNUM type but keeping a way to query what is the most efficientrange of integers.  The phrase `use the FIXNUM type specifier in a waysimilar to how the "int" type is used in C' really puts me off, sinceI have been shafted innumerable times by C's failure to specify anyportable meaning for the "int" type.*start*04475 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 SEP 88 02:43:42 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Sep 88  02:42:58 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 SEP 88 02:37:28 PDTDate: 23 Sep 88 02:37 PDTFrom: masinter.paSubject: Re: Issue FIXNUM-NON-PORTABLE (Version 2) to: cl-cleanup@sail.stanford.eduMessage-ID: <880923-023728-4008@Xerox>OK? !Issue:		FIXNUM-NON-PORTABLEReferences:	CLtL p. 14, 34, 43, 231Category:	CHANGE, CLARIFICATIONEdit History:   Version 1, 15-Sep-88, Masinter	(based on Issue BOGUS-FIXNUM)			Version 2, 23-Sep-88, MasinterProblem Description: Implementations of Common Lisp are required to support two disjointsubsets of integers, fixnums and bignums, with the promise thatfixnums have a more efficient representation.  However, nothing isguaranteed about the range of integers which are fixnums: "Exactlywhich integers are fixnums is implementation-dependent; typically theywill be those integers in the range -2**n to 2**n - 1, inclusive, forsome n not less than 15."There are few uses of the fixnum type that are portable, given thecurrent definition.  In particular, many programmers use FIXNUM typedeclarations where they really mean "small integer".While most Common Lisp implementations have a FIXNUM rangewhich is a subset of integers represeted and operated on mostefficiently, many also have several other subranges.  Thepartitioning of INTEGER into BIGNUM and FIXNUM is merelyconfusing in these implementations, and not useful.Proposal: FIXNUM-NONPORTABLE:TIGHTEN-DEFINITION(1) Change the description of the type FIXNUM to reflect that it is required to be a supertype of (SIGNED-BYTE 16).(2) remove the type BIGNUM from the language.Rationale:Many programmers already use FIXNUM to mean "small integer"; thisproposal makes this usage portable. However, there is little portable use for the type BIGNUM, and itis inconsistent with many current implementation techniques.Current Practice:Xerox Common Lisp has 17-bit fixnums.  Most other Common Lisp implementations have  fixnum ranges of 24 bits or larger. We knowof no implementation that currently violates the proposed minimum size.Several existing Common Lisp implementations have more than two representations for integers, such that the FIXNUM/BIGNUM distinctionis confusing.Cost to implementors:Slight.  All implementations we know of already define FIXNUMs to be atleast 16 bits and would only have to remove the BIGNUM type specifierto be in compliance with the proposal.Cost to users:Slight.  The removal of the BIGNUM type specifier will affect user codebut it appears to be little-used. Benefits:The FIXNUM type specifier would have a portable interpretation.The language would be less confusing.Discussion:Earlier discussion of a related proposal contained several other more controversialcomponents (adding a constant MAX-INTEGER-LENGTH, allowing MOST-POSITIVE-FIXNUM to be NIL as well as an integer.) This proposalis an attempt to address the part that cleanup committee seemed to agree on.It is possible that an implementation have a single  representation for allintegers, and no way to identify any efficient range of integers. Thoseimplementations might need to set MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUM to arbitrary values, consistent with the requirement that (SIGNED-BYTE 16) is a subtype of FIXNUM.Other alternatives considered (and not necessarly mutually exclusivewith this proposal):  remove the FIXNUM type specifier entirely, while leaving a way  to query what is the most efficient range of integers   leave the range of FIXNUMs unconstrained  and introduce a    SMALL-INTEGER type with a fixed range (but no promises about   efficiency) .   guarantee that the value of the constant ARRAY-TOTAL-SIZE-LIMIT be a  fixnum (for efficient array addressing)It might be possible to specify the required performance behaviorof FIXNUMs more concretely, e.g., specify that the basic integer operationsuse algorithms that are not proportional to the size of the data;  it should be just about as fast to add numbers in the middle of the fixnum range as it is to add, say, 10 and 11. This might be a useful way to describethe intent of the FIXNUM range, if not its specification.*start*04178 00024 USfDate:  6 Oct 88 21:08 PDTFrom: masinter.paSubject: Issue FIXNUM-NON-PORTABLE (Version 3) To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue: FIXNUM-NON-PORTABLEReferences:	CLtL p. 14, 34, 43, 231Category:	CHANGE, CLARIFICATIONEdit History:   Version 1, 11-Jul-88 (Sandra Loosemore)		    Version 2, 15-Sep-88, Masinter		    Version 3, 23-Sep-88, MasinterProblem Description: Implementations of Common Lisp are required to support two disjointsubsets of integers, fixnums and bignums, with the promise thatfixnums have a more efficient representation.  However, nothing isguaranteed about the range of integers which are fixnums: "Exactlywhich integers are fixnums is implementation-dependent; typically theywill be those integers in the range -2**n to 2**n - 1, inclusive, forsome n not less than 15."There are few uses of the fixnum type that are portable, given thecurrent definition.  In particular, many programmers use FIXNUM typedeclarations where they really mean "small integer".While most Common Lisp implementations have a FIXNUM rangewhich is a subset of integers represeted and operated on mostefficiently, many also have several other subranges.  Thepartitioning of INTEGER into BIGNUM and FIXNUM is merelyconfusing in these implementations, and not useful.Proposal: FIXNUM-NONPORTABLE:TIGHTEN-DEFINITION(1) Change the description of the type FIXNUM to reflect that it is required to be a supertype of (SIGNED-BYTE 16).(2) remove the type BIGNUM from the language.Rationale:Many programmers already use FIXNUM to mean "small integer"; thisproposal makes this usage portable. However, there is little portable use for the type BIGNUM, and itis inconsistent with many current implementation techniques.Current Practice:Xerox Common Lisp has 17-bit fixnums.  Most other Common Lisp implementations have  fixnum ranges of 24 bits or larger. We knowof no implementation that currently violates the proposed minimum size.Several existing Common Lisp implementations have more than two representations for integers, such that the FIXNUM/BIGNUM distinctionis confusing.Cost to implementors:Slight.  All implementations we know of already define FIXNUMs to be atleast 16 bits and would only have to remove the BIGNUM type specifierto be in compliance with the proposal.Cost to users:Slight.  The removal of the BIGNUM type specifier will affect user codebut it appears to be little-used. Benefits:The FIXNUM type specifier would have a portable interpretation.The language would be less confusing.Discussion:Earlier discussion of a related proposal contained several other more controversialcomponents (adding a constant MAX-INTEGER-LENGTH, allowing MOST-POSITIVE-FIXNUM to be NIL as well as an integer.) This proposalis an attempt to address the part that cleanup committee seemed to agree on.It is possible that an implementation have a single  representation for allintegers, and no way to identify any efficient range of integers. Thoseimplementations might need to set MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUM to arbitrary values, consistent with the requirement that (SIGNED-BYTE 16) is a subtype of FIXNUM.Other alternatives considered (and not necessarly mutually exclusivewith this proposal):  remove the FIXNUM type specifier entirely, while leaving a way  to query what is the most efficient range of integers   leave the range of FIXNUMs unconstrained  and introduce a    SMALL-INTEGER type with a fixed range (but no promises about   efficiency) .   guarantee that the value of the constant ARRAY-TOTAL-SIZE-LIMIT be a  fixnum (for efficient array addressing)It might be possible to specify the required performance behaviorof FIXNUMs more concretely, e.g., specify that the basic integer operationsuse algorithms that are not proportional to the size of the data;  it should be just about as fast to add numbers in the middle of the fixnum range as it is to add, say, 10 and 11. This might be a useful way to describethe intent of the FIXNUM range, if not its specification.*start*01023 00024 USaReturn-Path: <barmar@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 07 OCT 88 07:41:21 PDTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Fri, 7 Oct 88 10:42:59 EDTReceived: from OCCAM.THINK.COM by sauron.think.com; Fri, 7 Oct 88 10:39:56 EDTDate: Fri, 7 Oct 88 10:40 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue FIXNUM-NON-PORTABLE (Version 3) To: cl-cleanup@sail.stanford.eduCc: x3j13@sail.stanford.edu, Masinter.paIn-Reply-To: <881006-210851-2113@Xerox>Message-Id: <19881007144039.0.BARMAR@OCCAM.THINK.COM>    Date: 6 Oct 88 21:08 PDT    From: masinter.pa@xerox.com    Proposal: FIXNUM-NONPORTABLE:TIGHTEN-DEFINITION    (2) remove the type BIGNUM from the language.I don't really see the point of this.  Isn't BIGNUM simply defined to be(AND INTEGER (NOT FIXNUM))?  I admit that it isn't an extremely usefultype specifier, but it is just as portable as FIXNUM.                                                barmar*start*01117 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:58:23 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:58:30 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475869; Thu 13-Oct-88 16:57:10 EDTDate: Thu, 13 Oct 88 16:57 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FIXNUM-NON-PORTABLE (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013165702.1.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: GLS: p14 and p34 disagree about bignums. One says that fixnum and bignums      are an exhaustive partition of the integer space, the other says they      might not be! KMP: Moon is "neutral" on flushing bignums, but supports rest of proposal. Not ready for vote.X3J13 meeting: Barmar: Thinks change to bignums gratuitous. RWK: Let's just deprecate BIGNUM.*start*00925 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:11:45 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:57:22 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA19761; Thu, 13 Oct 88 14:55:47 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19864; Thu, 13 Oct 88 14:55:45 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132055.AA19864@defun.utah.edu>Date: Thu, 13 Oct 88 14:55:44 MDTSubject: issue FIXNUM-NON-PORTABLETo: cl-cleanup@sail.stanford.eduI would really prefer to retain the part of the proposal that removesthe BIGNUM type specifier, but if there is a decision made that BIGNUMshould stay in the language I think it should also be clarified that BIGNUM == (AND INTEGER (NOT FIXNUM)).-Sandra-------*start*01593 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 NOV 88 06:58:29 PSTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 1 Nov 88  06:57:06 PSTReceived:  by multimax.ARPA (5.51/25-eef)	id AA26377; Tue, 1 Nov 88 09:56:09 ESTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA29852; Tue, 1 Nov 88 10:00:04 ESTMessage-Id: <8811011500.AA29852@mist.UUCP>To: masinter.pa%Xerox.COM@MULTIMAX.ENCORE.COMCc: cl-cleanup%sail.stanford.edu@MULTIMAX.ENCORE.COMSubject: Re: Issue FIXNUM-NON-PORTABLE (Version 3) In-Reply-To: Your message of 31 Oct 88 14:55:00 -0800.             <881031-145600-6418@Xerox> Date: Tue, 01 Nov 88 09:59:55 ESTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>    I'm willing to split the issue into two parts, one of which says: constrain    FIXNUM and remove BIGNUM, and the other is to constrain FIXNUM and define    BIGNUM to be exactly (AND INTEGER (NOT FIXNUM)).    In the SUBTYPEP-TOO-VAGUE issue, we should probably make sure the    requirements for FIXNUM and BIGNUM are there.    Here's why I don't like the second proposal:Consider an implmentation with three numeric representations:Fast                (INTEGER -1024 1023)Immediate           29 bitsExtended            Multi-precision(I understand from the discussion that similar implementations exist.)Then, with the second proposal:FIXNUM is ImmediateBIGNUM is (OR Fast Extended) because Fast can't be a FIXNUM.*start*00888 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 NOV 88 10:07:43 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 1 Nov 88  10:05:41 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 01 NOV 88 10:01:13 PSTDate: 1 Nov 88 09:59 PSTFrom: masinter.paSubject: Re: Issue FIXNUM-NON-PORTABLE (Version 3) In-reply-to: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>'s message of Tue, 01 Nov 88 09:59:55 ESTTo: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>cc: cl-cleanup@sail.stanford.eduMessage-ID: <881101-100113-8002@Xerox>No, this can't be true. In such an implementation, Fast                (INTEGER -1024 1023)Immediate           29 bitsExtended            Multi-precisionFIXNUM is (OR Fast Immediate)andBIGNUM is Extended*start*01390 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 31 OCT 88 18:47:07 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 31 Oct 88  18:44:10 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 31 OCT 88 14:56:00 PSTDate: 31 Oct 88 14:55 PSTFrom: masinter.paSubject: Re: Issue FIXNUM-NON-PORTABLE (Version 3) In-reply-to: Barry Margolin <barmar@Think.COM>'s message of Fri, 7 Oct 88 10:40 EDTTo: Barry Margolin <barmar@Think.COM>cc: cl-cleanup@sail.stanford.eduMessage-ID: <881031-145600-6418@Xerox>The major reason for considering the removal of BIGNUM from the languagewas that it didn't correspond to current practice in severalimplementations; although all implementations had a single type which couldfit into the current and proposed definition of FIXNUM, many did not have asingle type that fit into BIGNUM. This is at least what led us to consider removing BIGNUM. We could not find programs that used the name BIGNUM.I'm willing to split the issue into two parts, one of which says: constrainFIXNUM and remove BIGNUM, and the other is to constrain FIXNUM and defineBIGNUM to be exactly (AND INTEGER (NOT FIXNUM)).In the SUBTYPEP-TOO-VAGUE issue, we should probably make sure therequirements for FIXNUM and BIGNUM are there.*start*05949 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 21:32:09 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Dec 88  21:22:57 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 07 DEC 88 21:08:50 PSTDate: 7 Dec 88 21:08 PSTFrom: masinter.paSubject: Issue FIXNUM-NON-PORTABLE (Version 4) To: cl-cleanup@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881207-210850-2688@Xerox>I must have been fooling myself, or forgotten how many unresolvedissues I had glossed over early in October. In any case, I'm discoveringmore than I expected in need of new versions. Please bear with me.Lest we go without resolving this, I made it have two proposals,which differed only by whether BIGNUM went away.!Issue: FIXNUM-NON-PORTABLEReferences:	CLtL p. 14, 34, 43, 231Category:	CHANGE, CLARIFICATIONEdit History:   Version 1, 11-Jul-88, Sandra Loosemore		    Version 2, 15-Sep-88, Masinter		    Version 3, 23-Sep-88, Masinter		    Version 4,  7-Dec-88, Masinter (two proposals)Problem Description: Implementations of Common Lisp are required to support two disjointsubsets of integers, fixnums and bignums, with the promise thatfixnums have a more efficient representation.  However, nothing isguaranteed about the range of integers which are fixnums: "Exactlywhich integers are fixnums is implementation-dependent; typically theywill be those integers in the range -2**n to 2**n - 1, inclusive, forsome n not less than 15."There are few uses of the fixnum type that are portable, given thecurrent definition.  In particular, many programmers use FIXNUM typedeclarations where they really mean "small integer".While most Common Lisp implementations have a FIXNUM rangewhich is a subset of integers represeted and operated on mostefficiently, many also have several other subranges.  Thepartitioning of INTEGER into BIGNUM and FIXNUM is merelyconfusing in these implementations, and not useful.CLtL p14 and p34 disagree about BIGNUM. One says that FIXNUM and BIGNUM are an exhaustive partition of theinteger space, the other says they might not be!Proposal: FIXNUM-NONPORTABLE:TIGHTEN-DEFINITION(1) Change the description of the type FIXNUM to reflect that it is required to be a supertype of (SIGNED-BYTE 16).(2) Define BIGNUM to be exactly (AND INTEGER (NOT FIXNUM))Proposal: FIXNUM-NONPORTABLE:TIGHTEN-FIXNUM-TOSS-BIGNUM(1) Change the description of the type FIXNUM to reflect that it is required to be a supertype of (SIGNED-BYTE 16).(2) remove the type BIGNUM from the language.Example:Consider an implementation with three numeric representations:	Fast                (INTEGER -1024 1023)	Immediate           29 bits	Extended            Multi-precisionSuch an implementation would have to defineFIXNUM to be (OR Fast Immediate). BIGNUM, if itremains, would then refer to multi-precision integers. Rationale:Many programmers already use FIXNUM to mean "small integer"; thisproposal makes this usage portable. However, there is little portable use for the type BIGNUM, and itis inconsistent with many current implementation techniques.Removing it is an incompatible change for a weak reason; thustwo proposals.Current Practice:Xerox Common Lisp has 17-bit fixnums.  Most other Common Lisp implementations have  fixnum ranges of 24 bits or larger. We knowof no implementation that currently violates the proposed minimum size.Several existing Common Lisp implementations have more than two representations for integers, such that the FIXNUM/BIGNUM distinctionis confusing; they define BIGNUM to cover all of the larger numbertypes.Cost to implementors:Slight.  All implementations we know of already define FIXNUMs to be atleast 16 bits; TOSS-BIGNUM would have to remove the BIGNUM typespecifier to be in compliance with the proposal.Cost to users:Slight.  The removal of the BIGNUM type specifier will affect user codebut it appears to be little-used. Benefits:The FIXNUM type specifier would have a portable interpretation.The language would be less confusing.Discussion:There was little consensus on whether to leave BIGNUM in the language.We don't currently have a way to "deprecate" features, so we are notproposing it here.Earlier discussion of a related proposal contained several other more controversialcomponents (adding a constant MAX-INTEGER-LENGTH, allowing MOST-POSITIVE-FIXNUM to be NIL as well as an integer.) This proposalis an attempt to address the part that cleanup committee seemed to agree on.It is possible that an implementation have a single  representation for allintegers, and no way to identify any efficient range of integers. Thoseimplementations might need to set MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUM to arbitrary values, consistent with the requirement that (SIGNED-BYTE 16) is a subtype of FIXNUM.Other alternatives considered (and not necessarily mutually exclusivewith this proposal):  remove the FIXNUM type specifier entirely, while leaving a way  to query what is the most efficient range of integers   leave the range of FIXNUMs unconstrained  and introduce a    SMALL-INTEGER type with a fixed range (but no promises about   efficiency) .   guarantee that the value of the constant ARRAY-TOTAL-SIZE-LIMIT be a  fixnum (for efficient array addressing)It might be possible to specify the required performance behaviorof FIXNUMs more concretely, e.g., specify that the basic integer operationsuse algorithms that are not proportional to the size of the data;  it should be just about as fast to add numbers in the middle of the fixnum range as it is to add, say, 10 and 11. This might be a useful way to describethe intent of the FIXNUM range, if not its specification.*start*05663 00024 USfReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 11:23:24 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  11:10:57 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 12 DEC 88 11:02:59 PSTDate: 12 Dec 88 10:49 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: FIXNUM-NON-PORTABLE (Version 4)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-110259-4502@Xerox>!Issue: FIXNUM-NON-PORTABLEReferences:	CLtL p. 14, 34, 43, 231Category:	CHANGE, CLARIFICATIONEdit History:   Version 1, 11-Jul-88, Sandra Loosemore		    Version 2, 15-Sep-88, Masinter		    Version 3, 23-Sep-88, Masinter		    Version 4,  7-Dec-88, Masinter (two proposals)Problem Description: Implementations of Common Lisp are required to support two disjointsubsets of integers, fixnums and bignums, with the promise thatfixnums have a more efficient representation.  However, nothing isguaranteed about the range of integers which are fixnums: "Exactlywhich integers are fixnums is implementation-dependent; typically theywill be those integers in the range -2**n to 2**n - 1, inclusive, forsome n not less than 15."There are few uses of the fixnum type that are portable, given thecurrent definition.  In particular, many programmers use FIXNUM typedeclarations where they really mean "small integer".While most Common Lisp implementations have a FIXNUM rangewhich is a subset of integers represeted and operated on mostefficiently, many also have several other subranges.  Thepartitioning of INTEGER into BIGNUM and FIXNUM is merelyconfusing in these implementations, and not useful.CLtL p14 and p34 disagree about BIGNUM. One says that FIXNUM and BIGNUM are an exhaustive partition of theinteger space, the other says they might not be!Proposal: FIXNUM-NONPORTABLE:TIGHTEN-DEFINITION(1) Change the description of the type FIXNUM to reflect that it is required to be a supertype of (SIGNED-BYTE 16).(2) Define BIGNUM to be exactly (AND INTEGER (NOT FIXNUM))Proposal: FIXNUM-NONPORTABLE:TIGHTEN-FIXNUM-TOSS-BIGNUM(1) Change the description of the type FIXNUM to reflect that it is required to be a supertype of (SIGNED-BYTE 16).(2) remove the type BIGNUM from the language.Example:Consider an implementation with three numeric representations:	Fast                (INTEGER -1024 1023)	Immediate           29 bits	Extended            Multi-precisionSuch an implementation would have to defineFIXNUM to be (OR Fast Immediate). BIGNUM, if itremains, would then refer to multi-precision integers. Rationale:Many programmers already use FIXNUM to mean "small integer"; thisproposal makes this usage portable. However, there is little portable use for the type BIGNUM, and itis inconsistent with many current implementation techniques.Removing it is an incompatible change for a weak reason; thustwo proposals.Current Practice:Xerox Common Lisp has 17-bit fixnums.  Most other Common Lisp implementations have  fixnum ranges of 24 bits or larger. We knowof no implementation that currently violates the proposed minimum size.Several existing Common Lisp implementations have more than two representations for integers, such that the FIXNUM/BIGNUM distinctionis confusing; they define BIGNUM to cover all of the larger numbertypes.Cost to implementors:Slight.  All implementations we know of already define FIXNUMs to be atleast 16 bits; TOSS-BIGNUM would have to remove the BIGNUM typespecifier to be in compliance with the proposal.Cost to users:Slight.  The removal of the BIGNUM type specifier will affect user codebut it appears to be little-used. Benefits:The FIXNUM type specifier would have a portable interpretation.The language would be less confusing.Discussion:There was little consensus on whether to leave BIGNUM in the language.We don't currently have a way to "deprecate" features, so we are notproposing it here.Earlier discussion of a related proposal contained several other more controversialcomponents (adding a constant MAX-INTEGER-LENGTH, allowing MOST-POSITIVE-FIXNUM to be NIL as well as an integer.) This proposalis an attempt to address the part that cleanup committee seemed to agree on.It is possible that an implementation have a single  representation for allintegers, and no way to identify any efficient range of integers. Thoseimplementations might need to set MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUM to arbitrary values, consistent with the requirement that (SIGNED-BYTE 16) is a subtype of FIXNUM.Other alternatives considered (and not necessarily mutually exclusivewith this proposal):  remove the FIXNUM type specifier entirely, while leaving a way  to query what is the most efficient range of integers   leave the range of FIXNUMs unconstrained  and introduce a    SMALL-INTEGER type with a fixed range (but no promises about   efficiency) .   guarantee that the value of the constant ARRAY-TOTAL-SIZE-LIMIT be a  fixnum (for efficient array addressing)It might be possible to specify the required performance behaviorof FIXNUMs more concretely, e.g., specify that the basic integer operationsuse algorithms that are not proportional to the size of the data;  it should be just about as fast to add numbers in the middle of the fixnum range as it is to add, say, 10 and 11. This might be a useful way to describethe intent of the FIXNUM range, if not its specification.     ----- End Forwarded Messages -----*start*01696 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 JAN 89 03:02:42 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 1 Jan 89  03:02:30 PSTDate: Sat, 31 Dec 88 19:47:14 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue FIXNUM-NON-PORTABLE, v4To: cl-cleanup@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUMessage-ID: <12458959255.23.IIM@ECLA.USC.EDU>Basically, I don't think either proposal really addresses the problemadequately.  I'm looking at this from the point of view of someone who hasdealt with porting C programs between machines with different native wordsizes, and therefor different definitions of the 'int' type.  I see many of thesame kinds of problems here, and the approach being taken by these proposalsreally doesn't do anything about them.Actually, I think a case could be made in favor of a third proposal,TOSS-FIXNUM-TOSS-BIGNUM, making it explicit that neither is portable.  I'm notplanning to put this forward as a serious proposal though, since I expect itwould go over like a lead balloon for historical reasons if nothing else.There are relatively few legitimate uses of FIXNUM in portable code, andlegislating the definition of FIXNUM in a fairly ad hoc way is not going toimprove the situation.  About the only place the FIXNUM type specifier shouldappear in portable code is as part of the definition of a type used by theportable code, with the definition parameterized according to theimplementation being ported to.  Even there it is probably better to use rangedinteger type specifiers.kab-------*start*01215 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 JAN 89 03:11:48 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 4 Jan 89  03:11:07 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa03629; 4 Jan 89 10:47 GMTDate: Tue, 3 Jan 89 17:26:31 GMTMessage-Id: <29459.8901031726@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue FIXNUM-NON-PORTABLE, v4To: "Kim A. Barrett" <IIM@ecla.usc.edu>, cl-cleanup@sail.stanford.eduIn-Reply-To: Kim A. Barrett's message of Sat 31 Dec 88 19:47:14-PSTCc: iim@ecla.usc.edu> There are relatively few legitimate uses of FIXNUM in portable code,While I sometimes use such arguments myself, I do not think it istrue in general that only portable code matters.  I want fixnumsbecause they let me do something is the same way in all implementationsthat do it.  Also, in most implementations fixnums are big enough tocontain the address part of a pointer to a data object.  Therefore,they are always big enough to count objects.*start*01238 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 JAN 89 06:25:03 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 4 Jan 89  06:23:11 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA01227; Wed, 4 Jan 89 09:21:59 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA13950; Wed, 4 Jan 89 09:22:00 ESTMessage-Id: <8901041422.AA13950@mist.>To: Jeff Dalton <"jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK"@multimax.encore.com>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue FIXNUM-NON-PORTABLE, v4 In-Reply-To: Your message of Tue, 03 Jan 89 17:26:31 +0000.             <29459.8901031726@subnode.aiai.ed.ac.uk> Date: Wed, 04 Jan 89 09:21:57 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>                 Also, in most implementations fixnums are big enough to    contain the address part of a pointer to a data object.  Therefore,    they are always big enough to count objects.    Note that this proposal does not guarantee that fixnums will be largeenough for your purposes; all Common Lisp systems will need more than16 address bits...*start*01518 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 JAN 89 16:20:12 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 4 Jan 89  11:37:25 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06991; 4 Jan 89 19:11 GMTDate: Wed, 4 Jan 89 19:16:04 GMTMessage-Id: <1732.8901041916@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue FIXNUM-NON-PORTABLE, v4 To: Jeff Dalton <"jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK"@multimax.encore.com>, pierson <@multimax.encore.com:pierson@mist.encore.com>Cc: cl-cleanup@sail.stanford.edu>                  Also, in most implementations fixnums are big enough to>     contain the address part of a pointer to a data object.  Therefore,>     they are always big enough to count objects.>     > Note that this proposal does not guarantee that fixnums will be large> enough for your purposes; all Common Lisp systems will need more than> 16 address bits...That's one of the problems with saying 16 bits: it might increase thelikelihood that implementations will do something that losing.  It wouldbe nice if there were some way to test whether fixmuns were big enough(if we can't actually guarantee it), but it's worth noting that rightnow fixnums work better for this purpose that any particular number ofbits I might pick.*start*01794 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JAN 89 23:35:45 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Jan 89  23:34:11 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 JAN 89 23:33:01 PSTDate: 8 Jan 89 23:31 PSTFrom: masinter.paSubject: Re: Issue FIXNUM-NON-PORTABLE, v4In-reply-to: Kim A. Barrett <IIM@ECLA.USC.EDU>'s message of Sat, 31 Dec 88 19:47:14 PSTTo: Kim A. Barrett <IIM@ECLA.USC.EDU>cc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <890108-233301-3546@Xerox>The portable use of FIXNUMs that convinced me came from applications thatwanted to use, say, a list of fixnums instead of a bit vector or a bignumas an efficient representation of an arbitrary length sequence of bits.For such an application, the FIXNUM type is ideal: it is the largest"efficient" set of integers, and any explicit ranged integer type specifierwould not have the right properties. I thought it was a legitimate portable use of the FIXNUM tpe. It is reallyonly a portable use of FIXNUM if FIXNUM is constrained to be a "reasonable"size, however; e.g., it doesn't work if MOST-POSITIVE-FIXNUM is negative!Constraining FIXNUM to be a reasonable size also makes other uses of FIXNUMmore legitimate. Perhaps we could make FIXNUM more useful if we requiredMOST-POSITIVE-FIXNUM to be at least as big as ARRAY-DIMENSION-LIMIT orCHAR-CODE-LIMIT or could be guaranteed to hold the largest "count" ofobjects, e.g., that LENGTH always returns a FIXNUM. An alternative would beto invent new types, e.g., (deftype array-dimension () `(integer 0 ,array-dimension-limit))What should the name of "an integer big enough to count objects" be?*start*05683 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 16-Mar-89 22:11:33 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 22:11:34 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  22:11:59 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 16 MAR 89 22:09:33 PSTDate: 16 Mar 89 21:51 PSTFrom: masinter.pato: cl-cleanup@sail.stanford.eduSubject: Issue: FIXNUM-NON-PORTABLE, v.5line-fold: NOMessage-ID: <890316-220933-6804@Xerox>This is my rewrite to capture the 'intent' of the amendmentat the January X3J13. I say 'intent' because the relationbetween MOST-POSITIVE-FIXNUM (which is an inclusive bound)and ARRAY-DIMENSION-LIMIT (which is an exclusive bound) is not> but rather (>= MOST-POSITIVE-FIXNUM (1- ARRAY-DIMENSION-LIMIT)).A minor nit. I wonder if we need to bring copies of the issuesthat were passed at the last meeting for the 'approval ofthe minutes' part.!Status: Passed Jan 89 X3J13, as amendedIssue: FIXNUM-NON-PORTABLEReferences:	CLtL p. 14, 34, 43, 231Category:	CHANGE, CLARIFICATIONEdit History:   Version 1, 11-Jul-88, Sandra Loosemore		    Version 2, 15-Sep-88, Masinter		    Version 3, 23-Sep-88, Masinter		    Version 4,  7-Dec-88, Masinter (two proposals)		    Version 5, 16-Mar-89, Masinter (incorporate amendments)Problem Description: Implementations of Common Lisp are required to support two disjointsubsets of integers, fixnums and bignums, with the promise thatfixnums have a more efficient representation.  However, nothing isguaranteed about the range of integers which are fixnums: "Exactlywhich integers are fixnums is implementation-dependent; typically theywill be those integers in the range -2**n to 2**n - 1, inclusive, forsome n not less than 15."There are few uses of the fixnum type that are portable, given thecurrent definition.  In particular, many programmers use FIXNUM typedeclarations where they really mean "small integer".While most Common Lisp implementations have a FIXNUM rangewhich is a subset of integers represeted and operated on mostefficiently, many also have several other subranges.  Thepartitioning of INTEGER into BIGNUM and FIXNUM is merelyconfusing in these implementations, and not useful.CLtL p14 and p34 disagree about BIGNUM. One says that FIXNUM and BIGNUM are an exhaustive partition of theinteger space, the other says they might not be!Proposal: FIXNUM-NONPORTABLE:TIGHTEN-DEFINITION(1) Change the description of the type FIXNUM to reflect that it is required to be a supertype of (SIGNED-BYTE 16).(2) Define BIGNUM to be exactly (AND INTEGER (NOT FIXNUM))(3) require that MOST-POSITIVE-FIXNUM be large enough  to hold all array indices, i.e.,	(>= MOST-POSITIVE-FIXNUM (1- ARRAY-DIMENSION-LIMIT))Example:Consider an implementation with three numeric representations:	Fast                (INTEGER -1024 1023)	Immediate           29 bits	Extended            Multi-precisionSuch an implementation would have to defineFIXNUM to be (OR Fast Immediate). BIGNUMwould then refer to multi-precision integers. Rationale:Many programmers already use FIXNUM to mean "small integer"; thisproposal makes this usage portable. However, there is little portable use for the type BIGNUM, and itis inconsistent with many current implementation techniques.Removing it is an incompatible change for a weak reason.Current Practice:Xerox Common Lisp has 17-bit fixnums.  Most other Common Lisp implementations have  fixnum ranges of 24 bits or larger. We knowof no implementation that currently violates the proposed minimum size.Several existing Common Lisp implementations have more than two representations for integers, such that the FIXNUM/BIGNUM distinctionis confusing; they define BIGNUM to cover all of the larger numbertypes.Cost to implementors:Slight.  All implementations we know of already define FIXNUMs to be atleast 16 bits.Cost to users:Slight.  Benefits:The FIXNUM type specifier would have a portable interpretation.The language would be less confusing.Discussion:There was little consensus on whether to leave BIGNUM in the language.Earlier discussion of a related proposal contained several other more controversialcomponents (adding a constant MAX-INTEGER-LENGTH, allowing MOST-POSITIVE-FIXNUM to be NIL as well as an integer.) This proposalis an attempt to address the part that cleanup committee seemed to agree on.It is possible that an implementation have a single  representation for allintegers, and no way to identify any efficient range of integers. Thoseimplementations might need to set MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUM to arbitrary values, consistent with the requirement that (SIGNED-BYTE 16) is a subtype of FIXNUM.Other alternatives considered (and not necessarily mutually exclusivewith this proposal):  remove the FIXNUM type specifier entirely, while leaving a way  to query what is the most efficient range of integers   leave the range of FIXNUMs unconstrained  and introduce a    SMALL-INTEGER type with a fixed range (but no promises about   efficiency) . It might be possible to specify the required performance behaviorof FIXNUMs more concretely, e.g., specify that the basic integer operationsuse algorithms that are not proportional to the size of the data;  it should be just about as fast to add numbers in the middle of the fixnum range as it is to add, say, 10 and 11. This might be a useful way to describethe intent of the FIXNUM range, if not its specification.*start*01519 00024 USaGV-Info: Moon@STONY-BROOK.SCRC.Symbolics.COM at 17-Mar-89 16:54:59 from AGReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 17 MAR 89 16:54:41 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 560137; Fri 17-Mar-89 19:54:04 ESTDate: Fri, 17 Mar 89 19:53 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FIXNUM-NON-PORTABLE, v.5To: masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <890316-220933-6804@Xerox>Message-ID: <19890318005344.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 16 Mar 89 21:51 PST    From: masinter.pa@Xerox.COM    This is my rewrite to capture the 'intent' of the amendment    at the January X3J13. I say 'intent' because the relation    between MOST-POSITIVE-FIXNUM (which is an inclusive bound)    and ARRAY-DIMENSION-LIMIT (which is an exclusive bound) is not    > but rather (>= MOST-POSITIVE-FIXNUM (1- ARRAY-DIMENSION-LIMIT)).No, the amendment was (<= ARRAY-DIMENSION-LIMIT MOST-POSITIVE-FIXNUM),and this was not a mistake nor an off-by-one error.  What you'veput in the proposal here is incorrect, I think.  I think it wasfully intended that not only every valid array index and everyarray dimension, but also array-dimension-limit itself would bea fixnum.  Someone might want to write an arithmetic iterationwhose upper bound was array-dimension-limit.*start*00793 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 18:39:19 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 18:39:03 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  18:39:40 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 17 MAR 89 18:09:23 PSTDate: 17 Mar 89 18:02 PSTFrom: masinter.paSubject: Re: Issue: FIXNUM-NON-PORTABLE, v.5In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 17 Mar 89 19:53 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: masinter.pa, cl-cleanup@sail.stanford.eduMessage-ID: <890317-180923-2962@Xerox>OK, I'll fix it. Thanks.Larry*start*02033 00024 USaGV-Info: gls@Think.COM at 20-Mar-89 16:09:25 from AGReturn-Path: <gls@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 20 MAR 89 16:08:06 PSTReceived: from fafnir.think.com by Think.COM; Mon, 20 Mar 89 11:47:53 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Mon, 20 Mar 89 11:48:52 ESTReceived: by verdi.think.com; Mon, 20 Mar 89 11:45:31 ESTDate: Mon, 20 Mar 89 11:45:31 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903201645.AA17143@verdi.think.com>To: Moon@stony-brook.scrc.symbolics.comCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 17 Mar 89 19:53 EST <19890318005344.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: FIXNUM-NON-PORTABLE, v.5   Date: Fri, 17 Mar 89 19:53 EST   From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>       Date: 16 Mar 89 21:51 PST       From: masinter.pa@Xerox.COM       This is my rewrite to capture the 'intent' of the amendment       at the January X3J13. I say 'intent' because the relation       between MOST-POSITIVE-FIXNUM (which is an inclusive bound)       and ARRAY-DIMENSION-LIMIT (which is an exclusive bound) is not       > but rather (>= MOST-POSITIVE-FIXNUM (1- ARRAY-DIMENSION-LIMIT)).   No, the amendment was (<= ARRAY-DIMENSION-LIMIT MOST-POSITIVE-FIXNUM),   and this was not a mistake nor an off-by-one error.  What you've   put in the proposal here is incorrect, I think.  I think it was   fully intended that not only every valid array index and every   array dimension, but also array-dimension-limit itself would be   a fixnum.  Someone might want to write an arithmetic iteration   whose upper bound was array-dimension-limit.I agree with Moon's observations and assessment; this was my understandingof the amendment.Pascal-type languages have had no end of grief because iteration counterstake on "invalid" (read "non-fixnum" here and you'll get the idea) valuesat the end of the last iteration.--Guy*start*05440 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-Mar-89 15:43:07 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 15:43:01 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Mar 89  15:32:54 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 23 MAR 89 13:14:25 PSTDate: 23 Mar 89 13:13 PSTFrom: masinter.paSubject: Re: Issue: FIXNUM-NON-PORTABLE, v.5In-reply-to: Guy Steele <gls@Think.COM>'s message of Mon, 20 Mar 89 11:45:31 ESTTo: Guy Steele <gls@Think.COM>cc: Moon@stony-brook.scrc.symbolics.com, masinter.pa, cl-cleanup@sail.stanford.eduMessage-ID: <890323-131425-5460@Xerox>Sorry, yes, I blew it. This is what I've saved as "passed":Status: Passed Jan 89 X3J13, as amendedIssue: FIXNUM-NON-PORTABLEReferences:	CLtL p. 14, 34, 43, 231Category:	CHANGE, CLARIFICATIONEdit History:   Version 1, 11-Jul-88, Sandra Loosemore		    Version 2, 15-Sep-88, Masinter		    Version 3, 23-Sep-88, Masinter		    Version 4,  7-Dec-88, Masinter (two proposals)		    Version 5, 16-Mar-89, Masinter (incorporate amendments)		    Version 6, 17-Mar-89, Masinter (incorporate amendments correctly)Problem Description: Implementations of Common Lisp are required to support two disjointsubsets of integers, fixnums and bignums, with the promise thatfixnums have a more efficient representation.  However, nothing isguaranteed about the range of integers which are fixnums: "Exactlywhich integers are fixnums is implementation-dependent; typically theywill be those integers in the range -2**n to 2**n - 1, inclusive, forsome n not less than 15."There are few uses of the fixnum type that are portable, given thecurrent definition.  In particular, many programmers use FIXNUM typedeclarations where they really mean "small integer".While most Common Lisp implementations have a FIXNUM rangewhich is a subset of integers represeted and operated on mostefficiently, many also have several other subranges.  Thepartitioning of INTEGER into BIGNUM and FIXNUM is merelyconfusing in these implementations, and not useful.CLtL p14 and p34 disagree about BIGNUM. One says that FIXNUM and BIGNUM are an exhaustive partition of theinteger space, the other says they might not be!Proposal: FIXNUM-NONPORTABLE:TIGHTEN-DEFINITION(1) Change the description of the type FIXNUM to reflect that it is required to be a supertype of (SIGNED-BYTE 16).(2) Define BIGNUM to be exactly (AND INTEGER (NOT FIXNUM))(3) require that (<= ARRAY-DIMENSION-LIMIT MOST-POSITIVE-FIXNUM)Example:Consider an implementation with three numeric representations:	Fast                (INTEGER -1024 1023)	Immediate           29 bits	Extended            Multi-precisionSuch an implementation would have to defineFIXNUM to be (OR Fast Immediate). BIGNUMwould then refer to multi-precision integers. Rationale:Many programmers already use FIXNUM to mean "small integer"; thisproposal makes this usage portable. However, there is little portable use for the type BIGNUM, and itis inconsistent with many current implementation techniques.Removing it is an incompatible change for a weak reason.Current Practice:Xerox Common Lisp has 17-bit fixnums.  Most other Common Lisp implementations have  fixnum ranges of 24 bits or larger. We knowof no implementation that currently violates the proposed minimum size.Several existing Common Lisp implementations have more than two representations for integers, such that the FIXNUM/BIGNUM distinctionis confusing; they define BIGNUM to cover all of the larger numbertypes.Cost to implementors:Slight.  All implementations we know of already define FIXNUMs to be atleast 16 bits.Cost to users:Slight.  Benefits:The FIXNUM type specifier would have a portable interpretation.The language would be less confusing.Discussion:There was little consensus on whether to leave BIGNUM in the language.Earlier discussion of a related proposal contained several other morecontroversial components (adding a constant MAX-INTEGER-LENGTH, allowing MOST-POSITIVE-FIXNUM to be NIL as well as an integer.) This proposalis an attempt to address the part that cleanup committee seemed to agreeon.It is possible that an implementation have a single  representation for allintegers, and no way to identify any efficient range of integers. Thoseimplementations might need to set MOST-POSITIVE-FIXNUM and MOST-NEGATIVE-FIXNUM to arbitrary values, consistent with the requirement that (SIGNED-BYTE 16) is a subtype of FIXNUM.Other alternatives considered (and not necessarily mutually exclusivewith this proposal):  remove the FIXNUM type specifier entirely, while leaving a way  to query what is the most efficient range of integers   leave the range of FIXNUMs unconstrained  and introduce a    SMALL-INTEGER type with a fixed range (but no promises about   efficiency) . It might be possible to specify the required performance behaviorof FIXNUMs more concretely, e.g., specify that the basic integer operationsuse algorithms that are not proportional to the size of the data;  it should be just about as fast to add numbers in the middle of the fixnum range as it is to add, say, 10 and 11. This might be a useful way todescribethe intent of the FIXNUM range, if not its specification.