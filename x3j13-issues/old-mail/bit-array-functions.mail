*start*11332 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-May-89 11:53:14 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAY 89 11:51:26 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 23 May 89  11:48:21 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 599444; 23 May 89 14:38:13 EDTDate: Tue, 23 May 89 14:42 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: BIT-ARRAY-FUNCTIONS (version 5)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19890523184240.1.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This is a new issue.  It arose from an investigation of featuresthat are plausibly needed but missing from draft ANSI Common Lisp.This issue seems sufficiently simple and noncontroversial thatI would like to see it on the agenda for the June X3J13 meeting.Let's use the cleanup subcommittee to test the assertion that thisis a simple and noncontroversial issue.  If it's controversial,let's just drop it, otherwise let's give X3J13 a chance to votefor or against it.Issue:         BIT-ARRAY-FUNCTIONSReferences:    The binary bit-array functions BIT-AND, BIT-IOR, BIT-XOR,               BIT-EQV, BIT-NAND, BIT-NOR, BIT-ANDC1, BIT-ANDC2, BIT-ORC1,               and BIT-ORC2 (CLtL p.294).               The unary bit-array function BIT-NOT (CLtL p.295).               The mapping functions EVERY, MAP, NOTANY, NOTEVERY, and SOME               (CLtL pp.249-250).               The functions COUNT and POSITION (CLtL p.257).Related issues: noneCategory:      ADDITIONEdit history:  Version 1,  9-May-89, by Moon               Version 2, 10-May-89, by Moon (add second proposal)               Version 3, 12-May-89, by Moon (small wording improvements)               Version 4, 13-May-89, by Moon (make more understandable)               Version 5, 23-May-89, by Moon (fix -p naming convention)Problem description:  Logical operations on bit vectors have been found to be useful in such  programs as compiler flow analysis.  They are easy to implement in  straight Common Lisp, but such an implementation is many times slower  than an optimized implementation on most machines.  This is partly  because many machines have instructions to perform these operations or  inner kernels of them, and partly because Common Lisp is not a good  language for implementing this type of low-level bit-oriented operation.  Common Lisp provides some logical operations on bit arrays, but the  provided set is incomplete.  Furthermore, the operations that are  provided are only defined for arrays of identical dimensions, making them  less useful for bit vectors that represent sets, where trailing zero  elements are often omitted.  Some of the sequence functions are useful  for bit vectors, but users (correctly) fear that their implementation may  be optimized for general sequences, not for bit vectors.  This issue contains two alternative proposals.Proposal (BIT-ARRAY-FUNCTIONS:ADD):  Allow the binary bit-array functions referenced above to accept arguments  of identical rank but unequal dimensions.  Nonexistent elements of  bit-array-1 or bit-array-2 are assumed to be zero.  If the third argument  is T or a bit-array, result elements outside the bounds of the array must  be zero or an error should be signalled.  If the third argument is NIL or  omitted, each dimension of the result array is equal to either the  corresponding dimension of bit-array-1 or the corresponding dimension of  bit-array-2.  The larger of the two dimensions is used when necessary to  hold all the nonzero elements of the result, otherwise either the larger  or the smaller of the two dimensions is used.  Allow BIT-NOT with a bit array as the second argument to accept arguments  of identical rank but unequal dimensions.  Result elements outside the  bounds of the array must be zero or an error should be signalled.  Add the following functions:    BIT-SUBSETP bit-array-1 bit-array-2    Returns true if for every element of bit-array-1 that is 1, the    element with the same subscripts exists in bit-array-2 and is 1.      Bit-array-1 and bit-array-2 must have identical rank but need not    have identical dimensions.    BIT-DISJOINTP bit-array-1 bit-array-2    Returns true if for every element of one bit-array that is 1, the    element with the same subscripts either does not exist in the other    bit-array or is 0.  Bit-array-1 and bit-array-2 must have identical    rank but need not have identical dimensions.    BIT-EQUALP bit-array-1 bit-array-2    Returns true if for every element of one bit-array that is 1, the    element with the same subscripts exists in the other bit-array and    is 1.  Bit-array-1 and bit-array-2 must have identical rank but need    not have identical dimensions.  Suggest in the language specification document that compilers should  optimize the following functions when the sequence argument is declared  to be a bit-vector, taking advantage of any relevant special machine  instructions.    COUNT    POSITION  Suggest in the language specification document that compilers should  optimize the following functions when there are two arguments, the second  argument is declared to be a bit-vector, and the predicate argument is  #'ZEROP, taking advantage of any relevant special machine instructions.    EVERY    NOTANY    NOTEVERY    SOMEProposal (BIT-ARRAY-FUNCTIONS:NO-NEW-FUNCTIONS):  Same as BIT-ARRAY-FUNCTIONS:ADD but do not add the three new functions.  Instead, generalize the mapping functions referenced above (EVERY, MAP,  NOTANY, NOTEVERY, and SOME) so that they operate on "mappables" rather  than just sequences.  Define a mappable to be an array or a list.  Specify that the mappable arguments to a mapping function, and the result  in the case of MAP with a non-NIL first argument, must all be of the same  rank (the rank of a list is considered to be 1).  Mapping accesses array  elements in row-major order.  Generalize the existing specification that  a mapping function uses the length of the shortest sequence, to say that  a mapping function uses on each axis the minimum of the dimensions on  that axis of the mappable arguments.  Suggest in the language specification document that compilers should  optimize the functions EVERY, NOTANY, NOTEVERY, and SOME when there are  two arguments, the second argument is declared to be a bit-array, and the  predicate argument is #'ZEROP, taking advantage of any relevant special  machine instructions.  In addition compilers should optimize when the  second argument is a call with two arguments to one of the binary  bit-array functions referenced above, to avoid consing an intermediate  result.Examples:  The equivalents of UNION and INTERSECTION for sets represented  as bit vectors, with 1's in positions where set elements are  present, are BIT-IOR and BIT-AND respectively.  (COUNT 1 (THE BIT-VECTOR BV)) computes the cardinality of a bit  vector (called the population on some computers).  This is  analogous to LOGCOUNT of an integer.  (POSITION BIT (THE BIT-VECTOR BV)) scans for a 1 or 0 bit, but  can likely be implemented using a word-at-a-time scan.  (EVERY #'ZEROP (THE BIT-VECTOR BV)) tests whether a bit vector  is entirely zero.  (BIT-SUBSETP bit-array-1 bit-array-2) is equivalent to   (EVERY #'ZEROP (BIT-ANDC2 bit-array-1 bit-array-2)) [under  the first proposal, only when the arguments are of rank 1.]  (BIT-DISJOINTP bit-array-1 bit-array-2) is equivalent to  (EVERY #'ZEROP (BIT-AND bit-array-1 bit-array-2)) [under  the first proposal, only when the arguments are of rank 1.]  This is analogous to NOT of LOGTEST of two integers.  (BIT-EQUALP bit-array-1 bit-array-2) is equivalent to  (EVERY #'ZEROP (BIT-XOR bit-array-1 bit-array-2)) [under  the first proposal, only when the arguments are of rank 1.]  BIT-EQUALP differs from EQUAL only when the arguments are of  unequal dimensions.Rationale:  Three new functions are added by BIT-ARRAY-FUNCTIONS:ADD because EVERY  only works on vectors, since issue SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS was  rejected.  BIT-ARRAY-FUNCTIONS:NO-NEW-FUNCTIONS includes the minimal  portion of that proposal needed to avoid adding any new functions, while  omitting all the controversial parts.  The suggestion for compiler optimization is to give users the confidence  that they will get good results when using sequence and mapping  operations on bit vectors.  Otherwise we would feel the need to add  additional bit-vector-specific functions to perform these operations in a  way that is optimized and specialized for bit-vectors.  Recommending optimization of a particular way of performing these  operations avoids the problem of each implementation choosing a different  idiom to optimize, resulting in performance problems when porting.  Relaxing the requirement that bit arrays must have equal dimensions was  requested by users who had tried to use these operations on sets.  The  loose specification of the result dimensions is to allow maximum  implementation freedom.  This is not essential to the proposal and could  be changed to require that the result have the same dimension as the  larger of the two arguments.Current practice:  Symbolics Genera 7.2 has something like the first proposal, but only for  bit vectors, not generalized for bit arrays.  Genera has some additional  functions (BIT-VECTOR-POSITION, BIT-VECTOR-CARDINALITY, and  BIT-VECTOR-ZERO-P) that aren't really necessary since they are equivalent  to POSITION, COUNT, or EVERY plus a type declaration.  The proposal seems  to fit into the rest of Common Lisp better than Genera's current practice.Cost to Implementors:  Implementing these very efficiently may require some clever hand coding.  Of course the standard cannot mandate any particular level of efficiency  and a simple, low-cost implementation is permissible.  Implementing the  compiler suggestions requires keeping track of type declarations in the  compiler, but most compilers already do that.  The second proposal  requires slightly more compiler analysis than the first proposal.  A run-time type test and dispatch to code specialized for bit-arrays  could be used instead of compiler analysis, at a small efficiency cost.Cost to Users:  None.Cost of non-adoption:  Less featureful language.  Some bit array manipulation will have to be  written in nonportable Lisp code or in C or assembly language.Performance impact:  None on programs that don't use these features.  Negligibly small on  the binary bit-array functions referenced above when array dimensions  are equal.  Large improvement for programs that can take advantage of  these features when running in an implementation that optimizes them.Benefits:  More featureful language.Esthetics:  More featureful language.Discussion:  This functionality was suggested on the Common Lisp mailing list  12-Jan-89.  The detailed design has evolved from what was suggested and  is greatly simplified.*start*01460 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 13-Jun-89 15:17:57 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JUN 89 15:17:58 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 13 Jun 89  15:16:35 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 610803; 13 Jun 89 18:18:06 EDTDate: Tue, 13 Jun 89 18:17 EDTFrom: Kim Barrett <IIM@ECLA.USC.EDU>Sender: KMP@STONY-BROOK.SCRC.Symbolics.COMSubject: Issue: BIT-ARRAY-FUNCTIONS (Version 5)To: CL-Cleanup@SAIL.Stanford.EDUComments: Received from Kim Barrett by KMP on MSDOS floppy disk via US MailMessage-ID: <19890613221755.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Of the two proposals, I prefer ADD.  I agree that allowing differingdimensions for the arguments to these functions is important.  Becauseof the current requirement that they have equal dimensions I end upalmost never using them.I think BIT-EQUAL might be a more consistent name, because ofSTRING-EQUAL, but that's a minor quibble.  What should BIT-EQUALP dowith fill-pointers?  EQUAL and EQUALP are limited by the fill-pointer,so probably this should be too.Since I believe we added the COMPLEMENT function at the Hawaii meeting(during the big TEST-NOT-IF-NOT debate), optimize (COMPLEMENT #'ZEROP) too.*start*12742 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 19-Jun-89 09:30:11 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 09:29:51 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 19 Jun 89  09:11:10 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 612952; 19 Jun 89 12:13:02 EDTDate: Mon, 19 Jun 89 12:13 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Reply-To: CL-Cleanup@sail.stanford.eduSubject: Issue: BIT-ARRAY-FUNCTIONS (version 6)To: X3J13@sail.stanford.eduMessage-ID: <19890619161334.2.MOON@EUPHRATES.SCRC.Symbolics.COM>This is a new issue.  It arose from an investigation of featuresthat are plausibly needed but missing from draft ANSI Common Lisp.This issue seems sufficiently simple and noncontroversial thatI would like to see it on the agenda for the June X3J13 meeting.If the discussion gets lengthy, indicating that it actually iscontroversial, then we should just drop it, rather than letting ittake up too much time.Issue:         BIT-ARRAY-FUNCTIONSReferences:    The binary bit-array functions BIT-AND, BIT-IOR, BIT-XOR,               BIT-EQV, BIT-NAND, BIT-NOR, BIT-ANDC1, BIT-ANDC2, BIT-ORC1,               and BIT-ORC2 (CLtL p.294).               The unary bit-array function BIT-NOT (CLtL p.295).               The mapping functions EVERY, MAP, NOTANY, NOTEVERY, and SOME               (CLtL pp.249-250).               The functions COUNT and POSITION (CLtL p.257).Related issues: noneCategory:      ADDITIONEdit history:  Version 1,  9-May-89, by Moon               Version 2, 10-May-89, by Moon (add second proposal)               Version 3, 12-May-89, by Moon (small wording improvements)               Version 4, 13-May-89, by Moon (make more understandable)               Version 5, 23-May-89, by Moon (fix -p naming convention)               Version 6, 19-Jun-89, by Moon (small fixes based on comments                        from Kim Barrett)Problem description:  Logical operations on bit vectors have been found to be useful in such  programs as compiler flow analysis.  They are easy to implement in  straight Common Lisp, but such an implementation is many times slower  than an optimized implementation on most machines.  This is partly  because many machines have instructions to perform these operations or  inner kernels of them, and partly because Common Lisp is not a good  language for implementing this type of low-level bit-oriented operation.  Common Lisp provides some logical operations on bit arrays, but the  provided set is incomplete.  Furthermore, the operations that are  provided are only defined for arrays of identical dimensions, making them  less useful for bit vectors that represent sets, where trailing zero  elements are often omitted.  Some of the sequence functions are useful  for bit vectors, but users (correctly) fear that their implementation may  be optimized for general sequences, not for bit vectors.  CLtL does not specify whether BIT-AND and related functions respect the  fill-pointer, however the description of fill-pointers on p.295 implies  that they should.  This issue contains two alternative proposals.Proposal (BIT-ARRAY-FUNCTIONS:ADD):  1. Allow the binary bit-array functions referenced above to accept  arguments of identical rank but unequal dimensions.  Nonexistent elements  of bit-array-1 or bit-array-2 are assumed to be zero.  If the third  argument is T or a bit-array, result elements outside the bounds of the  array must be zero or an error should be signalled.  If the third  argument is NIL or omitted, each dimension of the result array is equal  to either the corresponding dimension of bit-array-1 or the corresponding  dimension of bit-array-2.  The larger of the two dimensions is used when  necessary to hold all the nonzero elements of the result, otherwise  either the larger or the smaller of the two dimensions is used.  2. Allow BIT-NOT with a bit array as the second argument to accept  arguments of identical rank but unequal dimensions.  Result elements  outside the bounds of the array must be zero or an error should be  signalled.  3. Add the following functions:    BIT-SUBSETP bit-array-1 bit-array-2    Returns true if for every element of bit-array-1 that is 1, the    element with the same subscripts exists in bit-array-2 and is 1.      Bit-array-1 and bit-array-2 must have identical rank but need not    have identical dimensions.    BIT-DISJOINTP bit-array-1 bit-array-2    Returns true if for every element of one bit-array that is 1, the    element with the same subscripts either does not exist in the other    bit-array or is 0.  Bit-array-1 and bit-array-2 must have identical    rank but need not have identical dimensions.    BIT-EQUAL bit-array-1 bit-array-2    Returns true if for every element of one bit-array that is 1, the    element with the same subscripts exists in the other bit-array and    is 1.  Bit-array-1 and bit-array-2 must have identical rank but need    not have identical dimensions.  4. Specify that the binary bit-array functions referenced above, the  unary bit-array function referenced above, and the three bit-array  functions referenced in point 3 respect the fill-pointer of any argument  that is one-dimensional and has a fill-pointer.  5. Suggest in the language specification document that compilers should  optimize the following functions when the sequence argument is declared  to be a bit-vector, taking advantage of any relevant special machine  instructions.    COUNT    POSITION  6. Suggest in the language specification document that compilers should  optimize the following functions when there are two arguments, the second  argument is declared to be a bit-vector, and the predicate argument is  #'ZEROP, taking advantage of any relevant special machine instructions.    EVERY    NOTANY    NOTEVERY    SOMEProposal (BIT-ARRAY-FUNCTIONS:NO-NEW-FUNCTIONS):  Points 1, 2, 4, 5, and 6 are the same as BIT-ARRAY-FUNCTIONS:ADD.  Substitute for point 3:  3. Do not add the three new functions.  Instead, generalize the mapping  functions referenced above (EVERY, MAP, NOTANY, NOTEVERY, and SOME) so  that they operate on "mappables" rather than just sequences.  Define a  mappable to be an array or a list.  Specify that the mappable arguments  to a mapping function, and the result in the case of MAP with a non-NIL  first argument, must all be of the same rank (the rank of a list is  considered to be 1).  Mapping accesses array elements in row-major order.  Generalize the existing specification that a mapping function uses the  length of the shortest sequence, to say that a mapping function uses on  each axis the minimum of the dimensions on that axis of the mappable  arguments.  Additional point 7:  7. Suggest in the language specification document that compilers should  optimize the functions EVERY, NOTANY, NOTEVERY, and SOME when there are  two arguments, the second argument is declared to be a bit-array, and the  predicate argument is #'ZEROP, taking advantage of any relevant special  machine instructions.  In addition compilers should optimize when the  second argument is a call with two arguments to one of the binary  bit-array functions referenced above, to avoid consing an intermediate  result.Examples:  The equivalents of UNION and INTERSECTION for sets represented  as bit vectors, with 1's in positions where set elements are  present, are BIT-IOR and BIT-AND respectively.  (COUNT 1 (THE BIT-VECTOR BV)) computes the cardinality of a bit  vector (called the population on some computers).  This is  analogous to LOGCOUNT of an integer.  (POSITION BIT (THE BIT-VECTOR BV)) scans for a 1 or 0 bit, but  can likely be implemented using a word-at-a-time scan.  (EVERY #'ZEROP (THE BIT-VECTOR BV)) tests whether a bit vector  is entirely zero.  (BIT-SUBSETP bit-array-1 bit-array-2) is equivalent to   (EVERY #'ZEROP (BIT-ANDC2 bit-array-1 bit-array-2)) [under  the first proposal, only when the arguments are of rank 1.]  (BIT-DISJOINTP bit-array-1 bit-array-2) is equivalent to  (EVERY #'ZEROP (BIT-AND bit-array-1 bit-array-2)) [under  the first proposal, only when the arguments are of rank 1.]  This is analogous to NOT of LOGTEST of two integers.  (BIT-EQUAL bit-array-1 bit-array-2) is equivalent to  (EVERY #'ZEROP (BIT-XOR bit-array-1 bit-array-2)) [under  the first proposal, only when the arguments are of rank 1.]  BIT-EQUAL differs from EQUAL only when the arguments are of  unequal dimensions.Rationale:  1,2. Relaxing the requirement that bit arrays must have equal dimensions  was requested by users who had tried to use these operations on sets.  3. Three new functions are added by BIT-ARRAY-FUNCTIONS:ADD because EVERY  only works on vectors, since issue SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS was  rejected.  BIT-ARRAY-FUNCTIONS:NO-NEW-FUNCTIONS includes the minimal  portion of that proposal needed to avoid adding any new functions, while  omitting all the controversial parts.  4. Respecting the fill-pointer of vectors makes the BIT-xxx functions  more consistent with the rest of the language.  They can be thought of as  sequence functions for bit-vectors (and sequence functions always respect  the fill-pointer) that have been generalized to work on multidimensional  bit-arrays as well.  5,6,7. The suggestion for compiler optimization is to give users the  confidence that they will get good results when using sequence and  mapping operations on bit vectors.  Otherwise we would feel the need to  add additional bit-vector-specific functions to perform these operations  in a way that is optimized and specialized for bit-vectors.  Recommending  optimization of a particular way of performing these operations avoids  the problem of each implementation choosing a different idiom to  optimize, resulting in performance problems when porting.Current practice:  Symbolics Genera 7.2 has something like the first proposal, but only for  bit vectors, not generalized for bit arrays.  Genera has some additional  functions (BIT-VECTOR-POSITION, BIT-VECTOR-CARDINALITY, and  BIT-VECTOR-ZERO-P) that aren't really necessary since they are equivalent  to POSITION, COUNT, or EVERY plus a type declaration.  The proposal seems  to fit into the rest of Common Lisp better than Genera's current practice.  Symbolics Genera 7.2 does not respect the fill-pointer in BIT-AND.Cost to Implementors:  Implementing these very efficiently may require some clever hand coding.  Of course the standard cannot mandate any particular level of efficiency  and a simple, low-cost implementation is permissible.  Implementing the  compiler suggestions requires keeping track of type declarations in the  compiler, but most compilers already do that.  The second proposal  requires slightly more compiler analysis than the first proposal.  A run-time type test and dispatch to code specialized for bit-arrays  could be used instead of compiler analysis, at a small efficiency cost.Cost to Users:  None, unless some implementation currently violates point 4 and user  programs currently depend on that.  It seems quite unlikely that anyone  would depend on BIT-xxx functions to access past the fill-pointer.Cost of non-adoption:  Less featureful language.  Some bit array manipulation will have to be  written in nonportable Lisp code or in C or assembly language.Performance impact:  None on programs that don't use these features.  Negligibly small on  the binary bit-array functions referenced above when array dimensions  are equal.  Large improvement for programs that can take advantage of  these features when running in an implementation that optimizes them.Benefits:  More featureful language.Esthetics:  More featureful language.Discussion:  This functionality was suggested on the Common Lisp mailing list  12-Jan-89.  The detailed design has evolved from what was suggested and  is greatly simplified.  The loose specification of the result dimensions in points 1 and 2 is to  allow maximum implementation freedom.  This is not essential to the  proposal and could be changed to require that the result have the same  dimension as the larger of the two arguments.  It has been suggested that points 6 and 7 should specify some other  predicates to optimize, such as #'PLUSP or (COMPLEMENT #'ZEROP).  Moon  doesn't think this is important enough to be worth adding.*start*01297 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 19-Jun-89 10:35:02 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 10:35:08 PDTReceived: from Think.COM (Gateway.Think.COM) by SAIL.Stanford.EDU with TCP; 19 Jun 89  10:32:37 PDTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Mon, 19 Jun 89 13:33:13 EDTDate: Mon, 19 Jun 89 13:31 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: BIT-ARRAY-FUNCTIONS (version 6)To: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890619161334.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-Id: <19890619173133.4.BARMAR@OCCAM.THINK.COM>I'd like to suggest an additional change, which seems to be consistentwith the attitude about use of bit vectors expressed in the proposal.The BIT and SBIT functions should return 0 if asked to access outsidethe bit array.  This would maintain the tautology	(bit (bit-XXX v1 v2) n) == (logXXX (bit v1 n) (bit v2 n))If slowing down these functions (they'd be the only array accessorsREQUIRED to check the dimensions) is considered unacceptable, then a newaccessor should be added.                                                barmar*start*01576 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 19-Jun-89 10:49:59 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 10:50:01 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 19 Jun 89  10:47:50 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 613102; 19 Jun 89 13:44:00 EDTDate: Mon, 19 Jun 89 13:44 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: BIT-ARRAY-FUNCTIONS (version 6)To: Barry Margolin <barmar@Think.COM>cc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890619173133.4.BARMAR@OCCAM.THINK.COM>Message-ID: <19890619174433.5.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 19 Jun 89 13:31 EDT    From: Barry Margolin <barmar@Think.COM>    I'd like to suggest an additional change, which seems to be consistent    with the attitude about use of bit vectors expressed in the proposal.    The BIT and SBIT functions should return 0 if asked to access outside    the bit array.  This would maintain the tautology	    (bit (bit-XXX v1 v2) n) == (logXXX (bit v1 n) (bit v2 n))    If slowing down these functions (they'd be the only array accessors    REQUIRED to check the dimensions) is considered unacceptable, then a new    accessor should be added.I don't like this idea.If upon reflection you still like it, could you prepare an amendmentto bring up at the meeting next week?*start*02132 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 19-Jun-89 15:42:27 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 15:42:31 PDTReceived: from Think.COM (Gateway.Think.COM) by SAIL.Stanford.EDU with TCP; 19 Jun 89  15:40:23 PDTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Mon, 19 Jun 89 18:41:01 EDTDate: Mon, 19 Jun 89 18:39 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: BIT-ARRAY-FUNCTIONS (version 6)To: David A. Moon <Moon@stony-brook.scrc.symbolics.com>Cc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890619174433.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-Id: <19890619223922.8.BARMAR@OCCAM.THINK.COM>    Date: Mon, 19 Jun 89 13:44 EDT    From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>	Date: Mon, 19 Jun 89 13:31 EDT	From: Barry Margolin <barmar@Think.COM>	I'd like to suggest an additional change, which seems to be consistent	with the attitude about use of bit vectors expressed in the proposal.	The BIT and SBIT functions should return 0 if asked to access outside	the bit array.  This would maintain the tautology		(bit (bit-XXX v1 v2) n) == (logXXX (bit v1 n) (bit v2 n))	If slowing down these functions (they'd be the only array accessors	REQUIRED to check the dimensions) is considered unacceptable, then a new	accessor should be added.    I don't like this idea.Could you elaborate?  Why is it that you like the idea of assuming 0elements on the end when combining bit vectors, but not when accessingthem?  Either you think of them as being infinitely padded with zeros,or you don't.I'm not sure I really grasp the whole motivation for this change.Anyone who needs the kind of functionality being proposed can alreadyget it by using the boolean integer functions.  They already provide theinfinitely-padded-with-zeroes feature.  In fact, they also provideinfinitely-padded-with-ones, also, in the form of negative numbers.                                                barmar*start*03302 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 21-Jun-89 15:11:01 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 15:11:02 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 21 Jun 89  15:06:51 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 614570; 21 Jun 89 14:24:32 EDTDate: Wed, 21 Jun 89 14:25 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: BIT-ARRAY-FUNCTIONS (version 6)To: Barry Margolin <barmar@Think.COM>cc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890619223922.8.BARMAR@OCCAM.THINK.COM>Message-ID: <19890621182512.5.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 19 Jun 89 18:39 EDT    From: Barry Margolin <barmar@Think.COM>	Date: Mon, 19 Jun 89 13:44 EDT	From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>	    Date: Mon, 19 Jun 89 13:31 EDT	    From: Barry Margolin <barmar@Think.COM>	    I'd like to suggest an additional change, which seems to be consistent	    with the attitude about use of bit vectors expressed in the proposal.	    The BIT and SBIT functions should return 0 if asked to access outside	    the bit array.  This would maintain the tautology		    (bit (bit-XXX v1 v2) n) == (logXXX (bit v1 n) (bit v2 n))	    If slowing down these functions (they'd be the only array accessors	    REQUIRED to check the dimensions) is considered unacceptable, then a new	    accessor should be added.	I don't like this idea.    Could you elaborate?  Why is it that you like the idea of assuming 0    elements on the end when combining bit vectors, but not when accessing    them?  Either you think of them as being infinitely padded with zeros,    or you don't.I disagree with the last sentence.  I don't think the BIT function is inthe same category as the BIT-AND function, I think of it as being at adifferent conceptual level.  It's a matter of taste and intuition, soI don't think I can explain it better, and I don't expect you to beconvinced.  I'm only saying what I don't like, not what I think youought to dislike.Then again, I have never used the BIT function and would propose toremove it from the language if I thought that had a chance of passing.Same for SBIT, CHAR, SCHAR, and SVREF.    I'm not sure I really grasp the whole motivation for this change.    Anyone who needs the kind of functionality being proposed can already    get it by using the boolean integer functions.  They already provide the    infinitely-padded-with-zeroes feature.  In fact, they also provide    infinitely-padded-with-ones, also, in the form of negative numbers.The discussion that originally prompted this pointed out the reason whythe boolean integer functions aren't always adequate.  I forget now whatit was, maybe the lack of control over consing, or maybe something morefundamental.  It looks like all that got into the writeup was a pointerto that discussion, not a summary of it.  Of course, that's the motivationfor having the BIT-AND etc. functions in the language in the first place,more than the motivation for making this change to them.*start*02533 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 21-Jun-89 17:33:41 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 JUN 89 17:33:47 PDTReceived: from Think.COM (Gateway.Think.COM) by SAIL.Stanford.EDU with TCP; 21 Jun 89  17:32:18 PDTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Wed, 21 Jun 89 16:05:08 EDTDate: Wed, 21 Jun 89 16:03 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: BIT-ARRAY-FUNCTIONS (version 6)To: David A. Moon <Moon@stony-brook.scrc.symbolics.com>Cc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890621182512.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-Id: <19890621200319.9.BARMAR@OCCAM.THINK.COM>    Date: Wed, 21 Jun 89 14:25 EDT    From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>	Date: Mon, 19 Jun 89 18:39 EDT	From: Barry Margolin <barmar@Think.COM>	    Date: Mon, 19 Jun 89 13:44 EDT	    From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>		Date: Mon, 19 Jun 89 13:31 EDT		From: Barry Margolin <barmar@Think.COM>		I'd like to suggest an additional change, which seems to be consistent		with the attitude about use of bit vectors expressed in the proposal.		The BIT and SBIT functions should return 0 if asked to access outside		the bit array.  This would maintain the tautology			(bit (bit-XXX v1 v2) n) == (logXXX (bit v1 n) (bit v2 n))		If slowing down these functions (they'd be the only array accessors		REQUIRED to check the dimensions) is considered unacceptable, then a new		accessor should be added.	    I don't like this idea.	Could you elaborate?  Why is it that you like the idea of assuming 0	elements on the end when combining bit vectors, but not when accessing	them?  Either you think of them as being infinitely padded with zeros,	or you don't.    I disagree with the last sentence.  I don't think the BIT function is in    the same category as the BIT-AND function, I think of it as being at a    different conceptual level.That was why I suggested the possibility of inventing a new function forthis purpose (although the reason I gave wasn't complete).I just can't think of a good name that would make it obvious that one isjust a pre-optimized bit array accessor and the other is for accessingconceptually infinite bit vectors (or bit arrays, if the other part ofthe proposal passes).                                                barmar