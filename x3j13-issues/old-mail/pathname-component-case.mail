*start*05893 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JUL 88 11:59:47 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Jul 88  11:58:08 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 428071; Fri 1-Jul-88 19:57:18 EDTDate: Fri, 1 Jul 88 19:57 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-CASE (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880701195711.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        PATHNAME-COMPONENT-CASEReferences:   Pathnames (pp410-413),	      MAKE-PATHNAME (p416),	      PATHNAME-HOST (p417),	      PATHNAME-DEVICE (p417),	      PATHNAME-DIRECTORY (p417),	      PATHNAME-NAME (p417),	      PATHNAME-TYPE (p417)Category:     CHANGEEdit history: 1-Jul-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  Issues of case in pathnames are a major source of problems.  In some file systems, the canonical case is lowercase, in some  uppercase, in some mixed.  In some file systems, case matters, in others it does not.  (NAMESTRING (MAKE-PATHNAME :NAME "FOO" :TYPE "LISP"))  will produce an `ugly' file name like "FOO.LISP" in many (but not all)  Common Lisp implementations talking to Unix, for example.  (NAMESTRING (MAKE-PATHNAME :NAME "foo" :TYPE "lisp"))  might produce an `ugly' file name like "^Vf^Vo^Vo.^Vl^Vi^Vs^Vp"  in a Common Lisp implementation talking to a Tops-20.  Problems like this make it difficult to use MAKE-PATHNAME for much of  anything without corrective (non-portable) code.  Other problems occur in merging because doing   (NAMESTRING (MERGE-PATHNAMES (MAKE-PATHNAME :HOST "MY-TOPS-20" :NAME "FOO")	                        (PARSE-NAMESTRING "MY-UNIX:x.lisp")))  should probably return "MY-TOPS-20:FOO.LISP" but in fact might return  "MY-TOPS-20:FOO.^Vl^Vi^Vs^Vp" in some implementations.  Problems like this make it difficult to use any merging primitives for  much of anything without corrective (non-portable code).Proposal (PATHNAME-COMPONENT-CASE:CANONICALIZE):  Designate a treatment for case in pathname components which is  distinct from the treatment of case in the namestrings. The treatment  should be invariant across operating systems.  If a string given to MAKE-PATHNAME, or returned by any of the  PATHNAME-xxx accessor operations, is all uppercase, it is said to  designate a name in the system's "canonical case".  If a string given to MAKE-PATHNAME, or returned by any of the  PATHNAME-xxx accessor operations, is all lowercase, it is said to  designate a name in the system's "anticanonical case".  If a string given to MAKE-PATHNAME, or returned by any of the  PATHNAME-xxx accessor operations, is mixed case, it is said  designate a name in exactly the indicated case.  Functions such as PARSE-NAMESTRING and NAMESTRING which convert  from or to native host syntax will perform any necessary conversions  from internal syntax.  Note: In fact, this proposal does not require an implementation to  change its internal representation. It only requires the CL-defined  accessors to behave as if the internal representation had been changed.  Whether the actual internal representation is changed is still up to an  implementation. A consequence of this is that if pathnames print   in a way that shows the components individually (such as #S), they  are not constrained to print the components in any particular case;  they are constrained only to have definite syntax conventions and to  be able to invert those conventions at the appropriate time. Any change  to the way pathnames print is beyond the scope of this proposal.Test Case:  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp"))    => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")) => "FOO"Rationale:  This does not solve the whole pathname problem, but it does improve  the situation for a clearly defined set of very common problems.Current Practice:  Symbolics Genera implements this behavior.Cost to Implementors:  While this proposal is compatible with CLtL, it may not be compatible with  the implementations of CLtL which some implementations have chosen.  It is possible to isolate the forced changes to the referenced functions  (MAKE-PATHNAME and the PATHNAME-xxx accessors). Existing functions can be  renamed, and new functions with the same name can be introduced which simply  encapsulate case conversion. No further change is forced.  It may, however, be desirable for an implementation to make a more complete  overhaul of their representation. In implementations where the implementors  feel a need to do this, the amount of work may be considerably greater.Cost to Users:  Technically, this change is upward compatible.  In fact, since the existing CLtL spec is so poor, nearly everyone relies  heavily on implementation-specific behavior since there is little other  choice. As such, any change is almost certain to break lots of programs,  in usually superficial but nevertheless important ways. However, if we  really make the pathname facility more portable, the user community may be  willing to bear the consequences of these changes.Cost of Non-Adoption:  We would be contributing to the perpetuation of the existing fiasco of a  pathname system.Benefits:  The major costs of non-adoption would be avoided.Aesthetics:  More code is required, but the code supports a simpler user model.  Anything that simplifies the user model of pathnames is going to be an  improvement.Discussion:  Pitman suports PATHNAME-COMPONENT-CASE:CANONICALIZE.*start*01184 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 13:46:15 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 18 Jul 88  13:44:55 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 18 Jul 88 16:42:31 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-reply-to: Your message of Fri, 01 Jul 88 19:57:00 -0400.             <880701195711.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM> Date: Mon, 18 Jul 88 16:42:01 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUThis proposal to use case to control the canonicalization of case inpathname components looks to me like it would cause confusion and paralysisof truly awesome propotions.  For that reason, I am strongly opposed tothis proposal in its current form.If we need a way to canonicalize the case of various pathname fields, maybewe should have a CANONICALIZE-CASE function that takes a string and afile-system type and does the proper case-conversion.-- Scott*start*03007 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 14:04:37 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 18 Jul 88  14:03:19 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 434787; Mon 18-Jul-88 17:02:47 EDTDate: Mon, 18 Jul 88 17:02 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1)To: Scott.Fahlman@B.GP.CS.CMU.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880718170217.3.KMP@PEWEE.SCRC.Symbolics.COM>Can you elaborate on the kind of ``confusion and paralysis of trulyawsome proportions'' you expect?Can you also give a couple examples of what you consider portableuses of the current paradigm which do not involve the use of READ-LINEin order to obtain a namestring in the first place?My point is that if every portable use of MAKE-PATHNAME must look like (MAKE-PATHNAME :DIRECTORY (MAPCAR #'CANONICALIZE-CASE '("JOE" "TOOLS"))		:NAME (CANONICALIZE-CASE "FOO" *LOCAL-FS*)	        :TYPE (CANONICIALIZE-CASE "LISP" *LOCAL-FS*))then what's the point?I think the examples I put forth were simple and compelling and I wouldlike to see some equally compelling -- but most importantly, concrete --arguments of how such lossage is likely to occur. The only cases I canimagine causing problems are cases where people insist on programming innew-CL without reading the documentation. I don't mind designing languagesto take into account naive users (normal, thinking people who haveread the documentation) but I do mind designing languages to take intoaccount ignorant users (people who believe their own personal prejudicesand intuitions should take precedence over a carefully reasoned andthoroughly documented theory).Do you have a technical objection to the proposal on the table? The pathnamesystem from which I took the idea for this proposal is one of very few Iknow of which has tried this approach and demonstrated it to be workable inthe face of numerous operating systems. Frankly, the only comments I've everheard numerous users of the Symbolics pathname system were ones of astonishmentat how well that aspect of the lisp machine pathname system works. So itseems to me that the facts are in direct opposition to your ``doom and gloom''prediction. Do you contest this claim or practical experience to the contrarywhich you would like to share?Does anyone else have any opinion on this issue? I think the experience bothof users who have tried to port programs between radically different filesystems, and of implementors who support simultaneous interfaces to multiple,very different file systems would be of interest. I think this is atremendously important issue and deserves considerable thought.*start*06454 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 19:58:46 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 18 Jul 88  19:57:11 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 18 Jul 88 22:56:05 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-reply-to: Your message of Mon, 18 Jul 88 17:02:00 -0400.             <880718170217.3.KMP@PEWEE.SCRC.Symbolics.COM> Date: Mon, 18 Jul 88 22:55:49 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU    Can you elaborate on the kind of ``confusion and paralysis of truly    awsome proportions'' you expect?    Sure.  I expect to see several hundred spurious bug reports of the form "Itold Lisp to replace the extension of this file with `foo' and for someunknown reason it insisted on producing `filename.FOO'.  That's the formthe spurious report would take for people on lower-case systems like Unix-- others would have a slightly different problem.I agree that it would be nice if everyone read the manual, but if a featureof the language is sufficiently non-intuitive, people are going to beburned even if there's a warning in red letters -- they'll just refuse tobelieve that the language designers could have been so perverse.  Supposewe decided that it would be useful to represent positive integers as "-n"and negative integers as "+n".  Do you think that documenting this decisionwould turn it into good language design?  I think not, but you areproposing to tell Unix-based users, and lots of others, that for them "FOO"means you want lower case in the filename and "foo" means you want uppercase.As you point out, this would an effectively incompatible change in a partof the language that is used moderately heavily, though usually for rathersimple tasks.  A lot of users regard most of the pathname stuff as bizarrenonsense that they really don't want to understand, but they have learnedto do a few simple things (e.g. moving files between directories andchanging file extensions) by rote.  Only a few sophisticated users areconcerned with writing code that works across many systems with radicallydifferent file-naming conventions.  If we can give these sophisticatedusers a better way in which to do their job, fine, but I don't think weshould accomplish this by screwing the people who have existing code thatsolves their little file problems within, say, an all-Unix environment andwho never plan to export their code to Tenex.  (I hope you aren't going toreply that such people deserve to be screwed, since they should not bewriting nasty non-portable code.)    Can you also give a couple examples of what you consider portable    uses of the current paradigm which do not involve the use of READ-LINE    in order to obtain a namestring in the first place?    No.  I think that the existing pathname stuff is pretty much a dead lossfor this purpose due to the problem you describe and several others.  If itwere up to me, we'd toss this pathname mess out and start over, but it'stoo late for that.  If we can patch over the worst of these problems, fine,that's useful.  I'm not arguing with your goals.  I just don't think wehave to do this in a way that breaks existing code and that will standforever as a textbook example of counter-intuitive language design.Aside from my distaste for a system in which "foo" means "FOO" andvice-versa, I do have one technical objection to your proposal: unless I'vemissed something, there's no way to specify that you want some string to beused verbatim, regardless of the target system, unless that string happensto be of mixed case.  I guess in unix the "canonical" case is lower, butsometimes you want to specify a file whose name is something like"foo.BAR".  So if we overload the field-value strings to signalcase-canonicalization, we need some way to quote these strings and say"this is really what I want, so leave it alone".Would it suffice to add a :CANONICALIZE-CASE keyword to MAKE-PATHNAME forthose few users who really are trying to write code that will run on allknown systems?  That would be an upward compatible change.  If we needfield-by-field control of case-canonicalization, I think that theCANONICALIZE-CASE function I proposed earlier does the job quite well, evenif it is a bit verbose.  I'd rather have a form that states that thiscanonicalization is going on than to surprise naive users by doing it whenthey are not expecting it.  Alternatively we could try to work out thesyntax for a new function or macro, MAKE-PORTABLE-PATHNAME, thataccompanies each field specifier with a flag of some sort indicating howthe case is to be treated.    The pathname    system from which I took the idea for this proposal is one of very few I    know of which has tried this approach and demonstrated it to be workable in    the face of numerous operating systems. Frankly, the only comments I've ever    heard numerous users of the Symbolics pathname system were ones of astonishment    at how well that aspect of the lisp machine pathname system works. So it    seems to me that the facts are in direct opposition to your ``doom and gloom''    prediction. Do you contest this claim or practical experience to the contrary    which you would like to share?    No, I'm just flaming, based on instrospection and my rough model of hownaive users are likely to think; I haven't run any experiments.  If youtell me that Symbolics already uses the system that you propose and thatthe users are unanimous in their praise of it, I guess I'll have to acceptthat, surprising as it may be.  I know that I personally would find itconfusing to write "foo" when I mean "FOO" and vice versa, but then I'vealways been kind of slow at catching onto these advanced programmingconcepts.  Maybe I'm the only one with this hangup, or maybe I'm typicaland the Symbolics user community has learned not to complain about thingsthat seem overly complex and counter-intuitive.Some other views would be useful at this point.  If the rest of you thinkthat KMP's proposed change is the most intutive way to handle this caseproblem, I'll shut up -- I no longer have formal voting rights in any case.-- Scott*start*01329 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 18 JUL 88 20:34:46 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 18 Jul 88  20:33:18 PDTReceived: from Burger.ms by ArpaGateway.ms ; 18 JUL 88 20:31:59 PDTFrom: masinter.paDate: 18 Jul 88 20:31:02 PDTSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1)In-reply-to: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Mon, 18 Jul 88 22:55:49 EDTTo: Scott.Fahlman@B.GP.CS.CMU.EDUcc: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880718-203159-4394@Xerox>My general goal is to try to standardize current practice, and reduce needlessdivergence. As far as I can tell, there are lots of both case sensitive and caseinsensitive file systems around. We might be lucky if we can a) standardize how pathnames work when talking to various kinds of operatingsystems (e.g., all Unix Common Lisps should use file names the same way) andb) give users some guidelines on how to write portable code given that there areinevitable differences.Certainly a proposal that mandates an "unnatural" interface between Lisp and thehost operating system will be rejected by the operating system vendors.*start*06537 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 19 JUL 88 08:04:32 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 435112; Tue 19-Jul-88 11:04:36 EDTDate: Tue, 19 Jul 88 11:04 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1)To: masinter.pa, Scott.Fahlman@B.GP.CS.CMU.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <880718-203159-4394@Xerox>,             The message of 18 Jul 88 22:55 EDT from Scott.Fahlman@B.GP.CS.CMU.EDUMessage-ID: <880719110427.6.KMP@PEWEE.SCRC.Symbolics.COM>    Date: 18 Jul 88 20:31:02 PDT    From: masinter.pa@Xerox.COM    My general goal is to try to standardize current practice, and reduce needless    divergence. As far as I can tell, there are lots of both case sensitive and case    insensitive file systems around. We might be lucky if we can     a) standardize how pathnames work when talking to various kinds of operating    systems (e.g., all Unix Common Lisps should use file names the same way) and    b) give users some guidelines on how to write portable code given that there are    inevitable differences.Speaking now with my user's hat on, I must say that I think this is acomplete whimp-out.The plain fact is that programmers need MUCH more than a&b, and we are capableof providing it. Current practice is that there are at least some implementationswhich deal exceedingly well with a lot of kinds of operating systems in thesame environment. If we cannot select and standardize on one of those models, itseems clear to me that the reasons are political and not technical.    Certainly a proposal that mandates an "unnatural" interface between Lisp and the    host operating system will be rejected by the operating system vendors.I can't tell if this remark about unnaturalness alludes to my proposal,but I'll assume it does and reply on that premise...I don't intend to propose an "unnatural" interface between Lisp and thehost operating system. In fact, I don't see the functions I'm proposing changingas part of the interface between Lisp and the operating system. I see them asan interface to an abstract operating system.The purpose of the pathname system seems to me to have been to abstract awayfrom operating systems a bit and provide a portable file system model whichwas device independent.For example, we typically parse out `type' information where therereally is none on Unix. That idea is in some sense unnatural to Unix, but itis not unnatural to the idea of a file system, and CL programmers thought itwould be useful. So we created a model and users seem happy with it becauseit provides them something of value.Issues of case are completely non-trivial to writers of portable code. Theproposed solution does not intend to slight any host operating system. Theidea is to say that there is a partition in the file system interface:A pathname is an abstract representation of a filename. It containsinformation in its slots which ties it to a particular host file system,but it is designed in such a way that it can be manipulated with minimumregard for the particular characteristics of the host operating system. The MAKE-PATHNAME operation creates pathnames.    PATHNAME-HOST, PATHNAME-DEVICE, etc. access the abstract representation.A namestring is a concrete representation of a filename. Sincenamestrings are not portable, a namestring is rarely part of a programand is more commonly the result of user typein or of an operation suchas NAMESTRING which coerces a pathname to its native stringrepresentation.An IdeaIn some ways this smells of the FIXNUM issue. Perhaps the problem ispartly just that you have interesting functionality that you don't wantto lose and I can talk you into just `saying what you mean.' Currentlythere are two arguably desirable pieces of functionality, and only onename. Maybe if there were two names, we could make one name refer to whatScott wants and one name refer to what I want.In Genera, you can do (SEND pathname :RAW-NAME), etc. to see thehost-specific values, but hardly anyone ever does this in any code I'veever seen. I would be willing to extend the proposal in any of thefollowing ways if it would make it more palatable to anyone: (a) Add functions PATHNAME-RAW-DEVICE, PATHNAME-RAW-DIRECTORY,      PATHNAME-RAW-NAME, PATHNAME-RAW-TYPE, PATHNAME-RAW-VERSION.     [We could use "NATIVE" instead of "RAW" if people found that more      appealing. It is longer, though.] (b) Add an optional NATIVE-P argument which controlled case translation     and such in the PATHNAME-xxx accessors. For the sake of portability,     I would definitely want this argument to default to NIL (meaning that     the default was to return a canonicalized value, but that it could     be overridden to inhibit this behavior by people that wanted it).There are also a couple of interesting variants of (a) which we couldeven play with: (a1) Make functions FILENAME-HOST, FILENAME-DEVICE, etc. which were like     PATHNAME-HOST, etc. except:	- They would accept any argument that was coerceable to a	  pathname.	- They would return the argument in native form.     eg, (FILENAME-NAME "/foo/bar.lisp") => "bar" on Unix (a2) Extend the set of functions like FILE-NAMESTRING to include      NAME-NAMESTRING, TYPE-NAMESTRING, and VERSION-NAMESTRING so that      it would be more easily possible to pick apart namestrings.These latter two, especially a1, have the version of making the -raw-things feel perhaps less like second-class citizens. [Personally, I don'treally care if they are second-class citizens because in my view theyreally are. CL is supposed to be a portable language, and I'm content toprovide non-portable features only to the extent that it doesn't get inthe way of providing portable ones. In this case, the names PATHNAME-NAME,etc. have a right (I feel) to the portable semantics. As long as we don'tmuck with that, I'm content to provide whatever else is necessary tomake others happy.]Aside to Fahlman: I don't think voting rights have much to do withanything in this forum, so I wouldn't worry about that. I'm happy tohear your opinion when you're willing (as you were) to elaborate onyour fears enough that we can have a technical discussion.*start*01625 00024 US Return-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 20 JUL 88 11:48:04 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06730; 20 Jul 88 19:18 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Wed, 20 Jul 88 19:13:13 BSTMessage-Id: <8514.8807201813@subnode.aiai.ed.ac.uk>To: KMP@scrc-stony-brook.arpa, Scott.Fahlman@b.gp.cs.cmu.edu, masinter.paSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1)Cc: CL-Cleanup@sail.stanford.edu> Date: Tue, 19 Jul 88 11:04 EDT> From: Kent M Pitman <KMP@arpa.scrc-stony-brook>> A namestring is a concrete representation of a filename. Since> namestrings are not portable, a namestring is rarely part of a program> and is more commonly the result of user typein or of an operation such> as NAMESTRING which coerces a pathname to its native string> representation.I guess I don't understand this point, because I don't see that pathnamesare all that portable.  Aren't the files usually in a different place ondifferent machines, and so musn't the pathname be different for differentmachines?  A pathname might work if I'm creating a file and am willing tohave it go to some default place (the current directory, say), butotherwise I may have to know there's a place called "/tmp" or somethingof that sort.Moreover, it turns out that many programs do contain namestrings.  Thedefsys in PCL is one example.  They are immediately converted to pathnames,but nonetheless start out as namestrings.-- Jeff*start*04273 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 20 JUL 88 15:33:09 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 436177; Wed 20-Jul-88 18:33:07 EDTDate: Wed, 20 Jul 88 18:32 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1)To: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>, Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, masinter.pa, Scott.Fahlman@B.GP.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8514.8807201813@subnode.aiai.ed.ac.uk>,             <880719110427.6.KMP@PEWEE.SCRC.Symbolics.COM>,             <880718-203159-4394@Xerox>,             The message of 18 Jul 88 22:55 EDT from Scott.Fahlman@B.GP.CS.CMU.EDU,             <880718170217.3.KMP@PEWEE.SCRC.Symbolics.COM>,             The message of 18 Jul 88 16:42 EDT from Scott.Fahlman@B.GP.CS.CMU.EDU,             <880701195711.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19880720223239.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI support the proposal (PATHNAME-COMPONENT-CASE:CANONICALIZE).  I thinkcurrent practice in the Symbolics Genera system (and I believe in the TIExplorer system as well) has shown that this approach is very viable fordealing portably with a wide range of file systems.  The choice of upperrather than lower case as the canonical case is of course arbitrary; ajustification of upper case is for consistency with Common Lisp symbols.I agree with Kent that if this situation is not straightened out, pathnamesare not very useful for portable programs, and that straightening out thesituation will be a big help in that respect.I would also support a variant of this proposal that augmented theportable pathname constructor and accessors with a native constructorand accessors, either with different names or as additional arguments tothe same-named functions.  I assume Kent left the native constructor andaccessors out of his original proposal because he wanted to keep it leanand omit unnecessary complications.  However, if Scott feels they shouldbe included, I'm happy to let them be included.  I agree with Kent thatin practice the portable operations are used much more commonly than thenative operations.  I believe this is because programs that work interms of native pathnames typically use namestrings and do not accesspathname components at all.    Date: Wed, 20 Jul 88 19:13:13 BST    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>        I guess I don't understand this point, because I don't see that pathnames    are all that portable.  Aren't the files usually in a different place on    different machines....I have to comment on this, because it's a common misconception.Actually there are two points that have to be made.  First, we are nottalking about making pathnames portable, we are talking about makingpathname-manipulating programs portable.  That's a big difference!  Thepoint is to provide portable ways to perform the operations whosedetails vary across file systems.  In fact that is the -only- point ofpathnames; if we didn't want to do that, we would just use strings andmanipulate them with string operations.  The pathname abstraction wasintroduced solely to make pathname-manipulating programs portable.The second comment is that it is in fact both possible and useful to makepathnames themselves portable.  That would be the subject of a separateproposal.  Again, this has been current practice in both Symbolics and TIsystems since before Common Lisp even existed, and works quite well.  Theinterested reader can consult the documentation of "logical pathnames"for either of those systems.  Basically the idea is to have an imaginaryfile system that behaves in the same way everywhere, and that puts filesin the same place everywhere.  Then at each location one defines a set oftranslations that implement the imaginary file system by mapping it intoa real file system.  Any namestring embedded in a program ought to bea logical namestring if one expects that program to be at all portable.*start*04334 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 06:24:41 PDTReceived: from SEF1.SLISP.CS.CMU.EDU ([128.2.218.13]) by SAIL.Stanford.EDU with TCP; 21 Jul 88  06:23:28 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 21 Jul 88 01:06:51 EDTTo: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-reply-to: Your message of Wed, 20 Jul 88 18:32:00 -0400.             <19880720223239.0.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Thu, 21 Jul 88 01:06:44 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUDave,I think that the problem here is that we see rather different classes ofprograms and programmers.  At Symbolics and some of the big toolkitvendors, most of the code that is written has to be portable to all knownfile systems.  You people big, nasty portability problems to solve and youwant better tools for this.  If that means that lots of existing code hasto be broken and extremely counter-intuitive conventions have to beadopted, well, that's a small price to pay.  And to you it seems obviousthat the case-hacking versions of of the pathname functions should get thegood names, since any code that is not portable to every known file systemis "second-class", to use KMP's label.I see a different environment.  When I'm writing application code for myown use, or for that of my colleagues at CMU, I want that code to beportable across several different Common Lisp systems, but all of the filesystems around here are unix-like in their treatment of case.  In theunlikely event that anyone wants to port this code to a TOPS-20 system,they'll have to spend ten minutes fixing up a few pathname fields; I'm notgoing to worry about that right now.  I'm not opposed to making thingsportable across very different file systems, but I put a lower value onthis than the people who do it for a living.  I don't want to achieve thisgoal in a way that breaks a lot of existing code and that uses syntacticconventions that are going to confuse Lispers for generations to come.  I'mnot alone -- lots of people are working in environments where all the filesystems are similar in their treatment of case.OK, let's accept that we need to solve this portable-case problem and seeif there is some less obnoxious way to do it.  Some ideas:1. Nobody has responded to my suggestion that we add a :CANONICAL-CASEkeyword to MAKE-PATHNAME, which defaults to NIL.  If non-nil, this saysthat all the field-name string are to be converted to canonical case.  Ifwe do it this way, we break no existing code.  New users and those writingnon-portable code would leave this off, and their field-name strings wouldnot change case in mysterious ways.  This would eliminate most of thepotential confusion I described in my previous note.2. Same suggestion, but a non-nil :CANONICAL-CASE argument says to processthe fields the way KMP proposes: canonicalize, anti-canonicalize, or keepthe string as-is, depending on its case.  This gives us more flexibilitythat option 1, though it is more complicated.  Again, this breaks noexisting code, and mysterious case-conversions don't happen until you askfor them; at that point, you'd better have read the manual.  I suppose thatthe accessor functions for pathname fields also need a keyword or optionalarg saying to do the hairy case conversions.3. Make two sets of functions, one set handling the field names verbatimand the other doing Symbolics-style case conversion.  But leave the goodnames (the current ones) with the current non-converting definitions.Again, we break no existing code and naive users are less likely to land inthe deep guano.  Sophisticated users writing ultra-portable code might haveto type a little more, but not a lot more, and such people are probablyclever enough to use word-abbrev mode.I could live pretty happily with any of these three solutions; I'm stillpretty unhappy with the original proposal, despite the claim that Symbolicsand maybe TI users have learned to live with this system.  Have youactually polled the people who get bug reports and who teach Lisp to yournew users to see if this convention is causing confusion?-- Scott*start*00666 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 08:15:27 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Jul 88  08:14:11 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 21 JUL 88 08:09:56 PDTDate: 21 Jul 88 08:09 PDTFrom: Masinter.paSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-reply-to: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Thu, 21 Jul 88 01:06:44 EDTTo: Scott.Fahlman@B.GP.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880721-080956-3657@Xerox>I'd go for your #1 or #2.*start*01413 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 08:26:15 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Jul 88  08:25:18 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 436512; 21 Jul 88 11:23:58 EDTDate: Thu, 21 Jul 88 11:23 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) To: Scott.Fahlman@B.GP.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: The message of 21 Jul 88 01:06 EDT from Scott.Fahlman@B.GP.CS.CMU.EDUMessage-ID: <19880721152341.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 21 Jul 88 01:06:44 EDT    From: Scott.Fahlman@B.GP.CS.CMU.EDU    ....If we do it this way, we break no existing code....You mean we break none of -your- existing code.  The only way to break noexisting code is to retain the unsatisfactory status quo.  Since CLtL isnot specific here, different implementations have resolved the ambiguityin different ways, and if they are to be made all to work the same way,some existing code will have to change.If the above has an obnoxious tone, it's not intentional.  I simply meanto point out that what you said is not accurate.*start*03600 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 13:03:58 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 21 Jul 88  13:01:43 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 21 Jul 88 16:00:21 EDTTo: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-reply-to: Your message of Thu, 21 Jul 88 11:23:00 -0400.             <19880721152341.2.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Thu, 21 Jul 88 16:00:02 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU            Date: Thu, 21 Jul 88 01:06:44 EDT        From: Scott.Fahlman@B.GP.CS.CMU.EDU        ....If we do it this way, we break no existing code....        You mean we break none of -your- existing code.  The only way to break no    existing code is to retain the unsatisfactory status quo.  Since CLtL is    not specific here, different implementations have resolved the ambiguity    in different ways, and if they are to be made all to work the same way,    some existing code will have to change.    Well, what I really meant was that we break no existing Common Lisp code,where by "Common Lisp" code I mean code written according to any reasonablystraightforward interpretation of what is in the manual.  It hadn'toccurred to me that you folks at Symbolics consider the system describeedby KMP to be in compliance with CLtL and not an extension -- a worthwhileextension and perhaps even a necessary extension, given the problems youwant to solve.  KMP did label his proposal a "change" rather than a"clarification", though I see that he claims in the discussion section thatit is technically in compliance with CLtL.  I have some doubts aboutthat claim, but let's not argue about that.So, as you say, some of us are going to have to fix some existing code ifwe try to standardize this situation.  If we have a way -- either a switchor a separate set of functions -- to select either canonicalizing orverbatim interpretations, whoever has to change his code can do so with asimple editor macro.So the only thing we're really fighting about is who gets the good functionnames or the default version of switchable functions.  I still think thatthe princple of least astonishment suggests that these field names ought tobe used verbatim unless the user specifically asks for canonicalization ofcase.  We can make it easy to ask for the canonicalizing behavior (myproposal 2 does that), but it shouldn't be the default.One other suggestion: Whether we go with KMP's proposal or something likemy proposal 2, I think that we should use all-lower-case to indicatecanonical case, and all-upper to indicate anti-canonical case.  As someonepointed out in an earlier message, this choice is arbitrary.  Other thingsbeing equal, we may as well go with the arbitrary choice Symbolics made,but other things are not equal.  Unix, the herpes of operating systems, isstill spreading and is going to be the file system most Lisps have to dealwith for at least the next 5 years, and probably 10.  Tops-20 is almostdead, and I don't know of any other default-upper-case file systems thatare on the rise, at least in the communities to whom Lisp is important.  Solet's make the choice that minimizes the number of people who have to typethings in a case that is the opposite from what they want.  Of course, thischoice breaks some existing code, but we've already agreed that that isnecessary.-- Scott*start*03600 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 13:03:58 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 21 Jul 88  13:01:43 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 21 Jul 88 16:00:21 EDTTo: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-reply-to: Your message of Thu, 21 Jul 88 11:23:00 -0400.             <19880721152341.2.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Thu, 21 Jul 88 16:00:02 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU            Date: Thu, 21 Jul 88 01:06:44 EDT        From: Scott.Fahlman@B.GP.CS.CMU.EDU        ....If we do it this way, we break no existing code....        You mean we break none of -your- existing code.  The only way to break no    existing code is to retain the unsatisfactory status quo.  Since CLtL is    not specific here, different implementations have resolved the ambiguity    in different ways, and if they are to be made all to work the same way,    some existing code will have to change.    Well, what I really meant was that we break no existing Common Lisp code,where by "Common Lisp" code I mean code written according to any reasonablystraightforward interpretation of what is in the manual.  It hadn'toccurred to me that you folks at Symbolics consider the system describeedby KMP to be in compliance with CLtL and not an extension -- a worthwhileextension and perhaps even a necessary extension, given the problems youwant to solve.  KMP did label his proposal a "change" rather than a"clarification", though I see that he claims in the discussion section thatit is technically in compliance with CLtL.  I have some doubts aboutthat claim, but let's not argue about that.So, as you say, some of us are going to have to fix some existing code ifwe try to standardize this situation.  If we have a way -- either a switchor a separate set of functions -- to select either canonicalizing orverbatim interpretations, whoever has to change his code can do so with asimple editor macro.So the only thing we're really fighting about is who gets the good functionnames or the default version of switchable functions.  I still think thatthe princple of least astonishment suggests that these field names ought tobe used verbatim unless the user specifically asks for canonicalization ofcase.  We can make it easy to ask for the canonicalizing behavior (myproposal 2 does that), but it shouldn't be the default.One other suggestion: Whether we go with KMP's proposal or something likemy proposal 2, I think that we should use all-lower-case to indicatecanonical case, and all-upper to indicate anti-canonical case.  As someonepointed out in an earlier message, this choice is arbitrary.  Other thingsbeing equal, we may as well go with the arbitrary choice Symbolics made,but other things are not equal.  Unix, the herpes of operating systems, isstill spreading and is going to be the file system most Lisps have to dealwith for at least the next 5 years, and probably 10.  Tops-20 is almostdead, and I don't know of any other default-upper-case file systems thatare on the rise, at least in the communities to whom Lisp is important.  Solet's make the choice that minimizes the number of people who have to typethings in a case that is the opposite from what they want.  Of course, thischoice breaks some existing code, but we've already agreed that that isnecessary.-- Scott*start*06530 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 14:18:59 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Jul 88  14:17:45 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 436759; Thu 21-Jul-88 17:16:58 EDTDate: Thu, 21 Jul 88 17:16 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) To: Scott.Fahlman@B.GP.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: The message of 21 Jul 88 16:00 EDT from Scott.Fahlman@B.GP.CS.CMU.EDUMessage-ID: <880721171622.0.KMP@PEWEE.SCRC.Symbolics.COM>    Date: Thu, 21 Jul 88 16:00:02 EDT    From: Scott.Fahlman@B.GP.CS.CMU.EDU    ... I still think that the principle of least astonishment suggests    that these field names ought to be used verbatim unless the user    specifically asks for canonicalization of case.  We can make it easy    to ask for the canonicalizing behavior (my proposal 2 does that), but    it shouldn't be the default.There's another theory that says that if he's going to be astonished,let it happen early. The stated purpose of CL is to provide for thedevelopment of portable programs. If you do a non-portable thing thatkinda feels right and implementations are encouraged to accept it withoutwarning and you have to know to say something magic to get somethingportable, then you don't have a portable language and you don't encourageportable programs.Consider that we could have had a :PORTABLE keyword argument on all functions. Any time you wanted to opt for portable behavior, you couldask for it. Then everyone could write (DEFUN FOO (X Y Z)   (* (+ X Y :PORTABLE T) Z :PORTABLE T))and when people didn't ask for portability, they wouldn't have to put upwith it. You'd get a lot jazzier functionality out of things, and peoplewould stop complaining about implementations that provided `gratuitousextra functionality' because that would be the encouraged thing. For example, (DEFUN FOO (X Y Z)   (* (+ X Y) Z))-- without the :PORTABLE T arguments -- could be a lot faster because thenyou could always use native arithmetic. Don't think there aren't CLimplementations which do almost just this (eg, they don't implement fixnums).Plenty of people find it unintuitive that in present-day CL (* (THE FIXNUM X) (THE FIXNUM Y))doesn't use a fixnum-multiply instruction (because you didn't typedeclare the return value) but we just went and defined it in a way that weknew it was important for it to work, even if it didn't come up too often.Sorry about those short-sighted who get confused but having the language bewell-defined in a portable way is just more important. Some people are mad,too, because they think they know the processor type they're on and knowwhat to expect from the fixnum-multiply instruction, but we've already madethe decision that supporting that activity just wasn't CL's priority.We invented CL just -exactly- to get away from nonsense where animplementor's interpretations were preferred over the needs of a community.The default just has to be the thing which promotes portable applications.If it's not, you can't test programs in one environment and have anyhope that it will therefore run in another.It's true that in general there is no reference implementation of CL,nor is one possible, and running your program in one implementation cannot be a guarantee that it will run in another, but that's nothing tocheer about. That's just a sad thing we should be trying to minimizerather than institutionalize.And you just never know when your company or university might fold,you might get tired of what you're doing and decide to move, or yourcompany might find itself on different hardware/os/file-system thanit ever thought possible ... and you might be happy you were made todesign in a feature that you never originally thought had a personalmeaning to you. [Certainly this happened to me when I moved from ITS/Tops-20 file servers at MIT to Lispm/VMS/Unix ones at Symbolics.]    ... Whether we go with KMP's proposal or something like my proposal 2,    I think that we should use all-lower-case to indicate canonical case,    and all-upper to indicate anti-canonical case. ...There are already several places where this arbitrary decision has beenmade in Lisp. The decision has been made consistently, and I think that'suseful. I would hate to go against the grain: * Uppercase is the canonical case for non-backslashed symbols seen by   the reader. eg, (symbol-name 'xyz) => "XYZ". (p168, p367, ...)  * Uppercase is the canonical case for dispatch readmacros. eg, the chars   received as arguments by # readmacro functions will have been upcased.   The "a" in #a will be seen by the function supporting #a as #\A, not   #\a. eg, see SET-DISPATCH-MACRO-CHARACTER (p364).  * Uppercase is the default case for the Lisp printer. The default value    of *PRINT-CASE* is :UPCASE (p372).You may be surprised to learn that I almost exclusively use file systemswhere lowercase or mixed case is culturally preferred. My intent here isnot to force people to use uppercase filenames, or to assert that usinguppercase as a canonical internal case is no problem when I have noexperience with it. I use it daily and can't recall any problem with usinguppercase because - the only situations where it comes up is when I'm dealing with things   I conceptualize as abstract primitives. I write (load "s:>kmp>foo.lisp")   or (load (make-pathname :name "FOO" :type :lisp)), depending on what is    appropriate for the application. - it really does feel consisent with the canonical case for other things   elsewhere in the language.You can make whatever arguments you want about the prevalence of Unix, butI don't think our language design has any business catering to a particularstyle. The argument we make for the choice of canonical case should bedefensible in the abstract.To me, the really compelling argument in this regard is the following: * Uppercase is the canonical case for spoken language.   this is not a syntactically well-formed english sentence.   THIS IS A SYNTACTICALLY WELL-FORMED ENGLISH SENTENCE.Compatible with Unix or not, this is at least a position which can be defendedin the abstract.*start*03235 00024 US Return-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 23 JUL 88 01:19:54 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa07572; 21 Jul 88 23:05 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Thu, 21 Jul 88 23:01:09 BSTMessage-Id: <11002.8807212201@subnode.aiai.ed.ac.uk>To: KMP@scrc-stony-brook.arpa, Moon@scrc-stony-brook.arpa, Scott.Fahlman@b.gp.cs.cmu.edu, masinter.paSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1)Cc: CL-Cleanup@sail.stanford.eduScott's porposals (1 and 2) for a :canonical-case keyword seem worthconsidering, but whether 1 or 2 is better is less clear.  I'm stillnot sure what anti-canonical accomplishes.  On a system that accptsonly one case, it can do nothing; on a system that accepts any case,why change case at all?  Why not use whatever the user provides?  Somecase will be more common, but if we're trying to ignore the details ofthe FS do we care?  OK, anti-canonical matters so I can still get thatcase if I want it, and pathnames need to be able to represent suchnamestrings.  2 then?I do think this goes back to a question of exactly what portibilitygain is involved.  I can see that the Symbolics system does a numberof useful things, but I'm not sure how much each individual thingdoes in isolation.Moreover, pathnames are not useless without this change.  They are amore sturctured representation than namestrings, and save one fromparsing.  Code that does not aspire to complete portability mightnonetheless use them.  There may also be code that wants to beportable to different Unix systems, say, where the case problem willnot arise, or between different common lisps that parse namestringsdifferently or single lisps that refuse to parse them "correctly"(Unix names like ".lisprc", say, want to be merge-pathname'd as namesnot types.)> Date: Wed, 20 Jul 88 18:32 EDT> From: "David A. Moon" <Moon@arpa.scrc-stony-brook>> The second comment is that it is in fact both possible and useful to> make pathnames themselves portable.  That would be the subject of a> separate proposal.  Again, this has been current practice in both> Symbolics and TI systems since before Common Lisp even existed, and> works quite well.  The interested reader can consult the documentation> of "logical pathnames" for either of those systems.Done.> Basically the idea is to have an imaginary file system that behaves in> the same way everywhere, and that puts files in the same place> everywhere.  Then at each location one defines a set of translationsIsn't this independent of pathnames per se?  (I.e., couldn't it bedone just by having a convention for namestrings?)And I still have difficulty imagining interesting things portableprograms can do without such a convention (apart from the thingspathnames already provide, such as parsing).  Or, perhaps I should sayI have difficulty imagining interesting things made possible by thecanonical case proposal.  I can easily see the virtues of canonicaltypes.  But the gain from having the case made magically right seemssmall.-- Jeff*start*02164 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 16:34:16 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 21 Jul 88  16:31:46 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 21 Jul 88 18:08:44 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-reply-to: Your message of Thu, 21 Jul 88 17:16:00 -0400.             <880721171622.0.KMP@PEWEE.SCRC.Symbolics.COM> Date: Thu, 21 Jul 88 18:08:29 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDULet me see if I understand the philosophy underlying your argument.  Itseems to go as follows:1. There are certain complex and difficult things that a Common Lispprogrammer must do in order to be sure that his code will be absolutelyportable across all known file systems, living and dead.2. Some people believe that they don't care about that kind of portability.If given a choice they will not worry about these painful and complexthings.3. *WE* know that this attitude is short-sighted, so we should try toremove the temptation to cut corners.  In this case, the best way to dothat is to make sure EVERYONE has to deal with these portability issues allthe time, whether they want to or not.4.  In the end, they'll thank us for saving them from their baserinstincts.-- or, more briefly --Nobody ever expects the Spanish Inquisition!!!Well, I've said my piece, and will abide by the decision of the committee.If you and Moon can persuade some of the non-Symbolics people on thecommittee that the good names should go to the portable case-bashingversions, I'll disagree, but I can live with it.-- ScottP. S.  I don't agree with your "really compelling argument" about naturallanguage.  I don't think that an all-upcase sentence is any moresyntactically correct than an all-lower-case one.  But that's notimportant, since your arguments about upper-case being the defaultelsehwere in the language is a pretty good one.*start*01657 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 15:38:01 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 21 Jul 88  15:37:00 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA00913; Thu, 21 Jul 88 18:35:01 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA03624; Thu, 21 Jul 88 18:38:31 EDTMessage-Id: <8807212238.AA03624@mist.UUCP>To: Kent M Pitman <KMP%STONY-BROOK.SCRC.Symbolics.COM@multimax.ARPA>Cc: CL-Cleanup%SAIL.STANFORD.EDU@multimax.ARPASubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-Reply-To: Your message of Thu, 21 Jul 88 17:16:00 -0400.             <880721171622.0.KMP@PEWEE.SCRC.Symbolics.COM> Date: Thu, 21 Jul 88 18:38:24 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>    Date: Thu, 21 Jul 88 17:16 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>            ... Whether we go with KMP's proposal or something like my proposal 2,        I think that we should use all-lower-case to indicate canonical case,        and all-upper to indicate anti-canonical case. ...        There are already several places where this arbitrary decision has been    made in Lisp. The decision has been made consistently, and I think that's    useful. I would hate to go against the grain:    I hate to agree with Kent here because I really prefer lower case foreverything possible, but he's right.  The decision to make uppercasethe default in Common Lisp was probably a mistake, but it's a mistakewe're stuck with.  Inconsistency is worse.*start*03714 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 21 JUL 88 15:45:11 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 436854; Thu 21-Jul-88 18:43:52 EDTDate: Thu, 21 Jul 88 18:43 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1)To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, Scott.Fahlman@b.gp.cs.cmu.edu, masinter.pa, CL-Cleanup@sail.stanford.eduIn-Reply-To: <11002.8807212201@subnode.aiai.ed.ac.uk>Message-ID: <880721184315.3.KMP@PEWEE.SCRC.Symbolics.COM>    Date: Thu, 21 Jul 88 23:01:09 BST    From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>    ... And I still have difficulty imagining interesting things portable    programs can do without such a convention (apart from the things    pathnames already provide, such as parsing).  Or, perhaps I should say    I have difficulty imagining interesting things made possible by the    canonical case proposal.  I can easily see the virtues of canonical    types.  But the gain from having the case made magically right seems    small. ...I'd wager that there is a sizable number of TOPS-20 users out there whodon't know that the TOPS-20 file system admits lowercase names. The onlytrouble is that to refer to such a filename in any of the normal TOPS-20programs, you have to quote every character with Control-V.Sure, you can say that (MAKE-PATHNAME :TYPE "foo" :VERSION "lisp") shouldjust create a file called "foo.lisp" on Unix and "foo.lisp" on TOPS-20 andthat should be fine for "portable" programs, but it's not because you haveto tell Emacs c-X c-F c-V f c-V o c-V o . c-V l c-V i c-V s c-V pevery time you want to edit the file. This is very unnatural even for peoplewho know it's what must be done. But for people who don't know it must bedone, they just wonder why "foo.lisp" shows up in their directory listingbut doesn't appear to be something they can edit or delete from outside ofLisp!The value you get from having canonical case is that files get created ina natural way on any operating system.It also turns out that this just makes file merging a lot simpler.Consider an operation I do a lot on a day-to-day basis, which takesadvantage of the canonical type and canonical case issues: Command: Copy File (from) MYUNIX:/foo/bar/zap.l (to) MY20: Copying MYUNIX:/foo/bar/zap.l to MY20:<FOO.BAR>ZAP.LSP.0rather than: Copying MYUNIX:/foo/bar/zap.l to MY20:<FOO.BAR>^Vz^Va^Vp.^Vl.0which we might have if neither of these proposals passed.Sure, you can say that the Copy File command could go to massively morework using system-dependent knowledge to do all the case foolery to getmachine-to-machine copying correct, but the fact of the matter is thatif all this stuff were defined correctly, you could write COPY-FILE innearly portable code (I say nearly only because I'm glossing byte-sizeissues, an orthogonal problem): (WITH-OPEN-FILE (FROM-STREAM FROM :DIRECTION :INPUT)   (WITH-OPEN-FILE (TO-STREAM (MERGE-PATHNAMES TO FROM)			      :DIRECTION :OUTPUT)     (STREAM-COPY-UNTIL-EOF FROM-STREAM TO-STREAM)))and everything else takes care of itself. You could also argue that thehair belongs in MERGE-PATHNAMES but why make work for yourself? Thereonly needs to be hair at all if you can't get agreement on some trivialissues, such as those on the floor. If we can just agree on thesedetails, then no programs will need to have any hair -- things willjust work out.*start*01585 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 22 JUL 88 06:43:01 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 22 Jul 88  06:42:03 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 22 Jul 88 09:40:55 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-reply-to: Your message of Thu, 21 Jul 88 17:16:00 -0400.             <880721171622.0.KMP@PEWEE.SCRC.Symbolics.COM> Date: Fri, 22 Jul 88 09:40:41 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUAfter sleeping on it, I've decided that my arguments against your "SpanishInquisition" philosophy, forcing users to do everything in a portable wayaaginst their will, were silly.  As you say, Common Lisp does indeed makepeople go the long way round in dozens of places in the language, all fortheir own good and for greater portability.The only difference here is that the need for porting code to filesystems of different case comes up much less often than other kinds ofporting issues, and many of us may never be faced with this; if we are,it's easy to find and fix the problems.  And I still think it's a confusingchoice to use the case of a field to signal how you want the case to bealtered, though perhaps not fatally confusing.  I retain a mild preferencefor giving the default names to the verbatim versions, but can live witheither choice.-- Scott*start*02435 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 22 JUL 88 10:03:10 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 22 Jul 88  10:00:32 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA26819; Fri, 22 Jul 88 11:00:09 MDTReceived: by cdr.utah.edu (5.54/utah-2.0-leaf)	id AA02396; Fri, 22 Jul 88 11:00:07 MDTFrom: sandra%cdr@cs.utah.edu (Sandra J Loosemore)Message-Id: <8807221700.AA02396@cdr.utah.edu>Date: Fri, 22 Jul 88 11:00:03 MDTSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1)To: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>Cc: cl-cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Fri, 1 Jul 88 19:57 EDTI don't like this proposal at all and agree with Fahlman that itshould definitely not be the default behavior.  I also believe thatthere are also so many other issues unresolved with MAKE-PATHNAME thatmake it practically impossible to use portably, that trying to deal withcase is rather pointless.  These other issues include:    - how long the strings for each of the components can be    - what characters are valid in each component string    - whether punctuation (such as the square brackets around the      directory specifications for VMS, or the dot before the file type)      must/can be included in the component string    - whether the implementation/operating system even supports the      concept for a particular component (e.g., devices on Unix,      directories on CTSS)These issues are handled differently even among different Lispsrunning under the same operating system.  As a result, I have avoidedusing MAKE-PATHNAME like the plague.  Instead, I use MERGE-PATHNAME tofiddle with pathname objects created by passing namestrings toPATHNAME.  If I must hard-wire namestrings into my code, it is withthe understanding that they are specific to a particular operatingsystem.  I assume that PATHNAME does any canonicalization of caseappropriate for that Lisp implementation and operating system.  Thisapproach has been working quite well for me and I would be contentto leave things as they are, perhaps adding only stronger wording inthe standard about how nonportable MAKE-PATHNAME is.  Or, perhapsMAKE-PATHNAME should be removed from the language entirely.-Sandra-------*start*01599 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 16:19:28 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 19 Sep 88  16:17:56 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 19 SEP 88 16:03:15 PDTDate: 19 Sep 88 16:01 PDTFrom: masinter.paSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1) In-reply-to: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Fri, 22 Jul 88 09:40:41 EDTTo: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880919-160315-2575@Xerox>This issue had  a flurry of discussion back in July, but I have no record of anytraffic since. As the issue says "This does not solve the whole pathname problem, but it doesimprove the situation for a clearly defined set of very common problems."Is it worth putting this requirement on PATHNAME implementations if it doesn'treally improve portability of real applications?My general experience is that even within a single application, users havedifficulty writing portable code because of a lack of "logical" pathnames --they write code that reads in files and data from servers that don't exist whenat the site to which the code is shipped. This stuff, about case, doesn't seemto have much real effect.The only examples in the issue writeup relate to multiple-file-system hostswhere the host file system conventions are visible to the Lisp itself.(Sometimes, the file access protocol itself will map file names into a 'native'naming convention before Lisp even sees it.)*start*01044 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 NOV 88 15:42:28 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Nov 88  15:39:19 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 NOV 88 15:12:52 PSTDate: 23 Nov 88 15:11 PSTFrom: masinter.paSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 1 Jul 88 19:57 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <881123-151252-13448@Xerox>I have 19 messages on this proposal since its submission; I think therewere several points made that would need to get folded into the discussionif we're going to be able to vote on this at this time.The likelihood is slim. I wanted to be explicit that this issue would not make it into the letterballot as far as I can tell, although it isn't dismissed...*start*09893 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 22-Mar-89 14:23:03 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 MAR 89 14:22:43 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Mar 89  14:01:14 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 563174; Wed 22-Mar-89 17:00:57 ESTDate: Wed, 22 Mar 89 17:00 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: **DRAFT** issue: PATHNAME-COMPONENT-CASE (Version 1)To: X3J13@SAIL.Stanford.EDUMessage-ID: <890322170040.4.KMP@BOBOLINK.SCRC.Symbolics.COM>    >>> PLEASE DO -NOT- REPLY TO THIS ISSUE NOW <<<At this point, probably no one will read what you would writeanyway.  Instead, think about the issue and organize your thoughtsfor in-person discussion at the meeting.There was a lot of discussion on this issue.  The Cleanup committee isnot in agreement on its disposition.  However, the issue is a real onethat we cannot afford to overlook.  See additional comments at the endfor a survey of points of contention. -kmp-----Issue:        PATHNAME-COMPONENT-CASEReferences:   Pathnames (pp410-413),	      MAKE-PATHNAME (p416),	      PATHNAME-HOST (p417),	      PATHNAME-DEVICE (p417),	      PATHNAME-DIRECTORY (p417),	      PATHNAME-NAME (p417),	      PATHNAME-TYPE (p417)Category:     CHANGEEdit history: 1-Jul-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  Issues of case in pathnames are a major source of problems.  In some file systems, the canonical case is lowercase, in some  uppercase, in some mixed.  In some file systems, case matters, in others it does not.  (NAMESTRING (MAKE-PATHNAME :NAME "FOO" :TYPE "LISP"))  will produce an `ugly' file name like "FOO.LISP" in many (but not all)  Common Lisp implementations talking to Unix, for example.  (NAMESTRING (MAKE-PATHNAME :NAME "foo" :TYPE "lisp"))  might produce an `ugly' file name like "^Vf^Vo^Vo.^Vl^Vi^Vs^Vp"  in a Common Lisp implementation talking to a Tops-20.  Problems like this make it difficult to use MAKE-PATHNAME for much of  anything without corrective (non-portable) code.  Other problems occur in merging because doing   (NAMESTRING (MERGE-PATHNAMES (MAKE-PATHNAME :HOST "MY-TOPS-20" :NAME "FOO")	                        (PARSE-NAMESTRING "MY-UNIX:x.lisp")))  should probably return "MY-TOPS-20:FOO.LISP" but in fact might return  "MY-TOPS-20:FOO.^Vl^Vi^Vs^Vp" in some implementations.  Problems like this make it difficult to use any merging primitives for  much of anything without corrective (non-portable code).Proposal (PATHNAME-COMPONENT-CASE:CANONICALIZE):  Designate a treatment for case in pathname components which is  distinct from the treatment of case in the namestrings. The treatment  should be invariant across operating systems.  If a string given to MAKE-PATHNAME, or returned by any of the  PATHNAME-xxx accessor operations, is all uppercase, it is said to  designate a name in the system's "canonical case".  If a string given to MAKE-PATHNAME, or returned by any of the  PATHNAME-xxx accessor operations, is all lowercase, it is said to  designate a name in the system's "anticanonical case".  If a string given to MAKE-PATHNAME, or returned by any of the  PATHNAME-xxx accessor operations, is mixed case, it is said  designate a name in exactly the indicated case.  Functions such as PARSE-NAMESTRING and NAMESTRING which convert  from or to native host syntax will perform any necessary conversions  from internal syntax.  Note: In fact, this proposal does not require an implementation to  change its internal representation. It only requires the CL-defined  accessors to behave as if the internal representation had been changed.  Whether the actual internal representation is changed is still up to an  implementation. A consequence of this is that if pathnames print   in a way that shows the components individually (such as #S), they  are not constrained to print the components in any particular case;  they are constrained only to have definite syntax conventions and to  be able to invert those conventions at the appropriate time. Any change  to the way pathnames print is beyond the scope of this proposal.Test Case:  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp"))    => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")) => "FOO"Rationale:  This does not solve the whole pathname problem, but it does improve  the situation for a clearly defined set of very common problems.Current Practice:  Symbolics Genera implements this behavior.Cost to Implementors:  While this proposal is compatible with CLtL, it may not be compatible with  the implementations of CLtL which some implementations have chosen.  It is possible to isolate the forced changes to the referenced functions  (MAKE-PATHNAME and the PATHNAME-xxx accessors). Existing functions can be  renamed, and new functions with the same name can be introduced which simply  encapsulate case conversion. No further change is forced.  It may, however, be desirable for an implementation to make a more complete  overhaul of their representation. In implementations where the implementors  feel a need to do this, the amount of work may be considerably greater.Cost to Users:  Technically, this change is upward compatible.  In fact, since the existing CLtL spec is so poor, nearly everyone relies  heavily on implementation-specific behavior since there is little other  choice. As such, any change is almost certain to break lots of programs,  in usually superficial but nevertheless important ways. However, if we  really make the pathname facility more portable, the user community may be  willing to bear the consequences of these changes.Cost of Non-Adoption:  We would be contributing to the perpetuation of the existing fiasco of a  pathname system.Benefits:  The major costs of non-adoption would be avoided.Aesthetics:  More code is required, but the code supports a simpler user model.  Anything that simplifies the user model of pathnames is going to be an  improvement.Discussion:  Pitman suports PATHNAME-COMPONENT-CASE:CANONICALIZE.-------------------------------------------------------------------There was a lot of debate internally on CL-Cleanup about this onewhich reached no resolution. Rather than include that discussion, Iwill sum up what I think are the main discussion points: - Uppercase was proposed as the canonical case because it seemed   most consistent with other parts of the language which are forced   to use a canonical case (such as symbol names and arguments to   macro character handlers).   Some people wish we would use lowercase because they think more   file systems are lowercase.   Note well that the choice of a case as the `canonical case'   internal to Lisp has no technical effect on your ability to   create filenames in upper, lower, or mixed case under this   proposal.  This argument is purely an aesthetic one.   The Symbolics file system (upon which this proposal is based)   uses lowercase as the preferred case, and yet the use of uppercase   canonical case has caused no serious technical problems in the   five or so years that we've field tested this appraoch in    an environment that depends critically on heavy use of a variety   of file systems from the same lisp image.  This is not a    pie-in-the-sky idea -- it is implemented and has stood the test of time. - This proposal suggests that functions like PATHNAME-NAME return   and that make-pathname accept strings which are in the interchange   (canonical) case rather than in the native file system case so that   pathname components can be retrieved from one pathname and stored   in a second without regard to whether those two pathnames agreed on   native case.   Some people suggested that PATHNAME-NAME and MAKE-PATHNAME should   work non-portably, using native case information, and that you should   have to do more work (e.g., supply a keyword argument) to get portable   code. This strikes me as incompatible with our goals but is technically   a possible position to take.   Others suggested that two sets of functions should be available --   one set for native case (e.g., MAKE-FILENAME, FILENAME-NAME, ...)   and one for portable case (e.g., MAKE-PATHNAME, PATHNAME-NAME, ...).   These would make the same kind of object -- they would just support   different views on the set of operations that you might want on the   object.  If you follow this approach, the issues become ``who gets   which names'' and ``does this make the language gratuitously bloated''?   Some people who wanted parallel paradigms (one for native case, one   for an interchange/canonical case) seemed to be willing to give up   that desire if the canonical case was coincidentally chosen to be the   same as the native case for the file system they worked with.   ``I'll compromise as long as I don't have to change.'' - Some people don't use multiple file systems in the same core image   and don't realize how critical an issue this is to those of use who do.THE BOTTOM LINE: Users deal with this problem day in and day out as they move back and forth between different systems.  The solution is within our grasp technically -- the key issues to be resolved are aesthetic and political, not technical.  In the end, users won't want to hear about the political roadblocks. They are trusting us to come up with a solution and we should come through. Please be prepared to come at this issue constructively. I thank you, and our users will ultimately thank you.*start*13650 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 22-Mar-89 20:49:59 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 MAR 89 20:49:54 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Mar 89  20:30:42 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 563397; Wed 22-Mar-89 23:30:16 ESTDate: Wed, 22 Mar 89 23:30 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-CASE (Version 2)To: X3J13@SAIL.STANFORD.EDUMessage-ID: <19890323043004.2.MOON@EUPHRATES.SCRC.Symbolics.COM>I updated and rewrote this issue based on the discussion last Summer andAutumn that followed the publication of version 1 within the cleanupcommittee.  Perhaps we can use this as the basis for a constructivediscussion and get this issue out of the way.This issue contains four alternative proposals.Issue:        PATHNAME-COMPONENT-CASEReferences:   Pathnames (pp410-413),              MAKE-PATHNAME (p416),              PATHNAME-HOST (p417),              PATHNAME-DEVICE (p417),              PATHNAME-DIRECTORY (p417),              PATHNAME-NAME (p417),              PATHNAME-TYPE (p417)Category:     CHANGEEdit history: 1-Jul-88, Version 1 by Pitman              22-Mar-89, Version 2 by Moon, update and rewriteStatus:       Trying to be ready for releaseProblem Description:  Issues of alphabetic case in pathnames are a major source of problems.  In some file systems, the customary case is lowercase, in some  uppercase, in some mixed.  In some file systems, case matters, in  others it does not.  There are two kinds of portability problems connected with case in  pathnames: moving programs from one Common Lisp to another, and moving  pathname component values from one file system to another.  To solve  the first problem, all Common Lisp implementations that support a  particular file system must use compatible representations for  pathname component values.  To solve the second problem, there must be  a canonical representation for pathname component values that means  the same thing on all file systems.  The desire for a canonical representation for pathname component  values directly conflicts with the desire among programmers who only  use one file system to work with the local conventions and not to  have to think about issues of porting to other file systems.  The  canonical representation cannot be the same as every local  convention, since they vary.  In the current anarchy of pathname component case conventions:    (NAMESTRING (MAKE-PATHNAME :NAME "FOO" :TYPE "LISP"))  will produce foo.lisp in some Unix Common Lisp implementations  and will produce FOO.LISP in other Unix Common Lisp implementations.  (NAMESTRING (MAKE-PATHNAME :NAME "foo" :TYPE "lisp"))  will produce FOO.LISP in some Tops-20 Common Lisp implementations  and will produce "^Vf^Vo^Vo.^Vl^Vi^Vs^Vp"in other Tops-20 Common  Lisp implementations.  Problems like this make it difficult to use MAKE-PATHNAME for much of  anything without corrective (non-portable) code.  Other problems occur in merging because doing   (NAMESTRING (MERGE-PATHNAMES (MAKE-PATHNAME :HOST "MY-TOPS-20" :NAME "FOO")                                (PARSE-NAMESTRING "MY-UNIX:x.lisp")))  should probably return "MY-TOPS-20:FOO.LISP" but in fact might return  "MY-TOPS-20:FOO.^Vl^Vi^Vs^Vp" in some implementations.  Problems like this make it difficult to use any merging primitives for  much of anything without corrective (non-portable) code.Proposal (PATHNAME-COMPONENT-CASE:CANONICALIZE):  Designate a treatment for case in pathname components which is  distinct from the treatment of case in the namestrings.  The treatment  should be invariant across operating systems.  Namestrings use local  file system case conventions, pathname components use common case  conventions.  Arbitrarily choose uppercase as the common (or universal) case.  If a string given to MAKE-PATHNAME, or returned by any of the  PATHNAME-xxx accessor operations, is all uppercase, it is said to  designate a name in the system's "canonical case".  If a string given to MAKE-PATHNAME, or returned by any of the  PATHNAME-xxx accessor operations, is all lowercase, it is said to  designate a name in the system's "anticanonical case".  If a string given to MAKE-PATHNAME, or returned by any of the  PATHNAME-xxx accessor operations, is mixed case, it is said to  designate a name in exactly the indicated case.  Functions such as PARSE-NAMESTRING and NAMESTRING which convert from  or to local file system syntax will perform any necessary conversions  between "canonical case" and the host's customary case, and between  "anticanonical case" and the opposite of the host's customary case.Proposal (PATHNAME-COMPONENT-CASE:NEW-COMMON-ACCESSORS):  Add new pathname component accessor functions that return values  translated to the common case defined above.  Use the local file  system case conventions in the existing pathname component accessor  functions.  The new accessors are named PATHNAME-COMMON-DEVICE,  PATHNAME-COMMON-DIRECTORY, PATHNAME-COMMON-NAME, and  PATHNAME-COMMON-TYPE.  Add new keyword arguments to MAKE-PATHNAME that accept values in the  the common case defined above and translate to the host's customary  case.  Use the local file system case conventions in the existing  keyword arguments to MAKE-PATHNAME.  The new keyword arguments are  named :COMMON-DEVICE, :COMMON-DIRECTORY, :COMMON-NAME, and  :COMMON-TYPE.Proposal (PATHNAME-COMPONENT-CASE:NEW-LOCAL-ACCESSORS):  Do everything proposed for PATHNAME-COMPONENT-CASE:CANONICALIZE,  and in addition:    Add new pathname component accessor functions that return values in  the local file system case conventions.  The new accessors are named  PATHNAME-LOCAL-DEVICE, PATHNAME-LOCAL-DIRECTORY, PATHNAME-LOCAL-NAME,  and PATHNAME-LOCAL-TYPE.  Add new keyword arguments to MAKE-PATHNAME that accept values in the  local file system case conventions.  The new keyword arguments are  named :LOCAL-DEVICE, :LOCAL-DIRECTORY, :LOCAL-NAME, and :LOCAL-TYPE.Proposal (PATHNAME-COMPONENT-CASE:KEYWORD-ARGUMENT):  Add a keyword argument :CASE to MAKE-PATHNAME and the PATHNAME-xxx  accessors, indicating whether common or local conventions should be  followed.  The possible values for the argument are :COMMON and  :LOCAL.  The default is :COMMON.Test Case:  Under PATHNAME-COMPONENT-CASE:CANONICALIZE:  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp"))    => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")) => "FOO"  Under PATHNAME-COMPONENT-CASE:NEW-COMMON-ACCESSORS:  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp"))    => "foo"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")) => "FOO"  (PATHNAME-COMMON-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp"))    => "FOO"  (PATHNAME-COMMON-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")) => "FOO"  Under PATHNAME-COMPONENT-CASE:NEW-LOCAL-ACCESSORS:  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp"))    => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")) => "FOO"  (PATHNAME-LOCAL-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp"))    => "foo"  (PATHNAME-LOCAL-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")) => "FOO"  Under PATHNAME-COMPONENT-CASE:KEYWORD-ARGUMENT:  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp")                 :CASE :COMMON)                                 => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")                 :CASE :COMMON)                                 => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp")                 :CASE :LOCAL)                                  => "foo"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")                 :CASE :LOCAL)                                  => "FOO"Rationale:  This does not solve the whole pathname problem, but it does improve  the situation for a clearly defined set of very common problems.  Together with the other pathname proposals, the behavior of pathnames  should be sufficiently consistent across Common Lisp implementations  and across file systems to allow portability of pathname-manipulating  programs.  Upper case is chosen as the canonical case for no better reason than  consistency with the canonical case for Lisp symbols.  PATHNAME-COMPONENT-CASE:CANONICALIZE minimizes the size of the  language by not adding any new functions.  It assumes that pathname  operations using local file system conventions can be performed on  namestrings and that anything that calls MAKE-PATHNAME or the  PATHNAME-xxx accessors is portable code that is independent of the  local file system conventions.  PATHNAME-COMPONENT-CASE:NEW-COMMON-ACCESSORS assumes that the existing  MAKE-PATHNAME and PATHNAME-xxx accessor features are for programs that  only work on one file system and that more generally portable programs  should use new features.  PATHNAME-COMPONENT-CASE:NEW-LOCAL-ACCESSORS assumes that the existing  MAKE-PATHNAME and PATHNAME-xxx accessor features are for fully  portable programs but that PATHNAME-COMPONENT-CASE:CANONICALIZE is  insufficient and direct access to the local conventions is required.  PATHNAME-COMPONENT-CASE:KEYWORD-ARGUMENT assumes that access to both  conventions is necessary but introducing more functions is bad.  The default convention is the common one, assuming that most  programs are fully portable.Note:  None of these proposals requires an implementation to change its  internal representation.  They only require the canonical accessors to  behave as if the internal representation had been changed.  Whether  the actual internal representation is changed is still up to an  implementation. A consequence of this is that if pathnames print in a  way that shows the components individually (such as #S), they are not  constrained to print the components in any particular case; they are  constrained only to have definite syntax conventions and to be able to  invert those conventions at the appropriate time. Any change to the  way pathnames print is beyond the scope of this proposal.  There should probably be a remark somewhere that says that portable  programs shouldn't expect to be able to create and/or access distinct  files whose pathname components differ only in case.Current Practice:  Symbolics Genera implements something resembling  PATHNAME-COMPONENT-CASE:NEW-LOCAL-ACCESSORS except that the names use  "raw" rather than "local".  The "raw" accessors are almost never used.  Symbolics Genera's own file system uses lower case as the customary  case, but transparent network access is available to file systems  using all known case conventions.  Many Common Lisp implementations that only deal with a single file  system implement something resembling  PATHNAME-COMPONENT-CASE:NEW-COMMON-ACCESSORS except without the  new accessors and keyword arguments.Cost to Implementors:  While all of these proposals are compatible with CLtL, since CLtL is  so vague, they are not likely to be compatible with the  implementations of CLtL which some implementations have chosen.  It is possible to isolate the forced changes to the referenced functions  (MAKE-PATHNAME and the PATHNAME-xxx accessors). Existing functions can be  renamed, and new functions with the same name can be introduced which simply  encapsulate case conversion. No further change is forced.  It may, however, be desirable for an implementation to make a more complete  overhaul of their representation. In implementations where the implementors  feel a need to do this, the amount of work may be considerably greater.Cost to Users:  Technically, this change is upward compatible.  In fact, since the existing CLtL spec is so poor, nearly everyone relies  heavily on implementation-specific behavior since there is little other  choice. As such, any change is almost certain to break lots of programs,  in usually superficial but nevertheless important ways. However, if we  really make the pathname facility more portable, the user community may be  willing to bear the consequences of these changes.Cost of Non-Adoption:  We would be contributing to the perpetuation of the existing fiasco of a  pathname system.Benefits:  The major costs of non-adoption would be avoided.Aesthetics:  More code is required, but the code supports a simpler user model.  Anything that simplifies the user model of pathnames is going to be an  improvement.Discussion:  Some people would rather use lowercase as the canonical case.  The  decision is essentially arbitrary.  Everywhere else in Common Lisp  where there is a canonical case, uppercase was chosen.  It has been proposed that the Common Lisp specification should include  specifications of the exact behavior of pathnames for several popular  operating systems, so that multiple implementations for those  operating systems would be compatible with each other.  This proposal  does not attempt to do that, only to establish the coherent framework  within which it would be done.  In PATHNAME-COMPONENT-CASE:KEYWORD-ARGUMENT, some people want the  default for :CASE to be :LOCAL instead of :COMMON.  I would have  written that up too, but I thought five proposals were too many.*start*01714 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-Mar-89 06:46:15 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 06:46:13 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 23 Mar 89  06:45:08 PSTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA00648; Thu, 23 Mar 89 07:45:05 -0700Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA12384; Thu, 23 Mar 89 07:44:50 -0700From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8903231444.AA12384@defun.utah.edu>Date: Thu, 23 Mar 89 07:44:49 MSTSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 2)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Wed, 22 Mar 89 23:30 EST[removed x3j13; added cl-cleanup]I don't really like any of these proposals.Proposal CANONICALIZE is broken because it doesn't provide any way tospecify that a pathname component should be in *exactly* the case youprovide (including all upper or all lower) on file systems thatsupport mixed case.Proposals NEW-COMMON-ACCESSORS and NEW-LOCAL-ACCESSORS add too manyfunctions to the language. Proposal KEYWORD-ARGUMENT is the least objectionable of the bunch, butI still don't like it.  I still claim that there is no portable way touse MAKE-PATHNAME (even if the problems with case are involved),because there are other problems with things like the lengths ofstrings and what characters are valid in the various pathname fieldson different file systems. -Sandra-------*start*01829 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-Mar-89 08:07:59 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 08:05:16 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 23 Mar 89  08:03:56 PSTReceived: from mist.encore.COM by multimax.encore.com with SMTP (5.61/25-eef)	id AA10286; Thu, 23 Mar 89 11:03:37 -0500Received: from localhost by mist. (4.0/SMI-4.0)	id AA04203; Thu, 23 Mar 89 11:05:32 ESTMessage-Id: <8903231605.AA04203@mist.>To: "sandra%defun@cs.utah.edu"@Multimax.encore.com (Sandra J Loosemore)Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 2) In-Reply-To: Your message of Thu, 23 Mar 89 07:44:49 -0700.             <8903231444.AA12384@defun.utah.edu> Date: Thu, 23 Mar 89 11:05:29 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    Date: Thu, 23 Mar 89 07:44:49 MST    Proposal KEYWORD-ARGUMENT is the least objectionable of the bunch, but    I still don't like it.  I still claim that there is no portable way to    use MAKE-PATHNAME (even if the problems with case are involved),    because there are other problems with things like the lengths of    strings and what characters are valid in the various pathname fields    on different file systems.     Are you saying that there is no portable way to make any desiredpathname or that even if you limit your program to a "portable" subsetof file names that there is no portable way to manipulate them.  Such a portable subset might be a single alphabetic case, digits, 0 or1 period, and no more than 14 characters total.  You might be able toadd underscore are well.*start*01899 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-Mar-89 08:27:53 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 08:22:43 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 23 Mar 89  08:20:42 PSTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA03358; Thu, 23 Mar 89 09:20:38 -0700Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA12460; Thu, 23 Mar 89 09:20:35 -0700From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8903231620.AA12460@defun.utah.edu>Date: Thu, 23 Mar 89 09:20:34 MSTSubject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 2) To: Dan L. Pierson <pierson@mist.encore.com>Cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: Dan L. Pierson <pierson@mist.encore.com>, Thu, 23 Mar 89 11:05:29 EST> Date: Thu, 23 Mar 89 11:05:29 EST> From: Dan L. Pierson <pierson@mist.encore.com>> > Are you saying that there is no portable way to make any desired> pathname or that even if you limit your program to a "portable" subset> of file names that there is no portable way to manipulate them.  > > Such a portable subset might be a single alphabetic case, digits, 0 or> 1 period, and no more than 14 characters total.  You might be able to> add underscore are well.Yup, that's what I'm saying.  We ran into this problem while trying toport PCLS to the Cray running CTSS a few years ago.  The file systemhad no concept of directories or file types, and file names wererestricted to 6 characters. Also, the Atari ST's file system (and MS-DOS also?) supports only1-character device names, 8-character file names and 3-character filetypes.  As I recall, IBM's VM/CMS (and I think MVS/TSO too) delimitsthe file name and file type with a space instead of a period.-Sandra-------*start*01466 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-Mar-89 09:25:51 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 09:20:26 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Mar 89  09:18:57 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 563625; Thu 23-Mar-89 12:18:26 ESTDate: Thu, 23 Mar 89 12:18 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-CASE (Version 2)To: Sandra J Loosemore <sandra%defun@CS.UTAH.EDU>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8903231444.AA12384@defun.utah.edu>Message-ID: <19890323171821.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 23 Mar 89 07:44:49 MST    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    I still claim that there is no portable way to    use MAKE-PATHNAME (even if the problems with case are involved),    because there are other problems with things like the lengths of    strings and what characters are valid in the various pathname fields    on different file systems. I think there is a big difference between "it is possible to writenon-portable programs using MAKE-PATHNAME" and "it is impossibleto write any useful portable programs using MAKE-PATHNAME."*start*01100 00024 US Date:  4 Apr 89 12:41 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: PATHNAME-COMPONENT-CASETo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-CASETo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:36:24 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:24:06 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571225; Tue 4-Apr-89 15:23:56 EDTOriginal-Date: Tue, 4 Apr 89 15:23 EDTMessage-ID: <890404152331.9.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis was identified as `important' and deferred tothe next meeting (with explicit exception to cut-offdate on 18-0 vote).*start*09518 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-May-89 10:15:18 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAY 89 10:15:19 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 23 May 89  10:13:09 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 599388; 23 May 89 13:14:50 EDTDate: Tue, 23 May 89 13:19 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-CASE (version 4)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19890523171914.3.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This issue is on the agenda for the June X3J13 meeting.  KMP and Ihave prepared a revised writeup which we think is ready for release.I'd like to distribute this to X3J13 as soon as discussion, if any,in the cleanup subcommittee is completed.Issue:        PATHNAME-COMPONENT-CASEReferences:   Pathnames (pp410-413),              MAKE-PATHNAME (p416),              PATHNAME-HOST (p417),              PATHNAME-DEVICE (p417),              PATHNAME-DIRECTORY (p417),              PATHNAME-NAME (p417),              PATHNAME-TYPE (p417)Related-issues: PATHNAME-WILD-TRANSLATECategory:     CHANGEEdit history: 1-Jul-88, Version 1 by Pitman              22-Mar-89, Version 2 by Moon, update and rewrite               9-May-89, Version 3 by Moon, remove alternate proposals               9-May-89, Version 4 by Moon, respond to discussion with KMPProblem Description:  Issues of alphabetic case in pathnames are a major source of problems.  In some file systems, the customary case is lowercase, in some uppercase,  in some mixed.  In some file systems, case matters, in others it does  not.  There are two kinds of pathname case portability problems: moving  programs from one Common Lisp to another, and moving pathname component  values from one file system to another.  To solve the first problem, all  Common Lisp implementations that support a particular file system must  use compatible representations for pathname component values.  To solve  the second problem, there must be a common representation for the least  common denominator pathname component values that exist on all  interesting file systems.  This desire for a common representation directly conflicts with the  desire among programmers who only use one file system to work with the  local conventions and not think about issues of porting to other file  systems.  The common representation cannot be the same as every local  convention, since they vary.  In the current anarchy of pathname component case conventions:    (NAMESTRING (MAKE-PATHNAME :NAME "FOO" :TYPE "LISP"))  will produce foo.lisp in some Unix Common Lisp implementations  and will produce FOO.LISP in other Unix Common Lisp implementations.  (NAMESTRING (MAKE-PATHNAME :NAME "foo" :TYPE "lisp"))  will produce FOO.LISP in some Tops-20 Common Lisp implementations  and will produce "^Vf^Vo^Vo.^Vl^Vi^Vs^Vp"in other Tops-20 Common  Lisp implementations.  Problems like this make it difficult to use MAKE-PATHNAME for much of  anything without corrective (non-portable) code.  Other problems occur in merging because doing   (NAMESTRING (MERGE-PATHNAMES (MAKE-PATHNAME :HOST "MY-TOPS-20" :NAME "FOO")                                (PARSE-NAMESTRING "MY-UNIX:x.lisp")))  should probably return "MY-TOPS-20:FOO.LISP" but in fact might return  "MY-TOPS-20:FOO.^Vl^Vi^Vs^Vp" in some implementations.  Problems like this make it difficult to use any merging primitives for  much of anything without corrective (non-portable) code.Proposal (PATHNAME-COMPONENT-CASE:KEYWORD-ARGUMENT):  Add a keyword argument :CASE to MAKE-PATHNAME, PATHNAME-HOST,  PATHNAME-DEVICE, PATHNAME-DIRECTORY, PATHNAME-NAME, and PATHNAME-TYPE.  The possible values for the argument are :COMMON and :LOCAL.  :LOCAL means strings input to MAKE-PATHNAME or output by PATHNAME-xxx  follow the local file system's conventions for alphabetic case.  :COMMON means those strings follow this common convention:    - all uppercase means to use a file system's customary case.    - all lowercase means to use the opposite of the customary case.    - mixed case represents itself.  The second and third bullets exist so that translation from local to  common and back to local is information-preserving.  The default is :COMMON.  Namestrings always use local file system case conventions.  MERGE-PATHNAMES and TRANSLATE-WILD-PATHNAME map customary case in the  input pathnames into customary case in the output pathname.Implications of the proposal:  Unix is case-sensitive and prefers lowercase, so it translates between  common and local by inverting the case of non-mixed-case strings.    Tops-20 is case-sensitive and prefers uppercase, so it uses identical  representations for common and local.  VAX/VMS is upper-case-only, so it translates common to local by upcasing,  and translates local to common with no change.  Macintosh is case-insensitive and prefers lowercase, so it translates  between common and local by inverting the case of non-mixed-case strings,  and ignores case in EQUAL of two pathnames.Test Case/Examples:  Under PATHNAME-COMPONENT-CASE:KEYWORD-ARGUMENT:  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp")                 :CASE :COMMON)                                 => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")                 :CASE :COMMON)                                 => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp")                 :CASE :LOCAL)                                  => "foo"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")                 :CASE :LOCAL)                                  => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/TeX.lisp")                 :CASE :COMMON)                                 => "TeX"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/TeX.lisp")                 :CASE :LOCAL)                                  => "TeX"  (NAMESTRING (MAKE-PATHNAME :HOST "MY-UNIX" :NAME "FOO"                             :CASE :COMMON)                     => "MY-UNIX:foo"Rationale:  This does not solve the whole pathname problem, but it does improve  the situation for a clearly defined set of very common problems.  Together with the other pathname proposals, the behavior of pathnames  should be sufficiently consistent across Common Lisp implementations  and across file systems to allow portability of pathname-manipulating  programs.  Upper case is chosen as the common case for no better reason than  consistency with Lisp symbols.  The :CASE keyword argument provides access to both common and local  conventions without introducing any new functions.  The default  convention is the common one, assuming that most programs are fully  portable and therefore :COMMON will be more frequently used.Current Practice:  There are no known implementations of exactly what is proposed.  Symbolics Genera uses common case normally, and provides a way to  access the local case (called "raw") that in practice is rarely used.  Symbolics Genera's own file system uses lower case as the customary  case, but transparent network access is available to file systems  using all known case conventions.  Several Common Lisp implementations behave as if :CASE :LOCAL was  specified (but accept no :CASE argument).Cost to Implementors:  The :CASE feature is easily added, but some implementations may have  to change the default behavior when :CASE is not specified.  No  implementation need change its internal representation, nor the way  pathnames print, just the interface functions listed above.Cost to Users:  Technically, this change is upward compatible.  In fact, since the existing CLtL spec is so poor, nearly everyone relies  heavily on implementation-specific behavior since there is little other  choice. As such, any change is almost certain to break lots of programs,  in usually superficial but nevertheless important ways. However, if we  really make the pathname facility more portable, the user community may  be willing to bear the consequences of these changes.Cost of Non-Adoption:  We would be contributing to the perpetuation of the existing fiasco of a  pathname system.Performance Impact:  None.Benefits:  One step closer to a usable pathname system.Aesthetics:  Anything that simplifies the user model of pathnames is an improvement.Discussion:  Some people would rather use lowercase as the common case.  The  decision is essentially arbitrary.  Everywhere else in Common Lisp  where case matters, uppercase was chosen.  It has been proposed that the Common Lisp specification should include  specifications of the exact behavior of pathnames for several popular  operating systems, so that multiple implementations for those  operating systems would be compatible with each other.  This proposal  does that for alphabetic case.  Some people want the default for :CASE to be :LOCAL instead of :COMMON.  See Rationale.  There should probably be a remark somewhere that says that portable  programs shouldn't expect to be able to create and/or access distinct  files whose pathname components differ only in case.*start*00961 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 24-May-89 11:01:39 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAY 89 10:15:45 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 24 May 89  10:13:21 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 600008; 24 May 89 13:14:55 EDTDate: Wed, 24 May 89 13:18 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-CASE (version 4)To: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19890523171914.3.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>Message-ID: <19890524171855.0.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This line  Related-issues: PATHNAME-WILD-TRANSLATEwas a typo.  The correct issue name is PATHNAME-WILD.Sorry about that.*start*01258 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 24-May-89 23:40:11 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAY 89 23:40:09 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 24 May 89  23:38:21 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 24 MAY 89 23:34:28 PDTDate: 24 May 89 23:34 PDTFrom: masinter.paSubject: Re: Issue: PATHNAME-COMPONENT-CASE (version 4)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 23 May 89 13:19 EDTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@sail.stanford.eduMessage-ID: <890524-233428-10964@Xerox>The problem description is convincing. I'm still not personally convincedthat this is the "best" solution to the problem, or that all aspects of theproblem are as bad as others.I think it is intolerable that different implementations talk about the*same* file system in different ways.  I'm less certain that making thingsportable across Tops-20 and Unix and DOS is as important, and warrents theextra mechanism of additional keywords & arguments. However, I don't feeltoo strongly about it.*start*01778 00024 UU?GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 25-May-89 12:51:20 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAY 89 12:51:08 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 25 May 89  12:48:57 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 600738; 25 May 89 12:04:22 EDTDate: Thu, 25 May 89 12:08 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-CASE (version 4), PATHNAME-COMPONENT-VALUE (version 2)To: CL-Cleanup@sail.stanford.eduIn-Reply-To: <890524-233428-10964@Xerox>Message-ID: <19890525160824.7.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>    Date: 24 May 89 23:34 PDT    From: masinter.pa@Xerox.COM    I think it is intolerable that different implementations talk about the    *same* file system in different ways.I agree.  I think PATHNAME-COMPONENT-VALUE is actually the right issuein which to discuss that, although there is certainly much interactionwith other pathname issues, but if we proceed assuming that they pass,we should be able to prescribe exact pathname component values for atleast the key file systems MS/DOS, Macintosh, Unix, and VAX/VMS.  I wouldbe more than willing to add to the proposal specific prescriptions for thepathname component values in particular operating systems, except thatI cannot write this by myself.  If some other members of the cleanup committee will volunteer to help for particular systems, I will mail outnext week a draft writeup, or at least a framework, which they can thencorrect.  How does that sound?*start*04143 00024 UU?GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 25-May-89 11:12:09 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAY 89 11:10:54 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 25 May 89  11:08:50 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA11153; Thu, 25 May 89 12:09:05 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA09121; Thu, 25 May 89 12:09:01 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8905251809.AA09121@defun.utah.edu>Date: Thu, 25 May 89 12:08:59 MDTSubject: Re: Issue: PATHNAME-COMPONENT-CASE (version 4)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@sail.stanford.edu, sandra%defun@cs.utah.edu, gray@dsg.csc.ti.comIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Tue, 23 May 89 13:19 EDTI have a number of comments on this writeup, and some general commentson the issue it's trying to deal with.First the specific ones.>  Issues of alphabetic case in pathnames are a major source of problems.I'd say it's a much less "major" source of problems than issuesrelating to what characters may appear in pathname components and thelength of various components.>   There are two kinds of pathname case portability problems: moving>   programs from one Common Lisp to another, and moving pathname component>   values from one file system to another.  To solve the first problem, all>   Common Lisp implementations that support a particular file system must>   use compatible representations for pathname component values.  To solve>   the second problem, there must be a common representation for the least>   common denominator pathname component values that exist on all>   interesting file systems.Since this proposal doesn't do either of these two things, I don't understand what this paragraph is doing in this writeup.>   :COMMON means those strings follow this common convention:>     - all uppercase means to use a file system's customary case.>     - all lowercase means to use the opposite of the customary case.>     - mixed case represents itself.>   The second and third bullets exist so that translation from local to>   common and back to local is information-preserving.I don't understand the motivation for this.  There is no way tospecify a pathname component that is literally all uppercase or alllowercase.>   VAX/VMS is upper-case-only, so it translates common to local by upcasing,>   and translates local to common with no change.VAX/VMS is case-insensitive but its canonical case is uppercase.  Itsfile system primitives are perfectly capable of dealing with lowercasenamestrings -- it's just that if you ever ask it for the name of afile, it will return it in uppercase.Now for the more general comments.  I think that the :CASE :COMMONoption is pretty much useless because it doesn't handle the situationwhere you want the pathname component kept in exactly the case youspecified it.  I can't imagine any reason why I would want to specifya pathname component in the *opposite* of canonical case, plus if Idid I could get it by inverting the canonical case. I'd suggest trashing the current proposal and instead adding a:CANONICALIZE keyword argument to MAKE-PATHNAME and PARSE-NAMESTRING. A value of T indicates that the implementation is free to canonicalizethe representation of the pathname component in any way that isappropriate for the particular host.  This might include things liketruncation and performing some kind of filtering or translation oninvalid characters, and even expansion of logical names (on VMS), aswell as case conversion. A value of NIL indicates that the pathname components are to betreated as literals.  I think it would be a good idea to require anerror to be signalled in situations where a component is not alegitimate value. I think implementations should be permitted to assign meanings forother values of this argument. -Sandra-------*start*07160 00024 UU?GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 25-May-89 12:51:43 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAY 89 12:51:34 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 25 May 89  12:49:25 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 600887; 25 May 89 14:50:34 EDTDate: Thu, 25 May 89 14:54 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-CASE (version 4)To: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: CL-Cleanup@sail.stanford.edu, gray@dsg.csc.ti.comIn-Reply-To: <8905251809.AA09121@defun.utah.edu>Message-ID: <19890525185426.6.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>    Date: Thu, 25 May 89 12:08:59 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    I have a number of comments on this writeup, and some general comments    on the issue it's trying to deal with.    First the specific ones.    >  Issues of alphabetic case in pathnames are a major source of problems.    I'd say it's a much less "major" source of problems than issues    relating to what characters may appear in pathname components and the    length of various components.Let's not quibble about this, it's unproductive.    >   There are two kinds of pathname case portability problems: moving    >   programs from one Common Lisp to another, and moving pathname component    >   values from one file system to another.  To solve the first problem, all    >   Common Lisp implementations that support a particular file system must    >   use compatible representations for pathname component values.  To solve    >   the second problem, there must be a common representation for the least    >   common denominator pathname component values that exist on all    >   interesting file systems.    Since this proposal doesn't do either of these two things, I don't     understand what this paragraph is doing in this writeup.This proposal does the alphabetic case portion of both things.  Do youthink it doesn't?  Or are you saying that you would prefer to see all thepathname issues rolled into one omnibus proposal?  I was hesitant aboutnot allowing people the chance to vote separately on each portion of thepathname stuff.    >   :COMMON means those strings follow this common convention:    >     - all uppercase means to use a file system's customary case.    >     - all lowercase means to use the opposite of the customary case.    >     - mixed case represents itself.    >   The second and third bullets exist so that translation from local to    >   common and back to local is information-preserving.    I don't understand the motivation for this.  There is no way to    specify a pathname component that is literally all uppercase or all    lowercase.That is correct, in the :COMMON representation there is no way to saythose things.  That's because those are not portable concepts.  You usethe :LOCAL representation to do things like that.Things would be a lot simpler if :COMMON representation was monocase,which is the least common denominator.  The problem with that would bethat in some file systems (e.g. Unix) there would be many pathnamesthat could not be represented in :COMMON representation at all.  Ratherthan signal an error when such a pathname is encountered, it seems betterto assign otherwise unused characters (the lowercase letters) to representsuch pathnames.  Perhaps the proposal should be reworked to present thingsin these terms?    >   VAX/VMS is upper-case-only, so it translates common to local by upcasing,    >   and translates local to common with no change.    VAX/VMS is case-insensitive but its canonical case is uppercase.  Its    file system primitives are perfectly capable of dealing with lowercase    namestrings -- it's just that if you ever ask it for the name of a    file, it will return it in uppercase.That's precisely what upper-case-only means.  Sorry about theterminological unclarity.  Upper-case-only wasn't intended to meanthat it signals an error if you give it a lowercase letter; I don'tthink we want any file systems like that in Common Lisp; if the filesystem doesn't upcase, the Lisp interface to it should, rather thansignalling an error if it can't handle lower case.  Should I augmentthe proposal with more definitions of terminology?Note how VAX/VMS differs from other case-insensitive systems suchas the Macintosh, where file lookup is case-insensitive but if youask for the name of a file it will give it back in the same alphabeticcase in which you created it.    Now for the more general comments.  I think that the :CASE :COMMON    option is pretty much useless because it doesn't handle the situation    where you want the pathname component kept in exactly the case you    specified it.  That's what :CASE :LOCAL is for.  :CASE :COMMON is for portable programsthat want to conform to the local conventions of the local file systemrather than imposing their own conventions.  Not all programs want to dothat, but I would hardly characterize that as useless.		   I can't imagine any reason why I would want to specify    a pathname component in the *opposite* of canonical case, plus if I    did I could get it by inverting the canonical case. I can't imagine any reason either.  See above for the motivation for this.    I'd suggest trashing the current proposal and instead adding a    :CANONICALIZE keyword argument to MAKE-PATHNAME and PARSE-NAMESTRING.     A value of T indicates that the implementation is free to canonicalize    the representation of the pathname component in any way that is    appropriate for the particular host.  This might include things like    truncation and performing some kind of filtering or translation on    invalid characters, and even expansion of logical names (on VMS), as    well as case conversion.     A value of NIL indicates that the pathname components are to be    treated as literals.  I think it would be a good idea to require an    error to be signalled in situations where a component is not a    legitimate value.     I think implementations should be permitted to assign meanings for    other values of this argument. This could be a useful feature in its own right, but note that it isno help at all for retrieving pathname components in a form that isindependent of the local file system, which is what the :CASE argumentto the PATHNAME-xxx accessors proposed here is for.  I would encourageyou to write up your proposal in more detail.  I think you will findsome difficulties in defining exactly what is an invalid character(for example, is a character invalid if this file system uses it asa wildcard character but other file systems use it as an ordinarycharacter?) and some of the other specifics.  Also it would be helpfulto see your proposal complete with rationale, examples, costs, andbenefits.*start*03306 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 25-May-89 15:59:02 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAY 89 15:58:59 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 25 May 89  15:56:21 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA02018; Thu, 25 May 89 16:56:37 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA09378; Thu, 25 May 89 16:56:35 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8905252256.AA09378@defun.utah.edu>Date: Thu, 25 May 89 16:56:34 MDTSubject: Re: Issue: PATHNAME-COMPONENT-CASE (version 4)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: Sandra J Loosemore <sandra%defun@cs.utah.edu>, CL-Cleanup@sail.stanford.edu, gray@dsg.csc.ti.comIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Thu, 25 May 89 14:54 EDT> Date: Thu, 25 May 89 14:54 EDT> From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>> >     I don't understand the motivation for this.  There is no way to>     specify a pathname component that is literally all uppercase or all>     lowercase.> > That is correct, in the :COMMON representation there is no way to say> those things.  That's because those are not portable concepts.  You use> the :LOCAL representation to do things like that.Have I misunderstood the proposal?  I thought that the :LOCAL optionwas supposed to indicate that the implementations should do whatevercase conversion that's appropriate for the local file systemregardless of the original case.  If it's not supposed to do anytranslation at all, perhaps it ought to be renamed to :NONE orsomething more obvious. > :CASE :COMMON is for portable programs that want to conform to the local > conventions of the local file system rather than imposing their own > conventions.To me, it still seems like the decision is whether to canonicalize thecase or not, and that having the decision also depend on the case ofcharacters within the string is only needless complexity.  Iunderstand your argument about the monocase pathnames, but I don'tthink there's anything wrong with case canonicalization making somefilenames inaccessible.  You simply specify that you don't want tocanonicalize the filename in such a situation.> This could be a useful feature in its own right, but note that it is> no help at all for retrieving pathname components in a form that is> independent of the local file system, which is what the :CASE argument> to the PATHNAME-xxx accessors proposed here is for.I guess I'm confused about what problem this proposal is really tryingto address.  Originally I thought that this proposal was just tryingto specify a mechanism for controlling whether the case of pathnamesare canonicalized, but now it looks like what you really want is someway for pathnames to "remember" their original case even after they'vebeen canonicalized, so that when you extract the components and plugthem into some other pathname, you can get the original case back ifyou ask for it.  I just don't see how this is going to make it possibleto use MAKE-PATHNAME in a portable way.-Sandra-------*start*01318 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 13-Jun-89 15:21:29 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JUN 89 15:21:33 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 13 Jun 89  15:20:08 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 610813; 13 Jun 89 18:21:56 EDTDate: Tue, 13 Jun 89 18:21 EDTFrom: Kim Barrett <IIM@ECLA.USC.EDU>Sender: KMP@STONY-BROOK.SCRC.Symbolics.COMSubject: Issue: PATHNAME-COMPONENT-CASE (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUComments: Received from Kim Barrett by KMP on MSDOS floppy disk via US MailMessage-ID: <19890613222146.6.KMP@BOBOLINK.SCRC.Symbolics.COM>I had one person here who's initial reaction was against :COMMON as the default:CASE, but I think it's the right thing.  At first I thought that perhaps the:COMMON convention was backward, but after reviewing the file systems I'veencountered, I agree that the choice is pretty much arbitrary, and consistencywith Lisp symbols is as good a reason for choosing a direction on this as any.(Of course, the READ-CASE proposal might change this argument out from under.)*start*09818 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Jun-89 22:54:26 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 JUN 89 22:54:24 PDTReceived: from VALLECITO.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 16 Jun 89  22:38:34 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by VALLECITO.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 296248; Sat 17-Jun-89 01:09:50 EDTDate: Sat, 17 Jun 89 01:08 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Reply-To: CL-Cleanup@sail.stanford.eduSubject: Issue: PATHNAME-COMPONENT-CASE (version 5)To: X3J13@sail.stanford.eduMessage-ID: <19890617050833.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Issue:        PATHNAME-COMPONENT-CASEReferences:   Pathnames (pp410-413),              MAKE-PATHNAME (p416),              PATHNAME-HOST (p417),              PATHNAME-DEVICE (p417),              PATHNAME-DIRECTORY (p417),              PATHNAME-NAME (p417),              PATHNAME-TYPE (p417)Related-issues: PATHNAME-WILDCategory:     CHANGEEdit history: 1-Jul-88, Version 1 by Pitman              22-Mar-89, Version 2 by Moon, update and rewrite               9-May-89, Version 3 by Moon, remove alternate proposals               9-May-89, Version 4 by Moon, respond to discussion with KMP              17-Jun-89, Version 5 by Moon, fix typo, make minor improvements 			to the presentation.Problem Description:  Issues of alphabetic case in pathnames are a major source of problems.  In some file systems, the customary case is lowercase, in some uppercase,  in some mixed.  In some file systems, case matters, in others it does  not.  There are two kinds of pathname case portability problems: moving  programs from one Common Lisp to another, and moving pathname component  values from one file system to another.  To solve the first problem, all  Common Lisp implementations that support a particular file system must  use compatible representations for pathname component values.  To solve  the second problem, there must be a common representation for the least  common denominator pathname component values that exist on all  interesting file systems.  This desire for a common representation directly conflicts with the  desire among programmers who only use one file system to work with the  local conventions and not think about issues of porting to other file  systems.  The common representation cannot be the same as every local  convention, since they vary.  In the current anarchy of pathname component case conventions:    (NAMESTRING (MAKE-PATHNAME :NAME "FOO" :TYPE "LISP"))  will produce foo.lisp in some Unix Common Lisp implementations  and will produce FOO.LISP in other Unix Common Lisp implementations.  (NAMESTRING (MAKE-PATHNAME :NAME "foo" :TYPE "lisp"))  will produce FOO.LISP in some Tops-20 Common Lisp implementations  and will produce "^Vf^Vo^Vo.^Vl^Vi^Vs^Vp"in other Tops-20 Common  Lisp implementations.  Problems like this make it difficult to use MAKE-PATHNAME for much of  anything without corrective (non-portable) code.  Other problems occur in merging because doing   (NAMESTRING (MERGE-PATHNAMES (MAKE-PATHNAME :HOST "MY-TOPS-20" :NAME "FOO")                                (PARSE-NAMESTRING "MY-UNIX:x.lisp")))  should probably return "MY-TOPS-20:FOO.LISP" but in fact might return  "MY-TOPS-20:FOO.^Vl^Vi^Vs^Vp" in some implementations.  Problems like this make it difficult to use any merging primitives for  much of anything without corrective (non-portable) code.Proposal (PATHNAME-COMPONENT-CASE:KEYWORD-ARGUMENT):  Add a keyword argument :CASE to MAKE-PATHNAME, PATHNAME-HOST,  PATHNAME-DEVICE, PATHNAME-DIRECTORY, PATHNAME-NAME, and PATHNAME-TYPE.  The possible values for the argument are :COMMON and :LOCAL.  :LOCAL means strings input to MAKE-PATHNAME or output by PATHNAME-xxx  follow the local file system's conventions for alphabetic case.  Strings given to MAKE-PATHNAME will be used exactly as written if  the file system supports both cases.  If the file system only  supports one case, the strings will be translated to that case.  :COMMON means strings input to MAKE-PATHNAME or output by PATHNAME-xxx  follow this common convention:    - all uppercase means to use a file system's customary case.    - all lowercase means to use the opposite of the customary case.    - mixed case represents itself.  The second and third bullets exist so that translation from local to  common and back to local is information-preserving.  The default is :COMMON.  Namestrings always use local file system case conventions.  MERGE-PATHNAMES and TRANSLATE-WILD-PATHNAME map customary case in the  input pathnames into customary case in the output pathname.Implications of the proposal:  Unix is case-sensitive and prefers lowercase, so it translates between  common and local by inverting the case of non-mixed-case strings.    Tops-20 is case-sensitive and prefers uppercase, so it uses identical  representations for common and local.  VAX/VMS is upper-case-only (that is, the file system translates all file  name arguments to upper case), so it translates common to local by  upcasing, and translates local to common with no change.  Macintosh is case-insensitive and prefers lowercase, so it translates  between common and local by inverting the case of non-mixed-case strings,  and ignores case in EQUAL of two pathnames.Test Case/Examples:  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp")                 :CASE :COMMON)                                 => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")                 :CASE :COMMON)                                 => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/foo.lisp")                 :CASE :LOCAL)                                  => "foo"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-TOPS-20:<ME>FOO.LISP")                 :CASE :LOCAL)                                  => "FOO"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/TeX.lisp")                 :CASE :COMMON)                                 => "TeX"  (PATHNAME-NAME (PARSE-NAMESTRING "MY-UNIX:/me/TeX.lisp")                 :CASE :LOCAL)                                  => "TeX"  (NAMESTRING (MAKE-PATHNAME :HOST "MY-UNIX" :NAME "FOO"                             :CASE :COMMON)                     => "MY-UNIX:foo"Rationale:  This does not solve the whole pathname problem, but it does improve  the situation for a clearly defined set of very common problems.  Together with the other pathname proposals, the behavior of pathnames  should be sufficiently consistent across Common Lisp implementations  and across file systems to allow portability of pathname-manipulating  programs.  The current situation where different implementations talk about  the *same* file system in different ways will be corrected by this  and some of the other pathname proposals.  Upper case is chosen as the common case for no better reason than  consistency with Lisp symbols.  The :CASE keyword argument provides access to both common and local  conventions without introducing any new functions.  The default  convention is the common one, assuming that most programs are fully  portable and therefore :COMMON will be more frequently used.Current Practice:  There are no known implementations of exactly what is proposed.  Symbolics Genera uses common case normally, and provides a way to  access the local case (called "raw") that in practice is rarely used.  Symbolics Genera's own file system is case-insensitive and uses lower  case as the customary case, but transparent network access is available  to file systems using all known case conventions.  Several Common Lisp implementations behave as if :CASE :LOCAL was  specified (but accept no :CASE argument).Cost to Implementors:  The :CASE feature is easily added, but some implementations may have  to change the default behavior when :CASE is not specified.  No  implementation need change its internal representation, nor the way  pathnames print, just the interface functions listed above.Cost to Users:  Technically, this change is upward compatible.  In fact, since the existing CLtL spec is so poor, nearly everyone relies  heavily on implementation-specific behavior since there is little other  choice. As such, any change is almost certain to break lots of programs,  in usually superficial but nevertheless important ways. However, if we  really make the pathname facility more portable, the user community may  be willing to bear the consequences of these changes.Cost of Non-Adoption:  We would be contributing to the perpetuation of the existing fiasco of a  pathname system.Performance Impact:  None.Benefits:  One step closer to a usable pathname system.Aesthetics:  Anything that simplifies the user model of pathnames is an improvement.Discussion:  Some people would rather use lowercase as the common case.  The  decision is essentially arbitrary.  Everywhere else in Common Lisp  where case matters, uppercase was chosen.  It has been proposed that the Common Lisp specification should include  specifications of the exact behavior of pathnames for several popular  operating systems, so that multiple implementations for those  operating systems would be compatible with each other.  This proposal  does that for alphabetic case.  Some people want the default for :CASE to be :LOCAL instead of :COMMON.  See Rationale.  There should probably be a remark somewhere that says that portable  programs shouldn't expect to be able to create and/or access distinct  files whose pathname components differ only in case.