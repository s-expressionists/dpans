*start*05759 00024 US eturn-Path: <@SAIL.STANFORD.EDU:TOURETZKY@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 04 FEB 87 21:37:39 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 4 Feb 87  21:31:02 PSTReceived: ID <TOURETZKY@C.CS.CMU.EDU>; Thu 5 Feb 87 00:31:34-ESTDate: Thu, 5 Feb 87 00:31:33 ESTFrom: Dave.Touretzky@C.CS.CMU.EDUSubject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSTo: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <12276526020.28.TOURETZKY@C.CS.CMU.EDU>Issue:  SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReference:  Chapter 14 (Sequences) of CLtL.  Also, page 51 (COERCE).Description: Common Lisp provides many useful operations on lists and vectorswhich ought also to apply to arrays.  For example, one can FILL a vector with0's, but not an array.  One can REPLACE the contents of one vector withanother, but one can't do this for arrays.  One can verify that EVERY elementof a vector has some property, but one can't do this for arrays.  And so on.The programmer who wishes to use arrays instead of vectors must give up all theuseful tools CLtL provides for manipulating sequences, even though there is nointuitive reason why operations like FILL, REPLACE, and EVERY shouldn't work onarrays.  The designers of Common Lisp may have felt that there was no clear wayto consistently extend sequence functions to cover arrays.  In this note Ipropose a very low cost, uniform extension that solves this problem.Category:  Enhancement.Proposal:  SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:TREAT-ARRAYS-AS-DISPLACED-VECTORSCommon Lisp already provides a facility called "displaced arrays" which can beused to overlay one array on top of a portion of another, even if the two areof different ranks, so that the two share storage.  I propose the following:built in functions that take an argument of type "sequence" (the functions inchapter 14 of CLtL), and that could sensiby be applied to arrays, should beextended to handle arrays by treating them as displaced vectors.  There arethree cases to consider.  Suppose A is a 3x2x7 vector.Case I: sequence functions whose results aren't sequences, or whose results areEQ to their input.  LENGTH, ELT, COUNT, FIND, POSITION, SOME, EVERY, NOTANY,NOTEVERY, REDUCE, SEARCH, MISMATCH, FILL, REPLACE, NSUBSTITUTE, NREVERSE, SORT.All of these would be extended to access array elements as if they wereaccessing a vector displaced to that array.  For example, (LENGTH A) shouldreturn 42, and (ELT A 7) should return A[0,1,0].  :START and :END keywordswould be interpreted relative to the vector, as would the results returned byPOSITION and SEARCH.  Note that simply extending LENGTH, ELT, and the SETFexpander for ELT would have the side effect of extending the remainingfunctions in this list, assuming they're written in the obvious way.Case II: sequence functions whose result should be the same shape as but notnecessarily EQ to their argument.  There are just three of these: SUBSTITUTE,REVERSE, and MAP.  Actually, MAP should be able to return any shape arraythe user wants.  All three functions could be defined in terms of anextended MAKE-SEQUENCE function -- see below.Case III: sequence functions that cannot return results that are the same shapeas their arguments when their arguments are arrays.  SUBSEQ, COPY-SEQ,CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.These functions should remain undefined for arrays.Also, COERCE should be modified so that it can coerce arrays to vectors andvice versa.  In keeping with p.51 of CLtL, it should be an error if the resulttype has a different number of elements than the object being coerced.  AndMAKE-SEQUENCE should be modified to accept array descriptions as well as vectordescriptions.  Then a SUBSTITUTE function that worked for arrays could bewritten as follows:  (defun substitute (new-item old-item sequence &key ...)    (let ((result (make-sequence (type-of sequence))))      (dotimes (i (length sequence) result)        (setf (elt result i) (if (eql (elt sequence i) old-item) new-item                                 (elt sequence i))))))Note that EQUALP should not treat arrays as vectors.  It is not a sequencefunction, and it already has a well-defined behavior for arrays.  To testwhether the arrays A and B, of different shapes, have the same elements, onewould write (AND (= (LENGTH A) (LENGTH B)) (EVERY #'EQL A B)).Rationale: <a> This proposal would expand rather than interfere with existing practice. <b> Since displaced arrays are already part of Common Lisp, the cost of theproposed change would be very low. <c> If the change is not adopted, Common Lisp programmers who wish to usearrays will have two choices.  Either they must write nested DO loops everytime they want to perform an array operation equivalent to FILL, REPLACE,REDUCE, etc., or else they can build displaced vectors by hand and pass them tothe sequence functions when necessary.  I have been using the latter approachin my applications code, but I really dislike it. <d> This change is entirely upward compatible.  Existing code will runwithout modification. <e> Esthetics: this proposal extends sequence functions to cover arrays whileneatly avoiding the temptation to turn Common Lisp into a half-baked APL.Instead of trying to provide a full set of array handling primitives (whichwould be needed to take arbitrary k-dimensional slices out of n-dimensionalarrays, or to apply an operator across a specific dimension of amultidimensional array), it requires just one rule: treat arrays as displacedvectors.  The sequence functions become more useful, their behavior remainsintuitive, and the cost of the extension is very low.-------*start*11974 00024 USfReturn-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 APR 87 11:18:12 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 28 Apr 87  11:13:54 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 126277; Tue 28-Apr-87 14:13:26 EDTDate: Tue, 28 Apr 87 14:13 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 2)To: CL-Cleanup@SAIL.STANFORD.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COMReferences: <12276526020.28.TOURETZKY@C.CS.CMU.EDU>,            <870315-164404-1975@Xerox>Message-ID: <870428141313.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReferences:   Sequences (pp245-261), COERCE (p51)Category:     ENHANCEMENTEdit history: 05-Feb-87, Version 1 by Touretzky	      28-Apr-87, Version 2 by Pitman (variations on the theme)Status:	      For Internal DiscussionDescription:  Common Lisp provides many useful operations on lists and vectors which  don't apply to arrays.  For example, one can FILL a vector with 0's, but not an array. One can  REPLACE the contents of one vector with another, but one can't do this  for arrays.  One can verify that EVERY element of a vector has some   property, but one can't do this for arrays. And so on.  The programmer who wishes to use arrays instead of vectors must give up  most of the useful tools CLtL provides for manipulating sequences, even  though there is no intuitive reason why operations like FILL, REPLACE,  and EVERY shouldn't work on arrays.Notes about Voting:  Select one of:    SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE (by Touretzky)    SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:MODIFIED   (by Pitman)    SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:UNCHANGED  (status quo)  [See also notes in the discussion about the possibility of a fourth   way to go if you're not satisfied with any of these.]Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE):  Common Lisp already provides a facility called "displaced arrays"  which can be used to overlay one array on top of a portion of another,  even if the two are of different ranks, so that the two share storage.  Emphasize this as a way of explaining the behavior of sequence   functions on arbitrary arrays.  Modify the definition of COERCE to allow the coercion of an array to  a vector and vice versa. In keeping with p51 of CLtL, it should be an  error if the result type has a different number of elements than the  object being coerced.  Modify the definition of MAKE-SEQUENCE to accept array descriptions as  well as vector descriptions.  Extend the definitions of sequence functions that either return their  argument sequences or return non-sequences so that they also allow arrays.  These functions should treat array arguments as vectors displaced to the  array storage (in row-major format). The affected functions are LENGTH,  ELT, COUNT, FIND, POSITION, SOME, EVERY, NOTANY, NOTEVERY, REDUCE,   SEARCH, MISMATCH, FILL, REPLACE, NSUBSTITUTE, NREVERSE, SORT.  For example, suppose A is a 3x2x7 array. (LENGTH A) should return 42,  and (ELT A 7) should return A[0,1,0].  :START and :END keywords would  be interpreted relative to the vector, as would the results returned  by POSITION and SEARCH.  Extend the definitions of sequence functions whose result should be the  same shape as but not necessarily EQ to some argument. These functions  should deal with array arguments by returning an array of the same  shape. The affected functions are SUBSTITUTE, REVERSE, and MAP.  Expressly forbid arrays as arguments to sequence functions that modify  the number of elements in the array because the shape would be undefined.  These functions are SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE,  REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.  Note that EQUALP does -not- treat arrays as vectors.  It is not a   sequence function, and it already has a well-defined behavior for arrays.  To test whether the arrays A and B, of different shapes, have the same  elements, one would write:	(AND (= (LENGTH A) (LENGTH B)) (EVERY #'EQL A B)).  Rationale:      This proposal would expand rather than interfere with existing practice.      Since displaced arrays are already part of Common Lisp, the cost of the    proposed changes would be very low.      If the change is not adopted, Common Lisp programmers who wish to use    arrays will have two choices.  Either they must write nested DO loops    every time they want to perform an array operation equivalent to FILL,    REPLACE, REDUCE, etc., or else they can build displaced vectors by    hand and pass them to the sequence functions when necessary.    Adoption Cost:      This would involve a lot of changes to functions, but all of them    presumably minor. The presence of displaced arrays in the language    already guarantees that the internal storage format needed to back    up these proposed changes is already in place.      Note that simply extending COERCE, MAKE-SEQUENCE, LENGTH, ELT, and    the SETF expander for ELT would have the side effect of extending    the remaining functions if they are written in the obvious way.    For example:  	  (DEFUN SUBSTITUTE (NEW-ITEM OLD-ITEM SEQUENCE &KEY ...)	    (LET ((RESULT (MAKE-SEQUENCE (TYPE-OF SEQUENCE))))	      (DOTIMES (I (LENGTH SEQUENCE) RESULT)		(SETF (ELT RESULT I)		      (IF (EQL (ELT SEQUENCE I) OLD-ITEM) 			  NEW-ITEM			  (ELT SEQUENCE I))))))    Benefits:      Users of arrays do not have to use home-grown utilities to duplicate    functionality already primitively provided to users of arrays. The    sequence functions become useful in a variety of new situations.    Conversion Cost:      This change is `upward compatible.' User code should run unmodified.    Aesthetics:      This proposal extends sequence functions to cover arrays while neatly    avoiding the temptation to turn Common Lisp into a half-baked APL.    Instead of trying to provide a full set of array handling primitives    (which would be needed to take arbitrary k-dimensional slices out of     n-dimensional arrays, or to apply an operator across a specific    dimension of a multidimensional array), it requires just one rule:    treat arrays as displaced vectors.  Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:MODIFIED):  Common Lisp already provides a facility called "displaced arrays"  which can be used to overlay one array on top of a portion of another,  even if the two are of different ranks, so that the two share storage.  Emphasize this as a way of explaining the behavior of sequence   functions on certain arrays.  Modify the definition of COERCE to allow the coercion of an array to  a vector and vice versa. In keeping with p51 of CLtL, it should be an  error if the result type has a different number of elements than the  object being coerced.  Extend the definitions of sequence functions that either return their  argument sequences, return sequences which are the same shape as their  argument, or return non-sequences so that they also allow arrays iff  their action is conceptually independent of the shape of the array.  The affected functions are COUNT, SOME, EVERY, NOTANY, NOTEVERY,  FILL, REPLACE, SUBSTITUTE, NSUBSTITUTE, and MAP.  Expressly forbid arrays as arguments to other sequence functions. These  unaffected functions are LENGTH, ELT, FIND, POSITION, REDUCE, SEARCH,  MISMATCH, REVERSE, NREVERSE, SORT, MAP, SUBSEQ, COPY-SEQ, CONCATENATE,  MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.  Rationale:      This proposal would expand rather than interfere with existing practice.      Since displaced arrays are already part of Common Lisp, the cost of the    proposed changes would be very low.      If the change is not adopted, Common Lisp programmers who wish to use    arrays will have two choices.  Either they must write nested DO loops    every time they want to perform an array operation equivalent to FILL,    REPLACE, etc., or else they can build displaced vectors by hand and    pass them to the sequence functions when necessary.      This proposal extends certain sequence functions in some interesting    ways without committing us to a theory of how arrays and sequences    relate that everyone may not be happy with right now.  Adoption Cost:      This would involve a lot of changes to functions, but all of them    presumably minor. The presence of displaced arrays in the language    already guarantees that the internal storage format needed to back    up these proposed changes is already in place.    Benefits:      Users of arrays do not have to use home-grown utilities to duplicate    functionality already primitively provided to users of arrays. The    sequence functions become useful in a variety of new situations.    Conversion Cost:      This change is `upward compatible.' User code should run unmodified.    Aesthetics:      This extends certain existing sequence functions to allow arrays    as arguments in a fairly non-controversial way, leaving aside the    larger issue of whether and how to generalize the other sequence    functions.  Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:UNCHANGED):  This is the null proposal for the sake of voting clarity. Vote for this  if you think things should not change.Current Practice:  Neither SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE nor  SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:MODIFIED are likely to be implemented  anywhere since they are only very recently proposed.Discussion:  Touretzky supports SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE.  He's been building displaced vectors to pass to sequence functions when  necessary and really dislikes it.  The members of the Cleanup committee expressed interest in the ideas   behind this proposal but weren't sure they could accept it in the  proposed form. A rewrite to separate some of the issues more clearly  was solicited.  Rees suggested that if people are not sure about this a proposal, it might  be possible to make fly a modified version of the proposal which extended  only those functions which did not deal with positional information.  Pitman wrote SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:MODIFIED based on this idea  and supports at least that much extension, and is sympathetic to (but not  yet fully committed to the idea of the full proposal).  Note that in the SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:MODIFIED proposal,  the function REDUCE is in a grey area. Many of its uses are not  position-dependent, but some are. The same argument might be made about  FIND. If people felt strongly, these too could be extended either by  fudging the conservative rule or by explicit special case(s).  [It's also possible that a still-more-general proposal might be   interesting. For example, one that introduced and inverse to    ARRAY-ROW-MAJOR-INDEX called ARROW-ROW-MAJOR-SUBSCRIPTS, and have   functions like POSITION that returned position information or things   that take :START and :END arguments use subscript (rather than offset)   information. eg,    (SETQ A (MAKE-ARRAY '(2 2) :INITIAL-ELEMENT 0))    (SETF (AREF A 1 0) '1)    (POSITION 1 A) => (1 0) ;Rather than 2 as suggested above   This might ease some people's minds if they're just worried that   returning a 1-d index will feel funny for an any-d array. On the   other hand, the linear ordering must still be well defined so it'll   be clear what the search order is, what range is being selected when   :START and/or :END is used, etc. so you can't hide the issue   completely. Still, if anyone's interested in a full-blown proposal   along these lines, they should ask me and I'll write it. --KMP]*start*01766 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 30 APR 87 18:21:01 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 30 Apr 87  18:18:19 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 30 APR 87 16:46:05 PDTDate: 30 Apr 87 16:48 PDTFrom: Masinter.paSubject: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 2)To: cl-cleanup@sail.stanford.edu, Dave.Touretzky@C.CS.CMU.EDUMessage-ID: <870430-164605-4496@Xerox>fyi, this is the reaction from our local array expert...     ----- Begin Forwarded Messages -----Date: 30 Apr 87 15:07 PDTFrom: Pedersen.paSubject: Re: [Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>:SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 2)]In-reply-to: Masinter.pa's message of 30 Apr 87 14:17 PDTTo: Masinter.pacc: pedersen.pa	Don't really like either proposal -- because they seem like hacksrather than a serious approach to the problem. Also, Common Lisp isalready over-bloated, it just doesn't need creeping featurism -- butrather a trimming down. After all -- these proposals simply relieve theuser of the very minor chore of making displaced arrays for the rareinstances where that is the natural thing to do -- no real value isadded, but there is a cost in complexity, and possibly performance.	The truth is that if you really want to do multi-dimensioned arraymanipulation, you really do want something like APL, or close to it.Implementing an array calculus -- like APL -- is quite doable (I havesomething close to that floating around), and is the right way to go forheavy array users, but I don't think that functionality needs to bebuilt into the language.					J.P.     ----- End Forwarded Messages -----*start*01722 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 02 MAY 87 12:23:08 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 2 May 87  12:20:46 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sat 2 May 87 15:21:49-EDTDate: Sat, 2 May 87 15:21 EDTMessage-ID: <FAHLMAN.12299221539.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: CL-Cleanup@SAIL.STANFORD.EDUSubject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 2)In-reply-to: Msg of 28 Apr 1987  14:13-EDT from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>I have no strong opinion on this proposal.  It doesn't look to me likeit would add much confusion, it wouldn't be too hard to implement, andapparently some people would find it useful.  So I guess I'm mildly infavor of either the GENERALIZE or the MODIFIED version.I would not like to see this leave committee in the current format.Maybe KMP, Touretzky, Rees, and anyone else who cares can work out asingle proposal that they all like.  The paths not taken can bementioned in the discussion section.I would like to encourage KMP to go ahead with a separate proposal forROW-MAJOR-SUBSCRIPTS (or whatever we end up calling it).  Given that, Ithink a version of POSITION that returns a single number for arrays isprobably the way to go, and users can then turn this into a subscriptlist if they like.  I have a mild aversion to getting a list from somefunction that has heretofore always returned a number or NIL.In choosing issues to introduce in the future, we probably should leantoward doing clarifications first and saving extension for later.-- Scott*start*02102 00024 USaDate:  5 May 87 14:14 PDTFrom: pedersen.paSubject: Re: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 2)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 1 May 87 19:56 EDTTo: KMP@STONY-BROOK.SCRC.Symbolics.COMcc: Masinter.pa, cl-cleanup@sail.stanford.edu, Dave.Touretzky@C.CS.CMU.EDU, Pedersen.paPitman: 	"Actually, I bet some people don't ever used displaced-arrays because	they seem like excess hair and/or because the side-effect consequences	are hard to learn about. ... Displaced arrays may be taught in some thorough	courses and one or two advanced books, but I bet are largely overlooked...	Not to mention the fact that they inherently seem to violate an	abstraction and some people might avoid them because of some feel that	programs which use them are not clean."I find a certain inconsistency in your argument that constructing displaced-arrays is obtuse and unesthetic, while at the same time stating that multi-dimensional arrays are naturally operated on as vectors with elements laid out in row-major order. After all, displaced-arrays are the only mechanism in common lisp that allows one to adopt that view, and as such are indispensible. Indeed, one might argue that for the inexperienced Lisp user, who has some knowledge of "C" or "FORTRAN", displaced-arrays map directly into conventional use of pointers into arrays.On a more constructive note -- it seems like a small addition to the array mechanism might address most of our concerns. Consider:(defun flatten-array (array) 	(cond ((vectorp array) array)		((arrayp array) 			(make-array (array-total-size array) 				:element-type (array-element-type array)				:displaced-to array))		(t (error "Not an array: ~s" array))))then "flatten-array" may be used in combination with sequence functions to achieve the desired semantics, and would have the advantage of making clear the intention of a code fragment. A primitive like "flatten-array" is useful in other contexts as well, and would complement a "row-major-aref" primitive.							J.P.*start*06407 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 01 MAY 87 16:58:28 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 130001; Fri 1-May-87 19:56:58 EDTDate: Fri, 1 May 87 19:56 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 2)To: Masinter.pacc: cl-cleanup@sail.stanford.edu, Dave.Touretzky@C.CS.CMU.EDU, Pedersen.paIn-Reply-To: <870430-164605-4496@Xerox>Message-ID: <870501195646.5.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 30 Apr 87 16:48 PDT    From: Masinter.pa@Xerox.COM    fyi, this is the reaction from our local array expert...    ...    Date: 30 Apr 87 15:07 PDT    From: Pedersen.pa    ... they seem like hacks rather than a serious approach to    the problem. ...My guess is that it looks hackish more from a historical perspectivethan it would if you just saw a new edition of the manual that didn'trefer to these as sequence functions. Surely if you were just told fromscratch that arrays were valid arguments to MAP or COUNT, you wouldn'thave thought it even remotely hackish. You'd likely say: "Of course."I think your view may be skewed by feeling like we'll still have a sequencefunctions chapter that will say "Oh, by the way, as a special case, MAPand count will treat arrays as sequences displaced to their storage."The argument about displacement is the rationale for the argument (andfor why it won't be efficient) more than advice for how the result mightbe presented in the manual.    Pedersen: ... these proposals simply relieve the user of the very     minor chore of making displaced arrays for the rare instances where    that is the natural thing to do -- no real value is added, ...Actually, I bet some people don't ever used displaced-arrays becausethey seem like excess hair and/or because the side-effect consequencesare hard to learn about. RPLACA and RPLACD are hard to learn, but theyare taught about in lots of classes and lots of books so peopleeventually catch on.  Displaced arrays may be taught in some thoroughcourses and one or two advanced books, but I bet are largely overlooked.Not to mention the fact that they inherently seem to violate anabstraction and some people might avoid them because of some feel thatprograms which use them are not clean.  On the other hand, there'snothing even remotely unclean about using an operator like MAP or COUNTon an array if that operator is willing to do the work for you. It'snot the machine instructions that count, it's what the program has tosay in order to make the machine instructions get executed that's ofinterest.    Pedersen: ... but there is a cost in complexity, ...I'd find it easier to remember a rule saying that "SUBSTITUTE does top-level substitution in aggregate quantities" than one that says"SUBSTITUTE does top-level substitution in vectors" because"aggregate quantities" is a natural concept that I've been dealingwith for much longer than programming and "vector" is a domain specialized (and in this case very arbitrary) restriction on thatnatural concept. I'd consider it a simplification if SUBSTITUTE workedon arrays.    Pedersen: ... and possibly performance. ...I bet the performance hit is not remarkably large... * I'd think compilers which can optimize these function calls   based on declarations could optimize this new case just as easily. * Some implementations do microcode dispatch, so they don't have to   worry. Of the others, though, I'd bet most do a sequential type   dispatch that falls through to an error clause. If you put the   general array case right before the error clause, it's not costing   anyone but the people who want it (because they have to wade through   the other cases). * Even so, since it's a constant-time operation to do this algorithm   selection and since all of these operations involve loops, the   performance hit even if you took one would be likely to get lost   in the dust. * Touretzky effectively argues that there may be a speed improvement   because you can just check for type ARRAY and not check that it's   only a 1d array and go straight to business playing with its    elements. In some cases, this can speed things up by making it   possible to remove code that did what he is suggesting are   "gratuitous" error checks.    Pedersen: ... The truth is that if you really want to do     multi-dimensioned array manipulation, you really do want something    like APL, or close to it. Implementing an array calculus -- like APL    -- is quite doable ... and is the right way to go for heavy array users ...    Well, of course, Touretzky says outright in the proposal that he realizesthis is a harder problem and that he doubts that we would be interested in solving that, but that the solution to the simpler problem would besignificantly interesting to him certainly and perhaps to others (a claim that I think he gives a credible case for).Moreover, the more interesting case is for people who are -not- heavyarray users. They just have one array and they're in some place where theywant to count certain elements. Having to write a routine to do this candistract from the true purpose of the function, which may be unrelatedto the array issue.I was recently looking back over a lot of old Maclisp code I wrotearound 1979-80. I was struck by the number of times I'd written utilityfunctions that got used only once -- many things that now are (fortunately)available in the system. Getting up to a conversational level with Lisptook most of the effort -- the programs were trivial by modern standards.I had friends who wrote shorter (but I'd say less intelligible) programswhere they didn't take the time to abstract things out and so in themiddle of some program there'd be a couple of nested DO loops taking theMAX of something which was not very relevant in the grand scale of things,but which took up a lot of syntactic space.I think it's reasonable for us to consider minor extensions that aidthis end of just making certain utilities be common so that they needn'tbe written be written time and time again unnecessarily. I think this iswhat Common Lisp is about.*start*01280 00024 US Return-Path: <@SAIL.STANFORD.EDU:gls@Think.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 MAY 87 13:00:34 PDTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 12 May 87  12:57:56 PDTReceived: from boethius by Think.COM via CHAOS; Tue, 12 May 87 15:59:54 EDTDate: Tue, 12 May 87 15:59 EDTFrom: Guy Steele <gls@Think.COM>Subject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 2)To: Fahlman@c.cs.cmu.edu, CL-Cleanup@sail.stanford.eduIn-Reply-To: <FAHLMAN.12299221539.BABYL@C.CS.CMU.EDU>Message-Id: <870512155947.2.GLS@BOETHIUS.THINK.COM>    Date: Sat, 2 May 1987  15:21 EDT    From: "Scott E. Fahlman" <Fahlman@c.cs.cmu.edu>    ...    I would like to encourage KMP to go ahead with a separate proposal for    ROW-MAJOR-SUBSCRIPTS (or whatever we end up calling it).  Given that, I    think a version of POSITION that returns a single number for arrays is    probably the way to go, and users can then turn this into a subscript    list if they like.  I have a mild aversion to getting a list from some    function that has heretofore always returned a number or NIL.In this instance, note that a NIL result could be confused with anempty list of subscripts, the natural result in the case of azero-dimensional array.--Guy*start*01333 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 MAY 87 21:25:17 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 12 May 87  21:24:37 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 138606; Wed 13-May-87 00:23:14 EDTDate: Wed, 13 May 87 00:23 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 2)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <870428141313.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <870513002305.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Observation: some of the discussion appears to be assuming thatsomeone is proposing that  (position 3 #2a((0 1 2)(3 4 5))) => (1 0)As far as I can tell no one is proposing that.  My reading ofSEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE (by Touretzky)is that it proposes  (position 3 #2a((0 1 2)(3 4 5))) => 3and the other two options propose that it remains an error.Vote: I mildly favor SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:UNCHANGED asbeing the least confusing to users, although either of the other twoproposals would be okay with me: if there is strong support for them,I won't expend energy resisting it.*start*07719 00024 USfDate: 26 Oct 87 16:27 PSTFrom: Masinter.paSubject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 3)To: CL-Cleanup@SAIL.STANFORD.EDUcc: Masinter, PedersenLine-fold: 80There's been no mail on this topic since May.  My reading of the mail at that time was that most folks were lukewarm; I've tried to capture that in the discussion section below.  I've rewritten this proposal to include the GENERALIZE option and the watered down version in the discussion. I'm not sure that is right. Oh well --- progress. Usual caveats apply.Has anyone had any new thoughts on this topic since May?Issue:        SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReferences:   Sequences (pp245-261), COERCE (p51)Category:     ENHANCEMENTEdit history: 05-Feb-87, Version 1 by Touretzky              28-Apr-87, Version 2 by Pitman (variations on the theme)              26-Oct-87, Version 3 by Masinter (clean up for release)Description:Common Lisp provides many useful operations on lists and vectors which don't apply to arrays.For example, one can FILL a vector with 0's, but not an array. One can REPLACE the contents of one vector with another, but one can't do this for arrays.  One can verify that EVERY element of a vector has some property, but one can't do this for arrays, and so on.The programmer who wishes to use arrays instead of vectors must give up most of the useful tools CLtL provides for manipulating sequences, even though there is no intuitive reason why operations like FILL, REPLACE, and EVERY shouldn't work on arrays.Common Lisp already provides a facility called "displaced arrays" which can be used to overlay one array on top of a portion of another, even if the two are of different ranks, so that the two share storage or use the awkward convention of creating a displaced array to the operand. However, creating a displaced array merely to perform FILL, REPLACE or EVERY is awkward.Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE):1) Modify the definition of COERCE to allow the coercion of an array to a vector and vice versa. In keeping with p51 of CLtL, it should be an error if the result type has a different number of elements than the object being coerced.2) Modify the definition of MAKE-SEQUENCE to accept array descriptions as well as vector descriptions.3) Extend the definitions of sequence functions that either return their argument sequences or return non-sequences so that they also allow arrays. These functions should treat array arguments as vectors displaced to the array storage (in row-major format). The affected functions are LENGTH, ELT, COUNT, FIND, POSITION, SOME, EVERY, NOTANY, NOTEVERY, REDUCE, SEARCH, MISMATCH, FILL, REPLACE, NSUBSTITUTE, NREVERSE, SORT.For example, suppose A is a 3x2x7 array. (LENGTH A) should return 42, and (ELT A 7) should return the same element as (AREF A 0 1 0).  :START and :END keywords would be interpreted relative to the vector, as would the results returned by POSITION and SEARCH.Extend the definitions of sequence functions whose result should be the same shape as but not necessarily EQ to some argument. These functions should deal with array arguments by returning an array of the same shape. The affected functions are SUBSTITUTE, REVERSE, and MAP.Expressly forbid arrays as arguments to sequence functions that modify the number of elements in the array because the shape would be undefined. These functions are SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.Note that EQUALP does -not- treat arrays as vectors.  It is not a sequence function, and it already has a well-defined behavior for arrays. To test whether the arrays A and B, of different shapes, have the same elements, one would write:	(AND (= (LENGTH A) (LENGTH B)) (EVERY #'EQL A B)).Rationale:  This proposal would expand rather than interfere with existing practice.  Since displaced arrays are already part of Common Lisp, the cost of the proposed changes would be very low.  If the change is not adopted, Common Lisp programmers who wish to use arrays will have two choices.  Either they must write nested DO loops every time they want to perform an array operation equivalent to FILL, REPLACE, REDUCE, etc., or else they can build displaced vectors by hand and pass them to the sequence functions when necessary.  Adoption Cost:  This would involve a lot of changes to functions, but all of them presumably minor. The presence of displaced arrays in the language already guarantees that the internal storage format needed to back up these proposed changes is already in place.  Note that simply extending COERCE, MAKE-SEQUENCE, LENGTH, ELT, and the SETF expander for ELT would have the side effect of extending the remaining functions if they are written in the obvious way.For example:  (DEFUN SUBSTITUTE (NEW-ITEM OLD-ITEM SEQUENCE &KEY ...)    (LET ((RESULT (MAKE-SEQUENCE (TYPE-OF SEQUENCE))))     (DOTIMES (I (LENGTH SEQUENCE) RESULT)	 (SETF (ELT RESULT I)	       (IF (EQL (ELT SEQUENCE I) OLD-ITEM) 	 	   NEW-ITEM		   (ELT SEQUENCE I))))))  Benefits:  Users of arrays do not have to use home-grown utilities to duplicate functionality already primitively provided to users of arrays. The sequence functions become useful in a variety of new situations.  Conversion Cost:  This change is `upward compatible.' User code should run unmodified.  Aesthetics:  This proposal extends sequence functions to cover arrays while neatly avoiding the temptation to turn Common Lisp into a half-baked APL. Instead of trying to provide a full set of array handling primitives (which would be needed to take arbitrary k-dimensional slices out of n-dimensional arrays, or to apply an operator across a specific dimension of a multidimensional array), it requires just one rule:    treat arrays as displaced vectors.Current Practice:This is unlikely to be implemented anywhere since it has  only very recently been proposed. Discussion: This issue was discussed by the cleanup committee at length; this is only a brief summary of the discussion.An alternative considered was to only affect those functions which didn't explicitly depend on the shape of the array; that is, to modify  COUNT, SOME, EVERY, NOTANY, NOTEVERY, FILL, REPLACE, SUBSTITUTE, NSUBSTITUTE, and MAP, and expressly forbid arrays as arguments to other sequence functions, including LENGTH, ELT, FIND, POSITION, REDUCE, SEARCH,  MISMATCH, REVERSE, NREVERSE, SORT, MAP, as well as SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES. This would be less controversial, since it includes only those functions which do not deal with positional information. Some hedging over REDUCE and FIND, which often have non-positional uses, were considered.Touretzky supports SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE. He's been building displaced vectors to pass to sequence functions when necessary and really dislikes it.We considered but discarded as unworkable an alternative where POSITION and FIND might deal with "positions" as lists of array subscripts.Another alternative considered would be to only adopt the COERCE change, and require users who want to operate on arrays explictly perform, e.g.,  (COUNT item (COERCE x 'SEQUENCE)). This alternative would have the lowest adoption cost; perhaps some implementations could optimize such coercions.The general reason for opposing this change is that it adds more mechanism than it is worth. The general reason for liking it is that it adds generality at little cost. TITANTITANTIMESROMANP"$°Û97ÞÏKÂ_:«zº*start*01159 00024 US Return-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 26 OCT 87 17:39:15 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Mon 26 Oct 87 20:34:03-ESTDate: Mon, 26 Oct 87 20:33 ESTMessage-ID: <FAHLMAN.12345688787.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Masinter.paCc: CL-Cleanup@SAIL.STANFORD.EDU, Pedersen.paSubject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 3)In-reply-to: Msg of 26 Oct 1987  19:27-EST from Masinter.pa at Xerox.COMI'm in favor of this (the GENERALIZE option, that is).  While I don'tthink this is super-important, I do think that it is useful.  Some ofthe earlier impression of luke-warmness may have been due to the earlierinclusion of two different options; I remember thinking that we shouldadopt one or the other, but that I was indifferent as to which optionwon.I'm not sure about item 2 in the proposal: extending MAKE-SEQUENCE totake an array specifier.  That seems confusing to me.  On the otherhand, I have never had occasion to use MAKE-SEQUENCE, so I don't caretoo much about how far we stretch it.-- Scott*start*01146 00024 US Date: 26 Oct 87 19:30 PDTFrom: Pedersen.paSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 3)In-reply-to: Masinter.pa's message of 26 Oct 87 16:27 PSTTo: Masinter.pacc: CL-Cleanup@SAIL.STANFORD.EDU, Pedersen.pa"Note that simply extending COERCE, MAKE-SEQUENCE, LENGTH, 	ELT, and the SETF expander for ELT would have the side effect of extending the remaining functions if they are written in the obvious way.For example:  (DEFUN SUBSTITUTE (NEW-ITEM OLD-ITEM SEQUENCE &KEY ...)    (LET ((RESULT (MAKE-SEQUENCE (TYPE-OF SEQUENCE))))     (DOTIMES (I (LENGTH SEQUENCE) RESULT)	 (SETF (ELT RESULT I)	       (IF (EQL (ELT SEQUENCE I) OLD-ITEM) 	 	   NEW-ITEM		   (ELT SEQUENCE I))))))"I think this argument is a canard since any implementation worth its salt will type dispatch for all sequence functions. The :generalize proposal will inescapably induce a large number of small changes to existing Common Lisp implementations.It seems more esthetic to localize those changes in a single extension (eg. (coerce x 'sequence))  rather than spreading them all over the sequence functions.							J.P.*start*04358 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 04 NOV 87 11:51:22 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 4 Nov 87  11:48:27 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 272027; Wed 4-Nov-87 14:49:30 ESTDate: Wed, 4 Nov 87 14:49 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 3)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871026-163446-2308@Xerox>Message-ID: <19871104194928.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Comments on excerpts from version 3 of the proposal:    Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE):    1) Modify the definition of COERCE to allow the coercion of an array to    a vector and vice versa. Coercion of a vector to an array doesn't make any sense, since a vectoris already an array.  I think what you must really mean here is togeneralize the first bullet on CLtL p.51 to say "any sequence or arraytype can be converted to any other sequence or array type..." and toadd that this includes coercions that change the rank of an array andcoercions between lists and arrays of rank other than 1.  We have toexplain how array rank changes, and array dimension changes, renumberthe elements; basically row-major order, but a somewhat more verboseexplanation is probably appropriate.			     In keeping with p51 of CLtL, it should be an    error if the result type has a different number of elements than the    object being coerced.I don't see anything about number of elements on p.51 of CLtL.  I onlysee a comment about type of elements.  Is this a separate cleanup proposalto define whether (coerce "foo" '(vector * 2)) returns #(#\f #\o) orsignals an error?  What about (coerce "foo" '(vector * 4))?  I think thatshould be dealt with in a separate proposal.  If you want current practiceinput, both of these signal an error in Symbolics Common Lisp.If it's clarified as I suggest, I would agree with this part.    2) Modify the definition of MAKE-SEQUENCE to accept array descriptions    as well as vector descriptions.I disagree with this, but also I'm not sure what it says.  If it meansthat MAKE-SEQUENCE should be able to return an array of rank other than 1,I disagree, because I don't think we are proposing to extend the typenamed SEQUENCE to include such arrays.  On the other hand, if it meansthat (make-sequence '(array double-float 1) 5) should be valid, as faras I can tell it is already valid.  If it's based on someone's ideaof the internal implementation of SUBSTITUTE, REVERSE, and MAP, doing(MAKE-SEQUENCE (TYPE-OF argument) (LENGTH argument)), I think that's asilly reason to change the language.    3) Extend the definitions of sequence functions that either return their    argument sequences or return non-sequences so that they also allow    arrays. Again, say "of rank other than 1" since they already allow rank-1 arrays.	    These functions should treat array arguments as vectors    displaced to the array storage (in row-major format). The affected    functions are LENGTH, ELT, COUNT, FIND, POSITION, SOME, EVERY, NOTANY,    NOTEVERY, REDUCE, SEARCH, MISMATCH, FILL, REPLACE, NSUBSTITUTE,    NREVERSE, SORT.I agree with this.    Extend the definitions of sequence functions whose result should be the    same shape as but not necessarily EQ to some argument. These functions    should deal with array arguments by returning an array of the same    shape. The affected functions are SUBSTITUTE, REVERSE, and MAP.I agree with this.    Expressly forbid arrays as arguments to sequence functions that modify    the number of elements in the array because the shape would be    undefined. These functions are SUBSEQ, COPY-SEQ, CONCATENATE, MERGE,    REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.Does the novel phrase "expressly forbid" mean that CLtL leaves this open toextension ("is an error"), or that CLtL requires this to signal an error,or does it mean something else?  I guess I prefer "is an error".Conclusion: I support sending this to X3J13 but would like to seethe language of the proposal made crisper as suggested above.*start*08236 00024 USfDate: 11 Nov 87 00:46 PSTFrom: Masinter.paSubject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: CL-Cleanup@SAIL.STANFORD.EDUcc: Masinter, Dave.Touretzky@C.CS.CMU.EDU(Dave, in looking over the mail on this, I see that we neglected to cc you on our discussion. I intended to, but apparently forgot, to include the original submitter in subsequent discussion.)I've tried to respond to Moon's points. I was reluctant to add (at a late date) the ability to coerce a list to a non-vector array and vice versa, because there are several possible natural interpretations. (E.g., should (COERCE '#2A((A B) (C D)) 'LIST) => '(A B C D) or '((A B) (C D))? Rather than opening that can of worms unnecessarily, I thought it best to stick to the problem at hand...I don't think we've justified extending COERCE to allow it to *increase* the rank; all of the arguments were addressed toward merely allowing (COERCE <array> 'VECTOR).  I changed point 1 to say this, hopefully less ambiguously than before.I agree with David's analysis of point 2 and removed it, (re)numbering the subsequent points.NREVERSE, NSUBSTITUTE were miscategorized. The  (N)SUBSTITUTE-IF(-NOT) functions were missing.Issue:        SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReferences:   Sequences (pp245-261), COERCE (p51)              Issue REMF-DESTRUCTURING-UNSPECIFIED                (discussion of NREVERSE, NSUBSTITUTE)Category:     ENHANCEMENTEdit history: 05-Feb-87, Version 1 by Touretzky              28-Apr-87, Version 2 by Pitman (variations on the theme)              26-Oct-87, Version 3 by Masinter (clean up for release)              11-Nov-87, Version 4 by Masinter (respond to comments)Description:Common Lisp provides many useful operations on lists and vectors which don't apply to arrays.For example, one can FILL a vector with 0's, but not an array. One can REPLACE the contents of one vector with another, but one can't do this for arrays.  One can verify that EVERY element of a vector has some property, but one can't do this for arrays, and so on.The programmer who wishes to use arrays instead of vectors must give up most of the useful tools CLtL provides for manipulating sequences, even though there is no intuitive reason why operations like FILL, REPLACE, and EVERY shouldn't work on arrays.Common Lisp already provides a facility called "displaced arrays" which can be used to overlay one array on top of a portion of another, even if the two are of different ranks, so that the two share storage or use the awkward convention of creating a displaced array to the operand. However, creating a displaced array merely to perform FILL, REPLACE or EVERY is awkward.Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE):1) Generalize the definition of COERCE so that an array of any rank can be coerced to type VECTOR or to type SEQUENCE. The result of (COERCE <array> 'VECTOR) or (COERCE <array> 'SEQUENCE) when <array> is an array of rank other than 1 is a vector displaced to the original array, equivalent to  (MAKE-ARRAY (ARRAY-TOTAL-SIZE <array>)   :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE <array>)   :DISPLACED-TO <array>). 2) Extend the definitions of sequence functions that either return their argument sequences or return non-sequences so that they also allow arrays of rank other than 1. These functions should treat array arguments as vectors displaced to the array storage (in row-major format). The affected functions are LENGTH, ELT, COUNT, FIND, POSITION, SOME, EVERY, NOTANY, NOTEVERY, REDUCE, SEARCH, MISMATCH, FILL, REPLACE, SORT.For example, suppose A is a 3x2x7 array. (LENGTH A) should return 42, and (ELT A 7) should return the same element as (AREF A 0 1 0).  :START and :END keywords would be interpreted relative to the vector, as would the results returned by POSITION and SEARCH.3) Extend the definitions of sequence functions whose result should be the same shape as but not necessarily EQ to some argument. These functions should deal with array arguments by returning an array of the same shape as the argument, and operate on their argument in row-major order. The affected functions are SUBSTITUTE, NSUBSTITUTE, REVERSE, NREVERSE, SUBSTITUTE-IF, NSUBSTITUTE-IF, SUBSTITUTE-IF-NOT, NSUBSTITUTE-IF-NOT and MAP.4) Sequence functions that modify the number of elements in the array remain unchanged: it is an error to pass arrays of rank other than 1. (The functions are not extended because the shape would be undefined.) The unaffected functions are SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.Note that EQUALP does -not- treat arrays as vectors.  It is not a sequence function, and it already has a well-defined behavior for arrays. To test whether the arrays A and B, of different shapes, have the same elements, one might write:	(AND (= (LENGTH A) (LENGTH B)) (EVERY #'EQL A B)).Rationale:  This is a useful upward compatible extension with relatively low adoption cost.  Adoption Cost:  This would involve a lot of changes to functions, but all of the changes are likely to be minor. The presence of displaced arrays in the language already guarantees that the internal storage format needed to back up these proposed changes is already in place. Benefits:  This proposal adds natural support for multi-dimensional arrays. Currently, users must write nested DO loops every time they want to perform an array operation equivalent to FILL, REPLACE, REDUCE, etc., or else they build displaced vectors by hand and pass them to the sequence functions when necessary. With this proposal,users of arrays do not have to use home-grown utilities to duplicate functionality already primitively provided to users of arrays. The sequence functions become useful in a variety of new situations.  Conversion Cost:  This change is upward compatible; current user code should run unmodified.  Aesthetics:  This proposal extends sequence functions to cover arrays while neatly avoiding the temptation to turn Common Lisp into a half-baked APL. Instead of trying to provide a full set of array handling primitives (which would be needed to take arbitrary k-dimensional slices out of n-dimensional arrays, or to apply an operator across a specific dimension of a multidimensional array), it requires just one rule:    treat arrays as displaced vectors where it is well-defined.Current Practice:We know of no current implementation of this proposal. Discussion: This issue was discussed by the cleanup committee at length; what follows is only a brief summary of the discussion.An alternative considered was to only affect those functions which didn't explicitly depend on the shape of the array; that is, to modify  COUNT, SOME, EVERY, NOTANY, NOTEVERY, FILL, REPLACE, SUBSTITUTE, NSUBSTITUTE, and MAP, and expressly forbid arrays as arguments to other sequence functions, including LENGTH, ELT, FIND, POSITION, REDUCE, SEARCH,  MISMATCH, REVERSE, NREVERSE, SORT, MAP, as well as SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES. This would be less controversial, since it includes only those functions which do not deal with positional information. Some hedging over REDUCE and FIND, which often have non-positional uses, were considered.Touretzky supports SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE. He's been building displaced vectors to pass to sequence functions when necessary and really dislikes it.We considered but discarded as unworkable an alternative where POSITION and FIND might deal with "positions" as lists of array subscripts.Another alternative considered would be to only adopt the COERCE change, and require users who want to operate on arrays explictly perform, e.g.,  (COUNT item (COERCE x 'SEQUENCE)). This alternative would have the lowest adoption cost; perhaps some implementations could optimize such coercions.The general reason for opposing this change is that it adds more mechanism than it is worth. The general reason for liking it is that it adds generality at little cost. TITANTITANTIMESROMANTIMESROMAN"õÛ9jV	QÛ:Bzº*start*02340 00024 UShReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 NOV 87 18:18:33 PSTReceived: from SCRC-RIVERSIDE.ARPA by SAIL.STANFORD.EDU with TCP; 12 Nov 87  17:05:23 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 187827; Thu 12-Nov-87 19:21:17 ESTDate: Thu, 12 Nov 87 19:21 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: CL-Cleanup@SAIL.STANFORD.EDUcc: Dave.Touretzky@C.CS.CMU.EDUIn-Reply-To: <871111-004615-6413@Xerox>Message-ID: <19871113002102.3.MOON@EUPHRATES.SCRC.Symbolics.COM>This looks good.An obvious question that is going to arise is why did we define(COERCE array 'SEQUENCE) to be (MAKE-ARRAY ... :DISPLACED-TO array)rather than (CONCATENATE 'VECTOR array).  In researching this I notethat it's pretty hard to tell from CLtL whether the other sequencecoercions are required to allocate new storage, or are allowed to shareexisting storage, when they don't just return the argument.  The word"copy" is used in an off-hand remark, and I had always assumed withoutthinking about it that COERCE was a copying operation, but CLtL neveractually says whether or not the result is allowed to share storage withthe argument, when they are not identical.I imagine that unlike any other use of COERCE, our proposed(COERCE array 'SEQUENCE) is -required- to share storage with theargument, so that SETF of ELT may be used on the result, causing theelements of the original argument to be affected.  If true, we certainlyshould put in a sentence or two of rationale to forestall questions.This should both explain that we did it this way not just for "efficiency",but so the user could rely on side-effects propagating from the vectorback to the array, and also say something about the relation of this tothe vagueness of the other sequence coercions.This raises the question, why is COERCE really in this proposal anyway?It almost seems to be there only to support the remark at the end abouthow the whole proposal could have been replaced with a proposal just toextend COERCE, but we chose not to do that.  Maybe Dave T can comment onthe reasons for including COERCE.*start*01951 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 03:03:57 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 14 Nov 87  03:01:44 PSTReceived: ID <TOURETZKY@C.CS.CMU.EDU>; Sat 14 Nov 87 06:01:20-ESTDate: Sat, 14 Nov 87 06:01:16 ESTFrom: Dave.Touretzky@C.CS.CMU.EDUSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Moon@SCRC-STONY-BROOK.ARPAcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19871113002102.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <12350510652.7.TOURETZKY@C.CS.CMU.EDU>Here is an explanation of the proper role of COERCE wrt arrays:My "treat arrays as sequences" proposal was intended to do more than justextend the applicability of the sequence functions to arrays.  It was alsosupposed to change the feel of arrays in the language, by implying that shapeisn't all that important; content is what matters.To preserve the primacy of content, no matter what shape a sequence has (list,vector, or n-dimensional array), we should be able to convert it to some othershape and have the behavior of FIND, POSITION, LENGTH, ELT, etc., stay thesame.  Looked at this way, it's perfectly obvious that if ARR is a 3x3 array,then (COERCE 'LIST ARR) should return a nine element list, not a triple oftriples.As for going from lists to arrays, I suggest that  (COERCE '(ARRAY dims) SEQ)should be equivalent to  (REPLACE (MAKE-ARRAY 'dims) SEQ)Note that SEQ may be any type of sequence, including an array; its elementswill be extracted in row-major order as if ELT were used.  This definition alsopreserves the results of ELT, FIND, POSITION, etc., as long as the source anddestination objects have the same LENGTH.  If the source is longer, itsextra elements are lost; if the destination is longer, its extra elementshave undefined initial values.-- Dave-------*start*02787 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 13:41:49 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 14 Nov 87  13:39:52 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 279870; Sat 14-Nov-87 16:39:29 ESTDate: Sat, 14 Nov 87 16:39 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Dave.Touretzky@C.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <12350510652.7.TOURETZKY@C.CS.CMU.EDU>Message-ID: <19871114213919.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sat 14 Nov 87 06:01:16-EST    From: Dave.Touretzky@C.CS.CMU.EDU    Here is an explanation of the proper role of COERCE wrt arrays:    My "treat arrays as sequences" proposal was intended to do more than just    extend the applicability of the sequence functions to arrays.  It was also    supposed to change the feel of arrays in the language, by implying that shape    isn't all that important; content is what matters.Okay; this rationale should go into the SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS proposal.    To preserve the primacy of content, no matter what shape a sequence has (list,    vector, or n-dimensional array), we should be able to convert it to some other    shape and have the behavior of FIND, POSITION, LENGTH, ELT, etc., stay the    same.  Looked at this way, it's perfectly obvious that if ARR is a 3x3 array,    then (COERCE 'LIST ARR) should return a nine element list, not a triple of    triples.Sure (ignoring wrong argument order to COERCE).  Does this mean coercions fromnon-vector arrays to lists should be put back into the proposal, but with a cleardescription of what they do (unlike last time)?    As for going from lists to arrays, I suggest that      (COERCE '(ARRAY dims) SEQ)    should be equivalent to      (REPLACE (MAKE-ARRAY 'dims) SEQ)    Note that SEQ may be any type of sequence, including an array; its elements    will be extracted in row-major order as if ELT were used.  This definition also    preserves the results of ELT, FIND, POSITION, etc., as long as the source and    destination objects have the same LENGTH.  If the source is longer, its    extra elements are lost; if the destination is longer, its extra elements    have undefined initial values.This is pretty hard to understand in light of the proposal that coercing anarray to a vector should share the storage, rather than creating a new vectorand using REPLACE to copy the elements.  So is the semantics we are looking forfrom COERCE to be sharing, copying, or undefined which?*start*02668 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 NOV 87 12:42:38 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 15 Nov 87  12:39:37 PSTReceived: ID <TOURETZKY@C.CS.CMU.EDU>; Sun 15 Nov 87 15:38:58-ESTDate: Sun, 15 Nov 87 15:38:57 ESTFrom: Dave.Touretzky@C.CS.CMU.EDUSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Moon@SCRC-STONY-BROOK.ARPAcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19871114213919.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <12350877959.8.TOURETZKY@C.CS.CMU.EDU>Okay, here's a cleaned up description of coercion and sequences, which shouldbe added to the SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE proposal.1.  The term "sequence" includes not only lists and vectors, but also arrays,with the understanding that array elements are accessed in row-major order.This guarantees that functions like LENGTH, ELT, FIND, POSITION, etc. willbehave the same way on a coerced sequence (of the same length) as on theoriginal sequence.2.  COERCE can convert from any type of sequence to any other.  It is undefinedwhether the result of a coercion shares structure with the original sequence.3.  If a sequence is coerced to a vector or array with an explicitly-specifiedlength N not equal to the length of the input sequence, M, then:  a) the result of the coercion must be of length exactly N, as requested  b) if N < M, the extra elements in the input sequence are ignored  c) if N > M, the initial values of the extra elements in the result        sequence are undefinedRationale: This extension fits naturally with the generalization of sequence functions tooperate on arrays.  It changes the nature of arrays in the language by makingcontent more important than structure.  Sequences can be converted to differentshapes, maintaining the same content, and all the sequence functions willcontinue to return the same results.Discussion: The idea that the result of coercing an array to a vector should sharestructure with the original was never part of my original proposal; it wassuggested as an alternative to the proposed extensions to the sequencefunctions.  I don't like it, as it forces COERCE to copy in some cases (e.g.,string --> list) and explicitly not copy in others.  Type coercion is unrelatedto the copy vs. share structure debate.  Therefore we should leave it undefinedwhether COERCE copies or not, except to continue the convention in CLtL that ifthe input is already of the specified type, it will be returned withoutcopying.-- Dave-------*start*01115 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 NOV 87 19:27:36 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 15 Nov 87  19:26:04 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 15 Nov 87 22:25:36-ESTDate: Sun, 15 Nov 87 22:25 ESTMessage-ID: <FAHLMAN.12350951963.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Dave.Touretzky@C.CS.CMU.EDUCc: CL-Cleanup@SAIL.STANFORD.EDU, Moon@SCRC-STONY-BROOK.ARPASubject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)In-reply-to: Msg of 15 Nov 1987  15:38-EST from Dave.TouretzkyI like the idea of extending certain sequence functions to also work onarrays of more than one dimension.  I do NOT like the idea ofconsidering multi-D arrays to be sequences.  This seems deeplyunintuitive to me, and it is likely to have unexpected repercussions inother parts of the language.  So I am not in favor of theproposal as modified by Touretzky.  I'm not sure what coerce should do.-- Scott*start*02563 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 NOV 87 22:59:18 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 15 Nov 87  22:57:36 PSTReceived: ID <TOURETZKY@C.CS.CMU.EDU>; Mon 16 Nov 87 01:57:11-ESTDate: Mon, 16 Nov 87 01:57:08 ESTFrom: Dave.Touretzky@C.CS.CMU.EDUSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Fahlman@C.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDU, Moon@SCRC-STONY-BROOK.ARPA, Dave.Touretzky@C.CS.CMU.EDUMessage-ID: <12350990498.13.TOURETZKY@C.CS.CMU.EDU>I don't understand Fahlman's objection to calling arrays sequences.  We'veconsidered every sequence function in CLtL, and extended them to arrays inall the cases that made sense, which is all cases except when the resultwould be a sequence that could have a diferent number of elements than the input sequence.  Given this step, we should either admit that arraysare sequences, or else rename the sequence functions to ``sequence or arrayfunctions.''   Let me restate the basic intuition one more time.  A sequence is like a stringof beads.  If you stretch it out straight you have a list or vector.  If youfold it up in various ways using COERCE or MAP, you have an n-dimensional arraywhich you can access with AREF, which is not a sequence function.  The beadsstill sit on the string in the same order, and the sequence functions stillgive the same result no matter how you fold the string of beads.  This propertyis guaranteed by the existing commitment in CLtL to storing array elements inrow-major order.Calling arrays sequences only affects the description of the sequencefunctions; it doesn't affect array functions, string functions, etc.  If Scottoverlooked this point, it might explain his intuition that the ramifications ofthis change would be hard to predict or control.Another natural consequence of my modified proposal would be to allow MAPto return multi-dimensional arrays, since COERCE can do it.Suppose Aij is a 3x3 array.  We can apply operation F to every element of thearray, and get back a new array of the same shape, by writing  (MAP '(ARRAY * (3 3)) #'F Aij)Note: if we just specify ARRAY for the result type, we should get back a nineelement vector instead of a 3x3 array.  CLtL should be modified to indicatethat the result of MAP is a list or vector as long as the shortest inputsequence, *except* when a different length or shape is explicitly specified.-- Dave-------*start*01976 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 NOV 87 07:25:56 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 16 Nov 87  07:23:33 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Mon 16 Nov 87 10:23:05-ESTDate: Mon, 16 Nov 87 10:22 ESTMessage-ID: <FAHLMAN.12351082581.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Dave.Touretzky@C.CS.CMU.EDUCc: CL-Cleanup@SAIL.STANFORD.EDUSubject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)In-reply-to: Msg of 16 Nov 1987  01:57-EST from Dave.Touretzky    I don't understand Fahlman's objection to calling arrays sequences.  We've    considered every sequence function in CLtL, and extended them to arrays in    all the cases that made sense, which is all cases except when the result    would be a sequence that could have a diferent number of elements than     the input sequence.  Given this step, we should either admit that arrays    are sequences, or else rename the sequence functions to ``sequence or array    functions.''   When we consider a sweeping change in the type hierarchy, it isnecessary to scan the entire manual for occurrences of "sequence" tomake sure there's not some damned little comment that will causetrouble.  Even then, there are probably some gotchas.  Have you donethis?Rearranging the type hierarchy is a big incompatible step.  Theextensions to the various sequence functions were of marginal value, butwhen considered as a minor extensions, the convenience probablyoutweighs the cost.  If people feel that changes in the type hierarchyare a necessary part of this extension, then a whole new set ofconsiderations come into play.  I think that the added convenience isnot sufficient to justify a change in the type hierarchy -- at least,the case has to be considered much more carefully.-- Scott*start*01860 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 19 NOV 87 13:42:50 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 19 Nov 87  13:40:15 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 19 NOV 87 13:38:44 PSTDate: 19 Nov 87 13:38 PSTFrom: Masinter.paSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)In-reply-to: Dave.Touretzky@C.CS.CMU.EDU's message of Mon, 16 Nov 87 01:57:08 ESTTo: Dave.Touretzky@C.CS.CMU.EDU, CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <871119-133844-9984@Xerox>Dave:Integers are not floating point numbers, although all of the functionsthat work on floating point numbers can easily be extended to work onintegers in all the cases that make sense. Just because there is a wayof converting an array into a sequence doesn't mean that an array *is* asequence.Frankly, most other programming dialects that I am aware of coerce anarray into a vector by treating #2A((A B C) (D E F) (G H I))  coerces to #(#(A B C) #(D E F) #(G H I)),i.e., a vector arrays.  Since there are multiple reasonable views of anarray as a sequence, I'm not happy with extending COERCE: COERCE shouldbe left for those cases where there is a unique "natural" injection. I believe the drift on this proposal (also in discussions in Denver) isthat we should leave the ARRAY and SEQUENCE types alone, but change thesection title of "sequence function" to talk about a set of genericfunctions that work on types LIST, VECTOR, and, for some of them, ARRAY.Post-CLOS, we might also be able to document how users can define howthese functions work for their own types, too.This would be  a gentle upward compatible change which gives us most ofwhat we want, without doing too much violence to our sensibilities. *start*01667 00024 US Date: 19 Nov 87 14:24 PSTFrom: Pedersen.paSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)In-reply-to: Masinter.pa's message of 19 Nov 87 13:38 PSTTo: Masinter.pacc: Dave.Touretzky@C.CS.CMU.EDU, CL-Cleanup@SAIL.STANFORD.EDU	I agree that trying to stuff something similar to APL "reshape" and APL "ravel" into coerce would most likely lead to confusion rather than clarification. However, the "ravel" operation is a quite useful one -- and would be a nice complement to the proposed AREF1. "Ravel" is easily written in terms of existing primitives, but its major value is in abbreviating a frequent operation. E.G.(defun ravel (array)	(typecase array		(vector array)		(array 			(make-array (array-total-size array) :element-type				(array-element-type array) :displaced-to array))		(other			(error "Not an array: ~s" array))))	I guess it is worth insisting that the vector returned from "ravel" share storage with the argument array.	Supposing one had "ravel", then I see no driving need for any of the extensions outlined in "SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)". Perhaps someone would care to enlighten me on this point. Is the argument that distributing array coercion throughout some (but not all) sequence functions is likely to be more efficient   --  more esthetic ? Larry's argument that the sequence functions form a paradigm that should be extendable to include arbitrary structures is interesting, but I fail to see how "SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)" makes this any easier or any harder. Surely it is sufficient to make all the sequence functions generalizable.							J.P.*start*01296 00024 US Return-Path: <TOURETZKY@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 19 NOV 87 21:01:59 PSTReceived: ID <TOURETZKY@C.CS.CMU.EDU>; Fri 20 Nov 87 00:01:54-ESTDate: Fri, 20 Nov 87 00:01:52 ESTFrom: Dave.Touretzky@C.CS.CMU.EDUSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Masinter.pacc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871119-133844-9984@Xerox>Message-ID: <12352018090.16.TOURETZKY@C.CS.CMU.EDU>Okay, I concede that the array/sequence issue isn't as clear cut as I made itout to be.  I will be happy to go with Version 4 as stated, except we shouldcut out any mention of COERCE.In reply to Petersen, I think the proposal to use explicit raveling in place ofextending the sequence functions as described in Version 4 is unacceptable onaesthetic grounds.  It makes for really ugly code.  It treats vectorsdifferently than arrays (since only arrays need to be raveled), which isawkward.  It misses the fact that sequence functions like FILL and COUNT arealready generalized to arrays in non-Lisp contexts; in English we use thegeneralized forms all the time, e.g., "count the number of 1's in this matrix."I look forward to the day when I can say (FILL MY-MATRIX 0.0) and have Lispdo the right thing.-- Dave-------*start*03423 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 29 NOV 87 00:32:24 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 28 Nov 87  05:34:09 PSTReceived: by labrea.stanford.edu; Sat, 28 Nov 87 05:32:29 PSTReceived: from bhopal.lucid.com by edsel id AA28590g; Sat, 28 Nov 87 05:26:50 PSTReceived: by bhopal id AA17747g; Sat, 28 Nov 87 05:27:53 PSTDate: Sat, 28 Nov 87 05:27:53 PSTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8711281327.AA17747@bhopal.lucid.com>To: labrea!Dave.Touretzky%C.CS.CMU.EDU@labrea.stanford.eduCc: labrea!cl-cleanup%sail@labrea.stanford.eduIn-Reply-To: Dave.Touretzky@C.CS.CMU.EDU's message of Mon 16 Nov 87 01:57:08-EST <12350990498.13.TOURETZKY@C.CS.CMU.EDU>Subject: [Density?] SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)There's one sense in which I share Fahlman's reluctance to accept this idea.It seems to presume that underlying any array whatsoever is a simplevector of elements that represent the array in dense, row-major order.In fact, Lucid Common Lisp does just about that (as all the others do too, I suspect!).  There is even an "internal" function named     'underlying-simple-vector'to fetch that simple vector.But the problem is that the simple-vector needn't be "dense" in elements of the array!  The existence of the function array-row-major-index doesn't require, for example, that there be no gaps between the rows.  [The definition on CLtL, p293 is only one possibility --  the one for dense underlying simple-vectors.]   Rather, it only requires a 1-1 mappingbetween the integers {0,1,...(1- <array-total-size>)} and the full set ofmulti-dimensional indices.Your characterization of the relation between arrays and sequences exhibitsthe bias towards dense, underlying simple vectors:    Let me restate the basic intuition one more time.  A sequence is like      a string of beads.  If you stretch it out straight you have a list or     vector.  If you fold it up in various ways using COERCE or MAP, you     have an n-dimensional array which you can access with AREF, which is     not a sequence function.  The beads still sit on the string in the same     order, and the sequence functions still give the same result no matter     how you fold the string of beads.  This property is guaranteed by the     existing commitment in CLtL to storing array elements in row-major order."Ordering" may be guaranteed by row-major order; but "density" isn't.Not even the existence of :displaced-index-offset guarantees "density"(especially if it's value is typically row-aligned anyway), althoughI admit that you won't get portable results if you can't assume density.Until it is decided that a particular implementation of multi-dimensionalarrays is *standard* (as opposed to the functional interface to multi-dimensional arrays), then Common Lisp implementations should be freeto store the rows of a matrix in any random way that is convenient tothe storage layout of that implementation (e.g., "sparse" storage?).I must confess that on "stock" hardware, it would be rather inefficient notto use the dense, row-major odering.  But closing off other implementation options seems premature, to me; at least until there is evidence of a *great* win to be had by doing so.-- JonL --*start*01670 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 30 NOV 87 11:25:56 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 30 Nov 87  09:21:08 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 290628; Mon 30-Nov-87 12:19:35 ESTDate: Mon, 30 Nov 87 12:19 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: [Density?] SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Jon L White <edsel!jonl@labrea.stanford.edu>cc: Dave.Touretzky@C.CS.CMU.EDU, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8711281327.AA17747@bhopal.lucid.com>Message-ID: <19871130171930.3.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sat, 28 Nov 87 05:27:53 PST    From: Jon L White <edsel!jonl@labrea.stanford.edu>    There's one sense in which I share Fahlman's reluctance to accept this idea.    It seems to presume that underlying any array whatsoever is a simple    vector of elements that represent the array in dense, row-major order.    ....That was clearly the intention of Common Lisp, although I note that theonly place in CLtL that says this explicitly is an example on p.289.It can also be deduced from the definitions of array-total-size andarray-row-major-index, because the range of array-row-major-index'sanswer is defined to be a range of integers that contains just enoughmembers to supply a value for each subscript set, with no gaps.Since CLtL was not explicit enough to be clear to you, perhaps a cleanupproposal in the "clarification" category is needed.*start*01971 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 DEC 87 23:06:18 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 7 Dec 87  20:38:02 PSTReceived: by labrea.stanford.edu; Mon, 7 Dec 87 20:31:59 PSTReceived: from bhopal.lucid.com by edsel id AA02700g; Mon, 7 Dec 87 18:22:09 PSTReceived: by bhopal id AA01347g; Mon, 7 Dec 87 18:22:31 PSTDate: Mon, 7 Dec 87 18:22:31 PSTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8712080222.AA01347@bhopal.lucid.com>To: labrea!Moon%STONY-BROOK.SCRC.Symbolics.COM@labrea.stanford.eduCc: labrea!cl-cleanup%sail@labrea.stanford.eduIn-Reply-To: David A. Moon's message of Mon, 30 Nov 87 12:19 EST <19871130171930.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: [Density?] SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)re: It [density] can also be deduced from the definitions of array-total-size     and array-row-major-index, because the range of array-row-major-index's    answer is defined to be a range of integers that contains just enough    members to supply a value for each subscript set, with no gaps.I think my previous note mentioned that density in storage isn't actuallyrequired by this bijective mapping -- it would only do so if the outputof array-row-major-index were required to be a memory index.Perhaps one couldn't imagine any other meaning for array-row-major-indexother than "index offset from base memory location"; but CLtL doesn'tsay this now, and I can certainly think of alternative representationswhich would reinject the "linearized" index into the multi-dimensionalformat simply in order to preserve the documented property.If any clarification is necessary, then it ought to take into accountthe AREF-1D proposal, which would raise some efficiency questions if the bijective mapping weren't "index-offset" memory access.-- JonL --*start*07292 00024 USfDate:  5 Feb 88 16:48 PSTFrom: Masinter.paSubject: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 5)To: MasinterIssue:        SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReferences:   Sequences (pp245-261)              Issue REMF-DESTRUCTURING-UNSPECIFIED                (discussion of NREVERSE, NSUBSTITUTE)              Issue AREF-1DCategory:     ENHANCEMENTEdit history: 05-Feb-87, Version 1 by Touretzky              28-Apr-87, Version 2 by Pitman (variations on the theme)              26-Oct-87, Version 3 by Masinter (clean up for release)              11-Nov-87, Version 4 by Masinter (respond to comments)               5-Feb-88, Version 5 by Masinter (remove COERCE)Description:Common Lisp provides many useful operations on lists and vectors which don't apply to arrays.For example, one can FILL a vector with 0's, but not an array. One can REPLACE the contents of one vector with another, but one can't do this for arrays.  One can verify that EVERY element of a vector has some property, but one can't do this for arrays, and so on.The programmer who wishes to use arrays instead of vectors must give up most of the useful tools CLtL provides for manipulating sequences, even though there is no intuitive reason why operations like FILL, REPLACE, and EVERY shouldn't work on arrays.Common Lisp already provides a facility called "displaced arrays" which can be used to overlay one array on top of a portion of another, even if the two are of different ranks, so that the two share storage or use the awkward convention of creating a displaced array to the operand. However, creating a displaced array merely to perform FILL, REPLACE or EVERY is awkward.Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE):1) Extend the definitions of sequence functions that either return their argument sequences or return non-sequences so that they also allow arrays of rank other than 1. These functions should treat array arguments as vectors displaced to the array storage (in row-major format). The affected functions are LENGTH, ELT, COUNT, FIND, POSITION, SOME, EVERY, NOTANY, NOTEVERY, REDUCE, SEARCH, MISMATCH, FILL, REPLACE, SORT.For example, suppose A is a 3x2x7 array. (LENGTH A) should return 42, and (ELT A 7) should return the same element as (AREF A 0 1 0).  :START and :END keywords would be interpreted relative to the vector, as would the results returned by POSITION and SEARCH.2) Extend the definitions of sequence functions whose result should be the same shape as but not necessarily EQ to some argument. These functions should deal with array arguments by returning an array of the same shape as the argument, and operate on their argument in row-major order. The affected functions are SUBSTITUTE, NSUBSTITUTE, REVERSE, NREVERSE, SUBSTITUTE-IF, NSUBSTITUTE-IF, SUBSTITUTE-IF-NOT, NSUBSTITUTE-IF-NOT and MAP.3) Sequence functions that modify the number of elements in the array remain unchanged: it is an error to pass arrays of rank other than 1. (The functions are not extended because the shape would be undefined.) The unaffected functions are SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.Note that EQUALP does -not- treat arrays as vectors.  It is not a sequence function, and it already has a well-defined behavior for arrays. To test whether the arrays A and B, of different shapes, have the same elements, one might write:	(AND (= (LENGTH A) (LENGTH B)) (EVERY #'EQL A B)).Rationale:  This is a useful upward compatible extension with relatively low adoption cost.  Adoption Cost:  This would involve a lot of changes to functions, but all of the changes are likely to be minor. The presence of displaced arrays in the language already guarantees that the internal storage format needed to back up these proposed changes is already in place. Benefits:  This proposal adds natural support for multi-dimensional arrays. Currently, users must write nested DO loops every time they want to perform an array operation equivalent to FILL, REPLACE, REDUCE, etc., or else they build displaced vectors by hand and pass them to the sequence functions when necessary. With this proposal, users of arrays do not have to use home-grown utilities to duplicate functionality already primitively provided to users of arrays. The sequence functions become useful in a variety of new situations.  Conversion Cost:  This change is upward compatible; current user code should run unmodified.  Aesthetics:  This proposal extends sequence functions to cover arrays while neatly avoiding the temptation to turn Common Lisp into a half-baked APL. Instead of trying to provide a full set of array handling primitives (which would be needed to take arbitrary k-dimensional slices out of n-dimensional arrays, or to apply an operator across a specific dimension of a multidimensional array), it requires just one rule:    treat arrays as displaced vectors where it is well-defined.Current Practice:We know of no current implementation of this proposal. Discussion: This issue was discussed by the cleanup committee at length; what follows is only a brief summary of the discussion.An alternative considered was to only affect those functions which didn't explicitly depend on the shape of the array; that is, to modify  COUNT, SOME, EVERY, NOTANY, NOTEVERY, FILL, REPLACE, SUBSTITUTE, NSUBSTITUTE, and MAP, and expressly forbid arrays as arguments to other sequence functions, including LENGTH, ELT, FIND, POSITION, REDUCE, SEARCH,  MISMATCH, REVERSE, NREVERSE, SORT, MAP, as well as SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES. This would be less controversial, since it includes only those functions which do not deal with positional information. Some hedging over REDUCE and FIND, which often have non-positional uses, were considered.Touretzky supports SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE. He's been building displaced vectors to pass to sequence functions when necessary and really dislikes it.We considered but discarded as unworkable an alternative where POSITION and FIND might deal with "positions" as lists of array subscripts.At one point, this proposal included an extension to COERCE to allow COERCE to translate from array types to sequences, but it was thought better to separate out COERCE. We considered a proposal to only introduce a change to COERCE, and require users who want to operate on arrays explictly perform, e.g.,  (COUNT item (COERCE x 'SEQUENCE)). This alternative would have the lowest adoption cost but was deemed awkward.Sequence functions like FILL and COUNT are already generalized to arrays in non-Lisp contexts; in English we use the generalized forms all the time, e.g., "count the number of 1's in this matrix."There is some concern that this proposal makes the requirement for row-major ordering of internal storage for arrays even more evident.The general reason for opposing this change is that it adds more mechanism than it is worth. The general reason for liking it is that it adds generality at little cost. TITANTITANTIMESROMANTIMESROMANu"4Û9ÏV	QÛ:q©3ã#zº*start*07521 00024 US Date: 13 Feb 88 16:39 PSTFrom: Masinter.paSubject: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 5)To: cl-cleanup@Sail.stanford.educc: MasinterThis is another version that I apparently neglected to mail out.Issue:        SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReferences:   Sequences (pp245-261)              Issue REMF-DESTRUCTURING-UNSPECIFIED                (discussion of NREVERSE, NSUBSTITUTE)              Issue AREF-1DCategory:     ENHANCEMENTEdit history: 05-Feb-87, Version 1 by Touretzky              28-Apr-87, Version 2 by Pitman (variations on the theme)              26-Oct-87, Version 3 by Masinter (clean up for release)              11-Nov-87, Version 4 by Masinter (respond to comments)               5-Feb-88, Version 5 by MasinterDescription:Common Lisp provides many useful operations on lists and vectors which don't apply to arrays.For example, one can FILL a vector with 0's, but not an array. One can REPLACE the contents of one vector with another, but one can't do this for arrays.  One can verify that EVERY element of a vector has some property, but one can't do this for arrays, and so on.The programmer who wishes to use arrays instead of vectors must give up most of the useful tools CLtL provides for manipulating sequences, even though there is no intuitive reason why operations like FILL, REPLACE, and EVERY shouldn't work on arrays.Common Lisp already provides a facility called "displaced arrays" which can be used to overlay one array on top of a portion of another, even if the two are of different ranks, so that the two share storage or use the awkward convention of creating a displaced array to the operand. However, creating a displaced array merely to perform FILL, REPLACE or EVERY is awkward.Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE):1) Extend the definitions of sequence functions that either return their argument sequences or return non-sequences so that they also allow arrays of rank other than 1. These functions should treat array arguments as vectors displaced to the array storage (in row-major format). The affected functions are LENGTH, ELT, COUNT, FIND, POSITION, SOME, EVERY, NOTANY, NOTEVERY, REDUCE, SEARCH, MISMATCH, FILL, REPLACE, SORT.For example, suppose A is a 3x2x7 array. (LENGTH A) should return 42, and (ELT A 7) should return the same element as (AREF A 0 1 0).  :START and :END keywords would be interpreted relative to the vector, as would the results returned by POSITION and SEARCH.2) Extend the definitions of sequence functions whose result should be the same shape as but not necessarily EQ to some argument. These functions should deal with array arguments by returning an array of the same shape as the argument, and operate on their argument in row-major order. The affected functions are SUBSTITUTE, NSUBSTITUTE, REVERSE, NREVERSE, SUBSTITUTE-IF, NSUBSTITUTE-IF, SUBSTITUTE-IF-NOT, NSUBSTITUTE-IF-NOT and MAP.3) Sequence functions that modify the number of elements in the array remain unchanged: it is an error to pass arrays of rank other than 1. (The functions are not extended because the shape would be undefined.) The unaffected functions are SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.Note that EQUALP does -not- treat arrays as vectors.  It is not a sequence function, and it already has a well-defined behavior for arrays. To test whether the arrays A and B, of different shapes, have the same elements, one might write:	(AND (= (LENGTH A) (LENGTH B)) (EVERY #'EQL A B)).Rationale:  This is a useful upward compatible extension with relatively low adoption cost.  Cost to implementors:  This would involve a lot of changes to functions, but all of the changes are likely to be minor. The presence of displaced arrays in the language already guarantees that the internal storage format needed to back up these proposed changes is already in place. Cost to Users:  This change is upward compatible; current user code should run unmodified.  Benefits:  This proposal adds natural support for multi-dimensional arrays. Currently, users must write nested DO loops every time they want to perform an array operation equivalent to FILL, REPLACE, REDUCE, etc., or else they build displaced vectors by hand and pass them to the sequence functions when necessary. With this proposal, users of arrays do not have to use home-grown utilities to duplicate functionality already primitively provided to users of arrays. The sequence functions become useful in a variety of new situations.  Aesthetics:  This proposal extends sequence functions to cover arrays while neatly avoiding the temptation to turn Common Lisp into a half-baked APL. Instead of trying to provide a full set of array handling primitives (which would be needed to take arbitrary k-dimensional slices out of n-dimensional arrays, or to apply an operator across a specific dimension of a multidimensional array), it requires just one rule:    treat arrays as displaced vectors where it is well-defined.Current Practice:We know of no current implementation of this proposal. Discussion: This issue was discussed by the cleanup committee at length; what follows is only a brief summary of the discussion.An alternative considered was to only affect those functions which didn't explicitly depend on the shape of the array; that is, to modify  COUNT, SOME, EVERY, NOTANY, NOTEVERY, FILL, REPLACE, SUBSTITUTE, NSUBSTITUTE, and MAP, and expressly forbid arrays as arguments to other sequence functions, including LENGTH, ELT, FIND, POSITION, REDUCE, SEARCH,  MISMATCH, REVERSE, NREVERSE, SORT, MAP, as well as SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES. This would be less controversial, since it includes only those functions which do not deal with positional information. Some hedging over REDUCE and FIND, which often have non-positional uses, were considered.Touretzky supports SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE. He's been building displaced vectors to pass to sequence functions when necessary and really dislikes it.We considered but discarded as unworkable an alternative where POSITION and FIND might deal with "positions" as lists of array subscripts.At one point, this proposal included an extension to COERCE to allow COERCE to translate from array types to sequences, but it was thought better to separate out COERCE. We considered a proposal to only introduce a change to COERCE, and require users who want to operate on arrays explictly perform, e.g.,  (COUNT item (COERCE x 'SEQUENCE)). This alternative would have the lowest adoption cost but was deemed awkward.Sequence functions like FILL and COUNT are already generalized to arrays in non-Lisp contexts; in English we use the generalized forms all the time, e.g., "count the number of 1's in this matrix."There is some concern that this proposal makes the requirement for row-major ordering of internal storage for arrays even more evident. While such an internal ordering is implied by the ability to create displaced arrays and the AREF-1D proposal, this proposal adds yet another constraint.The general reason for opposing this change is that it adds more mechanism than it is worth. The general reason for liking it is that it adds generality at little cost. TITANTITANTIMESROMANÝ"$Û9ÏV	QÛ:q©Í×"zº*start*07479 00024 US Date: 14 Feb 88 13:54 PSTFrom: Masinter.paSubject: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 5)To: X3J13@Sail.stanford.educc: Masinterreply-to: CL-CLEANUP@Sail.Stanford.EDUThis issue is new.Issue:        SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReferences:   Sequences (pp245-261)              Issue REMF-DESTRUCTURING-UNSPECIFIED                (discussion of NREVERSE, NSUBSTITUTE)              Issue AREF-1DCategory:     ENHANCEMENTEdit history: 05-Feb-87, Version 1 by Touretzky              28-Apr-87, Version 2 by Pitman (variations on the theme)              26-Oct-87, Version 3 by Masinter (clean up for release)              11-Nov-87, Version 4 by Masinter (respond to comments)               5-Feb-88, Version 5 by MasinterDescription:Common Lisp provides many useful operations on lists and vectors which don't apply to arrays.For example, one can FILL a vector with 0's, but not an array. One can REPLACE the contents of one vector with another, but one can't do this for arrays.  One can verify that EVERY element of a vector has some property, but one can't do this for arrays, and so on.The programmer who wishes to use arrays instead of vectors must give up most of the useful tools CLtL provides for manipulating sequences, even though there is no intuitive reason why operations like FILL, REPLACE, and EVERY shouldn't work on arrays.Common Lisp already provides a facility called "displaced arrays" which can be used to overlay one array on top of a portion of another, even if the two are of different ranks, so that the two share storage or use the awkward convention of creating a displaced array to the operand. However, creating a displaced array merely to perform FILL, REPLACE or EVERY is awkward.Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE):1) Extend the definitions of sequence functions that either return their argument sequences or return non-sequences so that they also allow arrays of rank other than 1. These functions should treat array arguments as vectors displaced to the array storage (in row-major format). The affected functions are LENGTH, ELT, COUNT, FIND, POSITION, SOME, EVERY, NOTANY, NOTEVERY, REDUCE, SEARCH, MISMATCH, FILL, REPLACE, SORT.For example, suppose A is a 3x2x7 array. (LENGTH A) should return 42, and (ELT A 7) should return the same element as (AREF A 0 1 0).  :START and :END keywords would be interpreted relative to the vector, as would the results returned by POSITION and SEARCH.2) Extend the definitions of sequence functions whose result should be the same shape as but not necessarily EQ to some argument. These functions should deal with array arguments by returning an array of the same shape as the argument, and operate on their argument in row-major order. The affected functions are SUBSTITUTE, NSUBSTITUTE, REVERSE, NREVERSE, SUBSTITUTE-IF, NSUBSTITUTE-IF, SUBSTITUTE-IF-NOT, NSUBSTITUTE-IF-NOT and MAP.3) Sequence functions that modify the number of elements in the array remain unchanged: it is an error to pass arrays of rank other than 1. (The functions are not extended because the shape would be undefined.) The unaffected functions are SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.Note that EQUALP does -not- treat arrays as vectors.  It is not a sequence function, and it already has a well-defined behavior for arrays. To test whether the arrays A and B, of different shapes, have the same elements, one might write:	(AND (= (LENGTH A) (LENGTH B)) (EVERY #'EQL A B)).Rationale:  This is a useful upward compatible extension with relatively low adoption cost.  Cost to Implementors:  This would involve a lot of changes to functions, but all of the changes are likely to be minor. The presence of displaced arrays in the language already guarantees that the internal storage format needed to back up these proposed changes is already in place. Cost to Users:  This change is upward compatible; current user code should run unmodified.  Benefits:  This proposal adds natural support for multi-dimensional arrays. Currently, users must write nested DO loops every time they want to perform an array operation equivalent to FILL, REPLACE, REDUCE, etc., or else they build displaced vectors by hand and pass them to the sequence functions when necessary. With this proposal, users of arrays do not have to use home-grown utilities to duplicate functionality already primitively provided to users of arrays. The sequence functions become useful in a variety of new situations.  Aesthetics:  This proposal extends sequence functions to cover arrays while neatly avoiding the temptation to turn Common Lisp into a half-baked APL. Instead of trying to provide a full set of array handling primitives (which would be needed to take arbitrary k-dimensional slices out of n-dimensional arrays, or to apply an operator across a specific dimension of a multidimensional array), it requires just one rule:    treat arrays as displaced vectors where it is well-defined.Current Practice:We know of no current implementation of this proposal. Discussion: This issue was discussed by the cleanup committee at length; what follows is only a brief summary of the discussion.An alternative considered was to only affect those functions which didn't explicitly depend on the shape of the array; that is, to modify  COUNT, SOME, EVERY, NOTANY, NOTEVERY, FILL, REPLACE, SUBSTITUTE, NSUBSTITUTE, and MAP, and expressly forbid arrays as arguments to other sequence functions, including LENGTH, ELT, FIND, POSITION, REDUCE, SEARCH,  MISMATCH, REVERSE, NREVERSE, SORT, MAP, as well as SUBSEQ, COPY-SEQ, CONCATENATE, MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES. This would be less controversial, since it includes only those functions which do not deal with positional information. Some hedging over REDUCE and FIND, which often have non-positional uses, were considered.Touretzky supports SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE. He's been building displaced vectors to pass to sequence functions when necessary and really dislikes it.We considered but discarded as unworkable an alternative where POSITION and FIND might deal with "positions" as lists of array subscripts.At one point, this proposal included an extension to COERCE to allow COERCE to translate from array types to sequences, but it was thought better to separate out COERCE. We considered a proposal to only introduce a change to COERCE, and require users who want to operate on arrays explictly perform, e.g.,  (COUNT item (COERCE x 'SEQUENCE)). This alternative would have the lowest adoption cost but was deemed awkward.Sequence functions like FILL and COUNT are already generalized to arrays in non-Lisp contexts; in English we use the generalized forms all the time, e.g., "count the number of 1's in this matrix."There is some concern that this proposal makes the requirement for row-major ordering of internal storage for arrays even more evident. While such an internal ordering is implied by the ability to create displaced arrays and the AREF-1D proposal, this proposal adds yet another constraint.The general reason for opposing this change is that it adds more mechanism than it is worth. The general reason for liking it is that it adds generality at little cost. TITANTITANÐ"$Û9ÏV	QÛ:¨Êzº*start*00442 00024 US Date: Sat, 13 Feb 88 17:57:02 PSTFrom: Pavel.paSubject: Re: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 5)In-reply-to: <880213-163954-10487@Xerox>To: MasinterWording change:In the Benefits section, ``With this proposal, users of arrays do not have to use home-grownutilities to duplicate functionality already primitively provided to users ofarrays.'' should perhaps have ``vectors'' as the last word.*start*02082 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 01 MAR 88 11:04:35 PSTReceived: from hudson.dec.com by SAIL.Stanford.EDU with TCP; 1 Mar 88  11:01:53 PSTDate: 1 Mar 88 13:45:00 EDTFrom: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>Subject: sequence-functions-exclude-arrays (pardon msg duplication, if any)To: "cl-cleanup" <cl-cleanup@sail.stanford.edu>cc: vanroggen@hudson.dec.com Reply-To: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>We currently oppose the proposal SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:GENERALIZE as it stands.There are a number of issues that should be addressed.The proposal merely offers new syntax for functionality alreadyprovided by displaced vectors.  The argument that users (or at leastone user) "dislikes" using displaced vectors has little meaning.The syntax for displaced vectors could be improved with some trivialmacros, while efficiency concerns should be handled by the compiler.    The availability of ROW-MAJOR-AREF would seem to make this proposaleven less necessary than before.  It wouldn't change the behavior ofFILL, COUNT, etc. but does make such array operations even easier toimplement efficiently.There is no description of the meaning of :START and :END keyword argumentsfor affected functions in the current proposal.    Do ARRAYs become a subtype of SEQUENCE?  We assume not, but this shouldbe specified.  However, the sequence functions won't just be``sequence'' functions any more.  It's confusing to remember whichfunctions work on arrays and which don't.Despite the proposal's claim to the contrary, it strikes us thatthis is precisely an attempt to make Common Lisp into a kind ofhalf-baked APL.  We feel adoption of this proposal will almostcertainly result in pressure to extend still more sequence functions.This may or may not be desirable in the long run; but this proposal isonly a partial measure.			---Walter van Roggen &			   Jeff Piazza------*start*05965 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 15:30:05 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Oct 88  15:29:55 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472169; Thu 6-Oct-88 18:28:27 EDTDate: Thu, 6 Oct 88 18:28 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 6)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881006182817.9.KMP@BOBOLINK.SCRC.Symbolics.COM>I feel we didn't give the MODIFIED variation of this proposal a fairshake. We took GENERALIZED to X3J13 even knowing that it was themost controversial of the two options we had. X3J13 voted it down,not surprisingly to me. MODIFIED is considerably more conservativeand deserves consideration as a fall-back position. -kmp-----Issue:        SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReferences:   Sequences (pp245-261), COERCE (p51)Category:     ENHANCEMENTEdit history: 05-Feb-87, Version 1 by Touretzky (option GENERALIZED)	      28-Apr-87, Version 2 by Pitman (add option MODIFIED)              26-Oct-87, Version 3 by Masinter (remove MODIFIED)              11-Nov-87, Version 4 by Masinter (respond to comments)              05-Feb-88, Version 5 by Masinter	      06-Oct-88, Version 6 by Pitman 	       (revert to version 2, flush GENERALIZED option	        -- which was rejected by X3J13 -- and resurrect MODIFIED)Status:	      For Internal DiscussionDescription:  Common Lisp provides many useful operations on lists and vectors which  don't apply to arrays.  For example, one can FILL a vector with 0's, but not an array. One can  REPLACE the contents of one vector with another, but one can't do this  for arrays.  One can verify that EVERY element of a vector has some   property, but one can't do this for arrays. And so on.  The programmer who wishes to use arrays instead of vectors must give up  most of the useful tools CLtL provides for manipulating sequences, even  though there is no intuitive reason why operations like FILL, REPLACE,  and EVERY shouldn't work on arrays.Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:MODIFIED):  Common Lisp already provides a facility called "displaced arrays"  which can be used to overlay one array on top of a portion of another,  even if the two are of different ranks, so that the two share storage.  Emphasize this as a way of explaining the behavior of sequence   functions on certain arrays.  Modify the definition of COERCE to allow the coercion of an array to  a vector and vice versa. In keeping with p51 of CLtL, it should be an  error if the result type has a different number of elements than the  object being coerced.  Extend the definitions of sequence functions that either return their  argument sequences, return sequences which are the same shape as their  argument, or return non-sequences so that they also allow arrays iff  their action is conceptually independent of the shape of the array.  The affected functions are COUNT, SOME, EVERY, NOTANY, NOTEVERY,  FILL, REPLACE, SUBSTITUTE, NSUBSTITUTE, and MAP.  Expressly forbid arrays as arguments to other sequence functions.  These other functions are LENGTH, ELT, FIND, POSITION, REDUCE, SEARCH,  MISMATCH, REVERSE, NREVERSE, SORT, MAP, SUBSEQ, COPY-SEQ, CONCATENATE,  MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.Rationale:  This proposal would expand rather than interfere with existing practice.  Since displaced arrays are already part of Common Lisp, the cost of the  proposed changes would be very low.  If the change is not adopted, Common Lisp programmers who wish to use  arrays will have two choices.  Either they must write nested DO loops  every time they want to perform an array operation equivalent to FILL,  REPLACE, etc., or else they can build displaced vectors by hand and  pass them to the sequence functions when necessary.  This proposal extends certain sequence functions in some interesting  ways without committing us to a theory of how arrays and sequences  relate that everyone may not be happy with right now.Adoption Cost:  This would involve a lot of changes to functions, but all of them  presumably minor. The presence of displaced arrays in the language  already guarantees that the internal storage format needed to back  up these proposed changes is already in place.Benefits:  Users of arrays do not have to use home-grown utilities to duplicate  functionality already primitively provided to users of arrays. The  sequence functions become useful in a variety of new situations.Conversion Cost:  This change is `upward compatible.' User code should run unmodified.Aesthetics:  This extends certain existing sequence functions to allow arrays  as arguments in a fairly non-controversial way, leaving aside the  larger issue of whether and how to generalize the other sequence  functions.Current Practice:  Probably no one implements this now.Discussion:  A more general version of this was introduced by Touretzky but  it was rejected by X3J13.  The members of the Cleanup committee expressed interest in the ideas   behind this proposal but weren't sure they could accept it in the  proposed form. A rewrite to separate some of the issues more clearly  was solicited. Rees suggested this subset of Tourtezky's proposal  might be interesting.  Note that the function REDUCE is in a gray area. Many of its uses  are not position-dependent, but some are. The same argument might  be made about FIND. If people felt strongly, these too could be  extended either by fudging the conservative rule or by explicit  special case(s), but they have been omitted to be conservative.*start*05616 00024 UU?Date: 11 Jan 89 22:30 PSTSender: masinter.paSubject: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 6)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinterline-fold: No  A more general version of this was introduced by Touretzky but  it was rejected by X3J13. This has much more restricted proposal.Issue:        SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReferences:   Sequences (pp245-261), COERCE (p51)Category:     ENHANCEMENTEdit history: 05-Feb-87, Version 1 by Touretzky (option GENERALIZED)	      28-Apr-87, Version 2 by Pitman (add option MODIFIED)              26-Oct-87, Version 3 by Masinter (remove MODIFIED)              11-Nov-87, Version 4 by Masinter (respond to comments)              05-Feb-88, Version 5 by Masinter	      06-Oct-88, Version 6 by Pitman 	       (revert to version 2, flush GENERALIZED option	        -- which was rejected by X3J13 -- and resurrect MODIFIED)Description:  Common Lisp provides many useful operations on lists and vectors which  don't apply to arrays.  For example, one can FILL a vector with 0's, but not an array. One can  REPLACE the contents of one vector with another, but one can't do this  for arrays.  One can verify that EVERY element of a vector has some   property, but one can't do this for arrays. And so on.  The programmer who wishes to use arrays instead of vectors must give up  most of the useful tools CLtL provides for manipulating sequences, even  though there is no intuitive reason why operations like FILL, REPLACE,  and EVERY shouldn't work on arrays.Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:MODIFIED):  Common Lisp already provides a facility called "displaced arrays"  which can be used to overlay one array on top of a portion of another,  even if the two are of different ranks, so that the two share storage.  Emphasize this as a way of explaining the behavior of sequence   functions on certain arrays.  Modify the definition of COERCE to allow the coercion of an array to  a vector and vice versa. In keeping with p51 of CLtL, it should be an  error if the result type has a different number of elements than the  object being coerced.  Extend the definitions of sequence functions that either return their  argument sequences, return sequences which are the same shape as their  argument, or return non-sequences so that they also allow arrays iff  their action is conceptually independent of the shape of the array.  The affected functions are COUNT, SOME, EVERY, NOTANY, NOTEVERY,  FILL, REPLACE, SUBSTITUTE, NSUBSTITUTE, and MAP.  Expressly forbid arrays as arguments to other sequence functions.  These other functions are LENGTH, ELT, FIND, POSITION, REDUCE, SEARCH,  MISMATCH, REVERSE, NREVERSE, SORT, MAP, SUBSEQ, COPY-SEQ, CONCATENATE,  MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.Rationale:  This proposal would expand rather than interfere with existing practice.  Since displaced arrays are already part of Common Lisp, the cost of the  proposed changes would be very low.  If the change is not adopted, Common Lisp programmers who wish to use  arrays will have two choices.  Either they must write nested DO loops  every time they want to perform an array operation equivalent to FILL,  REPLACE, etc., or else they can build displaced vectors by hand and  pass them to the sequence functions when necessary.  This proposal extends certain sequence functions in some interesting  ways without committing us to a theory of how arrays and sequences  relate that everyone may not be happy with right now.Cost to Implementors:  This would involve a lot of changes to functions, but all of them  presumably minor. The presence of displaced arrays in the language  already guarantees that the internal storage format needed to back  up these proposed changes is already in place.Benefits:  Users of arrays do not have to use home-grown utilities to duplicate  functionality already primitively provided to users of arrays. The  sequence functions become useful in a variety of new situations.Cost to Users:  This change is `upward compatible.' User code should run unmodified.Aesthetics:  This extends certain existing sequence functions to allow arrays  as arguments in a fairly non-controversial way, leaving aside the  larger issue of whether and how to generalize the other sequence  functions.Current Practice:  Probably no one implements this now.Discussion:  A more general version of this was introduced by Touretzky but  it was rejected by X3J13.  The members of the Cleanup committee expressed interest in the ideas   behind this proposal but weren't sure they could accept it in the  proposed form. A rewrite to separate some of the issues more clearly  was solicited. Rees suggested this subset of Tourtezky's proposal  might be interesting.  Note that the function REDUCE is in a gray area. Many of its uses  are not position-dependent, but some are. The same argument might  be made about FIND. If people felt strongly, these too could be  extended either by fudging the conservative rule or by explicit  special case(s), but they have been omitted to be conservative.        TITAN 
         TITAN 
           >       !                            "              $       	                    Ë             {       7      Ó             Ù                    
       Ñ              I              Ù              )             Þ       zº*start*05618 00024 UU?Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 22:48:44 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  22:33:48 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 11 JAN 89 22:32:40 PSTDate: 11 Jan 89 22:30 PSTSender: masinter.paSubject: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 6)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinter.paline-fold: NoMessage-ID: <890111-223240-11606@Xerox>  A more general version of this was introduced by Touretzky but  it was rejected by X3J13. This has much more restricted proposal.!Issue:        SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYSReferences:   Sequences (pp245-261), COERCE (p51)Category:     ENHANCEMENTEdit history: 05-Feb-87, Version 1 by Touretzky (option GENERALIZED)	      28-Apr-87, Version 2 by Pitman (add option MODIFIED)              26-Oct-87, Version 3 by Masinter (remove MODIFIED)              11-Nov-87, Version 4 by Masinter (respond to comments)              05-Feb-88, Version 5 by Masinter	      06-Oct-88, Version 6 by Pitman 	       (revert to version 2, flush GENERALIZED option	        -- which was rejected by X3J13 -- and resurrect MODIFIED)Description:  Common Lisp provides many useful operations on lists and vectors which  don't apply to arrays.  For example, one can FILL a vector with 0's, but not an array. One can  REPLACE the contents of one vector with another, but one can't do this  for arrays.  One can verify that EVERY element of a vector has some   property, but one can't do this for arrays. And so on.  The programmer who wishes to use arrays instead of vectors must give up  most of the useful tools CLtL provides for manipulating sequences, even  though there is no intuitive reason why operations like FILL, REPLACE,  and EVERY shouldn't work on arrays.Proposal (SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS:MODIFIED):  Common Lisp already provides a facility called "displaced arrays"  which can be used to overlay one array on top of a portion of another,  even if the two are of different ranks, so that the two share storage.  Emphasize this as a way of explaining the behavior of sequence   functions on certain arrays.  Modify the definition of COERCE to allow the coercion of an array to  a vector and vice versa. In keeping with p51 of CLtL, it should be an  error if the result type has a different number of elements than the  object being coerced.  Extend the definitions of sequence functions that either return their  argument sequences, return sequences which are the same shape as their  argument, or return non-sequences so that they also allow arrays iff  their action is conceptually independent of the shape of the array.  The affected functions are COUNT, SOME, EVERY, NOTANY, NOTEVERY,  FILL, REPLACE, SUBSTITUTE, NSUBSTITUTE, and MAP.  Expressly forbid arrays as arguments to other sequence functions.  These other functions are LENGTH, ELT, FIND, POSITION, REDUCE, SEARCH,  MISMATCH, REVERSE, NREVERSE, SORT, MAP, SUBSEQ, COPY-SEQ, CONCATENATE,  MERGE, REMOVE, REMOVE-DUPLICATES, DELETE, DELETE-DUPLICATES.Rationale:  This proposal would expand rather than interfere with existing practice.  Since displaced arrays are already part of Common Lisp, the cost of the  proposed changes would be very low.  If the change is not adopted, Common Lisp programmers who wish to use  arrays will have two choices.  Either they must write nested DO loops  every time they want to perform an array operation equivalent to FILL,  REPLACE, etc., or else they can build displaced vectors by hand and  pass them to the sequence functions when necessary.  This proposal extends certain sequence functions in some interesting  ways without committing us to a theory of how arrays and sequences  relate that everyone may not be happy with right now.Cost to Implementors:  This would involve a lot of changes to functions, but all of them  presumably minor. The presence of displaced arrays in the language  already guarantees that the internal storage format needed to back  up these proposed changes is already in place.Benefits:  Users of arrays do not have to use home-grown utilities to duplicate  functionality already primitively provided to users of arrays. The  sequence functions become useful in a variety of new situations.Cost to Users:  This change is `upward compatible.' User code should run unmodified.Aesthetics:  This extends certain existing sequence functions to allow arrays  as arguments in a fairly non-controversial way, leaving aside the  larger issue of whether and how to generalize the other sequence  functions.Current Practice:  Probably no one implements this now.Discussion:  A more general version of this was introduced by Touretzky but  it was rejected by X3J13.  The members of the Cleanup committee expressed interest in the ideas   behind this proposal but weren't sure they could accept it in the  proposed form. A rewrite to separate some of the issues more clearly  was solicited. Rees suggested this subset of Tourtezky's proposal  might be interesting.  Note that the function REDUCE is in a gray area. Many of its uses  are not position-dependent, but some are. The same argument might  be made about FIND. If people felt strongly, these too could be  extended either by fudging the conservative rule or by explicit  special case(s), but they have been omitted to be conservative.*start*00755 00024 US Return-Path: <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Received: from NSS.Cs.Ucl.AC.UK ([128.41.9.3]) by Xerox.COM ; 12 JAN 89 15:04:25 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa09068; 12 Jan 89 22:56 GMTDate: Thu, 12 Jan 89 22:59:13 GMTMessage-Id: <21697.8901122259@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 6)To: cl-cleanup@sail.stanford.eduIn-Reply-To: cl-cleanup@edu.stanford.sail's message of 11 Jan 89 22:30 PSTCc: masinter.paI would prefer to have no sequence functions take arrays than todivide the sequence functions into two classes in this way.