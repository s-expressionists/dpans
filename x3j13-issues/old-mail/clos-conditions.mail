*start*09258 00024 USfReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 OCT 88 02:50:46 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 9 Oct 88  02:30:05 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 473546; Sun 9-Oct-88 05:28:47 EDTDate: Sun, 9 Oct 88 05:28 EDTFrom: CL-ERROR-HANDLING@SAIL.Stanford.EDUSender: KMP@STONY-BROOK.SCRC.Symbolics.COMSubject: Draft Issue: CLOS-CONDITIONS (Version 3)To: X3J13@SAIL.Stanford.EDUMessage-ID: <881009052832.8.KMP@BOBOLINK.SCRC.Symbolics.COM>There's been some disagreement about a couple of details, so this maychange yet again before we ask you to vote on it, but this is theversion that is likely to be presented for comment at the meeting.The conflict is represented in the writeup by the presence of twovariant proposals, YES-OPTION-A and YES-OPTION-B.-----Issue:        CLOS-CONDITIONSReferences:   Condition System (Revision 18)Category:     ADDITIONEdit history: 26-Sep-88, Version 1 by Pitman	      06-Oct-88, Version 2 by Pitman	      09-Oct-88, Version 3 by PitmanStatus:	      For Internal DiscussionProblem Description:  The description of the Common Lisp condition system presupposes  only DEFSTRUCT and not DEFCLASS because it was written when  CLOS had not been adopted. It is stylistically out of step with  CLOS in a few places and places some restrictions which are not  necessary if CLOS can be presupposed.Subproposal (CLOS-CONDITIONS:YES):  [These options are very similar. They agree except as otherwise noted.]  Define that condition types are CLOS classes.  Define that condition objects are CLOS instances.  Permit multiple parent-types to be named in the list of  parent types. Define that these parent types are treated the  same as the superior class list in a CLOS DEFCLASS expression.  Define that slots in condition objects are normal CLOS slots.  Note that WITH-SLOTS can be used to provide more convenient  access to the slots where slot accessors are undesirable.  Functions such as SIGNAL, which take arguments of class names,  are permitted to take class objects. Such class objects must  still be subclasses of CONDITION.  Eliminate the :CONC-NAME option to DEFINE-CONDITION.  Define that condition reporting is mediated through the  PRINT-OBJECT method for the condition type (class) in question,  with *PRINT-ESCAPE* always being NIL. Specifying   (:REPORT fn) in the definition of a condition type C is  equivalent to doing   (DEFMETHOD PRINT-OBJECT ((X c) STREAM)     (IF *PRINT-ESCAPE* (CALL-NEXT-METHOD) (fn X STREAM)))Proposal (CLOS-CONDITIONS:YES-OPTION-A):  All of subproposal YES, plus the following...  Extend the syntax for a slot in a DEFINE-CONDITION as follows...   - If a symbol is used, DEFINE-CONDITION will by special case     treat this as if (symbol :INITARG keyword :READER reader-name)     were specified instead, where KEYWORD is generated by	(INTERN (SYMBOL-NAME symbol) (FIND-PACKAGE "KEYWORD"))     and reader-name is generated by	(INTERN (FORMAT NIL "~A-~A" condition-type symbol))     for CONDITION-TYPE being the condition type being defined.   - A length 1 list, (symbol), is treated the same as providing     the symbol itself.   - If a length 2 list, (symbol value) is provided, it is treated     as (symbol :INITARG keyword :READER reader-name :INITFORM value),     with KEYWORD and READER-NAME being computed as above.   - If a list of length greater than 2 is used, it is treated     the same as a CLOS slot-specifier. In that case, the :INITARG     and :READER options must be explicitly specified if desired.  This syntax is compatible with the existing semantics of  DEFINE-CONDITION.  Rationale:    This provides maximal compatibilty with the old semantics    for DEFINE-CONDITION, which numerous vendors now distribute.    Further, and perhaps more importantly, the uses of slots in    DEFINE-CONDITION are highly constrained. They are not assigned    so an INITARG is nearly always needed. There are almost    universally accessed externally, so a :READER is usually    needed. This syntax makes what is by far the most convenient    use very syntactically simple.Proposal (CLOS-CONDITIONS:YES-OPTION-B):  Incompatibly change the syntax of a slot in DEFINE-CONDITION  to be compatible with a DEFCLASS slot specification.  An implication of this change is that forms like   (DEFINE-CONDITION FOO (BAR) ((A 1) (B 2)))  would have to be written   (DEFINE-CONDITION FOO (BAR) ((A :INITARG :A :READER FOO-A :INITFORM 1)			        (B :INITARG :B :READER FOO-B :INITFORM 2)))  Rationale: This is most compatible with CLOS.Examples:  Slot specifiers...    Under YES-OPTION-A ...       A slot specifier of X in condition type FOO is still valid       and means the same as (X :INITARG :X :READER FOO-X).            A slot specifier of (X) in condition type FOO is still valid       and means the same as (X :INITARG :X :READER FOO-X).            A slot specifier of (X V) in condition type FOO is still       valid and means the same as 	(X :INITARG :X :READER FOO-X :INITFORM V).              In addition, other slot specifiers such as	(X :INITARG :EX :TYPE FIXNUM)       are permitted as in DEFCLASS.       Under YES-OPTION-B ...       A slot specifier of X is still valid but is incompatibly       changed to mean what CLOS has it mean; no :INITARG or        :READER would be supplied.            A slot specifier of (X) is still valid but is incompatibly       changed to mean what CLOS has it mean; no :INITARG or        :READER would be supplied.       A slot specifier of (X V) would no longer be valid.              In addition, other slot specifiers such as	(X :INITARG :EX :TYPE FIXNUM)       are permitted as in DEFCLASS. Conc names ...   (DEFINE-CONDITION FOOBAR (FOO BAR) (X Y) (:CONC-NAME FUBAR))   would be rewritten   (DEFINE-CONDITION FOOBAR (FOO BAR)     ((X :INITARG :X :READER FUBAR-X)      (Y :INITARG :Y :READER FUBAR-Y))) Report methods ...   (DEFINE-CONDITION OOPS (ERROR) ())   (DEFMETHOD PRINT-OBJECT ((X OOPS) STREAM)     (IF *PRINT-ESCAPE* 	 (CALL-NEXT-METHOD)	 (FORMAT STREAM "Oops! Something went wrong.")))   (ERROR 'OOPS)   >>Error: Oops! Something went wrong.Rationale:  These changes are consistent with the intent of the recent  X3J13 endorsement of CLOS and the Common Lisp Condition System.  The shorthand notations for DEFINE-CONDITION's slots spec  are justified since the the way in which condition slots are  used is much more highly constrained than for arbitrary classes.  This means we can predict what will be the common case and make  it far more syntactically convenient than it might otherwise be.  Although flushing :CONC-NAME is an incompatible change, nothing  forbids an implementation from supporting it as an extension  during a transition period.Current Practice:  Some implementations supporting CLOS probably already do this,  or something very similar.Cost to Implementors:  If you really have CLOS, this is very straightforward.Cost to Users:  Small, but tractable.  The main potential problems are:   - :CONC-NAME. There is nothing that keeps an implementation from     continuing to support :CONC-NAME for a short while until old code     has been upgraded.   - The incompatible change to slot syntax. Again, it is possible to     unambiguously recognize a 2-list as old-style syntax and an     implementation can provide interim compatibility support during     a transition period.  Even if implementations did not provide the recommended compatibility  support, users could trivially shadow DEFINE-CONDITION and provide the  support themselves, expanding into the native DEFINE-CONDITION in the  proper syntax.Cost of Non-Adoption:  Conditions will seem harder to manipulate than other user-defined types.  People will wonder if CLOS is really something we're committed to.Benefits:  A more regular language.Aesthetics:  Anything that makes the language more regular improves the aesthetics.Discussion:  People seem to disagree about the status that CLOS might occupy  in the upcoming standard. In spite of a vote of support, they seem  to think it might be optional in some way. Passing this proposal  establishes a clear precedent for the full integration of CLOS into  the emerging language.  Moon suggests that we might want to add condition types for the errors  CLOS might signal. It isn't obvious (to Pitman, at least) that this   change is as straightforward as it looks, though, so it will have to  come up under separate cover.  Richard Mlynarik suggests adding a generic function, REPORT-CONDITION,  which is used for reporting conditions. It is possible to discuss such  a generic function as a separate issue layered atop the substrate which  this proposal provides, so that issue has been deferred.  Pitman supports this change, with mild preference for YES-OPTION-A.  Gregor supports this change, with strong preference for YES-OPTION-B.*start*10304 00024 USfReturn-Path: <Mly%AI.AI.MIT.EDU@XX.LCS.MIT.EDU>Received: from XX.LCS.MIT.EDU ([10.0.0.44]) by Xerox.COM ; 30 OCT 88 11:34:02 PSTReceived: from NICKB.AI.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 30 Oct 88 14:32-ESTDate: Sun, 30 Oct 88 14:34 ESTFrom: Richard Mlynarik <Mly@AI.AI.MIT.EDU>Subject: Re: Draft Issue: CLOS-CONDITIONS (Version 3)To: masinter.pacc: gregor.paIn-Reply-To: <881026-153859-14085@Xerox>Included-msgs: <19881007052142.8.MLY@JACKIE.AI.MIT.EDU>Message-ID: <19881030193406.7.MLY@NICKB.AI.MIT.EDU>Character-Type-Mappings: (1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Fonts: CPTFONT, CPTFONTI    Date: 26 Oct 88 15:38 PDT    From: masinter.pa@Xerox.COM    I thought there might be a way to word this proposal in a way that would    make the error/signal system *compatible* with CLOS but not to actually    make it require the low-level implementation to *use* CLOS if it didn't    want to. Many vendors are only now working on integrating CLOS into their    environment. A lot of the concern is for "staging" the introduction of CLOS    and the condition system. This is also a concern for those with existing    implementations where they might want to load in the CLOS support late in    the system-building process, and yet use the condition system early in that    process. While this is an implementation detail, the implementation    ramifications of your proposal need to be spelled out.    [...]I sent the following comments to Pitman.I guess I don't really care that much about this anymore, since I thinkthat the error Standard is pretty broken.  The phrase ``swimming upwaterfalls'' comes to mind.Date: Fri, 7 Oct 88 01:21 EDTFrom: Richard Mlynarik <MLY@AI.AI.MIT.EDU>Subject: Issue: CLOS-CONDITIONS (Version 2)To: KMP@STONY-BROOK.SCRC.SYMBOLICS.COMcc: Moon@STONY-BROOK.SCRC.SYMBOLICS.COMIn-Reply-To: <881006162757.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19881007052142.8.MLY@JACKIE.AI.MIT.EDU>[Mailing list removed]I had promised myself that I would have no more to do with thisError Standard but nevertheless...    Date: Thu, 6 Oct 88 16:27 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>      The description of the Common Lisp condition system presupposes      only DEFSTRUCT and not DEFCLASS because it was written when      CLOS had not been adopted. It is stylistically out of step with      CLOS in a few places and places some restrictions which are not      necessary if CLOS can be presupposed.    Proposal (CLOS-CONDITIONS:YES):      Define that condition types are CLOS classes.      Define that condition objects are CLOS instances.This is certainly desirable.  However, it ignores a pragmatic problem:* Even though CLOS has been adopted, it is not widely supported.  (Support means `supplied by vendors' rather than `you can use PCL')* The error system is much simpler to implement than CLOS.  The error system is perceived to be more critical than CLOS.  (For example, I believe that Lucid supply an implementation of  something like KMP's error system in their 3.0 Lisp release.  They do  not supply any CLOS or CLOS-precursor support as far as I know.)Therefore...It would be nice if the standard were worded in such a way that itallowed a non-CLOS implementation.  Given that the only`object-oriented' features that the error standard requires are* TYPEP* slot inheritance* report-function inheritance (with no method-combination)and since it is very easy to write a toy class system which implementsjust those features, let me suggest that the DEFINE-CONDITION macro notimplicitly define :READERs.  Readers presuppose CLOS generic functions alittle too much.  I feel that a better (interim -- all discussion hereis interim) solution would be to define the function SLOT-VALUE in thespec.  KMP-CONDITION-SYSTEM:SLOT-VALUE will be EQ CLOS:SLOT-VALUE inLisp implementations which include a CLOS implementation.Please note that I am in no way trying to deprecate acceptance or usageof CLOS -- I want to see it as an integral part of Common Lisp(especially if define-method-combination worked properly by usingclosures instead of manipulating list structure... :-)      Permit multiple parent-types to be named in the list of      parent types. Define that these parent types are treated the      same as the superior class list in a CLOS DEFCLASS expression.You should explicitly state that the class precedence list is computedin the way CLOS specifies.      Extend the syntax for a slot in a DEFINE-CONDITION as follows...       - If a symbol is used, DEFINE-CONDITION will by special case	 treat this as if (symbol :INITARG keyword :READER reader-name)	 were specified instead, where KEYWORD is generated by	    (INTERN (SYMBOL-NAME symbol) (FIND-PACKAGE "KEYWORD"))	 and reader-name is generated by	    (INTERN (FORMAT NIL "~A-~A" condition-type symbol))	 for CONDITION-TYPE being the condition type being defined.       - A length 1 list, (symbol), is treated the same as providing	 the symbol itself.       - If a length 2 list, (symbol value) is provided, it is treated	 as (symbol :INITARG keyword :READER reader-name :INITFORM value),	 with KEYWORD and READER-NAME being computed as above.       - If a list of length greater than 2 is used, it is treated	 the same as a CLOS slot-specifier. In that case, the :INITARG	 and :READER options must be explicitly specified if desired.I think that this is highly undesirable wording to place in thespecification (but then, it wouldn't be the first time I've thoughtthat.)I really don't think that your Standard is entrenched far enoughthat backwards compatibility is an issue in its definition.  Note thatwhether individual 1implementations0 wish to offer such abackward-compatibility feature is a different matter.DEFINE-CONDITION (like statice:define-entity-type...) should require theuse of the standard :INITFORM option.  I'm of two minds about whetherDEFINE-CONDITION should default the :INITARG.  I lean towards having itdo so, with the prosiso that the initarg be exactly the symbol, *NOT* akeyword.  My reasons for this are as follows:* I can't think of a single case in which it is undesirable for the  caller of MAKE-CONDITION to be able to specify the value of a slot.* Given that there exists a DEFINE-CONDITION macro (distinct from  DEFCLASS) we might as well make it do things that are useful for  conditions.  (While we're at it, we should make it support  :required-initargs -- only 1/4 joking.)  I think this argues for defaulting the :INITARG option.* (intern ... (find-package "KEYWORD")) is just asking for disaster.  Major disaster.  The sort of disaster which non-keyword initargs were  invented to avoid in the first place.  Just Say No!  (BTW, this doesn't pose much of a compatibility problem.  A  backwards-compatible DEFINE-CONDITION can recognise  slot-specifications of the obsolete forms <name> and (<name> <initform>)  and default the :INITARG in these cases to the losing keyword.  There remains the problem of (<name>)...)      Functions such as SIGNAL, which take arguments of class names,      are permitted to take class objects.Presumably it is an error to pass something which is not a subclass ofCONDITION.      Eliminate the :CONC-NAME option to DEFINE-CONDITION.Strongly agreed.      Define that condition reporting is mediated through the      PRINT-OBJECT method for the condition type (class) in question,      with *PRINT-ESCAPE* always being NIL. Specifying       (:REPORT fn) in the definition of a condition type C is      equivalent to doing       (DEFMETHOD PRINT-OBJECT ((X c) STREAM)	 (IF *PRINT-ESCAPE* (CALL-NEXT-METHOD) (fn X STREAM)))I think that this is a very bad move.A much better idea is the define something like DBG:REPORT, which isonly called in the PRINC case.  Otherwise every time a user wants towrite a method to affect the way a condition reports itself she must gothrough the (if *print-escape* (call-next-method) ...) crap.I suggest(defgeneric report-condition (condition stream &key verbosely))[BTW the reason for the :VERBOSELY keyword is in case you have ever seemthe error messages from ILA-NFS -- there is no way to control whetherthey print a dozen lines explaining every possible conceivable cause ofthe problem (which is appropriate when the debugger is entered, forexample) or whether they should just summarise the problem (which isappropriate when the ":Copy File" command reports that it was unable tocopy one particular file.)]Having the :VERBOSELY keyword can't hurt anything, and it provides a wayto avoid horrible inappropriate verbosity.Another reason for defining a new generic function and not reusingPRINT-OBJECT is that that 1does0 provide a way to add extra options like:VERBOSELY.    Examples:     [...]     Report methods ...       (DEFMETHOD PRINT-OBJECT ((X OOPS) STREAM)	 (IF *PRINT-ESCAPE* 	     (CALL-NEXT-METHOD)	     (FORMAT STREAM "Oops! Something went wrong.")))I think this is a good example of the lossage I described above.    [...]    Discussion:      People seem to disagree about the status that CLOS might occupy      in the upcoming standard. In spite of a vote of support, they seem      to think it might be optional in some way. Passing this proposal      establishes a clear precedent for the full integration of CLOS into      the emerging language.As I said above, I completely agree with this.  However, the pragmaticsof the next year or so -- in which users will likely be offeredvendor-supported Error Standard implementations but not vendor-supportedCLOS -- argue for the sort of minor change I suggested above.Finally, in <881006184006.0.KMP@BOBOLINK.SCRC.Symbolics.COM> you replyto Gregor:   Also, it's no different than what DEFSTRUCT does, so it's not like this   is the only place in the language following those rules. Have you   submitted a proposal to deprecate DEFSTRUCT?I think this is a highly spurious argument.  There is no reason to prepetuatethe bad design of DEFSTRUCT.  (I have never heard anybody argue that themandatory default-value in defstruct slot syntax is anything but amistake.)*start*20375 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 FEB 89 22:33:10 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 3 Feb 89  22:32:31 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 03 FEB 89 22:30:55 PSTDate: 3 Feb 89 22:30 PSTFrom: masinter.paSubject: Issue: CLOS-CONDITIONS (Version 3)To: cl-cleanup@sail.stanford.eduline-fold: NOMessage-ID: <890203-223055-2803@Xerox>I believe I agreed that the cleanup committee would take over this issue. It was discussed in the Error Committee report at a previous meeting in 1988, but not voted on at the time.As you can see, there are comments...     ----- Begin Forwarded Messages -----Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 OCT 88 02:50:46 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 9 Oct 88  02:30:05 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 473546; Sun 9-Oct-88 05:28:47 EDTDate: Sun, 9 Oct 88 05:28 EDTFrom: CL-ERROR-HANDLING@SAIL.Stanford.EDUSender: KMP@STONY-BROOK.SCRC.Symbolics.COMSubject: Draft Issue: CLOS-CONDITIONS (Version 3)To: X3J13@SAIL.Stanford.EDUMessage-ID: <881009052832.8.KMP@BOBOLINK.SCRC.Symbolics.COM>There's been some disagreement about a couple of details, so this maychange yet again before we ask you to vote on it, but this is theversion that is likely to be presented for comment at the meeting.The conflict is represented in the writeup by the presence of twovariant proposals, YES-OPTION-A and YES-OPTION-B.-----Issue:        CLOS-CONDITIONSReferences:   Condition System (Revision 18)Category:     ADDITIONEdit history: 26-Sep-88, Version 1 by Pitman	      06-Oct-88, Version 2 by Pitman	      09-Oct-88, Version 3 by PitmanStatus:	      For Internal DiscussionProblem Description:  The description of the Common Lisp condition system presupposes  only DEFSTRUCT and not DEFCLASS because it was written when  CLOS had not been adopted. It is stylistically out of step with  CLOS in a few places and places some restrictions which are not  necessary if CLOS can be presupposed.Subproposal (CLOS-CONDITIONS:YES):  [These options are very similar. They agree except as otherwise noted.]  Define that condition types are CLOS classes.  Define that condition objects are CLOS instances.  Permit multiple parent-types to be named in the list of  parent types. Define that these parent types are treated the  same as the superior class list in a CLOS DEFCLASS expression.  Define that slots in condition objects are normal CLOS slots.  Note that WITH-SLOTS can be used to provide more convenient  access to the slots where slot accessors are undesirable.  Functions such as SIGNAL, which take arguments of class names,  are permitted to take class objects. Such class objects must  still be subclasses of CONDITION.  Eliminate the :CONC-NAME option to DEFINE-CONDITION.  Define that condition reporting is mediated through the  PRINT-OBJECT method for the condition type (class) in question,  with *PRINT-ESCAPE* always being NIL. Specifying   (:REPORT fn) in the definition of a condition type C is  equivalent to doing   (DEFMETHOD PRINT-OBJECT ((X c) STREAM)     (IF *PRINT-ESCAPE* (CALL-NEXT-METHOD) (fn X STREAM)))Proposal (CLOS-CONDITIONS:YES-OPTION-A):  All of subproposal YES, plus the following...  Extend the syntax for a slot in a DEFINE-CONDITION as follows...   - If a symbol is used, DEFINE-CONDITION will by special case     treat this as if (symbol :INITARG keyword :READER reader-name)     were specified instead, where KEYWORD is generated by	(INTERN (SYMBOL-NAME symbol) (FIND-PACKAGE "KEYWORD"))     and reader-name is generated by	(INTERN (FORMAT NIL "~A-~A" condition-type symbol))     for CONDITION-TYPE being the condition type being defined.   - A length 1 list, (symbol), is treated the same as providing     the symbol itself.   - If a length 2 list, (symbol value) is provided, it is treated     as (symbol :INITARG keyword :READER reader-name :INITFORM value),     with KEYWORD and READER-NAME being computed as above.   - If a list of length greater than 2 is used, it is treated     the same as a CLOS slot-specifier. In that case, the :INITARG     and :READER options must be explicitly specified if desired.  This syntax is compatible with the existing semantics of  DEFINE-CONDITION.  Rationale:    This provides maximal compatibilty with the old semantics    for DEFINE-CONDITION, which numerous vendors now distribute.    Further, and perhaps more importantly, the uses of slots in    DEFINE-CONDITION are highly constrained. They are not assigned    so an INITARG is nearly always needed. There are almost    universally accessed externally, so a :READER is usually    needed. This syntax makes what is by far the most convenient    use very syntactically simple.Proposal (CLOS-CONDITIONS:YES-OPTION-B):  Incompatibly change the syntax of a slot in DEFINE-CONDITION  to be compatible with a DEFCLASS slot specification.  An implication of this change is that forms like   (DEFINE-CONDITION FOO (BAR) ((A 1) (B 2)))  would have to be written   (DEFINE-CONDITION FOO (BAR) ((A :INITARG :A :READER FOO-A :INITFORM 1)			        (B :INITARG :B :READER FOO-B :INITFORM 2)))  Rationale: This is most compatible with CLOS.Examples:  Slot specifiers...    Under YES-OPTION-A ...       A slot specifier of X in condition type FOO is still valid       and means the same as (X :INITARG :X :READER FOO-X).            A slot specifier of (X) in condition type FOO is still valid       and means the same as (X :INITARG :X :READER FOO-X).            A slot specifier of (X V) in condition type FOO is still       valid and means the same as 	(X :INITARG :X :READER FOO-X :INITFORM V).              In addition, other slot specifiers such as	(X :INITARG :EX :TYPE FIXNUM)       are permitted as in DEFCLASS.       Under YES-OPTION-B ...       A slot specifier of X is still valid but is incompatibly       changed to mean what CLOS has it mean; no :INITARG or        :READER would be supplied.            A slot specifier of (X) is still valid but is incompatibly       changed to mean what CLOS has it mean; no :INITARG or        :READER would be supplied.       A slot specifier of (X V) would no longer be valid.              In addition, other slot specifiers such as	(X :INITARG :EX :TYPE FIXNUM)       are permitted as in DEFCLASS. Conc names ...   (DEFINE-CONDITION FOOBAR (FOO BAR) (X Y) (:CONC-NAME FUBAR))   would be rewritten   (DEFINE-CONDITION FOOBAR (FOO BAR)     ((X :INITARG :X :READER FUBAR-X)      (Y :INITARG :Y :READER FUBAR-Y))) Report methods ...   (DEFINE-CONDITION OOPS (ERROR) ())   (DEFMETHOD PRINT-OBJECT ((X OOPS) STREAM)     (IF *PRINT-ESCAPE* 	 (CALL-NEXT-METHOD)	 (FORMAT STREAM "Oops! Something went wrong.")))   (ERROR 'OOPS)   >>Error: Oops! Something went wrong.Rationale:  These changes are consistent with the intent of the recent  X3J13 endorsement of CLOS and the Common Lisp Condition System.  The shorthand notations for DEFINE-CONDITION's slots spec  are justified since the the way in which condition slots are  used is much more highly constrained than for arbitrary classes.  This means we can predict what will be the common case and make  it far more syntactically convenient than it might otherwise be.  Although flushing :CONC-NAME is an incompatible change, nothing  forbids an implementation from supporting it as an extension  during a transition period.Current Practice:  Some implementations supporting CLOS probably already do this,  or something very similar.Cost to Implementors:  If you really have CLOS, this is very straightforward.Cost to Users:  Small, but tractable.  The main potential problems are:   - :CONC-NAME. There is nothing that keeps an implementation from     continuing to support :CONC-NAME for a short while until old code     has been upgraded.   - The incompatible change to slot syntax. Again, it is possible to     unambiguously recognize a 2-list as old-style syntax and an     implementation can provide interim compatibility support during     a transition period.  Even if implementations did not provide the recommended compatibility  support, users could trivially shadow DEFINE-CONDITION and provide the  support themselves, expanding into the native DEFINE-CONDITION in the  proper syntax.Cost of Non-Adoption:  Conditions will seem harder to manipulate than other user-defined types.  People will wonder if CLOS is really something we're committed to.Benefits:  A more regular language.Aesthetics:  Anything that makes the language more regular improves the aesthetics.Discussion:  People seem to disagree about the status that CLOS might occupy  in the upcoming standard. In spite of a vote of support, they seem  to think it might be optional in some way. Passing this proposal  establishes a clear precedent for the full integration of CLOS into  the emerging language.  Moon suggests that we might want to add condition types for the errors  CLOS might signal. It isn't obvious (to Pitman, at least) that this   change is as straightforward as it looks, though, so it will have to  come up under separate cover.  Richard Mlynarik suggests adding a generic function, REPORT-CONDITION,  which is used for reporting conditions. It is possible to discuss such  a generic function as a separate issue layered atop the substrate which  this proposal provides, so that issue has been deferred.  Pitman supports this change, with mild preference for YES-OPTION-A.  Gregor supports this change, with strong preference for YES-OPTION-B.     ----- Next Message -----Return-Path: <Mly%AI.AI.MIT.EDU@XX.LCS.MIT.EDU>Received: from XX.LCS.MIT.EDU ([10.0.0.44]) by Xerox.COM ; 30 OCT 88 11:34:02 PSTReceived: from NICKB.AI.MIT.EDU by XX.LCS.MIT.EDU via Chaosnet; 30 Oct 88 14:32-ESTDate: Sun, 30 Oct 88 14:34 ESTFrom: Richard Mlynarik <Mly@AI.AI.MIT.EDU>Subject: Re: Draft Issue: CLOS-CONDITIONS (Version 3)To: masinter.pacc: gregor.paIn-Reply-To: <881026-153859-14085@Xerox>Included-msgs: <19881007052142.8.MLY@JACKIE.AI.MIT.EDU>Message-ID: <19881030193406.7.MLY@NICKB.AI.MIT.EDU>Character-Type-Mappings: (1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Fonts: CPTFONT, CPTFONTI    Date: 26 Oct 88 15:38 PDT    From: masinter.pa@Xerox.COM    I thought there might be a way to word this proposal in a way that would    make the error/signal system *compatible* with CLOS but not to actually    make it require the low-level implementation to *use* CLOS if it didn't    want to. Many vendors are only now working on integrating CLOS into their    environment. A lot of the concern is for "staging" the introduction of CLOS    and the condition system. This is also a concern for those with existing    implementations where they might want to load in the CLOS support late in    the system-building process, and yet use the condition system early in that    process. While this is an implementation detail, the implementation    ramifications of your proposal need to be spelled out.    [...]I sent the following comments to Pitman.I guess I don't really care that much about this anymore, since I thinkthat the error Standard is pretty broken.  The phrase ``swimming upwaterfalls'' comes to mind.Date: Fri, 7 Oct 88 01:21 EDTFrom: Richard Mlynarik <MLY@AI.AI.MIT.EDU>Subject: Issue: CLOS-CONDITIONS (Version 2)To: KMP@STONY-BROOK.SCRC.SYMBOLICS.COMcc: Moon@STONY-BROOK.SCRC.SYMBOLICS.COMIn-Reply-To: <881006162757.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19881007052142.8.MLY@JACKIE.AI.MIT.EDU>[Mailing list removed]I had promised myself that I would have no more to do with thisError Standard but nevertheless...    Date: Thu, 6 Oct 88 16:27 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>      The description of the Common Lisp condition system presupposes      only DEFSTRUCT and not DEFCLASS because it was written when      CLOS had not been adopted. It is stylistically out of step with      CLOS in a few places and places some restrictions which are not      necessary if CLOS can be presupposed.    Proposal (CLOS-CONDITIONS:YES):      Define that condition types are CLOS classes.      Define that condition objects are CLOS instances.This is certainly desirable.  However, it ignores a pragmatic problem:* Even though CLOS has been adopted, it is not widely supported.  (Support means `supplied by vendors' rather than `you can use PCL')* The error system is much simpler to implement than CLOS.  The error system is perceived to be more critical than CLOS.  (For example, I believe that Lucid supply an implementation of  something like KMP's error system in their 3.0 Lisp release.  They do  not supply any CLOS or CLOS-precursor support as far as I know.)Therefore...It would be nice if the standard were worded in such a way that itallowed a non-CLOS implementation.  Given that the only`object-oriented' features that the error standard requires are* TYPEP* slot inheritance* report-function inheritance (with no method-combination)and since it is very easy to write a toy class system which implementsjust those features, let me suggest that the DEFINE-CONDITION macro notimplicitly define :READERs.  Readers presuppose CLOS generic functions alittle too much.  I feel that a better (interim -- all discussion hereis interim) solution would be to define the function SLOT-VALUE in thespec.  KMP-CONDITION-SYSTEM:SLOT-VALUE will be EQ CLOS:SLOT-VALUE inLisp implementations which include a CLOS implementation.Please note that I am in no way trying to deprecate acceptance or usageof CLOS -- I want to see it as an integral part of Common Lisp(especially if define-method-combination worked properly by usingclosures instead of manipulating list structure... :-)      Permit multiple parent-types to be named in the list of      parent types. Define that these parent types are treated the      same as the superior class list in a CLOS DEFCLASS expression.You should explicitly state that the class precedence list is computedin the way CLOS specifies.      Extend the syntax for a slot in a DEFINE-CONDITION as follows...       - If a symbol is used, DEFINE-CONDITION will by special case	 treat this as if (symbol :INITARG keyword :READER reader-name)	 were specified instead, where KEYWORD is generated by	    (INTERN (SYMBOL-NAME symbol) (FIND-PACKAGE "KEYWORD"))	 and reader-name is generated by	    (INTERN (FORMAT NIL "~A-~A" condition-type symbol))	 for CONDITION-TYPE being the condition type being defined.       - A length 1 list, (symbol), is treated the same as providing	 the symbol itself.       - If a length 2 list, (symbol value) is provided, it is treated	 as (symbol :INITARG keyword :READER reader-name :INITFORM value),	 with KEYWORD and READER-NAME being computed as above.       - If a list of length greater than 2 is used, it is treated	 the same as a CLOS slot-specifier. In that case, the :INITARG	 and :READER options must be explicitly specified if desired.I think that this is highly undesirable wording to place in thespecification (but then, it wouldn't be the first time I've thoughtthat.)I really don't think that your Standard is entrenched far enoughthat backwards compatibility is an issue in its definition.  Note thatwhether individual 1implementations0 wish to offer such abackward-compatibility feature is a different matter.DEFINE-CONDITION (like statice:define-entity-type...) should require theuse of the standard :INITFORM option.  I'm of two minds about whetherDEFINE-CONDITION should default the :INITARG.  I lean towards having itdo so, with the prosiso that the initarg be exactly the symbol, *NOT* akeyword.  My reasons for this are as follows:* I can't think of a single case in which it is undesirable for the  caller of MAKE-CONDITION to be able to specify the value of a slot.* Given that there exists a DEFINE-CONDITION macro (distinct from  DEFCLASS) we might as well make it do things that are useful for  conditions.  (While we're at it, we should make it support  :required-initargs -- only 1/4 joking.)  I think this argues for defaulting the :INITARG option.* (intern ... (find-package "KEYWORD")) is just asking for disaster.  Major disaster.  The sort of disaster which non-keyword initargs were  invented to avoid in the first place.  Just Say No!  (BTW, this doesn't pose much of a compatibility problem.  A  backwards-compatible DEFINE-CONDITION can recognise  slot-specifications of the obsolete forms <name> and (<name> <initform>)  and default the :INITARG in these cases to the losing keyword.  There remains the problem of (<name>)...)      Functions such as SIGNAL, which take arguments of class names,      are permitted to take class objects.Presumably it is an error to pass something which is not a subclass ofCONDITION.      Eliminate the :CONC-NAME option to DEFINE-CONDITION.Strongly agreed.      Define that condition reporting is mediated through the      PRINT-OBJECT method for the condition type (class) in question,      with *PRINT-ESCAPE* always being NIL. Specifying       (:REPORT fn) in the definition of a condition type C is      equivalent to doing       (DEFMETHOD PRINT-OBJECT ((X c) STREAM)	 (IF *PRINT-ESCAPE* (CALL-NEXT-METHOD) (fn X STREAM)))I think that this is a very bad move.A much better idea is the define something like DBG:REPORT, which isonly called in the PRINC case.  Otherwise every time a user wants towrite a method to affect the way a condition reports itself she must gothrough the (if *print-escape* (call-next-method) ...) crap.I suggest(defgeneric report-condition (condition stream &key verbosely))[BTW the reason for the :VERBOSELY keyword is in case you have ever seemthe error messages from ILA-NFS -- there is no way to control whetherthey print a dozen lines explaining every possible conceivable cause ofthe problem (which is appropriate when the debugger is entered, forexample) or whether they should just summarise the problem (which isappropriate when the ":Copy File" command reports that it was unable tocopy one particular file.)]Having the :VERBOSELY keyword can't hurt anything, and it provides a wayto avoid horrible inappropriate verbosity.Another reason for defining a new generic function and not reusingPRINT-OBJECT is that that 1does0 provide a way to add extra options like:VERBOSELY.    Examples:     [...]     Report methods ...       (DEFMETHOD PRINT-OBJECT ((X OOPS) STREAM)	 (IF *PRINT-ESCAPE* 	     (CALL-NEXT-METHOD)	     (FORMAT STREAM "Oops! Something went wrong.")))I think this is a good example of the lossage I described above.    [...]    Discussion:      People seem to disagree about the status that CLOS might occupy      in the upcoming standard. In spite of a vote of support, they seem      to think it might be optional in some way. Passing this proposal      establishes a clear precedent for the full integration of CLOS into      the emerging language.As I said above, I completely agree with this.  However, the pragmaticsof the next year or so -- in which users will likely be offeredvendor-supported Error Standard implementations but not vendor-supportedCLOS -- argue for the sort of minor change I suggested above.Finally, in <881006184006.0.KMP@BOBOLINK.SCRC.Symbolics.COM> you replyto Gregor:   Also, it's no different than what DEFSTRUCT does, so it's not like this   is the only place in the language following those rules. Have you   submitted a proposal to deprecate DEFSTRUCT?I think this is a highly spurious argument.  There is no reason to prepetuatethe bad design of DEFSTRUCT.  (I have never heard anybody argue that themandatory default-value in defstruct slot syntax is anything but amistake.)     ----- End Forwarded Messages -----*start*01028 00024 US Date: Sun, 5 Feb 89 11:07 PSTFrom: Gregor.paSubject: Issue: CLOS-CONDITIONS (Version 3)To: masinter.pacc: cl-cleanup@sail.stanford.eduFcc: BD:>Gregor>mail>outgoing-mail-5.text.newestIn-Reply-To: <890203-223055-2803@Xerox>Message-ID: <19890205190724.0.GREGOR@SPIFF.parc.xerox.com>Line-fold: noThis needs to say a little bit more than that condition types are CLOSclasses.  We already new they were classes since they were types definedby defstruct.What we need to know is what the metaclass is.  That is crucialinformation because it is what allows people to include classes thatwere not defined with define-condition in their condition classes.BTW, if you want a concise version of my rational for B over A its: "The best argument for adding list function specifiers to the  language was to avoid the problems caused by automaticall  creating and interning symbols.  That argument must also be  strong to eliminate automatically generated symbols from  define-condition."-------*start*00810 00024 US Date:  6 Feb 89 11:57 PSTFrom: masinter.paSubject: Re: Issue: CLOS-CONDITIONS (Version 3)In-reply-to: your message of Mon, 6 Feb 89 13:40 ESTTo: Richard Mlynarik <Mly@AI.AI.MIT.EDU>cc: masinter.paI'm sorry. I usually try to be careful, and get quite annoyed myself when people forward my private mail to a distribution.I don't know what more I can say, except to repeat my apology.I don't want to get involved in flame wars either. I think that if the current situation invokes flames, it needs correction. At the very least, I should have moderated your comments by making them anonymous.I'll point out to the distribution list that your remarks, while addressed privately and couched informally, should be taken seriously, if you don't object...Again, sorry...Larry*start*01864 00024 USaReturn-Path: <@REAGAN.AI.MIT.EDU:Mly@AI.AI.MIT.EDU>Received: from REAGAN.AI.MIT.EDU ([128.52.22.53]) by Xerox.COM ; 06 FEB 89 10:42:03 PSTReceived: from ALMA-MAHLER.AI.MIT.EDU by REAGAN.AI.MIT.EDU via CHAOS with CHAOS-MAIL id 171092; Mon 6-Feb-89 13:41:07 ESTDate: Mon, 6 Feb 89 13:40 ESTFrom: Richard Mlynarik <Mly@AI.AI.MIT.EDU>Subject: Issue: CLOS-CONDITIONS (Version 3)To: masinter.pacc: Mly@AI.AI.MIT.EDUIn-Reply-To: <890203-223055-2803@Xerox>Message-ID: <19890206184030.1.MLY@ALMA-MAHLER.AI.MIT.EDU>    Date: 3 Feb 89 22:30 PST    From: masinter.pa@Xerox.COM    I believe I agreed that the cleanup committee would take over this issue. It was discussed in the Error Committee report at a previous meeting in 1988, but not voted on at the time.    As you can see, there are comments...    [...]Larry,The comments I forwarded to you were private mail, sent at your request.If Pitman And His Error-Handling Committee want to ignore comments I maketo them in private mail, that's fine -- I don't want to be seen asattempting to make noise through the technique of sending mail to youinstead.  If I'd wanted to make an issue of it I could have sent mailto CL-Cleanup myself.I really really don't want to get involved in CL-Cleanup or in any flamewars.  I have more productive and interesting things to do.Regardless of which, I'm quite unhappy that you included my preparatorycomments, which were addressed to you and Gregor and have little technicalrelevance to the issue at hand.  It's not that I try to hide my opinions,or that I think that electronic mail is in any sense private -- it's justthat I wouldn't write in the same manner when addressing the large andquasi-technical recipient list of CL-Cleanup as I would when sendingprivate mail to two individuals.Thanks for your understanding.*start*01731 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 FEB 89 06:57:24 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 9 Feb 89  06:56:53 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01831g; Thu, 9 Feb 89 06:51:15 PSTReceived: by bhopal id AA05327g; Thu, 9 Feb 89 06:53:37 PSTDate: Thu, 9 Feb 89 06:53:37 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8902091453.AA05327@bhopal>To: Gregor.paCc: masinter.pa, cl-cleanup@sail.stanford.eduIn-Reply-To: Gregor.pa@Xerox.COM's message of Sun, 5 Feb 89 11:07 PST <19890205190724.0.GREGOR@SPIFF.parc.xerox.com>Subject: Issue: CLOS-CONDITIONS (Version 3)re: BTW, if you want a concise version of my rational for B over A its:     "The best argument for adding list function specifiers to the      language was to avoid the problems caused by automaticall      creating and interning symbols.  That argument must also be      strong to eliminate automatically generated symbols from      define-condition."Agreed.  At Lucid, we have had bug reports (as well as confusionreports?)  due to the symbol-concing nature of DEFINE-CONDITION.  We'veperpretated a "50%" fix, and declined to do a "90%" fix on the theorythat when conditions become classes, the need for symbol concing will begone.  Let it be gone, even at the expense of a minor incompatibilitywith "old" error syntax.  [After all, this "old" error system is "brandnew" to almost all CL users; and many of those using it are aware thatthe current implementations may change slightly when the final ANSIstandard is published).-- JonL --*start*00827 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 FEB 89 16:16:08 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Feb 89  16:15:19 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 FEB 89 16:09:30 PSTDate: 14 Feb 89 16:07 PSTFrom: masinter.paSubject: Re: Issue: CLOS-CONDITIONS (Version 3)To: cl-cleanup@sail.stanford.eduMessage-ID: <890214-160930-10914@Xerox>We need a new version of this proposal that includes option B instead ofoption A, and that summarizes some of the arguments recieved. It would benice if it could address the issue of error-system-bootstrapping etc thathas concerned some of the community.First rights go to KMP, as the last author. Kent?*start*00827 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 FEB 89 16:16:08 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Feb 89  16:15:19 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 FEB 89 16:09:30 PSTDate: 14 Feb 89 16:07 PSTFrom: masinter.paSubject: Re: Issue: CLOS-CONDITIONS (Version 3)To: cl-cleanup@sail.stanford.eduMessage-ID: <890214-160930-10914@Xerox>We need a new version of this proposal that includes option B instead ofoption A, and that summarizes some of the arguments recieved. It would benice if it could address the issue of error-system-bootstrapping etc thathas concerned some of the community.First rights go to KMP, as the last author. Kent?*start*01177 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 09 MAR 89 11:07:02 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 553826; Thu 9-Mar-89 14:06:34 ESTDate: Thu, 9 Mar 89 14:06 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: CLOS-CONDITIONS (Version 3)To: masinter.pa, KMP@STONY-BROOK.SCRC.Symbolics.COMcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <890203-223055-2803@Xerox>Message-ID: <19890309190624.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI favor CLOS-CONDITIONS:YES-OPTION-B, even though it's moreverbose, because it makes for a more consistent language.I don't think the compatibility issue is important since we'reonly talking about being compatible with a prototype that somepeople have used, not being compatible with a widely usedstandard.  Essentially, I agree with JonL's comment of 9 Feb.Would it make sense to offer only YES-OPTION-B to the wholeX3J13 committee, in order to limit the length of the discussion?Or is that excessively Fascist?*start*02082 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 11:28:01 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 9 Mar 89  11:23:31 PSTReceived: from mist.encore.COM by multimax.encore.com with SMTP (5.61/25-eef)	id AA04368; Thu, 9 Mar 89 14:21:59 -0500Received: from localhost by mist. (4.0/SMI-4.0)	id AA00548; Thu, 9 Mar 89 14:19:30 ESTMessage-Id: <8903091919.AA00548@mist.>To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: CLOS-CONDITIONS (Version 3) In-Reply-To: Your message of Thu, 09 Mar 89 14:06:00 -0500.             <19890309190624.4.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Thu, 09 Mar 89 14:19:28 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    I favor CLOS-CONDITIONS:YES-OPTION-B, even though it's more    verbose, because it makes for a more consistent language.    I don't think the compatibility issue is important since we're    only talking about being compatible with a prototype that some    people have used, not being compatible with a widely used    standard.  Essentially, I agree with JonL's comment of 9 Feb.    Even though I personally prefer the aesthetics of YES-OPTION-A, JonLand Gregor have made a very strong case for YES-OPTION-B so I nowsupport it instead.    Would it make sense to offer only YES-OPTION-B to the whole    X3J13 committee, in order to limit the length of the discussion?    Or is that excessively Fascist?    The comments I got from non-cleanup members at Kuaui were that cleanupshould be making more decisions and giving more guidance.  Some evenwent to far as to say we had done a poor job because we didn't have anexplicit recomendation from cleanup attached to every issue.Let's just present YES-OPTION-B and concentrate on dealing with moredifficult objections such as Thom Linden's (the policy ofCLOSification must be decided in general before voting in any piece ofit). *start*01939 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 09 MAR 89 15:25:19 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 554211; Thu 9-Mar-89 18:24:42 ESTDate: Thu, 9 Mar 89 18:24 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: CLOS-CONDITIONS (Version 3)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: masinter.pa, KMP@STONY-BROOK.SCRC.Symbolics.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: <19890309190624.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <890309182425.5.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Thu, 9 Mar 89 14:06 EST    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    I favor CLOS-CONDITIONS:YES-OPTION-B, even though it's more    verbose, because it makes for a more consistent language.    I don't think the compatibility issue is important since we're    only talking about being compatible with a prototype that some    people have used, not being compatible with a widely used    standard.  Essentially, I agree with JonL's comment of 9 Feb.    Would it make sense to offer only YES-OPTION-B to the whole    X3J13 committee, in order to limit the length of the discussion?    Or is that excessively Fascist?If no one had been given the opportunity to present an alternative,it would be too fascist, I think.  However, people have had two meetingsworth of time to react and no one has championed the alternate proposal.My feeling is that option B wins over option A because although itis syntactically more cumbersome in a few cases, it does away withthe `symbolconcing' feature, which is a real conceptual nightmare,and because it regularizes the set of rules that people have to learn.I will flush option A in a proposal to be written tomorrow unless someone advances cause not to.*start*07566 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 MAR 89 11:10:31 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Mar 89  11:09:41 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 554683; Fri 10-Mar-89 14:07:19 ESTDate: Fri, 10 Mar 89 14:07 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: CLOS-CONDITIONS (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890310140701.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Ok, it's `tomorrow' and no one protested so I did a quick overhaulof this to remove the dead wood.I did not deliberately change the content of anything, but it wouldhelp if someone would read it top to bottom for continuity just tobe sure I didn't screw it up. I mainly changed the Rationale andDiscussion, and smoothed some wording here and there where thingsgot elimiated.If anyone else wants to add commentary pro or con, they should sayso now.If no one says anything, I'll assume this is ready to ship. -kmp-----Issue:        CLOS-CONDITIONSReferences:   Condition System (Revision 18)Category:     ADDITIONEdit history: 26-Sep-88, Version 1 by Pitman	      06-Oct-88, Version 2 by Pitman	      09-Oct-88, Version 3 by Pitman	      10-Mar-89, Version 4 by Pitman (remove unsupported options)Status:	      For Internal DiscussionProblem Description:  The description of the Common Lisp condition system presupposes  only DEFSTRUCT and not DEFCLASS because it was written when  CLOS had not been adopted. It is stylistically out of step with  CLOS in a few places and places some restrictions which are not  necessary if CLOS can be presupposed.Proposal (CLOS-CONDITIONS:INTEGRATE):  1. Define that condition types are CLOS classes.  2. Define that condition objects are CLOS instances.  3. Functions such as SIGNAL, which take arguments of class names, are     permitted to take class objects. Such class objects must still be     subclasses of CONDITION.  4. Define that slots in condition objects are normal CLOS slots. Note     that WITH-SLOTS can be used to provide more convenient access to the     slots where slot accessors are undesirable.  5. Incompatibly change the syntax of a slot in DEFINE-CONDITION     to be compatible with a DEFCLASS slot specification.     An implication of this change is that forms like      (DEFINE-CONDITION FOO (BAR) ((A 1) (B 2)))     would have to be written      (DEFINE-CONDITION FOO (BAR)	((A :INITARG :A :READER FOO-A :INITFORM 1)	 (B :INITARG :B :READER FOO-B :INITFORM 2)))  6. Permit multiple parent-types to be named in the list of parent types.     Define that these parent types are treated the same as the superior     class list in a CLOS DEFCLASS expression.  7. Eliminate the :CONC-NAME option to DEFINE-CONDITION.  8. Define that condition reporting is mediated through the PRINT-OBJECT     method for the condition type (class) in question, with *PRINT-ESCAPE*     always being NIL. Specifying (:REPORT fn) in the definition of a     condition type C is equivalent to doing       (DEFMETHOD PRINT-OBJECT ((X c) STREAM)	(IF *PRINT-ESCAPE* (CALL-NEXT-METHOD) (fn X STREAM)))Rationale:  These changes are consistent with the intent of the X3J13 endorsement  of CLOS and the Common Lisp Condition System.  Although items 5 and 7 are incompatible with the interim condition  handling which we've been working with, the overall proposal significantly  improves compatibility with CLOS.  This compatibility will make the language seem less fragmented, and  probably more learnable because there will be fewer paradigms to learn.  Also, items 5 and 7 in particular are an improvement for reasons  unrelated to CLOS if only because they get rid of the need for symbol  concatenation, a process which has been seen to cause problems because  of the transient nature of the binding of *PACKAGE*.Examples:  Slot specifiers...    A slot specifier of X is still valid but is incompatibly    changed to mean what CLOS has it mean; no :INITARG or     :READER would be supplied.      A slot specifier of (X) is still valid but is incompatibly    changed to mean what CLOS has it mean; no :INITARG or     :READER would be supplied.    A slot specifier of (X V) would no longer be valid.        In addition, other slot specifiers such as     (X :INITARG :EX :TYPE FIXNUM)    are permitted as in DEFCLASS. Conc names ...   (DEFINE-CONDITION FOOBAR (FOO BAR) (X Y) (:CONC-NAME FUBAR))   would be rewritten   (DEFINE-CONDITION FOOBAR (FOO BAR)     ((X :INITARG :X :READER FUBAR-X)      (Y :INITARG :Y :READER FUBAR-Y))) Report methods ...   (DEFINE-CONDITION OOPS (ERROR) ())   (DEFMETHOD PRINT-OBJECT ((X OOPS) STREAM)     (IF *PRINT-ESCAPE* 	 (CALL-NEXT-METHOD)	 (FORMAT STREAM "Oops! Something went wrong.")))   (ERROR 'OOPS)   >>Error: Oops! Something went wrong.Current Practice:  Some implementations supporting CLOS probably already do this,  or something very similar.Cost to Implementors:  If you really have CLOS, this is very straightforward.Cost to Users:  Small, but tractable.  The main potential problems are:   - :CONC-NAME. There is nothing that keeps an implementation from     continuing to support :CONC-NAME for a short while until old code     has been upgraded.   - The incompatible change to slot syntax. Again, it is possible to     unambiguously recognize a 2-list as old-style syntax and an     implementation can provide interim compatibility support during     a transition period.  Even if implementations did not provide the recommended compatibility  support, users could trivially shadow DEFINE-CONDITION and provide the  support themselves, expanding into the native DEFINE-CONDITION in the  proper syntax.  In any case, the total number of uses of DEFINE-CONDITION at this   point is probably quite small. Searching for them and repairing  each by hand is probably not an expensive operation.Cost of Non-Adoption:  Conditions will seem harder to manipulate than other user-defined types.  People will wonder if CLOS is really something we're committed to.Benefits:  A more regular, more learnable language.Aesthetics:  Improved.Discussion:  Gregor, Pierson, Moon, and Pitman support this proposal.  People seem to disagree about the status that CLOS might occupy  in the upcoming standard. In spite of a vote of support, they seem  to think it might be optional in some way. Passing this proposal  establishes a clear precedent for the full integration of CLOS into  the emerging language.  The sense of the cleanup committee was that it was acceptable for  a vendor to identify a CLOS-free subset of Common Lisp, but that since  the position of X3J13 seems to be that no resources should be devoted  to work on subsets, it was inappropriate for us to work out the details  of that subset ourselves.  Since nothing about this proposal would  impede such a subset, we took that to be adequate basis for presenting  this single proposal.  Moon thinks we might want to add condition types for the errors  CLOS might signal. Richard Mlynarik thinks we should add a generic  function, REPORT-CONDITION, which is used for reporting conditions.  Both of these issues should probably be pursued under separate cover.*start*00900 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 MAR 89 17:24:16 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 10 Mar 89  17:23:20 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 10 MAR 89 17:09:24 PSTDate: Fri, 10 Mar 89 17:09 PSTFrom: Gregor.paSubject: Re: Issue: CLOS-CONDITIONS (Version 4)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUFcc: BD:>Gregor>mail>outgoing-mail-5.text.newestIn-Reply-To: <890310140701.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890311010901.9.GREGOR@SPIFF.parc.xerox.com>Line-fold: noOne comment is that you should explicitly mention bootstrappingconcerns under cost to implementors.  If you just leave it out,someone may think it is a difficult problem.  -------*start*02702 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 09:40:16 PSTReceived: from REAGAN.AI.MIT.EDU by SAIL.Stanford.EDU with TCP; 13 Mar 89  09:40:01 PSTReceived: from JACKIE-O.AI.MIT.EDU by REAGAN.AI.MIT.EDU via CHAOS with CHAOS-MAIL id 180784; Mon 13-Mar-89 12:33:08 ESTDate: Mon, 13 Mar 89 12:35 ESTFrom: Richard Mlynarik <Mly@AI.AI.MIT.EDU>Subject: Issue: CLOS-CONDITIONS (Version 4)To: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890310140701.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890313173553.9.MLY@JACKIE-O.AI.MIT.EDU>    Date: Fri, 10 Mar 89 14:07 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    Proposal (CLOS-CONDITIONS:INTEGRATE):      1. Define that condition types are CLOS classes.      2. Define that condition objects are CLOS instances.      4. Define that slots in condition objects are normal CLOS slots. Note	 that WITH-SLOTS can be used to provide more convenient access to the	 slots where slot accessors are undesirable.This isn't any sort of clarification.  The actual clarification required-- which has been requested several times, and not just by myself -- iswhat the *METACLASS* of condition types is.Condition types may be "CLOS classes" without being STANDARD-CLASSesCondition objects may be "CLOS instances" without being STANDARD-OBJECTs.Just what are "normal CLOS slots"?  As I see it, the "normalcy" orotherwise of slots is determined by the metaclass.My opinion for some time has been that condition types should not beSTANDARD-CLASSes but instead something like READ-ONLY-CLASS.Conceptually, It Is An Error to modify the slots of condition objects,which are supposed to be immutable descriptions of part of the state ofa computation.  Implementationally,(setf (slot-value <condition-object> <slot-name>) <new-value>) shouldsignal an error.(I also think that conditions in particular have a strong need forsomething like :REQUIRED-INIT-KEYWORDS, but that's another story.)Even if you decide to make condition classes' metaclass STANDARD-CLASS,the point is that you need to state this, so that users may definecondition classes and mixins using DEFCLASS.			 Richard Mlynarik thinks we should add a generic      function, REPORT-CONDITION, which is used for reporting conditions.      Both of these issues should probably be pursued under separate cover.Since, as you know, I largely regard work on the Common Lisp conditionsystem as a waste of my time, this won't happen until somebody elserealises that it is needed.*start*02570 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 10:08:36 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Mar 89  10:09:13 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 555769; Mon 13-Mar-89 13:06:17 ESTDate: Mon, 13 Mar 89 13:06 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: CLOS-CONDITIONS (Version 4)To: Mly@AI.AI.MIT.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <19890313173553.9.MLY@JACKIE-O.AI.MIT.EDU>Message-ID: <890313130600.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Mon, 13 Mar 89 12:35 EST    From: Richard Mlynarik <Mly@AI.AI.MIT.EDU>	Date: Fri, 10 Mar 89 14:07 EST	From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>	Proposal (CLOS-CONDITIONS:INTEGRATE):	  1. Define that condition types are CLOS classes.	  2. Define that condition objects are CLOS instances.	  4. Define that slots in condition objects are normal CLOS slots. Note	     that WITH-SLOTS can be used to provide more convenient access to the	     slots where slot accessors are undesirable.    This isn't any sort of clarification.  The actual clarification required    -- which has been requested several times, and not just by myself -- is    what the *METACLASS* of condition types is.I do not agree that it is a -necessary- thing to specify the Meta-Classof conditions because all intended uses of conditions can be donewithout this information.I agree that it is a -possibly useful- thing to do, but there is a downside to it -- it would unnecessarily tie the hands of people who wantimplementation flexibility for one reason or another.I happen to like your idea of a READ-ONLY-CLASS, by the way.I do not mind if someone proposes this change, but I do believe it is notproperly a part of the "essential changes" to integrate conditions withCLOS. As such, I would prefer that it not be raised as part of this issuebecause I don't want to risk this level of changes not going through dueto worry over that issue.I would be happy to see you write up a separate proposal on the issue.I can't guarantee that it will be accepted due to all the impending deadlines, but my vote will not be to table it on mere procedural grounds.I can't speak for anyone else.Please call the new issue CONDITION-META-CLASS.*start*00832 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 14:56:47 PSTReceived: from ECLC.USC.EDU by SAIL.Stanford.EDU with TCP; 13 Mar 89  14:57:13 PSTDate: Sat, 11 Mar 89 19:32:37 PSTFrom: Kim A. Barrett <IIM%ECLA@ECLC.USC.EDU>Subject: Issue CLOS-CONDITIONS, v4To: kmp@SCRC-STONY-BROOK.ARPAcc: cl-cleanup@SAIL.STANFORD.EDU, iim%ECLA@ECLC.USC.EDUMessage-ID: <12477306674.30.IIM@ECLA.USC.EDU>I would like to second Richard Mlynarik's suggestion of a REPORT-CONDITIONmethod, for much the same reasons he mentioned.  It's really ugly to have toalways include the check for *PRINT-ESCAPE* with a CALL-NEXT-METHOD every timeyou want to define your own report method for a condition.kab-------*start*01644 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 14-Mar-89 13:48:29 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 MAR 89 13:43:49 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Mar 89  13:43:59 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 MAR 89 13:23:23 PSTDate: Tue, 14 Mar 89 13:23 PSTFrom: Gregor.paSubject: Re: Issue: CLOS-CONDITIONS (Version 4)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Mly@AI.AI.MIT.EDU, CL-Cleanup@SAIL.Stanford.EDUFcc: BD:>Gregor>mail>outgoing-mail-5.text.newestIn-Reply-To: <890313130600.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890314212317.7.GREGOR@SPIFF.parc.xerox.com>Line-fold: no    Date: Mon, 13 Mar 89 13:06 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    I do not agree that it is a -necessary- thing to specify the Meta-Class    of conditions because all intended uses of conditions can be done    without this information.I don't agree with this.  If we don't specify the metaclass, then userswon't know what other classes they can mix in when defining conditionclasses.  It may seem weird, but I can imagine someone wanting to mixin an arbitrary class into a condition class.I think we should just say that the class CONDITION is an instance ofSTANDARD-CLASS, and that by default DEFINE-CONDITION defines standardclasses.  Sure it might be nice to do the read only class thing but Idon't think this is a good time to design a special purpose metaclassfor this.  -------*start*09315 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Mar-89 09:18:20 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 09:13:30 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  08:54:08 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 MAR 89 08:44:08 PSTDate: 16 Mar 89 08:43 PSTFrom: masinter.paSubject: Issue: CLOS-CONDITIONS (Version 4)To: X3J13@SAIL.Stanford.EDUline-fold: NOMessage-ID: <890316-084408-3922@Xerox>There've been various comments on this version; most of therelevant discussion centers on whether the metaclass ofcondition classes should be specified. Exerpts fromthe mail appear at the end.!Status: DRAFTIssue:        CLOS-CONDITIONSReferences:   Condition System (Revision 18)Category:     ADDITIONEdit history: 26-Sep-88, Version 1 by Pitman	      06-Oct-88, Version 2 by Pitman	      09-Oct-88, Version 3 by Pitman	      10-Mar-89, Version 4 by Pitman (remove unsupported options)Problem Description:  The description of the Common Lisp condition system presupposes  only DEFSTRUCT and not DEFCLASS because it was written when  CLOS had not been adopted. It is stylistically out of step with  CLOS in a few places and places some restrictions which are not  necessary if CLOS can be presupposed.Proposal (CLOS-CONDITIONS:INTEGRATE):  1. Define that condition types are CLOS classes.  2. Define that condition objects are CLOS instances.  3. Functions such as SIGNAL, which take arguments of class names, are     permitted to take class objects. Such class objects must still be     subclasses of CONDITION.  4. Define that slots in condition objects are normal CLOS slots. Note     that WITH-SLOTS can be used to provide more convenient access to the     slots where slot accessors are undesirable.  5. Incompatibly change the syntax of a slot in DEFINE-CONDITION     to be compatible with a DEFCLASS slot specification.     An implication of this change is that forms like      (DEFINE-CONDITION FOO (BAR) ((A 1) (B 2)))     would have to be written      (DEFINE-CONDITION FOO (BAR)	((A :INITARG :A :READER FOO-A :INITFORM 1)	 (B :INITARG :B :READER FOO-B :INITFORM 2)))  6. Permit multiple parent-types to be named in the list of parent types.     Define that these parent types are treated the same as the superior     class list in a CLOS DEFCLASS expression.  7. Eliminate the :CONC-NAME option to DEFINE-CONDITION.  8. Define that condition reporting is mediated through the PRINT-OBJECT     method for the condition type (class) in question, with *PRINT-ESCAPE*     always being NIL. Specifying (:REPORT fn) in the definition of a     condition type C is equivalent to doing       (DEFMETHOD PRINT-OBJECT ((X c) STREAM)	(IF *PRINT-ESCAPE* (CALL-NEXT-METHOD) (fn X STREAM)))Rationale:  These changes are consistent with the intent of the X3J13 endorsement  of CLOS and the Common Lisp Condition System.  Although items 5 and 7 are incompatible with the interim condition  handling which we've been working with, the overall proposal significantly  improves compatibility with CLOS.  This compatibility will make the language seem less fragmented, and  probably more learnable because there will be fewer paradigms to learn.  Also, items 5 and 7 in particular are an improvement for reasons  unrelated to CLOS if only because they get rid of the need for symbol  concatenation, a process which has been seen to cause problems because  of the transient nature of the binding of *PACKAGE*.Examples:  Slot specifiers...    A slot specifier of X is still valid but is incompatibly    changed to mean what CLOS has it mean; no :INITARG or     :READER would be supplied.      A slot specifier of (X) is still valid but is incompatibly    changed to mean what CLOS has it mean; no :INITARG or     :READER would be supplied.    A slot specifier of (X V) would no longer be valid.        In addition, other slot specifiers such as     (X :INITARG :EX :TYPE FIXNUM)    are permitted as in DEFCLASS. Conc names ...   (DEFINE-CONDITION FOOBAR (FOO BAR) (X Y) (:CONC-NAME FUBAR))   would be rewritten   (DEFINE-CONDITION FOOBAR (FOO BAR)     ((X :INITARG :X :READER FUBAR-X)      (Y :INITARG :Y :READER FUBAR-Y))) Report methods ...   (DEFINE-CONDITION OOPS (ERROR) ())   (DEFMETHOD PRINT-OBJECT ((X OOPS) STREAM)     (IF *PRINT-ESCAPE* 	 (CALL-NEXT-METHOD)	 (FORMAT STREAM "Oops! Something went wrong.")))   (ERROR 'OOPS)   >>Error: Oops! Something went wrong.Current Practice:  Some implementations supporting CLOS probably already do this,  or something very similar.Cost to Implementors:  If you really have CLOS, this is very straightforward.Cost to Users:  Small, but tractable.  The main potential problems are:   - :CONC-NAME. There is nothing that keeps an implementation from     continuing to support :CONC-NAME for a short while until old code     has been upgraded.   - The incompatible change to slot syntax. Again, it is possible to     unambiguously recognize a 2-list as old-style syntax and an     implementation can provide interim compatibility support during     a transition period.  Even if implementations did not provide the recommended compatibility  support, users could trivially shadow DEFINE-CONDITION and provide the  support themselves, expanding into the native DEFINE-CONDITION in the  proper syntax.  In any case, the total number of uses of DEFINE-CONDITION at this   point is probably quite small. Searching for them and repairing  each by hand is probably not an expensive operation.Cost of Non-Adoption:  Conditions will seem harder to manipulate than other user-defined types.  People will wonder if CLOS is really something we're committed to.Benefits:  A more regular, more learnable language.Aesthetics:  Improved.Discussion:  Gregor, Pierson, Moon, and Pitman support this proposal.  People seem to disagree about the status that CLOS might occupy  in the upcoming standard. In spite of a vote of support, they seem  to think it might be optional in some way. Passing this proposal  establishes a clear precedent for the full integration of CLOS into  the emerging language.  The sense of the cleanup committee was that it was acceptable for  a vendor to identify a CLOS-free subset of Common Lisp, but that since  the position of X3J13 seems to be that no resources should be devoted  to work on subsets, it was inappropriate for us to work out the details  of that subset ourselves.  Since nothing about this proposal would  impede such a subset, we took that to be adequate basis for presenting  this single proposal.  Moon thinks we might want to add condition types for the errors  CLOS might signal. Richard Mlynarik thinks we should add a generic  function, REPORT-CONDITION, which is used for reporting conditions.  Both of these issues should probably be pursued under separate cover.!"One comment is that you should explicitly mention bootstrappingconcerns under cost to implementors.  If you just leave it out,someone may think it is a difficult problem. ""This isn't any sort of clarification.  The actual clarification required-- which has been requested several times, and not just by myself -- iswhat the *METACLASS* of condition types is.Condition types may be "CLOS classes" without being STANDARD-CLASSesCondition objects may be "CLOS instances" without being STANDARD-OBJECTs.Just what are "normal CLOS slots"?  As I see it, the "normalcy" orotherwise of slots is determined by the metaclass.My opinion for some time has been that condition types should not beSTANDARD-CLASSes but instead something like READ-ONLY-CLASS.Conceptually, It Is An Error to modify the slots of condition objects,which are supposed to be immutable descriptions of part of the state ofa computation.  Implementationally,(setf (slot-value <condition-object> <slot-name>) <new-value>) shouldsignal an error.(I also think that conditions in particular have a strong need forsomething like :REQUIRED-INIT-KEYWORDS, but that's another story.)Even if you decide to make condition classes' metaclass STANDARD-CLASS,the point is that you need to state this, so that users may definecondition classes and mixins using DEFCLASS.""I do not agree that it is a -necessary- thing to specify the Meta-Classof conditions because all intended uses of conditions can be donewithout this information.I agree that it is a -possibly useful- thing to do, but there is a downside to it -- it would unnecessarily tie the hands of people who wantimplementation flexibility for one reason or another.""... If we don't specify the metaclass, then userswon't know what other classes they can mix in when defining conditionclasses.  It may seem weird, but I can imagine someone wanting to mixin an arbitrary class into a condition class.I think we should just say that the class CONDITION is an instance ofSTANDARD-CLASS, and that by default DEFINE-CONDITION defines standardclasses.  Sure it might be nice to do the read only class thing but Idon't think this is a good time to design a special purpose metaclassfor this.  "*start*01005 00024 US Date:  4 Apr 89 08:07 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: CLOS-CONDITIONSTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: CLOS-CONDITIONSTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 08:07:17 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  08:05:45 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 570862; Tue 4-Apr-89 11:05:44 EDTOriginal-Date: Tue, 4 Apr 89 11:05 EDTMessage-ID: <890404110518.1.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say this passed on a vote of N-0-3.