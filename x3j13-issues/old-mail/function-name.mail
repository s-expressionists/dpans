*start*07731 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 SEP 87 13:57:19 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 28 Sep 87  13:54:51 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 243389; Mon 28-Sep-87 16:55:16 EDTDate: Mon, 28 Sep 87 16:55 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: fixing our problems with setfTo: Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <870920-190342-9834@Xerox>,             <870921-091049-10309@Xerox>,             <870921163510.2.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <2768308570-8410382@Jenner>,             <16906.559842149@hplabsz>Message-ID: <870928165521.9.MOON@EUPHRATES.SCRC.Symbolics.COM>The goal is to unify the handling of "setf functions" with the handlingof regular functions, so we don't need a proliferation of -setf versionsof defmethod, defgeneric, ensure-generic-function, fboundp, generic-labels,with-added-methods, etc.  The major issue is that Common Lisp has not seena need to do this already, so the onus falls on CLOS.  In addition, weran into difficulty with confusion between the idea of associating afunction name with a function object (in our case, a generic functionobject), and the idea of associating a way to setf a function with thatfunction.  This proposal unifies those ideas.I believe the following proposal neatly solves the problem.Add to Common Lisp the same concept of "setf functions" that we arealready introducing in CLOS.  Right now, Common Lisp only has "setfmacros", which are defined by define-setf-method and both forms ofdefsetf.  I draw the distinction because a "setf macro" is somethingthat produces code (or other specifications, as in define-setf-method)which, when evaluated, will perform the effect of an invocation of setf,while a "setf function" is something that is called to perform directlythe effect of an invocation of setf.As with regular functions, associated with any given name you can have asetf function or a setf macro, but not both.  This means that one doesnot define a setf function (with defmethod or defgeneric) and also calldefsetf.  The mere act of defining the setf function is enough to tellsetf what to do.Since setf functions are in a separate, but parallel, namespace fromregular functions, we need a way to name them.  The simplest way is toallow a list (setf -name-) to be used as the name of the setf functionthat is called to perform the effect of (setf (-name- ...) ...).  Thefollowing functions, macros, and special forms defined in CLtL need tobe enhanced to accept such lists where they now accept symbols asfunction names:  compile  defun  disassemble  documentation  fboundp  flet  fmakunbound  function  labels  symbol-function and setf of symbol-function  trace  untraceThe following functions, macros, and special forms defined in CLOS needto be enhanced in the same way:  defgeneric  defmethod  ensure-generic-function  generic-flet  generic-labels  with-added-methodsdefmethod-setf and defgeneric-setf need to be removed.Note that in Common Lisp, setf macroexpansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.Note that I do not propose to introduce lexically local setf macros,that is, a cross between defsetf and macrolet.  This does not appear tobe logically necessary.  If someone else wants this, it would certainlynot be hard to do.  The main issue is whether all three ways of defininglexically global setf macros need local counterparts.  I also do not nowpropose to codify the definition of global setf macros, for example tosay that (macro-function '(setf foo)) returns an expander function thattakes two arguments and returns five values.The next issue is what to do about the lambda-list of a setf-function.We already agreed on what is the lambda-list in the expansion of(defun (setf foo) ...) into (setf (symbol-function '(setf foo)) #'(lambda ...)).  Specifically,#'(setf foo) takes one more required argument than #'foo, and the lastrequired argument is the new value to be stored.The issue is whether certain function-defining macros should have aspecial syntax with two lambda-lists when defining a setf function, orshould use their normal syntax.  The macros in question are defun, flet,labels, defgeneric, defmethod, and the :method option to defgeneric,generic-flet, generic-labels, and with-added-methods.  In favor of twolambda-lists is that it's easier for the programmer to see whichparameter is bound to the new value to be stored.  In favor of onelambda-list is syntactic consistency between setf functions and regularfunctions.  At the meeting two weeks ago, we favored two lambda-lists,but I now believe that that was a mistake.  The rule that the new valueis the last required argument should not be at all difficult forprogrammers to understand.  Syntactic consistency is important.The remaining issue is a scoping issue.  We have introduced lexicallylocal setf functions, where before Common Lisp only had lexically globalsetf macros.  Thus the namespace of setf operators has been extended tohave a lexical component, just like the namespace of regular operators.(Recall that "operator" means the union of functions, macros, andspecial forms).  Regular functions and setf functions naturally come inpairs, but since they are defined separately we have to specify whathappens in various cases where only one is defined at a given lexicalcontour.The simplest solution would be to say that (setf (-foo- ...) ...) ignoresthe scope of the name -foo- when considering how to setf it.  However, thissolution has already been ruled out by the Cleanup committee's resolutionof issue GET-SETF-METHOD-ENVIRONMENT.  Specifically inside the scope ofa macrolet of foo, the expansion of (setf (foo ...) ...) proceeds bycalling the macrolet expander, regardless of whether there is a globallydefined setf macro for foo.  Similarly, inside the scope of a flet of foo,(setf (foo ...) ...) is invalid.To be consistent with this, I propose a suite of three rules for thebehavior of local function defining forms (flet, generic-flet,generic-labels, labels, macrolet, and with-added-methods):(1) A local function definition of the name foo implicitly shadows thescope of a global setf macro definition for foo.(2) A local function definition of the name foo implicitly shadows thescope of any enclosing function definition of (setf foo).  When the samefunction defining form defines both foo and (setf foo), the scopes ofthe two names are equal regardless of their order of appearance in thefunction defining form.(3) A local function definition of the name (setf foo) does not changethe scope of any enclosing function definition of foo.with-added-methods may require a special rule, because of its unusualhalf-shadowing semantics.  I'm inclined to ignore this and say that(with-added-methods ((foo ...)) ...) shadows any enclosing definitionof (setf foo), just like generic-labels.Example (for Patrick):(defmethod (setf subseq)	   ((sequence vector) start (new-value vector) &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (aref sequence i) (aref new-value j))))If this meets with general approval I will recast this for the Cleanupcommittee.*start*10210 00024 USfReturn-Path: <@SAIL.Stanford.EDU,@STONY-BROOK.SCRC.Symbolics.COM,@EUPHRATES.SCRC.Symbolics.COM:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 OCT 87 14:16:19 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 15 Oct 87  14:10:45 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 256462; 15 Oct 87 17:11:02 EDTDate: Thu, 15 Oct 87 17:11 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 1)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19871015211100.8.MOON@EUPHRATES.SCRC.Symbolics.COM>ISSUE:         SETF-FUNCTION-VS-MACROREFERENCES:    setf rules for what -place- can be (pp.94-7)               compile function (p.438)               defun macro (p.57)               disassemble function (p.439)               documentation function (p.440)               fboundp function (p.90)               flet special form (p.113)               fmakunbound function (p.92)               ftype declaration (p.158)               function special form (p.87)               function declaration (p.159)               inline declaration (p.159)               notinline declaration (p.159)               labels special form (p.113)               symbol-function and setf of symbol-function (p.90)               trace macro (p.440)               untrace macro (p.440)CATEGORY:      ADDITIONEDIT HISTORY:  Version 1, 13-Oct-87 Moon		   (based on discussion among the CLOS working group)PROBLEM DESCRIPTION:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSis much simpler in the relevant areas.PROPOSAL (SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The form (setf (-name- ...) ...), when -name- is defined as a function(rather than a macro) and no setf macro has been defined for -name-,expands into a call to a setf function.  The name of this setf functionis a list (setf -name-), where -name- is a symbol.  The functions,macros, and special forms defined in CLtL and listed in the Referencessection above need to be enhanced to accept such lists in addition tosymbols as function names, so that setf functions can be defined andmanipulated.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)		;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.TEST CASE:  (really more examples than test cases);If setf of subseq was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when rules 1-3 do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))	(temp-vars (do ((a (cdr form) (cdr a))			(v nil (cons (gensym) v)))		       ((null a) v))))    (values temp-vars (cdr form) (list new-value)	    `(funcall #'(setf ,(car form))		      ,new-value ,@temp-vars)	    `(,(car form) ,@temp-vars))))RATIONALE:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.  In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingdefsetf can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a similar feature,in that they have setting functions named (SETF reader).  I don'tknow of any implementation that has precisely the proposed feature.ADOPTION COST:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.COST OF NON-ADOPTION:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.BENEFITS:Allow CLOS to be defined without out-of-hand complexity.CONVERSION COST:None, this is an upward-compatible change.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question, however bystressing setf functions rather than setf macros SETF could becomeeasier to teach.DISCUSSION:Note that in Common Lisp, setf macroexpansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:  Lexically local setf macros, that is, a cross between defsetf and  macrolet.  This does not appear to be logically necessary.  Do all three  ways of defining lexically global setf macros need local counterparts?    Should we define the meaning of defmacro or macrolet of (setf foo)?  This would be a fourth way to define a setf macro.    Should we enhance the definition of global setf macros, for example to  say that (macro-function '(setf foo)) returns an expander function that  takes two arguments and returns five values?    Should we introduce a new name for symbol-function, since it accepts  non-symbols now?*start*02516 00024 US Return-Path: <@SAIL.Stanford.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 OCT 87 17:30:25 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 15 Oct 87  17:24:59 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Thu 15 Oct 87 20:21:44-EDTDate: Thu, 15 Oct 87 20:21 EDTMessage-ID: <FAHLMAN.12342792040.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: SETF-FUNCTION-VS-MACRO (Version 1)In-reply-to: Msg of 15 Oct 1987  17:11-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>I have no problem with this proposal, except for the notion that thename of the setf-function associated with FOO should be a list, (SETFFOO).  This seems like a more radical change than is really necessary toaccomplish the stated purposes.  It is a considerable extension to theidea of a "function name", at least for standard Common Lispimplementations that do not implement Lisp machine style function-specs.Would it not be simpler to introduce a new setf-able access functionGET-SETF-FUNCTION which takes a symbol and returns the associated SETFfunction?  Under Moon's proposal a SETF form expands into something like(funcall #'(setf foo) ...).  This would become (funcall(get-setf-function foo)...).  I assume that in either case one must usean explicit funcall and not just drop this "name" into the car-positionof an expression to be evaluated.The one problem I can see with this alternative proposal is that itthere is no very good way to do something like FLET for the setffunction if there is not a name-like entity that can be bound.  Is thatthe reason for introducing this new kind of "name" instead of justsetting up the association with a setf-able function?  Of course, wecould arbitrarily add some tweak to FLET that would locally rebind thesetf-function, but maybe Moon's scheme is more regular after all.If we do go ahead with Moon's proposal in its current form, it would bea good idea to address this concern and why something like thealternative discussed here is not a better choice.I assume that this would not preclude the addition of something like thefunction specs that are present on the Lisp machine?  If we finallydecide that Common Lisp is going to remain a Lisp-2, then we might wantto look at that whole issue again.-- Scott*start*02365 00024 US Return-Path: <@SAIL.Stanford.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 OCT 87 17:44:01 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 15 Oct 87  17:38:43 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 256662; Thu 15-Oct-87 20:39:42 EDTDate: Thu, 15 Oct 87 20:39 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 1)To: Scott E. Fahlman <Fahlman@C.CS.CMU.EDU>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12342792040.BABYL@C.CS.CMU.EDU>Message-ID: <19871016003933.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 15 Oct 1987  20:21 EDT    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    I have no problem with this proposal, except for the notion that the    name of the setf-function associated with FOO should be a list, (SETF    FOO).    Would it not be simpler to introduce a new setf-able access function    GET-SETF-FUNCTION which takes a symbol and returns the associated SETF    function?  The CLOS committee tried that for a long time, but it doesn't work.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF or something.    The one problem I can see with this alternative proposal is that it    there is no very good way to do something like FLET for the setf    function if there is not a name-like entity that can be bound.  Precisely.  That's the reason for making the name explicit.    I assume that this would not preclude the addition of something like the    function specs that are present on the Lisp machine?Right.  There could be other function names that are not symbols, howeverwe don't really need to propose any others for CLOS.    I assume that in either case one must use    an explicit funcall and not just drop this "name" into the car-position    of an expression to be evaluated.Yes, the extra complexity of allowing something new in the car of a formdidn't seem to be justified.  I guess I should have listed that among therejected ideas at the end.*start*00954 00024 US Return-Path: <@SAIL.Stanford.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 OCT 87 17:51:08 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 15 Oct 87  17:46:11 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Thu 15 Oct 87 20:46:42-EDTDate: Thu, 15 Oct 87 20:46 EDTMessage-ID: <FAHLMAN.12342796585.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: SETF-FUNCTION-VS-MACRO (Version 1)In-reply-to: Msg of 15 Oct 1987  20:39-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>OK, Moon's proposal looks to me like the right way to go.  It would beuseful to address the alternative I raised in the proposal and thearguments against it, just so that N other people won't bring up thesame idea.-- Scott*start*01092 00024 US Return-Path: <@SAIL.Stanford.EDU:Pavel.pa@Xerox.COM>Received: from SAIL.Stanford.EDU by Xerox.COM ; 13 OCT 87 20:11:17 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 13 Oct 87  20:09:28 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 13 OCT 87 20:07:00 PDTDate: Tue, 13 Oct 87 20:01:00 PDTFrom: Pavel.paSubject: Re: fixing our problems with setfIn-reply-to: <19871013204504.5.MOON@EUPHRATES.SCRC.Symbolics.COM>To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: Common-Lisp-Object-System@SAIL.STANFORD.EDUMessage-ID: <871013-200700-6060@Xerox>A nit in your test case.  It would be nicer if the optional variable endhad a default value rather than using the (unless end ...) hack:;If setf of subseq was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional (end (lengthsequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))))*start*08230 00024 US Return-Path: <@SAIL.Stanford.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.Stanford.EDU by Xerox.COM ; 13 OCT 87 13:52:58 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 13 Oct 87  13:48:20 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 254492; Tue 13-Oct-87 16:45:14 EDTDate: Tue, 13 Oct 87 16:45 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: fixing our problems with setfTo: Gregor.pacc: Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <871013105134.3.GREGOR@SPIFF.isl.parc.xerox.com>Message-ID: <19871013204504.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoHere is the proposal I will send to the cleanup committee Wednesdayevening, after incorporating any comments you have to offer:Issue:         SETF-CLOSReferences:    setf rules for what -place- can be (pp.94-7)	       compile function (p.438)	       defun macro (p.57)	       disassemble function (p.439)	       documentation function (p.440)	       fboundp function (p.90)	       flet special form (p.113)	       fmakunbound function (p.92)	       ftype declaration (p.158)	       function special form (p.87)	       function declaration (p.159)	       inline declaration (p.159)	       notinline declaration (p.159)	       labels special form (p.113)	       symbol-function and setf of symbol-function (p.90)	       trace macro (p.440)	       untrace macro (p.440)Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 MoonProblem description:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-CLOS:SETF-FUNCTIONS is muchsimpler in the relevant areas.Proposal (SETF-CLOS:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The name of the setf function that is called to perform the effect of(setf (-name- ...) ...) is a list (setf -name-), where -name- is asymbol.  The functions, macros, and special forms defined in CLtL andlisted in the References section above need to be enhanced to acceptsuch lists in addition to symbols as function names.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)	  (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.Test Case:  (really more of an example than a test case);If setf of subseq was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))))Rationale:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.Current practice:A few Common Lisp implementations already have a similar feature,in that they have setting functions named (SETF reader).  I don'tknow of any implementation that has precisely the proposed feature.Adoption Cost:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.Cost of non-adoption:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.Benefits:Allow CLOS to be defined without out-of-hand complexity.Conversion Cost:None, this is an upward-compatible change.Esthetics:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question, however bystressing setf functions SETF could become easier to teach.Discussion:Note that in Common Lisp, setf macroexpansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:  Lexically local setf macros, that is, a cross between defsetf and  macrolet.  This does not appear to be logically necessary.  Do all three  ways of defining lexically global setf macros need local counterparts?    Should we define the meaning of defmacro or macrolet of (setf foo)?  This would be a fourth way to define a setf macro.    Should we enhance the definition of global setf macros, for example to  say that (macro-function '(setf foo)) returns an expander function that  takes two arguments and returns five values?    Should we introduce a new name for symbol-function, since it accepts  non-symbols now?*start*07696 00024 US Return-Path: <@SAIL.Stanford.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.Stanford.EDU by Xerox.COM ; 13 OCT 87 14:38:43 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 13 Oct 87  14:36:09 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 254575; Tue 13-Oct-87 17:36:18 EDTDate: Tue, 13 Oct 87 17:36 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: fixing our problems with setfTo: Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <871013105134.3.GREGOR@SPIFF.isl.parc.xerox.com>Message-ID: <19871013213622.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Here is a revision of what I mailed out yesterday, revised to reflectGregor's comments.  If this differs from the CL-cleanup draft proposalI mailed out a few minutes ago, that proposal supersedes this one.The goal is to unify the handling of "setf functions" with the handlingof regular functions, so we don't need a proliferation of -setf versionsof defmethod, defgeneric, ensure-generic-function, fboundp, generic-labels,with-added-methods, etc.  The major issue is that Common Lisp has not seena need to do this already, so the onus falls on CLOS.  In addition, weran into difficulty with confusion between the idea of associating afunction name with a function object (in our case, a generic functionobject), and the idea of associating a way to setf a function with thatfunction.  This proposal clarifies the situation.Add to Common Lisp the same concept of "setf functions" that we arealready introducing in CLOS.  Right now, Common Lisp only has "setfmacros", which are defined by define-setf-method and both forms ofdefsetf.  I draw the distinction because a "setf macro" is somethingthat produces code (or other specifications, as in define-setf-method)which, when evaluated, will perform the effect of an invocation of setf,while a "setf function" is something that is called to perform directlythe effect of an invocation of setf.Since setf functions are in a separate, but parallel, namespace fromregular functions, we need a way to name them.  The simplest way is toallow a list (setf -name-) to be used as the name of the setf functionthat is called to perform the effect of (setf (-name- ...) ...).  Thefollowing functions, macros, and special forms defined in CLtL need tobe enhanced to accept such lists where they now accept symbols asfunction names:  compile  defun  disassemble  documentation  fboundp  flet  fmakunbound  function  labels  symbol-function and setf of symbol-function  trace  untrace  and the declarations ftype, function, inline, and notinlineThis makes the name of symbol-function a bit obsolete, but I do notpropose to introduce a new function to replace it.  The discrepancy isnot that important.The following functions, macros, and special forms defined in CLOS needto be enhanced in the same way:  defgeneric  defmethod  ensure-generic-function  generic-flet  generic-labels  with-added-methodsdefmethod-setf and defgeneric-setf need to be removed.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.Normally one does not define both a setf function and a setf macrofor the same reading function.A definition of a setf function can be lexically local, like adefinition of a reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET, LABELS, GENERIC-FLET, GENERIC-LABELS, orWITH-ADDED-METHODS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.Note that in Common Lisp, setf macroexpansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.Note that I do not propose to introduce lexically local setf macros,that is, a cross between defsetf and macrolet.  This does not appear tobe logically necessary.  If someone else wants this, it would certainlynot be hard to do.  The main issue is whether all three ways of defininglexically global setf macros need local counterparts.  A secondary issueis whether to define the meaning of defmacro or macrolet of (setf foo).I also do not now propose to enhance the definition of global setfmacros, for example to say that (macro-function '(setf foo)) returns anexpander function that takes two arguments and returns five values.These issues logically belong to Common Lisp, not to CLOS.Contrary to what we already decided about the lambda-list of asetf-function, the new value to be stored will be passed as the firstargument.The function-defining macros defun, flet, labels, defgeneric, defmethod,and the :method option to defgeneric, generic-flet, generic-labels, andwith-added-methods will not have a special syntax with two lambda-listswhen defining a setf function, contrary to what we decided before.  Theprogrammer writing a setf-function must know to insert the new-valueparameter at the front of the lambda-list.The remaining issue is a scoping issue.  We have introduced lexicallylocal setf functions, where before Common Lisp only had lexically globalsetf macros.  Thus the namespace of setf operators has been extended tohave a lexical component, just like the namespace of regular operators.(Recall that "operator" means the union of functions, macros, andspecial forms).  Regular functions and setf functions naturally come inpairs, but since they are defined separately we have to specify whathappens in various cases where only one is defined at a given lexicalcontour.  The following rules for the behavior of SETF suffice; notethat these rules are ordered and the first rule to apply supersedes anylater rules.  These rules are a consistent extension of the currentbehavior of Common Lisp and the Cleanup committee's resolution of issueGET-SETF-METHOD-ENVIRONMENT.  Only rule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf-macro defined for foo, use the setf-macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)	  (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo) and does not care if that scope is different from the scopeof the function name foo.  This allows some nonsensical programs tobe written, but does not seem harmful enough to justify making therules more complicated.Example (for Patrick):(defmethod (setf subseq)	   ((new-value vector) (sequence vector) start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (aref sequence i) (aref new-value j))))*start*02240 00024 US Return-Path: <@SAIL.Stanford.EDU:Bobrow.pa@Xerox.COM>Received: from SAIL.Stanford.EDU by Xerox.COM ; 13 OCT 87 18:19:37 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 13 Oct 87  18:17:45 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 13 OCT 87 18:18:23 PDTDate: 13 Oct 87 18:18 PDTSender: Bobrow.paFrom: Danny Bobrow <Bobrow.pa>Subject: Re: fixing our problems with setfIn-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 13 Oct 87 16:45 EDTTo: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: Gregor.pa, Common-Lisp-Object-System@SAIL.STANFORD.EDUMessage-ID: <871013-181823-5939@Xerox>    Rules for the macroexpansion of (setf (foo x) y):    (1) If the function-name foo refers to the global function    definition, rather than a locally defined function or macro, and if    there is a setf macro defined for foo, use the setf macro to    compute the expansion.    (2) If the function-name foo is defined as a macro in the    current scope, use macroexpand-1 to expand (foo x) and try again.    (3) If the function-name foo is defined as a special form in    the current scope, signal an error.    (4) Expand into the equivalent of    (let ((#:temp-1 x)	  (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Do (1) and (4) together imply that if there is a macro definition forfoo, and there is an flet foo, but no (setf foo) defined, that theexpansion of  (setf (foo ...)...)uses (funcall #'(setf foo) ...) rather than the macro. This seems wrong(inconsistent with CLtL ???).    Normally one does not define both a setf function and a setf    macro for the same reading function.But if a (setf foo) is defined locally, it is always be used, whether ornot foo is defined locally or globally, right???I think the rule might be stated that if there is no (setf foo) functionAND there is a setf macro, then the macro is used, else the (setf foo)function is used in the expansion.  This is a slightly extended versionof your:    In the absence of any setf macro definition, SETF of a function    expands into a call to the setf function.  But aside from these two glitches (or my misunderstanding), I agree.danny       *start*01336 00024 US Return-Path: <@SAIL.Stanford.EDU:Pavel.pa@Xerox.COM>Received: from SAIL.Stanford.EDU by Xerox.COM ; 13 OCT 87 18:46:58 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 13 Oct 87  18:45:13 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 13 OCT 87 18:45:51 PDTDate: Tue, 13 Oct 87 18:45:44 PDTFrom: Pavel.paSubject: Re: fixing our problems with setfIn-reply-to: <871013-181823-5939@Xerox>To: Danny Bobrow <Bobrow.pa>Cc: Common-Lisp-Object-System@SAIL.STANFORD.EDUMessage-ID: <871013-184551-5973@Xerox>	Date: 13 Oct 87 18:18 PDT	From: Danny Bobrow <Bobrow.pa>	Do (1) and (4) together imply that if there is a macro definition for	foo, and there is an flet foo, but no (setf foo) defined, that the	expansion of	  (setf (foo ...)...)	uses (funcall #'(setf foo) ...) rather than the macro. This seems wrong	(inconsistent with CLtL ???).Isn't it the case that lexical functions cannot have a SETF method inCLtL?  I believe that in the following code:	(defsetf foo set-foo)		(flet ((foo (x) ...))	   (setf (foo 7) 8))the function SET-FOO will not be called.  Instead, SETF should signal anerror complaining about how there isn't a SETF method for the lexicalfunction FOO.  The SETF method for the global function FOO is not used.Am I just hallucinating about this?	Pavel*start*01546 00024 US Return-Path: <@SAIL.Stanford.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.Stanford.EDU by Xerox.COM ; 13 OCT 87 19:01:51 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 13 Oct 87  19:00:02 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 254770; Tue 13-Oct-87 22:00:32 EDTDate: Tue, 13 Oct 87 22:00 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: fixing our problems with setfTo: Pavel.pacc: Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <871013-184551-5973@Xerox>Message-ID: <19871014020034.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Tue, 13 Oct 87 18:45:44 PDT    From: Pavel.pa@Xerox.COM    Isn't it the case that lexical functions cannot have a SETF method in    CLtL?CLtL doesn't say, but the CL-Cleanup committee decided about half a yearago, in resolving issue GET-SETF-METHOD-ENVIRONMENT, that what you sayis true.  See the handout from the June X3J13 meeting.    I believe that in the following code:	    (defsetf foo set-foo)		    (flet ((foo (x) ...))	       (setf (foo 7) 8))    the function SET-FOO will not be called.  Instead, SETF should signal an    error complaining about how there isn't a SETF method for the lexical    function FOO.  The SETF method for the global function FOO is not used.That's correct.    Am I just hallucinating about this?If so, you're hallucinating the same way as the Cleanup committee.*start*07977 00024 US Return-Path: <@SAIL.Stanford.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.Stanford.EDU by Xerox.COM ; 12 OCT 87 13:53:28 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 12 Oct 87  13:51:21 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 253615; Mon 12-Oct-87 16:52:14 EDTDate: Mon, 12 Oct 87 16:52 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: fixing our problems with setfTo: Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <870928165521.9.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <871002163721.4.GREGOR@SPIFF.isl.parc.xerox.com>Message-ID: <19871012205211.7.MOON@EUPHRATES.SCRC.Symbolics.COM>After thinking it over, I think Gregor's proposal to simplify theway setf-functions work is reasonable.  There will be some adoptioncost for us, because the order of arguments to a setf function isbeing changed from what we agreed on before, but I think we cancome up with a compatibility kludge to take care of that.  Of course,Gregor's proposal doesn't really eliminate the scoping issues, notonly because we cannot get rid of defsetf and define-setf-method,but also because of the already defined interaction of setf withmacros.  However, I think the scoping rules are quite straightforward.Here is a revised version of what I mailed out on September 28,modified and simplified to reflect what Gregor proposed:The goal is to unify the handling of "setf functions" with the handlingof regular functions, so we don't need a proliferation of -setf versionsof defmethod, defgeneric, ensure-generic-function, fboundp, generic-labels,with-added-methods, etc.  The major issue is that Common Lisp has not seena need to do this already, so the onus falls on CLOS.  In addition, weran into difficulty with confusion between the idea of associating afunction name with a function object (in our case, a generic functionobject), and the idea of associating a way to setf a function with thatfunction.  This proposal clarifies the situation.Add to Common Lisp the same concept of "setf functions" that we arealready introducing in CLOS.  Right now, Common Lisp only has "setfmacros", which are defined by define-setf-method and both forms ofdefsetf.  I draw the distinction because a "setf macro" is somethingthat produces code (or other specifications, as in define-setf-method)which, when evaluated, will perform the effect of an invocation of setf,while a "setf function" is something that is called to perform directlythe effect of an invocation of setf.As with regular functions, associated with any given name you can have asetf function or a setf macro, but not both.  This means that one doesnot define a setf function (with defmethod or defgeneric) and also calldefsetf.  The mere act of defining the setf function is enough to tellsetf what to do.  In fact setf only needs for the setf function to bedefined at run time, not at compile time.Since setf functions are in a separate, but parallel, namespace fromregular functions, we need a way to name them.  The simplest way is toallow a list (setf -name-) to be used as the name of the setf functionthat is called to perform the effect of (setf (-name- ...) ...).  Thefollowing functions, macros, and special forms defined in CLtL need tobe enhanced to accept such lists where they now accept symbols asfunction names:  compile  defun  disassemble  documentation  fboundp  flet  fmakunbound  function  labels  symbol-function and setf of symbol-function  trace  untrace  and the declarations ftype, function, inline, and notinlineThis makes the name of symbol-function a bit obsolete, but I do notpropose to introduce a new function to replace it.  The discrepancy isnot that important.The following functions, macros, and special forms defined in CLOS needto be enhanced in the same way:  defgeneric  defmethod  ensure-generic-function  generic-flet  generic-labels  with-added-methodsdefmethod-setf and defgeneric-setf need to be removed.Note that in Common Lisp, setf macroexpansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.Note that I do not propose to introduce lexically local setf macros,that is, a cross between defsetf and macrolet.  This does not appear tobe logically necessary.  If someone else wants this, it would certainlynot be hard to do.  The main issue is whether all three ways of defininglexically global setf macros need local counterparts.  A secondary issueis whether to define the meaning of defmacro or macrolet of (setf foo).I also do not now propose to clarify the definition of global setfmacros, for example to say that (macro-function '(setf foo)) returns anexpander function that takes two arguments and returns five values.These issues logically belong to Common Lisp, not to CLOS.Contrary to what we already decided about the lambda-list of asetf-function, the new value to be stored will be passed as the firstargument.  Thus, #'(setf foo) takes one more required argument than#'foo, the first required argument is the new value to be stored, andthe remaining arguments are the same as #'foo's arguments.The function-defining macros defun, flet, labels, defgeneric, defmethod,and the :method option to defgeneric, generic-flet, generic-labels, andwith-added-methods will not have a special syntax with two lambda-listswhen defining a setf function, contrary to what we decided before.  Theprogrammer writing a setf-function must know to insert the new-valueparameter at the front of the lambda-list.The remaining issue is a scoping issue.  We have introduced lexicallylocal setf functions, where before Common Lisp only had lexically globalsetf macros.  Thus the namespace of setf operators has been extended tohave a lexical component, just like the namespace of regular operators.(Recall that "operator" means the union of functions, macros, andspecial forms).  Regular functions and setf functions naturally come inpairs, but since they are defined separately we have to specify whathappens in various cases where only one is defined at a given lexicalcontour.  The following rules for the behavior of SETF suffice; notethat these rules are ordered and the first rule to apply supersedes anylater rules.  These rules are a consistent extension of the currentbehavior of Common Lisp and the Cleanup committee's resolution of issueGET-SETF-METHOD-ENVIRONMENT.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf-macro defined for foo, use the setf-macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)	  (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo) and does not care if that scope is different from the scopeof the function name foo.  This allows some nonsensical programs tobe written, but does not seem harmful enough to justify making therules more complicated.Example (for Patrick):(defmethod (setf subseq)	   ((new-value vector) (sequence vector) start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (aref sequence i) (aref new-value j))))If this meets with general approval I will recast this for the Cleanupcommittee.*start*10535 00024 US Return-Path: <@SAIL.Stanford.EDU:Gregor.pa@Xerox.COM>Received: from SAIL.Stanford.EDU by Xerox.COM ; 13 OCT 87 15:03:18 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 13 Oct 87  14:59:00 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 13 OCT 87 14:59:16 PDTDate: Tue, 13 Oct 87 14:59 PDTFrom: Gregor.paSubject: fixing our problems with setfTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: Gregor.pa, Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <19871013204504.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <871013145903.8.GREGOR@SPIFF.isl.parc.xerox.com>Line-fold: no    Date: Tue, 13 Oct 87 16:45 EDT    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>I have just a couple of comments.  I put them in as comments rather thanediting your text so it would be easier to see them.  Otherwise thislooks good, it seems the best compromise between what I have beenwanting to do with setf for sometime and backward compatibility.    Here is the proposal I will send to the cleanup committee Wednesday    evening, after incorporating any comments you have to offer:    Issue:         SETF-CLOS    References:    setf rules for what -place- can be (pp.94-7)		   compile function (p.438)		   defun macro (p.57)		   disassemble function (p.439)		   documentation function (p.440)		   fboundp function (p.90)		   flet special form (p.113)		   fmakunbound function (p.92)		   ftype declaration (p.158)		   function special form (p.87)		   function declaration (p.159)		   inline declaration (p.159)		   notinline declaration (p.159)		   labels special form (p.113)		   symbol-function and setf of symbol-function (p.90)		   trace macro (p.440)		   untrace macro (p.440)    Category:      ADDITION    Edit history:  Version 1, 13-Oct-87 Moon    Problem description:    The Common Lisp Object System needs a well-defined way to relate the    name and arguments of a setting function to those of a reading function,    because both functions can be generic and can have user-defined methods.    We tried to hide the name and arguments of the setting function with    macrology, but the complexity got out of hand.  It seems better to make    this information explicit; the version of the CLOS specification that    assumes the adoption of proposal SETF-CLOS:SETF-FUNCTIONS is much    simpler in the relevant areas.    Proposal (SETF-CLOS:SETF-FUNCTIONS):     Add to Common Lisp the concept of "setf functions".  Right now, Common    Lisp only has "setf macros", which are defined by define-setf-method and    both forms of defsetf.  Terminology:      - a "setf macro" is something that produces code (or other	specifications, as in define-setf-method) which, when evaluated,	will perform the effect of an invocation of setf.      - a "setf function" is something that is called to perform	directly the effect of an invocation of setf.You should say right here that a setf function is called by the defaultexpansion of setf (unless a setf macro was explicitly defined).    The name of the setf function that is called to perform the effect of    (setf (-name- ...) ...) is a list (setf -name-), where -name- is a    symbol.  The functions, macros, and special forms defined in CLtL and    listed in the References section above need to be enhanced to accept    such lists in addition to symbols as function names.    A setf function receives the new value to be stored as its first    argument.  Thus, #'(setf foo) should have one more required parameter    than #'foo, the first required parameter is the new value to be stored,    and the remaining parameters should be the same as #'foo's parameters.    A setf function must return its first argument, since setf is defined    to return the new value.    A definition of a setf function can be lexically local, like a    definition of a reading function.  The following rules specify the    behavior of SETF; note that these rules are ordered and the first rule    to apply supersedes any later rules.  These rules are a consistent    extension of the current behavior of Common Lisp and the Cleanup    committee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Only    rule 4 is new with this proposal.    Rules for the macroexpansion of (setf (foo x) y):    (1) If the function-name foo refers to the global function definition,    rather than a locally defined function or macro, and if there is a    setf macro defined for foo, use the setf macro to compute the expansion.    (2) If the function-name foo is defined as a macro in the current scope,    use macroexpand-1 to expand (foo x) and try again.    (3) If the function-name foo is defined as a special form in the current    scope, signal an error.    (4) Expand into the equivalent of	(let ((#:temp-1 x)	      (#:temp-2 y))	  (funcall #'(setf foo) #:temp-2 #:temp-1))    Note that rule 4 is independent of the scope of the function name    (setf foo).  It does not matter if that scope is different from the    scope of the function name foo.  This allows some nonsensical programs    to be written, but does not seem harmful enough to justify making more    complicated rules to compare the scopes of the two function definitions.    Normally one does not define both a setf function and a setf macro    for the same reading function.    Normally one defines a local reading function and a local setf function    together in a single FLET or LABELS.(I give an example later).    In the absence of any setf macro definition, SETF of a function expands    into a call to the setf function.  This means that the setf function    only needs to be defined at run time, not compile time.Should be "Since in the absence of ..."?     Test Case:  (really more of an example than a test case)    ;If setf of subseq was not already built into Common Lisp,    ;it could have been defined like this    (defun (setf subseq) (new-value sequence start &optional end)      (unless end (setq end (length sequence)))      (setq end (min end (+ start (length new-value))))      (do ((i start (1+ i))	   (j 0 (1+ j)))	  ((= i end) new-value)	(setf (elt sequence i) (elt new-value j))))Another example would be:(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))))    Rationale:    By making the names and arguments of setting functions explicit, CLOS is    considerably simplified.This reduces the desire having a way to lexially bind setf macrosbecause code which doesn't use defsetf or define-modify-macro won't needlexical setf macros it can just use lexical functions.It would be good to point out that right now, many people are doingsomething *like* this: (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)and that these many similar styles will all be able to be expressedwith: (defun foo (x) ..) (defun (setf foo) (new x) ..)The bringing together of these styles will make code more 'common'.  Itried to capture this in the following paragraph but it doesn't quiteget it.Many of the current styles of using setf are quite similar.  That codewill be be simplified because many people who have been using techniquesessentially equivalent to using setf functions with no setf macros inthe new technique will begin using a common mechanism.    Current practice:    A few Common Lisp implementations already have a similar feature,    in that they have setting functions named (SETF reader).  I don't    know of any implementation that has precisely the proposed feature.    Adoption Cost:    The main cost is generalization of a few functions to accept lists    beginning with SETF where they now accept only symbols.  Implementations    must add a data structure to store the function definition of a setf    function, however, this can trivially be done with property lists or    generated symbols.    The cost of making the SETF macro expand into a call to a setf function,    when it does not find a setf macro or a regular macro to expand, is    negligible.    This will be an incompatible change for Symbolics, since it already has    setf functions but they do not take the same arguments as proposed here.    However, the change is considered worthwhile.    Cost of non-adoption:    Non-adoption of this proposal would be a significant roadblock to the    Common Lisp Object System.  Some major rethinking of CLOS would be    required.    Benefits:    Allow CLOS to be defined without out-of-hand complexity.    Conversion Cost:    None, this is an upward-compatible change.    Esthetics:    SETF would be more esthetic, but less powerful, if it had only the    proposed setf functions and did not have setf macros.  Such a major    incompatible change is of course out of the question, however by    stressing setf functions SETF could become easier to teach.perhaps "by stressing the use of setf functions and no explicit setfmacros SETF could become easier to teach.".I really believe that many people will stop defining setf macros oncethis proposal is accepted.      Discussion:    Note that in Common Lisp, setf macroexpansion is an operation on    function names, not on functions.  It differs from some dialects of    Scheme, such as T, in this respect.  This proposal does not attempt to    change that.    The following related features were considered but are specifically    not being proposed at this time, since they are unnecessary for CLOS    and appear not to improve the simplicity and esthetics of the language:      Lexically local setf macros, that is, a cross between defsetf and      macrolet.  This does not appear to be logically necessary.  Do all three      ways of defining lexically global setf macros need local counterparts?        Should we define the meaning of defmacro or macrolet of (setf foo)?      This would be a fourth way to define a setf macro.        Should we enhance the definition of global setf macros, for example to      say that (macro-function '(setf foo)) returns an expander function that      takes two arguments and returns five values?        Should we introduce a new name for symbol-function, since it accepts      non-symbols now?-------*start*01906 00024 US Return-Path: <@SAIL.Stanford.EDU:Masinter.pa@Xerox.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 OCT 87 17:59:36 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 22 Oct 87  17:57:25 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 22 OCT 87 17:53:59 PDTDate: 22 Oct 87 17:51 PDTFrom: Masinter.paSubject: Re: SETF-FUNCTION-VS-MACRO (Version 1)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 15 Oct 87 17:11 EDTTo: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@sail.stanford.eduMessage-ID: <871022-175359-5842@Xerox>I propose releasing this issue with the following changes to thediscussion section:Add these paragraphs before the section "The following related featureswere considered..." :There was some concern about introducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.However, the CLOS unsuccessfully tried a number of alternatives.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  Add this paragraph to the end of "The following related features wereconsidered...":	Should one allow these extended function names in the car-position of	an expression to be evaluated? The extra complexity didn't seemjustified,	instead, an explicit funcall is required.*start*00995 00024 US Return-Path: <@SAIL.Stanford.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 OCT 87 18:42:24 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 22 Oct 87  18:39:48 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 261570; Thu 22-Oct-87 21:39:53 EDTDate: Thu, 22 Oct 87 21:39 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: SETF-FUNCTION-VS-MACRO (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871022-175359-5842@Xerox>Message-ID: <19871023013955.7.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 22 Oct 87 17:51 PDT    From: Masinter.pa@Xerox.COM    I propose releasing this issue with the following changes to the    discussion section....Those amendments are fine with me.  I was planning to add them myself,and I apologize for being slow to get around to it.*start*03386 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 23 OCT 87 15:14:34 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 262399; Fri 23-Oct-87 18:14:18 EDTDate: Fri, 23 Oct 87 18:14 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 1)To: Gregor.pacc: Scott E. Fahlman <Fahlman@C.CS.CMU.EDU>, Masinter.pa, CL-Cleanup@sail.stanford.eduIn-Reply-To: <871023143012.1.GREGOR@SPIFF.isl.parc.xerox.com>Message-ID: <19871023221404.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Fri, 23 Oct 87 14:30 PDT    From: Gregor.pa@Xerox.COM    In particular, I would like it to be the case that however we finally    write this up, we make it clear that in many cases (not all cases)    defsetf is now obsolete.  I believe that having programs which don't    need to use defsetf avoid doing so will considerably simplify the Common    Lisp evaluator as seen by those programmers.  I believe that teaching    the style of SETF which doesn't use defsetf (long) before the style    which does will make it more understandable to students.I agree with this, but I think "obsolete" might be too strong a word.What we're saying is that using setf functions instead of setf macroswherever you can is good programming style.  I think the analogy to regularmacros is compelling.  In the old days people used to over-use macros,or even worse fsubrs, where they could just as well have used functions;eventually it was widely realized that this was a bad idea, and thatmacros should only be used where you are actually trying to do syntaxextensions.  This didn't mean macros were obsolete, it just meant thatpeople better understood when it was good programming style to use them.In the CL-Cleanup proposal form, this would go in the Benefits section.	Date: Thu, 15 Oct 87 20:21 EDT	From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>	I have no problem with this proposal, except for the notion that the	name of the setf-function associated with FOO should be a list, (SETF	FOO).    Of course another solution to this problem would be to say that the    function name for the "setf function" for FOO is |SETF FOO|.    Specifically, instead of having the mapping:       package::foo  ==>  (setf package::foo)       package::foo  ==>  package::|SETF FOO|    Of course |bar| would become |SETF bar|.    The advantage of this is it doesn't require introducing list function    specs.Right.  The problem is that "package::" above hides a multitude ofsins.  How is (defun (setf car) (new-car cons) (rplaca cons new-car) new-car)to be written in your proposal?  There is a separate symbol |SETF CAR|in every package, unless this (and all possible others) is pre-internedin the Lisp package.  I think what this shows is that if we want to deriveone object from another object, in Lisp doing this with list processingworks a whole lot better than doing it with string processing.It might be worth putting this little digression into the Discussion section.    If we do introduce list function specs, we have to decide wether they    can appear as the car of a form (I assume they can't).The latest version states that they can't.*start*02513 00024 US Date: Fri, 23 Oct 87 14:30 PDTFrom: Gregor.paSubject: SETF-FUNCTION-VS-MACRO (Version 1)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>,    Scott E. Fahlman <Fahlman@C.CS.CMU.EDU>, Masinter.pacc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <19871015211100.8.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <FAHLMAN.12342792040.BABYL@C.CS.CMU.EDU>,             <19871016003933.6.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <FAHLMAN.12342796585.BABYL@C.CS.CMU.EDU>,             <19871023013955.7.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <871022-175359-5842@Xerox>Message-ID: <871023143012.1.GREGOR@SPIFF.isl.parc.xerox.com>Line-fold: no    Date: Thu, 15 Oct 87 17:11 EDT    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>First let me say that I am a very strong supporter of this proposal.Moon and I actually worked on it a fair amount before he wrote it up, Ithink it would be a significant improvement to the language.In particular, I would like it to be the case that however we finallywrite this up, we make it clear that in many cases (not all cases)defsetf is now obsolete.  I believe that having programs which don'tneed to use defsetf avoid doing so will considerably simplify the CommonLisp evaluator as seen by those programmers.  I believe that teachingthe style of SETF which doesn't use defsetf (long) before the stylewhich does will make it more understandable to students.    Date: Thu, 15 Oct 87 20:21 EDT    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    I have no problem with this proposal, except for the notion that the    name of the setf-function associated with FOO should be a list, (SETF    FOO).  This seems like a more radical change than is really necessary to    accomplish the stated purposes.  It is a considerable extension to the    idea of a "function name", at least for standard Common Lisp    implementations that do not implement Lisp machine style    function-specs.Of course another solution to this problem would be to say that thefunction name for the "setf function" for FOO is |SETF FOO|.Specifically, instead of having the mapping:   package::foo  ==>  (setf package::foo)   package::foo  ==>  package::|SETF FOO|Of course |bar| would become |SETF bar|.The advantage of this is it doesn't require introducing list functionspecs.If we do introduce list function specs, we have to decide wether theycan appear as the car of a form (I assume they can't).-------*start*01584 00024 US Return-Path: <@SAIL.Stanford.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 16:53:01 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 25 Oct 87  16:50:02 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 25 Oct 87 19:50:33-ESTDate: Sun, 25 Oct 87 19:50 ESTMessage-ID: <FAHLMAN.12345418731.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: SETF-FUNCTION-VS-MACRO (Version 1)In-reply-to: Msg of 23 Oct 1987  18:14-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>    What we're saying is that using setf functions instead of setf macros    wherever you can is good programming style.  I think the analogy to regular    macros is compelling.  In the old days people used to over-use macros,    or even worse fsubrs, where they could just as well have used functions;    eventually it was widely realized that this was a bad idea, and that    macros should only be used where you are actually trying to do syntax    extensions.  This didn't mean macros were obsolete, it just meant that    people better understood when it was good programming style to use them.Another reason for using macros is because you don't trust the inlinedeclaration to do its job in some implementations under some conditions.Which reminds me, we might want to say explicitly that(proclaim '(inline (setf foo))) is allowed.-- Scott*start*01067 00024 US Return-Path: <@SAIL.Stanford.EDU:Moon@ALLEGHENY.SCRC.Symbolics.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 09:38:36 PSTReceived: from [128.81.41.45] by SAIL.STANFORD.EDU with TCP; 26 Oct 87  09:35:00 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by ALLEGHENY.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 69583; Mon 26-Oct-87 12:26:44 ESTDate: Mon, 26 Oct 87 12:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 1)To: Scott E. Fahlman <Fahlman@C.CS.CMU.EDU>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12345418731.BABYL@C.CS.CMU.EDU>Message-ID: <19871026172642.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sun, 25 Oct 1987  19:50 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    ....we might want to say explicitly that    (proclaim '(inline (setf foo))) is allowed.Version 1 of the proposal said that.  I didn't keep a copy ofversion 2, so I can't check, but I assume version 2 said so also.*start*11457 00024 US Date: 26 Oct 87 16:51 PSTFrom: Masinter.paSubject: SETF-FUNCTION-VS-MACRO (Version 2)To: CL-Cleanup@sail.stanford.eduCC: Masinterline-fold: 80I made the edits as previously announced. I added to Benefits the improved utility of SETF independent of CLOS. I made a grammatical change somewhere (I'm having trouble finding it), where I added a semicolon and changed the active element of a sentence. I made several changes in case. Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon		   (based on discussion among the CLOS working group)		     Version 2, 26-Oct-87 Masinter, minor modsPROBLEM DESCRIPTION:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSis much simpler in the relevant areas.PROPOSAL (SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The form (setf (-name- ...) ...), when -name- is defined as a function(rather than a macro) and no setf macro has been defined for -name-,expands into a call to a setf function.  The name of this setf functionis a list (setf -name-), where -name- is a symbol.  The functions,macros, and special forms defined in CLtL and listed in the Referencessection above need to be enhanced to accept such lists in addition tosymbols as function names, so that setf functions can be defined andmanipulated.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)		;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.Examples:;If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when rules 1-3 do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))	(temp-vars (do ((a (cdr form) (cdr a))			(v nil (cons (gensym) v)))		       ((null a) v))))    (values temp-vars (cdr form) (list new-value)	    `(funcall #'(setf ,(car form))		      ,new-value ,@temp-vars)	    `(,(car form) ,@temp-vars))))RATIONALE:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.  In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a similar feature,in that they allow setting functions named (SETF reader).  We don'tknow of any implementation that has precisely the proposed feature.ADOPTION COST:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.COST OF NON-ADOPTION:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.BENEFITS:Allow CLOS to be defined without out-of-hand complexity. Improve usability of SETF.CONVERSION COST:None, this is an upward-compatible change.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.DISCUSSION:Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.There was some concern about introducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.However, the CLOS unsuccessfully tried a number of alternatives.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  This proposal is not incompatible with other extensions to function specifications present in some implementations. The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.  d)  Introduce a new name for SYMBOL-FUNCTION, since it accepts    non-symbols now. e)  Should one allow these extended function names in the car-position of	an expression to be evaluated? The extra complexity didn't seem     justified, instead, an explicit FUNCALL is required.        TITAN          TITAN           
TIMESROMAN 
                                                   
                                  3             
      [                                                             
       W              -                          }      +D z*start*11456 00024 US Return-Path: <@SAIL.Stanford.EDU:Masinter.pa@Xerox.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 16:58:35 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 26 Oct 87  16:55:41 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 26 OCT 87 16:54:30 PSTDate: 26 Oct 87 16:51 PSTFrom: Masinter.paSubject: SETF-FUNCTION-VS-MACRO (Version 2)To: CL-Cleanup@sail.stanford.eduCC: Masinter.paline-fold: 80Message-ID: <871026-165430-2342@Xerox>I made the edits as previously announced. I added to Benefits theimproved utility of SETF independent of CLOS. I made a grammaticalchange somewhere (I'm having trouble finding it), where I added asemicolon and changed the active element of a sentence. I made severalchanges in case. !Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon		   (based on discussion among the CLOS working group)		     Version 2, 26-Oct-87 Masinter, minor modsPROBLEM DESCRIPTION:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSis much simpler in the relevant areas.PROPOSAL (SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The form (setf (-name- ...) ...), when -name- is defined as a function(rather than a macro) and no setf macro has been defined for -name-,expands into a call to a setf function.  The name of this setf functionis a list (setf -name-), where -name- is a symbol.  The functions,macros, and special forms defined in CLtL and listed in the Referencessection above need to be enhanced to accept such lists in addition tosymbols as function names, so that setf functions can be defined andmanipulated.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)		;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.Examples:;If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when rules 1-3 do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))	(temp-vars (do ((a (cdr form) (cdr a))			(v nil (cons (gensym) v)))		       ((null a) v))))    (values temp-vars (cdr form) (list new-value)	    `(funcall #'(setf ,(car form))		      ,new-value ,@temp-vars)	    `(,(car form) ,@temp-vars))))RATIONALE:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.  In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a similar feature,in that they allow setting functions named (SETF reader).  We don'tknow of any implementation that has precisely the proposed feature.ADOPTION COST:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.COST OF NON-ADOPTION:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.BENEFITS:Allow CLOS to be defined without out-of-hand complexity. Improve usability of SETF.CONVERSION COST:None, this is an upward-compatible change.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.DISCUSSION:Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.There was some concern about introducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.However, the CLOS unsuccessfully tried a number of alternatives.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  This proposal is not incompatible with other extensions to functionspecifications present in some implementations. The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.  d)  Introduce a new name for SYMBOL-FUNCTION, since it accepts    non-symbols now. e)  Should one allow these extended function names in the car-positionof	an expression to be evaluated? The extra complexity didn't seem     justified, instead, an explicit FUNCALL is required.*start*02623 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 28 OCT 87 21:11:48 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 266727; Thu 29-Oct-87 00:12:52 ESTDate: Thu, 29 Oct 87 00:10 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 2)To: Masinter.pa, Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.Stanford.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <871026-165430-2342@Xerox>Message-ID: <871029001055.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>In general, I support the idea of the SETF-FUNCTIONS proposal for this issue.I'd like to see some presentation issues get cleared up, though, before itgoes to X3J13... * Currently the proposal section says:    "The functions, macros, and special forms defined in CLtL and listed     in the References section above need to be enhanced to accept such     lists in addition to symbols as function names, so that setf functions     can be defined and manipulated."   I'm sympathetic to this in principle but I don't think this is adequately   explicit for us to vote in. For example,    . I think we have to explicitly mention notation issues such as the      syntax for INLINE and FTYPE declarations in the proposal section.    . I think we have to mention how DEFUN and FLET are extended, not just      provide examples that seem to imply something.    . We need to talk about what FMAKUNBOUND, FBOUNDP, DISASSEMBLE,      DOCUMENTATION, etc. individually/explicitly. It's ok for Moon to have      proposed the issue to CL-Cleanup at this level of sketchiness so he      didn't have to work too hard to get it on the table, but I think we      should flesh this out before it goes to the full committee. Experience      with places in CLtL that ask the reader to extrapolate should have       taught us by now that this is pretty dangerous to depend upon. * Moon's reply to Gregor's remark about package::|SETF -name-| is important.   In general, such an approach would require the space of symbols in the   given package to be extended if you wanted to make something SETF-able   which had not previously been. Using the list notation does not have this   bad misfeature. This should definitely be mentioned in the discussion. * The lettered items in the discussion (paths not taken) should be worded   in some sort of parallel style. As it is now, some seem to be questions and   some statements.*start*02739 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 29 OCT 87 10:50:41 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 29 Oct 87  10:47:52 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 267277; Thu 29-Oct-87 13:43:12 ESTDate: Thu, 29 Oct 87 13:43 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 2)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.pa, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871029001055.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19871029184314.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Thu, 29 Oct 87 00:10 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    In general, I support the idea of the SETF-FUNCTIONS proposal for this issue.    I'd like to see some presentation issues get cleared up, though, before it    goes to X3J13...     * Currently the proposal section says:	"The functions, macros, and special forms defined in CLtL and listed	 in the References section above need to be enhanced to accept such	 lists in addition to symbols as function names, so that setf functions	 can be defined and manipulated."       I'm sympathetic to this in principle but I don't think this is adequately       explicit for us to vote in. For example,	. I think we have to explicitly mention notation issues such as the	  syntax for INLINE and FTYPE declarations in the proposal section.	. I think we have to mention how DEFUN and FLET are extended, not just	  provide examples that seem to imply something.	. We need to talk about what FMAKUNBOUND, FBOUNDP, DISASSEMBLE,	  DOCUMENTATION, etc. individually/explicitly. It's ok for Moon to have	  proposed the issue to CL-Cleanup at this level of sketchiness so he	  didn't have to work too hard to get it on the table, but I think we	  should flesh this out before it goes to the full committee. Experience	  with places in CLtL that ask the reader to extrapolate should have 	  taught us by now that this is pretty dangerous to depend upon.I don't understand what you find insufficiently explicit about this now.Do you mean that we should say  (defun (setf foo) ...) works like (defun foo ...)  (flet (((setf foo) ... works like (flet ((foo ...  (declare (inline (setf foo))) works like (declare (inline foo))  (symbol-function '(setf foo)) works like (symbol-function 'foo)  and so on for all the rest of them?That seems pretty pointless to me.  You must mean something more profound,but I don't see what.    ....*start*02648 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 29 OCT 87 13:51:06 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 267277; Thu 29-Oct-87 13:43:12 ESTDate: Thu, 29 Oct 87 13:43 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 2)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.pa, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871029001055.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19871029184314.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Thu, 29 Oct 87 00:10 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    In general, I support the idea of the SETF-FUNCTIONS proposal for this issue.    I'd like to see some presentation issues get cleared up, though, before it    goes to X3J13...     * Currently the proposal section says:	"The functions, macros, and special forms defined in CLtL and listed	 in the References section above need to be enhanced to accept such	 lists in addition to symbols as function names, so that setf functions	 can be defined and manipulated."       I'm sympathetic to this in principle but I don't think this is adequately       explicit for us to vote in. For example,	. I think we have to explicitly mention notation issues such as the	  syntax for INLINE and FTYPE declarations in the proposal section.	. I think we have to mention how DEFUN and FLET are extended, not just	  provide examples that seem to imply something.	. We need to talk about what FMAKUNBOUND, FBOUNDP, DISASSEMBLE,	  DOCUMENTATION, etc. individually/explicitly. It's ok for Moon to have	  proposed the issue to CL-Cleanup at this level of sketchiness so he	  didn't have to work too hard to get it on the table, but I think we	  should flesh this out before it goes to the full committee. Experience	  with places in CLtL that ask the reader to extrapolate should have 	  taught us by now that this is pretty dangerous to depend upon.I don't understand what you find insufficiently explicit about this now.Do you mean that we should say  (defun (setf foo) ...) works like (defun foo ...)  (flet (((setf foo) ... works like (flet ((foo ...  (declare (inline (setf foo))) works like (declare (inline foo))  (symbol-function '(setf foo)) works like (symbol-function 'foo)  and so on for all the rest of them?That seems pretty pointless to me.  You must mean something more profound,but I don't see what.    ....*start*04456 00024 US Return-Path: <KMP@MEAD.SCRC.Symbolics.COM>Received: from MEAD.SCRC.Symbolics.COM ([128.81.41.234]) by Xerox.COM ; 29 OCT 87 12:42:03 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by MEAD.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 105872; Thu 29-Oct-87 15:17:24 ESTDate: Thu, 29 Oct 87 15:15 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 2)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Masinter.pa, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19871029184314.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <871029151550.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Thu, 29 Oct 87 13:43 EST    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    ...    I don't understand what you find insufficiently explicit about this now.    Do you mean that we should say      (defun (setf foo) ...) works like (defun foo ...)      (flet (((setf foo) ... works like (flet ((foo ...      (declare (inline (setf foo))) works like (declare (inline foo))      (symbol-function '(setf foo)) works like (symbol-function 'foo)      and so on for all the rest of them?    That seems pretty pointless to me.  You must mean something more profound,    but I don't see what.    ...I don't think I meant anything drastically profound in any given case, but Ido think it's more important to do this enumeration than you're suggesting.Many ``obvious'' things follow from the statements in your proposal, but someof them may be surprising to some people, depending on how far their forwardchaining theorem prover runs when they read the descriptions you've provided.And in a few cases, I bet we've not thought out all the consequences enoughto realize the subtle pitfalls that might follow... * Some people will distrust their ability to extrapolate and be likely   to say to themselves: ``Surely they couldn't have meant that I should   write (SYMBOL-FUNCTION '(SETF FOO)).'' By stating this explicitly,   we'll confirm that this extrapolation is correct. * Some people may expect that    (DEFUN (SETF FOO) (VAL) ...)   sets up (DOCUMENTATION '(SETF FOO) 'FUNCTION) while others may expect   that it sets up (DOCUMENTATION 'FOO 'SETF). Some may expect that    (DOCUMENTATION 'FOO 'SETF) is oboleted, while others may assume that   you now have to know how the SETF thing was defined in order to get   its documentation. Others may expect (DOCUMENTATION 'FOO 'SETF) to    apply only to SETF macros and (DOCUMENTATION '(SETF FOO) 'FUNCTION)   to apply to SETF functions, independently of how they're defined. * Some people may wonder whether (FLET ((FOO ...)) ...) will implicitly   make (SETF FOO) lexically funbound. By writing things out in English,   we have a place where we can be explicit remarks about this. They may   be redundant with logical consequences of things you've already written,   but I think some such redundancy is appropriate in a proposal of this   kind. * By the way, some people, myself included, have functions which map   down existing linguistic constructs such as declarations and do things   like GET on them because they presuppose that the things they're   operating on will be symbols. Since GET works only on symbols, such   code will be broken by this so-called upward compatible change. A more   subtle consequence is something which takes a function name and does   MEMBER into a list of function names. That won't blow out but unless   :TEST #'EQUAL is added, it will no longer reliably find the function name.   By mentioning things like (PROCLAIM '(INLINE (SETF FOO))) you may trigger   a red flag in some people's brains that alerts them to a potential   impact of this change which you had not anticipated. * You need to specify things like how the implicit block in (SETF FOO)   generalizes. Does (RETURN-FROM (SETF FOO) ...) work, or does it just   create a (BLOCK FOO ...).I could probably think of more of these. I think that by making a little paragraphthat claims to explain the extrapolation technique for each of these functions,we will make it more likely that someone will notice other little nagging oversightsthat need to be explicitly addressed. As long as you just say "and these willbe attended to in the obvious way" there is nothing to criticize/correct and yetgrave potential for loose ends to be left dangling.*start*06902 00024 US Return-Path: <@SAIL.STANFORD.EDU:Gregor.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 02 OCT 87 16:42:25 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Oct 87  16:40:11 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 02 OCT 87 16:38:07 PDTDate: Fri, 2 Oct 87 16:37 PDTFrom: Gregor.paSubject: fixing our problems with setfTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Patrick H Dussud <DUSSUD%Jenner@ti-csl.CSNET>cc: Common-Lisp-Object-System@Sail.Stanford.edu, Gregor.paIn-Reply-To: <870921163510.2.MOON@EUPHRATES.SCRC.Symbolics.COM>,              <2768308570-8410382@Jenner>,              <870928165521.9.MOON@EUPHRATES.SCRC.Symbolics.COM>,              <870921200005.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <871002163721.4.GREGOR@SPIFF.isl.parc.xerox.com>Line-fold: noAs I believe I made clear before, I believe Common Lisp would be abetter language if setf facility it provided was a lot simpler.  Thismessage starts by making more clear what it is I think would have been abetter original design, it then goes on to propose a clean up of setfwhich has many of the same nice properties but is compatible with thecurrent situation.In my 'improved original design' the setf mechanism would just be anabbreviation for calling a function whose name was (SETF -symbol-).There would be no defsetf or any other mechanism for changing the waythe setf macro would expand under certain circumstances.  Here is anexample of how this would work:(setq mex (macroexpand '(setf (foo 1 2) 3)))(LET ((#:G0 1)      (#:G1 2)      (#:G2 3))  (FUNCALL #'(SETF FOO) #:G2 #:G0 #:G1));;;;;; at this point, assuming there was no previous definition for;;; (setf foo) attempting to evaluate the form bound to MEX would;;; signal an error.;;;(eval mex)>Error: undefined function (SETF FOO)...;;;;;; but if we define a function (SETF FOO) then eval of mex would work;;; as expected(defun (setf foo) (new-value indicator) ...)What are the features of this mechanism:  The macroexpansion of setf does not depend on any defining form,lexical environment, compile environment or anything.  Because it is notpossible to do a 'top-level' definition for setf expansion, there are noproblems with wanting to do a lexical binding of a rule for setfexpansion.  Also because the expansion of setf does not depend on the argumentlist of FOO or (SETF FOO), there can't be any problems with having tore-expand (recompile) code after the defun for foo or (setf foo)changes.  This rule for setf always puts the new value argument as thefirst of the other arguments, this rule always works since it doesn'tdepend on the definition of FOO or (SETF FOO).Of course, proposing to Common Lisp that they completely do away withdefsetf is probably too radical a proposal.  But I believe there is auseful intermediate ground which could help us all.1) Change the behavior of setf so that in the absence of any   special information provided by defsetf it expands as shown   above.2) Add the setf function spec to the language to support this.   But note that the forms like defun and defmethod would only   have one lambda-list.  The programmer would know that the   function/method will be receiving the new-value as its first   argument.3) Document very clearly that this is the suggested way of using   setf and that the only real reason to continue using the old   form of setf is to do things like LDB or other fundamentally   macro-ish things.I believe this proposal solves many of the problems previously raised ina clean simple way:    Date: Tue, 22 Sep 87 09:36:10 CDT    From: Patrick H Dussud <DUSSUD%Jenner@ti-csl.CSNET>    The problem is that we can't always specialize on the new-value argument    using the short defsetf form.  The programmer will have to write a hocky    defsetf form to get around the problem of having optional arguments    (e.g.  implementing the setf form of SUBSEQ as a generic function).  We    lose the COMBINE-LAMBDA-LISTS abstraction.In this scheme we can always specialize on the new value form since theprogrammer can count on it coming in as the first argument to the setffunction.    Date: Mon, 28 Sep 87 16:55 EDT    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    The next issue is what to do about the lambda-list of a setf-function.    We already agreed on what is the lambda-list in the expansion of    (defun (setf foo) ...) into     (setf (symbol-function '(setf foo)) #'(lambda ...)).  Specifically,    #'(setf foo) takes one more required argument than #'foo, and the last    required argument is the new value to be stored.    The issue is whether certain function-defining macros should have a    special syntax with two lambda-lists when defining a setf function, or    should use their normal syntax.  The macros in question are defun, flet,    labels, defgeneric, defmethod, and the :method option to defgeneric,    generic-flet, generic-labels, and with-added-methods.  In favor of two    lambda-lists is that it's easier for the programmer to see which    parameter is bound to the new value to be stored.  In favor of one    lambda-list is syntactic consistency between setf functions and regular    functions.  At the meeting two weeks ago, we favored two lambda-lists,    but I now believe that that was a mistake.  The rule that the new value    is the last required argument should not be at all difficult for    programmers to understand.  Syntactic consistency is important.I believe making it be the first argument is better because the rule youpropose loses in the following scenario.(defun foo (a b) ..)(defun (setf foo) (a b new-value) ..)(defun code-calling-setf-of-foo ()  (setf (foo a b) c))Now at this point the programmer realizes that they would rather havethe second argument to FOO be optional.  But they are screwed becausethey have to go back and recompile all the code that uses setf of foo.    The remaining issue is a scoping issue.  We have introduced lexically    local setf functions, where before Common Lisp only had lexically global    setf macros.  Thus the namespace of setf operators has been extended to    have a lexical component, just like the namespace of regular operators.    (Recall that "operator" means the union of functions, macros, and    special forms).  Regular functions and setf functions naturally come in    pairs, but since they are defined separately we have to specify what    happens in various cases where only one is defined at a given lexical    contour.Scoping is not a problem in my proposal provided the programmer neveruses defsetf.  Because setf always expands the same way, all theprogrammer needs to do is provide lexical definitions for the actualsetf function (SETF FOO).-------*start*07298 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 04 NOV 87 11:31:11 PSTReceived: from SCRC-RIVERSIDE.ARPA by SAIL.STANFORD.EDU with TCP; 4 Nov 87  11:25:38 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 184902; Wed 4-Nov-87 14:17:54 ESTDate: Wed, 4 Nov 87 14:17 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 2)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.pa, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871029151550.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19871104191709.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Thu, 29 Oct 87 15:15 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>	Date: Thu, 29 Oct 87 13:43 EST	From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>	...	I don't understand what you find insufficiently explicit about this now.	Do you mean that we should say	  (defun (setf foo) ...) works like (defun foo ...)	  (flet (((setf foo) ... works like (flet ((foo ...	  (declare (inline (setf foo))) works like (declare (inline foo))	  (symbol-function '(setf foo)) works like (symbol-function 'foo)	  and so on for all the rest of them?	That seems pretty pointless to me.  You must mean something more profound,	but I don't see what.	...    I don't think I meant anything drastically profound in any given case, but I    do think it's more important to do this enumeration than you're suggesting.    Many ``obvious'' things follow from the statements in your proposal, but some    of them may be surprising to some people, depending on how far their forward    chaining theorem prover runs when they read the descriptions you've provided.I guess you're right.  I don't think I'm going to find the time to elaboratethis proposal in the immediate future though.    And in a few cases, I bet we've not thought out all the consequences enough    to realize the subtle pitfalls that might follow...I don't think so, but let's discuss the individual points you listed below.     * Some people will distrust their ability to extrapolate and be likely       to say to themselves: ``Surely they couldn't have meant that I should       write (SYMBOL-FUNCTION '(SETF FOO)).'' By stating this explicitly,       we'll confirm that this extrapolation is correct.I can't imagine anyone seriously thinking this, when the proposal says:  The functions,  macros, and special forms defined in CLtL and listed in the References  section above need to be enhanced to accept such lists in addition to  symbols as function names, so that setf functions can be defined and  manipulated.If this doesn't mean that SYMBOL-FUNCTION accepts such a list in additionto accepting a symbol, then what does it mean?Aside: in the next edit, the above sentence should read "The functions,macros, special forms, and declarations ...."     * Some people may expect that	(DEFUN (SETF FOO) (VAL) ...)       sets up (DOCUMENTATION '(SETF FOO) 'FUNCTION) while others may expect       that it sets up (DOCUMENTATION 'FOO 'SETF). Some may expect that        (DOCUMENTATION 'FOO 'SETF) is oboleted, while others may assume that       you now have to know how the SETF thing was defined in order to get       its documentation. Others may expect (DOCUMENTATION 'FOO 'SETF) to        apply only to SETF macros and (DOCUMENTATION '(SETF FOO) 'FUNCTION)       to apply to SETF functions, independently of how they're defined.You're right that the proposal needs to say that we are not changing whatCLtL says about (documentation foo 'setf), namely that it applies to defsetf(and define-setf-method, that's an omission in CLtL).     * Some people may wonder whether (FLET ((FOO ...)) ...) will implicitly       make (SETF FOO) lexically funbound. I can't imagine why anyone would think that.  Common Lisp doesn't evenhave a concept of lexically funbound names (although I think it perhaps ought to).					   By writing things out in English,       we have a place where we can be explicit remarks about this. They may       be redundant with logical consequences of things you've already written,       but I think some such redundancy is appropriate in a proposal of this       kind.     * By the way, some people, myself included, have functions which map       down existing linguistic constructs such as declarations and do things       like GET on them because they presuppose that the things they're       operating on will be symbols. Since GET works only on symbols, such       code will be broken by this so-called upward compatible change. By that reasoning, no language extension of any sort is ever upward compatible,because a program that purports to understand the entire language won'tknow about it.  So I think when we call a change upward-compatible, we mustnot be referring to its effect on program-understanding programs.								       A more       subtle consequence is something which takes a function name and does       MEMBER into a list of function names. That won't blow out but unless       :TEST #'EQUAL is added, it will no longer reliably find the function name.       By mentioning things like (PROCLAIM '(INLINE (SETF FOO))) you may trigger       a red flag in some people's brains that alerts them to a potential       impact of this change which you had not anticipated.The proposal does say that the INLINE declaration works with (SETF FOO).  I don'tsee why the INLINE declaration is more likely to trigger a "red flag" than anythingelse, though.  You're right that some programs that assume all function namesare symbols will break if someone feeds them one of these new function names.In the next version we should add a brief note about that to "conversion cost"(not "adoption cost", because these programs are not required by CLtL, but aresomething added on top of Common Lisp, even if they are written by implementorsand used as part of a Common Lisp compiler.  At least, that's my understanding ofthe difference between these two very similar sections of the CL-Cleanup form.)     * You need to specify things like how the implicit block in (SETF FOO)       generalizes. Does (RETURN-FROM (SETF FOO) ...) work, or does it just       create a (BLOCK FOO ...).Good point, that should be added in the next version.    I could probably think of more of these. I think that by making a little paragraph    that claims to explain the extrapolation technique for each of these functions,    we will make it more likely that someone will notice other little nagging oversights    that need to be explicitly addressed. As long as you just say "and these will    be attended to in the obvious way" there is nothing to criticize/correct and yet    grave potential for loose ends to be left dangling.I will send out a revised proposal with the above small corrections, but I don'tthink it's desirable to write a whole paragraph about each of the 16 languageentities named in the References section.  Note that the proposal says nothingabout "attended to in the obvious way".*start*12307 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 04 NOV 87 11:31:32 PSTReceived: from SCRC-RIVERSIDE.ARPA by SAIL.STANFORD.EDU with TCP; 4 Nov 87  11:26:09 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 184904; Wed 4-Nov-87 14:27:05 ESTDate: Wed, 4 Nov 87 14:27 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (version 3)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <19871104192703.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon                   (based on discussion among the CLOS working group)               Version 2, 26-Oct-87 Masinter, minor mods               Version 3, 4-Nov-87 Moon, small clarifications at KMP's urgingPROBLEM DESCRIPTION:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSis much simpler in the relevant areas.PROPOSAL (SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The form (setf (-name- ...) ...), when -name- is defined as a function(rather than a macro) and no setf macro has been defined for -name-,expands into a call to a setf function.  The name of this setf functionis a list (setf -name-), where -name- is a symbol.  The body of thisfunction is surrounded by an implicit block named -name-.The functions, macros, special forms, and declarations defined in CLtLand listed in the References section above need to be enhanced to acceptsuch lists in addition to symbols as function names, so that setffunctions can be defined and manipulated.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)          ;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.What CLtL says about (documentation foo 'setf) will not change.Specifically, the setf documentation type applies just to defsetf (anddefine-setf-method, that's an omission in CLtL).  The documentation fora setf function, as for any function, is retrieved by(documentation '(setf foo) 'function).Examples:;If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when rules 1-3 do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))        (temp-vars (do ((a (cdr form) (cdr a))                        (v nil (cons (gensym) v)))                       ((null a) v))))    (values temp-vars (cdr form) (list new-value)            `(funcall #'(setf ,(car form))                      ,new-value ,@temp-vars)            `(,(car form) ,@temp-vars))))RATIONALE:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.  In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a similar feature,in that they allow setting functions named (SETF reader).  We don'tknow of any implementation that has precisely the proposed feature.ADOPTION COST:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.COST OF NON-ADOPTION:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.BENEFITS:Allow CLOS to be defined without out-of-hand complexity. Improve usability of SETF.CONVERSION COST:None, this is an upward-compatible change.As with any language extension, some program-understanding programs mayneed to be enhanced.  A particular issue here is programs that assumethat all function names are symbols.  They may use GET to accessproperties of a function name or use EQ or EQL (perhaps via MEMBER orASSOC) to compare function names for equality.  Such programs will needimprovement before they can understand programs that use the newfeature, but otherwise they will still work.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.DISCUSSION:Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.There was some concern about introducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.However, the CLOS unsuccessfully tried a number of alternatives.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  This proposal is not incompatible with other extensions to functionspecifications present in some implementations. The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.  d)  Introduce a new name for SYMBOL-FUNCTION, since it accepts    non-symbols now. e)  Should one allow these extended function names in the car-position    of an expression to be evaluated? The extra complexity didn't seem    justified, instead, an explicit FUNCALL is required.*start*07302 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 04 NOV 87 11:41:45 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 4 Nov 87  11:38:03 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 271978; Wed 4-Nov-87 14:17:28 ESTDate: Wed, 4 Nov 87 14:17 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 2)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.pa, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871029151550.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19871104191709.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Thu, 29 Oct 87 15:15 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>	Date: Thu, 29 Oct 87 13:43 EST	From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>	...	I don't understand what you find insufficiently explicit about this now.	Do you mean that we should say	  (defun (setf foo) ...) works like (defun foo ...)	  (flet (((setf foo) ... works like (flet ((foo ...	  (declare (inline (setf foo))) works like (declare (inline foo))	  (symbol-function '(setf foo)) works like (symbol-function 'foo)	  and so on for all the rest of them?	That seems pretty pointless to me.  You must mean something more profound,	but I don't see what.	...    I don't think I meant anything drastically profound in any given case, but I    do think it's more important to do this enumeration than you're suggesting.    Many ``obvious'' things follow from the statements in your proposal, but some    of them may be surprising to some people, depending on how far their forward    chaining theorem prover runs when they read the descriptions you've provided.I guess you're right.  I don't think I'm going to find the time to elaboratethis proposal in the immediate future though.    And in a few cases, I bet we've not thought out all the consequences enough    to realize the subtle pitfalls that might follow...I don't think so, but let's discuss the individual points you listed below.     * Some people will distrust their ability to extrapolate and be likely       to say to themselves: ``Surely they couldn't have meant that I should       write (SYMBOL-FUNCTION '(SETF FOO)).'' By stating this explicitly,       we'll confirm that this extrapolation is correct.I can't imagine anyone seriously thinking this, when the proposal says:  The functions,  macros, and special forms defined in CLtL and listed in the References  section above need to be enhanced to accept such lists in addition to  symbols as function names, so that setf functions can be defined and  manipulated.If this doesn't mean that SYMBOL-FUNCTION accepts such a list in additionto accepting a symbol, then what does it mean?Aside: in the next edit, the above sentence should read "The functions,macros, special forms, and declarations ...."     * Some people may expect that	(DEFUN (SETF FOO) (VAL) ...)       sets up (DOCUMENTATION '(SETF FOO) 'FUNCTION) while others may expect       that it sets up (DOCUMENTATION 'FOO 'SETF). Some may expect that        (DOCUMENTATION 'FOO 'SETF) is oboleted, while others may assume that       you now have to know how the SETF thing was defined in order to get       its documentation. Others may expect (DOCUMENTATION 'FOO 'SETF) to        apply only to SETF macros and (DOCUMENTATION '(SETF FOO) 'FUNCTION)       to apply to SETF functions, independently of how they're defined.You're right that the proposal needs to say that we are not changing whatCLtL says about (documentation foo 'setf), namely that it applies to defsetf(and define-setf-method, that's an omission in CLtL).     * Some people may wonder whether (FLET ((FOO ...)) ...) will implicitly       make (SETF FOO) lexically funbound. I can't imagine why anyone would think that.  Common Lisp doesn't evenhave a concept of lexically funbound names (although I think it perhaps ought to).					   By writing things out in English,       we have a place where we can be explicit remarks about this. They may       be redundant with logical consequences of things you've already written,       but I think some such redundancy is appropriate in a proposal of this       kind.     * By the way, some people, myself included, have functions which map       down existing linguistic constructs such as declarations and do things       like GET on them because they presuppose that the things they're       operating on will be symbols. Since GET works only on symbols, such       code will be broken by this so-called upward compatible change. By that reasoning, no language extension of any sort is ever upward compatible,because a program that purports to understand the entire language won'tknow about it.  So I think when we call a change upward-compatible, we mustnot be referring to its effect on program-understanding programs.								       A more       subtle consequence is something which takes a function name and does       MEMBER into a list of function names. That won't blow out but unless       :TEST #'EQUAL is added, it will no longer reliably find the function name.       By mentioning things like (PROCLAIM '(INLINE (SETF FOO))) you may trigger       a red flag in some people's brains that alerts them to a potential       impact of this change which you had not anticipated.The proposal does say that the INLINE declaration works with (SETF FOO).  I don'tsee why the INLINE declaration is more likely to trigger a "red flag" than anythingelse, though.  You're right that some programs that assume all function namesare symbols will break if someone feeds them one of these new function names.In the next version we should add a brief note about that to "conversion cost"(not "adoption cost", because these programs are not required by CLtL, but aresomething added on top of Common Lisp, even if they are written by implementorsand used as part of a Common Lisp compiler.  At least, that's my understanding ofthe difference between these two very similar sections of the CL-Cleanup form.)     * You need to specify things like how the implicit block in (SETF FOO)       generalizes. Does (RETURN-FROM (SETF FOO) ...) work, or does it just       create a (BLOCK FOO ...).Good point, that should be added in the next version.    I could probably think of more of these. I think that by making a little paragraph    that claims to explain the extrapolation technique for each of these functions,    we will make it more likely that someone will notice other little nagging oversights    that need to be explicitly addressed. As long as you just say "and these will    be attended to in the obvious way" there is nothing to criticize/correct and yet    grave potential for loose ends to be left dangling.I will send out a revised proposal with the above small corrections, but I don'tthink it's desirable to write a whole paragraph about each of the 16 languageentities named in the References section.  Note that the proposal says nothingabout "attended to in the obvious way".*start*07204 00024 US Return-Path: <Moon@Riverside.SCRC.Symbolics.COM>Received: from Riverside.SCRC.Symbolics.COM (SCRC-RIVERSIDE.ARPA) by Xerox.COM ; 04 NOV 87 17:17:12 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by Riverside.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 184902; Wed 4-Nov-87 14:17:54 ESTDate: Wed, 4 Nov 87 14:17 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: SETF-FUNCTION-VS-MACRO (Version 2)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Masinter.pa, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871029151550.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Message-ID: <19871104191709.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Thu, 29 Oct 87 15:15 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>	Date: Thu, 29 Oct 87 13:43 EST	From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>	...	I don't understand what you find insufficiently explicit about this now.	Do you mean that we should say	  (defun (setf foo) ...) works like (defun foo ...)	  (flet (((setf foo) ... works like (flet ((foo ...	  (declare (inline (setf foo))) works like (declare (inline foo))	  (symbol-function '(setf foo)) works like (symbol-function 'foo)	  and so on for all the rest of them?	That seems pretty pointless to me.  You must mean something more profound,	but I don't see what.	...    I don't think I meant anything drastically profound in any given case, but I    do think it's more important to do this enumeration than you're suggesting.    Many ``obvious'' things follow from the statements in your proposal, but some    of them may be surprising to some people, depending on how far their forward    chaining theorem prover runs when they read the descriptions you've provided.I guess you're right.  I don't think I'm going to find the time to elaboratethis proposal in the immediate future though.    And in a few cases, I bet we've not thought out all the consequences enough    to realize the subtle pitfalls that might follow...I don't think so, but let's discuss the individual points you listed below.     * Some people will distrust their ability to extrapolate and be likely       to say to themselves: ``Surely they couldn't have meant that I should       write (SYMBOL-FUNCTION '(SETF FOO)).'' By stating this explicitly,       we'll confirm that this extrapolation is correct.I can't imagine anyone seriously thinking this, when the proposal says:  The functions,  macros, and special forms defined in CLtL and listed in the References  section above need to be enhanced to accept such lists in addition to  symbols as function names, so that setf functions can be defined and  manipulated.If this doesn't mean that SYMBOL-FUNCTION accepts such a list in additionto accepting a symbol, then what does it mean?Aside: in the next edit, the above sentence should read "The functions,macros, special forms, and declarations ...."     * Some people may expect that	(DEFUN (SETF FOO) (VAL) ...)       sets up (DOCUMENTATION '(SETF FOO) 'FUNCTION) while others may expect       that it sets up (DOCUMENTATION 'FOO 'SETF). Some may expect that        (DOCUMENTATION 'FOO 'SETF) is oboleted, while others may assume that       you now have to know how the SETF thing was defined in order to get       its documentation. Others may expect (DOCUMENTATION 'FOO 'SETF) to        apply only to SETF macros and (DOCUMENTATION '(SETF FOO) 'FUNCTION)       to apply to SETF functions, independently of how they're defined.You're right that the proposal needs to say that we are not changing whatCLtL says about (documentation foo 'setf), namely that it applies to defsetf(and define-setf-method, that's an omission in CLtL).     * Some people may wonder whether (FLET ((FOO ...)) ...) will implicitly       make (SETF FOO) lexically funbound. I can't imagine why anyone would think that.  Common Lisp doesn't evenhave a concept of lexically funbound names (although I think it perhaps ought to).					   By writing things out in English,       we have a place where we can be explicit remarks about this. They may       be redundant with logical consequences of things you've already written,       but I think some such redundancy is appropriate in a proposal of this       kind.     * By the way, some people, myself included, have functions which map       down existing linguistic constructs such as declarations and do things       like GET on them because they presuppose that the things they're       operating on will be symbols. Since GET works only on symbols, such       code will be broken by this so-called upward compatible change. By that reasoning, no language extension of any sort is ever upward compatible,because a program that purports to understand the entire language won'tknow about it.  So I think when we call a change upward-compatible, we mustnot be referring to its effect on program-understanding programs.								       A more       subtle consequence is something which takes a function name and does       MEMBER into a list of function names. That won't blow out but unless       :TEST #'EQUAL is added, it will no longer reliably find the function name.       By mentioning things like (PROCLAIM '(INLINE (SETF FOO))) you may trigger       a red flag in some people's brains that alerts them to a potential       impact of this change which you had not anticipated.The proposal does say that the INLINE declaration works with (SETF FOO).  I don'tsee why the INLINE declaration is more likely to trigger a "red flag" than anythingelse, though.  You're right that some programs that assume all function namesare symbols will break if someone feeds them one of these new function names.In the next version we should add a brief note about that to "conversion cost"(not "adoption cost", because these programs are not required by CLtL, but aresomething added on top of Common Lisp, even if they are written by implementorsand used as part of a Common Lisp compiler.  At least, that's my understanding ofthe difference between these two very similar sections of the CL-Cleanup form.)     * You need to specify things like how the implicit block in (SETF FOO)       generalizes. Does (RETURN-FROM (SETF FOO) ...) work, or does it just       create a (BLOCK FOO ...).Good point, that should be added in the next version.    I could probably think of more of these. I think that by making a little paragraph    that claims to explain the extrapolation technique for each of these functions,    we will make it more likely that someone will notice other little nagging oversights    that need to be explicitly addressed. As long as you just say "and these will    be attended to in the obvious way" there is nothing to criticize/correct and yet    grave potential for loose ends to be left dangling.I will send out a revised proposal with the above small corrections, but I don'tthink it's desirable to write a whole paragraph about each of the 16 languageentities named in the References section.  Note that the proposal says nothingabout "attended to in the obvious way".*start*12335 00024 UShDate: 14 Feb 88 13:40 PSTFrom: Masinter.paSubject: Issue: SETF-FUNCTION-VS-MACRO (version 3)To: X3J13@Sail.stanford.educc: Masinterline-fold: NOreply-to: CL-CLEANUP@Sail.Stanford.EDUThis issue was distributed at the November 1987 meeting.Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon                   (based on discussion among the CLOS working group)               Version 2, 26-Oct-87 Masinter, minor mods               Version 3, 4-Nov-87 Moon, small clarifications at KMP's urgingPROBLEM DESCRIPTION:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSis much simpler in the relevant areas.PROPOSAL (SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The form (setf (-name- ...) ...), when -name- is defined as a function(rather than a macro) and no setf macro has been defined for -name-,expands into a call to a setf function.  The name of this setf functionis a list (setf -name-), where -name- is a symbol.  The body of thisfunction is surrounded by an implicit block named -name-.The functions, macros, special forms, and declarations defined in CLtLand listed in the References section above need to be enhanced to acceptsuch lists in addition to symbols as function names, so that setffunctions can be defined and manipulated.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)          ;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.What CLtL says about (documentation foo 'setf) will not change.Specifically, the setf documentation type applies just to defsetf (anddefine-setf-method, that's an omission in CLtL).  The documentation fora setf function, as for any function, is retrieved by(documentation '(setf foo) 'function).Examples:;If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when rules 1-3 do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))        (temp-vars (do ((a (cdr form) (cdr a))                        (v nil (cons (gensym) v)))                       ((null a) v))))    (values temp-vars (cdr form) (list new-value)            `(funcall #'(setf ,(car form))                      ,new-value ,@temp-vars)            `(,(car form) ,@temp-vars))))RATIONALE:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.  In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a similar feature,in that they allow setting functions named (SETF reader).  We don'tknow of any implementation that has precisely the proposed feature.ADOPTION COST:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.COST OF NON-ADOPTION:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.BENEFITS:Allow CLOS to be defined without out-of-hand complexity. Improve usability of SETF.CONVERSION COST:None, this is an upward-compatible change.As with any language extension, some program-understanding programs mayneed to be enhanced.  A particular issue here is programs that assumethat all function names are symbols.  They may use GET to accessproperties of a function name or use EQ or EQL (perhaps via MEMBER orASSOC) to compare function names for equality.  Such programs will needimprovement before they can understand programs that use the newfeature, but otherwise they will still work.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.DISCUSSION:Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.There was some concern about introducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.However, the CLOS unsuccessfully tried a number of alternatives.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  This proposal is not incompatible with other extensions to functionspecifications present in some implementations. The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.  d)  Introduce a new name for SYMBOL-FUNCTION, since it accepts    non-symbols now. e)  Should one allow these extended function names in the car-position    of an expression to be evaluated? The extra complexity didn't seem    justified, instead, an explicit FUNCALL is required.        TITAN 
         TITAN 
          
TIMESROMAN 
          
TIMESROMAN 
           _       ^       <                                         
                                  3      #       
                                                                   
       W                                       }      . !z*start*01516 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 MAR 88 17:05:13 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 12 Mar 88  17:02:51 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 361839; Sat 12-Mar-88 20:03:09 ESTDate: Sat, 12 Mar 88 20:02 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-FUNCTION-VS-MACRO (version 3)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880214-134110-1441@Xerox>Message-ID: <880312200240.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>[X3J13 removed.]I support many ideas of this proposal, but I have two gripes which make mehave to oppose it: * I can't deal with the idea of generalizing SYMBOL-FUNCTION. I would like   to see FDEFINITION introduced and SYMBOL-FUNCTION left alone. * I'm also a little leary about TRACE being extended this way because   (TRACE (a list)) might later want to be interpreted as options rather   than as a function spec and I'd rather not have to risk heuristic resolution.   I would rather someone right now introduce a generalized syntax for TRACE   with syntactic space for trace options, such as      (TRACE (fn . options) (fn . options) (fn . options))   and then allow the generalized (non-symbol) fn to only occur within that   syntax so that no ambiguity results.*start*12335 00024 USfDate: 14 Feb 88 13:40 PSTFrom: Masinter.paSubject: Issue: SETF-FUNCTION-VS-MACRO (version 3)To: X3J13@Sail.stanford.educc: Masinterline-fold: NOreply-to: CL-CLEANUP@Sail.Stanford.EDUThis issue was distributed at the November 1987 meeting.Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon                   (based on discussion among the CLOS working group)               Version 2, 26-Oct-87 Masinter, minor mods               Version 3, 4-Nov-87 Moon, small clarifications at KMP's urgingPROBLEM DESCRIPTION:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSis much simpler in the relevant areas.PROPOSAL (SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The form (setf (-name- ...) ...), when -name- is defined as a function(rather than a macro) and no setf macro has been defined for -name-,expands into a call to a setf function.  The name of this setf functionis a list (setf -name-), where -name- is a symbol.  The body of thisfunction is surrounded by an implicit block named -name-.The functions, macros, special forms, and declarations defined in CLtLand listed in the References section above need to be enhanced to acceptsuch lists in addition to symbols as function names, so that setffunctions can be defined and manipulated.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)          ;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.What CLtL says about (documentation foo 'setf) will not change.Specifically, the setf documentation type applies just to defsetf (anddefine-setf-method, that's an omission in CLtL).  The documentation fora setf function, as for any function, is retrieved by(documentation '(setf foo) 'function).Examples:;If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when rules 1-3 do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))        (temp-vars (do ((a (cdr form) (cdr a))                        (v nil (cons (gensym) v)))                       ((null a) v))))    (values temp-vars (cdr form) (list new-value)            `(funcall #'(setf ,(car form))                      ,new-value ,@temp-vars)            `(,(car form) ,@temp-vars))))RATIONALE:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.  In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a similar feature,in that they allow setting functions named (SETF reader).  We don'tknow of any implementation that has precisely the proposed feature.ADOPTION COST:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.COST OF NON-ADOPTION:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.BENEFITS:Allow CLOS to be defined without out-of-hand complexity. Improve usability of SETF.CONVERSION COST:None, this is an upward-compatible change.As with any language extension, some program-understanding programs mayneed to be enhanced.  A particular issue here is programs that assumethat all function names are symbols.  They may use GET to accessproperties of a function name or use EQ or EQL (perhaps via MEMBER orASSOC) to compare function names for equality.  Such programs will needimprovement before they can understand programs that use the newfeature, but otherwise they will still work.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.DISCUSSION:Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.There was some concern about introducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.However, the CLOS unsuccessfully tried a number of alternatives.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  This proposal is not incompatible with other extensions to functionspecifications present in some implementations. The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.  d)  Introduce a new name for SYMBOL-FUNCTION, since it accepts    non-symbols now. e)  Should one allow these extended function names in the car-position    of an expression to be evaluated? The extra complexity didn't seem    justified, instead, an explicit FUNCALL is required.        TITAN 
         TITAN 
          
TIMESROMAN 
          
TIMESROMAN 
           _       ^       <                                         
                                  3      #       
                                                                   
       W                                       }      . !z*start*02168 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 00:28:15 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 20 Sep 88  00:28:02 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 20 SEP 88 00:13:04 PDTDate: 20 Sep 88 00:13 PDTFrom: masinter.paSubject: Re: Issue: SETF-FUNCTION-VS-MACRO (version 3)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Sat, 12 Mar 88 20:02 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880920-001304-3264@Xerox>The last message I can find on this issue is your message of last March. I'vemisplaced Mathis message with the last minutes meetings; while I did note mostof the issues that were passed and discussed. This one I recall was held up pending the function-spec proposal. However, I'msuprised we don't have a writeup past Version 3, given what I think werereasonable comments from Kent.Did I misplace some mail?To recall:Date: Sat, 12 Mar 88 20:02 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-FUNCTION-VS-MACRO (version 3)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880214-134110-1441@Xerox>Message-ID: <880312200240.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>[X3J13 removed.]I support many ideas of this proposal, but I have two gripes which make mehave to oppose it: * I can't deal with the idea of generalizing SYMBOL-FUNCTION. I would like   to see FDEFINITION introduced and SYMBOL-FUNCTION left alone. * I'm also a little leary about TRACE being extended this way because   (TRACE (a list)) might later want to be interpreted as options rather   than as a function spec and I'd rather not have to risk heuristic resolution.   I would rather someone right now introduce a generalized syntax for TRACE   with syntactic space for trace options, such as      (TRACE (fn . options) (fn . options) (fn . options))   and then allow the generalized (non-symbol) fn to only occur within that   syntax so that no ambiguity results.*start*00357 00024 US Date: 20 Sep 88 00:38 PDTFrom: masinter.paSubject: Re: Issue: SETF-FUNCTION-VS-MACRO (version 3)In-reply-to: masinter.pa's message of 20 Sep 88 00:13 PDTTo: masinter.pacc: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, CL-Cleanup@SAIL.STANFORD.EDU"meeting's minutes", not "minutes meetings". I guess I should go home....*start*12602 00024 USfDate:  7 Oct 88 21:26 PDTFrom: masinter.paSubject: Issue: SETF-FUNCTION-VS-MACRO (version 3)To: X3J13@Sail.stanford.educc: Masinterline-fold: NOreply-to: CL-CLEANUP@Sail.Stanford.EDUThis issue was distributed at the November 1987 meeting.It was tabled to allow for discussion of function specs.The only mail comments, which have not been incorporated,have been:Instead of generalizing SYMBOL-FUNCTION, add FDEFINITION and leaveSYMBOL-FUNCTION alone.Do not modify TRACE and UNTRACE. Leave them implementation-dependent.Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon                   (based on discussion among the CLOS working group)               Version 2, 26-Oct-87 Masinter, minor mods               Version 3, 4-Nov-87 Moon, small clarifications at KMP's urgingPROBLEM DESCRIPTION:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSis much simpler in the relevant areas.PROPOSAL (SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The form (setf (-name- ...) ...), when -name- is defined as a function(rather than a macro) and no setf macro has been defined for -name-,expands into a call to a setf function.  The name of this setf functionis a list (setf -name-), where -name- is a symbol.  The body of thisfunction is surrounded by an implicit block named -name-.The functions, macros, special forms, and declarations defined in CLtLand listed in the References section above need to be enhanced to acceptsuch lists in addition to symbols as function names, so that setffunctions can be defined and manipulated.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)          ;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.What CLtL says about (documentation foo 'setf) will not change.Specifically, the setf documentation type applies just to defsetf (anddefine-setf-method, that's an omission in CLtL).  The documentation fora setf function, as for any function, is retrieved by(documentation '(setf foo) 'function).Examples:;If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when rules 1-3 do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))        (temp-vars (do ((a (cdr form) (cdr a))                        (v nil (cons (gensym) v)))                       ((null a) v))))    (values temp-vars (cdr form) (list new-value)            `(funcall #'(setf ,(car form))                      ,new-value ,@temp-vars)            `(,(car form) ,@temp-vars))))RATIONALE:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.  In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a similar feature,in that they allow setting functions named (SETF reader).  We don'tknow of any implementation that has precisely the proposed feature.ADOPTION COST:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.COST OF NON-ADOPTION:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.BENEFITS:Allow CLOS to be defined without out-of-hand complexity. Improve usability of SETF.CONVERSION COST:None, this is an upward-compatible change.As with any language extension, some program-understanding programs mayneed to be enhanced.  A particular issue here is programs that assumethat all function names are symbols.  They may use GET to accessproperties of a function name or use EQ or EQL (perhaps via MEMBER orASSOC) to compare function names for equality.  Such programs will needimprovement before they can understand programs that use the newfeature, but otherwise they will still work.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.DISCUSSION:Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.There was some concern about introducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.However, the CLOS unsuccessfully tried a number of alternatives.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  This proposal is not incompatible with other extensions to functionspecifications present in some implementations. The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.  d)  Introduce a new name for SYMBOL-FUNCTION, since it accepts    non-symbols now. e)  Should one allow these extended function names in the car-position    of an expression to be evaluated? The extra complexity didn't seem    justified, instead, an explicit FUNCALL is required.        TITAN 
          TITAN 
         
TIMESROMAN 
          w                                                       
                                  3      #       
                                                                   
       W                                       ~      / !z*start*01555 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:12:04 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  18:05:33 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476117; Thu 13-Oct-88 19:16:08 EDTDate: Thu, 13 Oct 88 19:15 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-FUNCTION-VS-MACRO (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013191556.9.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting:Cleanup meeting: KMP: Moon thinks it's important to get this vote on in some form soon,      even if it takes an ammendment to leave out SYMBOL-FUNCTION and TRACE.X3J13 meeting: Sandra brought an ammendment slide...   Remove SYMBOL-FUNCTION, TRACE and UNTRACE from the list of affected   functions.   Add a new function:   FDEFINITION <spec>					[Function]   The current global function definition named by <spec> is returned.   It is an error if the <spec> has no function definition.   <spec> must be either a symbol or a list of the form (SETF <symbol>).   FDEFINITION may be used with SETF to alter the global function   definition. JonL, Gregor: De-couple the issue from the issue of essential      	       functionality from that of function specs. The discussion ended due to lack of time.*start*01784 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 08 NOV 88 22:00:54 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02174g; Tue, 8 Nov 88 22:00:03 PSTReceived: by bhopal id AA03393g; Tue, 8 Nov 88 21:58:42 PSTDate: Tue, 8 Nov 88 21:58:42 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811090558.AA03393@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.eduSubject: Issue deadlinesI need more time to work on the several remaining issues that I'm acentral party to.  Could you possibly extend the deadline for one moreweek?  In particular, I have three nascent new version of issues that need airing:  SETF-FUNCTION-VS-MACRO  -- As per discussion at the Fairfax meeting --                             Gregor and I have a good plan; it's just a                              matter of writing it out and proofreading it;  DECLARATION-SCOPE       -- Again, I have it "scoped out", with partial                             discussion appearing recently, but need an                             hour or so to write out the simpler version;  HASH-TABLE-STABILITY    -- The issue that I explicitly asked for "more                              time" on at Fairfax; clarify what "Hash on                             EQ" implies.The problem, as usual, is that one's companies product deadlines don't just disappear when we go into high-speed "Cleanup" mode, and there is only so much time per week I can spend on reading x3 mail etc. [plusanother bout with the "flu".]I expect to be able to have fairly good versions of two of the threeissues above by this weekend, and the third one finished by the middleof next week.  Can this time frame be accommodated?-- JonL --*start*19628 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 NOV 88 13:03:46 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 16 Nov 88  12:59:51 PSTReceived: from bhopal by heavens-gate.lucid.com id AA00299g; Tue, 15 Nov 88 14:58:15 PSTReceived: by bhopal id AA01215g; Tue, 15 Nov 88 14:56:59 PSTDate: Tue, 15 Nov 88 14:56:59 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811152256.AA01215@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue: SETF-PLACES (version 1)The following is the emmendation of SETF-FUNCTION-VS-MACRO that wasdiscussed at the Fairfax meeting; it incorporates the suggestions  made there by Gregor, Bob Kerns, and myself.  Eric Benson and PatrickDussud here at Lucid have also reviewed it. I've started it out under a different issue name, since it is sucha drastic change; but I wouldn't object at all if someone wants itto be just another version of SETF-FUNCTION-VS-MACRO.-- JonL --!Issue: SETF-PLACESReferences: SETF rules for what a place-specifier can be; CLtL pp.94-7            X3J13 88-002R:                Accessing Slots, Ch. 1 p.11               DEFGENERIC  Ch. 2 pp.26-9               DEFMETHOD  Ch. 2 pp.39-41               (SETF DOCUMENTATION)  Ch. 2 pp.43-5               ENSURE-GENERIC-FUNCTION  Ch. 2 pp.46-7               GENERIC-FLET  Ch. 2 p.52               GENERIC-LABELS  Ch. 2 p.55-6               WITH-ADDED-METHODS Ch. 2 pp.90-1Related issues: SETF-FUNCTION-VS-MACROCategory:  ADDITIONEdit history:  Version 1, 11-Nov-88, by JonLProblem description:Common Lisp explicitly refrains from giving names to accessor updatefunctions.  The intent is that the macro SETF should shield the userfrom ever having to know such names; the correlation between an accessorname and its corresponding updator name, or updating code sequence, isto be established by DEFSETF and DEFINE-SETF-METHOD.  Update functionnames like SET and RPLACA are retained primarily for backwardscompatibility.  See CLtL p.93-4.However, this is extremely inconvenient for CLOS programing.  The rub is that the functionality of an updator function must be specifiable "in pieces", by incremental uses of DEFMETHOD distributed throughout perhaps dozens of files.  A single definition using either DEFSETF orDEFINE-SETF-METHOD is not an acceptable constraint for this style.A named, generic function is the CLOS interface for doing distributedcode specification.Furthermore, it is not at all clear where a DEFSETF call for a genericfunction should go.  Should it be before the first DEFMETHOD on the update function?  should it be bundled into every such DEFMETHOD?  should it be bundled into ENSURE-GENERIC-FUNCTION?  Clearly, the first two options would violate the modularity CLOS has strived so hard to achieve; and the third violates the optionality of ENSURE-GENERIC-FUNCTION.The best choice would be to elide the DEFSETF call completely.  Some way is needed to designate an update function, without necessarily doing a DEFSETF or DEFINE-SETF-METHOD first.Additionally the simpler form of DEFSETF, which could be used foralmost all generic needs (e.g., slot updating), requires the new-value argument to be the last argument to the update function.But in order to be able to discriminate upon the class of thenew-value argument, it cannot be described simply as "last" --it must come before any &optional and &key arguments.  Thus thereis need for some other avenue whereby the new-value argument wouldcome, say, first in the argument list of the update function.Finally, the CLOS specification X3J13 88-002R seems to implythat the CLOS exterior syntax for function specifiers must be implemented down in the innards of every conforming Lisp implementation.  There is a very large amount of resistancein the X3J13 group, at present, to any proposal which requiresany non-symbols as ordinary function names; not only do peopleobject to code like (SYMBOL-FUNCTION '(SOME LIST)), but thereis great reluctance to carry out system-wide modifications toall places that deal with function names (most of which nowpresume that "name" means SYMBOL).  Yet is the current opinionof most of the CLOS subcommittee that the exterior CLOS interfacecan be kept intact without requiring the underlying Lisp implementation to support non-symbols as function names.Proposal (SETF-PLACES:ADD-SETF-FUNCTIONS)-- Specify that certain function names are reserved to be "SETF functions",   or "updator functions", for use by SETF expansions.  The very existence    of such an updator function is implicitly similar to having done a    DEFSETF [or rather, a modified form of the simple DEFSETF, as explained    next below].  Every accessor function name is uniquely paired with such    an updator name, regardless of whether the updator name ever has a    functional definition.  However, these functions do not replace any    previously defined SETF methods, nor override the place specifications    of CLtL section 7.2; they simply provide a default expansion for SETF,    as described below.-- Specify that such a a SETF function must take one more argument than    its corresponding access function.  Let <access-fn> and <update-fn>    be such a correlated pair; then when SETF is given a "place" that is    a call on <access-fn>, it expands into a call on <update-fn> that is    given all the arguments to <access-fn> and also, as its very first    argument, the new-value (which must be  returned by <update-fn> as    its value).  For example, suppose that ASET is the updator function   name corresponding to AREF.  Then         (SETF (AREF a i1 i2 ... in) value)   could expand into        (ASET value a i1 i2 ... in)-- Extend the set of valid "place specifiers" as defined on CLtL p.94-7    by adding the following clause after all the existing ones:       For any other place specifier, the form         (SETF (<access-fn> A1 A2 ... AN) NEW-VALUE)       will expand into a call to the uniquely-named updator function       corresponding to <access-fn>, that is to the function named by       (UNDERLYING-NAME '(SETF <access-fn>)).   Note that SETF will no longer signal any "unknown place specifier"    errors during macroexpansion, because the default behavior is to   simply construct a call to the setf function [except, however, when   "access-fn" isn't legal as the name of a function; for example,   (setf ((spaz) i1 i2) value) is still syntaticly illegal].  But if   at run time, the "setf function" still hasn't been defined as a   function [such as by DEFUN, DEFMETHOD, setf of SYMBOL-FUNCTION etc.],   then a run-time "undefined function" error may occur.   Note also that not every SETF method for an accessor function can be   defined using an updator function.  For example, LDB cannot be handled   this way, even if its corresponding update name is a defined function;   LDB must be handled by DEFINE-SETF-METHOD, and as such the prior rules   of CLtL p.94-7 would apply.-- Be reminded that the rules for interpreting SETF place specifiers   are actually embodied in the functions GET-SETF-METHOD and   GET-SETF-METHOD-MULTIPLE-VALUE, rather than in the SETF macro   itself.  Thus these two functions must be altered to reflect the new    "place specifier" called for just above.  Since the rules on p.94-7    of CLtL are to be applied in order, then SETF functions will only be    used when no SETF "method" has been defined for the name, such as by    calling DEFINE-SETF-METHOD or DEFSETF; also, a macro definition for    the access name will block the use of the SETF function, since the    macro call must be expanded first.  Remember also that such a updator    name may have a lexically local definition, as well as (or in addition   to) a global one.-- Add a new function, UNDERLYING-NAME of one argument; and also add an   inverse for this function, UNDERLYING-NAME-TO-SPEC of one argument.   UNDERLYING-NAME is defined as:      (i) on any list like (SETF <name>), it returns a unique,           implementation-dependent name suitable for actual use as           a function name in that implementaion.     (ii) on symbols, it is the identity function; and    (iii) on any other data, it is undefined; however, other lists          like (<spec-kind> ...) should be reserved for extensions          which the x3J13 committee may be considering.   UNDERLYING-NAME-TO-SPEC is defined as:      (i) on any argument which specifically is the output of part (i)          above [i.e., an "underlying" name], it returns (SETF <name>);          thus the argument is the unique name which is EQUAL to          (UNDERLYING-NAME '(SETF <name>)).     (ii) on any symbol or list not covered by part (i) just above, it           returns it's argument.    (iii) on any other data, it is undefined; however, other lists          like (<spec-kind> ...) should be reserved for extensions          which the x3J13 committee may be considering.   The reason EQUAL is the determiner of "uniqueness" above is that it   is EQ for symbols; and for implementations which have "function specs"   it permits non-EQ copies of (SETF <name>) to be used interchangably.   The result of UNDERLYING-NAME should be constant across "incarnations"   of the same release of an implementation, and should be of a data type   that can be printed out and read back in reliably.      Thus in one implementation, which uses only symbols to name functions,   it might be that:      (UNDERLYING-NAME '(SETF FOO)) ==> SETF:4.USER.FOO      (UNDERLYING-NAME-TO-SPEC 'SETF:4.USER.FOO) ==> (SETF FOO)   whereas in another implementation, which has LispMachine style   "function specs", it would be that:      (UNDERLYING-NAME '(SETF FOO)) ==> (SETF FOO)      (UNDERLYING-NAME-TO-SPEC '(SETF FOO)) ==> (SETF FOO)-- Alter all the above-referenced documentation in the CLOS specification   so as not to imply that lists are suitable as function names.  In   particular,     (a) phrases like "... if <function-specifier> names a function" should         be changed to a phrase like "... if <function-specifier> refers to        a defined function", or possibly even something like        "... if (UNDERLYING-NAME <function-specifier>) names a function"    (b) phrases like "(FBOUNDP <function-specifier>)" should be changed        into "(FBOUNDP (UNDERLYING-NAME <function-specifier>))"; or        else other terminology should express the intent of what is to        be said.  For example, instead of saying: "When (FBOUNDP <f-s>)         is  true ..." one could just as well say  "When <f-s> refers to         a defined function ..."  The choice of which of these two formats         to use is an editorial one.    (c) phrases like "(SYMBOL-FUNCTION function-specifier)" should be changed        into "(SYMBOL-FUNCTION (UNDERLYING-NAME <function-specifier>))";        or else other terminology should express the intent of what is to        be said.  For example, one might say "... the function referred         to by <f-s>".  The choice of which of these two formats to use is        an editorial one.Since the concept of a standard expansion for DEFMETHOD has beenaccepted, then it is clear that a form like     (DEFMETHOD (SETF FOO) ...)will expand exactly the same as    (DEFMETHOD #.(UNDERLYING-NAME '(SETF FOO)) ...)The underlying call to ADD-METHOD will see the real function name usedfor the updator function.  The user-level interface of CLOS can stillpresent the list format as acceptable; it is only the implementation ofDEFMETHOD, DEFGENERIC, that will have to worry about converting to a"real" name.One expected use of UNDERLYING-NAME-TO-SPEC is in Lisp-level debuggers,which could try to print out something more user-comprehensible thanthe very internal names that an implementation might use in place offunction specs.Examples:;;; If CLtL did not already prescribe a SETF expansion for SUBSEQ calls,;;;  it could be defined like this:  (setf (symbol-function (underlying-name '(setf subseq)))	#'(lambda (new-value sequence start &optional end)	    (unless end (setq end (length sequence)))	    (setq end (min end (+ start (length new-value))))	    (do ((i start (1+ i))		 (j 0 (1+ j)))		((= i end) new-value)	      (setf (elt sequence i) (elt new-value i)))))or, for implementations that have "function specs", this could be writen:  (defun (setf subseq) (new-value sequence start &optional end)    . . .);;; Here's an example using a local function.  First, define ;;;  MIDDLE-REF to be an accessor function as follows.  [Assume ;;;  also that MIDDLE-REF's home package is BAR.]    (defun middle-ref (vec i)       (check-type i fixnum)      (aref vec (ceiling i 2)));;; Now let SETF:3.BAR.MIDDLE-REF be the (implementation-dependent) ;;;  updator function name corresponding to MIDDLE-REF; a normal ;;;  definition of an update function for MIDDLE-REF could be:    (defun setf:3.bar.middle-ref (new-element vec i)       (check-type i fixnum)      (setf (aref vec (ceiling i 2)) new-element));;; But the SETF below will call FILL, because of the local definition ;;;  of SETF:3.BAR.MIDDLE-REF;  and nowhere have we have made any;;;   explicit call to DEFSETF or DEFINE-SETF-METHOD for MIDDLE-REF.    (flet ((setf:3.bar.middle-ref (new-element vec i)              ;;"wide-body" version of set-middle-ref             (declare (ignore i))             (fill vec new-element :end (ceiling i 2))))      (setf (middle-ref "abc" 1) #\z));;; The following function could be called by GET-SETF-METHOD, to ;;;  implement SETF functions, when none of the other rules of CLtL;;;  p.94-7 apply.  (defun get-setf-method-for-setf-functions (form)    (let* ((new-value (gensym))	   (temp-vars (do ((a (cdr form) (cdr a))			   (v nil (cons (gensym) v)))			  ((null a) v)))	  ((access-fn (car form)))	  ((update-fn (underlying-name `(SETF ,access-fn)))))      (values temp-vars 	      (cdr form) 	      (list new-value)	      `(,update-fn  ,new-value  ,@temp-vars)	      `(,access-fn ,@temp-vars))));;; For those implementations using "function specs", the form:;;;   `(,update-fn  ,new-value  ,@temp-vars);;;  would probably have to  be replaced by:;;;   `(FUNCALL #',update-fn  ,new-value  ,@temp-vars)Rationale:The paragraphs of the "Problem description:", except for the first,describe four major problems with the status quo -- three concerningthe unsuitability of current SETF methods for supporting the CLOSgeneric style, and one for an unintended presumption that everyimplementation of CL will have "function specs".  This proposalcorrects these problems, without adding any significant new ones.Current practice:Some implementations have "function specs", so that forms like (SETF FOO) are permitted to name functions;  but none have extended the setf place specifiers as proposed herein.Cost to Implementors:Basically, none.  Implementations which already have Lisp Machine style "function specs" can just define UNDERLYING-NAME andUNDERLYING-NAME-TO-SPEC as the identity function.  For those withoutsuch capabilities, there is a portable implementation listed in the discussion section.Extending GET-SETF-METHOD etc. to handle SETF functions should be avery modest task at most.Cost to Users:This is basically an upward-compatible addition, so there should beno cost to users [at least not for correct programs -- incorrectSETF expansions will no longer be signalled at macroexpand time,but may simply result in a runtime error for undefined function.]Cost of non-adoption:Non-adoption of this proposal would be a significant setback for the Common Lisp Object System.  There seems to be no agreeable alternativefor implementing generic setf methods.Performance impact:N.A.Benefits:See "Cost of non-adoption".Esthetics:This proposal increases the size of the definition of SETF; butit greatly simplifies the "default" case, namely just definingan updator function to correspond to an accessor.Discussion:The following code can be used by an implementation which doesn'thave "function specs" to implement the new functions:  ;;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: SYSTEM; Base: 10 -*-  ;;;  ;;; Author: JonL White, 15-Nov-88  ;;;  (in-package "SYSTEM")			;or, your development package  (eval-when (eval compile load)  ;;; The SETF package should be reserved for this purpose  ;;;  (or (find-package "SETF")       (make-package "SETF" :use nil))  (defparameter *setf-package* (find-package "SETF"))  (unless (and (null (package-use-list *setf-package*))	       (null (package-used-by-list *setf-package*)))    (error "SETF package has connections?"))  ;;; "Internal Markers", to be used for uninterned symbols.  ;;;  (export (intern "SETF-SPEC" *setf-package*) *setf-package*)  (export (intern "SETF-NAME" *setf-package*) *setf-package*)  )  (eval-when (eval compile)  (defmacro setf-spec-p (x)    (let ((spec (gensym)))      `(LET ((,spec ,x))	 (AND (CONSP ,spec) 	      (EQ (CAR ,spec) 'SETF)	      (CONSP (CDR ,spec))	      (NULL (CDDR ,spec))	      (SYMBOLP (SECOND ,spec))))))  )  (defun UNDERLYING-NAME (spec)    (cond       ((symbolp spec)        spec)      ((setf-spec-p spec)       (let* ((accessor (second spec))	      (accessor-name (symbol-name accessor))	      (home-package (symbol-package accessor)))	 (if home-package	     (let* ((package-name (package-name home-package))		    ;; 'spec-name' is a form like "~D.~A.~A", but FORMAT has a		    ;; problem with global print parameters like *print-radix*		    (spec-name (concatenate 'string				 (write-to-string (length package-name)				   :radix nil :base 10 :length nil :level nil)				 "."				 package-name				 "."				 accessor-name))		    (updator (or (find-symbol spec-name *setf-package*)				 (let ((sym (intern spec-name *setf-package*)))				   (export sym *setf-package*)				   sym))))	       ;; A possible optimization, which trades off space for time, is	       ;;  as follows; see definition of UNDERLYING-NAME-TO-SPEC below	       ;;(setf (get updator 'setf:setf-spec) (copy-list spec))	       updator)	     (or (get accessor 'setf:setf-name)		 (let* ((uname (concatenate 'string "SET-" accessor-name))			(updator (make-symbol uname)))		   (setf (get accessor 'setf:setf-name) updator)		   (setf (get updator 'setf:setf-spec) (copy-list spec))		   updator)))))	  (t 	   (error "~S is an invalid arg for ~S" spec 'UNDERLYING-NAME))))  (defun UNDERLYING-NAME-TO-SPEC (x)    (cond      ((not (symbolp x))       (if (setf-spec-p x)	   x	   (error "~S is an invalid arg for ~S" 		  x 'UNDERLYING-NAME-TO-SPEC)))      ((get x 'setf:setf-spec))      (t        (let ((home-package (symbol-package x)))	  (if (not (eq home-package *setf-package*))	      x	      (let ((name (symbol-name x))		    accessor package-name)		;; Unpack the name, which is a form like "~D.~A.~A"		(multiple-value-bind (nchars starti)				(parse-integer name :radix 10 :junk-allowed t)		  (incf starti)		  (setq package-name (subseq name starti (incf starti nchars)))		  (incf starti)		  (setq accessor (find-symbol (subseq name starti) 					      (find-package package-name)))		  (unless accessor		    (error "~S failed to parse in ~S" 			   x 'UNDERLYING-NAME-TO-SPEC))		  `(SETF ,accessor))))))))*start*02249 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 16:50:30 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Nov 88  16:49:28 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496949; Tue 22-Nov-88 19:49:27 ESTDate: Tue, 22 Nov 88 19:49 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-PLACES (version 1)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <8811152256.AA01215@bhopal>Message-ID: <19881123004923.5.MOON@EUPHRATES.SCRC.Symbolics.COM>I am not happy with this proposal, because I think it is excessivelycomplicated.  I still prefer the SETF-FUNCTION-VS-MACRO proposal.However, I would rather accept this kludge than not have CLOS at all, soif X3J13 is adamantly against SETF-FUNCTION-VS-MACRO I will accept thisproposal.  I would prefer to see X3J13 allowed to vote on both proposalsas alternatives, since it's possible that when they see this one theywould prefer the one they rejected before.Note: I am not complaining about the writeup of the proposal, whichis quite clear, but about the substance of the proposal.  I believethe distinction between "specs" and "underlying names" is confusingand unnecessary.  Evidently that is a minority position.A few additional comments on the details of the proposal.  All ofthese are easily corrected:I believe that DEFUN should have syntax compatible with DEFGENERIC andDEFMETHOD, for aesthetic reasons, and therefore the proposal shouldspecify that DEFUN will call UNDERLYING-NAME, just as DEFMETHOD does.Once this is done, the first example can be simplified.Similarly, LABELS and FLET should accept "specs", since GENERIC-LABELSand GENERIC-FLET do.  This would eliminate the non-portability ofthe FLET of setf:3.bar.middle-ref example.The get-setf-method-for-setf-functions example has parenthesis errors.I did not check whether this proposal preserves the carefully worked outrules about local functions and local macros from the earlier proposal.I'll assume that it does.*start*03138 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 16:53:05 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 22 Nov 88  16:51:04 PSTReceived: by ti.com id AA27756; Tue, 22 Nov 88 18:50:32 CSTReceived: from Kelvin by tilde id AA24761; Tue, 22 Nov 88 18:37:41 CSTMessage-Id: <2805237539-1438981@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 22 Nov 88 18:38:59 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Jon L White <jonl@lucid.com>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: SETF-PLACES (version 1)In-Reply-To: Msg of Tue, 15 Nov 88 14:56:59 PST from Jon L White <jonl@lucid.com>>     (b) phrases like "(FBOUNDP <function-specifier>)" should be changed>         into "(FBOUNDP (UNDERLYING-NAME <function-specifier>))"; or>         else other terminology should express the intent of what is to>         be said.  For example, instead of saying: "When (FBOUNDP <f-s>) >         is  true ..." one could just as well say  "When <f-s> refers to >         a defined function ..."  The choice of which of these two formats >         to use is an editorial one.>     (c) phrases like "(SYMBOL-FUNCTION function-specifier)" should be changed>         into "(SYMBOL-FUNCTION (UNDERLYING-NAME <function-specifier>))";>         or else other terminology should express the intent of what is to>         be said.  For example, one might say "... the function referred >         to by <f-s>".  The choice of which of these two formats to use is>         an editorial one.There is a non-editorial issue here:  are FBOUNDP and SYMBOL-FUNCTIONrequired to accept anything returned by UNDERLYING-NAME, or are theyonly meaningful for symbols?  On Lisp Machines these are primitives foraccessing symbol definition cells while other functions, FDEFINEDP andFDEFINITION, accept any function spec.> Since the concept of a standard expansion for DEFMETHOD has been> accepted, then it is clear that a form like >     (DEFMETHOD (SETF FOO) ...)> will expand exactly the same as>     (DEFMETHOD #.(UNDERLYING-NAME '(SETF FOO)) ...)> The underlying call to ADD-METHOD will see the real function name used> for the updator function.  The user-level interface of CLOS can still> present the list format as acceptable; it is only the implementation of> DEFMETHOD, DEFGENERIC, that will have to worry about converting to a> "real" name.For consistency, shouldn't this be accepted by all function-definingmacros and special forms?  Besides DEFMETHOD and DEFGENERIC, there areDEFUN, FLET, LABELS, GENERIC-FLET, GENERIC-LABELS, WITH-ADDED-METHODS,and DEFCLASS.  I also can't find any mention of the special formFUNCTION in the proposal; shouldn't it also accept function specifiers?> Cost to Implementors:> > Basically, none.  Implementations which already have Lisp Machine > style "function specs" can just define UNDERLYING-NAME and> UNDERLYING-NAME-TO-SPEC as the identity function. If we don't have to also extend the meaning of FBOUNDP andSYMBOL-FUNCTION.*start*01069 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 18:17:09 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 22 Nov 88  18:16:16 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 22 Nov 88 21:14:06 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: SETF-PLACES (version 1) In-reply-to: Your message of Tue, 22 Nov 88 19:49:00 -0500.             <19881123004923.5.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Tue, 22 Nov 88 21:13:26 ESTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUI'm inclined to agree with Moon on this.  However, I wasn't around when theSETF-FUNCTION-VS-MACRO issue was voted on, so I don't know what argumentswere raised against it.  The current proposal looks like a recipe fordisaster, since this name/spec distinction is going to confuse people andraise lots of questions about which can be used where.-- Scott*start*01071 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 17:47:52 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Nov 88  17:00:28 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496964; Tue 22-Nov-88 20:00:25 ESTDate: Tue, 22 Nov 88 20:00 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: SETF-PLACES (version 1)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <2805237539-1438981@Kelvin>Message-ID: <19881123010011.7.MOON@EUPHRATES.SCRC.Symbolics.COM>I think Gray's points are well-taken and I agree with them (passinglightly over the typo of DEFCLASS in a list of function-defining forms).I think they amplify my contention that this proposal is too complicated,because by introducing a distinction between "names" and "specs" wehave to clarify which functions work with which.*start*01984 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 NOV 88 09:51:21 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Nov 88  09:30:40 PSTReceived: from rainbow-warrior ([192.9.200.16]) by heavens-gate.lucid.com id AA00455g; Mon, 28 Nov 88 09:28:28 PSTReceived: by rainbow-warrior id AA10535g; Mon, 28 Nov 88 09:29:57 PSTDate: Mon, 28 Nov 88 09:29:57 PSTFrom: Patrick Dussud <dussud@lucid.com>Message-Id: <8811281729.AA10535@rainbow-warrior>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 22 Nov 88 19:49 EST <19881123004923.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: SETF-PLACES (version 1)   Date: Tue, 22 Nov 88 19:49 EST   From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>   I am not happy with this proposal, because I think it is excessively   complicated.  I still prefer the SETF-FUNCTION-VS-MACRO proposal.   However, I would rather accept this kludge than not have CLOS at all, so   if X3J13 is adamantly against SETF-FUNCTION-VS-MACRO I will accept this   proposal.I have the same feelings about it. Having my name associated with it does notmean that I like it, only that I helped debug it, and that I am not ready toremove SETF specs from CLOS.  I would prefer to see X3J13 allowed to vote on both proposals   as alternatives, since it's possible that when they see this one they   would prefer the one they rejected before.I think we should do that.   Note: I am not complaining about the writeup of the proposal, which   is quite clear, but about the substance of the proposal.  I believe   the distinction between "specs" and "underlying names" is confusing   and unnecessary.  Evidently that is a minority position.Given the amount of feedback, it is too early to tell if it is a minorityposition. Patrick.*start*26826 00024 US Date: 27 Nov 88 15:00 PSTFrom: masinter.paSubject: Issue: SETF-FUNCTION-VS-MACRO (version 5)To: CL-CLEANUP@Sail.Stanford.EDUline-fold: NOcc: masinterThis is an attempt to merge version 3 (from David Moon) and Version 4 (from JonL White, distributed as SETF-PLACES version 1), into a single Issue with two Proposals.Doing so has not been easy. I must admit that, having gotten a first draft, I'm eager to mail this out for comments even without having proofread it myself carefully. I'lldo so this week, but if you have some objection to the overall merger, please speak up.Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)             X3J13 88-002R:               Accessing Slots, Ch. 1 p.11               DEFGENERIC  Ch. 2 pp.26-9               DEFMETHOD  Ch. 2 pp.39-41               (SETF DOCUMENTATION)  Ch. 2 pp.43-5               ENSURE-GENERIC-FUNCTION  Ch. 2 pp.46-7               GENERIC-FLET  Ch. 2 p.52               GENERIC-LABELS  Ch. 2 p.55-6               WITH-ADDED-METHODS Ch. 2 pp.90-1Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon                   (based on discussion among the CLOS working group)               Version 2, 26-Oct-87 Masinter, minor mods               Version 3, 4-Nov-87 Moon, small clarifications at KMP's urging               Version 4, 15-Nov-88 JonL, complete rewrite               Version 5, 26-Nov-88 Masinter, merge Versions 3 & 4.PROBLEM DESCRIPTION:The SETF mechanism in Common Lisp was designed to allow for a uniform way of refering to the "update" function of an accessor withouthaving to have separate names for the updator.  The SETF macro shields the userfrom ever having to know such names; the correlation between an accessorname and its corresponding updator name, or updating code sequence, wasestablished by DEFSETF and DEFINE-SETF-METHOD. Update function nameslike SET and RPLACA were retained primarily for backward compatibility.However, in CLOS programming, generic updator functions mustbe specified in pieces, by incremental uses of DEFMETHOD. For this,and a variety of other reasons, the CLOS specification 88-002R (accepted by X3J13) assumed that lists of the form (SETF <name>) wereacceptable to a wide variety of functions and macros as a way tospecify the "name" of the SETF function. The problem is that thispart of CLOS must be resolved with the rest of Common Lisp.This issue has two proposals, NAMED-BY-LIST and COMPUTE-UNDERLYING-NAME.The proposals differ only in how setf functions are named; the common partis given first.PROPOSAL (SETF-FUNCTION-VS-MACRO:COMMON-PART):Add the concept of a "SETF function". Right now, Common Lisp has twoways to define the behavior of SETF of a form, DEFINE-SETF-METHOD andDEFSETF. Terminology:- a "setf macro" is something that produces code (or other  specifications, as in define-setf-method) which, when evaluated,  will perform the effect of an invocation of setf.- a "setf function" is something that is called to perform  directly the effect of an invocation of setf.Extend the set of valid "place specifiers" as defined on CLtL p 94-97by adding a clause after the existing ones, to the effect that:"For any other place specifier, the form  (SETF (-name- a1 a2 ... an) new-value),   will expand into a call to -name-'s corresponding setf-function,  such expansion to be of the form:(<setf-function-for--name-> y a1 a2 ... an), except that  the left-to-right evalution order of a1 a2 ... an y is preserved."A setf function receives the new value to be stored as its firstargument. The setf function for -name- should have one more requiredparameter than -name-, the first required parameter is the new valueto be stored, and the remaining paramters should be the same as -name-'sparameters. A setf function should return its first argument, sinceSETF is defined to return the new value. Note that SETF will no longer signal any "unknown place specifier" errors during macroexpansion, because the default behavior is tosimply construct a call to the setf function [except, however, when"access-fn" isn't legal as the name of a function; for example,(SETF ((SPAZ) I1 I2) VALUE) is still syntaticly illegal].  But ifat run time, the "setf function" still hasn't been defined as afunction [such as by DEFUN, DEFMETHOD, setf of SYMBOL-FUNCTION etc.],then a run-time "undefined function" error may occur.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.What CLtL says about (documentation foo 'setf) will not change.Specifically, the setf documentation type applies just to defsetf (anddefine-setf-method, that's an omission in CLtL).  The documentation fora setf function can be retrieved by (documentation '(setf foo) 'function).The two proposals differ in the manner in which the "name" ofa setf function is determined.The proposal COMPUTE-UNDERLYING-NAME allows these to beimplementation-dependent, and adds two functions,UNDERLYING-NAME and UNDERLYING-NAME-TO-SPEC, for convertingfrom specifications of the form (SETF -name-) to the realname and back.The proposal NAMED-BY-LIST specifies that the name ofthe setf function for -name-  *is* the list (SETF -name-),and extends those places in Common Lisp that deal withfunction names to require them to accept such lists. PROPOSAL (SETF-FUNCTION-VS-MACRO:COMPUTE-UNDERLYING-NAME):The name of the setf function for -name- is implementationdependent; in some implementations, it could be a list (aswith the NAMED-BY-LIST proposal below), but in other implementations, it could be a symbol.- Add a new function, UNDERLYING-NAME of one argument:      (i) on any list like (SETF <name>), it returns a unique,           implementation-dependent name suitable for actual use as           a function name in that implementaion.     (ii) on symbols, it is the identity function; and    (iii) on any other data, it is undefined; however, other lists          like (<spec-kind> ...) should be reserved for extensions          which the x3J13 committee may be considering.- Add a new function, UNDERLYING-NAME-TO-SPEC of one argument:      (i) on any argument which results from UNDERLYING-NAME applied         to a list (SETF <name>), UNDERLYING-NAME-TO-SPEC returns         an EQUAL list.     (ii) on any symbol or list not covered by part (i),         UNDERLYING-NAME-TO-SPEC returns it's argument.    (iii) on any other data, it is undefined.The result of UNDERLYING-NAME should be constant across "incarnations"of the same release of an implementation, and should be of a data typethat can be printed out and read back in reliably.   Thus in one implementation, which uses only symbols to name functions,it might be that:      (UNDERLYING-NAME '(SETF FOO)) ==> SETF:4.USER.FOO      (UNDERLYING-NAME-TO-SPEC 'SETF:4.USER.FOO) ==> (SETF FOO)whereas in another implementation, which has LispMachine style"function specs", it would be that:      (UNDERLYING-NAME '(SETF FOO)) ==> (SETF FOO)      (UNDERLYING-NAME-TO-SPEC '(SETF FOO)) ==> (SETF FOO)-- Modify the wording in the standard which describes parts imported  from the CLOS specification so as not to imply that lists are  suitable as function names.  In particular,     (a) phrases like "... if <function-specifier> names a function" should         be changed to a phrase like "... if <function-specifier> refers to        a defined function", or possibly even something like        "... if (UNDERLYING-NAME <function-specifier>) names a function"    (b) phrases like "(FBOUNDP <function-specifier>)" should be changed        into "(FBOUNDP (UNDERLYING-NAME <function-specifier>))"; or        else other terminology should express the intent of what is to        be said.  For example, instead of saying: "When (FBOUNDP <f-s>)         is  true ..." one could just as well say  "When <f-s> refers to         a defined function ..."  The choice of which of these two formats         to use is an editorial one.    (c) phrases like "(SYMBOL-FUNCTION function-specifier)" should be changed        into "(SYMBOL-FUNCTION (UNDERLYING-NAME <function-specifier>))";        or else other terminology should express the intent of what is to        be said.  For example, one might say "... the function referred         to by <f-s>".  The choice of which of these two formats to use is        an editorial one.Note that forms like    (DEFMETHOD (SETF FOO) ...)will expand similarly to     (DEFMETHOD #.(UNDERLYING-NAME '(SETF FOO)) ...)except that the implicit block name surrounding the body of the methodwill be FOO and not (UNDERLYING-NAME '(SETF FOO)).The underlying call to ADD-METHOD will see the real function name usedfor the updator function.  The user-level interface of CLOS can stillpresent the list format as acceptable; it is only the implementation ofDEFMETHOD, DEFGENERIC, that will have to worry about converting to a"real" name.In an implementation note, point out that UNDERLYING-NAME-TO-SPECcould be used by debuggers to print out something more user-comprehensiblethan the internal names that an implementation might use.PROPOSAL (SETF-FUNCTION-VS-MACRO:NAMED-BY-LIST): The "name" of the setf function for -name- is a list (SETF -name-),where -name- is a symbol. The body of thisfunction is surrounded by an implicit block named -name-.Modify the following functions, macros, special forms, and declarations:COMPILE function, DEFUN macro, DISASSEMBLE function, DOCUMENTATION function,FBOUNDP function, FLET special form, FMAKUNBOUND function, FTYPE declaration,FUNCTION special form, FUNCTION declaration, INLINE declaration,NOTINLINE declaration, LABELS special formto accept such lists in addition to symbols as function names, so thatsetf functions can be defined and manipulated.Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)          ;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.What CLtL says about (documentation foo 'setf) will not change.Specifically, the setf documentation type applies just to defsetf (anddefine-setf-method, that's an omission in CLtL).  The documentation fora setf function, as for any function, is retrieved by(documentation '(setf foo) 'function).Examples:;;If SETF of SUBSEQ were not already built into Common Lisp,;it could be defined, under NAMED-BY-LIST, as:(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));; while with COMPUTE-UNDERLYING-NAME, as:  (setf (symbol-function (underlying-name '(setf subseq)))	#'(lambda (new-value sequence start &optional end)	    (unless end (setq end (length sequence)))	    (setq end (min end (+ start (length new-value))))	    (do ((i start (1+ i))		 (j 0 (1+ j)))		((= i end) new-value)	      (setf (elt sequence i) (elt new-value i)))));;Another example, showing a locally defined setf function.;; with NAMED-BY-LIST:(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));; with COMPUTE-UNDERLYING-NAME:; First, define MIDDLE-REF to be an accessor function as follows:    (defun middle-ref (vec i)       (check-type i fixnum)      (aref vec (ceiling i 2)));; then, even given:    (defun #.(underlying-name '(setf middle-ref)) (new-element vec i)       (check-type i fixnum)      (setf (aref vec (ceiling i 2)) new-element))    (flet ((#.(underlying-name '(setf middle-ref)) (new-element vec i)              ;;"wide-body" version of set-middle-ref             (declare (ignore i))             (fill vec new-element :end (ceiling i 2))))      (setf (middle-ref "abc" 1) #\z));;;GET-SETF-METHOD could implement setf functions by calling;;;this function when none of the other rules of CLtL p 94-7 apply:(defun get-setf-method-for-setf-function (form)  (let ((access-fn (car form))        (new-value (gensym))        (temp-vars (do ((a (cdr form) (cdr a))                        (v nil (cons (gensym) v)))                       ((null a) v))))    (values temp-vars (cdr form) (list new-value)            `(,@#+NAMED-BY-LIST			`(funcall #'(setf ,access-fn)) #+COMPUTE-UNDERLYING-NAME			`(,(underlying-name `(setf ,access-fn)))                      ,new-value ,@temp-vars)            `(,(car form) ,@temp-vars))))RATIONALE:Both proposals allow a more functional appropach to dealing withSETF, and bring the CLOS and Common Lisp parts of the standard intomore alignment. COMPUTE-UNDERLYING-FUNCTION does so by adding functionsto go between the "specification" of (SETF -name-) to the name actually used, while NAMED-BY-LIST does so by extending a numberof already existing Common Lisp functions, macro and special forms.SETF functions take the "new value" as the first argument to allowfor defining them on accessors that have &REST and &KEY arguments.By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified. In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a feature similar,but not compatible with, NAMED-BY-LIST, in that they allow setting functions named (SETF reader).  We don't know of any implementationthat has precisely the proposed feature.For example, This will be an incompatible change for Symbolics,since it already has setf functions but they do not take thesame arguments as proposed here.COST TO IMPLEMENTORS:For either proposal, the SETF macro expansion would have to beextended to generate the appropriate call on the setf function.The additional cost of proposal COMPUTE-UNDERLYING-NAME is low;implementations would need to add the two proposed functions.In addition, implementations would need to modify theirCLOS implementation to use UNDERLYING-NAME where appropriate.[A sample implementation is given at the end of the proposal.]The cost of proposal NAMED-BY-LIST is higher, since many otherfunctions, macros and special forms would have to be extended to deal with the SETF specifications. The main cost is generalizationof a few functions to accept lists beginning with SETF where theynow accept only symbols.  Implementations must add a data structureto store the function definition of a setf function, however, this canbe done with property lists or generated symbols.COST TO USERS:Both proposals are basically upward-compatible changes for currentlyportable Common Lisp programs.As with any language extension, some program-understanding programs mayneed to be enhanced.  A particular issue with NAMED-BY-LIST is programsthat assume that all function names are symbols.  They may use GET toaccess properties of a function name or use EQ or EQL (perhaps via MEMBER or ASSOC) to compare function names for equality.  Such programswill need improvement before they can understand programs that usethe new feature.Both proposals remove some macro-expansion error checking, sincedetection of incorrect SETF expansion will be postponed to run-time.This is a minor deficiency, as it puts invocation of SETF functionson the same footing as other function calls.COST OF NON-ADOPTION:Common Lisp and CLOS would be significantly inconsistent; some majorrethinking of CLOS would be required.BENEFITS:Improve usability of SETF. Avoids cost of non-adoption.With NAMED-BY-LIST, current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)could be replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)With NAMED-BY-LIST, a convenent way of lexically definingor redefining the behavior of SETF would be allowed.PERFORMANCE IMPACT:Negligible; ether proposal might make an implementation slightlylarger.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.The proposal NAMED-BY-LIST allows lists of the form (SETF -name-) to beused in many places where only symbols were allowed before. Somepeople feel this is unesthetic, because it is at odds with manycurrent descriptions of Common Lisp say that names are symbols.DISCUSSION:This issue has been in discussion in the CLOS committee and at X3J13for over a year. Versions of the proposal were distributed, discussed,and voting tabled at three successive meetings of X3J13. The proposalpreviously distributed most resembles the NAMED-BY-LIST proposl containedin this version.Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  Neither proposal attempts tochange that aspect of Common Lisp.Most of the objection to previous proposals were based onintroducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.The CLOS group unsuccessfully tried a number of alternatives thatdid not require naming the setf function at all. However,fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.Appendix: Sample implementation of COMPUTE-UNDERLYING-NAMEThe following code can be used by an implementation which doesn'thave "function specs" to implement the COMPUTE-UNDERLYING-NAME proposal:  ;;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: SYSTEM; Base: 10 -*-  ;;;  ;;; Author: JonL White, 15-Nov-88  ;;;  (in-package "SYSTEM")			;or, your development package  (eval-when (eval compile load)  ;;; The SETF package should be reserved for this purpose  ;;;  (or (find-package "SETF")       (make-package "SETF" :use nil))  (defparameter *setf-package* (find-package "SETF"))  (unless (and (null (package-use-list *setf-package*))	       (null (package-used-by-list *setf-package*)))    (error "SETF package has connections?"))  ;;; "Internal Markers", to be used for uninterned symbols.  ;;;  (export (intern "SETF-SPEC" *setf-package*) *setf-package*)  (export (intern "SETF-NAME" *setf-package*) *setf-package*)  )  (eval-when (eval compile)  (defmacro setf-spec-p (x)    (let ((spec (gensym)))      `(LET ((,spec ,x))	 (AND (CONSP ,spec) 	      (EQ (CAR ,spec) 'SETF)	      (CONSP (CDR ,spec))	      (NULL (CDDR ,spec))	      (SYMBOLP (SECOND ,spec))))))  )  (defun UNDERLYING-NAME (spec)    (cond       ((symbolp spec)        spec)      ((setf-spec-p spec)       (let* ((accessor (second spec))	      (accessor-name (symbol-name accessor))	      (home-package (symbol-package accessor)))	 (if home-package	     (let* ((package-name (package-name home-package))		    ;; 'spec-name' is a form like "~D.~A.~A", but FORMAT has a		    ;; problem with global print parameters like *print-radix*		    (spec-name (concatenate 'string				 (write-to-string (length package-name)				   :radix nil :base 10 :length nil :level nil)				 "."				 package-name				 "."				 accessor-name))		    (updator (or (find-symbol spec-name *setf-package*)				 (let ((sym (intern spec-name *setf-package*)))				   (export sym *setf-package*)				   sym))))	       ;; A possible optimization, which trades off space for time, is	       ;;  as follows; see definition of UNDERLYING-NAME-TO-SPEC below	       ;;(setf (get updator 'setf:setf-spec) (copy-list spec))	       updator)	     (or (get accessor 'setf:setf-name)		 (let* ((uname (concatenate 'string "SET-" accessor-name))			(updator (make-symbol uname)))		   (setf (get accessor 'setf:setf-name) updator)		   (setf (get updator 'setf:setf-spec) (copy-list spec))		   updator)))))	  (t 	   (error "~S is an invalid arg for ~S" spec 'UNDERLYING-NAME))))  (defun UNDERLYING-NAME-TO-SPEC (x)    (cond      ((not (symbolp x))       (if (setf-spec-p x)	   x	   (error "~S is an invalid arg for ~S" 		  x 'UNDERLYING-NAME-TO-SPEC)))      ((get x 'setf:setf-spec))      (t        (let ((home-package (symbol-package x)))	  (if (not (eq home-package *setf-package*))	      x	      (let ((name (symbol-name x))		    accessor package-name)		;; Unpack the name, which is a form like "~D.~A.~A"		(multiple-value-bind (nchars starti)				(parse-integer name :radix 10 :junk-allowed t)		  (incf starti)		  (setq package-name (subseq name starti (incf starti nchars)))		  (incf starti)		  (setq accessor (find-symbol (subseq name starti) 					      (find-package package-name)))		  (unless accessor		    (error "~S failed to parse in ~S" 			   x 'UNDERLYING-NAME-TO-SPEC))		  `(SETF ,accessor))))))))        TITAN 
          TITAN 
         
TIMESROMAN 
          M                           a              
             g             c       /             ;             2             
      	J                                       x                           m       
                    K             &                   g %z*start*00653 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 NOV 88 11:47:17 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 28 Nov 88  11:41:32 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 28 NOV 88 10:24:45 PSTDate: 26 Nov 88 22:34 PSTFrom: masinter.paSubject: Issue: SETF-FUNCTION-VS-MACROTo: cl-cleanup@sail.stanford.eduMessage-ID: <881128-102445-1325@Xerox>I'm working on preparing a single issue with two proposals; I'm making someprogress on simplifying the writeup.I hope to be done by late Monday.*start*04198 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 NOV 88 22:49:03 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Nov 88  22:47:30 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01399g; Mon, 28 Nov 88 22:45:27 PSTReceived: by bhopal id AA00476g; Mon, 28 Nov 88 22:44:19 PSTDate: Mon, 28 Nov 88 22:44:19 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811290644.AA00476@bhopal>To: Gray@DSG.csc.ti.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David N Gray's message of Tue, 22 Nov 88  18:38:59 CST <2805237539-1438981@Kelvin>Subject: Issue: SETF-PLACES (version 1)re: There is a non-editorial issue here:  are FBOUNDP and SYMBOL-FUNCTION    required to accept anything returned by UNDERLYING-NAME, or are they    only meaningful for symbols?  On Lisp Machines these are primitives for    accessing symbol definition cells while other functions, FDEFINEDP and    FDEFINITION, accept any function spec.Yes, the current CLOS spec requires FBOUNDP and SYMBOL-FUNCTION toaccept "function specs"; see for example the documentation in 88-002Rof ENSURE-GENERIC-FUNCTION.  This proposal (SETF-PLACES, or whatever name you want to call it) does not purport to change that requirement for those implementations that already have "function specs" implemented.[Incidentally, the earlier SETF-FUNCTION-VS-MACRO proposal failed toaddress the SYMBOL-FUNCTION issue.]re: For consistency, shouldn't this be accepted by all function-defining    macros and special forms?  Besides DEFMETHOD and DEFGENERIC, there are    DEFUN, FLET, LABELS, GENERIC-FLET, GENERIC-LABELS, WITH-ADDED-METHODS,    and DEFCLASS.  I also can't find any mention of the special form    FUNCTION in the proposal; shouldn't it also accept function specifiers?Most certainly not!  This is the whole point of this proposal -- tolimit non-symbol names to precisely the one place in CLOS where it isextremely difficult to use just one symbol, namely in the SETF genericmethods.  Note that DEFMETHOD, DEFGENERIC etc doesn't define "a function",but rather a piece of one.  The whole reason that anyone outside the Brothers-of-MIT-LispMachinecommunity acceed to compound names for setf methods is that it was verydifficult to use a single symbol for specifying what "piece" of what"function" is meant.  Further, by Gregor's argumentation, the non-symbolname need only appear in the outer CLOS syntax, since DEFMETHOD is justa macro which will expand out into something more primitive (which inmany implementations will be a hoked-up symbol a la the example code.)Similarly, requiring a few functional entries of CLOS to accommodate alimited function spec notion is nowhere near the burden on otherimplementations that extending to full functions specs would be.Looking ahead, I see that several more of the "Brothers-..." havemade the same request, which basically boils down to requiring allimplementations to have the essence of function specs by "trojan horse".Contrary to what has been said, the X3J13 group is not adamantly againstSETF-FUNCTIONS -- rather, they are balking at the notion of lists as function names.  I fervently hope that in the future some improvedversion of function specs -- definition specs -- will be accepted intoCommon Lisp; but in my opinion, the consensus to do it now just isn'tthere.  It just does no good to pretend that this one itsy-bitsy,teensy-weensy extension isn't full functions specs; the issues seenso clearly by many are:  (1) once you've had to dicker around with all the places in an      implementation to make (SETF <foo>) uniformly acceptable as      a function name, you have basically done all the necessary       work for "functions specs".  So if it walks like a duck,       quacks like a duck . . .   (2) functions specs [and indeed "definition specs"] break a very      fundamental notion people have about function names -- that      only symbols will do; it will take some longer period of time       to get them used to the newer ideas.-- JonL --*start*01938 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 NOV 88 23:06:31 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Nov 88  23:05:39 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01405g; Mon, 28 Nov 88 23:03:29 PSTReceived: by bhopal id AA00498g; Mon, 28 Nov 88 23:02:21 PSTDate: Mon, 28 Nov 88 23:02:21 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811290702.AA00498@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 22 Nov 88 19:49 EST <19881123004923.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: SETF-PLACES (version 1)re: Similarly, LABELS and FLET should accept "specs", since GENERIC-LABELS    and GENERIC-FLET do.  This would eliminate the non-portability of    the FLET of setf:3.bar.middle-ref example.I don't think so.  The point of the non-portable example was just toillustrate the implementational structure of one kind of underlyingname, and its consequences outside the demands of CLOS.  In real CLOS usage, GENERIC-FLET would be used rather than FLET; and that kind of code would be portable [and it *is* the needs of CLOS that is the excuse for doing this kludge now -- not because we think it is such a great thingin its own right].Also, SETF functions currently aren't accessible via FUNCTION orSYMBOL-FUNCTION.  Namely, you have to say (SETF (AREF ...) val); there is no form that you can evaluate to get a functional definition for the SETF method.  By not making the world's most general extension here -- by admitting that you probably won't be able to define a generic setf function portably with FLET, but instead will use GENERIC-FLET -- we are not adding any limitations on what is currently doable in Common Lisp.-- Jonl --*start*01383 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 NOV 88 23:14:03 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Nov 88  23:12:23 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01411g; Mon, 28 Nov 88 23:10:01 PSTReceived: by bhopal id AA00511g; Mon, 28 Nov 88 23:08:52 PSTDate: Mon, 28 Nov 88 23:08:52 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811290708.AA00511@bhopal>To: Scott.Fahlman@B.GP.CS.CMU.EDUCc: Moon@STONY-BROOK.SCRC.Symbolics.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Tue, 22 Nov 88 21:13:26 EST <8811230216.AA02071@lucid.com>Subject: Issue: SETF-PLACES (version 1) re: . . . The current proposal looks like a recipe for    disaster, since this name/spec distinction is going to confuse people and    raise lots of questions about which can be used where.The "disaster" is _already_ there -- in 88-002R.  Have you read it?You have to pay careful attention to the whole thing, or else you maynot remember where it says what can be used where.  This proposal --(1) to clear up the setf functions issue and (2) to limit the lists-as-names issue -- neither adds nor detracts from that potentialsource of confusion.-- JonL --*start*05372 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 09:22:05 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 29 Nov 88  09:20:12 PSTReceived: by ti.com id AA15233; Tue, 29 Nov 88 11:19:22 CSTReceived: from Kelvin by tilde id AA24807; Tue, 29 Nov 88 11:13:21 CSTMessage-Id: <2805815733-10120696@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 29 Nov 88 11:15:33 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Jon L White <jonl@lucid.com>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: SETF-PLACES (version 1)In-Reply-To: Msg of Mon, 28 Nov 88 22:44:19 PST from Jon L White <jonl@lucid.com>> Yes, the current CLOS spec requires FBOUNDP and SYMBOL-FUNCTION to> accept "function specs";...> re: For consistency, shouldn't this be accepted by all function-defining>     macros and special forms? ...> Most certainly not!  This is the whole point of this proposal -- to> limit non-symbol names to precisely the one place in CLOS where it is> extremely difficult to use just one symbol, namely in the SETF generic> methods.  Note that DEFMETHOD, DEFGENERIC etc doesn't define "a function",> but rather a piece of one.  But if you are going extend the lowest level primitives, FBOUNDP andSYMBOL-FUNCTION, to accept function specs, then I don't see that yougain very much by saying that higher-level macros and special formswon't accept them.  DEFUN would typically be implemented as a macro thatexpands into (SETF (SYMBOL-FUNCTION ...) ...), so if SYMBOL-FUNCTIONaccepts function specs, wouldn't DEFUN also accept them automatically?If the intent is to limit the amount of change to implementations thatdon't already support function specs, it seems like it would be easierto leave FBOUNDP and SYMBOL-FUNCTION alone, introduce FDEFINEDP andFDEFINITION, and then say that DEFMETHOD, DEFGENERIC, etc. useFDEFINITION instead of SYMBOL-FUNCTION.  A portable definition usingyour conversion function is:  (DEFUN FDEFINITION (FUNCTION-SPEC)    (SYMBOL-FUNCTION (UNDERLYING-NAME FUNCTION-SPEC)))  (DEFUN FDEFINEDP (FUNCTION-SPEC)    (FBOUNDP (UNDERLYING-NAME FUNCTION-SPEC)))  (DEFSETF FDEFINITION (FUNCTION-SPEC) (DEFINITION)    `(SETF (SYMBOL-FUNCTION (UNDERLYING-NAME ,FUNCTION-SPEC))           ,DEFINITION))This approach also minimizes changes for those of use who do alreadysupport function specs.  The next question is whether there is really aneed for the user to know about UNDERLYING-NAME.  The only use I canthink of would be to do a GET on the underlying symbol, or to use it asa key in an EQ hash table, but neither of those would be portable sinceUNDERLYING-NAME could return a non-symbol on some implementations.  Wecould instead introduce a portable interface to associating propertieswith function-specs:  (DEFUN FUNCTION-SPEC-GET (FUNCTION-SPEC PROPERTY &OPTIONAL DEFAULT)    (GET (UNDERLYING-NAME FUNCTION-SPEC) PROPERTY DEFAULT))  (DEFSETF FUNCTION-SPEC-GET (FUNCTION-SPEC PROPERTY &OPTIONAL DEFAULT) (VALUE)    `(SETF (GET (UNDERLYING-NAME ,FUNCTION-SPEC) ,PROPERTY) ,VALUE))> Looking ahead, I see that several more of the "Brothers-..." have> made the same request, which basically boils down to requiring all> implementations to have the essence of function specs by "trojan horse".But I've just shown you how to implement the essence of function specsin only eleven lines of code.  Well, make that thirteen because youprobably want this too:  (DEFUN FUNDEFINE (FUNCTION-SPEC)     (FMAKUNBOUND (UNDERLYING-NAME FUNCTION-SPEC)))But that's it; it's not really that big a deal.  There is still aseparate question of where you want FDEFINITION etc. to be used insteadof SYMBOL-FUNCTION etc.  Mightn't it be easier to change them allconsistently than to have to document which forms of function names canbe used where?> Contrary to what has been said, the X3J13 group is not adamantly against> SETF-FUNCTIONS -- rather, they are balking at the notion of lists as > function names.  I fervently hope that in the future some improved> version of function specs -- definition specs -- will be accepted into> Common Lisp; but in my opinion, the consensus to do it now just isn't> there.  It just does no good to pretend that this one itsy-bitsy,> teensy-weensy extension isn't full functions specs; the issues seen> so clearly by many are:>   (1) once you've had to dicker around with all the places in an>       implementation to make (SETF <foo>) uniformly acceptable as>       a function name, you have basically done all the necessary >       work for "functions specs".  So if it walks like a duck, >       quacks like a duck . . . >   (2) functions specs [and indeed "definition specs"] break a very>       fundamental notion people have about function names -- that>       only symbols will do; it will take some longer period of time >       to get them used to the newer ideas.But if you accept lists to name functions in certain contexts, how doesit really help to say that they aren't "function specs"?  Since I'mobviously coming from a very biased perspective, I don't see anythingun-esthetic about using lists as function names.  It's certainly aconcept that has been around a long time and has proven very useful.*start*05472 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 NOV 88 19:38:11 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 29 Nov 88  19:37:04 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02387g; Tue, 29 Nov 88 19:35:00 PSTReceived: by bhopal id AA02997g; Tue, 29 Nov 88 19:33:53 PSTDate: Tue, 29 Nov 88 19:33:53 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811300333.AA02997@bhopal>To: Gray@DSG.csc.ti.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David N Gray's message of Tue, 29 Nov 88  11:15:33 CST <2805815733-10120696@Kelvin>Subject: Issue: SETF-PLACES (version 1)re: But if you are going extend the lowest level primitives, FBOUNDP and    SYMBOL-FUNCTION, to accept function specs, then I don't see that you    gain very much by saying that higher-level macros and special forms    won't accept them.  ....That is not the proposal.  In fact it is to _retract_ the CLOS imposedrequirement that every implementation's version of FBOUNDP andSYMBOL-FUNCTION has to accept function specs.  Only implementationswhich already allow DEFUN etc to admit functions specs will have tochange their FBOUNDP and SYMBOL-FUNCTION accordingly; this would be trueregardless of whether we accept SETF-FUNCTION-VS-MACRO or SETF-PLACES.    If the intent is to limit the amount of change to implementations that    don't already support function specs, it seems like it would be easier    to leave FBOUNDP and SYMBOL-FUNCTION alone, introduce FDEFINEDP and    FDEFINITION, and then say that DEFMETHOD, DEFGENERIC, etc. use    FDEFINITION instead of SYMBOL-FUNCTION.  I considered that, and rather liked it, but didn't find much support forit amongst others (Patrick was, I think, the main opponent; but I don'tthink Gregor liked it either).  Either way, we would have to change theCLOS spec.  In one case [the setf-places proposal] we would have to replace(FBOUNDP ...) in the CLOS spec by (FBOUNDP (UNDERLYING- ...)), etc., and in the other case we would have to to [1] Add new functions FDEFINEDP and FDEFINITION, and [2] replace (FBOUNDP ...) in the CLOS spec by (FDEFINEDP ...) etc.re:     The next question is whether there is really a    need for the user to know about UNDERLYING-NAME.  The only use I can    think of would be to do a GET on the underlying symbol, or to use it as    a key in an EQ hash table, but neither of those would be portable since    UNDERLYING-NAME could return a non-symbol on some implementations.  I don't forsee any reasonable portable use of UNDERLYING-NAME for theend  user; its existence is primarily to expose the barrier between the surface syntax of setf generic functions and the implementation-specific way in which hooks into function definition.  The end user will be usingCLOS primitives.   UNDERLYING-NAME is aimed at sub-system implementors,especially at the PCL implementor/maintainer, so that his code can beportable.  But since any implmentation that doesn't support truefunctions specs will have to have some such mapping (the "underlying"name), it might as well be a standardized function to access it.re: > Looking ahead, I see that several more of the "Brothers-..." have    > made the same request, which basically boils down to requiring all    > implementations to have the essence of function specs by "trojan horse".    But I've just shown you how to implement the essence of function specs    in only eleven lines of code.  Well, make that thirteen because you    probably want this too:With all due respect David, you've shown how to implement function specsfor DEFUN.  The original SETF-FUNCTION-VS-MACRO listed 18 Common Lispconstructs that would have to be changed, and that doesn't count thepain for the several portable code-walkers running around.  DEFUN is the easy one, because it generally is just a macro (as DEFMETHOD is a macro). At any rate, the killer objection is not how much or how little work it is to implement function specs, but rather that there is still an enormous undercurrent of distaste for list-as-function-names.re: But if you accept lists to name functions in certain contexts, how does    it really help to say that they aren't "function specs"?  Since I'm    obviously coming from a very biased perspective, I don't see anything    un-esthetic about using lists as function names.  It's certainly a    concept that has been around a long time and has proven very useful.To say that the way you incrementally define the setf method for ageneric function is by use of a form like (DEFMETHOD (SETF foo) ...)  is not by itself acceptance of lists-as-names.  One can pretend that this is just a macro that expands into (DEFUN SOME-SYMBOL ...)[along with whatever implementation-dependent processing is needed todistinguish generic functions from regular ones].  The difficultyarises when you require something like (SYMBOL-FUNCTION '(SETF foo))to have meaning; for those implementations without function specs,this is the uncrossable barrier.  The current setf-places proposalneatly puts in the little "fence" by saying:	(SYMBOL-FUNCTION (UNDERLYING-NAME '(SETF foo)))An implementation that already has function specs isn't affected atall by this, since it is permitted to define UNDERLYING-NAME as theidentity function.-- JonL --*start*03159 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 NOV 88 00:40:32 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 30 Nov 88  00:39:40 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02533g; Wed, 30 Nov 88 00:37:34 PSTReceived: by bhopal id AA03401g; Wed, 30 Nov 88 00:36:26 PSTDate: Wed, 30 Nov 88 00:36:26 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811300836.AA03401@bhopal>To: masinter.paCc: CL-CLEANUP@Sail.Stanford.EDUIn-Reply-To: masinter.pa@Xerox.COM's message of 27 Nov 88 15:00 PST <881128-102707-1360@Xerox>Subject: Merger SETF-FUNCTION-VS-MACRO and SETF-PLACES proposalsI object to the way in which this merger has been done *** in thestrongest possible way ***.There has never before been an issue upon which the cleanup committeesuccessfully reported out two competing proposals.  We do not have an acceptable precedent for sending unresolved alternatives to the committee as a whole.  However, if we in the subcommittee are unable to decide to drop one of these two proposals, then the presentation of the positions pro and con should come from the active proponents of each side --- not from your (misguided, I think) advocacy.I agree that the two proposals should be presented as "being of one Issue, and being mutually incompatible"; but I most strongly disagree that the current Issue format is adequate for the blending in of seriously opposed alternatives.  The "common" sections of References,Problem Description, Benefits, Rationale etc. presume a commonunderstanding of what the problem is.  But for the two proposalsat hand, the only common thread is the 10 lines (out of the 600 or so)that call for setf expansions to defaultly turn into setf functions.Furthermore, the attempted "merger" of the texts from the two proposals has led to one that is substantially longer, and substantially more complex, than the two separate ones standing by themselves.  For example, the setf-places version has only 9 items in the "References" section -- but the "merged" version has 25 items, 16 of which are irrelevant to anddistracting from the setf-places.  I would much much rather read two proposals of length N, than one co-mingled one of length 2N -- thecomplexity measure of the latter can easily be 4 times greater thanthat of either predecessor.Oddly enough, I have the same feeling towards this issue as Moon, but from the other side of the fence.  I would be only mildlydisappointed if X3J13 decides as a whole to cram "function specs"downs the throats of all those who have so vociferously rejectedthem ("disappointed", because I don't think "function specs" are good enough -- not because I find lists-as-names disagreeable).  ButI would be thoroughly displeased if the committee loses focus onthe choices because the issue is far to complex to read now.   I'drather see the issue settled by a flip of a coin than risk havingyet more ways to go astray, or more things to argue unproductivelyabout.-- JonL --*start*24581 00024 US Date: 30 Nov 88 10:33 PSTFrom: masinter.paSubject: *** POLL *** Issue: SETF-FUNCTION-VS-MACRO (version 6)To: CL-CLEANUP@Sail.Stanford.EDUline-fold: NOcc: masinter.pareply-to: cl-cleanup@sail.stanford.eduJonL has objected to the merger of the two writeups on the grounds that:a) precedent: we've rarely reported an issue with two proposalsb) partiality: I've not presented the arguments as strongly as theproponents of either "side" might; my advocacy is "misguided".c)  length:the merged version is as long as the sum of the sizesof the individual writeups. I have discovered, to my embarassement,  that I neglected to delete from "NAMED-BY-LIST" a fairly large section that was covered in"COMMON-PART".I would like to get a sense of the rest of the committee: would you pleaserespond to this message on the following question: ***** Should we continue to attempt to arrive at one writeup with twoseparate proposals?  *******Thanks,Larry!Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)             X3J13 88-002R:               Accessing Slots, Ch. 1 p.11               DEFGENERIC  Ch. 2 pp.26-9               DEFMETHOD  Ch. 2 pp.39-41               (SETF DOCUMENTATION)  Ch. 2 pp.43-5               ENSURE-GENERIC-FUNCTION  Ch. 2 pp.46-7               GENERIC-FLET  Ch. 2 p.52               GENERIC-LABELS  Ch. 2 p.55-6               WITH-ADDED-METHODS Ch. 2 pp.90-1Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon                   (based on discussion among the CLOS working group)               Version 2, 26-Oct-87 Masinter, minor mods               Version 3, 4-Nov-87 Moon, small clarifications at KMP's urging               Version 4, 15-Nov-88 JonL, complete rewrite               Version 5, 26-Nov-88 Masinter, merge Versions 3 & 4.               Version 6, 30-Nov-88 Masinter, shortenPROBLEM DESCRIPTION:The SETF mechanism in Common Lisp was designed to allow for a uniform way of refering to the "update" function of an accessor withouthaving to have separate names for the updator.  The SETF macro shields the userfrom ever having to know such names; the correlation between an accessorname and its corresponding updator name, or updating code sequence, wasestablished by DEFSETF and DEFINE-SETF-METHOD. Update function nameslike SET and RPLACA were retained primarily for backward compatibility.However, in CLOS programming, generic updator functions mustbe specified in pieces, by incremental uses of DEFMETHOD. For this,and a variety of other reasons, the CLOS specification 88-002R (accepted by X3J13) assumed that lists of the form (SETF <name>) wereacceptable to a wide variety of functions and macros as a way tospecify the "name" of the SETF function. The problem is that thispart of CLOS must be resolved with the rest of Common Lisp.This issue has two proposals, NAMED-BY-LIST and COMPUTE-UNDERLYING-NAME.The proposals differ only in how setf functions are named; the common partis given first.PROPOSAL (SETF-FUNCTION-VS-MACRO:COMMON-PART):Add the concept of a "SETF function". Right now, Common Lisp has twoways to define the behavior of SETF of a form, DEFINE-SETF-METHOD andDEFSETF. Terminology:- a "setf macro" is something that produces code (or other  specifications, as in define-setf-method) which, when evaluated,  will perform the effect of an invocation of setf.- a "setf function" is something that is called to perform  directly the effect of an invocation of setf.Extend the set of valid "place specifiers" as defined on CLtL p 94-97by adding a clause after the existing ones, to the effect that:"For any other place specifier, the form  (SETF (-name- a1 a2 ... an) new-value),   will expand into a call to -name-'s corresponding setf-function,  such expansion to be of the form:(<setf-function-for--name-> y a1 a2 ... an), except that  the left-to-right evalution order of a1 a2 ... an y is preserved."A setf function receives the new value to be stored as its firstargument. The setf function for -name- should have one more requiredparameter than -name-, the first required parameter is the new valueto be stored, and the remaining paramters should be the same as -name-'sparameters. A setf function should return its first argument, sinceSETF is defined to return the new value. Note that SETF will no longer signal any "unknown place specifier" errors during macroexpansion, because the default behavior is tosimply construct a call to the setf function [except, however, when"access-fn" isn't legal as the name of a function; for example,(SETF ((SPAZ) I1 I2) VALUE) is still syntaticly illegal].  But ifat run time, the "setf function" still hasn't been defined as afunction [such as by DEFUN, DEFMETHOD, setf of SYMBOL-FUNCTION etc.],then a run-time "undefined function" error may occur.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.What CLtL says about (documentation foo 'setf) will not change.Specifically, the setf documentation type applies just to defsetf (anddefine-setf-method, that's an omission in CLtL).  The documentation fora setf function can be retrieved by (documentation '(setf foo) 'function).The two proposals differ in the manner in which the "name" ofa setf function is determined.The proposal COMPUTE-UNDERLYING-NAME allows these to beimplementation-dependent, and adds two functions,UNDERLYING-NAME and UNDERLYING-NAME-TO-SPEC, for convertingfrom specifications of the form (SETF -name-) to the realname and back.The proposal NAMED-BY-LIST specifies that the name ofthe setf function for -name-  *is* the list (SETF -name-),and extends those places in Common Lisp that deal withfunction names to require them to accept such lists. PROPOSAL (SETF-FUNCTION-VS-MACRO:COMPUTE-UNDERLYING-NAME):The name of the setf function for -name- is implementationdependent; in some implementations, it could be a list (aswith the NAMED-BY-LIST proposal below); in other implementations, it could be a symbol.- Add a new function, UNDERLYING-NAME of one argument:      (i) on any list like (SETF <name>), it returns a unique,           implementation-dependent name suitable for actual use as           a function name in that implementaion.     (ii) on symbols, it is the identity function; and    (iii) on any other data, it is undefined; however, other lists          like (<spec-kind> ...) should be reserved for extensions          which the x3J13 committee may be considering.- Add a new function, UNDERLYING-NAME-TO-SPEC of one argument:      (i) on any argument which results from UNDERLYING-NAME applied         to a list (SETF <name>), UNDERLYING-NAME-TO-SPEC returns         an EQUAL list.     (ii) on any symbol or list not covered by part (i),         UNDERLYING-NAME-TO-SPEC returns it's argument.    (iii) on any other data, it is undefined.The result of UNDERLYING-NAME should be constant across incarnationsof the same release of an implementation, and should be of a data typethat can be printed out and read back in reliably.   For example, an implementation might choose to define:      (UNDERLYING-NAME '(SETF FOO)) ==> SETF:4.USER.FOO      (UNDERLYING-NAME-TO-SPEC 'SETF:4.USER.FOO) ==> (SETF FOO)or an implementation could choose to allow lists as names:      (UNDERLYING-NAME '(SETF FOO)) ==> (SETF FOO)      (UNDERLYING-NAME-TO-SPEC '(SETF FOO)) ==> (SETF FOO)-- Modify the wording in the standard which describes parts imported  from the CLOS specification so as not to imply that lists are  suitable as function names.  In particular,     (a) phrases like "... if <function-specifier> names a function" should         be changed to a phrase like "... if <function-specifier> refers to        a defined function", or possibly even something like        "... if (UNDERLYING-NAME <function-specifier>) names a function"    (b) phrases like "(FBOUNDP <function-specifier>)" should be changed        into "(FBOUNDP (UNDERLYING-NAME <function-specifier>))"; or        else other terminology should express the intent of what is to        be said.  For example, instead of saying: "When (FBOUNDP <f-s>)         is  true ..." one could just as well say  "When <f-s> refers to         a defined function ..."  The choice of which of these two formats         to use is an editorial one.    (c) phrases like "(SYMBOL-FUNCTION function-specifier)" should be changed        into "(SYMBOL-FUNCTION (UNDERLYING-NAME <function-specifier>))";        or else other terminology should express the intent of what is to        be said.  For example, one might say "... the function referred         to by <f-s>".  The choice of which of these two formats to use is        an editorial one.Note that forms like    (DEFMETHOD (SETF FOO) ...)will expand similarly to     (DEFMETHOD #.(UNDERLYING-NAME '(SETF FOO)) ...)except that the implicit block name surrounding the body of the methodwill be FOO and not (UNDERLYING-NAME '(SETF FOO)).The underlying call to ADD-METHOD will see the real function name usedfor the updator function.  The user-level interface of CLOS can stillpresent the list format as acceptable; it is only the implementation ofDEFMETHOD, DEFGENERIC, that will have to worry about converting to a"real" name.In an implementation note, point out that UNDERLYING-NAME-TO-SPECcould be used by debuggers to print out something more user-comprehensiblethan the internal names that an implementation might use.PROPOSAL (SETF-FUNCTION-VS-MACRO:NAMED-BY-LIST): The "name" of the setf function for -name- is a list (SETF -name-),where -name- is a symbol. The body of thisfunction is surrounded by an implicit block named -name-.Modify the following functions, macros, special forms, and declarations:COMPILE function, DEFUN macro, DISASSEMBLE function, DOCUMENTATION function,FBOUNDP function, FLET special form, FMAKUNBOUND function, FTYPE declaration,FUNCTION special form, FUNCTION declaration, INLINE declaration,NOTINLINE declaration, LABELS special formto accept such lists in addition to symbols as function names, so thatsetf functions can be defined and manipulated.Note that, although it is possible to lexically redefine the function definitionof (SETF -name-), the macro expansion of SETF is not affected by suchlexical redefinition. Clarify that (documentation foo 'setf) is only affected by invocationsof defsetf and define-setf-method. (As specified above, the DOCUMENTATIONfunction is modified so that (documentation '(setf foo) 'function) willretrieve documentation strings established by (defun (setf foo) (arg) "This is documentation..." ....)Examples:;;If SETF of SUBSEQ were not already built into Common Lisp,;it could be defined, under NAMED-BY-LIST, as:(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));; while with COMPUTE-UNDERLYING-NAME, as:  (setf (symbol-function (underlying-name '(setf subseq)))	#'(lambda (new-value sequence start &optional end)	    (unless end (setq end (length sequence)))	    (setq end (min end (+ start (length new-value))))	    (do ((i start (1+ i))		 (j 0 (1+ j)))		((= i end) new-value)	      (setf (elt sequence i) (elt new-value i)))));;Another example, showing a locally defined setf function.;; with NAMED-BY-LIST:(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));; with COMPUTE-UNDERLYING-NAME:; First, define MIDDLE-REF to be an accessor function as follows:    (defun middle-ref (vec i)       (check-type i fixnum)      (aref vec (ceiling i 2)));; then, even given:    (defun #.(underlying-name '(setf middle-ref)) (new-element vec i)       (check-type i fixnum)      (setf (aref vec (ceiling i 2)) new-element))    (flet ((#.(underlying-name '(setf middle-ref)) (new-element vec i)              ;;"wide-body" version of set-middle-ref             (declare (ignore i))             (fill vec new-element :end (ceiling i 2))))      (setf (middle-ref "abc" 1) #\z));;;GET-SETF-METHOD could implement setf functions by calling;;;this function when none of the other rules of CLtL p 94-7 apply:(defun get-setf-method-for-setf-function (form)  (let ((access-fn (car form))        (new-value (gensym))        (temp-vars (do ((a (cdr form) (cdr a))                        (v nil (cons (gensym) v)))                       ((null a) v))))    (values temp-vars (cdr form) (list new-value)            `(,@#+NAMED-BY-LIST			`(funcall #'(setf ,access-fn)) #+COMPUTE-UNDERLYING-NAME			`(,(underlying-name `(setf ,access-fn)))                      ,new-value ,@temp-vars)            `(,(car form) ,@temp-vars))))RATIONALE:Both proposals allow a more functional appropach to dealing withSETF, and bring the CLOS and Common Lisp parts of the standard intomore alignment. COMPUTE-UNDERLYING-FUNCTION does so by adding functionsto go between the "specification" of (SETF -name-) to the name actually used, while NAMED-BY-LIST does so by extending a numberof already existing Common Lisp functions, macro and special forms.SETF functions take the "new value" as the first argument to allowfor defining them on accessors that have &REST and &KEY arguments.By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified. In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a feature similar,but not compatible with, NAMED-BY-LIST, in that they allow setting functions named (SETF reader).  We don't know of any implementationthat has precisely the proposed feature.For example, This will be an incompatible change for Symbolics,since it already has setf functions but they do not take thesame arguments as proposed here.COST TO IMPLEMENTORS:For either proposal, the SETF macro expansion would have to beextended to generate the appropriate call on the setf function.The additional cost of proposal COMPUTE-UNDERLYING-NAME is low;implementations would need to add the two proposed functions.In addition, implementations would need to modify theirCLOS implementation to use UNDERLYING-NAME where appropriate.[A sample implementation is given at the end of the proposal.]The cost of proposal NAMED-BY-LIST is higher, since many otherfunctions, macros and special forms would have to be extended to deal with the SETF specifications. The main cost is generalizationof a few functions to accept lists beginning with SETF where theynow accept only symbols.  Implementations must add a data structureto store the function definition of a setf function, however, this canbe done with property lists or generated symbols.COST TO USERS:Both proposals are basically upward-compatible changes for currentlyportable Common Lisp programs.As with any language extension, some program-understanding programs mayneed to be enhanced.  A particular issue with NAMED-BY-LIST is programsthat assume that all function names are symbols.  They may use GET toaccess properties of a function name or use EQ or EQL (perhaps via MEMBER or ASSOC) to compare function names for equality.  Such programswill need improvement before they can understand programs that usethe new feature.Both proposals remove some macro-expansion error checking, sincedetection of incorrect SETF expansion will be postponed to run-time.This is a minor deficiency, as it puts invocation of SETF functionson the same footing as other function calls.COST OF NON-ADOPTION:Common Lisp and CLOS would be significantly inconsistent; some majorrethinking of CLOS would be required.BENEFITS:Improve usability of SETF. Avoids cost of non-adoption.With NAMED-BY-LIST, current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)could be replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)With NAMED-BY-LIST, a convenent way of lexically definingor redefining the behavior of SETF would be allowed.PERFORMANCE IMPACT:Negligible; ether proposal might make an implementation slightlylarger.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.The proposal NAMED-BY-LIST allows lists of the form (SETF -name-) to beused in many places where only symbols were allowed before. Somepeople feel this is unesthetic, because it is at odds with manycurrent descriptions of Common Lisp say that names are symbols.DISCUSSION:This issue has been in discussion in the CLOS committee and at X3J13for over a year. Versions of the proposal were distributed, discussed,and voting tabled at three successive meetings of X3J13. The proposalpreviously distributed most resembles the NAMED-BY-LIST proposl containedin this version.Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  Neither proposal attempts tochange that aspect of Common Lisp.Most of the objection to previous proposals were based onintroducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.The CLOS group unsuccessfully tried a number of alternatives thatdid not require naming the setf function at all. However,fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.!Appendix: Sample implementation of COMPUTE-UNDERLYING-NAMEThe following code can be used by an implementation which doesn'thave "function specs" to implement the COMPUTE-UNDERLYING-NAME proposal:  ;;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: SYSTEM; Base: 10 -*-  ;;;  ;;; Author: JonL White, 15-Nov-88  ;;;  (in-package "SYSTEM")			;or, your development package  (eval-when (eval compile load)  ;;; The SETF package should be reserved for this purpose  ;;;  (or (find-package "SETF")       (make-package "SETF" :use nil))  (defparameter *setf-package* (find-package "SETF"))  (unless (and (null (package-use-list *setf-package*))	       (null (package-used-by-list *setf-package*)))    (error "SETF package has connections?"))  ;;; "Internal Markers", to be used for uninterned symbols.  ;;;  (export (intern "SETF-SPEC" *setf-package*) *setf-package*)  (export (intern "SETF-NAME" *setf-package*) *setf-package*)  )  (eval-when (eval compile)  (defmacro setf-spec-p (x)    (let ((spec (gensym)))      `(LET ((,spec ,x))	 (AND (CONSP ,spec) 	      (EQ (CAR ,spec) 'SETF)	      (CONSP (CDR ,spec))	      (NULL (CDDR ,spec))	      (SYMBOLP (SECOND ,spec))))))  )  (defun UNDERLYING-NAME (spec)    (cond       ((symbolp spec)        spec)      ((setf-spec-p spec)       (let* ((accessor (second spec))	      (accessor-name (symbol-name accessor))	      (home-package (symbol-package accessor)))	 (if home-package	     (let* ((package-name (package-name home-package))		    ;; 'spec-name' is a form like "~D.~A.~A", but FORMAT has a		    ;; problem with global print parameters like *print-radix*		    (spec-name (concatenate 'string				 (write-to-string (length package-name)				   :radix nil :base 10 :length nil :level nil)				 "."				 package-name				 "."				 accessor-name))		    (updator (or (find-symbol spec-name *setf-package*)				 (let ((sym (intern spec-name *setf-package*)))				   (export sym *setf-package*)				   sym))))	       ;; A possible optimization, which trades off space for time, is	       ;;  as follows; see definition of UNDERLYING-NAME-TO-SPEC below	       ;;(setf (get updator 'setf:setf-spec) (copy-list spec))	       updator)	     (or (get accessor 'setf:setf-name)		 (let* ((uname (concatenate 'string "SET-" accessor-name))			(updator (make-symbol uname)))		   (setf (get accessor 'setf:setf-name) updator)		   (setf (get updator 'setf:setf-spec) (copy-list spec))		   updator)))))	  (t 	   (error "~S is an invalid arg for ~S" spec 'UNDERLYING-NAME))))  (defun UNDERLYING-NAME-TO-SPEC (x)    (cond      ((not (symbolp x))       (if (setf-spec-p x)	   x	   (error "~S is an invalid arg for ~S" 		  x 'UNDERLYING-NAME-TO-SPEC)))      ((get x 'setf:setf-spec))      (t        (let ((home-package (symbol-package x)))	  (if (not (eq home-package *setf-package*))	      x	      (let ((name (symbol-name x))		    accessor package-name)		;; Unpack the name, which is a form like "~D.~A.~A"		(multiple-value-bind (nchars starti)				(parse-integer name :radix 10 :junk-allowed t)		  (incf starti)		  (setq package-name (subseq name starti (incf starti nchars)))		  (incf starti)		  (setq accessor (find-symbol (subseq name starti) 					      (find-package package-name)))		  (unless accessor		    (error "~S failed to parse in ~S" 			   x 'UNDERLYING-NAME-TO-SPEC))		  `(SETF ,accessor))))))))     ----- End Forwarded Messages -----*start*01205 00024 US Date: Wed, 30 Nov 88 17:19 PSTFrom: Gregor.paSubject: Re: *** POLL *** Issue: SETF-FUNCTION-VS-MACRO (version 6)To: cl-cleanup@sail.stanford.educc: masinter.paFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: <881130-103422-2216@Xerox>Message-ID: <19881201011953.3.GREGOR@PORTNOY.parc.xerox.com>Line-fold: noI continue to believe that there are two completely seperate topics:1) Should setf be changed to have a default behavior of calling some   function whose name is derived from the "accessor.  Doing this allows   one to define functions or generic functions without having to deal   with defsetf or friends.2) If 1 is accepted, what should the name of those "setf functions" be?   One solution is so called "function specifiers".  Another solution   is to have half function specifiers.  I still believe the best solution   is just to use symbols everywhere even in defmethod and defgeneric forms.I don't expect to see this be separated this way, nor do I expect thatfunction specs will really go away as much as they should.  At this point Ipromise not to argue about this at X3J13 meetings anymore.  But I may sulkabout it some!-------*start*01146 00024 US Date: 30 Nov 88 18:58 PSTFrom: masinter.paSubject: Issue: SETF-FUNCTION-VS-MACRO (version 6)In-reply-to: Gregor.pa's message of Wed, 30 Nov 88 17:19 PSTTo: Gregor.pacc: cl-cleanup@sail.stanford.edu, masinter.paThere are two other proposals which might also be considered on this issue:Proposal SETF-FUNCTION-VS-MACRO:NO-SETF-FUNCTIONSDo not change the behavior of SETF regarding the default behavior if no setf macro has been defined. Modify the sections throughout the CLOS specification which refer to defining methods or generic functions which affect the behavior of SETF.Proposal SETF-FUNCTION-VS-MACRO:USE-SYMBOL-IN-SETF-PACKAGEThe name of the SETF function associated with X is computed by (INTERN (LET ((*PACKAGE* (FIND-PACKAGE "KEYWORD") (*PRINT-CASE* :DOWNCASE)) (FORMAT NIL "~S" X)) (FIND-PACKAGE "SETF"))i.e., there is a package named SETF, and the SETF function for X is computed by printing X with package qualifier and then interning the result into the SETF package.This only has problems if X is a symbol for which reading the printed representation does not yield the same symbol.*start*00902 00024 US Return-Path: <@multimax.encore.com:pierson@mist.encore.com>Received: from multimax.encore.com ([192.5.63.14]) by Xerox.COM ; 30 NOV 88 12:08:55 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA04252; Wed, 30 Nov 88 15:06:02 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA01386; Wed, 30 Nov 88 14:26:34 ESTMessage-Id: <8811301926.AA01386@mist.>To: masinter.paCc: cl-cleanup@sail.stanford.eduSubject: Re: *** POLL *** Issue: SETF-FUNCTION-VS-MACRO (version 6) In-Reply-To: Your message of 30 Nov 88 10:33:00 -0800.             <881130-103422-2216@Xerox> Date: Wed, 30 Nov 88 14:26:32 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>I think that two separate proposals are easier to understand.  We cantry to attach a joint cover letter for the vote to indicate that onlyone should pass, but even that is probably unnecessary.*start*01627 00024 US Return-Path: <@REAGAN.AI.MIT.EDU:Mly@AI.AI.MIT.EDU>Received: from REAGAN.AI.MIT.EDU ([128.52.22.53]) by Xerox.COM ; 02 DEC 88 20:31:24 PSTReceived: from ISABEL-PERON.AI.MIT.EDU by REAGAN.AI.MIT.EDU via CHAOS with CHAOS-MAIL id 153052; Fri 2-Dec-88 23:30:26 ESTDate: Fri, 2 Dec 88 23:30 ESTFrom: Richard Mlynarik <Mly@AI.AI.MIT.EDU>Subject: *** POLL *** Issue: SETF-FUNCTION-VS-MACRO (version 6)To: masinter.paIn-Reply-To: <881130-103422-2216@Xerox>Message-ID: <19881203043022.2.MLY@ISABEL-PERON.AI.MIT.EDU>    Date: 30 Nov 88 10:33 PST    From: masinter.pa@Xerox.COM    JonL has objected to the merger of the two writeups on the grounds that:    a) precedent: we've rarely reported an issue with two proposals    b) partiality: I've not presented the arguments as strongly as the    proponents of either "side" might; my advocacy is "misguided".    c)  length:the merged version is as long as the sum of the sizes    of the individual writeups.(I think JonL is wedged and is just giving you a hard time.)I support NAMED-BY-LIST (and hence COMMON-PART) and oppose UNDERLYING-NAME. I believe that all implementations are going to have to bite thefunction specs bullet for CLOS in any case -- UNDERLYING-NAME seems tobe just perpetuating an untenable situation a little longer.I am opposed to splitting the proposal up for the same reasons I wasopposed to splitting up FUNCTION-TYPE -- I hoped to see a desirablechange to which there were shrill objections ``ride in on the coat-tailsof'' another issue.  I think I just like being on the losing side oftechnical arguments.*start*01103 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 06 DEC 88 12:26:43 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00560g; Mon, 5 Dec 88 17:10:31 PSTReceived: by bhopal id AA07713g; Mon, 5 Dec 88 17:07:58 PSTDate: Mon, 5 Dec 88 17:07:58 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812060107.AA07713@bhopal>To: masinter.paCc: jonl@lucid.comIn-Reply-To: masinter.pa@Xerox.COM's message of 30 Nov 88 10:33 PST <881130-103422-2216@Xerox>Subject: *** POLL *** Issue: SETF-FUNCTION-VS-MACRO (version 6)re: ***** Should we continue to attempt to arrive at one writeup with two    separate proposals?  *******It's probably moot now, but the question really is "Should Masinter continue the attempt ...".   More strongly than I care to discuss with you, my objection has been that you jerked this issue totally around without even considering the work that moon or I had put into it andhad expected to continue on it.  Witness the significant discussion with David Gray on SETF-PLACES.-- JonL --*start*03859 00024 USfReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 16 JUN 87 20:38:46 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 174865; Tue 16-Jun-87 23:36:11 EDTDate: Tue, 16 Jun 87 23:36 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re:  SETF- method namesTo: Jim Kempf <kempf%hplabsc@hplabs.HP.COM>cc: Masinter.paIn-Reply-To: <8706101425.AA14429@hplabsc>Message-ID: <870616233601.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Wed, 10 Jun 87 07:25:14 pdt    From: Jim Kempf <kempf%hplabsc@hplabs.HP.COM>    Dave, would it be possible to obtain a copy of your "function spec"    proposal? The problem with tracing may become serious enough when    CLOS gets adopted that a solution must be found. My users are    already getting restless. And I may be able to find the energy    to push it.I don't have a proposal as such.  Here's a quick summary of the documentation.Note that I didn't design any of this stuff, I'm just pointing out thatit has been found useful in practice.  I probably wouldn't advocate puttingthis into Common Lisp in precisely its present form, but haven't thoughtdeeply about what makes sense to change.  The important thing is that macroslike defmethod can construct names by using symbolic structures such as listsrather than using string concatenation.A function-spec is the name of a location in which you can store afunction.  This can be a symbol or a list whose car is a symbolregistered as a function-spec-type; the cdr of the list depends on theparticular function-spec-type.  (We also allow instances of user-definedclasses that obey a certain protocol as function-specs, for a peculiarinternal reason, but normally it turns out that lists are better becausethey have printed representations that can appear in source code.) Some operations on function-specs are:  FDEFINE function-spec definition &optional carefully no-query    Ignoring the optional arguments, this is the obvious generalization    of SETF of SYMBOL-FUNCTION.  The arguments help out the programming    environment.  Carefully, if true, means to preserve TRACE and ADVISE    and so forth.  If carefully is true and no-query is false, the    programming environment checks for name clashes between files.  FDEFINITION function-spec    Returns its definition.  Generalization of SYMBOL-FUNCTION.  FDEFINEDP function-spec    Returns true if it has a definition.  Generalization of FBOUNDP.  FUNDEFINE function-spec    Removes its definition.  Generalization of FMAKUNBOUND.  SYS:VALIDATE-FUNCTION-SPEC function-spec &optional nil-allowed    Returns true if the function-spec is well-formed.  This doesn't    imply that it has a definition, only that it could have one.  SI:FUNCTION-SPEC-GET, SETF of SI:FUNCTION-SPEC-GET,  SI:FUNCTION-SPEC-REMPROP, SI:FUNCTION-SPEC-PLIST    Function specs have property lists just like symbols.  FUNCTION function-spec    Works of course.  EQUAL function-spec function-spec    Function-specs are compared with EQUAL.Some example function-spec types:  (:PROPERTY symbol indicator)  (FLAVOR:METHOD generic-function flavor-name qualifiers...)  (:INTERNAL function-spec number [name])     :INTERNAL is used to name functions defined inside other     functions with LABELS, FLET, or plain LAMBDA.  (SETF symbol)     (SETF (symbol ...) ...) => (FUNCALL #'(SETF symbol) ... ...)     for those symbols that are set up this way.  This is how     setf-generic-functions are named in Flavors.There are 12 others in the world I'm running.(SYS:DEFINE-FUNCTION-SPEC-HANDLER symbol (&rest args) &body body)defines a function-spec-type; the details aren't interesting.*start*01053 00024 USaReturn-Path: <franz!feast!smh@ucbarpa.Berkeley.EDU>Received: from ucbarpa.Berkeley.EDU by Xerox.COM ; 23 NOV 87 21:17:13 PSTReceived: by ucbarpa.Berkeley.EDU (5.58/1.25)	id AA19658; Mon, 23 Nov 87 21:17:21 PSTReceived: by franz (5.5/3.14)	id AA04144; Mon, 23 Nov 87 20:47:34 PSTReceived: by feast (5.5/3.14)	id AA02284; Mon, 23 Nov 87 23:27:48 ESTDate: Mon, 23 Nov 87 23:27:48 ESTFrom: franz!feast!smh@ucbarpa.Berkeley.EDU (Steven M. Haflich)Message-Id: <8711240427.AA02284@feast>To: Masinter.paIn-Reply-To: franz!Xerox.COM!Masinter.pa's message of 23 Nov 87 14:28 PST <871123-143006-2795@Xerox>Subject: [David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>: Re: SETF- method names]Got Moon's message.  I think I have everyone's net address, but I'lllet you know if I need anything.I agree that it's difficult to motivate function specs, but it seemsalmost every implementation has gotten around to finding them useful.This is probably suufficient motivation for standardizing them, if noother can be found.*start*01889 00024 US Return-Path: <edsel!jonl@labrea.Stanford.EDU>Received: from labrea.Stanford.EDU by Xerox.COM ; 11 FEB 88 20:45:59 PSTReceived: by labrea.Stanford.EDU; Thu, 11 Feb 88 20:45:15 PSTReceived: from bhopal.lucid.com by edsel id AA14316g; Thu, 11 Feb 88 20:32:51 PSTReceived: by bhopal id AA10636g; Thu, 11 Feb 88 20:37:43 PSTDate: Thu, 11 Feb 88 20:37:43 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8802120437.AA10636@bhopal.lucid.com>To: labrea!masinter.PA%Xerox.COM@labrea.Stanford.EDUCc: labrea!CL-Cleanup%SAIL@labrea.Stanford.EDU, labrea!Common-Lisp-Object-System%SAIL.labrea!Moon%STONY-BROOK.SCRC.Symbolics.COM@labrea.Stanford.EDU, labrea!RG%AI.AI.MIT.EDU.sun!franz!smh@labrea.Stanford.EDU, labrea!rwk%AI.AI.MIT.EDU@labrea.Stanford.EDUIn-Reply-To: masinter.PA@Xerox.COM's message of 11 Feb 88 10:00:26 PST <880211-100052-7099@Xerox>Subject: Status of SETF functions in Common Lispre: The issue SETF-FUNCTION-VS-SYMBOL was distributed and tentatively approved    at the November 1987 meeting of X3J13. The issue name was SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSIt had two parts:    (1) Specify that the expansion of SETF is into a function rather       than merely into a "macro";   (2) Allow a generalized name for this function.The discussion under this issue is what led to formation of the "definition specs" group.  I doubt that anything that comes upunder the broader scope could conflict with the minimal assumptionsstated in that proposal.  In particular, a nomenclature style like(SETF FN) must be acceptable, and #'(SETF FN) will designate thefunction so named.I certainly remember the overwhelming approval for this direction ofextension, but I think the reason it didn't just end with this singleproposal is that every place that accepts function names is involved,not just SETF methods.-- JonL --*start*12788 00024 USaDate:  9 Dec 88 00:56 PSTFrom: masinter.paSubject: Issue: SETF-FUNCTION-VS-MACRO (version 3)To: X3J13@Sail.stanford.educc: Masinterline-fold: NOreply-to: CL-CLEANUP@Sail.Stanford.EDUThis is a very difficult issue.This writeup was distributed at the November 1987 meeting,and at the October 1988 meeting.There is another writeup, labelled Issue: SETF-PLACES which will follow.The following comments have not been incorporated intothis poposal:Instead of generalizing SYMBOL-FUNCTION, add FDEFINITION and leaveSYMBOL-FUNCTION alone.Do not modify TRACE and UNTRACE. Leave them implementation-dependent.Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon                   (based on discussion among the CLOS working group)               Version 2, 26-Oct-87 Masinter, minor mods               Version 3, 4-Nov-87 Moon, small clarifications at KMP's urgingPROBLEM DESCRIPTION:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSis much simpler in the relevant areas.PROPOSAL (SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The form (setf (-name- ...) ...), when -name- is defined as a function(rather than a macro) and no setf macro has been defined for -name-,expands into a call to a setf function.  The name of this setf functionis a list (setf -name-), where -name- is a symbol.  The body of thisfunction is surrounded by an implicit block named -name-.The functions, macros, special forms, and declarations defined in CLtLand listed in the References section above need to be enhanced to acceptsuch lists in addition to symbols as function names, so that setffunctions can be defined and manipulated.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)          ;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.What CLtL says about (documentation foo 'setf) will not change.Specifically, the setf documentation type applies just to defsetf (anddefine-setf-method, that's an omission in CLtL).  The documentation fora setf function, as for any function, is retrieved by(documentation '(setf foo) 'function).Examples:;If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when rules 1-3 do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))        (temp-vars (do ((a (cdr form) (cdr a))                        (v nil (cons (gensym) v)))                       ((null a) v))))    (values temp-vars (cdr form) (list new-value)            `(funcall #'(setf ,(car form))                      ,new-value ,@temp-vars)            `(,(car form) ,@temp-vars))))RATIONALE:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.  In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a similar feature,in that they allow setting functions named (SETF reader).  We don'tknow of any implementation that has precisely the proposed feature.ADOPTION COST:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.COST OF NON-ADOPTION:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.BENEFITS:Allow CLOS to be defined without out-of-hand complexity. Improve usability of SETF.CONVERSION COST:None, this is an upward-compatible change.As with any language extension, some program-understanding programs mayneed to be enhanced.  A particular issue here is programs that assumethat all function names are symbols.  They may use GET to accessproperties of a function name or use EQ or EQL (perhaps via MEMBER orASSOC) to compare function names for equality.  Such programs will needimprovement before they can understand programs that use the newfeature, but otherwise they will still work.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.DISCUSSION:Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.There was some concern about introducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.However, the CLOS unsuccessfully tried a number of alternatives.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  This proposal is not incompatible with other extensions to functionspecifications present in some implementations. The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.  d)  Introduce a new name for SYMBOL-FUNCTION, since it accepts    non-symbols now. e)  Should one allow these extended function names in the car-position    of an expression to be evaluated? The extra complexity didn't seem    justified, instead, an explicit FUNCALL is required.     ----- End Forwarded Messages -----        TITAN 
         TITAN 
          
TIMESROMAN 
         ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))                                                                  
                                  3      #       
                                                                   
       W                                             0* !z*start*19298 00024 US Date:  9 Dec 88 00:58 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: SETF-PLACES (Version 1)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noThe following is the emmendation of SETF-FUNCTION-VS-MACRO that wasdiscussed at the Fairfax meeting; it incorporates the suggestions  made there by Gregor, Bob Kerns, and myself.  Eric Benson and PatrickDussud here at Lucid have also reviewed it. I've started it out under a different issue name, since it is sucha drastic change; but I wouldn't object at all if someone wants itto be just another version of SETF-FUNCTION-VS-MACRO.-- JonL --Issue: SETF-PLACESReferences: SETF rules for what a place-specifier can be; CLtL pp.94-7            X3J13 88-002R:                Accessing Slots, Ch. 1 p.11               DEFGENERIC  Ch. 2 pp.26-9               DEFMETHOD  Ch. 2 pp.39-41               (SETF DOCUMENTATION)  Ch. 2 pp.43-5               ENSURE-GENERIC-FUNCTION  Ch. 2 pp.46-7               GENERIC-FLET  Ch. 2 p.52               GENERIC-LABELS  Ch. 2 p.55-6               WITH-ADDED-METHODS Ch. 2 pp.90-1Related issues: SETF-FUNCTION-VS-MACROCategory:  ADDITIONEdit history:  Version 1, 11-Nov-88, by JonLProblem description:Common Lisp explicitly refrains from giving names to accessor updatefunctions.  The intent is that the macro SETF should shield the userfrom ever having to know such names; the correlation between an accessorname and its corresponding updator name, or updating code sequence, isto be established by DEFSETF and DEFINE-SETF-METHOD.  Update functionnames like SET and RPLACA are retained primarily for backwardscompatibility.  See CLtL p.93-4.However, this is extremely inconvenient for CLOS programing.  The rub is that the functionality of an updator function must be specifiable "in pieces", by incremental uses of DEFMETHOD distributed throughout perhaps dozens of files.  A single definition using either DEFSETF orDEFINE-SETF-METHOD is not an acceptable constraint for this style.A named, generic function is the CLOS interface for doing distributedcode specification.Furthermore, it is not at all clear where a DEFSETF call for a genericfunction should go.  Should it be before the first DEFMETHOD on the update function?  should it be bundled into every such DEFMETHOD?  should it be bundled into ENSURE-GENERIC-FUNCTION?  Clearly, the first two options would violate the modularity CLOS has strived so hard to achieve; and the third violates the optionality of ENSURE-GENERIC-FUNCTION.The best choice would be to elide the DEFSETF call completely.  Some way is needed to designate an update function, without necessarily doing a DEFSETF or DEFINE-SETF-METHOD first.Additionally the simpler form of DEFSETF, which could be used foralmost all generic needs (e.g., slot updating), requires the new-value argument to be the last argument to the update function.But in order to be able to discriminate upon the class of thenew-value argument, it cannot be described simply as "last" --it must come before any &optional and &key arguments.  Thus thereis need for some other avenue whereby the new-value argument wouldcome, say, first in the argument list of the update function.Finally, the CLOS specification X3J13 88-002R seems to implythat the CLOS exterior syntax for function specifiers must be implemented down in the innards of every conforming Lisp implementation.  There is a very large amount of resistancein the X3J13 group, at present, to any proposal which requiresany non-symbols as ordinary function names; not only do peopleobject to code like (SYMBOL-FUNCTION '(SOME LIST)), but thereis great reluctance to carry out system-wide modifications toall places that deal with function names (most of which nowpresume that "name" means SYMBOL).  Yet is the current opinionof most of the CLOS subcommittee that the exterior CLOS interfacecan be kept intact without requiring the underlying Lisp implementation to support non-symbols as function names.Proposal (SETF-PLACES:ADD-SETF-FUNCTIONS)-- Specify that certain function names are reserved to be "SETF functions",   or "updator functions", for use by SETF expansions.  The very existence    of such an updator function is implicitly similar to having done a    DEFSETF [or rather, a modified form of the simple DEFSETF, as explained    next below].  Every accessor function name is uniquely paired with such    an updator name, regardless of whether the updator name ever has a    functional definition.  However, these functions do not replace any    previously defined SETF methods, nor override the place specifications    of CLtL section 7.2; they simply provide a default expansion for SETF,    as described below.-- Specify that such a a SETF function must take one more argument than    its corresponding access function.  Let <access-fn> and <update-fn>    be such a correlated pair; then when SETF is given a "place" that is    a call on <access-fn>, it expands into a call on <update-fn> that is    given all the arguments to <access-fn> and also, as its very first    argument, the new-value (which must be  returned by <update-fn> as    its value).  For example, suppose that ASET is the updator function   name corresponding to AREF.  Then         (SETF (AREF a i1 i2 ... in) value)   could expand into        (ASET value a i1 i2 ... in)-- Extend the set of valid "place specifiers" as defined on CLtL p.94-7    by adding the following clause after all the existing ones:       For any other place specifier, the form         (SETF (<access-fn> A1 A2 ... AN) NEW-VALUE)       will expand into a call to the uniquely-named updator function       corresponding to <access-fn>, that is to the function named by       (UNDERLYING-NAME '(SETF <access-fn>)).   Note that SETF will no longer signal any "unknown place specifier"    errors during macroexpansion, because the default behavior is to   simply construct a call to the setf function [except, however, when   "access-fn" isn't legal as the name of a function; for example,   (setf ((spaz) i1 i2) value) is still syntaticly illegal].  But if   at run time, the "setf function" still hasn't been defined as a   function [such as by DEFUN, DEFMETHOD, setf of SYMBOL-FUNCTION etc.],   then a run-time "undefined function" error may occur.   Note also that not every SETF method for an accessor function can be   defined using an updator function.  For example, LDB cannot be handled   this way, even if its corresponding update name is a defined function;   LDB must be handled by DEFINE-SETF-METHOD, and as such the prior rules   of CLtL p.94-7 would apply.-- Be reminded that the rules for interpreting SETF place specifiers   are actually embodied in the functions GET-SETF-METHOD and   GET-SETF-METHOD-MULTIPLE-VALUE, rather than in the SETF macro   itself.  Thus these two functions must be altered to reflect the new    "place specifier" called for just above.  Since the rules on p.94-7    of CLtL are to be applied in order, then SETF functions will only be    used when no SETF "method" has been defined for the name, such as by    calling DEFINE-SETF-METHOD or DEFSETF; also, a macro definition for    the access name will block the use of the SETF function, since the    macro call must be expanded first.  Remember also that such a updator    name may have a lexically local definition, as well as (or in addition   to) a global one.-- Add a new function, UNDERLYING-NAME of one argument; and also add an   inverse for this function, UNDERLYING-NAME-TO-SPEC of one argument.   UNDERLYING-NAME is defined as:      (i) on any list like (SETF <name>), it returns a unique,           implementation-dependent name suitable for actual use as           a function name in that implementaion.     (ii) on symbols, it is the identity function; and    (iii) on any other data, it is undefined; however, other lists          like (<spec-kind> ...) should be reserved for extensions          which the x3J13 committee may be considering.   UNDERLYING-NAME-TO-SPEC is defined as:      (i) on any argument which specifically is the output of part (i)          above [i.e., an "underlying" name], it returns (SETF <name>);          thus the argument is the unique name which is EQUAL to          (UNDERLYING-NAME '(SETF <name>)).     (ii) on any symbol or list not covered by part (i) just above, it           returns it's argument.    (iii) on any other data, it is undefined; however, other lists          like (<spec-kind> ...) should be reserved for extensions          which the x3J13 committee may be considering.   The reason EQUAL is the determiner of "uniqueness" above is that it   is EQ for symbols; and for implementations which have "function specs"   it permits non-EQ copies of (SETF <name>) to be used interchangably.   The result of UNDERLYING-NAME should be constant across "incarnations"   of the same release of an implementation, and should be of a data type   that can be printed out and read back in reliably.      Thus in one implementation, which uses only symbols to name functions,   it might be that:      (UNDERLYING-NAME '(SETF FOO)) ==> SETF:4.USER.FOO      (UNDERLYING-NAME-TO-SPEC 'SETF:4.USER.FOO) ==> (SETF FOO)   whereas in another implementation, which has LispMachine style   "function specs", it would be that:      (UNDERLYING-NAME '(SETF FOO)) ==> (SETF FOO)      (UNDERLYING-NAME-TO-SPEC '(SETF FOO)) ==> (SETF FOO)-- Alter all the above-referenced documentation in the CLOS specification   so as not to imply that lists are suitable as function names.  In   particular,     (a) phrases like "... if <function-specifier> names a function" should         be changed to a phrase like "... if <function-specifier> refers to        a defined function", or possibly even something like        "... if (UNDERLYING-NAME <function-specifier>) names a function"    (b) phrases like "(FBOUNDP <function-specifier>)" should be changed        into "(FBOUNDP (UNDERLYING-NAME <function-specifier>))"; or        else other terminology should express the intent of what is to        be said.  For example, instead of saying: "When (FBOUNDP <f-s>)         is  true ..." one could just as well say  "When <f-s> refers to         a defined function ..."  The choice of which of these two formats         to use is an editorial one.    (c) phrases like "(SYMBOL-FUNCTION function-specifier)" should be changed        into "(SYMBOL-FUNCTION (UNDERLYING-NAME <function-specifier>))";        or else other terminology should express the intent of what is to        be said.  For example, one might say "... the function referred         to by <f-s>".  The choice of which of these two formats to use is        an editorial one.Since the concept of a standard expansion for DEFMETHOD has beenaccepted, then it is clear that a form like     (DEFMETHOD (SETF FOO) ...)will expand exactly the same as    (DEFMETHOD #.(UNDERLYING-NAME '(SETF FOO)) ...)The underlying call to ADD-METHOD will see the real function name usedfor the updator function.  The user-level interface of CLOS can stillpresent the list format as acceptable; it is only the implementation ofDEFMETHOD, DEFGENERIC, that will have to worry about converting to a"real" name.One expected use of UNDERLYING-NAME-TO-SPEC is in Lisp-level debuggers,which could try to print out something more user-comprehensible thanthe very internal names that an implementation might use in place offunction specs.Examples:;;; If CLtL did not already prescribe a SETF expansion for SUBSEQ calls,;;;  it could be defined like this:  (setf (symbol-function (underlying-name '(setf subseq)))	#'(lambda (new-value sequence start &optional end)	    (unless end (setq end (length sequence)))	    (setq end (min end (+ start (length new-value))))	    (do ((i start (1+ i))		 (j 0 (1+ j)))		((= i end) new-value)	      (setf (elt sequence i) (elt new-value i)))))or, for implementations that have "function specs", this could be writen:  (defun (setf subseq) (new-value sequence start &optional end)    . . .);;; Here's an example using a local function.  First, define ;;;  MIDDLE-REF to be an accessor function as follows.  [Assume ;;;  also that MIDDLE-REF's home package is BAR.]    (defun middle-ref (vec i)       (check-type i fixnum)      (aref vec (ceiling i 2)));;; Now let SETF:3.BAR.MIDDLE-REF be the (implementation-dependent) ;;;  updator function name corresponding to MIDDLE-REF; a normal ;;;  definition of an update function for MIDDLE-REF could be:    (defun setf:3.bar.middle-ref (new-element vec i)       (check-type i fixnum)      (setf (aref vec (ceiling i 2)) new-element));;; But the SETF below will call FILL, because of the local definition ;;;  of SETF:3.BAR.MIDDLE-REF;  and nowhere have we have made any;;;   explicit call to DEFSETF or DEFINE-SETF-METHOD for MIDDLE-REF.    (flet ((setf:3.bar.middle-ref (new-element vec i)              ;;"wide-body" version of set-middle-ref             (declare (ignore i))             (fill vec new-element :end (ceiling i 2))))      (setf (middle-ref "abc" 1) #\z));;; The following function could be called by GET-SETF-METHOD, to ;;;  implement SETF functions, when none of the other rules of CLtL;;;  p.94-7 apply.  (defun get-setf-method-for-setf-functions (form)    (let* ((new-value (gensym))	   (temp-vars (do ((a (cdr form) (cdr a))			   (v nil (cons (gensym) v)))			  ((null a) v)))	  ((access-fn (car form)))	  ((update-fn (underlying-name `(SETF ,access-fn)))))      (values temp-vars 	      (cdr form) 	      (list new-value)	      `(,update-fn  ,new-value  ,@temp-vars)	      `(,access-fn ,@temp-vars))));;; For those implementations using "function specs", the form:;;;   `(,update-fn  ,new-value  ,@temp-vars);;;  would probably have to  be replaced by:;;;   `(FUNCALL #',update-fn  ,new-value  ,@temp-vars)Rationale:The paragraphs of the "Problem description:", except for the first,describe four major problems with the status quo -- three concerningthe unsuitability of current SETF methods for supporting the CLOSgeneric style, and one for an unintended presumption that everyimplementation of CL will have "function specs".  This proposalcorrects these problems, without adding any significant new ones.Current practice:Some implementations have "function specs", so that forms like (SETF FOO) are permitted to name functions;  but none have extended the setf place specifiers as proposed herein.Cost to Implementors:Basically, none.  Implementations which already have Lisp Machine style "function specs" can just define UNDERLYING-NAME andUNDERLYING-NAME-TO-SPEC as the identity function.  For those withoutsuch capabilities, there is a portable implementation listed in the discussion section.Extending GET-SETF-METHOD etc. to handle SETF functions should be avery modest task at most.Cost to Users:This is basically an upward-compatible addition, so there should beno cost to users [at least not for correct programs -- incorrectSETF expansions will no longer be signalled at macroexpand time,but may simply result in a runtime error for undefined function.]Cost of non-adoption:Non-adoption of this proposal would be a significant setback for the Common Lisp Object System.  There seems to be no agreeable alternativefor implementing generic setf methods.Performance impact:N.A.Benefits:See "Cost of non-adoption".Esthetics:This proposal increases the size of the definition of SETF; butit greatly simplifies the "default" case, namely just definingan updator function to correspond to an accessor.Discussion:The following code can be used by an implementation which doesn'thave "function specs" to implement the new functions:  ;;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: SYSTEM; Base: 10 -*-  ;;;  ;;; Author: JonL White, 15-Nov-88  ;;;  (in-package "SYSTEM")			;or, your development package  (eval-when (eval compile load)  ;;; The SETF package should be reserved for this purpose  ;;;  (or (find-package "SETF")       (make-package "SETF" :use nil))  (defparameter *setf-package* (find-package "SETF"))  (unless (and (null (package-use-list *setf-package*))	       (null (package-used-by-list *setf-package*)))    (error "SETF package has connections?"))  ;;; "Internal Markers", to be used for uninterned symbols.  ;;;  (export (intern "SETF-SPEC" *setf-package*) *setf-package*)  (export (intern "SETF-NAME" *setf-package*) *setf-package*)  )  (eval-when (eval compile)  (defmacro setf-spec-p (x)    (let ((spec (gensym)))      `(LET ((,spec ,x))	 (AND (CONSP ,spec) 	      (EQ (CAR ,spec) 'SETF)	      (CONSP (CDR ,spec))	      (NULL (CDDR ,spec))	      (SYMBOLP (SECOND ,spec))))))  )  (defun UNDERLYING-NAME (spec)    (cond       ((symbolp spec)        spec)      ((setf-spec-p spec)       (let* ((accessor (second spec))	      (accessor-name (symbol-name accessor))	      (home-package (symbol-package accessor)))	 (if home-package	     (let* ((package-name (package-name home-package))		    ;; 'spec-name' is a form like "~D.~A.~A", but FORMAT has a		    ;; problem with global print parameters like *print-radix*		    (spec-name (concatenate 'string				 (write-to-string (length package-name)				   :radix nil :base 10 :length nil :level nil)				 "."				 package-name				 "."				 accessor-name))		    (updator (or (find-symbol spec-name *setf-package*)				 (let ((sym (intern spec-name *setf-package*)))				   (export sym *setf-package*)				   sym))))	       ;; A possible optimization, which trades off space for time, is	       ;;  as follows; see definition of UNDERLYING-NAME-TO-SPEC below	       ;;(setf (get updator 'setf:setf-spec) (copy-list spec))	       updator)	     (or (get accessor 'setf:setf-name)		 (let* ((uname (concatenate 'string "SET-" accessor-name))			(updator (make-symbol uname)))		   (setf (get accessor 'setf:setf-name) updator)		   (setf (get updator 'setf:setf-spec) (copy-list spec))		   updator)))))	  (t 	   (error "~S is an invalid arg for ~S" spec 'UNDERLYING-NAME))))  (defun UNDERLYING-NAME-TO-SPEC (x)    (cond      ((not (symbolp x))       (if (setf-spec-p x)	   x	   (error "~S is an invalid arg for ~S" 		  x 'UNDERLYING-NAME-TO-SPEC)))      ((get x 'setf:setf-spec))      (t        (let ((home-package (symbol-package x)))	  (if (not (eq home-package *setf-package*))	      x	      (let ((name (symbol-name x))		    accessor package-name)		;; Unpack the name, which is a form like "~D.~A.~A"		(multiple-value-bind (nchars starti)				(parse-integer name :radix 10 :junk-allowed t)		  (incf starti)		  (setq package-name (subseq name starti (incf starti nchars)))		  (incf starti)		  (setq accessor (find-symbol (subseq name starti) 					      (find-package package-name)))		  (unless accessor		    (error "~S failed to parse in ~S" 			   x 'UNDERLYING-NAME-TO-SPEC))		  `(SETF ,accessor))))))))     ----- End Forwarded Messages -----*start*12678 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 01:09:26 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  00:57:39 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 00:56:50 PSTDate: 9 Dec 88 00:56 PSTFrom: masinter.paSubject: Issue: SETF-FUNCTION-VS-MACRO (version 3)To: X3J13@Sail.stanford.educc: Masinter.paline-fold: NOreply-to: CL-CLEANUP@Sail.Stanford.EDUMessage-ID: <881209-005650-5575@Xerox>This is a very difficult issue.This writeup was distributed at the November 1987 meeting,and at the October 1988 meeting.There is another writeup, labelled Issue: SETF-PLACES which will follow.The following comments have not been incorporated intothis poposal:Instead of generalizing SYMBOL-FUNCTION, add FDEFINITION and leaveSYMBOL-FUNCTION alone.Do not modify TRACE and UNTRACE. Leave them implementation-dependent.!Issue:         SETF-FUNCTION-VS-MACROReferences:    SETF rules for what -place- can be (pp.94-7)               COMPILE function (p.438)               DEFUN macro (p.57)               DISASSEMBLE function (p.439)               DOCUMENTATION function (p.440)               FBOUNDP function (p.90)               FLET special form (p.113)               FMAKUNBOUND function (p.92)               FTYPE declaration (p.158)               FUNCTION special form (p.87)               FUNCTION declaration (p.159)               INLINE declaration (p.159)               NOTINLINE declaration (p.159)               LABELS special form (p.113)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               TRACE macro (p.440)               UNTRACE macro (p.440)Category:      ADDITIONEdit history:  Version 1, 13-Oct-87 Moon                   (based on discussion among the CLOS working group)               Version 2, 26-Oct-87 Masinter, minor mods               Version 3, 4-Nov-87 Moon, small clarifications at KMP's urgingPROBLEM DESCRIPTION:The Common Lisp Object System needs a well-defined way to relate thename and arguments of a setting function to those of a reading function,because both functions can be generic and can have user-defined methods.We tried to hide the name and arguments of the setting function withmacrology, but the complexity got out of hand.  It seems better to makethis information explicit; the version of the CLOS specification thatassumes the adoption of proposal SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONSis much simpler in the relevant areas.PROPOSAL (SETF-FUNCTION-VS-MACRO:SETF-FUNCTIONS): Add to Common Lisp the concept of "setf functions".  Right now, CommonLisp only has "setf macros", which are defined by define-setf-method andboth forms of defsetf.  Terminology:  - a "setf macro" is something that produces code (or other    specifications, as in define-setf-method) which, when evaluated,    will perform the effect of an invocation of setf.  - a "setf function" is something that is called to perform    directly the effect of an invocation of setf.The form (setf (-name- ...) ...), when -name- is defined as a function(rather than a macro) and no setf macro has been defined for -name-,expands into a call to a setf function.  The name of this setf functionis a list (setf -name-), where -name- is a symbol.  The body of thisfunction is surrounded by an implicit block named -name-.The functions, macros, special forms, and declarations defined in CLtLand listed in the References section above need to be enhanced to acceptsuch lists in addition to symbols as function names, so that setffunctions can be defined and manipulated.A setf function receives the new value to be stored as its firstargument.  Thus, #'(setf foo) should have one more required parameterthan #'foo, the first required parameter is the new value to be stored,and the remaining parameters should be the same as #'foo's parameters.A setf function must return its first argument, since setf is definedto return the new value.A definition of a setf function can be lexically local, like adefinition of a reading function.  The following rules specify thebehavior of SETF; note that these rules are ordered and the first ruleto apply supersedes any later rules.  These rules are a consistentextension of the current behavior of Common Lisp and the Cleanupcommittee's resolution of issue GET-SETF-METHOD-ENVIRONMENT.  Onlyrule 4 is new with this proposal.Rules for the macroexpansion of (setf (foo x) y):(1) If the function-name foo refers to the global function definition,rather than a locally defined function or macro, and if there is asetf macro defined for foo, use the setf macro to compute the expansion.(2) If the function-name foo is defined as a macro in the current scope,use macroexpand-1 to expand (foo x) and try again.(3) If the function-name foo is defined as a special form in the currentscope, signal an error.(4) Expand into the equivalent of    (let ((#:temp-1 x)          ;force correct order of evaluation          (#:temp-2 y))      (funcall #'(setf foo) #:temp-2 #:temp-1))Note that rule 4 is independent of the scope of the function name(setf foo).  It does not matter if that scope is different from thescope of the function name foo.  This allows some nonsensical programsto be written, but does not seem harmful enough to justify making morecomplicated rules to compare the scopes of the two function definitions.The above rules are actually implemented by GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE, rather than by the SETF macro itself.Thus GET-SETF-METHOD generates the appropriate five values for a formthat is not a macro-invocation and does not have a defined setf macro.Normally one does not define both a setf function and a setf macrofor the same reading function.Normally one defines a local reading function and a local setf functiontogether in a single FLET or LABELS.In the absence of any setf macro definition, SETF of a function expandsinto a call to the setf function.  This means that the setf functiononly needs to be defined at run time, not compile time.What CLtL says about (documentation foo 'setf) will not change.Specifically, the setf documentation type applies just to defsetf (anddefine-setf-method, that's an omission in CLtL).  The documentation fora setf function, as for any function, is retrieved by(documentation '(setf foo) 'function).Examples:;If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when rules 1-3 do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))        (temp-vars (do ((a (cdr form) (cdr a))                        (v nil (cons (gensym) v)))                       ((null a) v))))    (values temp-vars (cdr form) (list new-value)            `(funcall #'(setf ,(car form))                      ,new-value ,@temp-vars)            `(,(car form) ,@temp-vars))))RATIONALE:By making the names and arguments of setting functions explicit, CLOS isconsiderably simplified.  In addition, this can supersede any proposalsto introduce a lexically local form of defsetf; lexically local setffunctions serve the same needs.Current code that resembles (defsetf foo |setf FOO|) (defun foo (x) ..) (defun |setf FOO| (x new) ..)or (defsetf foo internal-foo-setter) (defun foo (x) ..) (defun internal-foo-setter (x new) ..)can be, but is not required to be, replaced with the following code (defun foo (x) ..) (defun (setf foo) (new x) ..)An advantage of this is that several disparate styles of usingDEFSETF can be replaced with a single common style of usingsetf functions, making programs more standardized and readable.CURRENT PRACTICE:A few Common Lisp implementations already have a similar feature,in that they allow setting functions named (SETF reader).  We don'tknow of any implementation that has precisely the proposed feature.ADOPTION COST:The main cost is generalization of a few functions to accept listsbeginning with SETF where they now accept only symbols.  Implementationsmust add a data structure to store the function definition of a setffunction, however, this can trivially be done with property lists orgenerated symbols.The cost of making the SETF macro expand into a call to a setf function,when it does not find a setf macro or a regular macro to expand, isnegligible.This will be an incompatible change for Symbolics, since it already hassetf functions but they do not take the same arguments as proposed here.However, the change is considered worthwhile.COST OF NON-ADOPTION:Non-adoption of this proposal would be a significant roadblock to theCommon Lisp Object System.  Some major rethinking of CLOS would berequired.BENEFITS:Allow CLOS to be defined without out-of-hand complexity. Improve usability of SETF.CONVERSION COST:None, this is an upward-compatible change.As with any language extension, some program-understanding programs mayneed to be enhanced.  A particular issue here is programs that assumethat all function names are symbols.  They may use GET to accessproperties of a function name or use EQ or EQL (perhaps via MEMBER orASSOC) to compare function names for equality.  Such programs will needimprovement before they can understand programs that use the newfeature, but otherwise they will still work.ESTHETICS:SETF would be more esthetic, but less powerful, if it had only theproposed setf functions and did not have setf macros.  Such a majorincompatible change is of course out of the question; however, if setffunctions are stressed over setf macros, SETF will be much easier toteach.DISCUSSION:Note that in Common Lisp, setf macro expansion is an operation onfunction names, not on functions.  It differs from some dialects ofScheme, such as T, in this respect.  This proposal does not attempt tochange that.There was some concern about introducing the notion that the name of thesetf-function associated with FOO should be a list, (SETF FOO).  This isa considerable extension to the idea of a "function name", at least forstandard Common Lisp implementations that do not implement Lisp machinestyle function-specs.However, the CLOS unsuccessfully tried a number of alternatives.Fundamentally the problem is that there has to be a name that the useruses to define the thing and to talk about it.  Trying to hide the namejust means you use a more obscure name, like an alternate syntax forDEFUN or DEFUN-SETF. Another reason for making the name explicit is toallow one to use FLET for the setf function -- something which would bedifficult if there is not a name-like entity that can be bound.  This proposal is not incompatible with other extensions to functionspecifications present in some implementations. The following related features were considered but are specificallynot being proposed at this time, since they are unnecessary for CLOSand appear not to improve the simplicity and esthetics of the language:a) Lexically local setf macros, that is, a cross between DEFSETF and   MACROLET.  This does not appear to be logically necessary.  Would all   three ways of defining lexically global setf macros need local   counterparts?  b) Define the meaning of defmacro or macrolet of (setf foo)?   This would be a fourth way to define a setf macro.  c)  Enhance the definition of global setf macros, for example to    say that (MACRO-FUNCTION '(SETF FOO)) returns an expander function     that takes two arguments and returns five values.  d)  Introduce a new name for SYMBOL-FUNCTION, since it accepts    non-symbols now. e)  Should one allow these extended function names in the car-position    of an expression to be evaluated? The extra complexity didn't seem    justified, instead, an explicit FUNCALL is required.     ----- End Forwarded Messages -----*start*19622 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 01:14:16 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  00:59:36 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 00:58:47 PSTDate: 9 Dec 88 00:58 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: SETF-PLACES (Version 1)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881209-005847-5576@Xerox>The following is the emmendation of SETF-FUNCTION-VS-MACRO that wasdiscussed at the Fairfax meeting; it incorporates the suggestions  made there by Gregor, Bob Kerns, and myself.  Eric Benson and PatrickDussud here at Lucid have also reviewed it. I've started it out under a different issue name, since it is sucha drastic change; but I wouldn't object at all if someone wants itto be just another version of SETF-FUNCTION-VS-MACRO.-- JonL --!Issue: SETF-PLACESReferences: SETF rules for what a place-specifier can be; CLtL pp.94-7            X3J13 88-002R:                Accessing Slots, Ch. 1 p.11               DEFGENERIC  Ch. 2 pp.26-9               DEFMETHOD  Ch. 2 pp.39-41               (SETF DOCUMENTATION)  Ch. 2 pp.43-5               ENSURE-GENERIC-FUNCTION  Ch. 2 pp.46-7               GENERIC-FLET  Ch. 2 p.52               GENERIC-LABELS  Ch. 2 p.55-6               WITH-ADDED-METHODS Ch. 2 pp.90-1Related issues: SETF-FUNCTION-VS-MACROCategory:  ADDITIONEdit history:  Version 1, 11-Nov-88, by JonLProblem description:Common Lisp explicitly refrains from giving names to accessor updatefunctions.  The intent is that the macro SETF should shield the userfrom ever having to know such names; the correlation between an accessorname and its corresponding updator name, or updating code sequence, isto be established by DEFSETF and DEFINE-SETF-METHOD.  Update functionnames like SET and RPLACA are retained primarily for backwardscompatibility.  See CLtL p.93-4.However, this is extremely inconvenient for CLOS programing.  The rub is that the functionality of an updator function must be specifiable "in pieces", by incremental uses of DEFMETHOD distributed throughout perhaps dozens of files.  A single definition using either DEFSETF orDEFINE-SETF-METHOD is not an acceptable constraint for this style.A named, generic function is the CLOS interface for doing distributedcode specification.Furthermore, it is not at all clear where a DEFSETF call for a genericfunction should go.  Should it be before the first DEFMETHOD on the update function?  should it be bundled into every such DEFMETHOD?  should it be bundled into ENSURE-GENERIC-FUNCTION?  Clearly, the first two options would violate the modularity CLOS has strived so hard to achieve; and the third violates the optionality of ENSURE-GENERIC-FUNCTION.The best choice would be to elide the DEFSETF call completely.  Some way is needed to designate an update function, without necessarily doing a DEFSETF or DEFINE-SETF-METHOD first.Additionally the simpler form of DEFSETF, which could be used foralmost all generic needs (e.g., slot updating), requires the new-value argument to be the last argument to the update function.But in order to be able to discriminate upon the class of thenew-value argument, it cannot be described simply as "last" --it must come before any &optional and &key arguments.  Thus thereis need for some other avenue whereby the new-value argument wouldcome, say, first in the argument list of the update function.Finally, the CLOS specification X3J13 88-002R seems to implythat the CLOS exterior syntax for function specifiers must be implemented down in the innards of every conforming Lisp implementation.  There is a very large amount of resistancein the X3J13 group, at present, to any proposal which requiresany non-symbols as ordinary function names; not only do peopleobject to code like (SYMBOL-FUNCTION '(SOME LIST)), but thereis great reluctance to carry out system-wide modifications toall places that deal with function names (most of which nowpresume that "name" means SYMBOL).  Yet is the current opinionof most of the CLOS subcommittee that the exterior CLOS interfacecan be kept intact without requiring the underlying Lisp implementation to support non-symbols as function names.Proposal (SETF-PLACES:ADD-SETF-FUNCTIONS)-- Specify that certain function names are reserved to be "SETF functions",   or "updator functions", for use by SETF expansions.  The very existence    of such an updator function is implicitly similar to having done a    DEFSETF [or rather, a modified form of the simple DEFSETF, as explained    next below].  Every accessor function name is uniquely paired with such    an updator name, regardless of whether the updator name ever has a    functional definition.  However, these functions do not replace any    previously defined SETF methods, nor override the place specifications    of CLtL section 7.2; they simply provide a default expansion for SETF,    as described below.-- Specify that such a a SETF function must take one more argument than    its corresponding access function.  Let <access-fn> and <update-fn>    be such a correlated pair; then when SETF is given a "place" that is    a call on <access-fn>, it expands into a call on <update-fn> that is    given all the arguments to <access-fn> and also, as its very first    argument, the new-value (which must be  returned by <update-fn> as    its value).  For example, suppose that ASET is the updator function   name corresponding to AREF.  Then         (SETF (AREF a i1 i2 ... in) value)   could expand into        (ASET value a i1 i2 ... in)-- Extend the set of valid "place specifiers" as defined on CLtL p.94-7    by adding the following clause after all the existing ones:       For any other place specifier, the form         (SETF (<access-fn> A1 A2 ... AN) NEW-VALUE)       will expand into a call to the uniquely-named updator function       corresponding to <access-fn>, that is to the function named by       (UNDERLYING-NAME '(SETF <access-fn>)).   Note that SETF will no longer signal any "unknown place specifier"    errors during macroexpansion, because the default behavior is to   simply construct a call to the setf function [except, however, when   "access-fn" isn't legal as the name of a function; for example,   (setf ((spaz) i1 i2) value) is still syntaticly illegal].  But if   at run time, the "setf function" still hasn't been defined as a   function [such as by DEFUN, DEFMETHOD, setf of SYMBOL-FUNCTION etc.],   then a run-time "undefined function" error may occur.   Note also that not every SETF method for an accessor function can be   defined using an updator function.  For example, LDB cannot be handled   this way, even if its corresponding update name is a defined function;   LDB must be handled by DEFINE-SETF-METHOD, and as such the prior rules   of CLtL p.94-7 would apply.-- Be reminded that the rules for interpreting SETF place specifiers   are actually embodied in the functions GET-SETF-METHOD and   GET-SETF-METHOD-MULTIPLE-VALUE, rather than in the SETF macro   itself.  Thus these two functions must be altered to reflect the new    "place specifier" called for just above.  Since the rules on p.94-7    of CLtL are to be applied in order, then SETF functions will only be    used when no SETF "method" has been defined for the name, such as by    calling DEFINE-SETF-METHOD or DEFSETF; also, a macro definition for    the access name will block the use of the SETF function, since the    macro call must be expanded first.  Remember also that such a updator    name may have a lexically local definition, as well as (or in addition   to) a global one.-- Add a new function, UNDERLYING-NAME of one argument; and also add an   inverse for this function, UNDERLYING-NAME-TO-SPEC of one argument.   UNDERLYING-NAME is defined as:      (i) on any list like (SETF <name>), it returns a unique,           implementation-dependent name suitable for actual use as           a function name in that implementaion.     (ii) on symbols, it is the identity function; and    (iii) on any other data, it is undefined; however, other lists          like (<spec-kind> ...) should be reserved for extensions          which the x3J13 committee may be considering.   UNDERLYING-NAME-TO-SPEC is defined as:      (i) on any argument which specifically is the output of part (i)          above [i.e., an "underlying" name], it returns (SETF <name>);          thus the argument is the unique name which is EQUAL to          (UNDERLYING-NAME '(SETF <name>)).     (ii) on any symbol or list not covered by part (i) just above, it           returns it's argument.    (iii) on any other data, it is undefined; however, other lists          like (<spec-kind> ...) should be reserved for extensions          which the x3J13 committee may be considering.   The reason EQUAL is the determiner of "uniqueness" above is that it   is EQ for symbols; and for implementations which have "function specs"   it permits non-EQ copies of (SETF <name>) to be used interchangably.   The result of UNDERLYING-NAME should be constant across "incarnations"   of the same release of an implementation, and should be of a data type   that can be printed out and read back in reliably.      Thus in one implementation, which uses only symbols to name functions,   it might be that:      (UNDERLYING-NAME '(SETF FOO)) ==> SETF:4.USER.FOO      (UNDERLYING-NAME-TO-SPEC 'SETF:4.USER.FOO) ==> (SETF FOO)   whereas in another implementation, which has LispMachine style   "function specs", it would be that:      (UNDERLYING-NAME '(SETF FOO)) ==> (SETF FOO)      (UNDERLYING-NAME-TO-SPEC '(SETF FOO)) ==> (SETF FOO)-- Alter all the above-referenced documentation in the CLOS specification   so as not to imply that lists are suitable as function names.  In   particular,     (a) phrases like "... if <function-specifier> names a function" should         be changed to a phrase like "... if <function-specifier> refers to        a defined function", or possibly even something like        "... if (UNDERLYING-NAME <function-specifier>) names a function"    (b) phrases like "(FBOUNDP <function-specifier>)" should be changed        into "(FBOUNDP (UNDERLYING-NAME <function-specifier>))"; or        else other terminology should express the intent of what is to        be said.  For example, instead of saying: "When (FBOUNDP <f-s>)         is  true ..." one could just as well say  "When <f-s> refers to         a defined function ..."  The choice of which of these two formats         to use is an editorial one.    (c) phrases like "(SYMBOL-FUNCTION function-specifier)" should be changed        into "(SYMBOL-FUNCTION (UNDERLYING-NAME <function-specifier>))";        or else other terminology should express the intent of what is to        be said.  For example, one might say "... the function referred         to by <f-s>".  The choice of which of these two formats to use is        an editorial one.Since the concept of a standard expansion for DEFMETHOD has beenaccepted, then it is clear that a form like     (DEFMETHOD (SETF FOO) ...)will expand exactly the same as    (DEFMETHOD #.(UNDERLYING-NAME '(SETF FOO)) ...)The underlying call to ADD-METHOD will see the real function name usedfor the updator function.  The user-level interface of CLOS can stillpresent the list format as acceptable; it is only the implementation ofDEFMETHOD, DEFGENERIC, that will have to worry about converting to a"real" name.One expected use of UNDERLYING-NAME-TO-SPEC is in Lisp-level debuggers,which could try to print out something more user-comprehensible thanthe very internal names that an implementation might use in place offunction specs.Examples:;;; If CLtL did not already prescribe a SETF expansion for SUBSEQ calls,;;;  it could be defined like this:  (setf (symbol-function (underlying-name '(setf subseq)))	#'(lambda (new-value sequence start &optional end)	    (unless end (setq end (length sequence)))	    (setq end (min end (+ start (length new-value))))	    (do ((i start (1+ i))		 (j 0 (1+ j)))		((= i end) new-value)	      (setf (elt sequence i) (elt new-value i)))))or, for implementations that have "function specs", this could be writen:  (defun (setf subseq) (new-value sequence start &optional end)    . . .);;; Here's an example using a local function.  First, define ;;;  MIDDLE-REF to be an accessor function as follows.  [Assume ;;;  also that MIDDLE-REF's home package is BAR.]    (defun middle-ref (vec i)       (check-type i fixnum)      (aref vec (ceiling i 2)));;; Now let SETF:3.BAR.MIDDLE-REF be the (implementation-dependent) ;;;  updator function name corresponding to MIDDLE-REF; a normal ;;;  definition of an update function for MIDDLE-REF could be:    (defun setf:3.bar.middle-ref (new-element vec i)       (check-type i fixnum)      (setf (aref vec (ceiling i 2)) new-element));;; But the SETF below will call FILL, because of the local definition ;;;  of SETF:3.BAR.MIDDLE-REF;  and nowhere have we have made any;;;   explicit call to DEFSETF or DEFINE-SETF-METHOD for MIDDLE-REF.    (flet ((setf:3.bar.middle-ref (new-element vec i)              ;;"wide-body" version of set-middle-ref             (declare (ignore i))             (fill vec new-element :end (ceiling i 2))))      (setf (middle-ref "abc" 1) #\z));;; The following function could be called by GET-SETF-METHOD, to ;;;  implement SETF functions, when none of the other rules of CLtL;;;  p.94-7 apply.  (defun get-setf-method-for-setf-functions (form)    (let* ((new-value (gensym))	   (temp-vars (do ((a (cdr form) (cdr a))			   (v nil (cons (gensym) v)))			  ((null a) v)))	  ((access-fn (car form)))	  ((update-fn (underlying-name `(SETF ,access-fn)))))      (values temp-vars 	      (cdr form) 	      (list new-value)	      `(,update-fn  ,new-value  ,@temp-vars)	      `(,access-fn ,@temp-vars))));;; For those implementations using "function specs", the form:;;;   `(,update-fn  ,new-value  ,@temp-vars);;;  would probably have to  be replaced by:;;;   `(FUNCALL #',update-fn  ,new-value  ,@temp-vars)Rationale:The paragraphs of the "Problem description:", except for the first,describe four major problems with the status quo -- three concerningthe unsuitability of current SETF methods for supporting the CLOSgeneric style, and one for an unintended presumption that everyimplementation of CL will have "function specs".  This proposalcorrects these problems, without adding any significant new ones.Current practice:Some implementations have "function specs", so that forms like (SETF FOO) are permitted to name functions;  but none have extended the setf place specifiers as proposed herein.Cost to Implementors:Basically, none.  Implementations which already have Lisp Machine style "function specs" can just define UNDERLYING-NAME andUNDERLYING-NAME-TO-SPEC as the identity function.  For those withoutsuch capabilities, there is a portable implementation listed in the discussion section.Extending GET-SETF-METHOD etc. to handle SETF functions should be avery modest task at most.Cost to Users:This is basically an upward-compatible addition, so there should beno cost to users [at least not for correct programs -- incorrectSETF expansions will no longer be signalled at macroexpand time,but may simply result in a runtime error for undefined function.]Cost of non-adoption:Non-adoption of this proposal would be a significant setback for the Common Lisp Object System.  There seems to be no agreeable alternativefor implementing generic setf methods.Performance impact:N.A.Benefits:See "Cost of non-adoption".Esthetics:This proposal increases the size of the definition of SETF; butit greatly simplifies the "default" case, namely just definingan updator function to correspond to an accessor.Discussion:The following code can be used by an implementation which doesn'thave "function specs" to implement the new functions:  ;;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: SYSTEM; Base: 10 -*-  ;;;  ;;; Author: JonL White, 15-Nov-88  ;;;  (in-package "SYSTEM")			;or, your development package  (eval-when (eval compile load)  ;;; The SETF package should be reserved for this purpose  ;;;  (or (find-package "SETF")       (make-package "SETF" :use nil))  (defparameter *setf-package* (find-package "SETF"))  (unless (and (null (package-use-list *setf-package*))	       (null (package-used-by-list *setf-package*)))    (error "SETF package has connections?"))  ;;; "Internal Markers", to be used for uninterned symbols.  ;;;  (export (intern "SETF-SPEC" *setf-package*) *setf-package*)  (export (intern "SETF-NAME" *setf-package*) *setf-package*)  )  (eval-when (eval compile)  (defmacro setf-spec-p (x)    (let ((spec (gensym)))      `(LET ((,spec ,x))	 (AND (CONSP ,spec) 	      (EQ (CAR ,spec) 'SETF)	      (CONSP (CDR ,spec))	      (NULL (CDDR ,spec))	      (SYMBOLP (SECOND ,spec))))))  )  (defun UNDERLYING-NAME (spec)    (cond       ((symbolp spec)        spec)      ((setf-spec-p spec)       (let* ((accessor (second spec))	      (accessor-name (symbol-name accessor))	      (home-package (symbol-package accessor)))	 (if home-package	     (let* ((package-name (package-name home-package))		    ;; 'spec-name' is a form like "~D.~A.~A", but FORMAT has a		    ;; problem with global print parameters like *print-radix*		    (spec-name (concatenate 'string				 (write-to-string (length package-name)				   :radix nil :base 10 :length nil :level nil)				 "."				 package-name				 "."				 accessor-name))		    (updator (or (find-symbol spec-name *setf-package*)				 (let ((sym (intern spec-name *setf-package*)))				   (export sym *setf-package*)				   sym))))	       ;; A possible optimization, which trades off space for time, is	       ;;  as follows; see definition of UNDERLYING-NAME-TO-SPEC below	       ;;(setf (get updator 'setf:setf-spec) (copy-list spec))	       updator)	     (or (get accessor 'setf:setf-name)		 (let* ((uname (concatenate 'string "SET-" accessor-name))			(updator (make-symbol uname)))		   (setf (get accessor 'setf:setf-name) updator)		   (setf (get updator 'setf:setf-spec) (copy-list spec))		   updator)))))	  (t 	   (error "~S is an invalid arg for ~S" spec 'UNDERLYING-NAME))))  (defun UNDERLYING-NAME-TO-SPEC (x)    (cond      ((not (symbolp x))       (if (setf-spec-p x)	   x	   (error "~S is an invalid arg for ~S" 		  x 'UNDERLYING-NAME-TO-SPEC)))      ((get x 'setf:setf-spec))      (t        (let ((home-package (symbol-package x)))	  (if (not (eq home-package *setf-package*))	      x	      (let ((name (symbol-name x))		    accessor package-name)		;; Unpack the name, which is a form like "~D.~A.~A"		(multiple-value-bind (nchars starti)				(parse-integer name :radix 10 :junk-allowed t)		  (incf starti)		  (setq package-name (subseq name starti (incf starti nchars)))		  (incf starti)		  (setq accessor (find-symbol (subseq name starti) 					      (find-package package-name)))		  (unless accessor		    (error "~S failed to parse in ~S" 			   x 'UNDERLYING-NAME-TO-SPEC))		  `(SETF ,accessor))))))))     ----- End Forwarded Messages -----*start*01108 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 01:27:45 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  01:19:24 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 01:13:30 PSTDate: 9 Dec 88 01:13 PSTFrom: masinter.paSubject: Re: Issue: SETF-FUNCTION-VS-MACRO (version 3)In-reply-to: masinter.pa's message of 9 Dec 88 00:56 PSTTo: x3J13@Sail.Stanford.EDUMessage-ID: <881209-011330-5598@Xerox>At the last meeting, our notes are that an amendment was offered and accepted:"   Remove SYMBOL-FUNCTION, TRACE and UNTRACE from the list of affected   functions.   Add a new function:   FDEFINITION <spec>					[Function]   The current global function definition named by <spec> is returned.   It is an error if the <spec> has no function definition.   <spec> must be either a symbol or a list of the form (SETF <symbol>).   FDEFINITION may be used with SETF to alter the global function   definition."This amendment was not been incorporated into Version 3.*start*01767 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 08:21:07 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 9 Dec 88  08:20:01 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.1-cs)	id AA15143; Fri, 9 Dec 88 09:18:59 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA01151; Fri, 9 Dec 88 09:18:57 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8812091618.AA01151@defun.utah.edu>Date: Fri, 9 Dec 88 09:18:56 MSTSubject: Re: Issue: SETF-PLACES (Version 1)To: cl-cleanup@sail.stanford.eduIn-Reply-To: cl-cleanup@sail.stanford.edu, 9 Dec 88 00:58 PSTOn the whole, I like this approach a lot more than the function specapproach in issue SETF-FUNCTION-VERSUS-MACRO.I am a little uncomfortable with removing the ability of the compilerto complain about undefined places in SETF calls, but can live withthat if it's necessary for CLOS.The names UNDERLYING-NAME and UNDERLYING-NAME-TO-SPEC don't seem verygood to me; they don't really convey what the functions do.  Althoughit would cause a slight amount of extra work for CLOS, I would ratherbanish the idea of function specs entirely from the non-CLOS part ofthe language and see functions like    (SETF-FUNCTION <setf-place-symbol>)and its inverse    (SETF-PLACE <setf-function>)For example, an implementation that doesn't support function specs mightdo this as:    (SETF-FUNCTION 'FOO) ==> SETF:4.USER.FOO    (SETF-PLACE 'SETF:4.USER.FOO) ==> FOOand an implementation that does have them might return:    (SETF-FUNCTION 'FOO) ==> (SETF FOO)    (SETF-PLACE '(SETF FOO)) ==> FOO-Sandra-------*start*02623 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 DEC 88 14:47:28 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Dec 88  14:46:48 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 508073; Tue 13-Dec-88 17:46:21 ESTDate: Tue, 13 Dec 88 17:46 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issues: SETF-PLACES, SETF-FUNCTION-VERSUS-MACROTo: cl-cleanup@sail.stanford.eduIn-Reply-To: <8812091618.AA01151@defun.utah.edu>,             <881209-011330-5598@Xerox>,             <881209-005847-5576@Xerox>,             <881209-005650-5575@Xerox>,             <881130-185833-3618@Xerox>,             <19881201011953.3.GREGOR@PORTNOY.parc.xerox.com>,             <8811301926.AA01386@mist.>,             <881130-103422-2216@Xerox>,             <8811300836.AA03401@bhopal>,             <8811300333.AA02997@bhopal>,             <2805815733-10120696@Kelvin>,             <8811290708.AA00511@bhopal>,             <8811290702.AA00498@bhopal>,             <8811290644.AA00476@bhopal>,             <8811281729.AA10535@rainbow-warrior>,             <881128-102707-1360@Xerox>,             <19881123004923.5.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <2805237539-1438981@Kelvin>Message-ID: <19881213224631.8.MOON@EUPHRATES.SCRC.Symbolics.COM>I have re-read all of the referenced messages on SETF-PLACES andSETF-FUNCTION-VERSUS-MACRO.  My opinion has not changed.  I don'tconsider that any of my comments on SETF-PLACES have been adequatelyaddressed; that is, the version of SETF-PLACES that was mailed to X3J13was the same as the original version, and the mail response to mycomments did not convince me that no changes to the proposal wereappropriate.I agree with Gray that if the problem is with making SYMBOL-FUNCTIONaccept arguments that are not symbols, a better approach thanUNDERLYING-NAME is to add FDEFINITION and its related primitives,leaving SYMBOL-FUNCTION alone.  This provides a clear layering ofprimitives, instead of this strange (to me anyway) concept of atranslation that may or may not actually translate.  I wasn't at theOctober X3J13 meeting, but from the description of the amendment at thatmeeting, what Gray said seems to be more like what X3J13 was asking for.We have been discussing this stupid issue for almost a year and a half.I certainly hope the January X3J13 meeting can come to a decision.*start*07827 00024 US Date: Wed, 21 Dec 88 16:18 PSTFrom: Gregor.paSubject: Re: PCL bug or CLOS spec issue?To: goldman@vaxa.isi.educc: commonloops.paFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: <8812212250.AA23779@vaxa.isi.edu>Message-ID: <19881222001832.8.GREGOR@PORTNOY.parc.xerox.com>Line-fold: no    Date: Wed, 21 Dec 88 14:50:03 PST    From: goldman@vaxa.isi.edu    When I try to define a recursive method for (setf foo), and it is the    FIRST method being defined for (setf foo), I get an error message from    PCL's code walker, because the use of (setf foo) in the body is not (yet)    acceptable.Resolving this kind of problem is exactly what the cleanup proposal setffunction is all about.  By assigning a default behavior to setf, itresolves any problems having to do with trying to expand a setf beforeit is defined.Currently, PCL uses a hack to pretend that the required underlyingchange to setf has been made, your example is tickling a bug in thathack.  The following patch should solve your problem:;from boot.lisp(defun expand-defmethod-internal       (generic-function-name qualifiers specialized-lambda-list body env)  (declare (values fn-form specializers doc)	   (ignore qualifiers))  (when (listp generic-function-name)    (do-standard-defsetf-1 (cadr generic-function-name)))  (multiple-value-bind (documentation declarations real-body)      (extract-declarations body)    (multiple-value-bind (parameters lambda-list specializers)	(parse-specialized-lambda-list specialized-lambda-list)            (let* ((required-parameters	       (mapcar #'(lambda (r s) (declare (ignore s)) r)		       parameters		       specializers))	     (parameters-to-reference	       (make-parameter-references specialized-lambda-list					  required-parameters					  declarations					  generic-function-name					  specializers))	     (class-declarations 	       `(declare		  ,@(remove nil			    (mapcar #'(lambda (a s) (and (symbolp s)							 (neq s 't)							 `(class ,a ,s)))				    parameters				    specializers))))	     (method-lambda 	       ;; Remove the documentation string and insert the	       ;; appropriate class declarations.  The documentation	       ;; string is removed to make it easy for us to insert	       ;; new declarations later, they will just go after the	       ;; cadr of the method lambda.  The class declarations	       ;; are inserted to communicate the class of the method's	       ;; arguments to the code walk.	       (let ()		 `(lambda ,lambda-list		    ,class-declarations		    ,@declarations		    (progn ,@parameters-to-reference)		    (block ,(if (listp generic-function-name)				(cadr generic-function-name)				generic-function-name)		      ,@real-body))))	     (call-next-method-p nil)   ;flag indicating that call-next-method	                                ;should be in the method definition	     (next-method-p-p nil)      ;flag indicating that next-method-p                                        ;should be in the method definition	     (save-original-args nil)   ;flag indicating whether or not the				        ;original arguments to the method					;must be preserved.  This happens					;for two reasons:	                                ; - the method takes &mumble args,					;   so one of the lexical functions					;   might be used in a default value	                                ;   form					; - call-next-method is used without					;   arguments at least once in the					;   body of the method	     (original-args ())	     (applyp nil)		;flag indicating whether or not the					;method takes &mumble arguments. If					;it does, it means call-next-method					;without arguments must be APPLY'd					;to original-args.  If this gets set					;true, save-original-args is set so					;as well	     (aux-bindings ())		;Suffice to say that &aux is one of					;damndest things to have put in a					;language.	     (slots (mapcar #'list required-parameters))	     (plist ())	     (walked-lambda nil))	(flet ((walk-function (form context env)		 (cond ((not (eq context ':eval)) form)		       ((not (listp form)) form)		       ((eq (car form) 'call-next-method)			(setq call-next-method-p 't)			(setq save-original-args (not (cdr form)))			form)		       ((eq (car form) 'next-method-p)			(setq next-method-p-p 't)			form)		       ((and (eq (car form) 'function)			     (cond ((eq (cadr form) 'call-next-method)				    (setq call-next-method-p 't)				    (setq save-original-args 't)				    form)				   ((eq (cadr form) 'next-method-p)				    (setq next-method-p-p 't)				    form)				   (t nil))))		       ((and (or (eq (car form) 'slot-value)				 (eq (car form) 'set-slot-value))			     (symbolp (cadr form))			     (constantp (caddr form)))			(multiple-value-bind (parameter class)			    (can-optimize-access (cadr form) env)			  (if parameter			      (ecase (car form)				(slot-value				  (optimize-slot-value class form))				(set-slot-value				  (optimize-set-slot-value class form)))			      form)))		       ((eq (car form) 'standard-instance-access)			(multiple-value-bind (parameter class)			    (can-optimize-access (cadr form) env)			  (if parameter			      (optimize-standard-instance-access class								 parameter								 form								 slots)			      form)))		       (t form))))	  	  (setq walked-lambda (walk-form method-lambda env #'walk-function))	  ;;	  ;; Add &allow-other-keys to the lambda list as an interim	  ;; way of implementing lambda list congruence rules.	  ;;	  (when (and (memq '&key lambda-list)		     (not (memq '&allow-other-keys lambda-list)))	    (let* ((rll (reverse lambda-list))		   (aux (memq '&aux rll)))	      (setq lambda-list		    (if aux			(progn (setf (cdr aux)				     (cons '&allow-other-keys (cdr aux)))			       (nreverse rll))		        (nconc (nreverse rll) (list '&allow-other-keys))))))	  ;; Scan the lambda list to determine whether this method	  ;; takes &mumble arguments.  If it does, we set applyp and	  ;; save-original-args true.	  ;; 	  ;; This is also the place where we construct the original	  ;; arguments lambda list if there has to be one.	  (dolist (p lambda-list)	    (if (memq p lambda-list-keywords)		(if (eq p '&aux)		    (progn		      (setq aux-bindings (cdr (memq '&aux lambda-list)))		      (return nil))		    (progn		      (setq applyp t			    save-original-args t)		      (push '&rest original-args)		      (push (make-symbol "AMPERSAND-ARGS") original-args)		      (return nil)))		(push (make-symbol (symbol-name p)) original-args)))	  (setq original-args (if save-original-args				  (nreverse original-args)				  ()))	  	  (multiple-value-bind (ignore walked-declarations walked-lambda-body)	      (extract-declarations (cddr walked-lambda))	    (declare (ignore ignore))	    	    (when (some #'cdr slots)	      (setq slots (sort-slots-into-isl slots))	      (setq plist (list* :isl slots plist))	      (setq walked-lambda-body (add-pv-binding walked-lambda-body						       plist						       required-parameters						       specializers)))	    (when (or next-method-p-p call-next-method-p)	      (setq plist (list* :needs-next-methods-p 't plist)))	    (values	      `(function ,(if (or call-next-method-p next-method-p-p)			      (add-lexical-functions-to-method-lambda				walked-declarations				walked-lambda-body				`(lambda ,lambda-list				   ,@walked-declarations				   ,.walked-lambda-body)				original-args				lambda-list				save-original-args				applyp				aux-bindings				call-next-method-p				next-method-p-p)			      `(lambda ,lambda-list				 ,@walked-declarations				 ,.walked-lambda-body)))	      specializers	      documentation	      plist)))))))-------*start*01409 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 JAN 89 13:24:35 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 29 Jan 89  13:24:54 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.1-cs)	id AA22781; Sun, 29 Jan 89 14:23:25 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA23486; Sun, 29 Jan 89 14:22:46 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8901292122.AA23486@defun.utah.edu>Date: Sun, 29 Jan 89 14:22:45 MSTSubject: Re: Issue: FUNCTION-NAME (Version 1)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Fri, 27 Jan 89 22:48 ESTOn the whole, I like this presentation much better than either of theother two writeups that were circulated previously.  I suspect that itmight be necessary to vote on each of the items in the LARGE proposalindividually, though.  I think I would support items 1, 2, and 11, anddon't have any particular objections to 3, 5, and 6.  For item 4, ifconsistency with GENERIC-FLET and GENERIC-LABELS is an object, anotheralternative is to change those two special forms to be like ordinaryFLET and LABELS, instead of vice versa.-Sandra-------*start*15370 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 JAN 89 19:50:21 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Jan 89  19:49:46 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 528674; Fri 27-Jan-89 22:47:46 ESTDate: Fri, 27 Jan 89 22:48 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-NAME (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDUMessage-ID: <19890128034814.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Here is the new proposal for the SETF issue that I put up on slides atthe X3J13 meeting.  It's been refined a bit, according to thesuggestions various people made.Assuming this remains in the Cleanup subcommittee, perhaps Larry shouldput this on the forthcoming letter ballot so we don't necessarily haveto wait until March to deal with it.Issue:         FUNCTION-NAMEReferences:    SETF rules for what -place- can be (pp.94-7)               FBOUNDP function (p.90)               FMAKUNBOUND function (p.92)               FUNCTION special form (p.87)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               88-002R pages 1-21, 2-21, 2-26, 2-39, 2-44, 2-46, 2-51, and 2-55               (There are additional references for the MEDIUM and LARGE                proposals, but they are not listed here.  They're obvious.)Related issues: SETF-FUNCTION-VS-MACRO, SETF-PLACES (both subsumed by this)Category:      ADDITIONEdit history:  Version 1, 23-Jan-89, by Moon                               (based on discussion at X3J13 meeting)Problem description:The Common Lisp Object System needs a well-defined way to relate the nameand arguments of a writer function to those of a reader function, becauseboth functions can be generic and can have user-defined methods.  The waythat was adopted into Common Lisp when X3J13 voted to accept document88-002R was to use a list (SETF reader) as the name of the writer function.Some changes to the non-object-oriented portion of Common Lisp are requiredin order to support this.This issue has three proposals.Proposal (FUNCTION-NAME:SMALL):            Add a new concept "function-name" (called "function-specifier" in  88-002R).  A function-name is either a symbol or a 2-element list whose  first element is the symbol SETF and whose second element is a symbol.  Implementations are free to extend the syntax of function-names to  include lists beginning with additional symbols other than SETF.  Add a new function (FDEFINITION function-name), which returns the  current global function definition named by function-name, or signals  an error if there is no global function definition.  This follows all  the same rules listed for SYMBOL-FUNCTION in CLtL p.90.  Add SETF of FDEFINITION to change the current global function definition  named by a function-name.  This follows all the same rules listed for  SETF of SYMBOL-FUNCTION in CLtL p.90.  Change the FBOUNDP and FMAKUNBOUND functions, and the FUNCTION special  form, to accept function-names in place of symbols.  Implementation  defined extensions to the syntax of function-names cannot use the  symbol LAMBDA, since FUNCTION already uses that symbol.  Change the rules for SETF places (CLtL pp.94-7) by adding the following  clause after all the existing clauses:   - Any other list whose first element is a symbol, call it reader.     In this case, SETF expands into a call to the function named by the     list (SETF reader).  The first argument is the new value and the     remaining arguments are the values of the remaining elements of     -place-.  This expansion occurs regardless of whether reader or     (SETF reader) is defined as a function locally, globally, or not at     all.  For example,         (SETF (reader arg1 arg2...) new-value)     expands into a form with the same effect and value as         (LET ((#:temp-1 arg1)          ;force correct order of evaluation               (#:temp-2 arg2)               ...               (#:temp-0 new-value))           (FUNCALL (FUNCTION (SETF reader)) #:temp-0 #:temp-1 #:temp-2...)).  Change the functions GET-SETF-METHOD and GET-SETF-METHOD-MULTIPLE-VALUE  to implement the above change to the rules.           Document that a function named (SETF reader) should return its first  argument as its only value, in order to preserve the semantics of SETF.  Change the macro DEFGENERIC and the function ENSURE-GENERIC-FUNCTION to  refer to the function FDEFINITION where they now refer to the function  SYMBOL-FUNCTION.  Change the macros DEFCLASS, DEFGENERIC, and DEFMETHOD, the special forms  GENERIC-FLET and GENERIC-LABELS, and the functions DOCUMENTATION and  ENSURE-GENERIC-FUNCTION to use the term "function-name" where they now  use the term "function-specifier" or "function specifier".Rationale for FUNCTION-NAME:SMALL:  This is the minimum change to Common Lisp needed to do what 88-002R says  about (SETF reader).  Giving implementations freedom to extend the syntax  of function-names allows for current practice.  Changing the name from  "function-specifier" to "function-name" avoids confusion and improves  consistency with the rest of the language, at the cost of a few small  changes to 88-002R.Proposal (FUNCTION-NAME:MEDIUM):  Everything in FUNCTION-NAME:SMALL, and in addition:  Change the DEFUN macro to accept a function-name for its name argument,  instead of only accepting a symbol.  If function-name is (SETF sym),  the body is surrounded by an implicit block named sym.Rationale for FUNCTION-NAME:MEDIUM:  Keeping DEFUN consistent with DEFMETHOD is a good idea.  Also 88-002R  says "The name of a generic function, like the name of an ordinary  function, can be either a symbol or a two-element list whose...", which  implies this change to DEFUN.Proposal (FUNCTION-NAME:LARGE):  Everything in FUNCTION-NAME:MEDIUM, and in addition the following  numbered points, each of which could be adopted independently,  except where explicitly noted:  1. Change the function COMPILE to accept a function-name as its name  argument.  2. Change the function DISASSEMBLE to accept a function-name as its name  argument.  3. Change the FTYPE, INLINE, and NOTINLINE declarations and proclamations  to accept function-names, not just symbols, as function names.  4. Change the FLET and LABELS special forms to accept a function-name in  the name position, not just a symbol.  5. Change the TRACE and UNTRACE macros to accept function-names, not just  symbols, in the function name positions.  6. Change the ED function to accept (ED function-name) in place of  (ED symbol).  7. Change the syntax of a function call to allow a function-name as the  first element of the list, rather than allowing only a symbol.  8. Change the DEFMACRO macro and the MACROLET special form to accept a  function-name in the name position, not just a symbol.  Change the  MACRO-FUNCTION function to accept function-names, not just symbols.  Change the last rule for SETF places to use    ((SETF reader) #:temp-0 #:temp-1 #:temp-2...)  in place of    (FUNCALL (FUNCTION (SETF reader)) #:temp-0 #:temp-1 #:temp-2...)  so that (SETF reader) can be defined as a macro.  This depends on item  7.  If item 4 is rejected, MACROLET should be stricken from this item.  9. Add an optional environment argument to FDEFINITION, SETF of  FDEFINITION, FBOUNDP, and FMAKUNBOUND.  This is the same as the  &environment argument to a macroexpander.  This argument can be used to  access local function definitions, to access function definitions in the  compile-time remote environment, and to modify function definitions in  the compile-time remote environment.  10. Change the second, third, fourth, fifth, seventh, and ninth rules for  SETF places so that they only apply when the function-name refers to the  global function definition, rather than a locally defined function or  macro.  (The ninth rule is the one that refers to DEFSETF and  DEFINE-SETF-METHOD; the other rules listed are the ones that list  specific built-in functions).  The effect of this change is that SETF  methods defined for global functions are ignored when there is a local  function binding; instead, the function named (SETF reader), which may  have a local function binding, is called.  This change is most useful  in connection with item 4, but does not actually depend on it.  11. Clarify that the eighth rule for SETF places (the one for macros)  uses MACROEXPAND-1, not MACROEXPAND.Rationale for FUNCTION-NAME:LARGE:  This extends the new feature throughout the language, in order to make  things generally more consistent and powerful.  Point by point:  1,2,3 - one should be able to compile, examine, and make declarations  about functions regardless of whether they are named with symbols or  with lists.  4 - locally defined non-generic SETF functions are a logical companion  to locally defined generic SETF functions, which can be defined with  GENERIC-FLET or GENERIC-LABELS.  They make sense on their own, since one  might define a local reader function and want a local writer function  to go with it.  5,6 - one should be able to apply development tools to functions  regardless of how they are named.  The function DOCUMENTATION was already  updated to work for function-names by 88-002R.  There might be some  difficulty with implementation-dependent syntax extensions to TRACE and  UNTRACE conflicting with this new syntax.  7 - this restores consistency between the FUNCTION special form and the  first element of a function call form.  8 - it seems more consistent to allow macros to be named the same way  that ordinary functions are named.  However, this might be considered  redundant with DEFSETF.  9 - this is not needed by the "chapter 1 and 2" level of CLOS, but might  be used by the metaobject based implementation of ENSURE-GENERIC-FUNCTION.  10 - this change was in SETF-FUNCTION-VS-MACRO and makes item 4 more useful.  11 - this change was in SETF-FUNCTION-VS-MACRO and is a good idea, but  actually is independent of everything else being proposed here.Examples:;This is an example of the sort of syntax 88-002R allows(defmethod (setf child) (new-value (parent some-class))  (setf (slot-value 'child parent) new-value)  (update-dependencies parent)  new-value)(setf (child foo) bar);If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this, if the MEDIUM or LARGE;proposal is adopted.(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));The preceding example would have to be defined like this;if only the SMALL proposal is adopted.  This is a method;all of whose parameter specializer names are T.(defmethod (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when the earlier rules do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))	(temp-vars (do ((a (cdr form) (cdr a))			(v nil (cons (gensym) v)))		       ((null a) v))))    (values temp-vars	    (cdr form)	    (list new-value)	    `(funcall #'(setf ,(car form)) ,new-value ,@temp-vars)	    `(,(car form) ,@temp-vars))))Current practice:  No implementation supports exactly what is proposed.  Symbolics Genera  and the TI Explorer support something close to the MEDIUM proposal, but  differing in a number of details.  Symbolics Genera supports items 1, 2,  3, 6, and 11, and modified forms of items 5 and 8, of the LARGE proposal.  Moon considers this proposal's variations from Symbolics current practice  to be an improvement, although incompatible in some cases.    Many implementations currently support only symbols as function names.  Symbolics Genera and the TI Explorer have some additional function-name  syntaxes.Cost to Implementors:  The SMALL and MEDIUM proposals are estimated to be no more than 50 lines  of code and require no changes to the "guts" of the interpreter and  compiler.  Most of the code for this can be written portably and was  shown on two slides at the X3J13 meeting.  Some of the changes in the LARGE proposal are trivial, some require  the compiler to use EQUAL instead of EQ to compare function names, and  items 4, 7, and 8 might require a more substantial implementation  effort.  Even that effort is estimated to be negligible compared to  the effort required to implement CLOS.Cost to Users:  No cost to users, other than program-understanding programs, since this  is an upward compatible addition.  As with any language extension, some program-understanding programs may  need to be enhanced.  A particular issue here is programs that assume  that all function names are symbols.  They may use GET to access  properties of a function name or use EQ or EQL (perhaps via MEMBER or  ASSOC) to compare function names for equality.  Such programs will need  improvement before they can understand programs that use the new feature,  but otherwise they will still work.Cost of non-adoption:  We would have to make some other language change since the language  became inconsistent when 88-002R was adopted.Performance impact:  This has no effect on performance of compiled code.  It might slow  down the compiler and interpreter but not by very much.Benefits:  CLOS will work as designed.Esthetics:  Some people dislike using anything but symbols to name functions.  Other people would prefer that if the change is to be made at all,  the LARGE proposal be adopted so that the language is uniform in its  treatment of the new extended function names.  Other proposals for  how to deal with SETF in CLOS were considerably less esthetic,  especially when package problems are taken into account.    SETF would be more esthetic, but less powerful, if it had only the  proposed setf functions and did not have setf macros.  Such a major  incompatible change is of course out of the question; however, if setf  functions are stressed over setf macros, SETF will be much easier to  teach.Discussion:  Moon supports at least FUNCTION-NAME:MEDIUM.  He does not necessarily  approve of all parts of FUNCTION-NAME:LARGE.*start*01057 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 JAN 89 10:03:11 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Jan 89  10:03:07 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 30 JAN 89 10:00:38 PSTDate: Mon, 30 Jan 89 10:00 PSTFrom: Gregor.paSubject: Issue: FUNCTION-NAME (Version 1)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDUFcc: BD:>Gregor>mail>outgoing-mail-5.text.newestIn-Reply-To: <19890128034814.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19890130180031.2.GREGOR@SPIFF.parc.xerox.com>Line-fold: noI support FUNCTION-NAME:MEDIUM and may support LARGE once I think aboutit some more.As I explained in Hawaii, support for either of these is based on the:conc-name bugs being removed from the condition system.  Of course, Ibelieve the best way to do that is to CLOSify it.-------*start*01270 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 JAN 89 07:20:32 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 30 Jan 89  07:20:34 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 529874; Mon 30-Jan-89 10:18:34 ESTDate: Mon, 30 Jan 89 10:18 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-NAME (Version 1)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <19890128034814.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <890130101826.4.KMP@BOBOLINK.SCRC.Symbolics.COM>I'm still thinking about this, but while I am I wanted point out thatMEDIUM is unacceptable to me because I don't think FLET and DEFUN shoulddisagree on what they permit as defined names. If FLET were added toMEDIUM, I suspect I'd think it was an internally consistent position.LARGE has an appeal to me in general, but I'm still mulling over the specifics.I'll reply in more detail later.*start*07217 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 FEB 89 12:40:03 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 2 Feb 89  12:39:51 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA12354; Thu, 2 Feb 89 12:39:31 PSTReceived: from lukasiewicz.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA28202; Thu, 2 Feb 89 12:36:18 PSTReceived: by lukasiewicz.sun.com (4.0/SMI-4.0)	id AA00560; Thu, 2 Feb 89 12:39:12 PSTDate: Thu, 2 Feb 89 12:39:12 PSTFrom: jrose@Sun.COM (John Rose)Message-Id: <8902022039.AA00560@lukasiewicz.sun.com>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Fri, 27 Jan 89 22:48 EST <19890128034814.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-NAME (Version 1)I favor the FUNCTION-NAME:LARGE proposal, because it defines a single,useful notion of what a function name is.  The other proposals havethe flaw that there are two kinds of function names:  symbols, andextended names, with only some of the Lisp primitives accepting thelatter.  This may be convenient for some implementations, for theshort term, but it fragments the language.I have two other comments on the proposal.A. Reducing the Cost to ImplementorsOne observation you could put in the Cost To Implementors section isthat none of the SMALL, MEDIUM, or LARGE proposals require changes tothe "guts" of the interpreter and compiler.  This is because animplementation is free to use plain symbols internally to namefunctions, and use a hack like JonL's SETF:|3.FOO.BAR| mapping toconvert non-symbol names to symbols.  This conversion would be done as apart of parsing the handful of forms which accept function names, andthen all other passes of the interpreter and compiler (the "guts") wouldjust see symbols.  (By "parsing" I mean ensuring the right number andtype of syntactic subforms.  You can see that this is a very early andsimple stage of processing.)  Or, Lisp compilers with an "alphatization"phase could perform function name symbolization at that phase.B. Finishing the Job of RegularizationI'd like to suggest two additions to your smorgasbord of options in theFUNCTION-NAME:LARGE section of the proposal.  One addition wouldregularize a major special case of functions--lambda expressions.  Theother addition would reaffirm an unstated regularity in the language,that function names can stand in for functions under FUNCALL and APPLY.Not only can the treatment of symbolic and setf-list function names beregularized, but lambda too can be treated in a consistent manner.If these two points are added to your proposal, the language as a wholewould have a completely uniform treatment of functions and functionnames.  Here they are:13. Declare that any function name is a suitable argument to FUNCALL and    APPLY.  In such a case, the function name is passed to FDEFINITION,    and the result (which may in turn be a function name) is called.    That is, the following two expressions are equivalent, when fname    is a function name:	(FUNCALL fname x y)	  <==>	(FUNCALL (FDEFINITION fname) x y)    Note that the definition is sought in the global environment.    Compare with the rule which applies to a function name occurs,    syntactically, as the car of a list in code:	(fname x y)	  <==>	(FUNCALL (FUNCTION fname) x y)	  <==> (under proposal item 9)	(FUNCALL (FDEFINITION fname <local-environment>) x y)12. Declare that any lamba expression (i.e., a list whose car is LAMBDA and    whose cdr is a well-formed lambda argument list and body) is a function    name.  The effects of the function name accessors on lambda expressions    are as follows.  FDEFINITION returns an implementation-defined value which    is the function specified the lambda expression, closed in the global    environment.  This FDEFINITION value cannot be changed by SETF.    FBOUNDP always returns T, and MAKUNBOUND is an error.Esthetics:The effect of items 11 and 12 is to complete the regularization ofCommon Lisp's treatment of functions and function names.  The totaleffect of proposal items 1 through 12 is that Lisp has just two notionsfor referencing function objects: FUNCTIONS, which are Lisp objects thatdirectly represent executable code, and FUNCTION NAMES, which can denotefunctions.  Symbols, SETF function names, and lambda expressions are allexamples of the latter notion.  The former notion is highlyimplementation dependent.  Function names can occur as syntacticentities in code.  FUNCALL and APPLY work uniformly on both functionsand function names, with a consistent semantics.Lambda expressions are often thought to denote "anonymous" functions, soit may seem paradoxical to treat them as names.  The paradox is onlyapparent, since the expression itself has the properties of a Lispfunction name: It is (typically) a cons tree which can be read, printed,and stored in source files, and it denotes a well-defined Lisp function.Benefit to Users:Function names are useful for representing objects in remoteenvironments, because they need not be bound at all times to the samefunction, or to any function, and because they are typically stable inmeaning across reads and prints, where plain functions are not.Programs which deal simultaneously with remote and local environments,such as CLOS, can probably be simplified, since function namescan be used uniformly, rather than an ad-hoc mixture of functionsand function names.The language as a whole become more uniform from these additions andclarifications, making it easier to learn and use.  (See Esthetics.)Cost to Implementors:Interpreters which currently have a special case check for applicationof lambda expressions would need to modify this check to callFDEFINITION when a list of any sort is encountered.  Note that allCommon Lisps already must perform some such check, since lambdaexpressions can be funcalled (and this is currently a very special case,the only standard case of a list being funcalled).  This means thatevery Lisp already has a place to insert the required call toFDEFINITION.In some implementations, FDEFINITION of a lambda expression could be thatlambda-expression itself.  In others featuring a pre-eval codewalk, thewalk would be done by FDEFINITION, which would return an appropriateclosure.Cost of Non-adoption:Rather than two notions for function references (functions and functionnames), there would be several notions, each corresponding to the validinputs for particular group of primitives.  APPLY and FUNCALL wouldaccept functions, symbolic names, and lambda expressions, but not setffunction names.  FDEFINITION and its kind would accept symbols and setffunction names but not lambda expressions.  If the :LARGE proposal isnot adopted, this fragmentation would also apply to the various syntaxesinvolving function names; some names would be acceptable to DEFUNbut not to FLET, etc.					-- John*start*02599 00024 US Return-Path: <CL-Compiler-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 FEB 89 08:26:47 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 3 Feb 89  08:19:54 PSTReceived: by ti.com id AA13550; Fri, 3 Feb 89 10:17:57 CSTReceived: from Kelvin by tilde id AA18146; Fri, 3 Feb 89 10:06:53 CSTMessage-Id: <2811514004-8355350@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 3 Feb 89 10:06:44 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: jrose@Sun.COM (John Rose)Cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDUSubject: Re: Issue: FUNCTION-NAME (Version 1)In-Reply-To: Msg of Thu, 2 Feb 89 12:39:12 PST from jrose@Sun.COM (John Rose)> 13. Declare that any function name is a suitable argument to FUNCALL and>     APPLY.  In such a case, the function name is passed to FDEFINITION,>     and the result (which may in turn be a function name) is called.I don't think this is such a good idea.  The case of automatically coercinga symbol to a function is needed because it provides a portable mechanismfor indirect addressing of a function; I haven't seen a reason to need thisfor non-symbol function specs.  But more important is that coercing asymbol to a function is a trivial operation that is reasonable to do atrun time on each call without adding a significant amount of overhead.FDEFINITION, on the other hand, is a much more expensive operation -- atbest it might use GET to do a property list lookup, or it could be usingstring-append and INTERN to convert the name to a symbol.  In either case,I think this is more work than you want to do on each call.> 12. Declare that any lamba expression (i.e., a list whose car is LAMBDA and>     whose cdr is a well-formed lambda argument list and body) is a function>     name.  The effects of the function name accessors on lambda expressions>     are as follows.  FDEFINITION returns an implementation-defined value which>     is the function specified the lambda expression, closed in the global>     environment.  This FDEFINITION value cannot be changed by SETF.>     FBOUNDP always returns T, and MAKUNBOUND is an error.The exceptions for SETF and MAKUNBOUND show that this is not really asconsistent as you might like.  Furthermore, the FUNCTION special form wouldhave to treat a LAMBDA expression as a function, not a function name, inorder for it to be lexically scoped.  It seems like this might just causeconfusion rather than consistency.*start*24409 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Mar-89 23:04:57 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 23:04:38 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  22:43:21 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 16 MAR 89 22:40:08 PSTDate: 16 Mar 89 22:34 PSTFrom: masinter.paSubject: Issue: SETF-FUNCTION-VS-MACRO, SETF-PLACES, FUNCTION-NAME, v.1To: X3J13@sail.stanford.eduline-fold: NOMessage-ID: <890316-224008-6866@Xerox>This issue has been renamed several times; however, it isthe same old issue. I say this lest anyone think we can'two week' it away.We didn't have a 'letter ballot' and so we have to talkabout it. Maybe.Additional Comments are at the end; including a fairly substantialadditional proposal.!Issue:         FUNCTION-NAMEReferences:    SETF rules for what -place- can be (pp.94-7)               FBOUNDP function (p.90)               FMAKUNBOUND function (p.92)               FUNCTION special form (p.87)               SYMBOL-FUNCTION and setf of symbol-function (p.90)               88-002R pages 1-21, 2-21, 2-26, 2-39, 2-44, 2-46, 2-51, and 2-55               (There are additional references for the MEDIUM and LARGE                proposals, but they are not listed here.  They're obvious.)Related issues: SETF-FUNCTION-VS-MACRO, SETF-PLACES (both subsumed by this)Category:      ADDITIONEdit history:  Version 1, 23-Jan-89, by Moon                               (based on discussion at X3J13 meeting)Problem description:The Common Lisp Object System needs a well-defined way to relate the nameand arguments of a writer function to those of a reader function, becauseboth functions can be generic and can have user-defined methods.  The waythat was adopted into Common Lisp when X3J13 voted to accept document88-002R was to use a list (SETF reader) as the name of the writer function.Some changes to the non-object-oriented portion of Common Lisp are requiredin order to support this.This issue has three proposals.Proposal (FUNCTION-NAME:SMALL):            Add a new concept "function-name" (called "function-specifier" in  88-002R).  A function-name is either a symbol or a 2-element list whose  first element is the symbol SETF and whose second element is a symbol.  Implementations are free to extend the syntax of function-names to  include lists beginning with additional symbols other than SETF.  Add a new function (FDEFINITION function-name), which returns the  current global function definition named by function-name, or signals  an error if there is no global function definition.  This follows all  the same rules listed for SYMBOL-FUNCTION in CLtL p.90.  Add SETF of FDEFINITION to change the current global function definition  named by a function-name.  This follows all the same rules listed for  SETF of SYMBOL-FUNCTION in CLtL p.90.  Change the FBOUNDP and FMAKUNBOUND functions, and the FUNCTION special  form, to accept function-names in place of symbols.  Implementation  defined extensions to the syntax of function-names cannot use the  symbol LAMBDA, since FUNCTION already uses that symbol.  Change the rules for SETF places (CLtL pp.94-7) by adding the following  clause after all the existing clauses:   - Any other list whose first element is a symbol, call it reader.     In this case, SETF expands into a call to the function named by the     list (SETF reader).  The first argument is the new value and the     remaining arguments are the values of the remaining elements of     -place-.  This expansion occurs regardless of whether reader or     (SETF reader) is defined as a function locally, globally, or not at     all.  For example,         (SETF (reader arg1 arg2...) new-value)     expands into a form with the same effect and value as         (LET ((#:temp-1 arg1)          ;force correct order of evaluation               (#:temp-2 arg2)               ...               (#:temp-0 new-value))           (FUNCALL (FUNCTION (SETF reader)) #:temp-0 #:temp-1 #:temp-2...)).  Change the functions GET-SETF-METHOD and GET-SETF-METHOD-MULTIPLE-VALUE  to implement the above change to the rules.           Document that a function named (SETF reader) should return its first  argument as its only value, in order to preserve the semantics of SETF.  Change the macro DEFGENERIC and the function ENSURE-GENERIC-FUNCTION to  refer to the function FDEFINITION where they now refer to the function  SYMBOL-FUNCTION.  Change the macros DEFCLASS, DEFGENERIC, and DEFMETHOD, the special forms  GENERIC-FLET and GENERIC-LABELS, and the functions DOCUMENTATION and  ENSURE-GENERIC-FUNCTION to use the term "function-name" where they now  use the term "function-specifier" or "function specifier".Rationale for FUNCTION-NAME:SMALL:  This is the minimum change to Common Lisp needed to do what 88-002R says  about (SETF reader).  Giving implementations freedom to extend the syntax  of function-names allows for current practice.  Changing the name from  "function-specifier" to "function-name" avoids confusion and improves  consistency with the rest of the language, at the cost of a few small  changes to 88-002R.Proposal (FUNCTION-NAME:MEDIUM):  Everything in FUNCTION-NAME:SMALL, and in addition:  Change the DEFUN macro to accept a function-name for its name argument,  instead of only accepting a symbol.  If function-name is (SETF sym),  the body is surrounded by an implicit block named sym.Rationale for FUNCTION-NAME:MEDIUM:  Keeping DEFUN consistent with DEFMETHOD is a good idea.  Also 88-002R  says "The name of a generic function, like the name of an ordinary  function, can be either a symbol or a two-element list whose...", which  implies this change to DEFUN.Proposal (FUNCTION-NAME:LARGE):  Everything in FUNCTION-NAME:MEDIUM, and in addition the following  numbered points, each of which could be adopted independently,  except where explicitly noted:  1. Change the function COMPILE to accept a function-name as its name  argument.  2. Change the function DISASSEMBLE to accept a function-name as its name  argument.  3. Change the FTYPE, INLINE, and NOTINLINE declarations and proclamations  to accept function-names, not just symbols, as function names.  4. Change the FLET and LABELS special forms to accept a function-name in  the name position, not just a symbol.  5. Change the TRACE and UNTRACE macros to accept function-names, not just  symbols, in the function name positions.  6. Change the ED function to accept (ED function-name) in place of  (ED symbol).  7. Change the syntax of a function call to allow a function-name as the  first element of the list, rather than allowing only a symbol.  8. Change the DEFMACRO macro and the MACROLET special form to accept a  function-name in the name position, not just a symbol.  Change the  MACRO-FUNCTION function to accept function-names, not just symbols.  Change the last rule for SETF places to use    ((SETF reader) #:temp-0 #:temp-1 #:temp-2...)  in place of    (FUNCALL (FUNCTION (SETF reader)) #:temp-0 #:temp-1 #:temp-2...)  so that (SETF reader) can be defined as a macro.  This depends on item  7.  If item 4 is rejected, MACROLET should be stricken from this item.  9. Add an optional environment argument to FDEFINITION, SETF of  FDEFINITION, FBOUNDP, and FMAKUNBOUND.  This is the same as the  &environment argument to a macroexpander.  This argument can be used to  access local function definitions, to access function definitions in the  compile-time remote environment, and to modify function definitions in  the compile-time remote environment.  10. Change the second, third, fourth, fifth, seventh, and ninth rules for  SETF places so that they only apply when the function-name refers to the  global function definition, rather than a locally defined function or  macro.  (The ninth rule is the one that refers to DEFSETF and  DEFINE-SETF-METHOD; the other rules listed are the ones that list  specific built-in functions).  The effect of this change is that SETF  methods defined for global functions are ignored when there is a local  function binding; instead, the function named (SETF reader), which may  have a local function binding, is called.  This change is most useful  in connection with item 4, but does not actually depend on it.  11. Clarify that the eighth rule for SETF places (the one for macros)  uses MACROEXPAND-1, not MACROEXPAND.Rationale for FUNCTION-NAME:LARGE:  This extends the new feature throughout the language, in order to make  things generally more consistent and powerful.  Point by point:  1,2,3 - one should be able to compile, examine, and make declarations  about functions regardless of whether they are named with symbols or  with lists.  4 - locally defined non-generic SETF functions are a logical companion  to locally defined generic SETF functions, which can be defined with  GENERIC-FLET or GENERIC-LABELS.  They make sense on their own, since one  might define a local reader function and want a local writer function  to go with it.  5,6 - one should be able to apply development tools to functions  regardless of how they are named.  The function DOCUMENTATION was already  updated to work for function-names by 88-002R.  There might be some  difficulty with implementation-dependent syntax extensions to TRACE and  UNTRACE conflicting with this new syntax.  7 - this restores consistency between the FUNCTION special form and the  first element of a function call form.  8 - it seems more consistent to allow macros to be named the same way  that ordinary functions are named.  However, this might be considered  redundant with DEFSETF.  9 - this is not needed by the "chapter 1 and 2" level of CLOS, but might  be used by the metaobject based implementation of ENSURE-GENERIC-FUNCTION.  10 - this change was in SETF-FUNCTION-VS-MACRO and makes item 4 more useful.  11 - this change was in SETF-FUNCTION-VS-MACRO and is a good idea, but  actually is independent of everything else being proposed here.Examples:;This is an example of the sort of syntax 88-002R allows(defmethod (setf child) (new-value (parent some-class))  (setf (slot-value 'child parent) new-value)  (update-dependencies parent)  new-value)(setf (child foo) bar);If SETF of SUBSEQ was not already built into Common Lisp,;it could have been defined like this, if the MEDIUM or LARGE;proposal is adopted.(defun (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));The preceding example would have to be defined like this;if only the SMALL proposal is adopted.  This is a method;all of whose parameter specializer names are T.(defmethod (setf subseq) (new-value sequence start &optional end)  (unless end (setq end (length sequence)))  (setq end (min end (+ start (length new-value))))  (do ((i start (1+ i))       (j 0 (1+ j)))      ((= i end) new-value)    (setf (elt sequence i) (elt new-value j))));Another example, showing a locally defined setf function(defun frobulate (mumble)  (let ((table (mumble-table mumble)))    (flet ((foo (x)             (gethash x table))           ((setf foo) (new x)             (setf (gethash x table) new)))      ..      (foo a)      ..      (setf (foo a) b))));get-setf-method could implement setf functions by calling;this function when the earlier rules do not apply(defun get-setf-method-for-setf-function (form)  (let ((new-value (gensym))	(temp-vars (do ((a (cdr form) (cdr a))			(v nil (cons (gensym) v)))		       ((null a) v))))    (values temp-vars	    (cdr form)	    (list new-value)	    `(funcall #'(setf ,(car form)) ,new-value ,@temp-vars)	    `(,(car form) ,@temp-vars))))Current practice:  No implementation supports exactly what is proposed.  Symbolics Genera  and the TI Explorer support something close to the MEDIUM proposal, but  differing in a number of details.  Symbolics Genera supports items 1, 2,  3, 6, and 11, and modified forms of items 5 and 8, of the LARGE proposal.  Moon considers this proposal's variations from Symbolics current practice  to be an improvement, although incompatible in some cases.    Many implementations currently support only symbols as function names.  Symbolics Genera and the TI Explorer have some additional function-name  syntaxes.Cost to Implementors:  The SMALL and MEDIUM proposals are estimated to be no more than 50 lines  of code and require no changes to the "guts" of the interpreter and  compiler.  Most of the code for this can be written portably and was  shown on two slides at the X3J13 meeting.  Some of the changes in the LARGE proposal are trivial, some require  the compiler to use EQUAL instead of EQ to compare function names, and  items 4, 7, and 8 might require a more substantial implementation  effort.  Even that effort is estimated to be negligible compared to  the effort required to implement CLOS.Cost to Users:  No cost to users, other than program-understanding programs, since this  is an upward compatible addition.  As with any language extension, some program-understanding programs may  need to be enhanced.  A particular issue here is programs that assume  that all function names are symbols.  They may use GET to access  properties of a function name or use EQ or EQL (perhaps via MEMBER or  ASSOC) to compare function names for equality.  Such programs will need  improvement before they can understand programs that use the new feature,  but otherwise they will still work.Cost of non-adoption:  We would have to make some other language change since the language  became inconsistent when 88-002R was adopted.Performance impact:  This has no effect on performance of compiled code.  It might slow  down the compiler and interpreter but not by very much.Benefits:  CLOS will work as designed.Esthetics:  Some people dislike using anything but symbols to name functions.  Other people would prefer that if the change is to be made at all,  the LARGE proposal be adopted so that the language is uniform in its  treatment of the new extended function names.  Other proposals for  how to deal with SETF in CLOS were considerably less esthetic,  especially when package problems are taken into account.    SETF would be more esthetic, but less powerful, if it had only the  proposed setf functions and did not have setf macros.  Such a major  incompatible change is of course out of the question; however, if setf  functions are stressed over setf macros, SETF will be much easier to  teach.Discussion:  Moon supports at least FUNCTION-NAME:MEDIUM.  He does not necessarily  approve of all parts of FUNCTION-NAME:LARGE.!Additional Comments:On the whole, I like this presentation much better than either of theother two writeups that were circulated previously.  I suspect that itmight be necessary to vote on each of the items in the LARGE proposalindividually, though.  I think I would support items 1, 2, and 11, anddon't have any particular objections to 3, 5, and 6.  For item 4, ifconsistency with GENERIC-FLET and GENERIC-LABELS is an object, anotheralternative is to change those two special forms to be like ordinaryFLET and LABELS, instead of vice versa.- - - - - - -I support FUNCTION-NAME:MEDIUM and may support LARGE once I think aboutit some more.As I explained in Hawaii, support for either of these is based on the:conc-name bugs being removed from the condition system.  Of course, Ibelieve the best way to do that is to CLOSify it.- - - - - - - - I'm still thinking about this, but while I am I wanted point out thatMEDIUM is unacceptable to me because I don't think FLET and DEFUN shoulddisagree on what they permit as defined names. If FLET were added toMEDIUM, I suspect I'd think it was an internally consistent position.LARGE has an appeal to me in general, but I'm still mulling over the specifics.- - - - - - - - - -I favor the FUNCTION-NAME:LARGE proposal, because it defines a single,useful notion of what a function name is.  The other proposals havethe flaw that there are two kinds of function names:  symbols, andextended names, with only some of the Lisp primitives accepting thelatter.  This may be convenient for some implementations, for theshort term, but it fragments the language.I have two other comments on the proposal.A. Reducing the Cost to ImplementorsOne observation you could put in the Cost To Implementors section isthat none of the SMALL, MEDIUM, or LARGE proposals require changes tothe "guts" of the interpreter and compiler.  This is because animplementation is free to use plain symbols internally to namefunctions, and use a hack like JonL's SETF:|3.FOO.BAR| mapping toconvert non-symbol names to symbols.  This conversion would be done as apart of parsing the handful of forms which accept function names, andthen all other passes of the interpreter and compiler (the "guts") wouldjust see symbols.  (By "parsing" I mean ensuring the right number andtype of syntactic subforms.  You can see that this is a very early andsimple stage of processing.)  Or, Lisp compilers with an "alphatization"phase could perform function name symbolization at that phase.B. Finishing the Job of RegularizationI'd like to suggest two additions to your smorgasbord of options in theFUNCTION-NAME:LARGE section of the proposal.  One addition wouldregularize a major special case of functions--lambda expressions.  Theother addition would reaffirm an unstated regularity in the language,that function names can stand in for functions under FUNCALL and APPLY.Not only can the treatment of symbolic and setf-list function names beregularized, but lambda too can be treated in a consistent manner.If these two points are added to your proposal, the language as a wholewould have a completely uniform treatment of functions and functionnames.  Here they are:13. Declare that any function name is a suitable argument to FUNCALL and    APPLY.  In such a case, the function name is passed to FDEFINITION,    and the result (which may in turn be a function name) is called.    That is, the following two expressions are equivalent, when fname    is a function name:	(FUNCALL fname x y)	  <==>	(FUNCALL (FDEFINITION fname) x y)    Note that the definition is sought in the global environment.    Compare with the rule which applies to a function name occurs,    syntactically, as the car of a list in code:	(fname x y)	  <==>	(FUNCALL (FUNCTION fname) x y)	  <==> (under proposal item 9)	(FUNCALL (FDEFINITION fname <local-environment>) x y)12. Declare that any lamba expression (i.e., a list whose car is LAMBDA and    whose cdr is a well-formed lambda argument list and body) is a function    name.  The effects of the function name accessors on lambda expressions    are as follows.  FDEFINITION returns an implementation-defined value which    is the function specified the lambda expression, closed in the global    environment.  This FDEFINITION value cannot be changed by SETF.    FBOUNDP always returns T, and MAKUNBOUND is an error.Esthetics:The effect of items 11 and 12 is to complete the regularization ofCommon Lisp's treatment of functions and function names.  The totaleffect of proposal items 1 through 12 is that Lisp has just two notionsfor referencing function objects: FUNCTIONS, which are Lisp objects thatdirectly represent executable code, and FUNCTION NAMES, which can denotefunctions.  Symbols, SETF function names, and lambda expressions are allexamples of the latter notion.  The former notion is highlyimplementation dependent.  Function names can occur as syntacticentities in code.  FUNCALL and APPLY work uniformly on both functionsand function names, with a consistent semantics.Lambda expressions are often thought to denote "anonymous" functions, soit may seem paradoxical to treat them as names.  The paradox is onlyapparent, since the expression itself has the properties of a Lispfunction name: It is (typically) a cons tree which can be read, printed,and stored in source files, and it denotes a well-defined Lisp function.Benefit to Users:Function names are useful for representing objects in remoteenvironments, because they need not be bound at all times to the samefunction, or to any function, and because they are typically stable inmeaning across reads and prints, where plain functions are not.Programs which deal simultaneously with remote and local environments,such as CLOS, can probably be simplified, since function namescan be used uniformly, rather than an ad-hoc mixture of functionsand function names.The language as a whole become more uniform from these additions andclarifications, making it easier to learn and use.  (See Esthetics.)Cost to Implementors:Interpreters which currently have a special case check for applicationof lambda expressions would need to modify this check to callFDEFINITION when a list of any sort is encountered.  Note that allCommon Lisps already must perform some such check, since lambdaexpressions can be funcalled (and this is currently a very special case,the only standard case of a list being funcalled).  This means thatevery Lisp already has a place to insert the required call toFDEFINITION.In some implementations, FDEFINITION of a lambda expression could be thatlambda-expression itself.  In others featuring a pre-eval codewalk, thewalk would be done by FDEFINITION, which would return an appropriateclosure.Cost of Non-adoption:Rather than two notions for function references (functions and functionnames), there would be several notions, each corresponding to the validinputs for particular group of primitives.  APPLY and FUNCALL wouldaccept functions, symbolic names, and lambda expressions, but not setffunction names.  FDEFINITION and its kind would accept symbols and setffunction names but not lambda expressions.  If the :LARGE proposal isnot adopted, this fragmentation would also apply to the various syntaxesinvolving function names; some names would be acceptable to DEFUNbut not to FLET, etc.- - - - - - - - - - - - -> 13. Declare that any function name is a suitable argument to FUNCALL and>     APPLY.  In such a case, the function name is passed to FDEFINITION,>     and the result (which may in turn be a function name) is called.I don't think this is such a good idea.  The case of automatically coercinga symbol to a function is needed because it provides a portable mechanismfor indirect addressing of a function; I haven't seen a reason to need thisfor non-symbol function specs.  But more important is that coercing asymbol to a function is a trivial operation that is reasonable to do atrun time on each call without adding a significant amount of overhead.FDEFINITION, on the other hand, is a much more expensive operation -- atbest it might use GET to do a property list lookup, or it could be usingstring-append and INTERN to convert the name to a symbol.  In either case,I think this is more work than you want to do on each call.> 12. Declare that any lamba expression (i.e., a list whose car is LAMBDA and>     whose cdr is a well-formed lambda argument list and body) is a function>     name.  The effects of the function name accessors on lambda expressions>     are as follows.  FDEFINITION returns an implementation-defined value which>     is the function specified the lambda expression, closed in the global>     environment.  This FDEFINITION value cannot be changed by SETF.>     FBOUNDP always returns T, and MAKUNBOUND is an error.The exceptions for SETF and MAKUNBOUND show that this is not really asconsistent as you might like.  Furthermore, the FUNCTION special form wouldhave to treat a LAMBDA expression as a function, not a function name, inorder for it to be lexically scoped.  It seems like this might just causeconfusion rather than consistency.*start*01874 00024 US Date:  4 Apr 89 11:49 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: FUNCTION-NAMETo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-NAMETo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 11:30:25 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:17:21 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571095; Tue 4-Apr-89 14:17:15 EDTOriginal-Date: Tue, 4 Apr 89 14:16 EDTMessage-ID: <890404141651.0.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes show the following... We voted in order SMALL, MEDIUM, then LARGE. Each time, the attempt was to replace the previous. Option SMALL passed 15-2. Option MEDIUM passed 9-6, superseding SMALL. Option LARGE passed 13-2-3, superseding MEDIUM. The minutes probably just reflect LARGE having been passed. Moon then moved that we reconsider parts of LARGE -- parts 4,7,8,9. We agreed to reconsider. Sandra moved to retract 4,7,8,9.  RPG amended the proposal to affect GENERIC-FLET and GENERIC-LABELS, too,  for consistency.  RPG's amendment to Sandra's motion passed. We voted on each part of Sandra's motion separately:  Strike 4? No.  (Failed 3-15)  Strike 7? Yes. (Passed 16-1)  Strike 8? Yes. (Passed 16-0)  Strike 9? Yes  (Passed 17-0-1)   There was some question about 9's relation to SYNTACTIC-ENVIRONMENT-ACCESS. The net effect is that option LARGE passed with amendments to strike 7,8,9.