*start*05904 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 13:29:00 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Jan 89  13:28:15 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 514035; 2 Jan 89 16:26:46 ESTDate: Mon, 2 Jan 89 16:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 1)To: CL-Cleanup@sail.stanford.educc: Common-Lisp-Object-System@Sail.Stanford.edu, CL-Compiler@Sail.Stanford.eduIn-Reply-To: <19881229175913.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19890102212611.8.MOON@EUPHRATES.SCRC.Symbolics.COM>This was discussed on the clos and compiler lists.  I thought it wouldbe a good idea to write it up for discussion and give the cleanup groupa look at it.  I think it's something that fell in the cracks betweenthese three subcommittees.Issue:         LOAD-OBJECTSReferences:    noneRelated issues: noneCategory:      ADDITIONEdit history:  Version 1, 2-Jan-89, by Moon (for discussion)Problem description:  Common Lisp doesn't provide any way to use an object of a user-defined  type (defined with DEFCLASS or DEFSTRUCT) as a constant in a program  compiled with COMPILE-FILE.  The problem is that LOAD has to be able  to "reconstruct" an equivalent object when the compiled-code file is  loaded, but the programmer has no way to tell LOAD how to do that.Proposal (LOAD-OBJECTS:MAKE-LOAD-FORM):            Define a new generic function named MAKE-LOAD-FORM, which takes one  argument and returns one value.  The value is a form which, when  evaluated at some later time, should return an object that is  equivalent to the argument.  The exact meaning of "equivalent"  depends on the type of object and is up to the programmer who  defines a method for MAKE-LOAD-FORM.  Define that COMPILE-FILE calls MAKE-LOAD-FORM on any object that  appears in a constant and has STANDARD-CLASS or STRUCTURE-CLASS as a  metaclass.  Define that COMPILE-FILE will only call MAKE-LOAD-FORM  once for any given object (compared with EQ) within a single file.  It is unspecified whether LOAD calls EVAL on the form or does some  other operation that has an equivalent effect.  Define that an instance of a class defined with DEFCLASS without any  direct superclasses, or defined with DEFSTRUCT without the :TYPE or  :INCLUDE options, does not inherit any method for MAKE-LOAD-FORM other  than possibly a method that only signals an error.Example:  (defclass my-class ()     ((a :initarg :a :reader my-a)      (b :initarg :b :reader my-b)      (c :accessor my-c)))  (defmethod shared-initialize ((self my-class) ignore &rest ignore)    (unless (slot-boundp self 'c)      (setf (my-c self) (some-computation (my-a self) (my-b self)))))  (defmethod make-load-form ((self my-class))    `(make-instance ',(class-name (class-of self))                    :a ',(my-a self) :b ',(my-b self)))  In this example, an equivalent instance of my-class is reconstructed  by using the values of two of its slots.  The value of the third slot  is derived from those two values.  (defclass my-frob ()     ((name :initarg :name :reader my-name)))  (defmethod make-load-form ((self my-frob))    `(find-my-frob ',(my-name self) :if-does-not-exist :create))  In this example, instances of my-frob are "interned" in some way.  An equivalent instance is reconstructed by using the value of the  name slot as a key for searching existing objects.  In this case  the programmer has chosen to create a new object if no existing  object is found; alternatively she could have chosen to signal an  error in that case.Rationale:  Only the programmer who designed a class can know the correct  way to reconstruct objects of that class at load time, therefore  the reconstruction should be controlled by a generic function.  Using EVAL as the interface for telling LOAD what to do provides  full generality.  A default method, such as one that makes an object whose class has the  same name and whose slots have equivalent contents, is not supplied  because this is inappropriate for many objects and because it is easy  to write for those objects where it is appropriate.  MAKE-LOAD-FORM has a natural resemblance to PRINT-OBJECT.Current practice:  Symbolics Flavors has something like this, but under a different name.  The name Symbolics uses is not suitable for standardization.  JonL reports that Lucid is getting more and more requests for this.Cost to Implementors:  This seems like only a few one-line changes in the compiled-code  file writer and reader.Cost to Users:  None.Cost of non-adoption:  Serious impairment of the ability to use extended-type objects.  Each  implementation will probably make up its own version of this as an  extension.Performance impact:  None.Benefits:  See Cost of non-adoption.Esthetics:  No significant positive or negative impact.Discussion:  It would be possible to define an additional level of protocol that  allows multiple classes to contribute to the reconstruction of an  object, combining initialization arguments contributed by each class.  Since a user can easily define that in terms of MAKE-LOAD-FORM without  modifying the Lisp system, it is not being proposed now.  Any type that has a read syntax is likely to appear as a quoted  constant or inside a quoted constant.  Pathnames are one example, user  programs often define others.  Also many implementations provide a way  to create a compiled-code file full of data (rather than compiled Lisp  programs), and such data probably include extended-type objects.  Moon supports this.*start*05868 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 13:36:46 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Jan 89  13:28:15 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 514035; 2 Jan 89 16:26:46 ESTDate: Mon, 2 Jan 89 16:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 1)To: CL-Cleanup@sail.stanford.educc: Common-Lisp-Object-System@Sail.Stanford.edu, CL-Compiler@Sail.Stanford.eduIn-Reply-To: <19881229175913.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19890102212611.8.MOON@EUPHRATES.SCRC.Symbolics.COM>This was discussed on the clos and compiler lists.  I thought it wouldbe a good idea to write it up for discussion and give the cleanup groupa look at it.  I think it's something that fell in the cracks betweenthese three subcommittees.Issue:         LOAD-OBJECTSReferences:    noneRelated issues: noneCategory:      ADDITIONEdit history:  Version 1, 2-Jan-89, by Moon (for discussion)Problem description:  Common Lisp doesn't provide any way to use an object of a user-defined  type (defined with DEFCLASS or DEFSTRUCT) as a constant in a program  compiled with COMPILE-FILE.  The problem is that LOAD has to be able  to "reconstruct" an equivalent object when the compiled-code file is  loaded, but the programmer has no way to tell LOAD how to do that.Proposal (LOAD-OBJECTS:MAKE-LOAD-FORM):            Define a new generic function named MAKE-LOAD-FORM, which takes one  argument and returns one value.  The value is a form which, when  evaluated at some later time, should return an object that is  equivalent to the argument.  The exact meaning of "equivalent"  depends on the type of object and is up to the programmer who  defines a method for MAKE-LOAD-FORM.  Define that COMPILE-FILE calls MAKE-LOAD-FORM on any object that  appears in a constant and has STANDARD-CLASS or STRUCTURE-CLASS as a  metaclass.  Define that COMPILE-FILE will only call MAKE-LOAD-FORM  once for any given object (compared with EQ) within a single file.  It is unspecified whether LOAD calls EVAL on the form or does some  other operation that has an equivalent effect.  Define that an instance of a class defined with DEFCLASS without any  direct superclasses, or defined with DEFSTRUCT without the :TYPE or  :INCLUDE options, does not inherit any method for MAKE-LOAD-FORM other  than possibly a method that only signals an error.Example:  (defclass my-class ()     ((a :initarg :a :reader my-a)      (b :initarg :b :reader my-b)      (c :accessor my-c)))  (defmethod shared-initialize ((self my-class) ignore &rest ignore)    (unless (slot-boundp self 'c)      (setf (my-c self) (some-computation (my-a self) (my-b self)))))  (defmethod make-load-form ((self my-class))    `(make-instance ',(class-name (class-of self))                    :a ',(my-a self) :b ',(my-b self)))  In this example, an equivalent instance of my-class is reconstructed  by using the values of two of its slots.  The value of the third slot  is derived from those two values.  (defclass my-frob ()     ((name :initarg :name :reader my-name)))  (defmethod make-load-form ((self my-frob))    `(find-my-frob ',(my-name self) :if-does-not-exist :create))  In this example, instances of my-frob are "interned" in some way.  An equivalent instance is reconstructed by using the value of the  name slot as a key for searching existing objects.  In this case  the programmer has chosen to create a new object if no existing  object is found; alternatively she could have chosen to signal an  error in that case.Rationale:  Only the programmer who designed a class can know the correct  way to reconstruct objects of that class at load time, therefore  the reconstruction should be controlled by a generic function.  Using EVAL as the interface for telling LOAD what to do provides  full generality.  A default method, such as one that makes an object whose class has the  same name and whose slots have equivalent contents, is not supplied  because this is inappropriate for many objects and because it is easy  to write for those objects where it is appropriate.  MAKE-LOAD-FORM has a natural resemblance to PRINT-OBJECT.Current practice:  Symbolics Flavors has something like this, but under a different name.  The name Symbolics uses is not suitable for standardization.  JonL reports that Lucid is getting more and more requests for this.Cost to Implementors:  This seems like only a few one-line changes in the compiled-code  file writer and reader.Cost to Users:  None.Cost of non-adoption:  Serious impairment of the ability to use extended-type objects.  Each  implementation will probably make up its own version of this as an  extension.Performance impact:  None.Benefits:  See Cost of non-adoption.Esthetics:  No significant positive or negative impact.Discussion:  It would be possible to define an additional level of protocol that  allows multiple classes to contribute to the reconstruction of an  object, combining initialization arguments contributed by each class.  Since a user can easily define that in terms of MAKE-LOAD-FORM without  modifying the Lisp system, it is not being proposed now.  Any type that has a read syntax is likely to appear as a quoted  constant or inside a quoted constant.  Pathnames are one example, user  programs often define others.  Also many implementations provide a way  to create a compiled-code file full of data (rather than compiled Lisp  programs), and such data probably include extended-type objects.  Moon supports this.*start*04686 00024 US Return-Path: <CL-Compiler-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 DEC 88 11:32:32 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 30 Dec 88  11:28:17 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA17613; Fri, 30 Dec 88 11:30:11 PSTReceived: from suntana.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA28437; Fri, 30 Dec 88 11:26:52 PSTReceived: from localhost by suntana.sun.com (4.0/SMI-4.0)	id AA09230; Fri, 30 Dec 88 11:27:29 PSTMessage-Id: <8812301927.AA09230@suntana.sun.com>To: Jon L White <jonl@lucid.com>Cc: Common-Lisp-Object-System@Sail.Stanford.edu, CL-Compiler@Sail.Stanford.edu, cperdue%suntana@Sun.COMSubject: Re: Compilation implications In-Reply-To: Your message of Thu, 29 Dec 88 04:52:47 -0800.             <8812291252.AA10083@bhopal> Date: Fri, 30 Dec 88 11:27:27 PSTFrom: kempf@Sun.COMA couple comments on the original and Moon's followup.1) I proposed as a strawman awhile back that a read macro be introducedsimilar to #S for DEFSTRUCTSs so that CLOS objects could be stored inreadable ASCII form and also so that they could be made persistent. There was some discussion on the issue but it eventually died out withouta proposal.2) I think Moon's solution of a constructor form which gets executed usingEVAL at load time is the only possible solution to this problem. In particular,the semantics of quoted constants implied by CLtL is that only symbols canbe expected to be EQ across a FASDUMP, and only characters and numbers canadditionally be expected to be EQL. This has interesting implications for EQL specializers. Since the only objects which can be expected to survive a FASDUMP and remain EQL are symbols, numbers, and characters, these are theonly objects which make sense to have in a DEFMETHOD form with an EQLspecialized parameter. This makes it important that machinerybe available to add methods to a generic function through a functionalinterface, since some of the things one wants to do with EQL methods requireother objects. Part of that machinery is already in Chapter 2 (ADD-METHOD, MAKE-INSTANCE) but part of it is not (how to make a method function, for example). 3) With regard to using name equivalence for classes across FASDUMP, again,I largely agree with Moon on this issue, however I'll take the liberty ofextending his comment somewhat, since I think that slot structure needsto be taken into account. The problem is basically one of how to handleclass or type equivalence of two CLOS objects in FASL files. When thetwo objects are FASLed back in, when will their classes be the same? Because of the restrictions on EQ and EQL, the class objects, themselves,cannot be FASLed out because they are not guaranteed to be EQL when FASLed back in. This solution is impractical in any case, since it impliesFASLing out the entire metaobject structure at compile time just to savea single object. Also, name equivalence only (i.e. the names of theclasses are the same) may not be sufficient, because the number and names ofslots might be changed, and, in order to FASL the object in, there mustbe at least as many slots as their were when it was FASLed out. Havingthe same slot names is probably also necessary, since it allows a logicalmapping between the slot contents in the FASL file and the object in memory,as well as the physical constraint of having enough slots to handle theslot contents. Note that, again, EQLness of slot descriptor objects, orany other solution not involving symbols won't work. Requiring the sameclass precedence list, or that the inheritance of slots match strikesme as too restrictive, though I could see arguments why it would be desirable.Alternatively, the class redefinition protocol could be put to good use to allow the object to redefine its class if the number and names of slots didn'tmatch. In that case, name equivalence of classes is the only requirement.Note that this solution handles anonymous classes fine, but not instancesof anonymous classes. In particular, two instances of the same anonymousclass which are FASLed out then in cannot ever have a class object which is EQor EQL, since the FASL in code will create two separate instances of the anonymous class. The only way around this problem is to either change thesemantics of EQ and EQL for CLOS objects or to treat CLOS classes separatelyduring FASDUMP. Using class and slot name equivalence or just class nameequivalence with the redefinition protocol coming into play when there isa mismatch between the slot structures seems like an easier solution.				jak*start*01421 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 10:07:44 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 6 Jan 89  10:06:01 PSTReceived: by ti.com id AA02485; Fri, 6 Jan 89 12:03:52 CSTReceived: from Kelvin by tilde id AA01454; Fri, 6 Jan 89 11:52:41 CSTMessage-Id: <2809101212-8623747@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 6 Jan 89 11:53:32 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: gz@spt.entity.com (Gail Zacharias)Cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@sail.stanford.eduSubject: Re: Issue: LOAD-OBJECTS (Version 1)In-Reply-To: Msg of 6 Jan 89 11:44:25 EST (Fri) from gz@spt.entity.com (Gail Zacharias)> Defstruct needs a :LOAD-FUNCTION (or whatever) option, and a rule for how> you get the simple slot-recreation function. Rather than adding more options to DEFSTRUCT, I'm more inclined to thinkthat the :PRINT-FUNCTION option is obsolete now that you can do  (DEFMETHOD PRINT-OBJECT ...)>   I still think that it's going to> be awkward and confusing for this to default differently from :PRINT-FUNCTION> or :CONSTRUCTOR (both of which give you a default function if not specified),Maybe; on the Explorer, structures are already dumpable by treating themlike arrays, and I haven't noticed any problems caused by this.*start*02005 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 21:25:55 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Jan 89  21:25:37 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 516898; Sat 7-Jan-89 00:23:23 ESTDate: Sat, 7 Jan 89 00:22 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: LOAD-OBJECTS (Version 1)To: David N Gray <Gray@DSG.csc.ti.com>, Gail Zacharias <gz@spt.entity.com>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <2809101212-8623747@Kelvin>Message-ID: <19890107052254.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 6 Jan 89  11:53:32 CST    From: David N Gray <Gray@DSG.csc.ti.com>    > Defstruct needs a :LOAD-FUNCTION (or whatever) option, and a rule for how    > you get the simple slot-recreation function.     Rather than adding more options to DEFSTRUCT, I'm more inclined to think    that the :PRINT-FUNCTION option is obsolete now that you can do      (DEFMETHOD PRINT-OBJECT ...)I agree.  The old way using DEFSTRUCT options is so irregular and kludgy.    >   I still think that it's going to    > be awkward and confusing for this to default differently from :PRINT-FUNCTION    > or :CONSTRUCTOR (both of which give you a default function if not specified),    Maybe; on the Explorer, structures are already dumpable by treating them    like arrays, and I haven't noticed any problems caused by this.Since that's true in Symbolics Genera also, by reasoning from current practiceI could easily be convinced that the default method for STRUCTURE-OBJECT shouldjust save the structure name and slot values, rather than signalling an error.That's fine for compatibility.  What I really care about is that the defaultmethod for STANDARD-OBJECT must signal an error.*start*02725 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 21:28:03 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Jan 89  21:27:47 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 516901; Sat 7-Jan-89 00:26:41 ESTDate: Sat, 7 Jan 89 00:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 1)To: Gail Zacharias <gz@spt.entity.com>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8901061144.AA16434@spt.entity.com>Message-ID: <19890107052613.9.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 6 Jan 89 11:44:25 EST (Fri)    From: gz@spt.entity.com (Gail Zacharias)    I take it the form returned by MAKE-LOAD-FORM is walked again by the    file compiler, and it's the user's responsibility to avoid circularity    (as in (defmethod make-load-form ((x y)) `',x) or equivalent multi-level    examples).  If so, this should be stated.I'm not sure what "walked" means, but it wouldn't be useful if the formreturned by MAKE-LOAD-FORM wasn't allowed to contain objects for whichMAKE-LOAD-FORM must be called.  Also you're right that if the user causesinfinite recursion the process won't terminate.  We shouldn't assume thereader can figure these things out on his own, so I'll say something whenI edit the writeup.    It would be useful to make the simple slot-recreation function available as    part of the language.  Something like       (slot-reconstruct-form x) -> (make-instance '<class-name> :a <a> ...)    so they can do       (defmethod make-load-form ((x my-class)) (slot-reconstruct-form x))    The reason for this, aside from making things simpler for users doing    simple things, is that the obvious MAKE-LOAD-FORM doesn't work well with    inheritance.  That is, if a user writes      (defclass person ()	 ((name :reader person-name)	  (age :reader person-age)))      (defmethod make-load-form ((jrandom person))	 `(make-instance ',(class-name (class-of jrandom))			:name ',(person-name jrandom)			:age ',(person-age jrandom)))    as recommended by the examples, and then does       (defclass astronaut (person)	  ((helmet-size :initarg 17)))    without specifing a make-load-form, then he's going to quietly lose dumping    astronauts in a very difficult to detect way.I was thinking that CLOS metaobjects made slot-reconstruct-form so easyto write on one's own that there was no reason to build it in.  But perhapsGray's example shows that I was underestimating the complexity.*start*12188 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 14:54:28 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Jan 89  14:53:53 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 521325; Fri 13-Jan-89 17:52:09 ESTDate: Fri, 13 Jan 89 17:52 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 2)To: CL-Cleanup@SAIL.STANFORD.EDUcc: Common-Lisp-Object-System@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDUMessage-ID: <19890113225201.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Here is the updated version of this.  Sorry it took so long.I will bring a few copies of this with me to the meeting.Issue:         LOAD-OBJECTSReferences:    noneRelated issues: LOAD-TIME-EVAL,                CONSTANT-COMPILABLE-TYPES,                CONSTANT-CIRCULAR-COMPILATIONCategory:      ADDITIONForum:         CleanupEdit history:  Version 1, 2-Jan-89, by Moon (for discussion)               Version 2, 13-Jan-89, by Moon (draft updated from discussion)Problem description:  Common Lisp doesn't provide any way to use an object of a user-defined  type (defined with DEFCLASS or DEFSTRUCT) as a constant in a program  compiled with COMPILE-FILE.  The problem is that LOAD has to be able  to "reconstruct" an equivalent object when the compiled-code file is  loaded, but the programmer has no way to tell LOAD how to do that.Proposal (LOAD-OBJECTS:MAKE-LOAD-FORM):            Define a new generic function named MAKE-LOAD-FORM, which takes one  argument and returns two values.  The argument is an object that is  referenced as a constant or as a self-evaluating form in a file being  compiled by COMPILE-FILE.  The objective is to enable LOAD to  construct an equivalent object.  The first value, called the "creation form," is a form that, when  evaluated at load time, should return an object that is equivalent to  the argument.  The exact meaning of "equivalent" depends on the type  of object and is up to the programmer who defines a method for  MAKE-LOAD-FORM.  This is the same type of equivalence discussed  in issue CONSTANT-COMPILABLE-TYPES.  The second value, called the "initialization form," is a form that,  when evaluated at load time, should perform further initialization of  the object.  The value returned by the initialization form is ignored.  If the MAKE-LOAD-FORM method returns only one value, the  initialization form is NIL, which has no effect.  If the object used  as the argument to MAKE-LOAD-FORM appears as a constant in the  initialization form, at load time it will be replaced by the  equivalent object constructed by the creation form; this is how the  further initialization gains access to the object.  Both the creation form and the initialization form can contain  references to objects of user-defined types (defined precisely below).  However, there must not be any circular dependencies in creation forms.  An example of a circular dependency is when the creation form for the  object X contains a reference to the object Y, and the creation form  for the object Y contains a reference to the object X.  A simpler  example would be when the creation form for the object X contains  a reference to X itself.  Initialization forms are not subject to  any restriction against circular dependencies, which is the entire  reason that initialization forms exist.  See the example of circular  data structures below.  The creation form for an object is always evaluated before the  initialization form for that object.  When either the creation form or  the initialization form references other objects of user-defined types  that have not been referenced earlier in the COMPILE-FILE, the  compiler collects all of the creation forms together and collects all  of the initialization forms together.  All of the creation forms are  evaluated before any of the initialization forms.  The order of  evaluation of the creation forms is unspecified except when the  ordering is forced by data dependencies.  The order of evaluation of  the initialization forms is unspecified.  While these creation and initialization forms are being evaluated, the  objects are possibly in an uninitialized state, analogous to the state  of an object between the time it has been created by ALLOCATE-INSTANCE  and it has been processed fully by INITIALIZE-INSTANCE.  Programmers  writing methods for MAKE-LOAD-FORM must take care in manipulating  objects not to depend on slots that have not yet been initialized.  It is unspecified whether LOAD calls EVAL on the forms or does some  other operation that has an equivalent effect.  For example, the  forms might be translated into different but equivalent forms and  then evaluated, they might be compiled and the resulting functions  called by LOAD, or they might be interpreted by a special-purpose  interpreter different from EVAL.  All that is required is that the  effect be equivalent to evaluating the forms.  COMPILE-FILE calls MAKE-LOAD-FORM on any object that is referenced as  a constant or as a self-evaluating form, if the object's metaclass is  STANDARD-CLASS, STRUCTURE-CLASS, any user-defined metaclass (not a  subclass of BUILT-IN-CLASS), or any of a possibly-empty  implementation-defined list of other metaclasses.  COMPILE-FILE will  only call MAKE-LOAD-FORM once for any given object (compared with EQ)  within a single file.  It is valid for user programs to call MAKE-LOAD-FORM in other  circumstances.  The function MAKE-LOAD-FORM-USING-SLOTS can be useful in user-written  MAKE-LOAD-FORM methods.  Its first argument is the object.  Its  optional second argument is a list of the names of the slots to  preserve; it defaults to all of the local slots.  MAKE-LOAD-FORM-USING-SLOTS returns forms that construct an equivalent  object using MAKE-INSTANCE and SETF of SLOT-VALUE for slots with  values, or SLOT-MAKUNBOUND for slots without values, or using other  functions of equivalent effect.  MAKE-LOAD-FORM-USING-SLOTS returns  two values, thus it can deal with circular structures.  The default MAKE-LOAD-FORM method for STANDARD-OBJECT signals an  error.  The default MAKE-LOAD-FORM method for STRUCTURE-OBJECT returns forms  that construct an equivalent structure based on the structure name and  the slot values.  This might be written using  MAKE-LOAD-FORM-USING-SLOTS, but that is not required.Examples:  ;; Example 1  (defclass my-class ()     ((a :initarg :a :reader my-a)      (b :initarg :b :reader my-b)      (c :accessor my-c)))  (defmethod shared-initialize ((self my-class) ignore &rest ignore)    (unless (slot-boundp self 'c)      (setf (my-c self) (some-computation (my-a self) (my-b self)))))  (defmethod make-load-form ((self my-class))    `(make-instance ',(class-name (class-of self))                    :a ',(my-a self) :b ',(my-b self)))  In this example, an equivalent instance of my-class is reconstructed  by using the values of two of its slots.  The value of the third slot  is derived from those two values.  Another way to write the last form in the above example would have been  (defmethod make-load-form ((self my-class))     (make-load-form-using-slots self '(a b)))  ;; Example 2  (defclass my-frob ()     ((name :initarg :name :reader my-name)))  (defmethod make-load-form ((self my-frob))    `(find-my-frob ',(my-name self) :if-does-not-exist :create))  In this example, instances of my-frob are "interned" in some way.  An equivalent instance is reconstructed by using the value of the  name slot as a key for searching existing objects.  In this case  the programmer has chosen to create a new object if no existing  object is found; alternatively she could have chosen to signal an  error in that case.  ;; Example 3  (defclass tree-with-parent () ((parent :accessor tree-parent)                                 (children :initarg :children)))  (defmethod make-load-form ((x tree-with-parent))    (values      ;; creation form      `(make-instance ',(class-of x) :children ',(slot-value x 'children))      ;; initialization form      `(setf (tree-parent ',x) ',(slot-value x 'parent))))  In this example, the data structure to be dumped is circular, because  each parent has a list of its children and each child has a reference  back to its parent.  Suppose make-load-form is called on one object in  such a structure.  The creation form creates an equivalent object and  fills in the children slot, which forces creation of equivalent  objects for all of its children, grandchildren, etc.  At this point  none of the parent slots have been filled in.  The initialization form  fills in the parent slot, which forces creation of an equivalent  object for the parent if it was not already created.  Thus the entire  tree is recreated at load time.  At compile time, MAKE-LOAD-FORM is  called once for each object in the true.  All of the creation forms  are evaluated, in unspecified order, and then all of the  initialization forms are evaluated, also in unspecified order.Rationale:  Only the programmer who designed a class can know the correct  way to reconstruct objects of that class at load time, therefore  the reconstruction should be controlled by a generic function.  Using EVAL as the interface for telling LOAD what to do provides  full generality.  MAKE-LOAD-FORM returns two values so that circular structures can  be handled.  If CONSTANT-CIRCULAR-COMPILATION is rejected,  MAKE-LOAD-FORM will only return one value, although implementations  that make an extension to support circular constants will probably  also make the extension to accept two values from MAKE-LOAD-FORM.  A default method, such as one that makes an object whose class has the  same name and whose slots have equivalent contents, is not supplied  for DEFCLASS-defined objects, because this is inappropriate for many  objects and because it is easy to write for those objects where it is  appropriate.  The function MAKE-LOAD-FORM-USING-SLOTS makes it even  easier to write.  MAKE-LOAD-FORM has a natural resemblance to PRINT-OBJECT, as a hook  for the programmer to control the system's actions.Current practice:  Symbolics Flavors has something like this, but under a different name.  The name Symbolics uses is not suitable for standardization.  JonL reports that Lucid is getting more and more requests for this.Cost to Implementors:  This seems like only a few one-line changes in the compiled-code  file writer and reader.  MAKE-LOAD-FORM-USING-SLOTS is a couple  dozen lines of code, assuming the presence of the CLOS metaobject  protocol or an implementation-dependent equivalent.Cost to Users:  None.Cost of non-adoption:  Serious impairment of the ability to use extended-type objects.  Each  implementation will probably make up its own version of this as an  extension.Performance impact:  None.Benefits:  See Cost of non-adoption.Esthetics:  No significant positive or negative impact.Discussion:  It would be possible to define an additional level of protocol that  allows multiple classes to contribute to the reconstruction of an  object, combining initialization arguments contributed by each class.  Since a user can easily define that in terms of MAKE-LOAD-FORM without  modifying the Lisp system, it is not being proposed now.  Any type that has a read syntax is likely to appear as a quoted  constant or inside a quoted constant.  Pathnames are one example, user  programs often define others.  Also many implementations provide a way  to create a compiled-code file full of data (rather than compiled Lisp  programs), and such data probably include extended-type objects.  Moon supports this.  David Gray and John Rose made major contributions  to the discussion that produced this improved version 2 proposal.*start*01995 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 16:02:50 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Jan 89  16:02:32 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 521384; Fri 13-Jan-89 19:00:48 ESTDate: Fri, 13 Jan 89 19:00 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 2)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDUIn-Reply-To: <19890113225201.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <890113190027.7.KMP@BOBOLINK.SCRC.Symbolics.COM>This looks mostly very good, but ...I'd like to see a name attached to the default function for makingstructure load forms, since you're requiring it to exist anyway,and also since there might be reason to need to revert to using itin some structure class for which the method is shadowed by a superior class that was not `thinking ahead.'[I call this problem the `DESCRIBE problem,' since the analagous problem comes up there, too.]I also think there needs to be a rationale given to making thesefunctions not be the default. My personal feeling is that if it'sundefined for structures, it should be undefined for instances, and viceversa. In my mind, they serve the same conceptual purpose, and differonly in degree of efficiency and syntax of interface. For me, they donot differ in weird ways like whether EQUAL or EQUALP should treat themdifferently, or whether MAKE-LOAD-FORM should know how to dump them.I think the argument you give for not having a default instance-dumpingstrategy applies equally to struct-dumping, so if you're going to makethem differ, you need to say what your reasoning is.*start*01959 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 16:10:40 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Jan 89  16:02:32 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 521384; Fri 13-Jan-89 19:00:48 ESTDate: Fri, 13 Jan 89 19:00 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 2)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDUIn-Reply-To: <19890113225201.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <890113190027.7.KMP@BOBOLINK.SCRC.Symbolics.COM>This looks mostly very good, but ...I'd like to see a name attached to the default function for makingstructure load forms, since you're requiring it to exist anyway,and also since there might be reason to need to revert to using itin some structure class for which the method is shadowed by a superior class that was not `thinking ahead.'[I call this problem the `DESCRIBE problem,' since the analagous problem comes up there, too.]I also think there needs to be a rationale given to making thesefunctions not be the default. My personal feeling is that if it'sundefined for structures, it should be undefined for instances, and viceversa. In my mind, they serve the same conceptual purpose, and differonly in degree of efficiency and syntax of interface. For me, they donot differ in weird ways like whether EQUAL or EQUALP should treat themdifferently, or whether MAKE-LOAD-FORM should know how to dump them.I think the argument you give for not having a default instance-dumpingstrategy applies equally to struct-dumping, so if you're going to makethem differ, you need to say what your reasoning is.*start*02622 00024 US Sender: CL-Compiler-mailer%SAIL.Stanford:EDU:XeroxDate: 15 Dec 88 19:30Subject: dumping weird objects to compiled filesFrom: donc%vaxa.isi:EDU:XeroxTo: common-lisp%sail.stanford:EDU:Xerox, cl-compiler%sail.stanford:EDU:Xeroxcc: lwolf%franz.uucp%berkeley:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: common-lisp@sail.stanford.edu, cl-compiler@sail.stanford.eduCc: lwolf%franz.uucp@berkeley.eduSubject: dumping weird objects to compiled filesFrom: Don Cohen <donc@vaxa.isi.edu>Return-Path: <CL-Compiler-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 DEC 88 19:30:25 PSTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 15 Dec 88  18:53:10 PSTPosted-Date: Thu, 15 Dec 88 18:52:28 PSTMessage-Id: <8812160252.AA06530@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.59/5.51)	id AA06530; Thu, 15 Dec 88 18:52:31 PSTOriginal-Date: Thu, 15 Dec 88 18:52:28 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThe commonlisp spec is quite vague on what exactly the compilershould do and provides no control over how or whether strangeobjects can be dumped at all.  However, in the case of structuresit does provide for a print function.  Suppose I have a functionF that uses a macro M which expands into some structure of type S.1. If I give S a print function, can I expect that when I compile Fto a file, that print function will be used to write something tothe compiled file that will be read to return the "corresponding"object when the file is loaded?  (I'm interested in justificationsfor either answer.)  The other possibility is that the compiler would ignore the print function and dump something that would, when loaded, create a structure of type S and fill its slots with objects that were recursively dumped.  If I could count on my print function being used, I could arrange for it to print something that would "do the right thing".2. If you don't think that my expectation is justified, do youthink the commonlisp spec ought to say that it is (thereby makingit so).This "trick" would allow us to write a macro that allows macrosto generate the analog of #, which I think is a feature sorelymissed in commonlisp.  This in turn would go a long way towardsolving what I regard as a problem with the spec - that EQUALvalues may be identified.  This is a solution just because itreturns control over what things are EQ to the user, who knowswhich things he wants to be EQ, which things he does NOT want EQand which don't matter.*start*04717 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 20:58:37 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 13 Jan 89  20:58:12 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA04397; Fri, 13 Jan 89 20:59:34 PSTReceived: from lukasiewicz.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA22496; Fri, 13 Jan 89 20:56:15 PSTReceived: by lukasiewicz.sun.com (4.0/SMI-4.0)	id AA18401; Fri, 13 Jan 89 20:58:49 PSTDate: Fri, 13 Jan 89 20:58:49 PSTFrom: jrose@Sun.COM (John Rose)Message-Id: <8901140458.AA18401@lukasiewicz.sun.com>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Fri, 13 Jan 89 17:52 EST <19890113225201.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 2)  ...     The creation form for an object is always evaluated before the     initialization form for that object.  When either the creation form or     the initialization form references other objects of user-defined types     that have not been referenced earlier in the COMPILE-FILE, the     compiler collects all of the creation forms together and collects all     of the initialization forms together.  All of the creation forms are     evaluated before any of the initialization forms.  The order of     evaluation of the creation forms is unspecified except when the     ordering is forced by data dependencies.  The order of evaluation of     the initialization forms is unspecified.  ...Why does the proposal restrict the evaluation initialization forms tosuch a late time?  Data dependencies would allow an object X'sinitialization form to be executed any time after X's creation form hadfinished.  Is there a reason to be more strict?  I can't think of one,but if there is one, it should be stated on the rationale.Actually, it would be better (and no more difficult, it seems to me) tobe strict in the other direction: Objects should be initialized as earlyas possible, and hence at a deterministic time.  This would allow nodesin non-circular structures to be built out of fully initialized subparts,which is clearly something an application could need.Here's what your paragraph would look like, given that point:  The creation form for an object X is always fully evaluated before the  initialization form for that object.  This evaluation includes the  evaluation of the creation form of any user-defined object Y contained  in X's creation form, and will also include the evaluation of Y's  initialization form, if X and Y are not part of a circular chain of  initialization forms.  Any circular substructures of X will be fully  initialized.  Initialization forms of circular structures are  evaluated in an implementation-defined order, subject to the previous  restrictions.  These rules are intended to ensure that initialization  follows creation as quickly as possible, subject to data flow.Under these rules, noncircular data structures will be treated as ifall the initialization forms will immediately follow the creationforms this way:	(eval `(let ((obj ,<creation-form>))	         ,(subst 'obj <original-object> <initialization-form>)		 obj))Furthermore, circular sub-structures will not impair the timelyinitialization of non-circular containing structures.  Such guaranteeswill give programmers a sense of security in breaking out as muchprocessing as possible into the initialization form.If this point of view is not adopted, a laissez-faire position is probablybetter, and I think your paragraph above could be deleted, or rewritten thus:  The creation form for an object is always fully evaluated before the  initialization form for that object.  This evaluation includes the  evaluation of creation forms of any user-defined objects contained in  the creation form, and may or may not include the evaluation of  initialization forms.  However, when a "top-level object" is loaded,  all creation and initialization forms of that object must be fully  evaluated before any further loading actions are taken.  These rules  are intended to allow implementations a high degree of freedom in  ordering the evaluation of creation and initialization forms, subject  to the requirements of data flow.This paragraph needs to define the the specially-treated "top-level object",which seems to be a concept implicit in your original paragraph.  But I'drather see my first point adopted, and be done with top-level objects.				-- John*start*03105 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 13:01:07 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 9 Mar 89  13:01:40 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 554005; Thu 9-Mar-89 15:58:57 ESTDate: Thu, 9 Mar 89 15:58 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: LOAD-OBJECTS (Version 2)To: David N Gray <Gray@DSG.csc.ti.com>cc: Common-Lisp-Object-System@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDUIn-Reply-To: <2809731258-5200907@Kelvin>Message-ID: <19890309205844.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 13 Jan 89  18:54:18 CST    From: David N Gray <Gray@DSG.csc.ti.com>    This looks good.  The only thing I have doubts about is:    >   The function MAKE-LOAD-FORM-USING-SLOTS can be useful in user-written    >   MAKE-LOAD-FORM methods.  Its first argument is the object.  Its    >   optional second argument is a list of the names of the slots to    >   preserve; it defaults to all of the local slots.    >   MAKE-LOAD-FORM-USING-SLOTS returns forms that construct an equivalent    >   object using MAKE-INSTANCE and SETF of SLOT-VALUE for slots with    >   values, or SLOT-MAKUNBOUND for slots without values, or using other    >   functions of equivalent effect.     Rather than having the second argument default to a list of all instance    slots, it might be better to consider two separate cases:      1. If a second argument is supplied, then MAKE-INSTANCE will be used to	 create the object, (using INITIALIZE-INSTANCE to default the slot	 values), and then the designated slots will be forced to	 have the proper value.      2. Without a second argument, ALLOCATE-INSTANCE will be used to create	 the object (without invoking INITIALIZE-INSTANCE or	 SHARED-INITIALIZE), and then all the slots will be filled in.    If you are going to specify all of the slot values, then there shouldn't    be a need to compute default values, and it may be undesirable to invoke    INITIALIZE-INSTANCE -- for example, it might complain about missing    required arguments or perform undesired side-effects.I don't think it's a good idea to have such a large deviation in behaviorbased on whether an optional argument is present or not.  What if theargument is present but its value is a list of all the slots?I personally cannot figure out whether calling INITIALIZE-INSTANCE whenit's not wanted, or failing to call it when it is wanted, would causemore unexpected behavior.  I have to resolve that by keeping it simpleso the programmer can figure it out on his own.  So I think it shouldalways create the object with MAKE-INSTANCE.    >   The default MAKE-LOAD-FORM method for STANDARD-OBJECT signals an    >   error.    Wouldn't it be permissible to just not have a default method, so that a    "no applicable method" error is signalled?Agreed.*start*02380 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 13:36:57 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 9 Mar 89  13:25:46 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 554041; Thu 9-Mar-89 16:22:52 ESTDate: Thu, 9 Mar 89 16:22 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 2)To: John Rose <jrose@Sun.COM>cc: CL-Cleanup@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDUIn-Reply-To: <8901140458.AA18401@lukasiewicz.sun.com>Message-ID: <19890309212238.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 13 Jan 89 20:58:49 PST    From: jrose@Sun.COM (John Rose)      ...	 The creation form for an object is always evaluated before the	 initialization form for that object.  When either the creation form or	 the initialization form references other objects of user-defined types	 that have not been referenced earlier in the COMPILE-FILE, the	 compiler collects all of the creation forms together and collects all	 of the initialization forms together.  All of the creation forms are	 evaluated before any of the initialization forms.  The order of	 evaluation of the creation forms is unspecified except when the	 ordering is forced by data dependencies.  The order of evaluation of	 the initialization forms is unspecified.      ...    Why does the proposal restrict the evaluation initialization forms to    such a late time?  Data dependencies would allow an object X's    initialization form to be executed any time after X's creation form had    finished.    Actually, it would be better (and no more difficult, it seems to me) to    be strict in the other direction: Objects should be initialized as early    as possible, and hence at a deterministic time.  This would allow nodes    in non-circular structures to be built out of fully initialized subparts,    which is clearly something an application could need.Good point.  I've modified the proposal accordingly, although I did not useyour exact wording.  Of course the time is not fully determinstic, butit's more deterministic than in version 2 of the proposal.*start*13965 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 13:52:50 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 9 Mar 89  13:29:07 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 554052; Thu 9-Mar-89 16:26:35 ESTDate: Thu, 9 Mar 89 16:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 3)To: CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.edu, Common-Lisp-Object-System@sail.stanford.eduMessage-ID: <19890309212623.2.MOON@EUPHRATES.SCRC.Symbolics.COM>At Kauai I was asked to keep working on this and come up with a modifiedversion based on comments received.  Here it is.  I hope this is readyfor voting so we can clear it out of the way.Issue:         LOAD-OBJECTSReferences:    noneRelated issues: LOAD-TIME-EVAL,                CONSTANT-COMPILABLE-TYPES,                CONSTANT-CIRCULAR-COMPILATIONCategory:      ADDITIONForum:         CleanupEdit history:  Version 1, 2-Jan-89, by Moon (for discussion)               Version 2, 13-Jan-89, by Moon (draft updated from discussion)               Version 3,  9-Mar-89, by Moon (changes suggested by discussion)Problem description:  Common Lisp doesn't provide any way to use an object of a user-defined  type (defined with DEFCLASS or DEFSTRUCT) as a constant in a program  compiled with COMPILE-FILE.  The problem is that LOAD has to be able  to "reconstruct" an equivalent object when the compiled-code file is  loaded, but the programmer has no way to tell LOAD how to do that.Proposal (LOAD-OBJECTS:MAKE-LOAD-FORM):            Define a new generic function named MAKE-LOAD-FORM, which takes one  argument and returns two values.  The argument is an object that is  referenced as a constant or as a self-evaluating form in a file being  compiled by COMPILE-FILE.  The objective is to enable LOAD to  construct an equivalent object.  The first value, called the "creation form," is a form that, when  evaluated at load time, should return an object that is equivalent to  the argument.  The exact meaning of "equivalent" depends on the type  of object and is up to the programmer who defines a method for  MAKE-LOAD-FORM.  This is the same type of equivalence discussed  in issue CONSTANT-COMPILABLE-TYPES.  The second value, called the "initialization form," is a form that,  when evaluated at load time, should perform further initialization of  the object.  The value returned by the initialization form is ignored.  If the MAKE-LOAD-FORM method returns only one value, the  initialization form is NIL, which has no effect.  If the object used  as the argument to MAKE-LOAD-FORM appears as a constant in the  initialization form, at load time it will be replaced by the  equivalent object constructed by the creation form; this is how the  further initialization gains access to the object.  Both the creation form and the initialization form can contain  references to objects of user-defined types (defined precisely below).  However, there must not be any circular dependencies in creation forms.  An example of a circular dependency is when the creation form for the  object X contains a reference to the object Y, and the creation form  for the object Y contains a reference to the object X.  A simpler  example would be when the creation form for the object X contains  a reference to X itself.  Initialization forms are not subject to  any restriction against circular dependencies, which is the entire  reason that initialization forms exist.  See the example of circular  data structures below.  The creation form for an object is always evaluated before the  initialization form for that object.  When either the creation form or  the initialization form references other objects of user-defined types  that have not been referenced earlier in the COMPILE-FILE, the  compiler collects all of the creation and initialization forms.  Each  initialization form is evaluated as soon as possible after its  creation form, as determined by data flow.  If the initialization form  for an object does not reference any other objects of user-defined  types that have not been referenced earlier in the COMPILE-FILE, the  initialization form is evaluated immediately after the creation form.  If a creation or initialization form F references other objects of  user-defined types that have not been referenced earlier in the  COMPILE-FILE, the creation forms for those other objects are evaluated  before F, and the initialization forms for those other objects are  also evaluated before F whenever they do not depend on the object  created or initialized by F.  Where the above rules do not uniquely  determine an order of evaluation, which of the possible orders of  evaluation is chosen is unspecified.  While these creation and initialization forms are being evaluated, the  objects are possibly in an uninitialized state, analogous to the state  of an object between the time it has been created by ALLOCATE-INSTANCE  and it has been processed fully by INITIALIZE-INSTANCE.  Programmers  writing methods for MAKE-LOAD-FORM must take care in manipulating  objects not to depend on slots that have not yet been initialized.  It is unspecified whether LOAD calls EVAL on the forms or does some  other operation that has an equivalent effect.  For example, the  forms might be translated into different but equivalent forms and  then evaluated, they might be compiled and the resulting functions  called by LOAD, or they might be interpreted by a special-purpose  interpreter different from EVAL.  All that is required is that the  effect be equivalent to evaluating the forms.  COMPILE-FILE calls MAKE-LOAD-FORM on any object that is referenced as  a constant or as a self-evaluating form, if the object's metaclass is  STANDARD-CLASS, STRUCTURE-CLASS, any user-defined metaclass (not a  subclass of BUILT-IN-CLASS), or any of a possibly-empty  implementation-defined list of other metaclasses.  COMPILE-FILE will  only call MAKE-LOAD-FORM once for any given object (compared with EQ)  within a single file.  It is valid for user programs to call MAKE-LOAD-FORM in other  circumstances, providing the argument's metaclass is not BUILT-IN-CLASS  or a subclass of BUILT-IN-CLASS.  Define a new function named MAKE-LOAD-FORM-USING-SLOTS, which takes  one required argument and one optional argument and returns two  values.  This can be useful in user-written MAKE-LOAD-FORM methods.  The first argument is the object.  The optional second argument is a  list of the names of the slots to preserve; it defaults to all of the  local slots.  MAKE-LOAD-FORM-USING-SLOTS returns forms that construct  an equivalent object using MAKE-INSTANCE and SETF of SLOT-VALUE for  slots with values, or SLOT-MAKUNBOUND for slots without values, or  using other functions of equivalent effect.  MAKE-LOAD-FORM-USING-SLOTS returns two values, thus it can deal with  circular structures.  MAKE-LOAD-FORM-USING-SLOTS works for any object  of metaclass STANDARD-CLASS or STRUCTURE-CLASS.  Whether the result is  useful in an application depends on whether the object's type and slot  contents fully capture the application's idea of the object's state.  MAKE-LOAD-FORM of an object of metaclass STANDARD-CLASS or  STRUCTURE-CLASS for which no user-defined method is applicable signals  an error.  It is valid to implement this either by defining default  methods on STANDARD-OBJECT and STRUCTURE-OBJECT that signal an error  or by having no applicable method for those classes.Examples:  ;; Example 1  (defclass my-class ()     ((a :initarg :a :reader my-a)      (b :initarg :b :reader my-b)      (c :accessor my-c)))  (defmethod shared-initialize ((self my-class) ignore &rest ignore)    (unless (slot-boundp self 'c)      (setf (my-c self) (some-computation (my-a self) (my-b self)))))  (defmethod make-load-form ((self my-class))    `(make-instance ',(class-name (class-of self))                    :a ',(my-a self) :b ',(my-b self)))  In this example, an equivalent instance of my-class is reconstructed  by using the values of two of its slots.  The value of the third slot  is derived from those two values.  Another way to write the last form in the above example would have been  (defmethod make-load-form ((self my-class))     (make-load-form-using-slots self '(a b)))  ;; Example 2  (defclass my-frob ()     ((name :initarg :name :reader my-name)))  (defmethod make-load-form ((self my-frob))    `(find-my-frob ',(my-name self) :if-does-not-exist :create))  In this example, instances of my-frob are "interned" in some way.  An equivalent instance is reconstructed by using the value of the  name slot as a key for searching existing objects.  In this case  the programmer has chosen to create a new object if no existing  object is found; alternatively she could have chosen to signal an  error in that case.  ;; Example 3  (defclass tree-with-parent () ((parent :accessor tree-parent)                                 (children :initarg :children)))  (defmethod make-load-form ((x tree-with-parent))    (values      ;; creation form      `(make-instance ',(class-of x) :children ',(slot-value x 'children))      ;; initialization form      `(setf (tree-parent ',x) ',(slot-value x 'parent))))  In this example, the data structure to be dumped is circular, because  each parent has a list of its children and each child has a reference  back to its parent.  Suppose make-load-form is called on one object in  such a structure.  The creation form creates an equivalent object and  fills in the children slot, which forces creation of equivalent  objects for all of its children, grandchildren, etc.  At this point  none of the parent slots have been filled in.  The initialization form  fills in the parent slot, which forces creation of an equivalent  object for the parent if it was not already created.  Thus the entire  tree is recreated at load time.  At compile time, MAKE-LOAD-FORM is  called once for each object in the true.  All of the creation forms  are evaluated, in unspecified order, and then all of the  initialization forms are evaluated, also in unspecified order.  ;; Example 4  (defstruct my-struct a b c)  (defmethod make-load-form ((s my-struct))     (make-load-form-using-slots s))  In this example, the data structure to be dumped has no special  properties and an equivalent structure can be reconstructed  simply by reconstructing the slots' contents.Rationale:  Only the programmer who designed a class can know the correct  way to reconstruct objects of that class at load time, therefore  the reconstruction should be controlled by a generic function.  Using EVAL as the interface for telling LOAD what to do provides  full generality.  MAKE-LOAD-FORM returns two values so that circular structures can  be handled.  If CONSTANT-CIRCULAR-COMPILATION is rejected,  MAKE-LOAD-FORM will only return one value, although implementations  that make an extension to support circular constants will probably  also make the extension to accept two values from MAKE-LOAD-FORM.  The default for class objects and structures is to signal an error,  rather than picking some particular object reconstruction technique,  because no reconstruction technique is appropriate for all objects.  It only takes two lines of code, as in example 4, to instruct the  compiler to use the technique that most often has been suggested  as the default.  MAKE-LOAD-FORM has a natural resemblance to PRINT-OBJECT, as a hook  for the programmer to control the system's actions.  The order of evaluation rules for creation and initialization forms  eliminate the possibility of partially initialized objects in the  absence of circular structures, and reduce it to the minimum possible  in the presence of circular structures.  This allows nodes in  non-circular structures to be built out of fully initialized subparts.Current practice:  Symbolics Flavors has something like this, but under a different name.  The name Symbolics uses is not suitable for standardization.  JonL reports that Lucid is getting more and more requests for this.Cost to Implementors:  This seems like only a few one-line changes in the compiled-code  file writer and reader.  MAKE-LOAD-FORM-USING-SLOTS is a couple  dozen lines of code, assuming the presence of the CLOS metaobject  protocol or an implementation-dependent equivalent.Cost to Users:  None.Cost of non-adoption:  Serious impairment of the ability to use extended-type objects.  Each  implementation will probably make up its own version of this as an  extension.Performance impact:  None.Benefits:  See Cost of non-adoption.Esthetics:  No significant positive or negative impact.Discussion:  It would be possible to define an additional level of protocol that  allows multiple classes to contribute to the reconstruction of an  object, combining initialization arguments contributed by each class.  Since a user can easily define that in terms of MAKE-LOAD-FORM without  modifying the Lisp system, it is not being proposed now.  Any type that has a read syntax is likely to appear as a quoted  constant or inside a quoted constant.  Pathnames are one example, user  programs often define others.  Also many implementations provide a way  to create a compiled-code file full of data (rather than compiled Lisp  programs), and such data probably include extended-type objects.  Moon supports this.  David Gray and John Rose made major contributions  to the discussion that produced this improved version 2 proposal.*start*02416 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 13:26:53 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 9 Mar 89  13:25:46 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 554041; Thu 9-Mar-89 16:22:52 ESTDate: Thu, 9 Mar 89 16:22 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 2)To: John Rose <jrose@Sun.COM>cc: CL-Cleanup@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDUIn-Reply-To: <8901140458.AA18401@lukasiewicz.sun.com>Message-ID: <19890309212238.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 13 Jan 89 20:58:49 PST    From: jrose@Sun.COM (John Rose)      ...	 The creation form for an object is always evaluated before the	 initialization form for that object.  When either the creation form or	 the initialization form references other objects of user-defined types	 that have not been referenced earlier in the COMPILE-FILE, the	 compiler collects all of the creation forms together and collects all	 of the initialization forms together.  All of the creation forms are	 evaluated before any of the initialization forms.  The order of	 evaluation of the creation forms is unspecified except when the	 ordering is forced by data dependencies.  The order of evaluation of	 the initialization forms is unspecified.      ...    Why does the proposal restrict the evaluation initialization forms to    such a late time?  Data dependencies would allow an object X's    initialization form to be executed any time after X's creation form had    finished.    Actually, it would be better (and no more difficult, it seems to me) to    be strict in the other direction: Objects should be initialized as early    as possible, and hence at a deterministic time.  This would allow nodes    in non-circular structures to be built out of fully initialized subparts,    which is clearly something an application could need.Good point.  I've modified the proposal accordingly, although I did not useyour exact wording.  Of course the time is not fully determinstic, butit's more deterministic than in version 2 of the proposal.*start*14001 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 MAR 89 13:29:32 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 9 Mar 89  13:29:07 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 554052; Thu 9-Mar-89 16:26:35 ESTDate: Thu, 9 Mar 89 16:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 3)To: CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.edu, Common-Lisp-Object-System@sail.stanford.eduMessage-ID: <19890309212623.2.MOON@EUPHRATES.SCRC.Symbolics.COM>At Kauai I was asked to keep working on this and come up with a modifiedversion based on comments received.  Here it is.  I hope this is readyfor voting so we can clear it out of the way.Issue:         LOAD-OBJECTSReferences:    noneRelated issues: LOAD-TIME-EVAL,                CONSTANT-COMPILABLE-TYPES,                CONSTANT-CIRCULAR-COMPILATIONCategory:      ADDITIONForum:         CleanupEdit history:  Version 1, 2-Jan-89, by Moon (for discussion)               Version 2, 13-Jan-89, by Moon (draft updated from discussion)               Version 3,  9-Mar-89, by Moon (changes suggested by discussion)Problem description:  Common Lisp doesn't provide any way to use an object of a user-defined  type (defined with DEFCLASS or DEFSTRUCT) as a constant in a program  compiled with COMPILE-FILE.  The problem is that LOAD has to be able  to "reconstruct" an equivalent object when the compiled-code file is  loaded, but the programmer has no way to tell LOAD how to do that.Proposal (LOAD-OBJECTS:MAKE-LOAD-FORM):            Define a new generic function named MAKE-LOAD-FORM, which takes one  argument and returns two values.  The argument is an object that is  referenced as a constant or as a self-evaluating form in a file being  compiled by COMPILE-FILE.  The objective is to enable LOAD to  construct an equivalent object.  The first value, called the "creation form," is a form that, when  evaluated at load time, should return an object that is equivalent to  the argument.  The exact meaning of "equivalent" depends on the type  of object and is up to the programmer who defines a method for  MAKE-LOAD-FORM.  This is the same type of equivalence discussed  in issue CONSTANT-COMPILABLE-TYPES.  The second value, called the "initialization form," is a form that,  when evaluated at load time, should perform further initialization of  the object.  The value returned by the initialization form is ignored.  If the MAKE-LOAD-FORM method returns only one value, the  initialization form is NIL, which has no effect.  If the object used  as the argument to MAKE-LOAD-FORM appears as a constant in the  initialization form, at load time it will be replaced by the  equivalent object constructed by the creation form; this is how the  further initialization gains access to the object.  Both the creation form and the initialization form can contain  references to objects of user-defined types (defined precisely below).  However, there must not be any circular dependencies in creation forms.  An example of a circular dependency is when the creation form for the  object X contains a reference to the object Y, and the creation form  for the object Y contains a reference to the object X.  A simpler  example would be when the creation form for the object X contains  a reference to X itself.  Initialization forms are not subject to  any restriction against circular dependencies, which is the entire  reason that initialization forms exist.  See the example of circular  data structures below.  The creation form for an object is always evaluated before the  initialization form for that object.  When either the creation form or  the initialization form references other objects of user-defined types  that have not been referenced earlier in the COMPILE-FILE, the  compiler collects all of the creation and initialization forms.  Each  initialization form is evaluated as soon as possible after its  creation form, as determined by data flow.  If the initialization form  for an object does not reference any other objects of user-defined  types that have not been referenced earlier in the COMPILE-FILE, the  initialization form is evaluated immediately after the creation form.  If a creation or initialization form F references other objects of  user-defined types that have not been referenced earlier in the  COMPILE-FILE, the creation forms for those other objects are evaluated  before F, and the initialization forms for those other objects are  also evaluated before F whenever they do not depend on the object  created or initialized by F.  Where the above rules do not uniquely  determine an order of evaluation, which of the possible orders of  evaluation is chosen is unspecified.  While these creation and initialization forms are being evaluated, the  objects are possibly in an uninitialized state, analogous to the state  of an object between the time it has been created by ALLOCATE-INSTANCE  and it has been processed fully by INITIALIZE-INSTANCE.  Programmers  writing methods for MAKE-LOAD-FORM must take care in manipulating  objects not to depend on slots that have not yet been initialized.  It is unspecified whether LOAD calls EVAL on the forms or does some  other operation that has an equivalent effect.  For example, the  forms might be translated into different but equivalent forms and  then evaluated, they might be compiled and the resulting functions  called by LOAD, or they might be interpreted by a special-purpose  interpreter different from EVAL.  All that is required is that the  effect be equivalent to evaluating the forms.  COMPILE-FILE calls MAKE-LOAD-FORM on any object that is referenced as  a constant or as a self-evaluating form, if the object's metaclass is  STANDARD-CLASS, STRUCTURE-CLASS, any user-defined metaclass (not a  subclass of BUILT-IN-CLASS), or any of a possibly-empty  implementation-defined list of other metaclasses.  COMPILE-FILE will  only call MAKE-LOAD-FORM once for any given object (compared with EQ)  within a single file.  It is valid for user programs to call MAKE-LOAD-FORM in other  circumstances, providing the argument's metaclass is not BUILT-IN-CLASS  or a subclass of BUILT-IN-CLASS.  Define a new function named MAKE-LOAD-FORM-USING-SLOTS, which takes  one required argument and one optional argument and returns two  values.  This can be useful in user-written MAKE-LOAD-FORM methods.  The first argument is the object.  The optional second argument is a  list of the names of the slots to preserve; it defaults to all of the  local slots.  MAKE-LOAD-FORM-USING-SLOTS returns forms that construct  an equivalent object using MAKE-INSTANCE and SETF of SLOT-VALUE for  slots with values, or SLOT-MAKUNBOUND for slots without values, or  using other functions of equivalent effect.  MAKE-LOAD-FORM-USING-SLOTS returns two values, thus it can deal with  circular structures.  MAKE-LOAD-FORM-USING-SLOTS works for any object  of metaclass STANDARD-CLASS or STRUCTURE-CLASS.  Whether the result is  useful in an application depends on whether the object's type and slot  contents fully capture the application's idea of the object's state.  MAKE-LOAD-FORM of an object of metaclass STANDARD-CLASS or  STRUCTURE-CLASS for which no user-defined method is applicable signals  an error.  It is valid to implement this either by defining default  methods on STANDARD-OBJECT and STRUCTURE-OBJECT that signal an error  or by having no applicable method for those classes.Examples:  ;; Example 1  (defclass my-class ()     ((a :initarg :a :reader my-a)      (b :initarg :b :reader my-b)      (c :accessor my-c)))  (defmethod shared-initialize ((self my-class) ignore &rest ignore)    (unless (slot-boundp self 'c)      (setf (my-c self) (some-computation (my-a self) (my-b self)))))  (defmethod make-load-form ((self my-class))    `(make-instance ',(class-name (class-of self))                    :a ',(my-a self) :b ',(my-b self)))  In this example, an equivalent instance of my-class is reconstructed  by using the values of two of its slots.  The value of the third slot  is derived from those two values.  Another way to write the last form in the above example would have been  (defmethod make-load-form ((self my-class))     (make-load-form-using-slots self '(a b)))  ;; Example 2  (defclass my-frob ()     ((name :initarg :name :reader my-name)))  (defmethod make-load-form ((self my-frob))    `(find-my-frob ',(my-name self) :if-does-not-exist :create))  In this example, instances of my-frob are "interned" in some way.  An equivalent instance is reconstructed by using the value of the  name slot as a key for searching existing objects.  In this case  the programmer has chosen to create a new object if no existing  object is found; alternatively she could have chosen to signal an  error in that case.  ;; Example 3  (defclass tree-with-parent () ((parent :accessor tree-parent)                                 (children :initarg :children)))  (defmethod make-load-form ((x tree-with-parent))    (values      ;; creation form      `(make-instance ',(class-of x) :children ',(slot-value x 'children))      ;; initialization form      `(setf (tree-parent ',x) ',(slot-value x 'parent))))  In this example, the data structure to be dumped is circular, because  each parent has a list of its children and each child has a reference  back to its parent.  Suppose make-load-form is called on one object in  such a structure.  The creation form creates an equivalent object and  fills in the children slot, which forces creation of equivalent  objects for all of its children, grandchildren, etc.  At this point  none of the parent slots have been filled in.  The initialization form  fills in the parent slot, which forces creation of an equivalent  object for the parent if it was not already created.  Thus the entire  tree is recreated at load time.  At compile time, MAKE-LOAD-FORM is  called once for each object in the true.  All of the creation forms  are evaluated, in unspecified order, and then all of the  initialization forms are evaluated, also in unspecified order.  ;; Example 4  (defstruct my-struct a b c)  (defmethod make-load-form ((s my-struct))     (make-load-form-using-slots s))  In this example, the data structure to be dumped has no special  properties and an equivalent structure can be reconstructed  simply by reconstructing the slots' contents.Rationale:  Only the programmer who designed a class can know the correct  way to reconstruct objects of that class at load time, therefore  the reconstruction should be controlled by a generic function.  Using EVAL as the interface for telling LOAD what to do provides  full generality.  MAKE-LOAD-FORM returns two values so that circular structures can  be handled.  If CONSTANT-CIRCULAR-COMPILATION is rejected,  MAKE-LOAD-FORM will only return one value, although implementations  that make an extension to support circular constants will probably  also make the extension to accept two values from MAKE-LOAD-FORM.  The default for class objects and structures is to signal an error,  rather than picking some particular object reconstruction technique,  because no reconstruction technique is appropriate for all objects.  It only takes two lines of code, as in example 4, to instruct the  compiler to use the technique that most often has been suggested  as the default.  MAKE-LOAD-FORM has a natural resemblance to PRINT-OBJECT, as a hook  for the programmer to control the system's actions.  The order of evaluation rules for creation and initialization forms  eliminate the possibility of partially initialized objects in the  absence of circular structures, and reduce it to the minimum possible  in the presence of circular structures.  This allows nodes in  non-circular structures to be built out of fully initialized subparts.Current practice:  Symbolics Flavors has something like this, but under a different name.  The name Symbolics uses is not suitable for standardization.  JonL reports that Lucid is getting more and more requests for this.Cost to Implementors:  This seems like only a few one-line changes in the compiled-code  file writer and reader.  MAKE-LOAD-FORM-USING-SLOTS is a couple  dozen lines of code, assuming the presence of the CLOS metaobject  protocol or an implementation-dependent equivalent.Cost to Users:  None.Cost of non-adoption:  Serious impairment of the ability to use extended-type objects.  Each  implementation will probably make up its own version of this as an  extension.Performance impact:  None.Benefits:  See Cost of non-adoption.Esthetics:  No significant positive or negative impact.Discussion:  It would be possible to define an additional level of protocol that  allows multiple classes to contribute to the reconstruction of an  object, combining initialization arguments contributed by each class.  Since a user can easily define that in terms of MAKE-LOAD-FORM without  modifying the Lisp system, it is not being proposed now.  Any type that has a read syntax is likely to appear as a quoted  constant or inside a quoted constant.  Pathnames are one example, user  programs often define others.  Also many implementations provide a way  to create a compiled-code file full of data (rather than compiled Lisp  programs), and such data probably include extended-type objects.  Moon supports this.  David Gray and John Rose made major contributions  to the discussion that produced this improved version 2 proposal.*start*05082 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 MAR 89 16:57:44 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 11 Mar 89  16:58:32 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA01066g; Sat, 11 Mar 89 16:51:27 PSTReceived: by challenger id AA05936g; Sat, 11 Mar 89 16:46:51 PSTDate: Sat, 11 Mar 89 16:46:51 PSTFrom: Richard P. Gabriel <rpg@lucid.com>Message-Id: <8903120046.AA05936@challenger>To: CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.edu, Common-Lisp-Object-System@sail.stanford.eduSubject: Issue: LOAD-OBJECTS (Version 3)I was a little surprised to see that this proposal talks about loadforms instead of load functions (which goes to show how much I've beenpaying attention). After some thought and consultation with Moon, Irealized that part of it was that compiled functions could not becompiled constants. If we were to allow such constants, I would proposewe consider the alternative of load functions.The model would be that when objects are being either prepared fordumping or are being dumped, at certain points the generic functionMAKE-LOAD-FUNCTION would be invoked on objects that needed to bere-created later.  It would return either one or two functions. Thefirst is a function of 0 arguments that does the initial creation, andthe second is (if present) a function of 1 argument, which is theinitializer. If present it is applied to the created instance. Thissimplifies the naming problem in the current proposal, which, whileclever, is a little unpalatable. In particular, it introduces yetanother way to think about variables.I think people will find the macro approach (the current approach)baroque, partly because the approach is best understood by thinking ofan input phase to a compiler or some such program, rather than bythinking about an output phase when everything has already been supposedlycreated. For example, when I read the current proposal, I imagined itin the FASDUMP phase.One drawback of my proposal is that the function approach is a littlemore verbose in some cases. I also think it is subject to morecircularity errors by novices than the macro approach.  On the otherhand, the functional approach makes one think about the issues alittle harder when writing the code, which is possibly a good thing.Here are the examples in the macro proposal:  ;; Example 1  (defclass my-class ()     ((a :initarg :a :reader my-a)      (b :initarg :b :reader my-b)      (c :accessor my-c)))  (defmethod shared-initialize ((self my-class) ignore &rest ignore)    (unless (slot-boundp self 'c)      (setf (my-c self) (some-computation (my-a self) (my-b self)))))  (defmethod make-load-function ((self my-class))    (let ((name (class-name (class-of self)))	  (a (my-a self))	  (b (my-b self)))      #'(lambda () (make-instance name :a a :b b))))Here the computations of NAME, A, and B must be outside the function#'(lambda ...) so that they get evaluated in the right environment toavoid a circular (self-referential) structure. For this to work, thefaslout of #'(lambda ...) must also notice any constants or suchthings that need similar treatment, which will get NAME, A, and B, ifneeded.   ;; Example 2  (defclass my-frob ()     ((name :initarg :name :reader my-name)))  (defmethod make-load-function ((self my-frob))    (let ((name (my-name self)))      #'(lambda () (find-my-frob name :if-does-not-exist :create))))Maybe NAME is not something to worry about, but SELF cannot appear inthe #'(lambda ...).  ;; Example 3 (expanded to do a hairy thing that cannot be easily done  ;; in the macro approach).  (defclass tree-with-parent () ((parent :accessor tree-parent)				 (curious-facts :accessor tree-foma)                                 (children :initarg :children)))  (defmethod make-load-function ((x tree-with-parent))    (let ((class (class-of x))	  (children (slot-value x 'children))	  (random-info-at-dump-time (compute-random-info x))	  (more-random-info-at-creation-time ())	  (parent (slot-value x 'parent)))      (flet ((initialize (x)	       (setf (tree-foma x)		     (combine-info random-info-at-dump-time				   random-info-at-creation-time))	       (setf (tree-parent x) parent)))	(values	  ;; creation 	  #`(lambda ()	      (setq more-random-info-at-creation-time	      		    (compute-more-random-info))	      (make-instance class :children children))	  ;; initialization	  #'initialize))))One can imagine the shared lexical environment of the creator and initializerbeing a high-bandwidth channel for information, such as the importantinformation passed in the above example.Finally, I wouldn't use the name MAKE-LOAD-FUNCTION-USING-SLOTS,because the structure of the name ...-USING-SLOTS is like...-USING-CLASS, which is named that way to inform the programmer thathe can discriminate on the metaclass. Maybe,MAKE-LOAD-FUNCTION-PRESERVING-SLOTS?				-rpg-*start*01815 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 MAR 89 17:45:11 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 11 Mar 89  17:45:12 PSTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA13023; Sat, 11 Mar 89 18:43:00 -0700Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA00878; Sat, 11 Mar 89 18:42:57 -0700From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8903120142.AA00878@defun.utah.edu>Date: Sat, 11 Mar 89 18:42:56 MSTSubject: Re: Issue: LOAD-OBJECTS (Version 3)To: Richard P. Gabriel <rpg@lucid.com>Cc: CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.edu, Common-Lisp-Object-System@sail.stanford.eduIn-Reply-To: Richard P. Gabriel <rpg@lucid.com>, Sat, 11 Mar 89 16:46:51 PSTI haven't been paying too much attention to this issue either -- I'vebeen trusting Moon to do the right thing on the assumption that heknew more about it than I did.  I think his latest proposal does lookreasonable.  However, if there is disagreement about it, I might aswell suggest yet another alternative:Have two generic functions, not one.  The first would get called bycompile-file and it would return a list of components (or whatever)that are required to reconstruct the object.  The compiler would dumpthis list of objects in its usual way.  The loader would apply thesecond generic function to this list to reconstruct the object.  Itavoids the nasty syntax you object to, doesn't require functions to bedumpable, doesn't require any special support for circular constants,and ought to be real easy to add to the compiler/loader.  (You couldessentially convert the constant into a LOAD-TIME-VALUE expression.)-Sandra-------*start*01067 00024 US Return-Path: <Common-Lisp-Object-System-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 MAR 89 10:31:46 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 12 Mar 89  10:32:40 PSTReceived: from challenger ([192.9.200.17]) by heavens-gate.lucid.com id AA01322g; Sun, 12 Mar 89 10:25:36 PSTReceived: by challenger id AA06637g; Sun, 12 Mar 89 10:20:59 PSTDate: Sun, 12 Mar 89 10:20:59 PSTFrom: Richard P. Gabriel <rpg@lucid.com>Message-Id: <8903121820.AA06637@challenger>To: sandra%defun@cs.utah.eduCc: CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.edu, Common-Lisp-Object-System@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Sat, 11 Mar 89 18:42:56 MST <8903120142.AA00878@defun.utah.edu>Subject: Issue: LOAD-OBJECTS (Version 3)Sandra's idea of two generic functions, one producing components and theother doing construction/further initialization has some merits asidefrom the question of dumping functions. I think we should consider it.			-rpg-*start*03998 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 13:52:02 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 13 Mar 89  13:51:55 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA16534; Mon, 13 Mar 89 11:37:16 PSTReceived: from lukasiewicz.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA20771; Mon, 13 Mar 89 11:32:38 PSTReceived: by lukasiewicz.sun.com (4.0/SMI-4.0)	id AA00318; Mon, 13 Mar 89 11:35:38 PSTDate: Mon, 13 Mar 89 11:35:38 PSTFrom: jrose@Sun.COM (John Rose)Message-Id: <8903131935.AA00318@lukasiewicz.sun.com>To: sandra%defun@cs.utah.eduCc: rpg@lucid.com, CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.edu, Common-Lisp-Object-System@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Sat, 11 Mar 89 18:42:56 MST <8903120142.AA00878@defun.utah.edu>Subject: Issue: LOAD-OBJECTS (Version 3)   From: sandra%defun@cs.utah.edu (Sandra J Loosemore)   Date: Sat, 11 Mar 89 18:42:56 MST  ...   Have two generic functions, not one.  The first would get called by   compile-file and it would return a list of components (or whatever)   that are required to reconstruct the object.  The compiler would dump   this list of objects in its usual way.  The loader would apply the   second generic function to this list to reconstruct the object.  It   avoids the nasty syntax you object to, doesn't require functions to be   dumpable, doesn't require any special support for circular constants,   and ought to be real easy to add to the compiler/loader.  (You could   essentially convert the constant into a LOAD-TIME-VALUE expression.)Two objections here:One is that this scheme cannot support circular constants.  SinceLOAD-OBJECTS is not the issue which determines circular constants, itprobably should not force or presuppose a decision against circularconstants.Supporting circular constants requires two phases of objectconstruction, one which creates at least a valid reference to theobject, and a second one which further initializes the object (at leastby patching in back-references to finish building circularities).In order for your technique to support circular constants, you stillneed #'make-load-form to return two things, not one.  It would returntwo argument lists, and there would be two load-time generic functions.The other objection is that an arglist for a fixed generic function isless general and more complex than an EVAL-able form (or a thunk, as rpgsuggests).  The programmer must coordinate the construction of theargument list with the definition of the method to digest it at loadtime, which is probably on a different page of the source code.  What'sthe advantage to offset the complexity and lack of flexibility?Perhaps method combination within the load-time generic gives a cleanway to modularize the construction of an object of multiple classes?Someone will have to show me an example of this before I believe it.Until then, I think the simplicity of thunks (either EVAL-able orFUNCALL-able) is far preferable.By the way, I also share rpg's preference for functions over forms,because functions are parametrized naturally via captured lexicals,whereas you've got to use backquote to parametrize forms, a moreerror-prone technique.Here's an example which suggests the relative conciseness of the techniques:	;; Using functions:	(defmethod make-load-form ((x myclass))	  (let ((p <pval>) (q <qval>) (r <rval>))	    #'(lambda () <code>)))	;; Using forms:	(defmethod make-load-form ((x myclass))	  `(let ((p ',<pval>) (q ',<qval>) (r ',<rval>))	     <code>))	;; Using a generic:	(defmethod make-load-form ((x myclass))	  `(cookie00012 :p ,<pval> :q ,<qval> :r ,<rval>))	(defmethod load-time-constructor	    ((lf (eql 'cookie00012)) &key p q r &allow-other-keys)	  <code>)   -Sandra   -------					-- John*start*02924 00024 US Return-Path: <CL-Compiler-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 17:44:01 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 13 Mar 89  17:36:36 PSTReceived: by ti.com id AA04345; Mon, 13 Mar 89 19:33:22 CSTReceived: from Kelvin by tilde id AA09130; Mon, 13 Mar 89 19:25:26 CSTMessage-Id: <2814830669-4406064@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 13 Mar 89 19:24:29 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "Richard P. Gabriel" <rpg@lucid.com>Cc: CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.eduSubject: Re: Issue: LOAD-OBJECTS (Version 3)In-Reply-To: Msg of Sat, 11 Mar 89 16:46:51 PST from Richard P. Gabriel <rpg@lucid.com>> I was a little surprised to see that this proposal talks about load> forms instead of load functions (which goes to show how much I've been> paying attention).One advantage of sticking with the load form approach is that it hasalready been implemented and demonstrated to work.> I think people will find the macro approach (the current approach)> baroque, partly because the approach is best understood by thinking of> an input phase to a compiler or some such program, rather than by> thinking about an output phase when everything has already been supposedly> created. For example, when I read the current proposal, I imagined it> in the FASDUMP phase.Think of it as input to the loader.> One drawback of my proposal is that the function approach is a little> more verbose in some cases. I also think it is subject to more> circularity errors by novices than the macro approach.  On the other> hand, the functional approach makes one think about the issues a> little harder when writing the code, which is possibly a good thing.This sounds like a clear disadvantage, without a clear advantage.>   ;; Example 3 (expanded to do a hairy thing that cannot be easily done>   ;; in the macro approach)....> One can imagine the shared lexical environment of the creator and initializer> being a high-bandwidth channel for information, such as the important> information passed in the above example.This example illustrates the following assumptions about dumpingconstants:   1. Lexical closures can be dumped and loaded.  2. Two closures that share the same environment at compile-time will     also share the same environment at load time.  3. The lexical environment as reconstructed by the loader is not     write-protected (meaning that closures are not really constants).  4. It is safe to assume that none of the closed-over variables are     changed between the time the first closure is dumped and the time     the last closure that shares that environment is dumped.It could be argued that all of these would be desirable, but I thinkit's a little late to be biting off that much.*start*02058 00024 US Return-Path: <CL-Compiler-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 MAR 89 18:01:34 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 13 Mar 89  17:54:05 PSTReceived: by ti.com id AA04437; Mon, 13 Mar 89 19:49:49 CSTReceived: from Kelvin by tilde id AA09309; Mon, 13 Mar 89 19:36:34 CSTMessage-Id: <2814831335-4446073@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 13 Mar 89 19:35:35 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: jrose@Sun.COM (John Rose)Cc: sandra%defun@cs.utah.edu, rpg@lucid.com, CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.eduSubject: Re: Issue: LOAD-OBJECTS (Version 3)In-Reply-To: Msg of Mon, 13 Mar 89 11:35:38 PST from jrose@Sun.COM (John Rose)> One is that this scheme cannot support circular constants.I second the objection.> By the way, I also share rpg's preference for functions over forms,> because functions are parametrized naturally via captured lexicals,> whereas you've got to use backquote to parametrize forms, a more> error-prone technique.> > Here's an example which suggests the relative conciseness of the techniques:> > 	;; Using functions:> 	(defmethod make-load-form ((x myclass))> 	  (let ((p <pval>) (q <qval>) (r <rval>))> 	    #'(lambda () <code>)))> > 	;; Using forms:> 	(defmethod make-load-form ((x myclass))> 	  `(let ((p ',<pval>) (q ',<qval>) (r ',<rval>))> 	     <code>))I don't think that's a completely fair comparison because the LET isrequired for the function approach, but would usually not be needed withthe forms approach:	;; Using functions:	(defmethod make-load-form ((x myclass))	  (let ((p <pval>) (q <qval>) (r <rval>))	    #'(lambda () (make-mine p q r))))	;; Using forms:	(defmethod make-load-form ((x myclass))          `(make-mine ',<pval> ',<qval> ',<rval>))This is a very simple use of back-quote, while the function approach iserror-prone because it would be too easy to forget to do the LETbinding.*start*13848 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Mar-89 23:45:51 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 23:45:46 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  23:30:04 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 MAR 89 23:27:37 PSTDate: 16 Mar 89 23:26 PSTFrom: masinter.paSubject: Issue: LOAD-OBJECTS (Version 3)To: x3j13@sail.stanford.eduline-fold: NOMessage-ID: <890316-232737-6946@Xerox>Version 1 was distributed in hardcopy form and discussedat the January 1989 meeting.Discussion so far has been considering alternatives ofload functions rather than load forms, or having twogeneric functions.!Issue:         LOAD-OBJECTSReferences:    noneRelated issues: LOAD-TIME-EVAL,                CONSTANT-COMPILABLE-TYPES,                CONSTANT-CIRCULAR-COMPILATIONCategory:      ADDITIONForum:         CleanupEdit history:  Version 1, 2-Jan-89, by Moon (for discussion)               Version 2, 13-Jan-89, by Moon (draft updated from discussion)               Version 3,  9-Mar-89, by Moon (changes suggested by discussion)Problem description:  Common Lisp doesn't provide any way to use an object of a user-defined  type (defined with DEFCLASS or DEFSTRUCT) as a constant in a program  compiled with COMPILE-FILE.  The problem is that LOAD has to be able  to "reconstruct" an equivalent object when the compiled-code file is  loaded, but the programmer has no way to tell LOAD how to do that.Proposal (LOAD-OBJECTS:MAKE-LOAD-FORM):            Define a new generic function named MAKE-LOAD-FORM, which takes one  argument and returns two values.  The argument is an object that is  referenced as a constant or as a self-evaluating form in a file being  compiled by COMPILE-FILE.  The objective is to enable LOAD to  construct an equivalent object.  The first value, called the "creation form," is a form that, when  evaluated at load time, should return an object that is equivalent to  the argument.  The exact meaning of "equivalent" depends on the type  of object and is up to the programmer who defines a method for  MAKE-LOAD-FORM.  This is the same type of equivalence discussed  in issue CONSTANT-COMPILABLE-TYPES.  The second value, called the "initialization form," is a form that,  when evaluated at load time, should perform further initialization of  the object.  The value returned by the initialization form is ignored.  If the MAKE-LOAD-FORM method returns only one value, the  initialization form is NIL, which has no effect.  If the object used  as the argument to MAKE-LOAD-FORM appears as a constant in the  initialization form, at load time it will be replaced by the  equivalent object constructed by the creation form; this is how the  further initialization gains access to the object.  Both the creation form and the initialization form can contain  references to objects of user-defined types (defined precisely below).  However, there must not be any circular dependencies in creation forms.  An example of a circular dependency is when the creation form for the  object X contains a reference to the object Y, and the creation form  for the object Y contains a reference to the object X.  A simpler  example would be when the creation form for the object X contains  a reference to X itself.  Initialization forms are not subject to  any restriction against circular dependencies, which is the entire  reason that initialization forms exist.  See the example of circular  data structures below.  The creation form for an object is always evaluated before the  initialization form for that object.  When either the creation form or  the initialization form references other objects of user-defined types  that have not been referenced earlier in the COMPILE-FILE, the  compiler collects all of the creation and initialization forms.  Each  initialization form is evaluated as soon as possible after its  creation form, as determined by data flow.  If the initialization form  for an object does not reference any other objects of user-defined  types that have not been referenced earlier in the COMPILE-FILE, the  initialization form is evaluated immediately after the creation form.  If a creation or initialization form F references other objects of  user-defined types that have not been referenced earlier in the  COMPILE-FILE, the creation forms for those other objects are evaluated  before F, and the initialization forms for those other objects are  also evaluated before F whenever they do not depend on the object  created or initialized by F.  Where the above rules do not uniquely  determine an order of evaluation, which of the possible orders of  evaluation is chosen is unspecified.  While these creation and initialization forms are being evaluated, the  objects are possibly in an uninitialized state, analogous to the state  of an object between the time it has been created by ALLOCATE-INSTANCE  and it has been processed fully by INITIALIZE-INSTANCE.  Programmers  writing methods for MAKE-LOAD-FORM must take care in manipulating  objects not to depend on slots that have not yet been initialized.  It is unspecified whether LOAD calls EVAL on the forms or does some  other operation that has an equivalent effect.  For example, the  forms might be translated into different but equivalent forms and  then evaluated, they might be compiled and the resulting functions  called by LOAD, or they might be interpreted by a special-purpose  interpreter different from EVAL.  All that is required is that the  effect be equivalent to evaluating the forms.  COMPILE-FILE calls MAKE-LOAD-FORM on any object that is referenced as  a constant or as a self-evaluating form, if the object's metaclass is  STANDARD-CLASS, STRUCTURE-CLASS, any user-defined metaclass (not a  subclass of BUILT-IN-CLASS), or any of a possibly-empty  implementation-defined list of other metaclasses.  COMPILE-FILE will  only call MAKE-LOAD-FORM once for any given object (compared with EQ)  within a single file.  It is valid for user programs to call MAKE-LOAD-FORM in other  circumstances, providing the argument's metaclass is not BUILT-IN-CLASS  or a subclass of BUILT-IN-CLASS.  Define a new function named MAKE-LOAD-FORM-USING-SLOTS, which takes  one required argument and one optional argument and returns two  values.  This can be useful in user-written MAKE-LOAD-FORM methods.  The first argument is the object.  The optional second argument is a  list of the names of the slots to preserve; it defaults to all of the  local slots.  MAKE-LOAD-FORM-USING-SLOTS returns forms that construct  an equivalent object using MAKE-INSTANCE and SETF of SLOT-VALUE for  slots with values, or SLOT-MAKUNBOUND for slots without values, or  using other functions of equivalent effect.  MAKE-LOAD-FORM-USING-SLOTS returns two values, thus it can deal with  circular structures.  MAKE-LOAD-FORM-USING-SLOTS works for any object  of metaclass STANDARD-CLASS or STRUCTURE-CLASS.  Whether the result is  useful in an application depends on whether the object's type and slot  contents fully capture the application's idea of the object's state.  MAKE-LOAD-FORM of an object of metaclass STANDARD-CLASS or  STRUCTURE-CLASS for which no user-defined method is applicable signals  an error.  It is valid to implement this either by defining default  methods on STANDARD-OBJECT and STRUCTURE-OBJECT that signal an error  or by having no applicable method for those classes.Examples:  ;; Example 1  (defclass my-class ()     ((a :initarg :a :reader my-a)      (b :initarg :b :reader my-b)      (c :accessor my-c)))  (defmethod shared-initialize ((self my-class) ignore &rest ignore)    (unless (slot-boundp self 'c)      (setf (my-c self) (some-computation (my-a self) (my-b self)))))  (defmethod make-load-form ((self my-class))    `(make-instance ',(class-name (class-of self))                    :a ',(my-a self) :b ',(my-b self)))  In this example, an equivalent instance of my-class is reconstructed  by using the values of two of its slots.  The value of the third slot  is derived from those two values.  Another way to write the last form in the above example would have been  (defmethod make-load-form ((self my-class))     (make-load-form-using-slots self '(a b)))  ;; Example 2  (defclass my-frob ()     ((name :initarg :name :reader my-name)))  (defmethod make-load-form ((self my-frob))    `(find-my-frob ',(my-name self) :if-does-not-exist :create))  In this example, instances of my-frob are "interned" in some way.  An equivalent instance is reconstructed by using the value of the  name slot as a key for searching existing objects.  In this case  the programmer has chosen to create a new object if no existing  object is found; alternatively she could have chosen to signal an  error in that case.  ;; Example 3  (defclass tree-with-parent () ((parent :accessor tree-parent)                                 (children :initarg :children)))  (defmethod make-load-form ((x tree-with-parent))    (values      ;; creation form      `(make-instance ',(class-of x) :children ',(slot-value x 'children))      ;; initialization form      `(setf (tree-parent ',x) ',(slot-value x 'parent))))  In this example, the data structure to be dumped is circular, because  each parent has a list of its children and each child has a reference  back to its parent.  Suppose make-load-form is called on one object in  such a structure.  The creation form creates an equivalent object and  fills in the children slot, which forces creation of equivalent  objects for all of its children, grandchildren, etc.  At this point  none of the parent slots have been filled in.  The initialization form  fills in the parent slot, which forces creation of an equivalent  object for the parent if it was not already created.  Thus the entire  tree is recreated at load time.  At compile time, MAKE-LOAD-FORM is  called once for each object in the true.  All of the creation forms  are evaluated, in unspecified order, and then all of the  initialization forms are evaluated, also in unspecified order.  ;; Example 4  (defstruct my-struct a b c)  (defmethod make-load-form ((s my-struct))     (make-load-form-using-slots s))  In this example, the data structure to be dumped has no special  properties and an equivalent structure can be reconstructed  simply by reconstructing the slots' contents.Rationale:  Only the programmer who designed a class can know the correct  way to reconstruct objects of that class at load time, therefore  the reconstruction should be controlled by a generic function.  Using EVAL as the interface for telling LOAD what to do provides  full generality.  MAKE-LOAD-FORM returns two values so that circular structures can  be handled.  If CONSTANT-CIRCULAR-COMPILATION is rejected,  MAKE-LOAD-FORM will only return one value, although implementations  that make an extension to support circular constants will probably  also make the extension to accept two values from MAKE-LOAD-FORM.  The default for class objects and structures is to signal an error,  rather than picking some particular object reconstruction technique,  because no reconstruction technique is appropriate for all objects.  It only takes two lines of code, as in example 4, to instruct the  compiler to use the technique that most often has been suggested  as the default.  MAKE-LOAD-FORM has a natural resemblance to PRINT-OBJECT, as a hook  for the programmer to control the system's actions.  The order of evaluation rules for creation and initialization forms  eliminate the possibility of partially initialized objects in the  absence of circular structures, and reduce it to the minimum possible  in the presence of circular structures.  This allows nodes in  non-circular structures to be built out of fully initialized subparts.Current practice:  Symbolics Flavors has something like this, but under a different name.  The name Symbolics uses is not suitable for standardization.  JonL reports that Lucid is getting more and more requests for this.Cost to Implementors:  This seems like only a few one-line changes in the compiled-code  file writer and reader.  MAKE-LOAD-FORM-USING-SLOTS is a couple  dozen lines of code, assuming the presence of the CLOS metaobject  protocol or an implementation-dependent equivalent.Cost to Users:  None.Cost of non-adoption:  Serious impairment of the ability to use extended-type objects.  Each  implementation will probably make up its own version of this as an  extension.Performance impact:  None.Benefits:  See Cost of non-adoption.Esthetics:  No significant positive or negative impact.Discussion:  It would be possible to define an additional level of protocol that  allows multiple classes to contribute to the reconstruction of an  object, combining initialization arguments contributed by each class.  Since a user can easily define that in terms of MAKE-LOAD-FORM without  modifying the Lisp system, it is not being proposed now.  Any type that has a read syntax is likely to appear as a quoted  constant or inside a quoted constant.  Pathnames are one example, user  programs often define others.  Also many implementations provide a way  to create a compiled-code file full of data (rather than compiled Lisp  programs), and such data probably include extended-type objects.  Moon supports this.  David Gray and John Rose made major contributions  to the discussion that produced this improved version 2 proposal.     ----- End Forwarded Messages -----*start*03491 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 22:53:43 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 22:53:41 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 17 Mar 89  22:54:01 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 560294; Sat 18-Mar-89 01:50:31 ESTDate: Sat, 18 Mar 89 01:50 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: LOAD-OBJECTS (Version 3)To: Sandra J Loosemore <sandra%defun@cs.utah.edu>, Richard P. Gabriel <rpg@lucid.com>cc: CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.edu, Common-Lisp-Object-System@sail.stanford.eduIn-Reply-To: <8903120142.AA00878@defun.utah.edu>Message-ID: <19890318065022.2.MOON@EUPHRATES.SCRC.Symbolics.COM>There are a couple of small changes that seem warranted:   MAKE-LOAD-FORM-USING-SLOTS is too easy to confuse with   SLOT-VALUE-USING-CLASS.  MAKE-LOAD-FORM-FROM-SLOTS is better,   except for form/from dyslexia.  MAKE-LOAD-FORM-FOR-SLOTS ?   Maybe there should be a SIMILAR-AS-CONSTANTS generic function   for the benefit of CONSTANT-COLLAPSING.  In the absence of that   we're just using EQ.On the subject of this proposed alternative:    Date: Sat, 11 Mar 89 18:42:56 MST    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    Have two generic functions, not one.  The first would get called by    compile-file and it would return a list of components (or whatever)    that are required to reconstruct the object.  The compiler would dump    this list of objects in its usual way.  The loader would apply the    second generic function to this list to reconstruct the object.  This is exactly the way I did the first implementation of this idea,back in about 1978.  It didn't work very well, basically for two reasons.One is that representing information in the form of lists is prettyimpoverished and it's very easy to get the list the wrong length orout of order; it's also more difficult than it should be to makeupward-compatible changes, because the new format always has to bea superset of the old format.  Forms are more general.  You can makeupward-compatible changes by inventing a new function name and keepingthe old function name around forever with the old semantics; this alsoensures an undefined-function error if the new format is loaded intothe old system.The second reason is more serious.  The way you propose cannot be nicelyextended to deal with circular structures, because it fails to separateobject creation from object initialization.  The second generic functiondoes both operations.  My application used circular structuresextensively and had a fairly horrible kludge for them, involving standinobjects that were replaced with the correct objects later in loading;this was fragile and permeated the reconstruction methods, all the worstcharacteristics for this kind of thing.On the subject of forms versus functions as the interface, I thinkDavid Gray has expressed very well the reasons why that is notpractical, at least at Common Lisp's present stage of development.I've read all the mail on the subject, but I stand by LOAD-OBJECTSversion 3.  There may be more thought behind this proposal than isapparent at first glance.*start*01151 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 13:26:43 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 13:26:43 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 20 Mar 89  13:24:54 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 20 MAR 89 13:17:33 PSTDate: 20 Mar 89 13:16 PSTFrom: Danny Bobrow <Bobrow.pa>Subject: Re: Issue: LOAD-OBJECTS (Version 3)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Sat, 18 Mar 89 01:50 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: Sandra J Loosemore <sandra%defun@cs.utah.edu>, Richard P. Gabriel <rpg@lucid.com>, CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.edu, Common-Lisp-Object-System@sail.stanford.eduMessage-ID: <890320-131733-6488@Xerox>   MAKE-LOAD-FORM-USING-SLOTS is too easy to confuse with   SLOT-VALUE-USING-CLASS.  MAKE-LOAD-FORM-FROM-SLOTS is better,   except for form/from dyslexia.  MAKE-LOAD-FORM-FOR-SLOTS ?How about MAKE-LOAD-FORM-SAVING-SLOTS  danny*start*01115 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 13:43:26 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 13:40:34 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 20 Mar 89  13:24:54 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 20 MAR 89 13:17:33 PSTDate: 20 Mar 89 13:16 PSTFrom: Danny Bobrow <Bobrow.pa>Subject: Re: Issue: LOAD-OBJECTS (Version 3)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Sat, 18 Mar 89 01:50 ESTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: Sandra J Loosemore <sandra%defun@cs.utah.edu>, Richard P. Gabriel <rpg@lucid.com>, CL-Cleanup@sail.stanford.edu, CL-Compiler@sail.stanford.edu, Common-Lisp-Object-System@sail.stanford.eduMessage-ID: <890320-131733-6488@Xerox>   MAKE-LOAD-FORM-USING-SLOTS is too easy to confuse with   SLOT-VALUE-USING-CLASS.  MAKE-LOAD-FORM-FROM-SLOTS is better,   except for form/from dyslexia.  MAKE-LOAD-FORM-FOR-SLOTS ?How about MAKE-LOAD-FORM-SAVING-SLOTS  danny*start*01351 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 14:37:19 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 14:36:37 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Mar 89  14:27:09 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 561368; Mon 20-Mar-89 17:23:27 ESTDate: Mon, 20 Mar 89 17:23 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: LOAD-OBJECTS (Version 3)To: Danny Bobrow <Bobrow.pa>cc: Sandra J Loosemore <sandra%defun@cs.utah.edu>, Richard P. Gabriel <rpg@lucid.com>, CL-Cleanup@SAIL.STANFORD.EDU, CL-Compiler@SAIL.STANFORD.EDU, Common-Lisp-Object-System@SAIL.STANFORD.EDUIn-Reply-To: <890320-131733-6488@Xerox>Message-ID: <19890320222313.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 20 Mar 89 13:16 PST    From: Danny Bobrow <Bobrow.pa@Xerox.COM>       MAKE-LOAD-FORM-USING-SLOTS is too easy to confuse with       SLOT-VALUE-USING-CLASS.  MAKE-LOAD-FORM-FROM-SLOTS is better,       except for form/from dyslexia.  MAKE-LOAD-FORM-FOR-SLOTS ?    How about MAKE-LOAD-FORM-SAVING-SLOTSI like that name.*start*14412 00024 US Date:  4 Apr 89 12:21 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: LOAD-OBJECTS (Version 4)To: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: LOAD-OBJECTS (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:09:25 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:06:42 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571193; Tue 4-Apr-89 15:06:37 EDTOriginal-Date: Tue, 4 Apr 89 15:06 EDTMessage-ID: <890404150611.0.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMoon proposed friendly amendment to use the name MAKE-LOAD-FORM-SAVING-SLOTS.The amended proposal passed 18-0.I had to produce a revised writeup for my own purposes anyway, so it's attached below.-----Issue:         LOAD-OBJECTSReferences:    noneRelated issues: LOAD-TIME-EVAL,                CONSTANT-COMPILABLE-TYPES,                CONSTANT-CIRCULAR-COMPILATIONCategory:      ADDITIONForum:         CleanupEdit history:  Version 1, 2-Jan-89, by Moon (for discussion)               Version 2, 13-Jan-89, by Moon (draft updated from discussion)               Version 3,  9-Mar-89, by Moon (changes suggested by discussion)	       Version 4, 4-Apr-89, by Pitman (changes per X3J13 Mar 89; 		 MAKE-LOAD-FORM-USING-SLOTS => MAKE-LOAD-FORM-SAVING-SLOTS)Status:  Accepted by an 18-0 vote, March 1989.Problem description:  Common Lisp doesn't provide any way to use an object of a user-defined  type (defined with DEFCLASS or DEFSTRUCT) as a constant in a program  compiled with COMPILE-FILE.  The problem is that LOAD has to be able  to "reconstruct" an equivalent object when the compiled-code file is  loaded, but the programmer has no way to tell LOAD how to do that.Proposal (LOAD-OBJECTS:MAKE-LOAD-FORM):            Define a new generic function named MAKE-LOAD-FORM, which takes one  argument and returns two values.  The argument is an object that is  referenced as a constant or as a self-evaluating form in a file being  compiled by COMPILE-FILE.  The objective is to enable LOAD to  construct an equivalent object.  The first value, called the "creation form," is a form that, when  evaluated at load time, should return an object that is equivalent to  the argument.  The exact meaning of "equivalent" depends on the type  of object and is up to the programmer who defines a method for  MAKE-LOAD-FORM.  This is the same type of equivalence discussed  in issue CONSTANT-COMPILABLE-TYPES.  The second value, called the "initialization form," is a form that,  when evaluated at load time, should perform further initialization of  the object.  The value returned by the initialization form is ignored.  If the MAKE-LOAD-FORM method returns only one value, the  initialization form is NIL, which has no effect.  If the object used  as the argument to MAKE-LOAD-FORM appears as a constant in the  initialization form, at load time it will be replaced by the  equivalent object constructed by the creation form; this is how the  further initialization gains access to the object.  Both the creation form and the initialization form can contain  references to objects of user-defined types (defined precisely below).  However, there must not be any circular dependencies in creation forms.  An example of a circular dependency is when the creation form for the  object X contains a reference to the object Y, and the creation form  for the object Y contains a reference to the object X.  A simpler  example would be when the creation form for the object X contains  a reference to X itself.  Initialization forms are not subject to  any restriction against circular dependencies, which is the entire  reason that initialization forms exist.  See the example of circular  data structures below.  The creation form for an object is always evaluated before the  initialization form for that object.  When either the creation form or  the initialization form references other objects of user-defined types  that have not been referenced earlier in the COMPILE-FILE, the  compiler collects all of the creation and initialization forms.  Each  initialization form is evaluated as soon as possible after its  creation form, as determined by data flow.  If the initialization form  for an object does not reference any other objects of user-defined  types that have not been referenced earlier in the COMPILE-FILE, the  initialization form is evaluated immediately after the creation form.  If a creation or initialization form F references other objects of  user-defined types that have not been referenced earlier in the  COMPILE-FILE, the creation forms for those other objects are evaluated  before F, and the initialization forms for those other objects are  also evaluated before F whenever they do not depend on the object  created or initialized by F.  Where the above rules do not uniquely  determine an order of evaluation, which of the possible orders of  evaluation is chosen is unspecified.  While these creation and initialization forms are being evaluated, the  objects are possibly in an uninitialized state, analogous to the state  of an object between the time it has been created by ALLOCATE-INSTANCE  and it has been processed fully by INITIALIZE-INSTANCE.  Programmers  writing methods for MAKE-LOAD-FORM must take care in manipulating  objects not to depend on slots that have not yet been initialized.  It is unspecified whether LOAD calls EVAL on the forms or does some  other operation that has an equivalent effect.  For example, the  forms might be translated into different but equivalent forms and  then evaluated, they might be compiled and the resulting functions  called by LOAD, or they might be interpreted by a special-purpose  interpreter different from EVAL.  All that is required is that the  effect be equivalent to evaluating the forms.  COMPILE-FILE calls MAKE-LOAD-FORM on any object that is referenced as  a constant or as a self-evaluating form, if the object's metaclass is  STANDARD-CLASS, STRUCTURE-CLASS, any user-defined metaclass (not a  subclass of BUILT-IN-CLASS), or any of a possibly-empty  implementation-defined list of other metaclasses.  COMPILE-FILE will  only call MAKE-LOAD-FORM once for any given object (compared with EQ)  within a single file.  It is valid for user programs to call MAKE-LOAD-FORM in other  circumstances, providing the argument's metaclass is not BUILT-IN-CLASS  or a subclass of BUILT-IN-CLASS.  Define a new function named MAKE-LOAD-FORM-SAVING-SLOTS, which takes  one required argument and one optional argument and returns two  values.  This can be useful in user-written MAKE-LOAD-FORM methods.  The first argument is the object.  The optional second argument is a  list of the names of the slots to preserve; it defaults to all of the  local slots.  MAKE-LOAD-FORM-SAVING-SLOTS returns forms that construct  an equivalent object using MAKE-INSTANCE and SETF of SLOT-VALUE for  slots with values, or SLOT-MAKUNBOUND for slots without values, or  using other functions of equivalent effect.  MAKE-LOAD-FORM-SAVING-SLOTS returns two values, thus it can deal with  circular structures.  MAKE-LOAD-FORM-SAVING-SLOTS works for any object  of metaclass STANDARD-CLASS or STRUCTURE-CLASS.  Whether the result is  useful in an application depends on whether the object's type and slot  contents fully capture the application's idea of the object's state.  MAKE-LOAD-FORM of an object of metaclass STANDARD-CLASS or  STRUCTURE-CLASS for which no user-defined method is applicable signals  an error.  It is valid to implement this either by defining default  methods on STANDARD-OBJECT and STRUCTURE-OBJECT that signal an error  or by having no applicable method for those classes.Examples:  ;; Example 1  (defclass my-class ()     ((a :initarg :a :reader my-a)      (b :initarg :b :reader my-b)      (c :accessor my-c)))  (defmethod shared-initialize ((self my-class) ignore &rest ignore)    (unless (slot-boundp self 'c)      (setf (my-c self) (some-computation (my-a self) (my-b self)))))  (defmethod make-load-form ((self my-class))    `(make-instance ',(class-name (class-of self))                    :a ',(my-a self) :b ',(my-b self)))  In this example, an equivalent instance of my-class is reconstructed  by using the values of two of its slots.  The value of the third slot  is derived from those two values.  Another way to write the last form in the above example would have been  (defmethod make-load-form ((self my-class))     (make-load-form-saving-slots self '(a b)))  ;; Example 2  (defclass my-frob ()     ((name :initarg :name :reader my-name)))  (defmethod make-load-form ((self my-frob))    `(find-my-frob ',(my-name self) :if-does-not-exist :create))  In this example, instances of my-frob are "interned" in some way.  An equivalent instance is reconstructed by using the value of the  name slot as a key for searching existing objects.  In this case  the programmer has chosen to create a new object if no existing  object is found; alternatively she could have chosen to signal an  error in that case.  ;; Example 3  (defclass tree-with-parent () ((parent :accessor tree-parent)                                 (children :initarg :children)))  (defmethod make-load-form ((x tree-with-parent))    (values      ;; creation form      `(make-instance ',(class-of x) :children ',(slot-value x 'children))      ;; initialization form      `(setf (tree-parent ',x) ',(slot-value x 'parent))))  In this example, the data structure to be dumped is circular, because  each parent has a list of its children and each child has a reference  back to its parent.  Suppose make-load-form is called on one object in  such a structure.  The creation form creates an equivalent object and  fills in the children slot, which forces creation of equivalent  objects for all of its children, grandchildren, etc.  At this point  none of the parent slots have been filled in.  The initialization form  fills in the parent slot, which forces creation of an equivalent  object for the parent if it was not already created.  Thus the entire  tree is recreated at load time.  At compile time, MAKE-LOAD-FORM is  called once for each object in the true.  All of the creation forms  are evaluated, in unspecified order, and then all of the  initialization forms are evaluated, also in unspecified order.  ;; Example 4  (defstruct my-struct a b c)  (defmethod make-load-form ((s my-struct))     (make-load-form-saving-slots s))  In this example, the data structure to be dumped has no special  properties and an equivalent structure can be reconstructed  simply by reconstructing the slots' contents.Rationale:  Only the programmer who designed a class can know the correct  way to reconstruct objects of that class at load time, therefore  the reconstruction should be controlled by a generic function.  Using EVAL as the interface for telling LOAD what to do provides  full generality.  MAKE-LOAD-FORM returns two values so that circular structures can  be handled.  If CONSTANT-CIRCULAR-COMPILATION is rejected,  MAKE-LOAD-FORM will only return one value, although implementations  that make an extension to support circular constants will probably  also make the extension to accept two values from MAKE-LOAD-FORM.  The default for class objects and structures is to signal an error,  rather than picking some particular object reconstruction technique,  because no reconstruction technique is appropriate for all objects.  It only takes two lines of code, as in example 4, to instruct the  compiler to use the technique that most often has been suggested  as the default.  MAKE-LOAD-FORM has a natural resemblance to PRINT-OBJECT, as a hook  for the programmer to control the system's actions.  The order of evaluation rules for creation and initialization forms  eliminate the possibility of partially initialized objects in the  absence of circular structures, and reduce it to the minimum possible  in the presence of circular structures.  This allows nodes in  non-circular structures to be built out of fully initialized subparts.Current practice:  Symbolics Flavors has something like this, but under a different name.  The name Symbolics uses is not suitable for standardization.  JonL reports that Lucid is getting more and more requests for this.Cost to Implementors:  This seems like only a few one-line changes in the compiled-code  file writer and reader.  MAKE-LOAD-FORM-SAVING-SLOTS is a couple  dozen lines of code, assuming the presence of the CLOS metaobject  protocol or an implementation-dependent equivalent.Cost to Users:  None.Cost of non-adoption:  Serious impairment of the ability to use extended-type objects.  Each  implementation will probably make up its own version of this as an  extension.Performance impact:  None.Benefits:  See Cost of non-adoption.Esthetics:  No significant positive or negative impact.Discussion:  It would be possible to define an additional level of protocol that  allows multiple classes to contribute to the reconstruction of an  object, combining initialization arguments contributed by each class.  Since a user can easily define that in terms of MAKE-LOAD-FORM without  modifying the Lisp system, it is not being proposed now.  Any type that has a read syntax is likely to appear as a quoted  constant or inside a quoted constant.  Pathnames are one example, user  programs often define others.  Also many implementations provide a way  to create a compiled-code file full of data (rather than compiled Lisp  programs), and such data probably include extended-type objects.  Moon supports this.  David Gray and John Rose made major contributions  to the discussion that produced this improved version 2 proposal. 