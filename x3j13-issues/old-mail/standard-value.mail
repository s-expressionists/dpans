*start*08944 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 OCT 88 13:40:07 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Oct 88  13:38:16 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 480160; Fri 21-Oct-88 16:38:24 EDTDate: Fri, 21 Oct 88 16:38 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STANDARD-VALUE (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881021163813.2.KMP@BOBOLINK.SCRC.Symbolics.COM>From my list of "pending issues" distributed at the last X3J13 meeting...-----Issue:        STANDARD-VALUEReferences:   NoneCategory:     ADDITIONEdit history: 21-Oct-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  Sometimes a program binds option variables to implausible settings for a  very temporary purpose. For example, *PRINT-BASE* might be bound temporarily  to 3 or *PACKAGE* might be bound to the KEYWORD package.  Entry to the debugger or some other form of recursive read-eval-print loop  may happen either asynchronously (in some implementations) or synchronously  due to a call to ERROR or BREAK. When that happens, if these option variables  are bound to invalid values, it is most useful to bind them back to something  useful.  Unfortunately, Common Lisp does not provide a way of distinguishing    ``I'm binding/setting this variable for a temporary purpose which     should not affect recursive read-eval-print loops.''  from   ``I'm binding/setting this variable for the express purpose of     affecting recursive read-eval-print loops.''  So, for example,   (DEFUN PRINT-IN-KEYWORD-PACKAGE (X)     (LET ((*PRINT-BASE* (FIND-PACKAGE "KEYWORD"))) (PRINT XX)))   (PRINT-IN-KEYWORD-PACKAGE 'ZAP)   >>Error: The variable XX is unbound.   Debug> (HELP)   >>Error: The function :HELP is undefined.  It might be useful for *PACKAGE* to have been bound back to something  other than keyword here.   (DEFUN BASE-3-REPL ()     (LET ((*PRINT-BASE* 3) (*READ-BASE* 3) (*PRINT-RADIX* NIL))       (MY-READ-EVAL-PRINT-LOOP :PROMPT "Base 3> ")))   Base 3> (- 10 1)   2   Base 3> (+ 'FOO 1)   Error: FOO is not a valid argument to the + function.   Debug> :Use-Value 10   2  Here it was useful that *PRINT-BASE* was not bound back to something.Proposal (STANDARD-VALUE:NEW-FUNCTIONS):  Introduce these new macros:  DEFVAR-STANDARD name value					[Macro]   Like DEFVAR, but the initial value is recorded as the `standard value.'    LET-STANDARD let-bindings &body forms				[Macro]   Like LET, but binds both the values and the standard values of the   indicated variables (which must have been previously defined by   DEFVAR-STANDARD).  PROGV-STANDARD names values &body forms			[Macro]   Like PROGV, but binds both the values and the standard values of the   indicated variables (which must have been previously defined by   DEFVAR-STANDARD).  STANDARD-VALUE name						[Function]   Returns the standard value of the indicated variable.   Note that this may not be the same as (SYMBOL-VALUE name).   SETF may be used with this function. Note that setting the   standard value of NAME does not set (SYMBOL-VALUE name).  When the debugger is entered, variables which have been declared standard  but which do not currently have their standard values (as judged by EQL)  will be rebound to their standard values (and a mechanism will be provided  for viewing the values to which they were bound at debugger entry time).  NON-STANDARD-VALUES						[Function]   Returns a list of variables which are not currently bound to their   standard values.  The following variables in the LISP package are defined as if by  DEFVAR-STANDARD:    *PRINT-ARRAY*    *PRINT-GENSYM*   *READ-BASE*    *PRINT-BASE*     *PRINT-LENGTH*   *READ-DEFAULT-FLOAT-FORMAT*    *PRINT-CASE*     *PRINT-LEVEL*    *READ-SUPPRESS*    *PRINT-CIRCLE*   *PRINT-PRETTY*   *READTABLE*    *PRINT-ESCAPE*   *PRINT-RADIX*  Define that LOAD and COMPILE-FILE bind *PACKAGE* using LET-STANDARD.  Define that IN-PACKAGE sets both the SYMBOL-VALUE and the  STANDARD-VALUE of the variable in question.Test Case:  Contrast these with the analogous cases in the problem description:   (DEFUN PRINT-IN-KEYWORD-PACKAGE (X)     (LET ((*PRINT-BASE* (FIND-PACKAGE "KEYWORD"))) (PRINT XX)))   (PRINT-IN-KEYWORD-PACKAGE 'ZAP)   >>Error: The variable XX is unbound.   Rebinding *PACKAGE* from #<PACKAGE "KEYWORD"> to #<PACKAGE "USER">.   Debug> (HELP)   ...This is presumably typeout from some function called HELP...   (DEFUN BASE-3-REPL ()     (LET-STANDARD ((*PRINT-BASE* 3) (*READ-BASE* 3) (*PRINT-RADIX* NIL))       (MY-READ-EVAL-PRINT-LOOP :PROMPT "Base 3> ")))   Base 3> (- 10 1)   2   Base 3> (+ 'FOO 1)   Error: FOO is not a valid argument to the + function.   Debug> :Use-Value 10   2Rationale:  This would allow users to say when, when binding a variable, whether they  intended to bind it only `temporarily' or if they had some deeper purpose  in mind.  Also, users of Genera (where standard values already exist) have  complained that IN-PACKAGE does not set the standard value of *PACKAGE*  in Genera. The same is true for the binding of *PACKAGE* by LOAD. Other  users would complain if standard values were affected. The confusion is  not really due to the fact one meaning is preferrable over the other, but  rather due to the fact that Common Lisp cannot document such a meaning  without first admitting the concept of standard values. If standard  values existed in Common Lisp and the documentation was clear on how  IN-PACKAGE and LOAD related to that concept, users would no longer be  forced to guess what these functions did with respect to such information,  and so those users who are now surprised would no longer have reason to  be surprised.Current Practice:  Symbolics Genera implements the proposed functionality (with slightly  more options and slightly different names).Cost to Implementors:  Relatively small. A set of fairly straightforward definitions, looking  something like:  (DEFVAR *STANDARD-VALUES* '())  (DEFUN STANDARD-VALUE (NAME)    (LET ((ENTRY (ASSOC NAME *STANDARD-VALUES*)))      (IF (NOT ENTRY) (ERROR ...) (CADR ENTRY))))  (DEFUN SET-STANDARD-VALUE (NAME VALUE)    (LET ((ENTRY (ASSOC NAME *STANDARD-VALUES*)))      (IF (NOT ENTRY) (ERROR ...) (SETF (CADR ENTRY) VALUE))))  (DEFSETF STANDARD-VALUE SET-STANDARD-VALUE)  (DEFMACRO DEFVAR-STANDARD (NAME VALUE)    `(PROGN (DEFVAR ,NAME ,VALUE)	    (PUSHNEW (CONS ',NAME ,NAME) *STANDARD-VALUES* :KEY #'CAR)	    ',NAME))  (DEFMACRO LET-STANDARD (BINDINGS &BODY FORMS)    `(LET ,@BINDINGS       (LET ((*STANDARD-VALUES*	       (LIST* ,@(MAPCAR #'(LAMBDA (BINDING) 				    `(CONS ',(CAR BINDING) ,(CAR BINDING)))			        BINDINGS)		      *STANDARD-VALUES*)))	 ,@FORMS)))  (DEFMACRO PROGV-STANDARD (VARS VALUES &BODY FORMS)    (LET ((TEMP (GENSYM)))      `(LET ((,TEMP ,VARS))         (PROGV ,TEMP ,VALUES           (LET ((*STANDARD-VALUES* *STANDARD-VALUES*))	     ;; This puts them on backward from how LET-STANDARD does, but	     ;; if there are no duplicates, that won't matter... and	     ;; duplicates are disallowed as per LET.	     (DOLIST (,TEMP ,TEMP)	       (PUSH (CONS ,TEMP (SYMBOL-VALUE ,TEMP)) *STANDARD-VALUES*))	     ,@FORMS)))))  (DEFUN NON-STANDARD-VALUES ()    (LET ((RESULT '()))      (DOLIST (ENTRY *STANDARD-VALUES*)        (UNLESS (EQL (SYMBOL-VALUE (CAR ENTRY)) (CDR ENTRY))	  (PUSH (CAR ENTRY) RESULT)))      RESULT))  [I wrote these quickly and didn't test them. If anyone else reviewing this   has time to test them and let me know about bugs, that would be nice. -kmp]Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  There is no way for Common Lisp programs to provide advice to systems  already supporting this facility.Benefits:  The interaction between programs that bind important variables and the  debugger would become more clear (and hence less frustrating) to users.Aesthetics:  Some might argue that this adds a small amount of undue hair.  However, the hair is easy to overlook the nagging little problems that  come from not using this facility. The problem is that, without a  facility like this, those who do care about these issues have no way to  express their intent.Discussion:  Pitman thinks a facility like this would probably improve the quality of  debugging interaction in Common Lisp implementations.  The problem with the meaning of IN-PACKAGE was first pointed out to  Pitman by Rees, who encountered the problem while creating his portable  Scheme implementation.*start*02456 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 21 OCT 88 14:31:23 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 480223; Fri 21-Oct-88 17:31:38 EDTDate: Fri, 21 Oct 88 17:31 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: STANDARD-VALUE (Version 1)To: masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881021-141122-6552@Xerox>Message-ID: <881021173128.6.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: 21 Oct 88 13:48 PDT    From: masinter.pa@Xerox.COM    Envos Medley does this only slightly differently: there's a list    IL:*PER-EXEC-VARIABLES* instead of *STAHDARD-VALUES*. If you really add aHad I said STAHDARD? Must be that famous Boston accent creeping in. I meantSTANDARD.    new variable that really has to be rebound when a new debugger or EXEC is    invoked, you can push something onto it.I'm not proposing we advertise the variable that holds them. That'simplementation-dependent.    The initial value is ((*PACKAGE* (COND ((PACKAGEP *PACKAGE*) *PACKAGE*) (T    (PROMPTPRINT "Invalid package, reset to LISP") (SETQ *PACKAGE*    (FIND-PACKAGE LISP))))) (* *) (** **) (*** ***) (+ +) (++ ++) (+++ +++) (-    -) (/ /) (// //) (/// ///) (HELPFLAG T) (*EVALHOOK* NIL) (*APPLYHOOK* NIL)    (*ERROR-OUTPUT* *TERMINAL-IO*) (*READTABLE* *READTABLE*) (*EVAL-FUNCTION*    *EVAL-FUNCTION*) (*EXEC-PROMPT* *EXEC-PROMPT*) (*DEBUGGER-PROMPT*    *DEBUGGER-PROMPT*)) Mostly I'm content to union the LISP symbols in your list with ours. Weprobably ought to have *EVALHOOK* and *APPLYHOOK* in our list anyway,for example.The issue of *, **, ***, etc. is an unclear one. I think our users prefer thatthe values not be rebound, so they can abort out a level and still refer backto a value they got in a breakpoint.    I don't think this will fly, because it seems to be too dependent on one    particular style of debugger.I could weaken the restriction on the debugger to say it's only a mechanism forprograms to communicate such info with debuggers that can make use of it.I'm not interested in restricting debugger styles so much as acknowledging thatmany are like this and that many people have programs that would be happy togive the debugger hints if only they knew how.*start*01479 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 OCT 88 14:31:11 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Oct 88  14:24:58 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 21 OCT 88 14:11:22 PDTDate: 21 Oct 88 13:48 PDTFrom: masinter.paSubject: Re: Issue: STANDARD-VALUE (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 21 Oct 88 16:38 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881021-141122-6552@Xerox>Envos Medley does this only slightly differently: there's a listIL:*PER-EXEC-VARIABLES* instead of *STAHDARD-VALUES*. If you really add anew variable that really has to be rebound when a new debugger or EXEC isinvoked, you can push something onto it.The initial value is ((*PACKAGE* (COND ((PACKAGEP *PACKAGE*) *PACKAGE*) (T(PROMPTPRINT "Invalid package, reset to LISP") (SETQ *PACKAGE*(FIND-PACKAGE LISP))))) (* *) (** **) (*** ***) (+ +) (++ ++) (+++ +++) (--) (/ /) (// //) (/// ///) (HELPFLAG T) (*EVALHOOK* NIL) (*APPLYHOOK* NIL)(*ERROR-OUTPUT* *TERMINAL-IO*) (*READTABLE* *READTABLE*) (*EVAL-FUNCTION**EVAL-FUNCTION*) (*EXEC-PROMPT* *EXEC-PROMPT*) (*DEBUGGER-PROMPT**DEBUGGER-PROMPT*)) I don't think this will fly, because it seems to be too dependent on oneparticular style of debugger.*start*01498 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 OCT 88 23:01:27 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 27 Oct 88  23:00:08 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01772g; Thu, 27 Oct 88 22:59:01 PDTReceived: by bhopal id AA13471g; Thu, 27 Oct 88 22:57:33 PDTDate: Thu, 27 Oct 88 22:57:33 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810280557.AA13471@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Fri, 21 Oct 88 16:38 EDT <881021163813.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: STANDARD-VALUE (Version 1)Lucid does something like this -- for those interested, you can look atlucid::*debugger-bindings* to get a flavor for what sorts of things arere-bound, and to what kind of values they would be bound to.  Typically,when the debugger exits, it notices if some value on this list has beenchanged by the user, and asks whether you want to keep the changedvalue, or to restore the "re-bound" value.Although most implementations must be doing some very similar things,I just don't feel this issue is worth trying to standardize now.  Therecould be a lot of work involved in reaching a consensus, and I'd muchprefer to see that time spent on already open issues.  January '89 is"real close" now.-- JonL --