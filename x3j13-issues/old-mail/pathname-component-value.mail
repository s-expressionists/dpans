*start*08287 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 12:47:49 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 12:47:21 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Mar 89  12:41:44 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 561033; Mon 20-Mar-89 13:04:18 ESTDate: Mon, 20 Mar 89 13:04 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUE (version 1)To: CL-Cleanup@sail.stanford.educc: chapman%aitg.DEC@decwrl.dec.comMessage-ID: <19890320180405.2.MOON@EUPHRATES.SCRC.Symbolics.COM>This issue came up while reviewing section 2.2 of the draft standard.Does anyone object if I mail this to X3J13 and bring it up at theMarch meeting?  I couldn't find any sign that it has already been addressed.Issue:         PATHNAME-COMPONENT-VALUERelated Issues:PATHNAME-CANONICAL-TYPE,               PATHNAME-SUBDIRECTORY-LIST,               PATHNAME-UNSPECIFIC-COMPONENT,               PATHNAME-WILDReferences:    CLtL pp.410-3Category:      CLARIFICATION and CHANGEEdit history:  Version 1, 20-Mar-89, by MoonProblem description:    CLtL is overly restrictive on the possible values for pathname components.  These restrictions are described in a funny way that makes it unclear  whether they are requirements, guidelines, or just an example.    The restrictions are not all written down in one place, but they appear  to be as follows:  Host		nil, :wild, string, or list of strings  Device	nil, :wild, string, or something else ("structured")  Directory	nil, :wild, string, or something else ("structured")  Name		nil, :wild, string, or something else ("structured")  Type		nil, :wild, or string  Version	nil, :wild, :newest, positive integer, implementation		dependent symbol, or implementation-dependent integer		less than or equal to zero.  Suggestions include :oldest,		:previous, :installed, 0, and -1.  PATHNAME-UNSPECIFIC-COMPONENT:NEW-TOKEN allowed implementations to  allow any component to be :UNSPECIFIC.  This has been voted in.  PATHNAME-SUBDIRECTORY-LIST proposes a list of strings and keyword  symbols for the directory component.  PATHNAME-CANONICAL-TYPE proposes some new operations but does not  change the possible values of the type component.  PATHNAME-WILD proposes a portable way to test for implementation  dependent component values that indicate wildcard matching.  It  does not change the possible values of any component.Proposal (PATHNAME-COMPONENT-VALUE:SPECIFY):  The points of the proposal have been numbered to facilitate  amendments to remove or modify individual points.  When examining pathname components, conforming programs must be  prepared to encounter any of the following values:  1. Any component can be NIL, which means the component has not  been specified.  2. Any component can be :UNSPECIFIC, which means the component has  no meaning in this particular pathname.  3. Any component can be :WILD, which matches any component value.  Wild pathnames can be used with DIRECTORY but not with OPEN.  4. The host, device, directory, name, and type can be strings.  5. The host and device can be a list, a structure, or a  standard-object at the discretion of the implementation.  6. The directory can be a list of strings and symbols as detailed in  PATHNAME-SUBDIRECTORY-LIST (this assumes that it passes.)  7. The version can be any symbol or any integer.  The symbol :NEWEST  refers to the largest version number that already exists in the file  system when reading, overwriting, appending, superseding, or directory  listing an existing file, and refers to the smallest version number  greater than any existing version number when creating a new file.  When constructing a pathname from components, conforming programs  must follow these rules:    11. Any component can be NIL.  NIL in the host may mean a default host  rather than an actual NIL in some implementations.  12. Any component can be :WILD, which matches any component value.  Wild pathnames can be used with DIRECTORY but not with OPEN.    13. The host, device, directory, name, and type can be strings.  14. The directory can be a list of strings and symbols as detailed in  PATHNAME-SUBDIRECTORY-LIST (this assumes that it passes.)  15. The version can be :NEWEST.  16. Any component can be taken from the corresponding component  of another pathname on the same host and device.  17. An implementation might support other values for some  components, but a portable program cannot use those values.    An implementation might allow values to be transferred between  pathnames on different hosts or different devices, but a portable  program cannot rely on that.  A conforming program can use implementation-dependent values  but this can make it non-portable, for example, it might work  only with Unix file systems.  18. It is suggested, but not required, that implementations use  positive integers starting at 1 as version numbers, recognize  the symbol :oldest to designate the smallest existing version  number, and use keyword symbols for other special versions.Consequences:  The changes relative to CLtL plus PATHNAME-UNSPECIFIC-COMPONENT  are as follows:  The definition of "structured" component is restricted to lists,  structures, and standard-objects, rather than allowing any object  whatsoever.    "Structured" hosts are allowed, a generalization of CLtL's list  of strings.  "Structured" directories are replaced by PATHNAME-SUBDIRECTORY-LIST.  "Structured" names are forbidden.  The difference between what component values a program can depend  on being able to use, versus what component values a program must  be prepared to encounter, is clarified.Rationale:    This should make it easier to write portable programs that deal with  pathnames and make it easier for implementors by clarifying the  framework into which they must fit.  Also it should make it easier  to write the Common Lisp language specification by resolving some  things that were unclear about the status quo.  Adding "structured" hosts conforms to current practice.  Substituting a default host for NIL conforms to current practice  in implementations that require all pathnames to have a specific host.  Removing "structured" names should improve portability without causing  any harm, assuming no implementation uses structured names.  This will  improve portability by allowing programs to do string manipulation on  names, although such programs still have to be careful since the valid  characters and maximum length of a name are implementation-dependent.  Disallowing transferral of nonstandard component values between  different hosts or different devices allows implementations to support  multiple incompatible file systems.Current practice:    All versions of Symbolics Genera violate CLtL in the matter of hosts,  since it uses standard-objects as the host component.  Genera deviates  slightly from PATHNAME-SUBDIRECTORY-LIST, but otherwise conforms to  PATHNAME-COMPONENT-VALUE:SPECIFY.  Other implementations were not surveyed.  This proposal assumes that no current or planned implementation  uses structured names, not even for wildcards.Cost to Implementors:  Most implementations already conform, except for the changes required  by PATHNAME-UNSPECIFIC-COMPONENT and PATHNAME-SUBDIRECTORY-LIST, so  the cost of this proposal itself should be minimal.  It is conceivable  that an implementation may exist that has to change its pathname  representation, for example one that uses numbers as structured devices.Cost to Users:  None.Cost of non-adoption:    Pathnames will continue to be a poorly specified part of the language.Performance impact:  None of any significance.Benefits/Esthetics:  The boundary between the specified behavior of pathnames and the  implementation-dependent behavior of pathnames will be more clear.Discussion:  None.*start*02095 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Mar-89 21:01:14 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 MAR 89 21:01:14 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Mar 89  20:59:17 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 561655; Mon 20-Mar-89 23:36:27 ESTDate: Mon, 20 Mar 89 23:36 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUE (version 1)To: CL-Cleanup@SAIL.STANFORD.EDUcc: chapman%aitg.DEC@decwrl.dec.comIn-Reply-To: <19890320180405.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19890321043621.8.MOON@EUPHRATES.SCRC.Symbolics.COM>      When constructing a pathname from components, conforming programs      must follow these rules:        16. Any component can be taken from the corresponding component      of another pathname on the same host and device.A possible alternative that's worth considering is:      16. Any component can be taken from the corresponding component      of another pathname.  When the two pathnames are for incompatible      file systems (in implementations that support multiple file      systems), an appropriate translation occurs.  If no meaningful      translation is possible, an error is signalled.  The definition      of "appropriate" and "meaningful" is implementation-dependent.This provides more useful behavior that conforming programs can depend upon, but the behavior cannot be as precisely specified.A significant amount of the Symbolics Genera pathname facility isrelated to this capability, and it's used a lot in heterogeneousnetworks, so maybe this is a useful capability that ought to becalled for in the language.  The cost to implementors is small sincethey could define "appropriate" and "meaningful" to be whatever iseasiest for them, if their users don't complain.*start*09187 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 21-Mar-89 15:10:23 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 MAR 89 15:09:20 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Mar 89  14:53:02 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 562306; Tue 21-Mar-89 17:52:49 ESTDate: Tue, 21 Mar 89 17:52 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUE (version 1)To: X3J13@SAIL.STANFORD.EDUReferences: <19890320180405.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19890321225242.9.MOON@EUPHRATES.SCRC.Symbolics.COM>This issue came up while reviewing section 2.2 of the draft standard.Issue:         PATHNAME-COMPONENT-VALUERelated Issues:PATHNAME-CANONICAL-TYPE,               PATHNAME-SUBDIRECTORY-LIST,               PATHNAME-UNSPECIFIC-COMPONENT,               PATHNAME-WILDReferences:    CLtL pp.410-3Category:      CLARIFICATION and CHANGEEdit history:  Version 1, 20-Mar-89, by MoonProblem description:    CLtL is overly restrictive on the possible values for pathname components.  These restrictions are described in a funny way that makes it unclear  whether they are requirements, guidelines, or just an example.    The restrictions are not all written down in one place, but they appear  to be as follows:  Host          nil, :wild, string, or list of strings  Device        nil, :wild, string, or something else ("structured")  Directory     nil, :wild, string, or something else ("structured")  Name          nil, :wild, string, or something else ("structured")  Type          nil, :wild, or string  Version       nil, :wild, :newest, positive integer, implementation                dependent symbol, or implementation-dependent integer                less than or equal to zero.  Suggestions include :oldest,                :previous, :installed, 0, and -1.  PATHNAME-UNSPECIFIC-COMPONENT:NEW-TOKEN allowed implementations to  allow any component to be :UNSPECIFIC.  This has been voted in.  PATHNAME-SUBDIRECTORY-LIST proposes a list of strings and keyword  symbols for the directory component.  PATHNAME-CANONICAL-TYPE proposes some new operations but does not  change the possible values of the type component.  PATHNAME-WILD proposes a portable way to test for implementation  dependent component values that indicate wildcard matching.  It  does not change the possible values of any component.Proposal (PATHNAME-COMPONENT-VALUE:SPECIFY):  The points of the proposal have been numbered to facilitate  amendments to remove or modify individual points.  When examining pathname components, conforming programs must be  prepared to encounter any of the following values:  1. Any component can be NIL, which means the component has not  been specified.  2. Any component can be :UNSPECIFIC, which means the component has  no meaning in this particular pathname.  3. Any component can be :WILD, which matches any component value.  Wild pathnames can be used with DIRECTORY but not with OPEN.  4. The host, device, directory, name, and type can be strings.  5. The host and device can be a list, a structure, or a  standard-object at the discretion of the implementation.  6. The directory can be a list of strings and symbols as detailed in  PATHNAME-SUBDIRECTORY-LIST (this assumes that it passes.)  7. The version can be any symbol or any integer.  The symbol :NEWEST  refers to the largest version number that already exists in the file  system when reading, overwriting, appending, superseding, or directory  listing an existing file, and refers to the smallest version number  greater than any existing version number when creating a new file.  When constructing a pathname from components, conforming programs  must follow these rules:    11. Any component can be NIL.  NIL in the host may mean a default host  rather than an actual NIL in some implementations.  12. Any component can be :WILD, which matches any component value.  Wild pathnames can be used with DIRECTORY but not with OPEN.    13. The host, device, directory, name, and type can be strings.  14. The directory can be a list of strings and symbols as detailed in  PATHNAME-SUBDIRECTORY-LIST (this assumes that it passes.)  15. The version can be :NEWEST.  16. Any component can be taken from the corresponding component  of another pathname on the same host and device.  17. An implementation might support other values for some  components, but a portable program cannot use those values.    An implementation might allow values to be transferred between  pathnames on different hosts or different devices, but a portable  program cannot rely on that.  A conforming program can use implementation-dependent values  but this can make it non-portable, for example, it might work  only with Unix file systems.  18. It is suggested, but not required, that implementations use  positive integers starting at 1 as version numbers, recognize  the symbol :oldest to designate the smallest existing version  number, and use keyword symbols for other special versions.Consequences:  The changes relative to CLtL plus PATHNAME-UNSPECIFIC-COMPONENT  are as follows:  The definition of "structured" component is restricted to lists,  structures, and standard-objects, rather than allowing any object  whatsoever.    "Structured" hosts are allowed, a generalization of CLtL's list  of strings.  "Structured" directories are replaced by PATHNAME-SUBDIRECTORY-LIST.  "Structured" names are forbidden.  The difference between what component values a program can depend  on being able to use, versus what component values a program must  be prepared to encounter, is clarified.Rationale:    This should make it easier to write portable programs that deal with  pathnames and make it easier for implementors by clarifying the  framework into which they must fit.  Also it should make it easier  to write the Common Lisp language specification by resolving some  things that were unclear about the status quo.  Adding "structured" hosts conforms to current practice.  Substituting a default host for NIL conforms to current practice  in implementations that require all pathnames to have a specific host.  Removing "structured" names should improve portability without causing  any harm, assuming no implementation uses structured names.  This will  improve portability by allowing programs to do string manipulation on  names, although such programs still have to be careful since the valid  characters and maximum length of a name are implementation-dependent.  Disallowing transferral of nonstandard component values between  different hosts or different devices allows implementations to support  multiple incompatible file systems.Current practice:    All versions of Symbolics Genera violate CLtL in the matter of hosts,  since it uses standard-objects as the host component.  Genera deviates  slightly from PATHNAME-SUBDIRECTORY-LIST, but otherwise conforms to  PATHNAME-COMPONENT-VALUE:SPECIFY.  Other implementations were not surveyed.  This proposal assumes that no current or planned implementation  uses structured names, not even for wildcards.Cost to Implementors:  Most implementations already conform, except for the changes required  by PATHNAME-UNSPECIFIC-COMPONENT and PATHNAME-SUBDIRECTORY-LIST, so  the cost of this proposal itself should be minimal.  It is conceivable  that an implementation may exist that has to change its pathname  representation, for example one that uses numbers as structured devices.Cost to Users:  None.Cost of non-adoption:    Pathnames will continue to be a poorly specified part of the language.Performance impact:  None of any significance.Benefits/Esthetics:  The boundary between the specified behavior of pathnames and the  implementation-dependent behavior of pathnames will be more clear.Discussion:A possible alternative to item 16 that's worth considering is:      16. Any component can be taken from the corresponding component      of another pathname.  When the two pathnames are for incompatible      file systems (in implementations that support multiple file      systems), an appropriate translation occurs.  If no meaningful      translation is possible, an error is signalled.  The definition      of "appropriate" and "meaningful" is implementation-dependent.This provides more useful behavior that conforming programs can depend upon, but the behavior cannot be as precisely specified.A significant amount of the Symbolics Genera pathname facility isrelated to this capability, and it's used a lot in heterogeneousnetworks, so maybe this is a useful capability that ought to becalled for in the language.  The cost to implementors is small sincethey could define "appropriate" and "meaningful" to be whatever iseasiest for them, if their users don't complain.*start*04115 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 21-Mar-89 16:48:00 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 MAR 89 16:46:28 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 21 Mar 89  16:43:10 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Tue, 21 Mar 89 19:20:00 ESTDate: Tue, 21 Mar 89 19:21 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: PATHNAME-COMPONENT-VALUE (version 1)To: David A. Moon <Moon@stony-brook.scrc.symbolics.com>Cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <19890321225242.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-Id: <19890322002110.7.BARMAR@OCCAM.THINK.COM>This is all well and good, but it doesn't address the BIGGEST obstacleto portable use of MAKE-PATHNAME: uppercase vs lowercase.  If I can'twrite something as simple as	(setq dp (pathname "/u/barmar/foo.lisp"))	(namestring (make-pathname :name "bar" :defaults dp))and have it mean the same thing in Lucid and Genera, what good is allthe rest?  Anyone trying to deal with pathnames portably needs to writea set of wrapper functions, as Thinking Machines has.  Your proposalsdon't really make this much easier.The only effect of the various pathname proposals is to extend thestandard so that Symbolics's implementation conforms.  I have no problemwith this goal, but I think the approach is wrong.  What's the point ofrules 1-8, which specify the data types that the pathname accessors mayreturn, but don't specify the semantics of the values?  If we're notgoing to specify all the semantics, we might as well just say that theycan return any type, since there's nothing that a portable program cando besides stick the values in another pathname.  I think the onlyuseful rules in the whole list are 11 (any component can be NIL), 12(any component can be :WILD), 15 (the version can be :NEWEST), and 16(any component may be copied to the corresponding component of anotherpathname on the same (EQL?  EQUAL?) host and device).  Rule 13 (mostcomponents can be strings) is not useful because it doesn't define therelationship between the string specified and the name of the file thatwill be accessed (CLtL doesn't say whether (make-pathname :name "FOO")accesses a file named "FOO", "foo", or "BAR").Background:For those of you not familiar with Genera's mechanism for dealing withpathname case (with which I can't really find fault, because it is theonly way to solve problem of name translation across OS types, but itdoes result in portability problems), the above sequence results in"/u/barmar/BAR.lisp" in Genera, but "/u/barmar/bar.lisp" in most Uniximplementations.  In Genera, the string arguments to MAKE-PATHNAME, andthe results of the PATHNAME-<component> functions, are not necessarilyin the same case the actual pathname, but in a format called"interchange case".  In interchange format, uppercase represents thepreferred case for the OS, lowercase represents the opposite case, andmixed case is used verbatim.  This allows you to do	(make-pathname :name (pathname-name <unix-path>) :defaults <vms-path>)and have the lowercase Unix name translated to an uppercase VMS nameautomatically.Unfortunately, I can't think of any way to solve this problem in thestandard without incorporating the whole concept of interchange caseinto it.  There might not be too much opposition to it if we change thedesign so that lowercase were used to represent the preferred case,though.  How many uppercase-preferred systems are used much for CommonLisp?  Are there any besides VAX/VMS?  (Uppercase-only systems such asMS-DOS and case-insensitive systems such as Macintosh don't count, sincethey can use uppercase or lowercase interchangeably without affectingthe semantics.)By the way, there should probably be a rule somewhere that says thatportable programs shouldn't expect to be able to create and/or accessdistinct files whose pathname components differ only in case.*start*03692 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 21-Mar-89 17:54:52 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 MAR 89 17:54:49 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Mar 89  17:52:34 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 562499; Tue 21-Mar-89 20:49:08 ESTDate: Tue, 21 Mar 89 20:48 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUE (version 1)To: Barry Margolin <barmar@Think.COM>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19890322002110.7.BARMAR@OCCAM.THINK.COM>Message-ID: <19890322014857.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 21 Mar 89 19:21 EST    From: Barry Margolin <barmar@Think.COM>    This is all well and good, but it doesn't address the BIGGEST obstacle    to portable use of MAKE-PATHNAME: uppercase vs lowercase.  PATHNAME-COMPONENT-CASE addresses that; it's a separate issue.  I don'tknow whether it's on the agenda for next week, but I hope it is.    The only effect of the various pathname proposals is to extend the    standard so that Symbolics's implementation conforms.  Well, I certainly hope that with all the pathname proposals together, that is not the only effect!  The goal is to constrain the semanticsof pathnames enough to allow writing portable pathname-using programs,so people will stop complaining that pathnames are a useless wart.Maybe it was wrong to break it up into separate issues.							   I have no problem    with this goal, but I think the approach is wrong.  What's the point of    rules 1-8, which specify the data types that the pathname accessors may    return, but don't specify the semantics of the values?  If we're not    going to specify all the semantics, we might as well just say that they    can return any type, since there's nothing that a portable program can    do besides stick the values in another pathname.  I think the only    useful rules in the whole list are 11 (any component can be NIL), 12    (any component can be :WILD), 15 (the version can be :NEWEST), and 16    (any component may be copied to the corresponding component of another    pathname on the same (EQL?  EQUAL?) host and device).  Rule 13 (most    components can be strings) is not useful because it doesn't define the    relationship between the string specified and the name of the file that    will be accessed (CLtL doesn't say whether (make-pathname :name "FOO")    accesses a file named "FOO", "foo", or "BAR").I think you're partly right here.  It was probably a mistake to try toconstrain the types of "structured" values, because there is nothingthat a portable program can do with a "structured" value that depends onthe type.As for strings, the intent was that with PATHNAME-COMPONENT-CASE therelation between the string and the name of the file is fully specified;I guess that wasn't at all clear from the PATHNAME-COMPONENT-VALUEwriteup.  Similarly, with PATHNAME-SUBDIRECTORY-LIST the relationbetween the list and the name of the directory is fully specified.I see the proposal for PATHNAME-COMPONENT-CASE is rather stale, I'llsee if I can work up a version updated from the discussion tonight ortomorrow.    By the way, there should probably be a rule somewhere that says that    portable programs shouldn't expect to be able to create and/or access    distinct files whose pathname components differ only in case.Good point.*start*01122 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 21-Mar-89 22:30:37 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 MAR 89 22:30:32 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 21 Mar 89  22:27:46 PSTReturn-Path: <barmar@Think.COM>Received: from kulla.think.com by Think.COM; Wed, 22 Mar 89 00:54:22 ESTReceived: by kulla.think.com; Wed, 22 Mar 89 00:54:37 ESTDate: Wed, 22 Mar 89 00:54:37 ESTFrom: barmar@Think.COMMessage-Id: <8903220554.AA25095@kulla.think.com>To: Moon@stony-brook.scrc.symbolics.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 21 Mar 89 20:48 EST <19890322014857.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUE (version 1)Not being on cl-cleanup, I wasn't aware of PATHNAME-COMPONENT-CASE.You may be right that it was wrong to break up the issues.  On theother hand, merging them all together would probably result in a2K-line issue, which is no fun, either.						barmar*start*09016 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 23-Mar-89 17:13:12 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 17:12:50 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 23 Mar 89  15:52:13 PSTReceived: from pitney-bowes ([192.9.200.50]) by heavens-gate.lucid.com id AA03552g; Thu, 23 Mar 89 12:36:58 PSTReceived: by pitney-bowes id AA26463g; Thu, 23 Mar 89 12:35:22 PSTDate: Thu, 23 Mar 89 12:35:22 PSTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8903232035.AA26463@pitney-bowes>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: X3J13@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Tue, 21 Mar 89 17:52 EST <19890321225242.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUE (version 1)PATHNAME-COMPONENT-VALUE:SPECIFY seems seriously flawed to me.  I givesome reasons, a sktech of a strawman alternative, and some options toconsider.  Pardon the length, but the issue is one of the messiest thatCL must deal with.  If you're really pressed, search for "given all".My particular concern is that by restricting pathname-names, forexample, to be strings, PATHNAME-COMPONENT-VALUE:SPECIFY hides thesemantics associated with a pathname behind host-specific stringparsing rules.  ("Structured" names are forbidden.)  My comments willrefer to pathname-names, but similar arguments should apply forpathname-types and elements of directory lists.Part of the rationale says:  Removing "structured" names should improve portability without causing  any harm, assuming no implementation uses structured names.  This will  improve portability by allowing programs to do string manipulation on  names, although such programs still have to be careful since the valid  characters and maximum length of a name are implementation-dependent.But I fail to see how string manipulation functions are particularlyuseful or intuitive when porting the un*x c-shell wildcard name"/foo/a?b.lisp" into an MVS pathname, where there is no system supportfor single-character wildcards.  I would rather specify somethinglike:   (MAKE-PATHNAME :DIRECTORY *source-dir*                  :NAME      '("a" :WILD-CHARACTER "b")                   :EXTENSION "lisp")and let CL handle the wildcard problem if the OS doesn't.Also note that the "host" parsing rules may be something as specificas a shell convention.  E.e., un*x filesystems do not treat "*" at all specially--that is done by the shells.  Only a kind of peer pressure keeps the shells and other utilities fairly consistent on agiven machine.In spite of the paragraph quoted above from the rationale, I assumethe best motivation for hiding the semantics is to be able to deferall such semantic questions to the host, to avoid any need to querythe host during normal pathname manipulations.  I.e., when a usertypes "a$b" for host foo, lisp don't need to query foo to discoverthat this is a wildcard template or means burn after reading.  (Don'tlaugh--the "3" in "FOO LISP A3" for CMS means erase this file as soonas the first reference is closed, as opposed to "FOO LISP A1" which means treat this as a normal file, or "FOO LISP A7" which is illegal.)Overall, I see three generic problems:  (1)  To determine if a given pathname-name (e.g. "a$b") is a specific       filename or a template, one needs to invoke some as-yet       unspecified oracle.  Something like the proposal       PATHNAME-EXTENSIONS would be needed to address this issue.  (2)  To portably make a template to select a given set of filenames,       one needs to consult an unspecified inverse oracle.         >> I've seen no proposal that addresses this problem. <<       E.g., consider the problem of making a template that will match       all filenames on a given directory starting with "a" and ending       with "b".  How would I write this??       Or consider the problem of finding all files that match "*foo*"       (using Unix csh conventions), but not "*.lisp".  Under the       given proposal, one is forced to use the DIRECTORY function to       get truenames for all the "*.lisp" files before doing the       set-difference.  This seems very clumsy and wasteful when       compared to what DIRECTORY could accomplish if it understood       pathnames containing regular expressions.        Also note that some operating systems (e.g. MVS) support the       notion of the "*" wildcard convention (wild string), but not       "?" (wild character).  So the proposal mandates that it must be       impossible to portably create a pathname template for names of       three characters starting with "a" and ending with "b".   (3)  OS oracles such as those proposed by PATHNAME-EXTENSIONS cannot       hope to address all novel or idiosyncratic features of       file-systems, except in the very weak sense of saying "here be       dragons".  More informative oracles would be needed for       portability, so over time we must be prepared to augment the       standard or ports must write ad hoc oracles for things like       "A3" on CMS.  This is only vaguely addressed through the       proposals about legal extensions to Common Lisp. An alternative scheme (admittedly not perfect) would be to standardizean internal format for things like wildcard templates, e.g. ("a" :WILD-STRING "b").  This addresses the three problems as follows:   (1)  The first problem partially goes away--e.g., "a$b" could be       treated unambiguously as a three-character filename, even for       hosts where shells, etc. tend to treat "$" specially.       Templates would be required to be non-atomic objects, perhaps       lists starting with :WILD.  (In effect, the oracle at this       level has been reduced to simple standardized rules on obvious       lisp data formats.)        Unfortunately, the problem has been pushed to another level,       since users are presumably typing filenames according to host-       specific conventions which they expect to be honored.  Even if       the internal representation becomes largely host-independant,       parse-namestring may need to consult the same oracles mentioned       above to be able to internalize correctly.  This could even be       pessimal in putting all of the semantic burden (hence perhaps       file-system queries) up front when it might otherwise be       avoided.  In general though, there can be CL code to emulate       most of the parsing that would be done by the filesystem, and       there could be an escape such as (:UNPARSED "a$b"), to allow       parsing to be deferred until necessary.         On the whole, I think something like this alternative scheme       would win on this point.        (2)  The second problem goes away (it was the original motivation       for this message).  E.g., the rules for making a wildcard are       standardized and portable.  (Of course, each implementor then       needs to interpret ("a" :WILD-STRING "b") appropriately, which       might involve the creation of a string like "a$b".  But       implementors are trained to deal with such details.)   (3)  The third problem comes back with a vengeance, since nothing       would be passed through "as is", and thus novel features by       definition would be prohibited.  This could be addressed by       adding an escape that passes things through to the OS for       semantic parsing without CL attempting to understand them.  How       users would indicate this option is problematic.Given all of the above, I think a more flexible proposal for pathnameswould allow the name field (for example) to be structured as at leastany of the following:   "a*b"                   -- a 3-character filename, or  (:EXPLICIT "a*b")       -- a 3-character filename  ("a" :WILD-STRING "b")  -- a template for filenames string with "a"                             and ending with "b"  (:UNPARSED "a*b")       -- a filename or template that may require                             an OS request to disambiguate (when                             parsed, this should yield a standard CL                             format)  (:UNINTERPRETED "a*b")  -- a filename or template that CL will not                             attempt to understand (if used                              inappropriately, the consequences are                              undefined)It should be a separate issue which of these (PARSE-NAMESTRING "a*b")would produce.PATHNAME-COMPONENT-VALUE:SPECIFY seems to give "a*b" the semantics of :UNINTERPRETED and forbid all other options.  Personally, I wouldprefer to give "a*b" the semantics of :EXPLICIT and allow at least these four options.The rules for parse-namestring require more thought than I can affordright now, but I hope this suffices to show that the stated proposalis, unfortunately, far more problematic than advertized.   jlm*start*01543 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 23-Mar-89 16:11:23 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAR 89 16:11:17 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 23 Mar 89  15:51:29 PSTReceived: from pitney-bowes ([192.9.200.50]) by heavens-gate.lucid.com id AA03604g; Thu, 23 Mar 89 13:25:02 PSTReceived: by pitney-bowes id AA26521g; Thu, 23 Mar 89 13:23:24 PSTDate: Thu, 23 Mar 89 13:23:24 PSTFrom: Jim McDonald <jlm@lucid.com>Message-Id: <8903232123.AA26521@pitney-bowes>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: X3J13@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Tue, 21 Mar 89 17:52 EST <19890321225242.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUE (version 1)Food for thought:An interesting alternative that was just suggested to me would splitthe type PATHNAME into something like PATHNAME and PATHNAME-TEMPLATE.OPEN, TRUENAME, and friends would accept only PATHNAME arguments,and DIRECTORY would accept only PATHNAME-TEMPLATE arguments.(DIRECTORY would return a list of PATHNAME's.)This would perhaps enhance our ability to stabilize the syntax andsemantics of PATHNAME much more rigidly, and leave open room forexperimentation with PATHNAME-TEMPLATE, where there seems to be moreneed for it.  The basic idea is that a pathname would specify at most one file (itcould be bogus), whereas PATHNAME-TEMPLATE would specify a set offiles.   jlm*start*01017 00024 US Date:  4 Apr 89 12:52 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: PATHNAME-COMPONENT-VALUETo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUETo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:45:55 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:24:23 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571227; Tue 4-Apr-89 15:24:18 EDTOriginal-Date: Tue, 4 Apr 89 15:23 EDTMessage-ID: <890404152354.0.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis was deferred to the next meeting.*start*01017 00024 USmDate:  4 Apr 89 12:52 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: PATHNAME-COMPONENT-VALUETo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUETo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:45:55 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:24:23 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571227; Tue 4-Apr-89 15:24:18 EDTOriginal-Date: Tue, 4 Apr 89 15:23 EDTMessage-ID: <890404152354.0.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis was deferred to the next meeting.*start*09682 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-May-89 10:15:47 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAY 89 10:15:45 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 23 May 89  10:13:57 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 599391; 23 May 89 13:15:46 EDTDate: Tue, 23 May 89 13:20 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PATHNAME-COMPONENT-VALUE (version 2)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19890523172011.4.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This issue is on the agenda for the June X3J13 meeting.  KMP and Ihave prepared a revised writeup which we think is ready for release.I'd like to distribute this to X3J13 as soon as discussion, if any,in the cleanup subcommittee is completed.Issue:         PATHNAME-COMPONENT-VALUERelated Issues:PATHNAME-CANONICAL-TYPE,               PATHNAME-SUBDIRECTORY-LIST,               PATHNAME-UNSPECIFIC-COMPONENT,               PATHNAME-WILDReferences:    CLtL pp.410-3Category:      CLARIFICATION and CHANGEEdit history:  Version 1, 20-Mar-89, by Moon               Version 2,  9-May-89, by Moon (rewrite based on mail)Problem description:    CLtL is overly restrictive on the possible values for pathname components.  These restrictions are described in a funny way that makes it unclear  whether they are requirements, guidelines, or just an example.    The restrictions are not all written down in one place, but they appear  to be as follows:  Host          nil, :wild, string, or list of strings  Device        nil, :wild, string, or something else ("structured")  Directory     nil, :wild, string, or something else ("structured")  Name          nil, :wild, string, or something else ("structured")  Type          nil, :wild, or string  Version       nil, :wild, :newest, positive integer, implementation                dependent symbol, or implementation-dependent integer                less than or equal to zero.  Suggestions include :oldest,                :previous, :installed, 0, and -1.  PATHNAME-UNSPECIFIC-COMPONENT:NEW-TOKEN allowed implementations to  allow any component to be :UNSPECIFIC.  This has been voted in.  PATHNAME-SUBDIRECTORY-LIST proposes a list of strings and keyword  symbols for the directory component.  PATHNAME-CANONICAL-TYPE proposes some new operations but does not  change the possible values of the type component.  PATHNAME-WILD proposes a portable way to test for implementation  dependent component values that indicate wildcard matching.  It  does not change the possible values of any component.Proposal (PATHNAME-COMPONENT-VALUE:SPECIFY):  The points of the proposal have been numbered/lettered to facilitate  discussion of individual points.  0. Pathname component value strings never contain the punctuation  characters that are used to separate pathname fields (e.g. slashes and  dots in Unix).  Punctuation characters appear only in namestrings.  Characters used as punctuation can appear in pathname component values  with a non-punctuation meaning if the file system allows it (e.g. a Unix  file name that begins with a dot).  When examining pathname components, conforming programs must be prepared  to encounter any of the following values:      1. Any component can be NIL, which means the component has not    been specified.      2. Any component can be :UNSPECIFIC, which means the component has    no meaning in this particular pathname.      3. The device, directory, name, and type can be strings.      4. The host can be any object, at the discretion of the implementation.      5. The directory can be a list of strings and symbols as detailed in    PATHNAME-SUBDIRECTORY-LIST (this assumes that it passes.)      6. The version can be any symbol or any integer.  The symbol :NEWEST    refers to the largest version number that already exists in the file    system when reading, overwriting, appending, superseding, or directory    listing an existing file, and refers to the smallest version number    greater than any existing version number when creating a new file.    Other symbols and integers have implementation-defined meaning.    It is suggested, but not required, that implementations use positive    integers starting at 1 as version numbers, recognize the symbol :OLDEST    to designate the smallest existing version number, and use keyword    symbols for other special versions.  Wildcard pathnames can be used with DIRECTORY but not with OPEN, and  return true from WILD-PATHNAME-P (if issue PATHNAME-WILD passes).  When  examining wildcard components of a wildcard pathname, conforming programs  must be prepared to encounter any of the following additional values  in any component or any element of a list that is the directory component:    7. :WILD, which matches anything.    8. A string containing implementation-dependent special wildcard    characters.    9. Any object, representing an implementation-dependent wildcard    pattern.  When constructing a pathname from components, conforming programs  must follow these rules:      a. Any component can be NIL.  NIL in the host may mean a default host    rather than an actual NIL in some implementations.        b. The host, device, directory, name, and type can be strings.  There    are implementation-dependent limits on the number and type of    characters in these strings.      c. The directory can be a list of strings and symbols as detailed in    PATHNAME-SUBDIRECTORY-LIST (this assumes that it passes.)  There are    implementation-dependent limits on the list's length and contents.      d. The version can be :NEWEST.    e. Any component can be taken from the corresponding component    of another pathname.  When the two pathnames are for different    file systems (in implementations that support multiple file    systems), an appropriate translation occurs.  If no meaningful    translation is possible, an error is signalled.  The definitions    of "appropriate" and "meaningful" are implementation-dependent.      f. When constructing a wildcard pathname, the name, type, or version    can be :WILD, which matches anything.      g. An implementation might support other values for some components,    but a portable program cannot use those values.  A conforming program    can use implementation-dependent values but this can make it    non-portable, for example, it might work only with Unix file systems.Consequences:  The changes relative to CLtL plus PATHNAME-UNSPECIFIC-COMPONENT  are as follows:  The removal of punctuation characters during parsing is specified.  "Structured" components are disallowed in non-wildcard pathnames,  except for the specific structuring of directories specified  in issue PATHNAME-SUBDIRECTORY-LIST.    "Structured" hosts are allowed, a generalization of CLtL's list  of strings.  The type and version can be "structured" in wildcard pathnames.    The difference between what component values a program can depend  on being able to use, versus what component values a program must  be prepared to encounter, is clarified.  The implementation-dependent variations are identified explicitly.Rationale:    This should make it easier to write portable programs that deal with  pathnames and make it easier for implementors by clarifying the  framework into which they must fit.  Also it should make it easier  to write the Common Lisp language specification by resolving some  things that were unclear about the status quo.  Adding "structured" hosts conforms to current practice.  Substituting a default host for NIL conforms to current practice  in implementations that require all pathnames to have a specific host.  Confining "structured" devices and names to wildcard pathnames, and  replacing "structured" directories with an explicit specification of  the form of the directory value, should improve portability without causing  any harm.  :WILD is only required to be supported in the name, type, or version,  which are the easiest to implement and the most useful in applications.Current practice:    All versions of Symbolics Genera violate CLtL in the matter of hosts,  since it uses standard-objects as the host component.  Genera deviates  slightly from PATHNAME-SUBDIRECTORY-LIST, but otherwise conforms to  PATHNAME-COMPONENT-VALUE:SPECIFY.  Other implementations were not surveyed.  This proposal assumes that no current or planned implementation  uses "structured" names except possibly for wildcards.Cost to Implementors:  Most implementations already conform, except for the changes required  by PATHNAME-UNSPECIFIC-COMPONENT and PATHNAME-SUBDIRECTORY-LIST, so  the cost of this proposal itself should be minimal.  It is conceivable  that an implementation may exist that has to change its pathname  representation, for example one that uses numbers as "structured" devices.  Some implementations may have to change their treatment of punctuation  characters.Cost to Users:  None.Cost of non-adoption:    Pathnames will continue to be a poorly specified part of the language.Performance impact:  None of any significance.Benefits/Esthetics:  The boundary between the specified behavior of pathnames and the  implementation-dependent behavior of pathnames will be more clear.Discussion:  None.*start*00987 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 24-May-89 23:40:04 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAY 89 23:40:08 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 24 May 89  23:38:25 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 24 MAY 89 23:38:03 PDTDate: 24 May 89 23:37 PDTFrom: masinter.paSubject: Re: Issue: PATHNAME-COMPONENT-VALUE (version 2)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 23 May 89 13:20 EDTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@sail.stanford.eduMessage-ID: <890524-233803-10977@Xerox>I wish "other implementations were not surveyed" were not true. Will "otherimplementations" speak up?  My quick glance at this didn't turn up anythingtoo serious, except the risk of overspecifying based on limited experience.*start*01373 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 25-May-89 12:50:56 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAY 89 12:50:44 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 25 May 89  12:49:02 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 600733; 25 May 89 12:01:12 EDTDate: Thu, 25 May 89 12:05 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PATHNAME-COMPONENT-VALUE (version 2)To: masinter.pacc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <890524-233803-10977@Xerox>Message-ID: <19890525160515.6.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>Line-fold: No    Date: 24 May 89 23:37 PDT    From: masinter.pa@Xerox.COM    I wish "other implementations were not surveyed" were not true. Me too.    Will "other implementations" speak up?I do not have convenient access to most Common Lisp implementations, soI was hoping to rely on the other members of the Cleanup committee, whotogether cover a pretty broad range of systems, to supply currentpractice information before the issue is forwarded to X3J13 as a whole.This applies to all of the pathname issues.  Please help, y'all.*start*01220 00024 US GV-Info: Gray@DSG.csc.ti.com at 25-May-89 14:57:55 from AGReturn-Path: <Gray@DSG.csc.ti.com>Received: from ti.com ([128.247.159.141]) by Xerox.COM ; 25 MAY 89 14:57:38 PDTReceived: by ti.com id AA20849; Thu, 25 May 89 16:56:53 CDTReceived: from dsg by tilde id AA04070; Thu, 25 May 89 16:37:46 CDTReceived: From Kelvin By dsg Via CHAOS-NET With CHAOS-MAIL; Thu, 25 May 89  11:28:28 CDTMessage-Id: <2821105757-10704406@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Thu, 25 May 89 11:29:17 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: masinter.pa, "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: PATHNAME-COMPONENT-VALUE (version 2)In-Reply-To: Msg of 24 May 89 23:37 PDT from masinter.pa@Xerox.COM> I wish "other implementations were not surveyed" were not true. Will "other> implementations" speak up? Like Genera, the Explorer current practice is to use an object instead ofa string for the host component.  The directory component is a list ofstrings, not yet supporting the symbols specified in proposalPATHNAME-SUBDIRECTORY-LIST; other than that, the Explorer conforms toproposal PATHNAME-COMPONENT-VALUE:SPECIFY.*start*01666 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 25-May-89 11:32:29 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAY 89 11:32:37 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 25 May 89  11:30:11 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA11868; Thu, 25 May 89 12:30:31 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA09139; Thu, 25 May 89 12:30:29 -0600From: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8905251830.AA09139@defun.utah.edu>Date: Thu, 25 May 89 12:30:28 MDTSubject: Re: Issue: PATHNAME-COMPONENT-VALUE (version 2)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@sail.stanford.edu, sandra%defun@cs.utah.edu, gray@dsg.csc.ti.comIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Tue, 23 May 89 13:20 EDTAs I've said before, I don't think that trying to construct or pickapart pathnames by component can be accomplished portably in any case,because even if you restrict the representation of what can appear inthe various components, the objects you stuff in may or may not makesense for a particular file system.  Instead, I would much prefer todeprecate MAKE-PATHNAME and the PATHNAME-xxx accessors and leave thequestion of representation of components unspecified in the standard.I realize that this position may be seen as being too extreme.  Inthat case I'd be willing to shut up and go along with proposal SPECIFYas long as my position gets noted in the writeup.-Sandra-------*start*00853 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 13-Jun-89 15:22:07 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JUN 89 15:22:01 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 13 Jun 89  15:20:43 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 610814; 13 Jun 89 18:22:25 EDTDate: Tue, 13 Jun 89 18:22 EDTFrom: Kim Barrett <IIM@ECLA.USC.EDU>Sender: KMP@STONY-BROOK.SCRC.Symbolics.COMSubject: Issue: PATHNAME-COMPONENT-VALUE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUComments: Received from Kim Barrett by KMP on MSDOS floppy disk via US MailMessage-ID: <19890613222215.7.KMP@BOBOLINK.SCRC.Symbolics.COM>Ok.*start*12087 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Jun-89 22:08:49 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 JUN 89 22:08:50 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 16 Jun 89  21:52:55 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 612480; 17 Jun 89 00:54:54 EDTDate: Sat, 17 Jun 89 00:55 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Reply-To: CL-Cleanup@sail.stanford.eduSubject: Issue: PATHNAME-COMPONENT-VALUE (version 3)To: X3J13@sail.stanford.eduMessage-ID: <19890617045523.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Issue:         PATHNAME-COMPONENT-VALUERelated Issues:PATHNAME-CANONICAL-TYPE,               PATHNAME-SUBDIRECTORY-LIST,               PATHNAME-UNSPECIFIC-COMPONENT,               PATHNAME-WILDReferences:    CLtL pp.410-3Category:      CLARIFICATION and CHANGEEdit history:  Version 1, 20-Mar-89, by Moon               Version 2,  9-May-89, by Moon (rewrite based on mail)               Version 3, 17-Jun-89, by Moon (add discussion, current practice)Problem description:    CLtL is overly restrictive on the possible values for pathname components.  These restrictions are described in a funny way that makes it unclear  whether they are requirements, guidelines, or just an example.    The restrictions are not all written down in one place, but they appear  to be as follows:  Host          nil, :wild, string, or list of strings  Device        nil, :wild, string, or something else ("structured")  Directory     nil, :wild, string, or something else ("structured")  Name          nil, :wild, string, or something else ("structured")  Type          nil, :wild, or string  Version       nil, :wild, :newest, positive integer, implementation                dependent symbol, or implementation-dependent integer                less than or equal to zero.  Suggestions include :oldest,                :previous, :installed, 0, and -1.  PATHNAME-UNSPECIFIC-COMPONENT:NEW-TOKEN allowed implementations to  allow any component to be :UNSPECIFIC.  This has been voted in.  PATHNAME-SUBDIRECTORY-LIST proposes a list of strings and keyword  symbols for the directory component.  PATHNAME-CANONICAL-TYPE proposes some new operations but does not  change the possible values of the type component.  PATHNAME-WILD proposes a portable way to test for implementation  dependent component values that indicate wildcard matching.  It  does not change the possible values of any component.Proposal (PATHNAME-COMPONENT-VALUE:SPECIFY):  The points of the proposal have been numbered/lettered to facilitate  discussion of individual points.  0. Pathname component value strings never contain the punctuation  characters that are used to separate pathname fields (e.g. slashes and  dots in Unix).  Punctuation characters appear only in namestrings.  Characters used as punctuation can appear in pathname component values  with a non-punctuation meaning if the file system allows it (e.g. a Unix  file name that begins with a dot).  When examining pathname components, conforming programs must be prepared  to encounter any of the following values:      1. Any component can be NIL, which means the component has not    been specified.      2. Any component can be :UNSPECIFIC, which means the component has    no meaning in this particular pathname.      3. The device, directory, name, and type can be strings.      4. The host can be any object, at the discretion of the implementation.      5. The directory can be a list of strings and symbols as detailed in    PATHNAME-SUBDIRECTORY-LIST (this assumes that it passes.)      6. The version can be any symbol or any integer.  The symbol :NEWEST    refers to the largest version number that already exists in the file    system when reading, overwriting, appending, superseding, or directory    listing an existing file, and refers to the smallest version number    greater than any existing version number when creating a new file.    Other symbols and integers have implementation-defined meaning.    It is suggested, but not required, that implementations use positive    integers starting at 1 as version numbers, recognize the symbol :OLDEST    to designate the smallest existing version number, and use keyword    symbols for other special versions.  Wildcard pathnames can be used with DIRECTORY but not with OPEN, and  return true from WILD-PATHNAME-P (if issue PATHNAME-WILD passes).  When  examining wildcard components of a wildcard pathname, conforming programs  must be prepared to encounter any of the following additional values  in any component or any element of a list that is the directory component:    7. :WILD, which matches anything.    8. A string containing implementation-dependent special wildcard    characters.    9. Any object, representing an implementation-dependent wildcard    pattern.  When constructing a pathname from components, conforming programs  must follow these rules:      a. Any component can be NIL.  NIL in the host may mean a default host    rather than an actual NIL in some implementations.        b. The host, device, directory, name, and type can be strings.  There    are implementation-dependent limits on the number and type of    characters in these strings.      c. The directory can be a list of strings and symbols as detailed in    PATHNAME-SUBDIRECTORY-LIST (this assumes that it passes.)  There are    implementation-dependent limits on the list's length and contents.      d. The version can be :NEWEST.    e. Any component can be taken from the corresponding component    of another pathname.  When the two pathnames are for different    file systems (in implementations that support multiple file    systems), an appropriate translation occurs.  If no meaningful    translation is possible, an error is signalled.  The definitions    of "appropriate" and "meaningful" are implementation-dependent.      f. When constructing a wildcard pathname, the name, type, or version    can be :WILD, which matches anything.      g. An implementation might support other values for some components,    but a portable program cannot use those values.  A conforming program    can use implementation-dependent values but this can make it    non-portable, for example, it might work only with Unix file systems.Consequences:  The changes relative to CLtL plus PATHNAME-UNSPECIFIC-COMPONENT  are as follows:  The removal of punctuation characters during parsing is specified.  "Structured" components are disallowed in non-wildcard pathnames,  except for the specific structuring of directories specified  in issue PATHNAME-SUBDIRECTORY-LIST.    "Structured" hosts are allowed, a generalization of CLtL's list  of strings.  The type and version can be "structured" in wildcard pathnames.    The difference between what component values a program can depend  on being able to use, versus what component values a program must  be prepared to encounter, is clarified.  The implementation-dependent variations are identified explicitly.Rationale:    This should make it easier to write portable programs that deal with  pathnames and make it easier for implementors by clarifying the  framework into which they must fit.  Also it should make it easier  to write the Common Lisp language specification by resolving some  things that were unclear about the status quo.  Adding "structured" hosts conforms to current practice.  Substituting a default host for NIL conforms to current practice  in implementations that require all pathnames to have a specific host.  Confining "structured" devices and names to wildcard pathnames, and  replacing "structured" directories with an explicit specification of  the form of the directory value, should improve portability without causing  any harm.  :WILD is only required to be supported in the name, type, or version,  which are the easiest to implement and the most useful in applications.Current practice:    All versions of Symbolics Genera violate CLtL in the matter of hosts,  since it uses standard-objects as the host component.  Genera deviates  slightly from PATHNAME-SUBDIRECTORY-LIST, but otherwise conforms to  PATHNAME-COMPONENT-VALUE:SPECIFY.  Like Genera, the Explorer current practice is to use an object instead of  a string for the host component.  The directory component is a list of  strings, not yet supporting the symbols specified in proposal  PATHNAME-SUBDIRECTORY-LIST; other than that, the Explorer conforms to  proposal PATHNAME-COMPONENT-VALUE:SPECIFY.  Macintosh Allegro Common Lisp 1.2.2 uses NIL and "" for :UNSPECIFIC,  and uses a string with punctuation characters instead of a list for  the directory.  MAKE-PATHNAME won't set a component to NIL when  :DEFAULTS is used, it merges with the defaults instead.  Otherwise it seems consistent with what is proposed.  Lucid Common Lisp 3.0.1 under Unix uses NIL for :UNSPECIFIC, and uses  a list for directories of somewhat different form from what is proposed  in PATHNAME-SUBDIRECTORY-LIST.  Lucid lets you store arbitrary information  in the version field with MAKE-PATHNAME :VERSION and will return it with  PATHNAME-VERSION (as long as it's a symbol or an integer), even though  it's not used.  Otherwise it seems consistent with what is proposed.  Ibuki Common Lisp Release 01/01 behaves the same as Lucid, including the  same form of structured directory, except it doesn't have the ability to  store information in the unused pathname version field, and it has the  same bug in MAKE-PATHNAME that the Macintosh has.  Otherwise it seems  consistent with what is proposed.  Other implementations were not surveyed.  This proposal assumes that no current or planned implementation  uses "structured" names except possibly for wildcards.Cost to Implementors:  Most implementations already conform, except for the changes required  by PATHNAME-UNSPECIFIC-COMPONENT and PATHNAME-SUBDIRECTORY-LIST, so  the cost of this proposal itself should be minimal.  It is conceivable  that an implementation may exist that has to change its pathname  representation, for example one that uses numbers as "structured" devices.  Some implementations may have to change their treatment of punctuation  characters.Cost to Users:  None.Cost of non-adoption:    Pathnames will continue to be a poorly specified part of the language.Performance impact:  None of any significance.Benefits/Esthetics:  The boundary between the specified behavior of pathnames and the  implementation-dependent behavior of pathnames will be more clear.Discussion:  Sandra Loosemore comments:    As I've said before, I don't think that trying to construct or pick    apart pathnames by component can be accomplished portably in any case,    because even if you restrict the representation of what can appear in    the various components, the objects you stuff in may or may not make    sense for a particular file system.  Instead, I would much prefer to    deprecate MAKE-PATHNAME and the PATHNAME-xxx accessors and leave the    question of representation of components unspecified in the standard.        I realize that this position may be seen as being too extreme.  In    that case I'd be willing to shut up and go along with proposal SPECIFY    as long as my position gets noted in the writeup.      Larry Masinter and Dave Moon both feel that we should be able to  prescribe exact pathname component values for popular file systems, so  that multiple implementations will behave the same way when using the  same file system.  Obvious candidates as the key file systems are MS/DOS,  Macintosh, Unix, and VAX/VMS.  A call for volunteers to write up tables  for any of them produced absolutely no response, however.