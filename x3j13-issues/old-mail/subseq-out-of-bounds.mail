*start*04010 00024 USaDate: 20 Nov 87 15:13 PSTFrom: Masinter.paSubject: Issue: SUBSEQ-OUT-OF-BOUNDSTo: Waldrum@TI-CSL.CSNETcc: MasinterThis is a reminder that you said you would write up this issue. - SUBSEQ-OUT-OF-BOUNDS (from ISSUES file, no formal proposal)   (p 246) "Specify that it is an error for the SUBSEQ indices or any   :START or :END argument have a negative index or point past the end   of the sequence in question.  (With respect to whether signalling is   required, this error will be treated the same as array   out-of-bounds.)"   Need volunteer to write up  Format for proposals to the cleanup committee (Version 13)                    November 20, 1987Replace the text below in >> double inverted angle-brackets <<. Bebrief; leave testimonials and personal opinions to the discussion at theend. Be complete; do not expect someone else to fix or redesign parts.Spell out names (e.g., Masinter rather than LMM) and upper-case all Lispsymbols (DEFUN rather than Defun). I like it better if you write in thethird person rather than first.Issue:         >>A short descriptive label, which starts with a name               which occurs in the index of CLtL, and be a suitable               symbol in the Common Lisp style, e.g., CDR-TERMINATION.<<References:    >>The pages of CLtL which describe the feature being               discussed, and other references, including other               related issues.<<Category:      >>One or more of:               CLARIFICATION -- proposal to resolve an ambiguity or case               of under-specified situation in CLtL, where this               ambiguity interferes with portability of code.               CHANGE -- proposal for an incompatible change.               ADDITION -- proposal for a compatible extension<<Edit history:  >>Author and date of submission (version 1), and author               and date of subsequent versions.<<Problem description:>>Describe the problem being addressed -- why is the current situationunclear or unsatisfactory? Avoid describing the proposal here or arguingfor its adoption. <<Proposal (>>issue-label:proposal-label<<): >> Describe as precisely aspossible what you are proposing.  Ideally, this should take the form oftext that could be dropped into the new specification document.Proposals should be for changes to Common Lisp, rather than changes toCLtL.  If necessary, propose a set of labelled alternatives here, ratherthan a single proposal. Each proposal must be a complete design; do notleave out details.  Avoid arguing for the proposal here, just describeit.<<Test Cases/Examples:>> Examples are samples of Common Lisp code that illustrates the issue.along with explanatory text.Test Cases are simple stand-alone expressions which are valid anddo not signal an error if the proposal is adhered to. (Use ASSERTif you need.)<<Rationale:>> A one or two sentence summary of the arguments that follow. <<Current practice:>>Do some/many/no Common Lisp implementations already work this way?Survey independent Common Lisp implementations - preferably three ormore.<<Cost to Implementors:>>What is the cost to implementors of adopting the proposal?  How muchimplementation effort is required?  Is public-domain code available? Forpervasive changes, can the conversion be automated?<<Cost to Users:>>For incompatible changes, what is the cost to users of convertingexisting user code?  To what extent can the process be automated? How?<<Cost of non-adoption:>>How serious is it if nothing is done? <<Benefits:>>What is better if the proposal is adopted? How serious is the problemif just left as it is? <<Esthetics:>>How does this proposal affect the simplicity of the language, ease oflearning, etc. You can spell it aesthetics if you like. <<Discussion:>> Additional arguments, discussions, endorsements, testimonials, etc.should go here. A blow-by-blow account of debates is not necessary. <<*start*02841 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAR 88 10:54:42 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 24 Mar 88  10:52:25 PSTReturn-Path: <gls@Think.COM>Received: from kali.think.com by Think.COM; Thu, 24 Mar 88 13:51:39 ESTReceived: by kali.think.com; Thu, 24 Mar 88 13:51:34 ESTDate: Thu, 24 Mar 88 13:51:34 ESTFrom: gls@Think.COMMessage-Id: <8803241851.AA10588@kali.think.com>To: cl-cleanup@sail.stanford.eduSubject: Issue SUBSEQ-OUT-OF-BOUNDSIssue:         SUBSEQ-OUT-OF-BOUNDSReferences:    :START and :END arguments (246-247), SUBSEQ (248)Category:      CLARIFICATIONEdit history:  24-Mar-88, Version 1 by SteeleProblem description:The descriptions of :START and :END arguments, and of SUBSEQ, do notexplicitly address the question of out-of-bounds indices.  (The language onpage 246, "These arguments should be integer indices into the sequence," isconsidered too vague on this point.)Proposal (SUBSEQ-OUT-OF-BOUNDS:IS-AN-ERROR):Specify that it is an error for the :START argument of any standardfunction, or the second argument to SUBSEQ, to be less than zero.  Specifythat it is an error for the :END argument of any standard function, or thethird argument to SUBSEQ, to be greater than the length of the sequence inquestion (as returned by LENGTH).(Note that there is already a requirement that a start argument notbe greater than an end argument.)Test Cases/Examples:(SUBSEQ "Where's the beef?" -1 5) might be assumed to be "Where" or " Where".(SUBSEQ "Where's the beef?" -3 -3) might be assumed to be "".(SUBSEQ "Where's the beef?" 16 18) might be assumed to be "?" or "? ".(SUBSEQ "Where's the beef?" 10000 10000) might be assumed to be "".Under this proposal each of these situations is an error, and portableprograms may not rely on their behavior.Rationale:We don't want code indexing off the ends of arrays.Current practice:KCL interpreted and compiled code signals an error.Symbolics Common Lisp interpreted and compiled code signals an error; thecompiler also issued an out-of-range warning (possible because thearguments were all constant).Lucid Common Lisp interpreted and compiled code signals an error.Cost to Implementors:None.Cost to Users:Users who depended on some specific implementation behavior in these casesmay find that their pragmatically unportable code is not officiallyunportable.Cost of non-adoption:Confusion.Benefits:Removal of a small but important ambiguity in the spec.Esthetics:It seems cleaner not to allow indexing off the end of an array, andby extension not allow it for any sequence.Discussion:This merely clarifies the original intent of the passage on page 246.*start*01590 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 MAR 88 14:30:35 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 25 Mar 88  14:11:42 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 370425; Fri 25-Mar-88 17:10:54 ESTDate: Fri, 25 Mar 88 17:10 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue SUBSEQ-OUT-OF-BOUNDSTo: gls@Think.COMcc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8803241851.AA10588@kali.think.com>Message-ID: <19880325221052.9.MOON@EUPHRATES.SCRC.Symbolics.COM>I support SUBSEQ-OUT-OF-BOUNDS:IS-AN-ERROR, however I think we needto be clearer about whether the upper bound is the fill-pointer orthe actual array length.  I remember that this was controversial before.Your rationale and esthetics could be taken as arguments for using theactual array length.  A close reading of your proposal shows that itproposes using the fill pointer.  Current practice in Symbolics Generais to use the fill pointer; I didn't check whether your other currentpractice entries referred to the fill pointer or the actual array length.Also be clearer that the start must less than or equal to the end evenif the end was defaulted or NIL.In the cost to users section, I believe you have a typo, "not" whereyou mean "now".  This is one of those commonly made unfortunate typosthat reverses the meaning of a sentence.*start*01898 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 MAR 88 14:58:46 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 25 Mar 88  14:55:58 PSTReturn-Path: <gls@Think.COM>Received: from kali.think.com by Think.COM; Fri, 25 Mar 88 17:54:38 ESTReceived: by kali.think.com; Fri, 25 Mar 88 17:54:32 ESTDate: Fri, 25 Mar 88 17:54:32 ESTFrom: gls@Think.COMMessage-Id: <8803252254.AA12274@kali.think.com>To: Moon@stony-brook.scrc.symbolics.comCc: gls@Think.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 25 Mar 88 17:10 EST <19880325221052.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue SUBSEQ-OUT-OF-BOUNDS   Date: Fri, 25 Mar 88 17:10 EST   From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>   I support SUBSEQ-OUT-OF-BOUNDS:IS-AN-ERROR, however I think we need   to be clearer about whether the upper bound is the fill-pointer or   the actual array length.  I remember that this was controversial before.   Your rationale and esthetics could be taken as arguments for using the   actual array length.  A close reading of your proposal shows that it   proposes using the fill pointer.  Current practice in Symbolics Genera   is to use the fill pointer; I didn't check whether your other current   practice entries referred to the fill pointer or the actual array length.Right.  The reference to LENGTH was intended to establish that thefill pointer governs.   Also be clearer that the start must less than or equal to the end even   if the end was defaulted or NIL.Good point, thank you.   In the cost to users section, I believe you have a typo, "not" where   you mean "now".  This is one of those commonly made unfortunate typos   that reverses the meaning of a sentence.OOPS.  I will double-check that.*start*00693 00024 USxReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 29 MAR 88 16:10:23 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 29 Mar 88  16:08:53 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 29 MAR 88 16:06:52 PSTDate: 29 Mar 88 16:06 PSTFrom: Daniels.paSubject: Re: Issue SUBSEQ-OUT-OF-BOUNDS, version 2In-reply-to: gls@Think.COM's message of Tue, 29 Mar 88 10:56:55 ESTTo: gls@Think.COMcc: cl-cleanup@sail.stanford.eduMessage-ID: <880329-160652-1908@Xerox>Xerox Common Lisp implements the proposal, signalling an error in all cases.I support it.		-- Andy. --*start*03875 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 29 MAR 88 08:03:27 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 29 Mar 88  07:59:37 PSTReturn-Path: <gls@Think.COM>Received: from kali.think.com by Think.COM; Tue, 29 Mar 88 10:57:02 ESTReceived: by kali.think.com; Tue, 29 Mar 88 10:56:55 ESTDate: Tue, 29 Mar 88 10:56:55 ESTFrom: gls@Think.COMMessage-Id: <8803291556.AA17475@kali.think.com>To: cl-cleanup@sail.stanford.eduSubject: Issue SUBSEQ-OUT-OF-BOUNDS, version 2Issue:         SUBSEQ-OUT-OF-BOUNDSReferences:    :START and :END arguments (246-247), SUBSEQ (248)Category:      CLARIFICATIONEdit history:  24-Mar-88, Version 1 by Steele	       29-Mar-88, Version 2 by Steele, in response to Moon's commentsProblem description:The descriptions of :START and :END arguments, and of SUBSEQ, do notexplicitly address the question of out-of-bounds indices.  (The language onpage 246, "These arguments should be integer indices into the sequence," isconsidered too vague on this point.)Also, the language on page 246 does not make clear whether the prohibitionagainst "start > end" applies to defaulted values as well as explicitvalues, and does not specify clearly whether the default value for theend argument is the allocated length or the active length.Proposal (SUBSEQ-OUT-OF-BOUNDS:IS-AN-ERROR):Specify that it is an error for the :START argument of any standardfunction, or the second argument to SUBSEQ, to be less than zero.Specify that it is an error for the :END argument of any standard function,or the third argument to SUBSEQ, to be greater than the active length ofthe sequence in question (as returned by LENGTH).Specify that the start value, after defaulting, must not be greater thanthe end value, after defaulting.Specify that the default value for the end argument is the active length ofthe sequence in question.This may be summarized as follows:Let X be the sequence within which indices are to be considered.  Let S bethe :START argument of any standard function, or the second argument toSUBSEQ, whether explicitly specified or defaulted, through omission, tozero.  Let E be the :END argument of any standard function, or the thirdargument to SUBSEQ, whether explicitly specified or defaulted, throughomission or an explicitly passed NIL value, to the active length of X, asreturned by LENGTH.  It is an error if the condition (<= 0 S E (LENGTH X))is not true.Test Cases/Examples:(SUBSEQ "Where's the beef?" -1 5) might be assumed to be "Where" or " Where".(SUBSEQ "Where's the beef?" -3 -3) might be assumed to be "".(SUBSEQ "Where's the beef?" 16 18) might be assumed to be "?" or "? ".(SUBSEQ "Where's the beef?" 10000 10000) might be assumed to be "".Under this proposal each of these situations is an error, and portableprograms may not rely on their behavior.Rationale:We don't want code indexing off the ends of arrays.Current practice:KCL interpreted and compiled code signals an error.Symbolics Common Lisp interpreted and compiled code signals an error; thecompiler also issued an out-of-range warning (possible because thearguments were all constant).Lucid Common Lisp interpreted and compiled code signals an error.Cost to Implementors:None.Cost to Users:Users who depended on some specific implementation behavior in these casesmay find that their pragmatically unportable code is now officiallyunportable.Cost of non-adoption:Confusion.Benefits:Removal of a small but important ambiguity in the spec.Esthetics:It seems cleaner not to allow indexing off the end of an array, andby extension not allow it for any sequence.Discussion:This merely clarifies the original intent of the passage on page 246.*start*03840 00024 US Date:  8 Jun 88 21:01 PDTFrom: Masinter.paTo: x3j13@sail.stanford.educc: masinterSubject: Issue SUBSEQ-OUT-OF-BOUNDS, version 2reply-to: cl-cleanup@Sail.stanford.eduline-fold: NOIssue:         SUBSEQ-OUT-OF-BOUNDSReferences:    :START and :END arguments (246-247), SUBSEQ (248)Category:      CLARIFICATIONEdit history:  24-Mar-88, Version 1 by Steele	       29-Mar-88, Version 2 by Steele, in response to Moon's commentsProblem description:The descriptions of :START and :END arguments, and of SUBSEQ, do notexplicitly address the question of out-of-bounds indices.  (The language onpage 246, "These arguments should be integer indices into the sequence," isconsidered too vague on this point.)Also, the language on page 246 does not make clear whether the prohibitionagainst "start > end" applies to defaulted values as well as explicitvalues, and does not specify clearly whether the default value for theend argument is the allocated length or the active length.Proposal (SUBSEQ-OUT-OF-BOUNDS:IS-AN-ERROR):Specify that it is an error for the :START argument of any standardfunction, or the second argument to SUBSEQ, to be less than zero.Specify that it is an error for the :END argument of any standard function,or the third argument to SUBSEQ, to be greater than the active length ofthe sequence in question (as returned by LENGTH).Specify that the start value, after defaulting, must not be greater thanthe end value, after defaulting.Specify that the default value for the end argument is the active length ofthe sequence in question.This may be summarized as follows:Let X be the sequence within which indices are to be considered.  Let S bethe :START argument of any standard function, or the second argument toSUBSEQ, whether explicitly specified or defaulted, through omission, tozero.  Let E be the :END argument of any standard function, or the thirdargument to SUBSEQ, whether explicitly specified or defaulted, throughomission or an explicitly passed NIL value, to the active length of X, asreturned by LENGTH.  It is an error if the condition (<= 0 S E (LENGTH X))is not true.Test Cases/Examples:(SUBSEQ "Where's the beef?" -1 5) might be assumed to be "Where" or " Where".(SUBSEQ "Where's the beef?" -3 -3) might be assumed to be "".(SUBSEQ "Where's the beef?" 16 18) might be assumed to be "?" or "? ".(SUBSEQ "Where's the beef?" 10000 10000) might be assumed to be "".Under this proposal each of these situations is an error, and portableprograms may not rely on their behavior.Rationale:We don't want code indexing off the ends of arrays.Current practice:KCL interpreted and compiled code signals an error.Symbolics Common Lisp interpreted and compiled code signals an error; thecompiler also issued an out-of-range warning (possible because thearguments were all constant).Lucid Common Lisp interpreted and compiled code signals an error.Cost to Implementors:None.Cost to Users:Users who depended on some specific implementation behavior in these casesmay find that their pragmatically unportable code is now officiallyunportable.Cost of non-adoption:Confusion.Benefits:Removal of a small but important ambiguity in the spec.Esthetics:It seems cleaner not to allow indexing off the end of an array, andby extension not allow it for any sequence.Discussion:This merely clarifies the original intent of the passage on page 246.        TITAN          TITAN           TIMESROMAN            ¼                            3                            g                    -      T                           6             &                                                        :              r              H      ƒ zº