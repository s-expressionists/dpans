*start*06356 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 DEC 88 14:46:25 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 30 Dec 88  14:45:54 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513680; Fri 30-Dec-88 17:43:47 ESTDate: Fri, 30 Dec 88 17:43 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESTo: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8810072119.AA03303@mist.UUCP>Message-ID: <19881230224313.0.MOON@EUPHRATES.SCRC.Symbolics.COM>I don't have any record of this issue being discussed.  If I'mcoming in late, please ignore and forgive me.    Date: Fri, 07 Oct 88 17:19:22 EDT    From: Dan L. Pierson <pierson%mist@multimax.ARPA>    Issue:         DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES    References:    Array type specifiers, pp. 45-46    Related issues: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, DECLARE-TYPE-FREEI don't think this has any actual interactions with the issueARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, sinceDECLARE-ARRAY-TYPE-ELEMENT-REFERENCES is about ARRAY type specifiers fordeclaration, while ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS is about ARRAY typespecifiers for discrimination.    Category:      CLARIFICATION    Edit history:  Version 1,  7-Oct-88, Pierson    Problem description:    Array type specifiers appear to be useful both for declaring the    storage format of the array and for declaring the types of legal    operations on array elements.  Unfortunately, the current definition    of the meaning of array type specifiers does not require an    implementation to support the second use.    Proposal (DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES:RESTRICTIVE):    Within the scope of an array type declaration, all references to array    elements are assumed to satisfy the exact declared element type.  That's reasonable.  However, this is not a CLARIFICATION but a CHANGE,since CLtL p.46 seems to be quite clear that the current meaning of sucha TYPE declaration is that the array elements satisfy the implementationelement type (what JonL calls the upgraded type), not the exact declaredelement type.  Since your proposed new definition is more restrictive,some portable programs that used to be correct may now be in error, hencethis is an incompatible CHANGE.  I think I'd vote for it anyway unlesssomeone argues that there is a significant impact on users.								      An    implementation should signal an error if this is ever violated.  That's not reasonable.  The status quo for type declarations is thata violation "is an error".  Changing it to "signals an error" is likely tomeet enormous resistance especially from stock hardware implementations,and I think even changing it to "signals an error at the highest SAFETYsetting" would meet significant resistance.								     A    compiler may treat the code within the scope of the array type    declaration as if each access of an array element was surrounded by an    appropriate THE form.That's a good way to define it (except you shouldn't assume that lettingeveryone work out for themselves what the "appropriate THE form" is meansthey will all come up with the same answer!).    Examples:    (DEFVAR *ONE-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 5)))    (DEFVAR *ANOTHER-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 8)))    (DEFUN FROB (AN-ARRAY)      (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))      (SETF (AREF AN-ARRAY 1) 31)		; OK      (SETF (AREF AN-ARRAY 2) 127)		; Should signal an error      (SETF (AREF AN-ARRAY 3) (* 2 (AREF AN-ARRAY 3))) ; Run-time decision needed      (LET ((FOO 0))	(DECLARE (TYPE (SIGNED-BYTE 5) FOO))	(SETF FOO (AREF AN-ARRAY 0))))	; Declared to be safe    (FROB *ONE-ARRAY*)			; Legal call, should signal an error    (FROM *ANOTHER-ARRAY*)			; Is probably an undetectable error    Note that the above definition of FROB is equivalent to:    (DEFUN FROB (AN-ARRAY)      (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))      (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 1) 31))      (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 2) 127))      (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))	    (* 2 (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))))      (LET ((FOO 0))	(DECLARE (TYPE (SIGNED-BYTE 5) FOO))	(SETF FOO (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 0)))))    Test Cases:    TBS    Rationale:    This mandates a useful and commonly expected behavior.  It complements    proposal ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, which deals with array    type specifiers as they refer to arrays as a whole.  The "should    signal an error" requirement permits compiler optimization while    requiring interpreters and low compiler optimization levels to perform    useful error checking.    Current practice:    ???    Cost to Implementors:    Most implementations will have to extend the type checking in the    interpreter and low optimization levels of the compiler.    Cost to Users:    Some users might find that errors in existing code become visible for    the first time.    Cost of non-adoption:    Users will continue to expect declaration syntax to be more useful    than it really is.    It will be harder to debug code that uses arrays containing    specialized types.    Performance impact:    Highly optimized code should be unaffected.  Interpreted and    unoptimized code will run slower because of the additional error    checking.     Benefits:    It will be easier to use the Common Lisp type system to catch    programming errors.    Aesthetics:    Improved because the meaning of type declarations will coincide more    clearly with their appearance.    Discussion:    Pierson supports this proposal.    JonL expressed support for the idea behind this proposal during the    discussion of ARRAY-TYPE-ELEMENT-TYPE-SEMANITICS but said that it was    a compiler committee problem.  This was submitted as a cleanup issue    anyway because it imposes requirements on the interpreter as well as    the compiler.*start*02250 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 JAN 89 21:42:44 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 1 Jan 89  21:42:26 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02548g; Sun, 1 Jan 89 21:38:03 PSTReceived: by bhopal id AA21474g; Sun, 1 Jan 89 21:40:16 PSTDate: Sun, 1 Jan 89 21:40:16 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901020540.AA21474@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: pierson%mist@MULTIMAX.ENCORE.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 30 Dec 88 17:43 EST <19881230224313.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESI seem to have no record of past mail on this issue, but I remember atone time arguing against it since it tended to contradict the agreementin ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS -- namely (1) that we wouldn'tdistinguish between "for declaration" and "for discrimination", and(2) that the original source-code element-type specifier may be "upgraded"so that for all intents an purposes you can't recover the "exact declared element type".  But if all that Dan wanted to say was that the arrayreferences were assumed to satisfy the *upgrade* of the declared type,then there would be no problem (with that part).My name probably got put reference in this proposal because I havegenerally given support for the following notion: that there be at leastone mode of operation (interpretation or compilation) in which all typeinformation is rigidly checked.  I don't think Lucid would be that averseto some form of required error signaling in this case; but likely itwouldn't be in interpreted code --  rather, it most easily could be incode compiled under highest safety [because the interpreter currently doesn't pay attention to type declarations].  Contrary to your suggestion, I would have thought that Symbolics would offer more resistance to this idea than would "stock hardware" implementatons, since many of the latterhave already invested in a compiler cognizant of type declartions.-- JonL --*start*04387 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 10:44:28 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Jan 89  10:44:07 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513967; Mon 2-Jan-89 12:37:48 ESTDate: Mon, 2 Jan 89 12:37 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESTo: Jon L White <jonl@lucid.com>cc: pierson%mist@MULTIMAX.ENCORE.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: <8901020540.AA21474@bhopal>Message-ID: <19890102173715.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sun, 1 Jan 89 21:40:16 PST    From: Jon L White <jonl@lucid.com>    I seem to have no record of past mail on this issue, but I remember at    one time arguing against it since it tended to contradict the agreement    in ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS -- namely (1) that we wouldn't    distinguish between "for declaration" and "for discrimination", and    (2) that the original source-code element-type specifier may be "upgraded"    so that for all intents an purposes you can't recover the "exact declared     element type".  But if all that Dan wanted to say was that the array    references were assumed to satisfy the *upgrade* of the declared type,    then there would be no problem (with that part).I basically agree with you, but would like to point out one thing that Ihadn't thought of until I read your mail just now.  Since a portableprogram cannot know what the upgraded element type is, it must notassume that all implementations have some objects that are members ofthe upgraded element type but not members of the exact declared type.This means that if it "is an error" for an array element not to be ofthe upgraded type, it also "is an error" for an array element not to beof the exact declared type; either way, a program that does that is notportable.  So the only real problem with Pierson's proposal is itsproposed change of enforcement of type declarations from "is an error"to "signals an error".Now, if we make it "signals an error in the highest safety mode" thenwe're back with the same problem: does it signal an error when youviolate the declared type, or only when you violate the upgraded type?The former provides a more portable definition of when errors aresignalled, but violates the consistency of declaration withdiscrimination.  The latter keeps declaration and descriminationconsistent, but means that there are some cases that "are an error" (orat least are not portable) in lower safety settings, but fail to "signalan error" in the highest safety setting.    My name probably got put reference in this proposal because I have    generally given support for the following notion: that there be at least    one mode of operation (interpretation or compilation) in which all type    information is rigidly checked.  I don't think Lucid would be that averse    to some form of required error signaling in this case; but likely it    wouldn't be in interpreted code --  rather, it most easily could be in    code compiled under highest safety [because the interpreter currently     doesn't pay attention to type declarations].  Contrary to your suggestion,     I would have thought that Symbolics would offer more resistance to this     idea than would "stock hardware" implementatons, since many of the latter    have already invested in a compiler cognizant of type declartions.I was referring to the suggestion that type information be rigidly checkedin all modes, not just in the highest safety mode.  In fact it would not beterribly difficult for Symbolics to check all type requirements, includingdeclarations, rather than just most implicit type requirements, in thehighest safety mode.  What priority this would have for implementationrelative to other things I can't say, but I do know that keeping track oftype declarations in the compiler would not be a major part of the work.I believe it is a one-line change, actually.It would be interesting to see the impact of a Lucid implementation wheredebugging was easier in compiled code than in interpreted code.*start*03436 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 09:20:10 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 3 Jan 89  09:16:19 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA25011; Tue, 3 Jan 89 12:15:08 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA12970; Tue, 3 Jan 89 12:15:09 ESTMessage-Id: <8901031715.AA12970@mist.>To: Jon L White <jonl@lucid.com>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES In-Reply-To: Your message of Sun, 01 Jan 89 21:40:16 -0800.             <8901020540.AA21474@bhopal> Date: Tue, 03 Jan 89 12:15:07 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    I seem to have no record of past mail on this issue, but I remember at    one time arguing against it since it tended to contradict the agreement    in ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS -- namely (1) that we wouldn't    distinguish between "for declaration" and "for discrimination", and    (2) that the original source-code element-type specifier may be "upgraded"    so that for all intents an purposes you can't recover the "exact declared     element type".  But if all that Dan wanted to say was that the array    references were assumed to satisfy the *upgrade* of the declared type,    then there would be no problem (with that part).    Sorry, but that's exactly the opposite of what I meant.  If I declarean array, FOO, to be (SIGNED-BYTE 5), within the scope of thatdefinition I'm saying that expect references to that array to beequivalent to:    (THE (SIGNED-BYTE 5) (AREF FOO X))No matter what the array was upgraded to.  Upgrading should  refer to thearray's physical layout and overall type, but it should not licensethe FOO below to be a different type from (AREF BAR X) in FROB.    (DEFUN FROB (FOO BAR)       (DECLARE (TYPE (SIGNED-BYTE 5) FOO)		(TYPE (ARRAY (SIGNED-BYTE 5)) BAR))       ...    )    My name probably got put reference in this proposal because I have    generally given support for the following notion: that there be at least    one mode of operation (interpretation or compilation) in which all type    information is rigidly checked.  I don't think Lucid would be that averse    to some form of required error signaling in this case; but likely it    wouldn't be in interpreted code --  rather, it most easily could be in    code compiled under highest safety [because the interpreter currently     doesn't pay attention to type declarations].  Contrary to your suggestion,     I would have thought that Symbolics would offer more resistance to this     idea than would "stock hardware" implementatons, since many of the latter    have already invested in a compiler cognizant of type declartions.    Actually, your name got put in support because of an early message ofyours (which I finally found) in the ARRAY-ELEMENT-TYPE-SEMANTICSdiscussion.  I'll be happy to remove your name if we now disagree.As I've said before, I support a strict type checking mode for allCommon Lisp compilers.  However I now suspect that it's too late (andmaybe too experimental) to get in this version of the standard.  Isaid I'd write up a proposal for it at the cleanup meeting lastOctober, but was later talked out of doing so.    *start*03092 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 09:27:47 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 3 Jan 89  09:24:41 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA25203; Tue, 3 Jan 89 12:23:23 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA12979; Tue, 3 Jan 89 12:23:24 ESTMessage-Id: <8901031723.AA12979@mist.>To: "David A. Moon" <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES In-Reply-To: Your message of Mon, 02 Jan 89 12:37:00 -0500.             <19890102173715.1.MOON@EUPHRATES.SCRC.Symbolics.COM> Date: Tue, 03 Jan 89 12:23:23 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    I basically agree with you, but would like to point out one thing that I    hadn't thought of until I read your mail just now.  Since a portable    program cannot know what the upgraded element type is, it must not    assume that all implementations have some objects that are members of    the upgraded element type but not members of the exact declared type.    This means that if it "is an error" for an array element not to be of    the upgraded type, it also "is an error" for an array element not to be    of the exact declared type; either way, a program that does that is not    portable.  So the only real problem with Pierson's proposal is its    proposed change of enforcement of type declarations from "is an error"    to "signals an error".        Now, if we make it "signals an error in the highest safety mode" then    we're back with the same problem: does it signal an error when you    violate the declared type, or only when you violate the upgraded type?    The former provides a more portable definition of when errors are    signalled, but violates the consistency of declaration with    discrimination.  The latter keeps declaration and descrimination    consistent, but means that there are some cases that "are an error" (or    at least are not portable) in lower safety settings, but fail to "signal    an error" in the highest safety setting.    The problem is that there are logically three types of declaration inthese cases: for discrimination, for declaration, and for reference.For declaration refers to the array as a whole.  For reference refersto references to array elements.  I claim that upgrading for referenceintroduces a confusing and unnecessary incompatibility between arrayelements and normal variables.  I also claim that there are peoplewriting and distributing code today who neither understand nor desirethis incompatibility.This whole upgrading thing is a necessary hack to try an adopt anabstract type system to a varying set of efficient implementations.There is no reason why this hack needs to be propagated to referencesto individual elements, which should follow the rules for "normal"variables as much as possible.*start*02591 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 JAN 89 02:26:11 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 4 Jan 89  02:24:33 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04062g; Wed, 4 Jan 89 02:20:45 PSTReceived: by bhopal id AA01609g; Wed, 4 Jan 89 02:22:57 PSTDate: Wed, 4 Jan 89 02:22:57 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901041022.AA01609@bhopal>To: pierson@mist.encore.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Dan L. Pierson's message of Tue, 03 Jan 89 12:15:07 EST <8901031715.AA12970@mist.>Subject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES re:     But if all that Dan wanted to say was that the array        references were assumed to satisfy the *upgrade* of the declared type,        then there would be no problem (with that part).        Sorry, but that's exactly the opposite of what I meant.  If I declare    an array, FOO, to be (SIGNED-BYTE 5), within the scope of that    definition I'm saying that expect references to that array to be    equivalent to:        (THE (SIGNED-BYTE 5) (AREF FOO X))    No matter what the array was upgraded to.  Yea, that's what I thought you meant, and that's what I think isinconsistent with the "unification" in issue ARRAY-ELEMENT-TYPE-SEMANTICS.re: Actually, your name got put in support because of an early message of    yours (which I finally found) in the ARRAY-ELEMENT-TYPE-SEMANTICS    discussion.  I'll be happy to remove your name if we now disagree.I fear that my very first reading of DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESwas too hasty, and I incorrectly thought it was subsumed byARRAY-ELEMENT-TYPE-SEMANTICS.  I'm sure I recanted that apostasy inlater mail.re: As I've said before, I support a strict type checking mode for all    Common Lisp compilers.  However I now suspect that it's too late (and    maybe too experimental) to get in this version of the standard.  I    said I'd write up a proposal for it at the cleanup meeting last    October, but was later talked out of doing so.Why?  [i.e., Why did you get "talked out of doing so"?]  I remember discussing this with you at length during the Palo Alto meeting inMarch 1988 and likeing it very much.  However -- I hasten to pointout -- it would help not to confuse this issue with the very limitedscope of DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES, which has it's ownpeculiar problems related to "upgrading".-- JonL --*start*01666 00024 USmReturn-Path: <CL-Iteration-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 JAN 89 16:15:00 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 4 Jan 89  10:38:15 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA11330; Wed, 4 Jan 89 10:40:09 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA09958; Wed, 4 Jan 89 10:36:51 PSTReceived: from Sun.COM (sun-arpa) by clam.sun.com (3.2/SMI-3.2)	id AA06239; Wed, 4 Jan 89 10:37:52 PSTReceived: from rice-chex.ai.mit.edu by Sun.COM (4.1/SMI-4.0)	id AA11325; Wed, 4 Jan 89 10:39:54 PSTReceived: by rice-chex.ai.mit.edu; Wed, 4 Jan 89 13:34:05 ESTDate: Wed, 4 Jan 89 13:34:05 ESTFrom: dick@wheaties.ai.mit.edu (Richard C. Waters)Message-Id: <8901041834.AA16826@rice-chex.ai.mit.edu>To: masinter.paCc: loop-group%clam@Sun.COMIn-Reply-To: masinter.pa@xerox.com's message of 3 Jan 89 14:40 PST <890103-145433-214@Xerox>Subject: Unification   If LOOP were defined in terms of an expansion into DO-SERIES/ITERATE and/or   GATHERING, it would be possible to intermix the forms. That seems like a   natural layering, does it not?This would certainly be nice, but it certainly is not easy and may noteven be possible.  The trouble stems from the same things that makeloop a problem in general.  90% of the stuff is perfectlystriaghtforward and easy to understand.  This could be layered on topof ITERATE etc. just fine.  Unfortunately, the remaining 10% is aninscrutable tangle.  It is hard to understand and I think would bequite hard to support faithfully based on something like ITERATE.			Dick*start*04219 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 JAN 89 16:17:49 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 4 Jan 89  11:15:55 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA02902; Wed, 4 Jan 89 13:53:40 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA14296; Wed, 4 Jan 89 13:53:41 ESTMessage-Id: <8901041853.AA14296@mist.>To: Jon L White <jonl@lucid.com>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES In-Reply-To: Your message of Wed, 04 Jan 89 02:22:57 -0800.             <8901041022.AA01609@bhopal> Date: Wed, 04 Jan 89 13:53:39 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>        Sorry, but that's exactly the opposite of what I meant.  If I declare        an array, FOO, to be (SIGNED-BYTE 5), within the scope of that        definition I'm saying that expect references to that array to be        equivalent to:            (THE (SIGNED-BYTE 5) (AREF FOO X))        No matter what the array was upgraded to.          Yea, that's what I thought you meant, and that's what I think is    inconsistent with the "unification" in issue ARRAY-ELEMENT-TYPE-SEMANTICS.    It seems that we disagree here.  I'll remove your endorsement from thenext version of the proposal.    re: As I've said before, I support a strict type checking mode for all        Common Lisp compilers.  However I now suspect that it's too late (and        maybe too experimental) to get in this version of the standard.  I        said I'd write up a proposal for it at the cleanup meeting last        October, but was later talked out of doing so.        Why?  [i.e., Why did you get "talked out of doing so"?]  I remember     discussing this with you at length during the Palo Alto meeting in    March 1988 and likeing it very much.  However -- I hasten to point    out -- it would help not to confuse this issue with the very limited    scope of DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES, which has it's own    peculiar problems related to "upgrading".    Well, it was a combination of factors: the issue looked to beextremely controversial; several well respected people were arguingagainst much milder proposals on the grounds that no one hadimplemented them (FUNCTION-COMPOSITION comes to mind); and Larry madea strong pitch that time was running out and we should concentrate ourefforts on the important issues that still might be resolved in time.I clearly don't have time to do a full writeup by Hawaii, but am stillwilling to consider doing one later; I've also considered a LispPointers article as an alternative or addition.  It seems that a veryrelevant question is whether any vendors would consider making such afeature part of their product if it wasn't required.  If the answer tothat is no, then I would have to reluctantly admit that thestandardization case is -very- weak.  Right now, I'm more likely to devote time to a foreign functioninterface standard, since almost everyone implements the feature andmany of the differences are clearly unnecessary, if not plaingratuitous.  The same arguments might apply to multiprocessing alastack groups (though emphatically not to parallel lisp).Just to remove any doubt, I personally think that such a "stringtyping" feature is very, very valuable and have felt and argued thatway since the early VAX Lisp days.  For one thing, the lack of thisfeature makes it extremely difficult to move a non-trivial applicationfrom low SPEED, high SAFETY to the reverse.  You currently have to gostraight from generic operations that "always" work to no-holds-barredinline code where errors can do anything; a mode that checked yourdeclarations and signalled precise errors would make debugging and QAof such an application vastly easier.  If we want people to produceserious applications and products with Common Lisp, we have to givethem the tools to produce efficient and safe code without sacrificingthe traditional development advantages of Lisp.  This feature helps doexactly that.*start*01132 00024 US Return-Path: <@multimax.ARPA:pierson%mist@multimax.ARPA>Received: from multimax.ARPA ([192.5.63.14]) by Xerox.COM ; 09 OCT 88 09:42:43 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA10066; Sun, 9 Oct 88 12:43:21 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA05988; Sun, 9 Oct 88 12:45:09 EDTMessage-Id: <8810091645.AA05988@mist.UUCP>To: masinter.pa%Xerox.COM@MULTIMAX.ENCORE.COMCc: cl-cleanup%sail.stanford.edu@MULTIMAX.ENCORE.COMSubject: Re: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES In-Reply-To: Your message of 08 Oct 88 22:33:00 -0700.             <881008-223321-2629@Xerox> Date: Sun, 09 Oct 88 12:45:07 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>    I think this issue is also addressed by    ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS; certainly the    ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS "Problem Description" has a lot    of overlap with the problem description here.So did I until JonL and others (?) pointed out that it was specificallynot covered by ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS.  (I was going toappend JonL's message, but I seem to have lost it.)*start*03451 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 08:59:25 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Jan 89  08:58:45 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 520983; Fri 13-Jan-89 11:57:08 ESTDate: Fri, 13 Jan 89 11:56 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES (Version 2)To: Pierson@mist.encore.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890113115650.1.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri, 13 Jan 89 10:49:25 EST    From: Dan L. Pierson <pierson@mist.encore.com>    ...    Problem description:    Array type specifiers appear to be useful both for declaring the    storage format of the array and for declaring the types of legal    operations on array elements.  Unfortunately, the current definition    of the meaning of array type specifiers does not require an    implementation to support the second use.It doesn't require them to support the first use, either. After all,it's optional to support type declarations in the first place.As such, this isn't an appropriate problem description. I'll suggestthe following wording, which I think doesn't distort your purpose,and which gets around the issue of whether type declarations are supported: In principle, array type specifiers could be used both for declaring the storage format of the array and for implicitly declaring the types of the elements held by those arrays. Unfortunately, the current  definition of the meaning of array type specifiers does not explicitly specify that the latter use of these declarations is legitimate.This in itself would not be enough reason to rewrite the proposal sinceat this point, I don't really much care about problem descriptions orany of that other junk, as long as the proposal part is right. However,since below I suggest you should change the proposal part, you might aswell catch this at the same time.    Proposal (DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES:RESTRICTIVE):        Within the scope of an array type declaration, all references to array    elements are assumed to satisfy the exact declared element type.  It    is an error if this is ever violated.  A compiler may treat the code    within the scope of the array type declaration as if each access of an    array element was surrounded by an appropriate THE form.    After all the fuss on DECLARE-TYPE-FREE, it's unreasonable to expect toget away with a vague term like "scope". You must say "dynamic scope" or"lexical scope". From the surrounding text, it seems clear to me that youintended "lexical scope" but you should definitely spell it out.If you write "lexical scope", you can add to the rationale that you areconsistent with SYMBOL-MACROLET-DECLARE:ALLOW and DECLARATION-SCOPE:LEXICAL.You can also then add me to the discussion as a supporter.If you write "dyanamic scope", you can add to the rationale that you areconsistent with DECLARATION-SCOPE:ALLOW (and you can mention that you aregratuitously incompatible with SYMBOL-MACROLET-DECLARE:ALLOW if you like...)You can also then add me to the discussion as firmly opposed.*start*03985 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 07:52:40 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 13 Jan 89  07:51:33 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA08762; Fri, 13 Jan 89 10:50:02 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA05587; Fri, 13 Jan 89 10:49:27 ESTMessage-Id: <8901131549.AA05587@mist.>To: cl-cleanup@sail.stanford.eduSubject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES (Version 2)Date: Fri, 13 Jan 89 10:49:25 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>Issue:         DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESReferences:    Array type specifiers, pp. 45-46Related issues: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, DECLARE-TYPE-FREECategory:      CHANGEEdit history:  Version 1,  7-Oct-88, Pierson               Version 2, 13-Jan-89, Pierson (Moon and JonL comments)Problem description:Array type specifiers appear to be useful both for declaring thestorage format of the array and for declaring the types of legaloperations on array elements.  Unfortunately, the current definitionof the meaning of array type specifiers does not require animplementation to support the second use.Proposal (DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES:RESTRICTIVE):Within the scope of an array type declaration, all references to arrayelements are assumed to satisfy the exact declared element type.  Itis an error if this is ever violated.  A compiler may treat the codewithin the scope of the array type declaration as if each access of anarray element was surrounded by an appropriate THE form.Examples:(DEFVAR *ONE-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 5)))(DEFVAR *ANOTHER-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 8)))(DEFUN FROB (AN-ARRAY)  (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))  (SETF (AREF AN-ARRAY 1) 31)		; OK  (SETF (AREF AN-ARRAY 2) 127)		; Should signal an error  (SETF (AREF AN-ARRAY 3) (* 2 (AREF AN-ARRAY 3))) ; Run-time decision needed  (LET ((FOO 0))    (DECLARE (TYPE (SIGNED-BYTE 5) FOO))    (SETF FOO (AREF AN-ARRAY 0))))	; Declared to be safe(FROB *ONE-ARRAY*)			; Legal call, should signal an error(FROM *ANOTHER-ARRAY*)			; Is probably an undetectable errorNote that the above definition of FROB is equivalent to:(DEFUN FROB (AN-ARRAY)  (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 1) 31))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 2) 127))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))	(* 2 (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))))  (LET ((FOO 0))    (DECLARE (TYPE (SIGNED-BYTE 5) FOO))    (SETF FOO (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 0)))))Given an implementation in which fixnums are 29 bits but fixnum arraysare upgraded to signed 32-bit arrays, the following should be compiledwith all fixnum arithmetic:(DEFUN BUMP-COUNTERS (COUNTERS)  (DECLARE (TYPE (ARRAY FIXNUM *) BUMP-COUNTERS))  (DOTIMES (I (LENGTH COUNTERS))    (INCF (AREF COUNTERS I))))Test Cases:TBSRationale:This mandates a useful and commonly expected behavior.  It complementsproposal ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, which deals with arraytype specifiers as they refer to arrays as a whole.Current practice:???Cost to Implementors:TBSCost to Users:Probably none; while this is technically a change, code that declaresan array to contain one thing and depends on it containing somethingelse is blatantly buggy.Cost of non-adoption:Users will continue to expect declaration syntax to be more usefulthan it really is.Performance impact:None.Benefits:Array type declarations will behave in a more useful and intuitive way.Aesthetics:Improved because the meaning of type declarations will coincide moreclearly with their appearance.Discussion:Pierson supports this proposal.*start*04487 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 11:09:58 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 13 Jan 89  11:08:43 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA12396; Fri, 13 Jan 89 14:07:06 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA05883; Fri, 13 Jan 89 14:06:32 ESTMessage-Id: <8901131906.AA05883@mist.>To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.Stanford.EDUSubject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES (Version 3) In-Reply-To: Your message of Fri, 13 Jan 89 11:56:00 -0500.             <890113115650.1.KMP@BOBOLINK.SCRC.Symbolics.COM> Date: Fri, 13 Jan 89 14:06:30 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>Thanks for the comments Kent.  I agree. Here is the new version.Issue:         DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESReferences:    Array type specifiers, pp. 45-46Related issues: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, DECLARE-TYPE-FREE,                SYMBOL-MACROLET-DECLARECategory:      CHANGEEdit history:  Version 1,  7-Oct-88, Pierson               Version 2, 13-Jan-89, Pierson (Moon and JonL comments)    	       Version 3, 13-Jan-89, Pierson (Pitman comments)Problem description:In principle, array type specifiers could be used both for declaringthe storage format of the array and for implicitly declaring the typesof the elements held by those arrays. Unfortunately, the current definition of the meaning of array type specifiers does not explicitlyspecify that the latter use of these declarations is legitimate.Proposal (DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES:RESTRICTIVE):Within the lexical scope of an array type declaration, all referencesto array elements are assumed to satisfy the exact declared elementtype.  It is an error if this is ever violated.  A compiler may treatthe code within the scope of the array type declaration as if eachaccess of an array element was surrounded by an appropriate THE form.Examples:(DEFVAR *ONE-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 5)))(DEFVAR *ANOTHER-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 8)))(DEFUN FROB (AN-ARRAY)  (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))  (SETF (AREF AN-ARRAY 1) 31)		; OK  (SETF (AREF AN-ARRAY 2) 127)		; Should signal an error  (SETF (AREF AN-ARRAY 3) (* 2 (AREF AN-ARRAY 3))) ; Run-time decision needed  (LET ((FOO 0))    (DECLARE (TYPE (SIGNED-BYTE 5) FOO))    (SETF FOO (AREF AN-ARRAY 0))))	; Declared to be safe(FROB *ONE-ARRAY*)			; Legal call, should signal an error(FROM *ANOTHER-ARRAY*)			; Is probably an undetectable errorNote that the above definition of FROB is equivalent to:(DEFUN FROB (AN-ARRAY)  (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 1) 31))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 2) 127))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))	(* 2 (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))))  (LET ((FOO 0))    (DECLARE (TYPE (SIGNED-BYTE 5) FOO))    (SETF FOO (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 0)))))Given an implementation in which fixnums are 29 bits but fixnum arraysare upgraded to signed 32-bit arrays, the following should be compiledwith all fixnum arithmetic:(DEFUN BUMP-COUNTERS (COUNTERS)  (DECLARE (TYPE (ARRAY FIXNUM *) BUMP-COUNTERS))  (DOTIMES (I (LENGTH COUNTERS))    (INCF (AREF COUNTERS I))))Test Cases:TBSRationale:This mandates a useful and commonly expected behavior.  It complementsproposal ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, which deals with arraytype specifiers as they refer to arrays as a whole.  This proposal is consistent with SYMBOL-MACROLET-DECLARE:ALLOW andDECLARATION-SCOPE:LEXICAL.Current practice:???Cost to Implementors:TBSCost to Users:Probably none; while this is technically a change, code that declaresan array to contain one thing and depends on it containing somethingelse is blatantly buggy.Cost of non-adoption:Users will continue to expect declaration syntax to be more usefulthan it really is.Performance impact:None.Benefits:Array type declarations will behave in a more useful and intuitive way.Aesthetics:Improved because the meaning of type declarations will coincide moreclearly with their appearance.Discussion:Pierson and Pitman support this proposal.*start*04195 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 FEB 89 23:43:14 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 3 Feb 89  23:33:32 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 03 FEB 89 23:31:31 PSTDate: 3 Feb 89 23:31 PSTFrom: masinter.paTo: X3J13@sail.stanford.eduSubject: Issue: DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES (Version 3) Line-fold: NOMessage-ID: <890203-233131-2862@Xerox>This proposal was distributed and passed at the January X3J13 meeting.Since it had not been emailed before, I am doing so now.!Status:	Passed, Jan 89 X3J13Issue:         DECLARE-ARRAY-TYPE-ELEMENT-REFERENCESReferences:    Array type specifiers, pp. 45-46Related issues: ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, DECLARE-TYPE-FREE,                SYMBOL-MACROLET-DECLARECategory:      CHANGEEdit history:  Version 1,  7-Oct-88, Pierson               Version 2, 13-Jan-89, Pierson (Moon and JonL comments)    	       Version 3, 13-Jan-89, Pierson (Pitman comments)Problem description:In principle, array type specifiers could be used both for declaringthe storage format of the array and for implicitly declaring the typesof the elements held by those arrays. Unfortunately, the current definition of the meaning of array type specifiers does not explicitlyspecify that the latter use of these declarations is legitimate.Proposal (DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES:RESTRICTIVE):Within the lexical scope of an array type declaration, all referencesto array elements are assumed to satisfy the exact declared elementtype.  It is an error if this is ever violated.  A compiler may treatthe code within the scope of the array type declaration as if eachaccess of an array element was surrounded by an appropriate THE form.Examples:(DEFVAR *ONE-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 5)))(DEFVAR *ANOTHER-ARRAY* (MAKE-ARRAY 10 :ELEMENT-TYPE '(SIGNED-BYTE 8)))(DEFUN FROB (AN-ARRAY)  (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))  (SETF (AREF AN-ARRAY 1) 31)		; OK  (SETF (AREF AN-ARRAY 2) 127)		; Should signal an error  (SETF (AREF AN-ARRAY 3) (* 2 (AREF AN-ARRAY 3))) ; Run-time decision needed  (LET ((FOO 0))    (DECLARE (TYPE (SIGNED-BYTE 5) FOO))    (SETF FOO (AREF AN-ARRAY 0))))	; Declared to be safe(FROB *ONE-ARRAY*)			; Legal call, should signal an error(FROM *ANOTHER-ARRAY*)			; Is probably an undetectable errorNote that the above definition of FROB is equivalent to:(DEFUN FROB (AN-ARRAY)  (DECLARE (TYPE (ARRAY (SIGNED-BYTE 5) 1) AN-ARRAY))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 1) 31))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 2) 127))  (SETF (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))	(* 2 (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 3))))  (LET ((FOO 0))    (DECLARE (TYPE (SIGNED-BYTE 5) FOO))    (SETF FOO (THE (SIGNED-BYTE 5) (AREF AN-ARRAY 0)))))Given an implementation in which fixnums are 29 bits but fixnum arraysare upgraded to signed 32-bit arrays, the following should be compiledwith all fixnum arithmetic:(DEFUN BUMP-COUNTERS (COUNTERS)  (DECLARE (TYPE (ARRAY FIXNUM *) BUMP-COUNTERS))  (DOTIMES (I (LENGTH COUNTERS))    (INCF (AREF COUNTERS I))))Test Cases:TBSRationale:This mandates a useful and commonly expected behavior.  It complementsproposal ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS, which deals with arraytype specifiers as they refer to arrays as a whole.  This proposal is consistent with SYMBOL-MACROLET-DECLARE:ALLOW andDECLARATION-SCOPE:LEXICAL.Current practice:???Cost to Implementors:TBSCost to Users:Probably none; while this is technically a change, code that declaresan array to contain one thing and depends on it containing somethingelse is blatantly buggy.Cost of non-adoption:Users will continue to expect declaration syntax to be more usefulthan it really is.Performance impact:None.Benefits:Array type declarations will behave in a more useful and intuitive way.Aesthetics:Improved because the meaning of type declarations will coincide moreclearly with their appearance.Discussion:Pierson and Pitman support this proposal.