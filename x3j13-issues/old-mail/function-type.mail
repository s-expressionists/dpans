*start*00845 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 FEB 87 18:37:40 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 28 Feb 87  18:35:39 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sat 28 Feb 87 21:36:25-ESTDate: Sat, 28 Feb 87 21:36 ESTMessage-ID: <FAHLMAN.12282785586.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: FUNCTION-TYPE In-reply-to: Msg of 26 Feb 1987  18:04-EST from Dick Gabriel <RPG at SAIL.STANFORD.EDU>I think I see what RPG is suggesting, but I have a bunch of questionsabout the details and implications of his proposal.  I'll try toorganize my thoughts on this in the next couple of days and send outsomething on this topic.-- Scott*start*02856 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 26 FEB 87 15:06:28 PSTDate: 26 Feb 87 15:04 PSTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE To: cl-cleanup@SAIL.STANFORD.EDU Proposal:     FUNCTION-TYPEReferences:   functions (pg 32), types (pg 33), FUNCTIONP (pg 76),	      APPLY (pg 107).Category:     CHANGE/CLARIFICATIONEdit History: Revision 1 by RPG 02/26/87Problem Description:The definition of the term `function' in CLtL includes all symbolsand many lists in addition to true functions. The type named `FUNCTION'is, therefore, not a reasonable type. The language would be much cleaned upand improved if functions were treated as a type in a consistent and usefulmanner. Most of the reason for the current state of affairs is the desirefor compatability with the past.Proposal:Page 32, section 2.13 should be amended to read:``A *function* is anything that might be correctly given to the FUNCALL or APPLYfunction and is to be executed as code when arguments are supplied.``The result of evaluating a FUNCTION special form will always be a function.''Page 33, section 2.15: the third bulleted item should be amended toread:``* The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION are    pairwise disjoint.''Page 76, the description of FUNCTIONP should be amended to read:``FUNCTIONP is true if its argument is a function (see page 32).''Page 107, the second sentence should be amended to read:``*Function* must be a function (see page 32).''Page 107, the first and fourth examples should be amended to read:(setq f #'+) (apply f '(1 2)) => 3(apply #'cons '((+ 2 3) 4)) =>       ((+ 2 3) . 4)  *not* (5 . 4)Other examples might require amendment.Rationale:I believe that this change takes a currently meaningless concept in CommonLisp (a function) and gives it a firmer foundation. Many programmerscannot rely on FUNCTIONP filtering out true functions from mere symbols.Current Practice:Programmers write their own predicate for true FUNCTIONP.Adoption Cost:Compiled functions are true functions in almost all implementations, but,in some implementations, interpreted functions are represented as lists.This would need to be changed in the interpreter, FUNCALL, APPLY, andother places.Benefits:A concept would be resurrected:  currently the concept of a function inCommon Lisp is bankrupt.  Common Lisp would come in closer alignment withScheme. It is the first step towards a Lisp1-ification of Common Lisp.Conversion Cost:Unknown. Deep-rooted bugs could be uncovered.Aesthetics:Making the concept of a function well-defined will probably be perceivedas a simplification.Discussion:RPG and Will Clinger believe it is important to get this cleared up assoon as possible.*start*00815 00024 US Return-Path: <@SAIL.STANFORD.EDU:gls@Think.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 27 FEB 87 09:36:18 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 27 Feb 87  09:34:09 PSTReceived: from boethius by Think.COM via CHAOS; Fri, 27 Feb 87 11:55:10 ESTDate: Fri, 27 Feb 87 11:56 ESTFrom: Guy Steele <gls@Think.COM>Subject: FUNCTION-TYPE To: RPG@sail.stanford.edu, cl-cleanup@sail.stanford.eduCc: gls@think.comIn-Reply-To: <8702262305.AA22492@Think.COM>Message-Id: <870227115655.4.GLS@BOETHIUS.THINK.COM>I favor the FUNCTION-TYPE proposal, with some mild reservationsbecause I think the proposal underemphasized the costs of conversion.Nevertheless I would support this proposal befroe the committee,because the current state of affairs is confusing.--Guy*start*01863 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 FEB 87 19:12:45 PSTDate: 28 Feb 87 19:10 PSTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE To: cl-cleanup@SAIL.STANFORD.EDU The point of the proposal is to make the type named FUNCTIONhave a more satisfying meaning. The Object System (CLOS - pronounced``See-Loss'') cannot have a class for functions unless the CommonLisp notion of a function is cleaned up. Things that currently are functions that will no longer be functionsare symbols and lists of the form (lambda ...). If we like thingsthat look like (lambda ...) to be functions, we can make LAMBDA be aspecial form that returns a function.In many implementations, a coercion is replaced by a call to anerror-signaling routine in functions like APPLY and FUNCALL. I thinksome interpreters, such as the Spice Lisp interpreter, will need tobe slightly re-worked. I'm not sure what other things are lurking inthe various implementations, so I cannot comment further on what otherthings will need to be changed.We can now write	(when (and (numberp x)(numberp y)) (+ x y))knowing that the addition will happen exactly when x and y arenumbers and that there will be no errors signalledThis, on the other hand,(when (functionp x) (funcall x))has no such intuitive behavior.Try these:(setq x 'a)(when (functionp x) (funcall x))(setq x '(lambda 99 33))(when (functionp x) (funcall x))I think some implementators will have more difficulty than others inmaking the change, and so I believe that a long ramp for this change isnecessary. I believe that there is now no reason to hang ontocompatability with MacLisp and ZetaLisp.There is plenty of experience with there being a type comprisingtrue functions in the Scheme world.			-rpg-*start*01374 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 FEB 87 19:32:27 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 28 Feb 87  19:30:29 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sat 28 Feb 87 22:31:12-ESTDate: Sat, 28 Feb 87 22:31 ESTMessage-ID: <FAHLMAN.12282795558.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: FUNCTION-TYPE In-reply-to: Msg of 28 Feb 1987  22:10-EST from Dick Gabriel <RPG at SAIL.STANFORD.EDU>Well, let me ask one question that is bothering me right away.  Iunderstand why we might want to create a FUNCTION type that includescompiled functions and what I would call interpreted closures, but thatexcludes lists whose car is lambda and symbols that may or may not bedefined.  (I have some other concerns about that, but will defer themfor now.)However, I'm not sure it is necessary that this new FUNCTION type bedisjoint from the LIST type.  In some systems the easy thing would be toimplement these closure-objects as a list with something special in theCAR.  Any good reason to outlaw this?  (Sure, interpreters could use astructure instead, but there might be efficiency reasons not to dothis.)-- Scott*start*04224 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 02 MAR 87 21:29:49 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 2 Mar 87  21:27:23 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 82Date: Tue, 3 Mar 87 00:26 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: FUNCTION-TYPE To: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: The message of 26 Feb 87 18:04 EST from Dick Gabriel <RPG@SAIL.STANFORD.EDU>,             <8702271Message-ID: <870303002615.9.MOON@EUPHRATES.SCRC.Symbolics.COM>I am basically in favor of the proposal, with some minor amendmentsnoted below.  I believe that the current definition of "function" inCommon Lisp was taken from pre-lexical-scoping Zetalisp and was notproperly reexamined when lexical scoping was thrown into the language,and in addition got damaged by abstracting out some of the specificbehavior for functions that Zetalisp had.Amendments:How does the proposal affect page 47?  I propose that it does not affectit except for adding a note that the atomic type-specifier FUNCTION canbe used for discrimination, but the list type-specifier (FUNCTION ...)cannot be.  This is already true, but perhaps not clear.As long as you are incompatibly changing the function FUNCTIONP,eliminate it entirely.  It doesn't do anything that TYPEP can't do.I don't believe that APPLY and FUNCALL should say that their <function>argument must be a function.  In current Common Lisp these primitivesindirect through symbols; you imply in the examples that this featurewill be removed, but don't say so explicitly and don't mention it in theadoption cost and conversion cost sections.  I know that some people usethis programming style and I don't see any advantage to removing it.Removing it would add incompatibility but wouldn't help clarify thedefinition of "function".  Just say that APPLY and FUNCALL accept eithera function or a symbol; given a symbol, they apply SYMBOL-FUNCTION to itand try again.By the way, it's important that using something other than a function ora symbol as the <function> argument to APPLY or FUNCALL "is an error"rather than "signals an error", because this leaves room forimplementation dependent extensions.  For example, it allows Old Flavorssupport; we need to be able to FUNCALL instances, but we surely don'twant to say that instances are functions.I don't believe that the value returned by the FUNCTION special formshould be required to be a function.  What does #'COND do?  CurrentlyCLtL specifies that this returns "an object representing a specialform or macro".  (That's reading pages 87 and 90; page 32 contradictsthis but I'm inclined to believe the specific function descriptionpages over the introductory pages.)  What does(macrolet ((foo (x) `(blatz ,x))) #'foo) do?  CLtL doesn't say.I don't care as much about this one, since I don't see how applicationprograms could be depending on it.It might be wise to add LEXICAL-CLOSURE and INTERPRETED-FUNCTION datatypes, to go along with the COMPILED-FUNCTION type that already exists.These three would be disjoint subtypes of FUNCTION, but not necessarilyan exhaustive partition.  There might be other ways to slice the spaceof types, since it's not so clear what a function not inside a closureis good for.  Alternatively we could flush COMPILED-FUNCTION and saythat the subtypes of FUNCTION are all implementation-dependent.  But Ithink having COMPILED-FUNCTION without the others is weird.With my suggested amendments, the only incompatible changes would be:  The FUNCTION type is now disjoint with CONS, SYMBOL, ARRAY,   NUMBER, and CHARACTER.  Compiled functions and closures must not be conses, symbols,   arrays, numbers, or characters.  The FUNCTIONP function is removed.This seems like just as much of a burden for implementors, but much lessof a burden for application programmers since very few applicationprograms would be affected by these changes, especially if they are notcalling FUNCTIONP now because its definition is bankrupt.*start*02523 00024 USaReturn-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 04 MAR 87 16:03:42 PSTDate: 04 Mar 87 16:01 PSTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE To: cl-cleanup@SAIL.STANFORD.EDU Moon makes some good points.Moon writes:``How does the proposal affect page 47?  I propose that it does not affectit....''Agreed.Moon writes:``As long as you are incompatibly changing the function FUNCTIONP,eliminate it entirely.  It doesn't do anything that TYPEP can't do.''Agreed.Moon writes:``I don't believe that the value returned by the FUNCTION special formshould be required to be a function.  What does #'COND do?  CurrentlyCLtL specifies that this returns "an object representing a specialform or macro".  (That's reading pages 87 and 90; page 32 contradictsthis but I'm inclined to believe the specific function descriptionpages over the introductory pages.)''This is an interesting point. To summarize the pages to which Moon refers,page 32 states that FUNCTION produces a function, page 87 states that (FUNCTION <symbol>) returns the functional definition associated with<symbol> (see SYMBOL-FUNCTION), and page 90 states that SYMBOL-FUNCTIONreturns the function definition associated with the symbol given to itas an argument, but that if the symbol represents a special form (like COND)SYMBOL-FUNCTION might return some other object. It is an error to attemptto invoke that other object.I propose that we clarify this contradictory set of statements by changingpage 32 as I proposed and leaving page 87 alone; page 90 would be amendedto state that SYMBOL-FUNCTION always returns a function if the symbol isFBOUNDP, but that it is an error to invoke that function if the symbolrepresents a special form.  That is, even if the symbol represents aspecial form, it has a function in its function cell, but invoking thatfunction is an error. Some implementations might signal that error.Anyone with an implementation in which this makes a difference shouldspeak up.I think that FUNCALL and APPLY really ought to be legal only on functionsand that the programmer should program his intentions.Moon writes:``For example, it allows Old Flavors support; we need to be able toFUNCALL instances, but we surely don't want to say that instances arefunctions.''Although I have little sympathy for Old Flavors, I would suggest that intheir implementation instances be made a subtype of FUNCTION.			-rpg-*start*01853 00024 US Return-Path: <@SAIL.STANFORD.EDU:gls@Think.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 05 MAR 87 06:58:42 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 5 Mar 87  06:56:09 PSTReceived: from boethius by Think.COM via CHAOS; Thu, 5 Mar 87 09:46:56 ESTDate: Thu, 5 Mar 87 09:48 ESTFrom: Guy Steele <gls@Think.COM>Subject: FUNCTION-TYPE To: cl-cleanup@sail.stanford.eduIn-Reply-To: <8703050002.AA06014@Think.COM>Message-Id: <870305094854.1.GLS@BOETHIUS.THINK.COM>    Date: 04 Mar 87  1601 PST    From: Dick Gabriel <RPG@sail.stanford.edu>    Moon makes some good points.    ...    Moon writes:    ``I don't believe that the value returned by the FUNCTION special form    should be required to be a function.  What does #'COND do?  Currently    CLtL specifies that this returns "an object representing a special    form or macro".  (That's reading pages 87 and 90; page 32 contradicts    this but I'm inclined to believe the specific function description    pages over the introductory pages.)''    This is an interesting point. To summarize the pages to which Moon refers,    page 32 states that FUNCTION produces a function, page 87 states that     (FUNCTION <symbol>) returns the functional definition associated with    <symbol> (see SYMBOL-FUNCTION)...One question is: can COND, which is not a function, be said tohave a functional definition?  Also, page 87 states "fn is interpretedas if it had appeared in the functional position of a functioninvocation."  Because (COND ...) is not a function invocation,one could claim that #'COND cannot be understood in this way tobe meaningful.  I have been trying to remember what I meant whenthat text was written, but I can't.[It feels really weird to be constantly examining hermeneuticallytext that I wrote myself.]--Guy*start*01327 00024 USmReturn-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 05 MAR 87 10:39:20 PSTDate: 05 Mar 87 10:37 PSTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE & Hermeneutics To: cl-cleanup@SAIL.STANFORD.EDU Now you're talking, Quux! Actually, if you had been involved withCLOS, you would have been quite used to reading text that way.However, to be serious (sic), the key to understanding the linkagebetween pages 87 and 90 is the phrasing:``In particular, if FN is a symbol, the functional definition associatedwith that symbol is returned; see SYMBOL-FUNCTION [which is page 90].''Then on page 90 the relevant text starts out,``SYMBOL-FUNCTION returns the current global function definitionnamed by SYMBOL....''The question is whether the semi-colon followed by ``see SYMBOL-FUNCTION''means that SYMBOL-FUNCTION is what FUNCTION is equivalent to or thatthe definition of SYMBOL-FUNCTION is enlightening in terms of understandingwhat FUNCTION does when the SYMBOL represents a function and not a specialform.Similarity of phrasing, collocation, and the linkage of ``see..''implies, to me, that (FUNCTION <symbol>) and (SYMBOL-FUNCTION <symbol>)are intended to be synonymous. I suggest we clarify this as I proposedearlier.			-rpg-*start*01627 00024 US Return-Path: <@SAIL.STANFORD.EDU:gls@Think.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 05 MAR 87 20:59:49 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 5 Mar 87  20:57:35 PSTReceived: from boethius by Think.COM via CHAOS; Thu, 5 Mar 87 17:42:50 ESTDate: Thu, 5 Mar 87 17:44 ESTFrom: Guy Steele <gls@Think.COM>Subject: FUNCTION-TYPE & Hermeneutics To: RPG@sail.stanford.edu, cl-cleanup@sail.stanford.eduCc: gls@think.comIn-Reply-To: <8703051937.AA14825@Think.COM>Message-Id: <870305174444.5.GLS@BOETHIUS.THINK.COM>    Date: 05 Mar 87  1037 PST    From: Dick Gabriel <RPG@sail.stanford.edu>    However, to be serious (sic)...    Similarity of phrasing, collocation, and the linkage of ``see..''    implies, to me, that (FUNCTION <symbol>) and (SYMBOL-FUNCTION <symbol>)    are intended to be synonymous. I suggest we clarify this as I proposed    earlier.			    -rpg-I agree with you.  However, to be non-serious:    [p. 87]    ``In particular, if FN is a symbol, the functional definition associated    with that symbol is returned; see SYMBOL-FUNCTION [which is page 90].''    ...    The question is whether the semi-colon followed by ``see SYMBOL-FUNCTION''    means that SYMBOL-FUNCTION is what FUNCTION is equivalent to or that    the definition of SYMBOL-FUNCTION is enlightening in terms of understanding    what FUNCTION does when the SYMBOL represents a function and not a special    form.The question is really whether the semicolon means the rest of the line isto be ignored.  After the semicolon, the next word should be "sure".--Q*start*08597 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 08 MAR 87 21:56:23 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 8 Mar 87  21:53:10 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Mon 9 Mar 87 00:53:51-ESTDate: Mon, 9 Mar 87 00:53 ESTMessage-ID: <FAHLMAN.12284918673.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUCc: fahlman@C.CS.CMU.EDUSubject: FUNCTION-TYPEI'd like to discuss a bunch of issues raised by RPG's FUNCTION-TYPEproposal.  I think that we need to understand some of these issuesbetter and see if we can reach a consensus before we try to produce afinal proposal (or set of proposals) to bring before the community.I should say first of all that, speaking only for myself, I would favorall of RPG's proposed changes (if I understand them correctly).However, I think that his proposal contains some lines of argument thatmight hurt his cause, and it bundles issues together in a way that manypeople will view as unfair: a proposal for the obviously necessarycleanup of the FUNCTION data type is combined with some incompatiblechanges whose justification is more aesthetic than anything else.Companies for whom incompatible changes are very expensive might want toaccept the cleanup but not the rest of the proposal.  It is unfair of usto try to "sleaze" these changes past them by mixing everythingtogether and then telling them to take it or leave it.As I understand RPG's proposal (as clarified by subsequent discussion),it suggests the following incompatible changes:1. A change in the definition of the FUNCTION type (and of FUNCTIONP, ifwe keep it).  Symbols, whether or not fboundp, and lambda expressionswould no longer qualify as functions.  We are left with compiledfunction objects and interpreted closures.2. It "is an error" to put anything other than a function (new strictdefinition) into the SYMBOL-FUNCTION cell.  Implementations may putother things there if they choose, but portable code cannot count onthis.  Actually, this is unclear at present, so it counts as aclarification and not a change.  FUNCTION when called on a symbol wouldreturn the associated function if there is one; if the symbol currentlynames a macro or special form, FUNCTION signals an error, regardless ofwhat might be in the SYMBOL-FUNCTION cell.3. The FUNCTION data type must be disjoint from the CONS data type.This underlines the requirement that a lambda expression is not a type,but it goes farther: it prohibits implementors from using a list toimplement any of the FUNCTION subtypes.  I suspect that a majority ofimplementations currently use lists to implement functions in theinterpreter, so this is not just a hypothetical incompatibility.4. The functional argument to FUNCALL, APPLY, and friends must now be afunction (strict definition).  It may not be a lambda expression or asymbol naming a function, thought this is clearly legal at present.One could quibble about whether the FUNCTION type is "bankrupt" or justa mess, but I agree that change 1 or something close to it is the rightway to perform the needed cleanup.  Change 2 is probably not toocontroversial.I asked in an earlier note about change 3, forbidding the use of a listto implement functions.  Some of RPG's reply strikes me as bogus.  Hesays that lists and functions are conceptually distinct, just as numbersand lists are distinct.  In my own view, lists are perfectly good rawmaterial from which to implement other data types that (functionally)have nothing to do with lists.  It is analogous to the use of a vectorto implement a named structure that in turn implements a random seed ora window.  (Currently we have a more awkward situation that really isuntenable: FUNCTION and CONS overlap, but neither type contains theother and we don't have a clean predicate for the itnersection.)But despite this objection that one of the arguments is weak, I agreewith some of the other reasons for making FUNCTION and CONS be disjointtypes: it prevents any further confusion about whether a Lambda list isa function, and it cleans up the type hierarchy in a way that shouldmake the new object proposal less complex.  And we are moving away fromthe position that it is OK to implement a structure (or an instance) asa Lisp vector.Change 4 is perhaps the one that affects the most user code, and it isthe change whose motivation is weakest.  One could imagine (and Moon hasproposed) adopting all the other changes, but saying that FUNCALL, APPLYand friends can take a function (new definition), a lambda list, or asymbol: in the latter two cases, FUNCTION is applied to the argumentbefore it is used.  RPG asserts that he likes his original proposalbetter.  So do I, on aesthetic grounds, but I think we need moreammunition than that in order to propose an incompatible change of thissize to the user community.  Is there a better justification?  If not, Ithink we should not push this change, or at least we should make it aseparate issue.Some other points:I think that RPG's proposed new definition of the function type iscircular, or at least not very easy to understand: "A FUNCTION isanything that might legally be given to FUNCALL or APPLY...and is to beexecuted as code."  I think we need to nail this down by spelling outall the cases in one place, when the FUNCTION data type is beingdefined.I don't like Moon's proposal that we flush FUNCTIONP.  I think that lotsof people will view this as a gratuitous incompatibility.  We need toclean up the definition of the FUNCTION data type, so that (TYPEP ...'FUNCTION) means something.  Once we've done that, I think we shouldjust define FUNCTIONP to mean the same thing as (TYPEP ... 'FUNCTION).At some point, we should consider whether to add new mumble-P predicatesfor all of the basic types or to get rid of them all, but I see no goodreason to add or delete any except as part of such a systematic change.It is a very bad idea to say that an advantage of the proposed change isthat "it is the first step towards a Lisp1-ification of Common Lisp".  Alot of people would vote against the FUNCTION-TYPE proposal if theybelieved that.  I might be one of them -- I'm against any such stepsuntil I see a workable Macro proposal.  Just say that it brings uscloser to Scheme and let it go at that.  In truth, I don't think thatthis has much to do with the Lisp1/Lisp2 issue per se.What exactly do we say that the FUNCTION special form does?  How aboutthe following: If applied to a symbol, it returns the current functionaldefinition, if any, else it signals an "undefined" error.  (An error issignalled if the symbol currently names a macro or special form insteadof a function.)  If applied to a lambda expression, FUNCTION returns afunction corresponding to the closure of that lambda expression in thecurrent lexical environment.  If applied to a function, it returns thatfunction unchanged.  Else it signals a "wrong type arg" error.  [I guesswe shouldn't use the verb "apply" with a special form, but you get theidea.]We should fix the description of DEFUN to make it clear that it isequivalent to(SETF (SYMBOL-FUNCTION name)      (FUNCTION (LAMBDA ...)))That is, the closure of the lambda in the environment of the defun iswhat gets saved.Do we want to propose that Lambda is a special form (or specialoperator), and that when you execute a lambda expression it returns theclosure, just as (FUNCTION (LAMBDA ...)) does now?  That looks OK to me.Under the definition of FUNCTION above, the (FUNCTION (LAMBDA ...)) formwould be allowed, so this introduces no new compatibility problems.Probably we should explicitly name COMPILED-FUNCTION andINTERPRETED-FUNCTION as subtypes of FUNCTION, and make TYPEP work forthem.  Am I correct in deducing that there would be no such thing as afunction that is not closed in some environment -- possibly the nullenvironment?  Moon seems to think that interpreted functions andinterpreted closures would be distinct concepts.  Some implementationscurrently use the raw lambda expression to represent functions whoseclosure doesn't capture anything external, but this would no longer belegal.That's all for now.  I might add that Rob independently came up with theobjection about all this stuff being bundled.  So, with Moon, that'sthree of us who found this aspect of the proposal to be troubling.-- Scott*start*05261 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 07:54:56 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 10 Mar 87  07:48:09 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 89098; Tue 10-Mar-87 01:57:50 ESTDate: Tue, 10 Mar 87 01:57 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: FUNCTION-TYPETo: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12284918673.BABYL@C.CS.CMU.EDU>,             The message of 9 Mar 87 02:51 EST from Dick Gabriel <RPG@SAIL.STANFORD.EDU>,             <FAHLMAN.12285028625.BABYL@C.CS.CMU.EDU>Message-ID: <870310015739.9.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 9 Mar 1987  00:53 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>This 150-line message of Scott's summarized the situation very welland I have almost nothing to add.  However, I am in the mood to waxprolix anyway.Somewhere RPG suggested that #'COND should return an object that iscalled a function, but is an error to call.  I'm opposed to this.Right now in our implementation #'COND returns an object that isnot called a function and is an error to call.  Either doing thator saying that it signals an error would get my vote.    I don't like Moon's proposal that we flush FUNCTIONP.I think all these mumble-P predicates are worthless, but I withdrawthe suggestion to flush FUNCTIONP.    What exactly do we say that the FUNCTION special form does?  How about    the following: If applied to a symbol, it returns the current functional    definition, if any, else it signals an "undefined" error.  (An error is    signalled if the symbol currently names a macro or special form instead    of a function.)  If applied to a lambda expression, FUNCTION returns a    function corresponding to the closure of that lambda expression in the    current lexical environment.  If applied to a function, it returns that    function unchanged.I'm opposed to this last clause.  It perpetuates the confusion between"a function" and "the name of a function".  The FUNCTION special form shouldonly accept "the name of a function", and should only return "a function".What it returns is the function denoted by the name, which involves closingin the current lexical environment if the name is a lambda-expression, whichis why FUNCTION is a special form.    Moon seems to think that interpreted functions and    interpreted closures would be distinct concepts.In -some- implementations they -could- be distinct concepts, just ascompiled functions and compiled closures could be.  I vacillate betweensaying that all of the subtypes of FUNCTION are implementation-dependentand shouldn't be standardized (thus COMPILED-FUNCTION should beremoved), and saying that programs might want to know this information,so all the plausible subtypes should have standard names, even if theyaren't distinct in some implementations.  The only thing I feel stronglyand consistently about is that COMPILED-FUNCTION should not be the onlystandardized subtype of FUNCTION; it should either acquire some siblingsor go away.    Date: 08 Mar 87  2351 PST    From: Dick Gabriel <RPG@SAIL.STANFORD.EDU>    Another alternative would be to define a functional form of FUNCTION,    called, for argument's sake, ENSURE-FUNCTION, such that    (ENSURE-FUNCTION <lambda-form>) = <closure corresponding to lambda-form>    (ENSURE-FUNCTION <symbol>) = (SYMBOL-FUNCTION <symbol>)    (ENSURE-FUNCTION <function>) = <function>    and then to define FUNCALL and APPLY to apply ENSURE-FUNCTION on its    first argument.This is okay with me if it's renamed to (COERCE <argument> 'FUNCTION).Note that it explicitly does not take a lexical environment as an argument,it always uses the null environment (only an issue when the argument isa lambda-expression.)    Date: Mon, 9 Mar 1987  10:57 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    Yeah, this might be the right move.  The FUNCTION special form now    becomes pretty useless, but we have to keep it for compatibility.Not so, because FUNCTION encloses in the current lexical environment.FUNCTION and COERCE-to-FUNCTION are actually at different reflectivelevels (if I may pretend for a moment that I understood Brian Smith'sthesis).    Date: 08 Mar 87  2351 PST    From: Dick Gabriel <RPG@SAIL.STANFORD.EDU>    Scott writes:    ``I think that RPG's proposed new definition of the function type is    circular, or at least not very easy to understand: ....''Making it disjoint from other types should help a lot; now when we saythat there are functions, we don't have to mumble about kludgey ways todistinguish them from other types, they are already distinguished.  Thenall that remains is to define their semantics, i.e. how they behave.  Wedon't want to appeal to the mathematical notion of function, but if weenumerate the conceptual subtypes (even if they aren't explicit languagesubtypes) of interpreted and compiled closures, possibly nakedinterpreted and compiled functions, and generic functions, the ideashould come across.*start*00794 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 09:40:25 PSTDate: 10 Mar 87 09:38 PSTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: Function Type To: cl-cleanup@SAIL.STANFORD.EDU Moon writes:``Right now in our implementation #'COND returns an object that isnot called a function and is an error to call.  Either doing thator saying that it signals an error would get my vote.''This is an alternative I thought of, but didn't mention. Namely,Let <symbol> be a symbol that names not a function. (function <symbol>), (symbol-function <symbol>), #'<symbol>all signal an error.If, on the other hand, we want #'<symbol'> to return a functionin all cases, then #'COND has to return a function.			-rpg-*start*02918 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 14:23:13 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 10 Mar 87  14:16:34 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 89832; Tue 10-Mar-87 17:16:01 ESTDate: Tue, 10 Mar 87 17:15 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: FUNCTION-TYPETo: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12285343870.BABYL@C.CS.CMU.EDU>Message-ID: <870310171555.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 10 Mar 1987  15:49 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>	    If applied to a function, it (FUNCTION) returns that	    function unchanged.	I'm opposed to this last clause.  It perpetuates the confusion between	"a function" and "the name of a function".  The FUNCTION special form should	only accept "the name of a function", and should only return "a function".	What it returns is the function denoted by the name, which involves closing	in the current lexical environment if the name is a lambda-expression, which	is why FUNCTION is a special form.    I agree that your view of this is conceptually cleaner.  The main reason for    allowing functions to pass through FUNCTION unchanged was to allow us to    turn Lambda into a special form that, when executed, returns a function    closed in the current environment.  The form #'(lambda ...) could be    deprecated if we do this, but it would be nice not to have to find all    the occurrences of this form and fix them.  I was afraid that this    prospect might make people balk at the change to lambda.  But the    process of eliminating #'(lambda ...) can be automated, so I don't feel    too strongly about this.  And if we don't adopt the change to Lambda,    then Moon's version of FUNCTION is better.This makes no sense.  The FUNCTION special form doesn't evaluate its argument,so it makes no difference what that Lisp object would happen to do if itwere evaluated.  The only way a function would need to pass unchanged throughthe FUNCTION special form would be if a function appeared in source code.Since there is no standardized printed representation for functions, thisseems unlikely.  I assume we don't have to worry very much aboutwhat #'#.(lambda ...) does; I propose that it signals an error.    Right, temporary insanity on my part.  Guess I should try again to read    Brian Smith's thesis...(-: Don't bother, the most likely result would be permanent insanity (orsore arms from holding it up for the weeks it takes to read).  :-)Actually, there is a short version (I assume it's an MIT AI memo, I can'tquite remember) which I found fairly understandable, and I'd recommendreading that.  It's still 100 pages or so.*start*00795 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 18:15:38 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 10 Mar 87  18:11:22 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 90033; Tue 10-Mar-87 21:08:56 ESTDate: Tue, 10 Mar 87 21:08 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: FUNCTION-TYPETo: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12285392689.BABYL@C.CS.CMU.EDU>Message-ID: <870310210851.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 10 Mar 1987  20:17 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>	This makes no sense.    Right?Right.*start*01485 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 17:20:58 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 10 Mar 87  17:17:07 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 10 Mar 87 20:17:41-ESTDate: Tue, 10 Mar 87 20:17 ESTMessage-ID: <FAHLMAN.12285392689.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: FUNCTION-TYPEIn-reply-to: Msg of 10 Mar 1987  17:15-EST from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>    This makes no sense.  The FUNCTION special form doesn't evaluate its argument,    so it makes no difference what that Lisp object would happen to do if it    were evaluated.OK, you're right.  So #'(lambda ...) should close the lambda in thecurrent lexical environment, as it always has.  #'<some-symbol> shouldget that symbol's definition in the current lexical environment, if thatsymbol currently names a function, else it signals an error.  AndFUNCTION of anything else signals an error.  This leaves us free to say that a lambda expression, when evaluated, isthe same as (FUNCTION (lambda...)).  That is, it also returns a functioncorresponding to the closure of that lambda in the current lexicalenvironment.  So old code full of #'(lambda ...) forms would continue towork. Right?-- Scott*start*01985 00024 US Return-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 10 MAR 87 18:03:32 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 10 Mar 87 21:02:06-ESTDate: Tue, 10 Mar 87 21:01 ESTMessage-ID: <FAHLMAN.12285400756.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDUSubject: #'cond, etc.  In-reply-to: Msg of 10 Mar 1987  18:28-EST from Masinter.pa at Xerox.COMI would be most comfortable with the following position, intermediatebetween Larry's choices:#'anything is absolutely equivalent to (FUNCTION anything) in all cases.(FUNCTION <symbol>), where the symbol names a function in the currentlexical context, returns that function.  If the symbol names aspecial-whatever or a macro, or if it currently has no definition, thena error IS SIGNALLED.If SYMBOL-FUNCTION is called on a symbol that names a function in thecurrent lexical context, it returns that function.  It IS AN ERROR tocall it on a symbol that names a macro or special form -- what itreturns in thsi case, if anything, is unpredictable.  Similarly, it ISAN ERROR to pass SETF of SYMBOL-FUNCTION a value that is not a function.Some implementations may accept this, others may signal an error.The point is that we can tighten up FUNCTION to always return afunction, while treating SYMBOL-FUNCTION as a lower-level primitive thatimplementors may use in implementing special-whatevers or macros.If we force SYMBOL-FUNCTION to return a function in all cases or signalan error, it is not a disaster: implementors could define some primitive%SYMBOL-FUNCTION that returns whatever is there, and the user-visibleSYMBOL-FUNCTION wraps a type-test around this.  But it seems to me likea gratuitous incompatibilty at this point.  We went out of our way toallow freedom in the use of SYMBOL-FUNCTION, and many implementationshave taken advantage of this.-- Scott*start*01982 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 11 MAR 87 12:02:12 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 11 Mar 87  09:27:57 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Wed 11 Mar 87 12:26:24-ESTDate: Wed, 11 Mar 87 12:26 ESTMessage-ID: <FAHLMAN.12285569035.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To:   edsel!bhopal!jonl@navajo.stanford.edu (Jon L White)Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: #'anythingIn-reply-to: Msg of 11 Mar 1987  10:45-EST from edsel!bhopal!jonl at navajo.stanford.edu (Jon L White)    Date: Wednesday, 11 March 1987  10:45-EST    From: edsel!bhopal!jonl at navajo.stanford.edu (Jon L White)    To:   navajo!Fahlman%C.CS.CMU.EDU at navajo.stanford.edu    cc:   Masinter.pa at xerox.com, cl-cleanup at sail.stanford.edu    Re:   #'anything    Re: #'anything is absolutely equivalent to (FUNCTION anything) in all cases.        (FUNCTION <symbol>), where the symbol names a function in the current        lexical context, returns that function.  . . .     As I remember it, the intent was that (FUNCTION <symbol>) would refer    to the innermost lexical function binding (as by flet, labels) if any,     or to the global function binding otherwise; (SYMBOL-FUNCTION '<symbol>)    would always refer to the global binding.  Are you really proposing to    do away with this distinction?No.  What ever gave you that idea?  When I say that "symbol names afunction in the current lexical context" I mean exactly what you justsaid that FUNCTION does, and I'm not proposing to change SYMBOL-FUNCTIONat all, except to clarify what is and is not an error.I guess my choice of words in describing FUNCTION was a poor choice,since it has bothered both you and RPG, though I still don't see theproblem.  In any event, we should use something like your wordinginstead.-- Scott*start*02924 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 MAR 87 09:15:07 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 11 Mar 87  14:03:26 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 90892; Wed 11-Mar-87 17:02:33 ESTDate: Wed, 11 Mar 87 17:02 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: #'cond, etc.  To: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12285400756.BABYL@C.CS.CMU.EDU>Message-ID: <870311170226.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 10 Mar 1987  21:01 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    I would be most comfortable with the following position, intermediate    between Larry's choices:    #'anything is absolutely equivalent to (FUNCTION anything) in all cases.    (FUNCTION <symbol>), where the symbol names a function in the current    lexical context, returns that function.  If the symbol names a    special-whatever or a macro, or if it currently has no definition, then    a error IS SIGNALLED.    If SYMBOL-FUNCTION is called on a symbol that names a function in the    current lexical context, it returns that function.  This is a typo, right?  "in the current lexical context" should be "globally".							It IS AN ERROR to    call it on a symbol that names a macro or special form -- what it    returns in thsi case, if anything, is unpredictable.  Similarly, it IS    AN ERROR to pass SETF of SYMBOL-FUNCTION a value that is not a function.    Some implementations may accept this, others may signal an error.    The point is that we can tighten up FUNCTION to always return a    function, while treating SYMBOL-FUNCTION as a lower-level primitive that    implementors may use in implementing special-whatevers or macros.Except for the typo noted above, I agree with this.    If we force SYMBOL-FUNCTION to return a function in all cases or signal    an error, it is not a disaster: implementors could define some primitive    %SYMBOL-FUNCTION that returns whatever is there, and the user-visible    SYMBOL-FUNCTION wraps a type-test around this.  But it seems to me like    a gratuitous incompatibilty at this point.  We went out of our way to    allow freedom in the use of SYMBOL-FUNCTION, and many implementations    have taken advantage of this.The Common Lisp Object System is going to propose a "gratuitous" incompatibilityin SYMBOL-FUNCTION anyway, I believe, although somehow it seems to have beendropped from (or never got into) the documents that were distributed as 87-002.It's an incompatibility for implementors, not for users, and requires thereto be underlying subprimitives that get and set the "real" function definitionof a symbol.  So I guess doing the same thing here must be okay.*start*01219 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 MAR 87 09:15:18 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 11 Mar 87  19:46:23 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Wed 11 Mar 87 22:47:05-ESTDate: Wed, 11 Mar 87 22:47 ESTMessage-ID: <FAHLMAN.12285682035.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: #'cond, etc.  In-reply-to: Msg of 11 Mar 1987  17:02-EST from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>        If SYMBOL-FUNCTION is called on a symbol that names a function in the        current lexical context, it returns that function.      This is a typo, right?  "in the current lexical context" should be    "globally".Right.  It's not exactly a typo, but it is certainly not what I meant tosay.  "Globally" is right.  Now I see what was confusing JONL.A "gratuitous" incompatibility ceases to be gratuitous if done for agood reason.  If the CLOS proposal wants to change SYMBOL-FUNCTION,presumably there's some good reason.-- Scott*start*01157 00024 US Return-Path: <JAR@AI.AI.MIT.EDU>Received: from AI.AI.MIT.EDU by Xerox.COM ; 12 MAR 87 12:53:56 PSTDate: Thu, 12 Mar 87 15:55:14 ESTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  #'cond, etc.  To: Fahlman@C.CS.CMU.EDUcc: cl-cleanup@SAIL.STANFORD.EDU, Masinter.paIn-reply-to: Msg of Tue 10 Mar 1987  21:01 EST from Scott E. Fahlman <Fahlman at C.CS.CMU.EDU>Message-ID: <167474.870312.JAR@AI.AI.MIT.EDU>    Date: Tue, 10 Mar 1987  21:01 EST    From: Scott E. Fahlman <Fahlman at C.CS.CMU.EDU>    (FUNCTION <symbol>), where the symbol names a function in the current    lexical context, returns that function.  If the symbol names a    special-whatever or a macro, or if it currently has no definition, then    a error IS SIGNALLED.This is asymmetric with variable reference unless the semantics ofvariable references is also changed to signal an error if the variableis unbound.  Changing one and not the other would be bizarre and (to me)distasteful, and changing either is incompatible with Common Lisp'sphilosphy of permitting compiled code which in the interest of speedomits checks like this.Jonathan*start*01790 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 MAR 87 14:07:16 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 12 Mar 87  14:02:42 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 92016; Thu 12-Mar-87 17:02:08 ESTDate: Thu, 12 Mar 87 17:02 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: #'cond, etc.  To: Jonathan A Rees <JAR@AI.AI.MIT.EDU>cc: cl-cleanup@SAIL.STANFORD.EDU, Masinter.paIn-Reply-To: <167474.870312.JAR@AI.AI.MIT.EDU>Message-ID: <870312170213.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Thu, 12 Mar 87 15:55:14 EST    From: Jonathan A Rees <JAR@AI.AI.MIT.EDU>	Date: Tue, 10 Mar 1987  21:01 EST	From: Scott E. Fahlman <Fahlman at C.CS.CMU.EDU>	(FUNCTION <symbol>), where the symbol names a function in the current	lexical context, returns that function.  If the symbol names a	special-whatever or a macro, or if it currently has no definition, then	a error IS SIGNALLED.    This is asymmetric with variable reference unless the semantics of    variable references is also changed to signal an error if the variable    is unbound.  Changing one and not the other would be bizarre and (to me)    distasteful, and changing either is incompatible with Common Lisp's    philosphy of permitting compiled code which in the interest of speed    omits checks like this.Good point.  It's always hard for me to remember which things are"signals an error" in Symbolics Common Lisp but "is an error" instraight Common Lisp.  I agree that the error checking in FUNCTIONis more properly "is an error", by Common Lisp's current philosophy.*start*01714 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 MAR 87 20:31:33 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 12 Mar 87  20:10:09 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Thu 12 Mar 87 23:10:41-ESTDate: Thu, 12 Mar 87 23:10 ESTMessage-ID: <FAHLMAN.12285948474.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: #'cond, etc.          From: Jonathan A Rees <JAR@AI.AI.MIT.EDU>    	(FUNCTION <symbol>), where the symbol names a function in the current    	lexical context, returns that function.  If the symbol names a    	special-whatever or a macro, or if it currently has no definition, then    	a error IS SIGNALLED.        This is asymmetric with variable reference unless the semantics of        variable references is also changed to signal an error if the variable        is unbound.Well, the manual says nothing about what happens when FUNCTION is calledon a symbol that is currently unbound.  There's a pointer toSYMBOL-FUNCTION, which clearly says "signals" (page 90).  A reference toan unbound variable "is an error", while "an error occurs" forSYMBOL-VALUE.  I don't care what we do about this, but it might be worthchanging a few things to get a consistent set of rules here.Whatever the standard says, I think that any decent implemenation willsignal an error in these cases unless the code in question is in afunction compiled with SPEED > SAFETY, but my attempt to get this intothe standard last summer stirred up so much trouble that I'm not goingto raise that issue again.-- Scott*start*01348 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 23:51:48 PSTDate: 10 Mar 87 23:47 PSTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: Consistency   To: cl-cleanup@SAIL.STANFORD.EDU I think if we were to choose to pursue consistency in the definitionof functions we would soon find ourselves in Lisp1-land. Larry, Scott,and, of course, Moon are right: current Common Lisp programming practiceconfuses functions and symbols (names for functions). There is a limiton how far down the consistency path we can go before we fundamentallychange Common Lisp to Lisp1. MacLisp-trained Common-Lispers are not used to thinking about symbols andfunctions in a deep way, and even people who return to first principles inthe form of Lisp 1.5 also see a confusion in this area.  Notice thatScott, who is quite Lisp-knowledgeable, in his last message talked about``symbols that name functions in the current lexical context,'' butsymbols are in a global context. This signals to me that thinking inprecise and consistent terms about functions and symbols is not part ofcurrent Common Lisp practice. So there is no point in pursuing consistencyvery far, and we compromise.Scott's compromise on FUNCTION and SYMBOL-FUNCTION is probably asgood as we can do.			-rpg-*start*01983 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 MAR 87 16:30:58 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 10 Mar 87  16:26:18 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 10 MAR 87 15:28:44 PSTDate: 10 Mar 87 15:28 PSTFrom: Masinter.paSubject: Re: Consistency is the Hob....   In-reply-to: Dick Gabriel <RPG@SAIL.STANFORD.EDU>'s message of 10 Mar 87 14:42 PSTTo: RPG@SAIL.STANFORD.EDUcc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <870310-152844-1933@Xerox>Richard,I don't see the irony that you apparently do.   There is good reason toavoid introducing incompatibility in the operation of APPLY and FUNCALL.We should be very cautious about how things behave. On the other hand,we have a great deal of flexibility in crafting the way things are*described*.  If you think Moon is being inconsistent, you need to sayso more directly, and explain why.It sounds to me that the only major question remaining in thefunction-type proposal is the handling of #'cond and #'a-macro, and thehandling of (symbol-function 'cond) and (symbol-function 'a-macro).I think no-one wants (function foo) to be different from #'foo.The positions are:"is an error"   #'cond  (symbol-function 'cond)   #'a-macro(symbol-function 'a-macro)   are errors. Implementations are free to		signal errors"signals an error"	same, but implementations are required to signalerrors"returns an unspecified value"	   The value returned is not specified,but implementations may not signal an error."returns a function"	The value returned must of type function, butattempting to call it signals an error.My personal belief is that "is an error" reflects current practice,i.e., the language in CLtL is vague enough to admit all of the otherinterpretations. Would the rest of you feel comfortable with a specification which saidthat (symbol-function 'cond) "is an error"? *start*00845 00024 USmReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 28 FEB 87 18:37:40 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 28 Feb 87  18:35:39 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sat 28 Feb 87 21:36:25-ESTDate: Sat, 28 Feb 87 21:36 ESTMessage-ID: <FAHLMAN.12282785586.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: FUNCTION-TYPE In-reply-to: Msg of 26 Feb 1987  18:04-EST from Dick Gabriel <RPG at SAIL.STANFORD.EDU>I think I see what RPG is suggesting, but I have a bunch of questionsabout the details and implications of his proposal.  I'll try toorganize my thoughts on this in the next couple of days and send outsomething on this topic.-- Scott*start*02503 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 MAR 87 16:51:34 PSTDate: 01 Mar 87 16:49 PSTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE To: cl-cleanup@SAIL.STANFORD.EDU Scott wonders why the types FUNCTION and LIST ought to be disjoint.First, they are different things. We don't ask why NUMBER and LIST shouldbe disjoint - though one could argue that a unary representation ofnumbers is good enough. There are a number of CL constructs intended tobuild functions; CONS, LIST, and backquote are not among them.  It seemsreasonable that exactly the range of those constructs in a given Lisp at agiven time should be precisely the things of type FUNCTION.Second, there is a confusion between functions and expressions. An expressionis a piece of list structure (as represented in a running Lisp) that representsa means of obtaining a value or values. EVAL accepts this representation andproduces that value or those values. An expression is not a function.CONS, LIST, and backquote can build expressions, which can then be handed toEVAL, whose purpose is to interpret expressions as programs.Third, a programmer should expect that the Common Lisp types be well-definedand well-founded. Confusing lists and functions does not serve that purpose.Again, image the horror if LIST and NUMBER were not required to be disjoint andthat some lists were numbers.Fourth, even if one requires that a function represented as a list whoseCAR hold some implementation-dependent unique object, a user can constructsuch a list himself, which list is not a function. If FUNCTION and LIST aredisjoint, the user can be sure that the thing that FUNCTIONP says is a functionis the product of one of the CL constructs for producing functions, and ifapplying the function results in an error, the bug is known to be in a placewhere it is intended that functions are being produced and not in someplace where CONS, CAR, LIST, and backquote are operating on bad data.Fifth, if you're interested in interpreter efficiency, you should advocatesome partial compilation technique rather than advocating eliminatinga structure reference (in place of a list structure reference).Sixth, in balancing the scales between providing a meaningful functiontype to the user and allowing implementors to use a cheap implementationstrategy, I think we are now in a position to regard as foolish the latter.				-rpg-*start*01447 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 18 FEB 87 10:22:01 PSTDate: 18 Feb 87 10:04 PSTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: Function Proposal  To: masinter.pa Larry, I was just in Portland talking to Will Clinger, and we'dlike to propose the following cleanup to the function problem.Actually, we'd like to have all three of us (you, Will, and me)sponsor it.The changes to ClTl are:On page 32, flush the middle three paragraphs in section 2.13. That is,eliminate the sentences:	``A compiled-function...'''	``A lambda expression...''	``A symbol...''On page 33, section 2.15, change the sentence that starts	``the types cons, symbol, array ...''to include the word ``function.'' This makes function pairwise disjointwith the other things in that sentence.On page 76, change the definition of FUNCTIONP to state that ``FUNCTIONPis true if its argument is a function (see page 32).''On page 107, under the description of APPLY, the second sentence shouldstate ``FUNCTION must be a function (see page 32).''Examples 1 and 4 under APPLY must be fixed as well. There are possiblyother broken examples.This change requires the special form FUNCTION to return somethingtype-different from other things, in particular, different from alist. We could also specify that (lambda ...) return a functionbut that isn't necessary.		-rpg-*start*01158 00024 US Date:  5 Mar 87 17:35 PSTFrom: Masinter.paSubject: Re: FUNCTION-TYPE In-reply-to: Dick Gabriel <RPG@SAIL.STANFORD.EDU>'s message of 04 Mar 87 16:01 PSTTo: RPG@SAIL.STANFORD.EDUcc: masinterSorry to send these in piece-meal. I'd rather sound you out about them in private first rather than cl-cleanup, if you don't mind. If you have no opinion, I'll just broadcast to cl-cleanup instead.Interpreting for John Allen as a representative of the functional-programming school:leaving FUNCALL and APPLY alone, and say that they accept either a function or a symbol; if passed a symbol, they dereference the symbol by calling symbol-function first, is OK. On the other hand, #'cond  should be an error. There is no function "COND", there is a macro.  symbol-function should be an error on macros, special-forms, and only return a function if there is a function definition.These positions are semantically clean, compatible with current implementations and involve the lowest cost of conversion for current Common Lisp applications. No program could portably rely on symbol-function returning a meaningful value for macros.*start*00984 00024 US Return-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 09 MAR 87 18:40:38 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Mon 9 Mar 87 21:39:02-ESTDate: Mon, 9 Mar 87 21:38 ESTMessage-ID: <FAHLMAN.12285145354.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Cc: masinter.paSubject: Scott's Remarks and Other Important Matters In-reply-to: Msg of 9 Mar 1987  14:19-EST from Dick Gabriel <RPG at SAIL.STANFORD.EDU>Dick,Since Larry wants to start at 2pm, perhaps we should meet in the hotellobby at 1:45 on Sunday?If that's inconvenient for you, I can get to PARC on my own.  I'll havea rental car.  I've had some trouble finding PARC in the past -- theykeep adding new, similar-looking streets and buildings back in among theidentical brown hills -- but I' sure I'll find it eventually.  I couldeven bring a couple of the others.-- Scott*start*01727 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 09 MAR 87 20:28:39 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 9 Mar 87  20:25:20 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Mon 9 Mar 87 23:25:29-ESTDate: Mon, 9 Mar 87 23:25 ESTMessage-ID: <FAHLMAN.12285164736.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUCc: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject: Scott's Remarks on FUNCTION Type  JAR pointed out that my remark about ENSURE-FUNCTION eliminating theneed for the FUNCTION speical form was confused.I was thinking that ENSURE-FUNCTION would evaluate its argument and thendo whatever FUNCTION does on the result.  But since ENSURE-FUNCTIONreceives its argument at runtime, it has no access to the lexicalenvironment which FUNCTION needs in order to do its thing, so this wholeview is incoherent.  It is frightening to think that I still don't havethe hang of lexical thinking...ENSURE-FUNCTION could be defined as follows:    (ENSURE-FUNCTION <lambda-form>) = <closure of lambda-form IN THE                                       NULL LEXICAL ENVIRONMENT>    (ENSURE-FUNCTION <symbol>) = (SYMBOL-FUNCTION <symbol>)    (ENSURE-FUNCTION <function>) = <function>Then, if we say that FUNCALL and APPLY run their functional argumentthrough ENSURE-FUNCTION, I think we get something equivalent to thesemantics specified currently in CLtL.  But we do need to keep FUNCTIONaround so that lambdas can be closed in the current lexical environmentand so that we can get the lexically apparent definition of a symbol.-- Scott*start*03682 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 08 MAR 87 23:54:05 PSTDate: 08 Mar 87 23:51 PSTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: Scott's Remarks on FUNCTION Type  To: cl-cleanup@SAIL.STANFORD.EDU Scott has some good points. I include here some other clarifyingremarks. Once we agree on a rational proposal, I will write itup.Scott writes:``Some of RPG's reply strikes me as bogus.  He says that lists andfunctions are conceptually distinct, just as numbers and lists aredistinct.  In my own view, lists are perfectly good raw....''[This quote is not intended to imply that Scott enjoys lists the waysomeone might enjoy sushi: it was an accident of editing.]My point was that lists and functions must be disjoint, because itmakes no sense to take CAR of a function, whereas it might make senseto take CAR of an expression.  Because we cannot conceive of doing(CAR 99), we made LIST, CONS, and NUMBER disjoint. Similarly, (CAR #'(LAMBDA (X)(+ X X))) strikes me as nonsense.Scott writes:``It is analogous to the use of a vector to implement a named structurethat in turn implements a random seed or a window.''Alas, we cannot eliminate all puns from the language. I asked auser interface guy what it meant to take VREF of a window, and hegot confused. But we cannot expect all implementations to separateall types, so I agree with his point vis-a-vis the current Common Lispworld situation.Scott writes:``One could imagine (and Moon has proposed) adopting all the otherchanges, but saying that FUNCALL, APPLY and friends can take a function(new definition), a lambda list, or a symbol: in the latter two cases,FUNCTION is applied to the argument before it is used.''Another alternative would be to define a functional form of FUNCTION,called, for argument's sake, ENSURE-FUNCTION, such that(ENSURE-FUNCTION <lambda-form>) = <closure corresponding to lambda-form>(ENSURE-FUNCTION <symbol>) = (SYMBOL-FUNCTION <symbol>)(ENSURE-FUNCTION <function>) = <function>and then to define FUNCALL and APPLY to apply ENSURE-FUNCTION on itsfirst argument. It would be nice to see how the `purist' proposalwould fly before springing it on the world. I believe there isa lot of code that would break if we added the purist proposal.Scott writes:``I think that RPG's proposed new definition of the function type iscircular, or at least not very easy to understand: ....''I simply removed text from section 2.13. I believe the text I removeddidn't clarify this circular definition. I'm not sure how much moreprecisely we define function in CLtL except by providing a denotationalsemantics for Common Lisp. Or maybe some examples of turning lambda-expressionsinto functions would help.Scott writes:``It is a very bad idea to say that an advantage of the proposed change isthat "it is the first step towards a Lisp1-ification of Common Lisp". ''I agree it might be impolitic.Scott writes:``Do we want to propose that Lambda is a special form (or specialoperator), and that when you execute a lambda expression it returns theclosure, just as (FUNCTION (LAMBDA ...)) does now?''I would agree with this.Scott writes:``Probably we should explicitly name COMPILED-FUNCTION andINTERPRETED-FUNCTION as subtypes of FUNCTION, and make TYPEP work forthem.''Possibly these should not be required to be pairwise disjoint (?).I think we shouldn't presume that all implementations implement functions as closures. I can imagine an implementation withCOMPILED-FUNCTIONs, INTERPRETED-FUNCTIONs, COMPILED-CLOSUREs,and INTERPRETED-CLOSUREs.			-rpg-*start*03596 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 09 MAR 87 08:07:46 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 9 Mar 87  08:01:49 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Mon 9 Mar 87 10:57:49-ESTDate: Mon, 9 Mar 87 10:57 ESTMessage-ID: <FAHLMAN.12285028625.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Scott's Remarks on FUNCTION Type  In-reply-to: Msg of 9 Mar 1987  02:51-EST from Dick Gabriel <RPG at SAIL.STANFORD.EDU>    My point was that lists and functions must be disjoint, because it    makes no sense to take CAR of a function, whereas it might make sense    to take CAR of an expression.  Because we cannot conceive of doing    (CAR 99), we made LIST, CONS, and NUMBER disjoint. Similarly,     (CAR #'(LAMBDA (X)(+ X X))) strikes me as nonsense.Well, I don't derive "must be disjoint" from this argument.  I wouldagree with "can be disjoint" and maybe "should be disjoint, sincenon-disjointness buys the users nothing and is likely to confuse them".Since I agree with the split on other grounds, I mention this onlybecause I think this this argument will strike some people as a weakone, so we should not rely too heavily on its persuasive power in thecoming debate.    Another alternative would be to define a functional form of FUNCTION,    called, for argument's sake, ENSURE-FUNCTION, such that    (ENSURE-FUNCTION <lambda-form>) = <closure corresponding to lambda-form>    (ENSURE-FUNCTION <symbol>) = (SYMBOL-FUNCTION <symbol>)    (ENSURE-FUNCTION <function>) = <function>    and then to define FUNCALL and APPLY to apply ENSURE-FUNCTION on its    first argument.Yeah, this might be the right move.  The FUNCTION special form nowbecomes pretty useless, but we have to keep it for compatibility.On the issue of how we define the function type, I'm not arguing that weneed a denotational semantics.  I just think that we ought to spell outthe various types of functions and where they come from (compilation,closing a lambda expression, etc.) rather than relying on some formulalike "executed as code".  Not a big deal, but the less we leave to theuser's imagination, the smaller the chances that we'll be doing thisagain a year from now.    Scott writes:    ``Probably we should explicitly name COMPILED-FUNCTION and    INTERPRETED-FUNCTION as subtypes of FUNCTION, and make TYPEP work for    them.''    Possibly these should not be required to be pairwise disjoint (?).Well, these make sense only in systems that do support both compiled andinterpreted code.  In compiler-only or interpreter-only systems, I guessthe best move would be to say that every function is a member of both ofthese subtypes: it is both a fast function and a slow function.    I think we shouldn't presume that all implementations implement     functions as closures. I can imagine an implementation with    COMPILED-FUNCTIONs, INTERPRETED-FUNCTIONs, COMPILED-CLOSUREs,    and INTERPRETED-CLOSUREs.Now you're the one who is letting the user see internal stuff that isnone of his concern.  All of these functions are closures, in that theyno longer have any free variables waiting to be closed.  In some cases,there may have been none in the first place, and implementors may wantto use some efficient internal form in such cases, but is there anyreason the user needs to know that?  A confusing concept that does himno good (I think).-- Scott*start*02231 00024 US Return-Path: <@SAIL.STANFORD.EDU:JAR@AI.AI.MIT.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 MAR 87 14:54:39 PSTReceived: from AI.AI.MIT.EDU by SAIL.STANFORD.EDU with TCP; 13 Mar 87  14:51:39 PSTDate: Fri, 13 Mar 87 17:55:05 ESTFrom: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Subject:  #'cond, etc.  To: Fahlman@C.CS.CMU.EDUcc: cl-cleanup@SAIL.STANFORD.EDUIn-reply-to: Msg of Thu 12 Mar 1987  23:10 EST from Scott E. Fahlman <Fahlman at C.CS.CMU.EDU>Message-ID: <168036.870313.JAR@AI.AI.MIT.EDU>I agree that SYMBOL-FUNCTION and SYMBOL-VALUE ought to work more or lesssymmetrically.  However, I see no reason for these *functions* to beconsistent (with respect to the "signals" vs. "is" question) with the*primitive expression types* variable reference and function reference.These two pairs of features operate at very different levels.So how about this:	SYMBOL-VALUE, SYMBOL-FUNCTION --	   These signal an error if the variable or function is unbound.	   (If a symbol names a macro or special form that counts as being	   "unbound" w.r.t. the function binding.)	variable reference, #'<name> --	   It is an error to evaluate these if the variable or function	   is unbound.There's a world of difference between "is an error" and "signals anerror".  I don't know why you mention random compiler switches in thiscontext, because compiler switches mustn't affect the semantics ofprograms, but should only affect the way the system treats incorrectprograms.  "Signals an error" doesn't imply incorrect!  Quite theopposite; when something signals an error, it isn't in error, becausethe result is perfectly well defined:  a condition is raised, and somepiece of user code may elect to exploit this constraint.The phrase "to signal an error," which sounds a lot like "to be anerror," is so misleading as to warrant replacement by a more appropriatephrase.  We'll be in much better shape if we can rely on an errorproposal, since then we can always say "signals the FOO condition" forsome FOO, and need never use the term "error" for this kind of thing.But maybe for now we could start saying "a condition is signalled" or "aserious condition is signalled".Jonathan*start*02687 00024 USaReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 MAR 87 17:30:39 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 13 Mar 87  17:28:07 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Fri 13 Mar 87 20:28:24-ESTDate: Fri, 13 Mar 87 20:28 ESTMessage-ID: <FAHLMAN.12286181070.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Jonathan A Rees <JAR@AI.AI.MIT.EDU>Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: #'cond, etc.  In-reply-to: Msg of 13 Mar 1987  17:55-EST from Jonathan A Rees <JAR at AI.AI.MIT.EDU>    So how about this:    	SYMBOL-VALUE, SYMBOL-FUNCTION --    	   These signal an error if the variable or function is unbound.    	   (If a symbol names a macro or special form that counts as being    	   "unbound" w.r.t. the function binding.)    	variable reference, #'<name> --    	   It is an error to evaluate these if the variable or function    	   is unbound.OK, whatever.  If some implementation fails to signal these latter twoerrors when I've asked the compiler for safety, I'll complain toConsumer Reports and not to the Common Lisp Validation Squad.    There's a world of difference between "is an error" and "signals an    error".  I don't know why you mention random compiler switches in this    context, because compiler switches mustn't affect the semantics of    programs, but should only affect the way the system treats incorrect    programs.  "Signals an error" doesn't imply incorrect!  Quite the    opposite; when something signals an error, it isn't in error, because    the result is perfectly well defined:  a condition is raised, and some    piece of user code may elect to exploit this constraint.I disagree with this.  Compiler switches mustn't affect the semantics ofcorrect programs, and "correct" in this context means (or should mean)that the program neither does anything that "is an error" nor "signalsan error".  "Signals" an error means "is an error" AND "signals somecondition".  That's why they are called errors.  If you take the word"error" to mean "a perfectly legitimate way to invoke your favoritehandler", we will just have to make up some other word ("flaming bloodydisaster"?) for things that you can't legitimately put in portable code,but that are guaranteed not to slip by undetected if you do.I may not be able to get people to agree that certain errors should besignalled if I ask for safety, though they may not be caught if I askfor speed.  But I don't think we ought to adopt terminology that wouldmake it impossible even to propose this.-- Scott*start*00741 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 MAR 87 18:26:26 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 13 Mar 87  18:24:27 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 13 MAR 87 18:04:18 PSTDate: 13 Mar 87 17:47 PSTFrom: Masinter.paSubject: Re: #'cond, etc.  In-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Fri, 13 Mar 87 20:28 ESTTo: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <870313-180418-1011@Xerox>Scott, can you give an example of something you think fits the categoryof "things that you can't legitimately put in portable code, but thatare guaranteed not to slip by undetected if you do."?*start*02859 00024 US Return-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 13 MAR 87 19:39:30 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Fri 13 Mar 87 22:39:12-ESTDate: Fri, 13 Mar 87 22:39 ESTMessage-ID: <FAHLMAN.12286204887.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDUSubject: #'cond, etc.  In-reply-to: Msg of 13 Mar 1987  20:47-EST from Masinter.pa at Xerox.COM    Scott, can you give an example of something you think fits the category    of "things that you can't legitimately put in portable code, but that    are guaranteed not to slip by undetected if you do."?I claim that anything that lands you in the debugger when given correctarguments (according to the program's spec) is not a correct portableCommon Lisp program, even if it lands you in the debugger in the sameway across all legal Common Lisp implementations.  So if a program isgiven legal inputs (according to its spec) and then calls SYMBOL-VALUEof an unbound symbol, I would claim that this program is not "correct".Assuming something like the KMP error system, I would go along withusing the term "correct" for a program that does something guaranteed tosignal an error, *IF* that program also provides a handler for the errorin question, so that you don't end up in the debugger.  If a programdoes something that "is an error", it can never be correct in this sense-- what happens is completely unpredictable from one implemenation toanother.  Of course, there are currently very few situations that"signal an error", because for many errors it was felt that, under somecircumstances, the user would prefer maximum speed on stock hardware toguaranteed signalling.However, if we adopt this definition of "correct", I think we shoulddrop the assertion that optimize declarations cannot affect programcorrectness.What I was arguing for last summer was that we allow safety declarationsto turn certain "is an error" cases into "signals an error" cases.  Thiswould make it possible to turn some programs that can never be correctunder the current rules into programs that are correct if you providethe right OPTIMIZE declarations and if you handle the resulting errorswithin the program.  Of course, the reverse is also true: adding an(OPTIMIZE (SPEED 3)) declaration can turn an otherwise correct programinto one that is incorrect because the error isn't signalled in someimplementations.If we reject that view on the grounds that optimize declarations shouldnever affect program correctness (even in a positive way), then allthese cases must remain "is an error".  This solves the problem bymaking sure that none of these programs can ever be considered correct.That doesn't seem terribly useful to me.-- Scott*start*02854 00024 US Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 MAR 87 21:23:55 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 13 Mar 87  21:21:35 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 93275; Sat 14-Mar-87 00:20:47 ESTDate: Sat, 14 Mar 87 00:20 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: #'cond, etc.  To: Fahlman@C.CS.CMU.EDUcc: JAR@AI.AI.MIT.EDU, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12286181070.BABYL@C.CS.CMU.EDU>Message-ID: <870314002037.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Fri, 13 Mar 1987  20:28 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    ... I disagree with this.  Compiler switches mustn't affect the semantics of    correct programs, and "correct" in this context means (or should mean)    that the program neither does anything that "is an error" nor "signals    an error".  "Signals" an error means "is an error" AND "signals some    condition".  That's why they are called errors.  If you take the word    "error" to mean "a perfectly legitimate way to invoke your favorite    handler", we will just have to make up some other word ("flaming bloody    disaster"?) for things that you can't legitimately put in portable code,    but that are guaranteed not to slip by undetected if you do.    I may not be able to get people to agree that certain errors should be    signalled if I ask for safety, though they may not be caught if I ask    for speed.  But I don't think we ought to adopt terminology that would    make it impossible even to propose this.I want to voice strong support for the point of view Jonathan is expressinghere. ``Signalling an error'' does not make a program undefined unless theprogram fails to handle the error. Currently there is no way to distinguishthese since you can't handle errors, but in my new condition system, therewill be. ``Is an error'' does make a program undefined since it doesn't saywhat action will be taken.This is a very tricky topic to talk about. New terminology is necessaryand that means the imposition of arbitrary additional semantics on seeminglynormal words. My Exceptional Situations paper (X3J13/86-011) develops thetopic very carefully, distinguishing between exceptional situations (which span both ``is an error'' and ``signals an error'') and conditions (whichrefers only to detected errors). I would appreciate it if you (and the others)could take the time to (re)read at least the first 4 pages -- up to andincluding section IV -- if not the entire document. I think that itestablishes some useful terminology which if we all shared would make someof this discussion easier on Sunday.*start*04706 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 17 APR 87 15:28:10 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 17 Apr 87  15:25:17 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 17 APR 87 15:26:18 PDTDate: 17 Apr 87 15:31 PDTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE (version 2)To: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <870417-152618-2924@Xerox>Status:  General agreement on basic proposal.	Wording to be worked out.	Fahlman volunteer to revise & run by RPG firstIssue:     FUNCTION-TYPEReferences:   functions (pg 32), types (pg 33), FUNCTIONP (pg 76),	      APPLY (pg 107).Category:     CHANGE/CLARIFICATIONEdit History: Version 1 by RPG 02/26/87			Version 2 by cleanup committee 15-Mar-87 15:37:21Problem Description:The definition of the term `function' in CLtL includes all symbols andmany lists in addition to true functions. The type named `FUNCTION' is,therefore, not a reasonable type. The language would be much cleaned upand improved if functions were treated as a type in a consistent anduseful manner. Most of the reason for the current state of affairs isthe desire for compatibility with the past.Proposal:1. Currently the FUNCTION type specifier can only be used fordeclaration and not for discrimination. This proposal makes FUNCTION afull-fledged type. Symbols, whether or not fboundp, and lambdaexpressions do not qualify as functions. Specifically the types CONS,SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION are pairwise disjoint.Under this proposal, a lambda expression is not of type FUNCTION. A listmay not be used to implement any FUNCTION subtype.Implementations may add sub-types of FUNCTION, for example,COMPILED-FUNCTION, INTERPRETED-FUNCTION, COMPILED-CLOSURE etc.2. This proposal changes the behavior of the FUNCTIONP function suchthat it is equivalent to #'(LAMBDA (X) (TYPEP X 'FUNCTION)). Inparticular, lists whose cars are LAMBDA, and symbols are no longerFUNCTIONP.3. The descriptions of FUNCALL, APPLY, MAPCAR and all functions in CLtLwhich take functional arguments are modified to clarify that they willtake either functions, symbols, or lists that representlambda-expressions; if given non-functions, they coerce their functionalargument to a function first. Their behavior is not changed.  4. It is an error to use the special form FUNCTION around symbols thatdenote macros or special forms. (Some implementations may not signalthis error for performance reasons.) In all non-error situations, theresult of evaluating a FUNCTION special form is required to be of typeFUNCTION.  5. It is an error to invoke SYMBOL-FUNCTION on Page 76, the description of FUNCTIONP should be amended to read:``FUNCTIONP is true if its argument is a function (see page 32).''Page 107, the second sentence should be amended to read:``*Function* must be a function (see page 32).''Page 107, the first and fourth examples should be amended to read:(setq f #'+) (apply f '(1 2)) => 3(apply #'cons '((+ 2 3) 4)) =>       ((+ 2 3) . 4)  *not* (5 . 4)Other examples might require amendment.Rationale:I believe that this change takes a currently meaningless concept inCommonLisp (a function) and gives it a firmer foundation. Many programmerscannot rely on FUNCTIONP filtering out true functions from mere symbols.Current Practice:Programmers write their own predicate for true FUNCTIONP.Adoption Cost:Compiled functions are true functions in almost all implementations,but,in some implementations, interpreted functions are represented as lists.This would need to be changed in the interpreter, FUNCALL, APPLY, andother places.Benefits:A concept would be resurrected:  currently the concept of a function inCommon Lisp is bankrupt.  Common Lisp would come in closer alignmentwithScheme. It is the first step towards a Lisp1-ification of Common Lisp.Conversion Cost:Unknown. Deep-rooted bugs could be uncovered.Aesthetics:Making the concept of a function well-defined will probably be perceivedas a simplification.Discussion:The committee felt a need for a new function which replaces the oldbehavior of FUNCTIONP, which tests whether the argument is a functionobject, a symbol which is FBOUNDP with a function object in itssymbol-function, or a list whose CAR is LAMBDA or some other validimplementation-specific s-expression representation of a function. What does COMPILE do? Can one COMPILE already compiled things.Does (SETF (SYMBOL-FUNCTION x) '(LAMBDA ...)) coerce the lambdaexpression?Is it an error?SYMBOL-FUNCTION of a special form "is an error".*start*07532 00024 USfReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 11 MAY 87 12:59:28 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 11 May 87  12:56:41 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Mon 11 May 87 15:55:55-EDTDate: Mon, 11 May 87 15:55 EDTMessage-ID: <FAHLMAN.12301587043.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-TYPE (version 3)Status:		Revised by SEF to reflect intensive discussions prior to the		last X3J13 meeting.Issue:		FUNCTION-TYPEReferences:   	functions (pg 32), types (pg 33), FUNCTIONP (pg 76),	      	APPLY (pg 107).Category:     	CHANGE/CLARIFICATIONEdit History: 	Version 1 by RPG 02/26/87		Version 2 by cleanup committee 15-Mar-87		Version 3 by SEF 10-May-83Problem Description:The definition of the term `function' in CLtL includes all symbols andmany lists in addition to true functions.  The type named `function' istherefore not a useful type, and its presence complicates the typehierarchy. The language would be improved if functions were treated as atype in a consistent and useful manner.  This would also make it easierto integrate the function data type into the CLOS class hierarchy.The current confused situation came about mostly because of a desire inthe original Common Lisp definition to retain compatibility with olderLisp dialects, but in the context of Common Lisp some of these ancientdesign decisions are inappropriate.Proposal FUNCTION-TYPE:REDEFINE1. Under this proposal FUNCTION is a full-fledged data type that can beused both for declaration and discrimination.  The list form of theFUNCTION type specifier may still be used only for declaration.Symbols (whether or not the symbol is FBOUNDP) and lambda expressionsare not of type FUNCTION under this proposal.The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION arepairwise disjoint.  In particular, a list may not be used to implementany FUNCTION subtype.No sub-types of FUNCTION are defined in Common Lisp, but implementationsare free to define subtypes of FUNCTION.  Examples might beCOMPILED-FUNCTION, INTERPRETED-FUNCTION, COMPILED-CLOSURE, and so on.2. The behvior of FUNCTIONP is defined to be exactly equivalent to#'(LAMBDA (X) (TYPEP X 'FUNCTION)).  In particular, FUNCTIONP is nolonger true of symbols and lambda lists.3. The descriptions of FUNCALL, APPLY, MAPCAR and all functions inCommon Lisp which take functional arguments are modified to clarify thatthey will take either functions, symbols, or lists that representlambda-expressions.  A symbol or lambda expression is coerced to afunction using the null lexical environment, and the resulting functionis used.  Note that this leaves the behavior of FUNCALL, APPLY, MAPCAR,et al. unchanged, but that their descriptions must be changed toaccommodate the new definition of the FUNCTION type.4. In all non-error situations, the result of evaluating a FUNCTIONspecial form is required to be of type FUNCTION.  It is an error to usethe special form FUNCTION on a symbol that does not denote a function inthe lexical environment in which the special form appears.Specifically, it is an error to use the FUNCTION special form on asymbol that denotes a macro or special form.  (Some implementations maychoose not to signal this error for performance reasons.)5. If SYMBOL-FUNCTION is called on a symbol that names a function in thenull lexical context, it returns that function (which, of course, is oftype FUNCTION).  It is an error to call SYMBOL-FUNCTION on anythingelse.  In particular, it is an error to call SYMBOL-FUNCTION on a symbolthat names a macro or special form in the null lexical context; it isunpredictable what will be returned in this case.It is an error to pass anything other than a (true) function as thevalue to (SETF (SYMBOL-FUNCTION symbol) value).  Some implementationswill signal an error in this case; others may accept the bogus objectand fail only when the supposed function is called.6. The description of COMPILE must be changed, since it is no longermeaningful to speak of a symbol with a definition that "is alambda-expression".  Change this to the following:If COMPILE is called with no definition supplied, then it will attemptto compile the current global definition of the symbol <name>, and willsignal an error if it is unable to do so.  In some implementations, aninterpeted function can be compiled individually only if it contains noreferences to lexical context outside the function definition.  If thesymbol's definition is already compiled, no error is signalled.  Animplemenation may choose to recompile the function if the originalinterpreted form is available; otherwise, this is a no-op.Rationale:This change gives a clean, useful definition to the FUNCTION data type inCommon Lisp and the related type predicates.  Under the currentdefinition, FUNCTIONP is nearly useless, since it is defined to be trueof all symbols, including those that do not have functional definitions.Current Practice:Many programmers find it necessary to write their own predicatecorresponding to the new form of FUNCTIONP.Adoption Cost:The type predicates would of course have to be brought into compliancewith this proposal, but that should require little effort.Compiled functions are true functions in almost all implementations,but, in some implementations, interpreted functions and closures arerepresented as lists.  This would have to be changed in the interpreter,FUNCALL, APPLY, and other places.Benefits:By resurrecting FUNCTION as a useful concept, this proposed change willeliminate a lot of confusion and will make it easier to talk aboutsituations in which (true) functions are passed around as Lisp objects.By eliminating some tangles in the type hierarchy, this proposalsimplifies the task of mapping Common Lisp types into CLOS classes.  Italso brings Common Lisp into closer alignment with Scheme and otherLisp-1 dialects.Conversion Cost:This proposal attempts to minimize the impact on user code by allowingAPPLY, FUNCALL, and related functions to accept symbols and lambdalists, as they currently do.  The only impact on user-level code shouldbe a change in the operation of certain type predicates, and such casesshould be relatively easy to find and fix.Aesthetics:Making the concept of a function well-defined will probably be perceivedas a simplification.It would be cleaner to require all functional arguments to be truefunctions, eliminating the use of symbols and lambda-lists in thiscontext.  However, in this case we felt that the simplification was notworth a major incompatible change.Discussion:The original form of this proposal suggested that APPLY and friendsshould take only true functions as the functional argument.  Thecurrent proposal was agreed to after a discussion of the conversionproblems that such an incompatible change might entail.Some committee members have argued for an APPLICABLE-P predicate thatwould be true of all objects that can be passed as the functionalargument to APPLY and friends: true functions, lambda lists, and symbolsthat are FBOUNDP.  I (sef) believe that this is not terribly useful andcan easily be defined by any user who wants it (or something similar).In any event, this can be handled in a separate proposal.*start*03856 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 11 MAY 87 14:21:56 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 11 May 87  14:20:33 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 137159; Mon 11-May-87 17:18:50 EDTDate: Mon, 11 May 87 17:18 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE (version 3)To: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12301587043.BABYL@C.CS.CMU.EDU>Message-ID: <870511171840.4.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 11 May 1987  15:55 EDT    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    Edit History:   Version 1 by RPG 02/26/87		    Version 2 by cleanup committee 15-Mar-87		    Version 3 by SEF 10-May-83I (apparently somewhat belatedly!) approve of FUNCTION-TYPE:REDEFINEexcept with the following two caveats:    No sub-types of FUNCTION are defined in Common Lisp, but implementations    are free to define subtypes of FUNCTION.  Examples might be    COMPILED-FUNCTION, INTERPRETED-FUNCTION, COMPILED-CLOSURE, and so on.Common Lisp currently defines a type-specifier named COMPILED-FUNCTION.Is this a proposal to remove it?  I would probably support such a proposal,but it should be explicit.    If COMPILE is called with no definition supplied, then it will attempt    to compile the current global definition of the symbol <name>, and will    signal an error if it is unable to do so.  In some implementations, an    interpeted function can be compiled individually only if it contains no    references to lexical context outside the function definition.  If the    symbol's definition is already compiled, no error is signalled.  An    implemenation may choose to recompile the function if the original    interpreted form is available; otherwise, this is a no-op.The phrase "signal an error if it is unable to do so" is new.  Myproblem is that the concept of "unable to compile" is not defined and isopen to varying interpretations.  For example, does this mean that ifany compiler warnings are issued, COMPILE should signal an error at theconclusion of the compilation?  Also, if we assume that the word"should" used on CLtL p.439 is covered by the discussion of "must" onCLtL p.6, then right now this "is an error" rather than "signals anerror."  Also, the specification that COMPILE is a no-op if called withone argument and the symbol's definition is already compiled appears tobe a change from CLtL, although CLtL is so ambiguous it's hard to besure.Unless there are reasons that these changes to COMPILE must beincorporated into this proposal, I think it would be better to deal withthem as a separate proposal.  For this proposal, I suggest confining thediscussion to how COMPILE defaults its second argument.  I would saythat if the second argument is not supplied, the first argument "should"be a symbol that is FBOUNDP and for which the implementation is able toreconstruct the lambda-expression corresponding to its definition.  Sothe only change from CLtL would be to change "a definition that is alambda-expression" to "a definition from which the implementation isable to reconstruct a lambda-expression".  Possibly we should try to statesome necessary conditions under which the implementation is required tobe able to recover the lambda-expression.  Possibly we shouldn't; thisonly points out the inherent uselessness of 1-argument COMPILE inportable programs.Alternatively, we could take the coward's way out and make botharguments to COMPILE be required, or, even better, make COMPILE takeonly one argument, which must be a lambda expression, and neither readnor write SYMBOL-FUNCTION.*start*00620 00024 US Return-Path: <@SAIL.STANFORD.EDU:gls@Think.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 MAY 87 14:30:36 PDTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 12 May 87  14:29:52 PDTReceived: from boethius by Think.COM via CHAOS; Tue, 12 May 87 17:31:34 EDTDate: Tue, 12 May 87 17:31 EDTFrom: Guy Steele <gls@Think.COM>Subject: Issue: FUNCTION-TYPE (version 3)To: Fahlman@c.cs.cmu.edu, cl-cleanup@sail.stanford.eduCc: gls@think.comIn-Reply-To: <FAHLMAN.12301587043.BABYL@C.CS.CMU.EDU>Message-Id: <870512173129.7.GLS@BOETHIUS.THINK.COM>I support FUNCTION-TYPE:REDEFINE.*start*04818 00024 US Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 MAY 87 00:13:57 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 13 May 87  00:12:36 PDTReceived: from TSUKUBA.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 138655; Wed 13-May-87 03:10:55 EDTDate: Wed, 13 May 87 03:10 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE (version 3)To: Fahlman@C.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <FAHLMAN.12301587043.BABYL@C.CS.CMU.EDU>Message-ID: <870513031041.0.KMP@TSUKUBA.SCRC.Symbolics.COM>While I'm sympathetic to this proposal in some form, I can't supportit as currently drafted.My main problem is that it tries to clarify too many things. The question ofwhat is a function is logically distinct from that of what may go in thefunction cell. I am very excited about clarifying the type issues, but verynervous about changing what can go in the function cell.Here are my notes on the proposal... * I'd like to see the word COMPILED-CLOSURE struck. It adds nothing to   the meaning and could provoke useless debate about what the difference   might be between a function and a closure; currently CL has no such   formal distinction. * It seems to me that we might as well go ahead and create types   INTERPRETED-FUNCTION and COMPILED-FUNCTION since the combination of   the FUNCTION type and the COMPILED-FUNCTION-P predicate already implements   this distinction. Perhaps eventually COMPILED-FUNCTION-P could be flushed. * "behavior" is spelled "behvior" in one place. * I never realized that FUNCTIONP and (TYPEP x 'FUNCTION) were not   synonymous. Please cite a page reference that suggests they are allowed   to differ. I could not find a definition of the FUNCTION type specifier   when I looked just now. * In item 3 of proposal, I'd say "the text of their description" to be   completely clear. To me, the descriptions are the abstract entities   which you've just noted don't need change. * Items 4 & 5 are a major incompatibility that I would like to see proposed   and discussed separately so as not to bog down the type issues which this   proposal should be about. Macsyma, for example, makes considerable use   of symbols and lambda expressions in the function cell. Making sure it   would be happy with this clause would be very non-trivial.   For now, I would leave this essentially as you left APPLY, pending a   separate proposal to change that; i.e., FUNCTION and SYMBOL-FUNCTION can   return things which are non-functions if those objects can be coerced to   functions. SETF of SYMBOL-FUNCTION can accept such a coercible object,   and the value later retrieved will be the given object (not a coerced   form of it), though obviously internally some encapsulation may want to   go on for stock hardware to make function calling fast. * At the in-person meeting at Xerox in March, I suggested that COMPILE   should not complain if it gets an already-compiled thing, and someone   pointed out that this could be bad because some users might be wanting   recompilation and others might want no action. I think we should consider   a better fix, like something that lets the user say explicitly what   action to take if the function is already compiled, but for now I would   leave this an error. * The adoption cost does not mention STEP, TRACE, and ED. I think it should. * The benefits section should flush the reference to Lisp1, since the only   criterion for being a Lisp-1 is that you have a unified namespace. In   fact, this is not properly related to that and mentioning Lisp1 may   provoke unnecessary worry. It is adequate to say it makes things more   like Scheme. * I believe the conversion cost is potentially much greater than you   have estimated unless you move items 4 & 5 to another proposal.   The ability to say (SETF #'FOO 'BAR) rather than (SETF #'FOO #'BAR) has   important consequences to do with the inheritance of new definitions of   BAR if it is later defined. I think that some people exploit this a lot   and it may not always be easy to detect.   The impact on home-grown steppers, trace and advise facilities, and other   functions which manipulate the contents of the function cell has also been   underplayed.Please don't let these comments get you down. It's clear that a lot of workhas gone into this and I'm hopeful that it will be resolved successfully.I just want to keep the decision process as unencumbered as possible andright now it's just too hard for me to reason clearly about the overallimpact of such a sweeping proposal. -kmp*start*07520 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 17 MAY 87 19:32:45 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 17 May 87  19:31:22 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 17 May 87 22:30:44-EDTDate: Sun, 17 May 87 22:30 EDTMessage-ID: <FAHLMAN.12303231779.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: CL-Cleanup@SAIL.STANFORD.EDUCc: fahlman@C.CS.CMU.EDUSubject: Issue: FUNCTION-TYPE (version 3)In-reply-to: Msg of 13 May 1987  03:10-EDT from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>In reply to: Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>.    My main problem is that it tries to clarify too many things. I agree with Moon that Compile can be split out of this proposal anddealt with separately.  However, I feel that the other issues reallyhave to be dealt with all at once.  The issue of what constitutes theFUNCTION type and whether function definitions have to be functions inwhatever sense we define are closely interconnected.  We'll ahve tosolve the latter issue sooner or later, so let's try to do it now.     * I'd like to see the word COMPILED-CLOSURE struck. It adds nothing to       the meaning and could provoke useless debate about what the difference       might be between a function and a closure; currently CL has no such       formal distinction.No problem with eliminating any mention of this.  It was just a "forinstance" anyway.     * It seems to me that we might as well go ahead and create types       INTERPRETED-FUNCTION and COMPILED-FUNCTION since the combination of       the FUNCTION type and the COMPILED-FUNCTION-P predicate already implements       this distinction. Perhaps eventually COMPILED-FUNCTION-P could be flushed.One possibility is not to define any of these and to eliminateCOMPILED-FUNCTION-P.  That's what I proposed in version 3.  The otherpossibility is to define COMPILED-FUNCTION and INTERPRETED-FUNCTION assubtypes of FUNCTION, but then we have to spell out what happens inimplementations that have only one internal representation or that havemore than two -- raw interpreted, transformed, and fully compiled, forexample.  Then there's the question of whether closures are, or can be,a separate subtype.  In some sense, all true functions are closures,since to get one you close a lambda expression in some lexicalenvironment.  However, we might want to reserve the word "closure" forfunctions that actually capture some part of the lexical context outsidethe function itself, and to create CLOSURE types based on this idea.In my view, we are better off avoiding this whole thing and leaving itto the individual implementations.     * In item 3 of proposal, I'd say "the text of their description" to be       completely clear. To me, the descriptions are the abstract entities       which you've just noted don't need change.I disagree with this use of "description", but there's no point inarguing epistemology here.  I'll change the wording.       Macsyma, for example, makes considerable use       of symbols and lambda expressions in the function cell. Making sure it       would be happy with this clause would be very non-trivial.I don't understand this.  If your code expects to put random symbols andlambda lists into function cells and to get them back later, unchanged,this is not portable Common Lisp.  At least, the manual is so vague inthis area that you'd better not count on anything of this sort beingportable.  PCL was storing symbols in symbol-function cells for awhile,but this broke lots of implementations and they finally gave up on this.       For now, I would leave this essentially as you left APPLY, pending a       separate proposal to change that; i.e., FUNCTION and SYMBOL-FUNCTION can       return things which are non-functions if those objects can be coerced to       functions. SETF of SYMBOL-FUNCTION can accept such a coercible object,       and the value later retrieved will be the given object (not a coerced       form of it), though obviously internally some encapsulation may want to       go on for stock hardware to make function calling fast.I know of several Common Lisps in which this is not the status quo.  Soeither way we clarify this, it is an incompatible change for someone.  Ihate to see us take a step backwards here, just to make Macsyma moreportable than it currently is.I agree that we should make a bit more of this issue in the "conversioncosts" section -- truth in advertising -- but I think that saying that afunction definition must be a function is an important part of therationalization we are trying to achieve.Would it make life any easier for Macsyma (and other programs with thissame problem, if any exist) if we were to add a function that extractsthe lambda expression from a function if the function is uncompiled andis not a closure (in the stronger sense mentioned above)?  In someimplementations this might be EQ or at least EQUAL to the originalLambda, but in others it might have been macro-expanded or altered insome way that preserves its essential behavior.  We could call thefunction EXTRACT-LAMBDA-EXPRESSION or something like that.     * At the in-person meeting at Xerox in March, I suggested that COMPILE       should not complain if it gets an already-compiled thing, and someone       pointed out that this could be bad because some users might be wanting       recompilation and others might want no action. I think we should consider       a better fix, like something that lets the user say explicitly what       action to take if the function is already compiled, but for now I would       leave this an error.How about if we just adopt your earlier proposal: if the function isalready compiled, COMPILE is a no-op that returns the NAME.     * The adoption cost does not mention STEP, TRACE, and ED. I think       it should.OK.     * The benefits section should flush the reference to Lisp1, since the only       criterion for being a Lisp-1 is that you have a unified namespace. In       fact, this is not properly related to that and mentioning Lisp1 may       provoke unnecessary worry. It is adequate to say it makes things more       like Scheme.OK.     * I believe the conversion cost is potentially much greater than you       have estimated unless you move items 4 & 5 to another proposal.       The ability to say (SETF #'FOO 'BAR) rather than (SETF #'FOO #'BAR) has       important consequences to do with the inheritance of new definitions of       BAR if it is later defined. I think that some people exploit this a lot       and it may not always be easy to detect.       The impact on home-grown steppers, trace and advise facilities, and other       functions which manipulate the contents of the function cell has also been       underplayed.Well, as I said, such code is currently not portable because nothing inthe book unambiguously requires that symbols and lambda expressions beput into the SYMBOL-FUNCTION cell unchanged (or that such changes beundone upon retrieval), and because many implementations currently donot do this.  So there's a cost either way we clarify this.  Doing itthe way you suggest tends to put the burden on implementors rather thanon the maintainers of old code, but I still think it is a stepbackwards.-- Scott*start*01494 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 17 MAY 87 19:44:41 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 17 May 87  19:42:52 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 17 May 87 22:42:14-EDTDate: Sun, 17 May 87 22:42 EDTMessage-ID: <FAHLMAN.12303233875.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: FUNCTION-TYPE and Archives   In-reply-to: Msg of 13 May 1987  12:14-EDT from Dick Gabriel <RPG at SAIL.STANFORD.EDU>In reply to: Dick Gabriel <RPG at SAIL.STANFORD.EDU>.    Second, about the FUNCTION-TYPE proposal: I support it, but mildly.    I favor a much stronger change, and this proposal is just barely above    the level of acceptability to me.I assume that the "stronger proposal" you favor would require FUNCALL,APPLY, and friends to accept only true functions.I would go along with putting both options into the proposal we send toX3J13 and let them vote on it.  My guess is that the conservatives wouldprevail, but I personally would favor the "stronger proposal".  (That'seasy for me, because I have relatively little code to maintain.)  Itmight be worth a try -- maybe truth and beauty would win.However, there's a chance that if we put forward two options, the wholething will bog down for a while.  I wonder if it is worth the risk ofadded delay.-- Scott*start*01668 00024 USmReturn-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 MAY 87 09:16:27 PDTDate: 13 May 87 09:14 PDTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE and Archives   To: cl-cleanup@SAIL.STANFORD.EDU First, the archives for CL-cleanup are in clclea.msg[com,lsp].However, this archive was separated out from the main Common-Lisparchive only recently.Second, about the FUNCTION-TYPE proposal: I support it, but mildly.I favor a much stronger change, and this proposal is just barely abovethe level of acceptability to me.KMP wonders`` I never realized that FUNCTIONP and (TYPEP x 'FUNCTION) were not   synonymous. Please cite a page reference that suggests they are allowed   to differ. I could not find a definition of the FUNCTION type specifier   when I looked just now.''The suggestion is on the same pages that allows the following two todiffer:	(let ((x '(or to-be (not to-be))))         (assert `(is-a question ,x)))	``To be or not to be: That is the question.''KMP's third sentence is the answer: FUNCTION is a type name symbolthat corresponds to no type, and therefore (typep x 'function) isnot defined. This is what this proposal attempts to remedy.However, to be slightly more serious, I am disturbed to always readthat Common Lisp must do this, that, or the other thing because otherwisethe effort to keep Macsyma up to date will suffer, or that the reason thatsome feature must continue to exist is because it is reflected in Macsyma usage. I like Macsyma as well as the next guy, but not enough tokill a language to keep its code legal.			-rpg-*start*02084 00024 US Return-Path: <@SAIL.STANFORD.EDU,@ALLEGHENY.SCRC.Symbolics.COM:File-Server@QUABBIN.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 MAY 87 11:34:40 PDTReceived: from [192.10.41.45] by SAIL.STANFORD.EDU with TCP; 13 May 87  11:33:01 PDTDate: Wed, 13 May 87 14:23 EDTFrom: KMP@QUABBIN.SCRC.Symbolics.COMSender: File-Server@QUABBIN.SCRC.Symbolics.COMSubject: FUNCTION-TYPE, archives, and MacsymaTo: RPG@SAIL.STANFORD.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <870513142303.6.FILE-SERVER@ALLEGHENY.SCRC.Symbolics.COM>I spent well over a year converting Macsyma to what I believe is a goodfaith reading of CLtL. At the outset, I was as tired as anyone of itsodd little needs that were unwritten parts of various languages and thathad to be supported only out of fear of breaking Macsyma.I am trying to invoke no such fear now. Indeed, I don't even work for theMacsyma project any more. I am sure that those who do work for it arewilling to do reasonable work to upgrade Macsyma into the next generationLisp.However, those people (whoever they may be when it finally happens; mygrandchildren, I fear) will need to be able to adequately estimae theimpact of the various changes which we have made. And we ourselves mustadequately estimate the impact so that we can know how much work we areasking people to absorb.I said several times in my message that I might be willing to go alongwith this change. I am not trying to "kill a language" as you put it.I just want us to be honest. And when I read the text in this proposalthat said "... attempts to minimize the impact on user code ... theonly impact should be a change in the operation of certain type predicates... relatively easy to find and fix" I knew we were not being honest.The changes we're proposing may be good ones. They will not all be easyto find and fix.I do think that the part which simply involves types is fairlynon-controversial. I would like to see it separated so we can agree thatit is and leave a smaller issue to worry about.*start*09260 00024 US Date: 29 May 87 21:18 PDTFrom: Masinter.paTo: cl-cleanup@SAIL.STANFORD.EDUCC: MasinterSubject: Issue: FUNCTION-TYPE (version 4)Status:        Ready to release? [Use ballot]Issue:          FUNCTION-TYPEReferences:     functions (pg 32), types (pg 33), FUNCTIONP (pg 76),                APPLY (pg 107).Category:     	CHANGE/CLARIFICATIONEdit History:   Version 1 by RPG 02/26/87                Version 2 by cleanup committee 15-Mar-87                Version 3 by SEF 10-May-87                Version 4 by Masinter 29-May-87 incorporate commentsProblem Description:The definition of the term `function' in CLtL includes all symbols andmany lists in addition to true functions.  The type named `function' istherefore not a useful type, and its presence complicates the typehierarchy. The language would be improved if functions were treated as atype in a consistent and useful manner.  This would also make it easierto integrate the function data type into the CLOS class hierarchy.Even though there is a predicate FUNCTIONP, it is not synonomous to the useof the type FUNCTION; the FUNCTION type cannot be used for discrimination.The current confused situation came about mostly because of a desire inthe original Common Lisp definition to retain compatibility with olderLisp dialects, but in the context of Common Lisp some of these ancientdesign decisions are inappropriate.Proposal FUNCTION-TYPE:REDEFINE1. Under this proposal FUNCTION is a full-fledged data type that can beused both for declaration and discrimination.  The list form of theFUNCTION type specifier may still be used only for declaration.Symbols (whether or not the symbol is FBOUNDP) and lambda expressionsare not of type FUNCTION under this proposal.The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION arepairwise disjoint.  In particular, a list may not be used to implementany FUNCTION subtype.No sub-types of FUNCTION are defined in Common Lisp, but implementationsare free to define subtypes of FUNCTION.  Examples might beCOMPILED-FUNCTION, INTERPRETED-FUNCTION, and so on. Note that thisis a change from the current Common Lisp definition which explicitlydefines a COMPILED-FUNCTION type. This proposal removes the predicateCOMPILED-FUNCTION-P from the standard language.2. The behavior of FUNCTIONP is defined to be exactly equivalent to#'(LAMBDA (X) (TYPEP X 'FUNCTION)).  In particular, FUNCTIONP is nolonger true of symbols and lambda lists.3. The text descriptions of FUNCALL, APPLY, MAPCAR and other functionsin Common Lisp which take functional arguments should be to clarify thatthey will take either functions, symbols, or lists that representlambda-expressions, where a symbol or lambda expression is coerced to afunction using the null lexical environment, and the resulting functionis used.  Note that this is not a change to the the behavior of Common Lisp; the descriptions must be changed to accommodate the new definitionof the FUNCTION type.4. In all non-error situations, the result of evaluating a FUNCTIONspecial form is required to be of type FUNCTION.  It is an error to usethe special form FUNCTION on a symbol that does not denote a function inthe lexical environment in which the special form appears.Specifically, it is an error to use the FUNCTION special form on asymbol that denotes a macro or special form.  (Some implementations maychoose not to signal this error for performance reasons.)5. If SYMBOL-FUNCTION is called on a symbol that names a function in thenull lexical context, it returns that function (which, of course, is oftype FUNCTION).  It is an error to call SYMBOL-FUNCTION on anythingelse.  In particular, it is an error to call SYMBOL-FUNCTION on a symbolthat names a macro or special form in the null lexical context; it isunpredictable what will be returned in this case.It is an error to pass anything other than a (true) function as thevalue to (SETF (SYMBOL-FUNCTION symbol) value).  Some implementationswill signal an error in this case; others may accept the bogus objectand fail only when the supposed function is called.6. The description of COMPILE is changed, since it is no longer meaningful to speak of a symbol with a definition that "is a lambda-expression". Where CLtL says "a definition that is a lambda-expression" the behavior of COMPILE should be described as "a definition from which the implementation is able to reconstruct a lambda-expression". Rationale:This change gives a clean, useful definition to the FUNCTION data type inCommon Lisp and the related type predicates.  Under the currentdefinition, FUNCTIONP is nearly useless, since it is defined to be trueof all symbols, including those that do not have functional definitions.Current Practice:The definition of FUNCTIONP varies widely between Common Lisp implementations. No current Common Lisp implementation has exactly the semantics described here, however.Adoption Cost:The type predicates would of course have to be brought into compliancewith this proposal, but that should require little effort.Compiled functions are true functions in almost all implementations,but, in some implementations, interpreted functions and closures arerepresented as lists.  Some implementations already always store specialtypes in function cells, but others, which currently store and return LAMBDA expressions in SYMBOL-FUNCTION, would be required to change thebehavior of (interpreted FUNCTION).Some implementations will have to modify the behavior of COMPILE, STEP, TRACE and (possibly) ED to deal with non-list values in symbol-function cells.Benefits:By resurrecting FUNCTION as a useful concept, this proposed change willeliminate a lot of confusion and will make it easier to talk aboutsituations in which (true) functions are passed around as Lisp objects.By eliminating some tangles in the type hierarchy, this proposalsimplifies the task of mapping Common Lisp types into CLOS classes.  Italso brings Common Lisp into closer alignment with Scheme.Conversion Cost:This proposal attempts to minimize the impact on user code by allowingAPPLY, FUNCALL, and related functions to accept symbols and lambdalists, as they currently do.  One impact on user-level code shouldbe a change in the operation of certain type predicates, and such casesshould be relatively easy to find and fix.User code which relies on the fact that in some environments, SYMBOL-FUNCTION returns a list in a well-known format for functions defined in the lexical global environment will have to change. Similarly, some implementations currently allow users to say (SETF #'FOO 'BAR) and then subsequently have a redefinition of BAR affect the behavior of FOO. This would no longer be allowed, and users of those implementations would have to change their code.  Others with home-grown steppers, trace and advise facilities which manipulated the contents of function cells might have additional work to do.User code which uses COMPILED-FUNCTION-P would no longer be valid or portable.Aesthetics:Making the concept of a function well-defined will probably be perceivedas a simplification.It would be cleaner to require all functional arguments to be truefunctions, eliminating the use of symbols and lambda-lists in thiscontext.  However, in this case we felt that the simplification was notworth a major incompatible change.Discussion:The original form of this proposal suggested that APPLY and friendsshould take only true functions as the functional argument.  Thecurrent proposal was written after a discussion of the conversionproblems that such an incompatible change might entail. Some cleanup committee members would prefer the stronger proposal.  Some committee members have argued for an APPLICABLE-P predicate thatwould be true of all objects that can be passed as the functionalargument to APPLY and friends: true functions, lambda lists, and symbolsthat are FBOUNDP.  Fahlman believes that this is not terribly useful andcan easily be defined by any user who wants it (or something similar).In any event, this can be handled in a separate proposal.Pitman believes that items 4 and 5 are major incopatibilities, and would prefer if FUNCTION and SYMBOL-FUNCTION be allowed to return things which are non-functions if those objects can be coerced to functions, and SETF of SYMBOL-FUNCTION can accept such a coercible object,    and the value later retrieved will be the given object (not a coerced form of it), though obviously internally some encapsulation may want to go on for stock hardware to make function calling fast.The cleanup committee believes that the definition of COMPILE needs clarification, but that it should be done in a separate proposal. The change to COMPILE in this proposal is the minimum necessary.        TITAN          TITAN           
TIMESROMAN 
                                       5                                                       <              8       (                                                      
                                R                   " z*start*01306 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 04 JUN 87 08:54:15 PDTDate: 04 Jun 87 08:52 PDTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE To: cl-cleanup@SAIL.STANFORD.EDU When Clinger and I proposed this cleanup, it was the maximally cleanversion, and that is the one I support. On the other hand, I believe thatthere is little reason to actually press for the maximally clean version.In some sense, all of us are trying to ``spread the word'' about Lisp,trying to get currently non-Lisp programmers to switch. We could do thisif there were some way for mainstream computing to be done in Lisp.With a language like Common Lisp this is not possible - it is too bigand it is growing. What we could have hoped to accomplish with thiscleanup is a first step towards establishing a continuum of Lisps fromScheme up through Common Lisp. Even if we were to adopt this change, theperiod until we had the continuum would be lengthy.I don't think we can win this game quickly given the time constraintsand the current state of Common Lisp. We continue to argue about thefiligrees.I believe that we ought to minimally clean up Common Lisp and rapidlymove on to the next great Lisp language design.			-rpg-*start*00741 00024 US Date:  1 Jun 87 16:46 PDTFrom: Gregor.paSubject: Re: Issue: FUNCTION-TYPE (version 4)In-reply-to: Masinter.pa's message of 29 May 87 21:18 PDTTo: Masinter.pacc: cl-cleanup@SAIL.STANFORD.EDUI don't like the current, 'concession to backward compatibility' which allows apply, mapcar etc. to accept things which are not functionp.  I bet the amount of code which would be affected by this change is small, and if we decide to make it now, vendors can make their systems warn about it for a while, so the transition should not be too painful.Face it, more code is going to be written than has already been written, lets look to the future, not the past.Now if only this argument could sway the Lisp-1 issue...*start*01331 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 JUN 87 17:16:19 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 1 Jun 87  17:14:59 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 161104; Mon 1-Jun-87 20:14:13 EDTDate: Mon, 1 Jun 87 20:14 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-TYPE (version 4)To: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <870601-164709-3170@Xerox>Message-ID: <870601201413.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 1 Jun 87 16:46 PDT    From: Gregor.pa@Xerox.COM    I don't like the current, 'concession to backward compatibility' which    allows apply, mapcar etc. to accept things which are not functionp.  I    bet the amount of code which would be affected by this change is small,    and if we decide to make it now, vendors can make their systems warn    about it for a while, so the transition should not be too painful.This kind of warning strategy isn't very effective for things that cannotbe detected at compile time.  A run time warning tends to be a big annoyanceand may not tell you just where in your program was responsible for theeffect.*start*00475 00024 US Date:  1 Jun 87 18:29 PDTFrom: Pavel.paSubject: Re: Issue: FUNCTION-TYPE (version 4)In-reply-to: Masinter.pa's message of 29 May 87 21:18 PDTTo: Masinter.pacc: cl-cleanup@SAIL.STANFORD.EDUTypo in the proposal:``it is not synonomous to the use of the type FUNCTION'' should be ``it is not synonomous with the use of the type FUNCTION''.        GACHA 
          
TIMESROMAN 
                  4              6             [ z*start*01504 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 01 JUN 87 21:23:10 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 1 Jun 87  21:21:48 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 161267; Tue 2-Jun-87 00:11:30 EDTDate: Tue, 2 Jun 87 00:11 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE (version 4)To: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <870529-211904-1265@Xerox>Message-ID: <870602001135.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 29 May 87 21:18 PDT    From: Masinter.pa@Xerox.COM    Even though there is a predicate FUNCTIONP, it is not synonomous to the    use of the type FUNCTION; the FUNCTION type cannot be used for    discrimination.I don't think that's true.  I believe CLtL p.47 is meant to say that alist type-specifier with FUNCTION in the car cannot be used fordiscrimination, while Table 4-1 combined with CLtL p.72 indicates thatthe symbol type-specifier FUNCTION can be used with TYPEP.  I wouldsimply remove this paragraph from the proposal.  Later in the proposalyou have an explicit statement that the symbol type-specifier FUNCTIONcan be used for discrimination.    This proposal removes the predicate    COMPILED-FUNCTION-P from the standard language.If it also removes the COMPILED-FUNCTION type-specifier, say so here.*start*00867 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 02 JUN 87 10:18:07 PDTDate: 02 Jun 87 10:16 PDTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: Issue: FUNCTION-TYPE (version 4)  To: cl-cleanup@SAIL.STANFORD.EDU Moon writes about Gregor's suggestion to warn on bad arguments to APPLY:``This kind of warning strategy isn't very effective for things that cannotbe detected at compile time.  A run time warning tends to be a big annoyanceand may not tell you just where in your program was responsible for theeffect.''This might be right, but I'd rather there be an annoyance during aperiod when old code is fixed than have years of bad news simply becauseof a sentimental attachment to MacLisp. Here's my proposal: Let the vendorsmake the change and let the users fix their code.			-rpg-*start*02992 00024 US Return-Path: <@SAIL.STANFORD.EDU:Gregor.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 02 JUN 87 11:49:25 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 2 Jun 87  11:48:06 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 JUN 87 11:32:42 PDTDate: 2 Jun 87 11:32 PDTFrom: Gregor.paSubject: Re: Issue: FUNCTION-TYPE (version 4)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 1 Jun 87 20:14 EDTTo: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <870602-113242-4179@Xerox>    Date: Mon, 1 Jun 87 20:14 EDT    From: David A. Moon    This kind of warning strategy isn't very effective for things    that cannot be detected at compile time.  A run time warning tends    to be a big annoyance and may not tell you just where in your    program was responsible for the effect.True, but I think many of the cases could in fact be detected at runtime.  Of course I have not done an extensive search, and there may wellbe large bodies of code for which this is not true.  Those large bodiesof code will require hand analysis and conversion.Here is another point which I think is relevant to this discussion.Define the Z of a lisp programmer to be their familiarity with thesubleties of Lisp programming.  This includes things like the history ofLisp, what dynamically scoped Lisps are like, what Lisp-1s are like etc.etc.  It seems to me that as time goes on, the average Z of lispprogrammers is going to go down.  In some sense, that is what it meansfor Lisp to become a successful language.  An effect of this, is that inmost cases, it is going to be much easier for the people who havewritten the existing code to deal with a change like the one I amsuggesting, than it will be for future programmers to deal with theconfusion caused by not making the change.  This is over and above thefact that there will be much more code 5 years from now (we all hope!).Take the example of Macsyma (or Spire or Kee or any other large 'oldtime but still in use' Lisp program).  What if this change breaks one ofthem?  We have to weigh that with the cost of propagating past confusionby making apply and friends do conversion.  But the people who maintainsystems like Macsyma and KEE are likely much higher Z programmers thanpeople who are writing new code.  It probably won't be real hard forthese old time people to make this change.  It is more likely that thenew lisp programmers will get confused and write bad code.  I supectpeople will write(squirrel-function-away-1 '(lambda (x) ..))(squirrel-function-away-2 #'(lambda (x) ..))(funcall (fetch-function-1) (some-data))(funcall (fetch-function-2) (some-data))Since both 'functions', when they are fetched and funcalled will work,people won't notice that the one isn't compiled.  When and if they donotice, it may take them a long time to understand why they are losingthis way.*start*02655 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 03 JUN 87 22:33:30 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 3 Jun 87  22:32:27 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Thu 4 Jun 87 01:31:53-EDTDate: Thu, 4 Jun 87 01:31 EDTMessage-ID: <FAHLMAN.12307721211.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-TYPE (version 4)In-reply-to: Msg of 30 May 1987  00:18-EDT from Masinter.pa at Xerox.COMThere seem to be three positions here:1. The "maximally clean" proposal, in which FUNCALL, APPLY, and thebuilt-in functions that take functional args would take only truefunctions and it would "be an error" to pass either of these a lambdaexpression or a symbol.2. The "maximally compatbile" proposal currently reflected byFUNCTION-TYPE:REDEFINE.3. The "maximally Macsyma" proposal, which is like 2 but would alsorequire that SYMBOL-FUNCTION take a symbol or lambda and return itunchanged.I actually favor option 1, though I think that we must be up-front aboutthe incompatibilities it introduces.  Several others seem to share thisview.It might be hard to get the majority of X3J13 to agree to option 1,however, since a lot of those people are more worried about preservingexisting code than about cleanliness and consistency.  If we want toresolve this issue in a hurry, pushing option 2 might be the way to go.Moon has been the most vocal advocate of option 2 within the cleanupcommittee.  Personally, I could live with this, though I prefer option1.So far, only KMP has argued in favor of option 3.  This does not reflectthe status quo in many implementations, and some of us view it as a stepbackwards.It would be great if we could reach some internal consensus on thisissue and present a recommendation from the whole cleanup committee.  Ifthis is impossible, we should write this up as a two-option orthree-option proposal and let X3J13 fight it out.  I don't think weshould sit on this indefinitely waiting for someone's mind to change orbreak it up into little pieces -- either move will just guarantee thatthis remains unresolved for the forseeable future.If people are comfortable with releasing the current version, I can goalong with that in priciple, but the presentation needs to be cleaned up.I will be happy to do some of the work of redrafting this proposal, butcan't do this without understanding where the committee members stand:what they favor, and what they would agree to.-- Scott*start*04315 00024 US Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 07 JUN 87 11:51:32 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 7 Jun 87  11:50:32 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 166143; Sun 7-Jun-87 14:50:04 EDTDate: Sun, 7 Jun 87 14:49 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: FUNCTION-TYPE To: RPG@SAIL.STANFORD.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: The message of 6 Jun 87 19:30 EDT from Dick Gabriel <RPG@SAIL.STANFORD.EDU>Message-ID: <870607144946.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 06 Jun 87  1630 PDT    From: Dick Gabriel <RPG@SAIL.STANFORD.EDU>    ... Changes that introduce or retain inconsistencies which confuse new    users and which complicate the rules of the language are preferable to    changes that cause old programs to stop working.    I think Common Lisp is so messed up that the cleanest change to    function types will not effect major improvements. Our position    with respect to EuLisp will be more difficult. ...I disagree with your claim that a change to the function types alone willnot make a major improvement in the language.We can define any function to do anything we want. That in itself doesnot make the language inconsistent. There is nothing inconsistent aboutdefining the functions FUNCALL and APPLY to take arguments which arecoercible to functions, especially if you also make it clear that youcan put things in function cells which are coercible to functions.This is no more unreasonable than allowing any function to coerce itsargument. Consider STRING-DOWNCASE of a symbol, for example.One of the great powers of types in a language is that you can tell whenyou have one that is not quite suitable and define an interpretation forit. If you require exactly one type as an argument to all functions, youalienate the whole notion of generic functions and take us into a worldthat more resembles CLU, where you need one function for every type.If all we did was fix the types and not fix the business about what can goin the cells or be given to APPLY or FUNCALL, we'd still have a lot.Consider that if the EuLisp guys don't like our definition of the functionsand want to run EuLisp compatibility in our lisp, they can effectively do: (IN-PACKAGE "EULISP" :USE "CL") (SHADOW '(APPLY FUNCALL)) ... (DEFUN APPLY (FUNCTION &REST SPREAD-ARGUMENTS)   (CL:APPLY (THE FUNCTION #'CL:APPLY)	     (THE FUNCTION FUNCTION) SPREAD-ARGUMENTS)) (DEFUN FUNCALL (FUNCTION &REST ARGUMENTS)   (CL:APPLY (THE FUNCTION FN) ARGUMENTS))And as for us, we can do the following to win in theirs: (IN-PACKAGE "COMMONLISP" :USE "EU") (SHADOW '(APPLY FUNCALL)) ... (PROCLAIM '(INLINE COERCE-TO-FUNCTION)) (DEFUN COERCE-TO-FUNCTION (FN)   (FLET ((FAIL () (ERROR "Not a function: ~S" FN)))     (TYPECASE FN       (FUNCTION FN)       (SYMBOL (SYMBOL-FUNCTION FN))       (LIST (IF (EQ (CAR LIST) 'LAMBDA)		 (EVAL ,LIST)		 (FAIL)))       (OTHERWISE (FAIL))))) (DEFUN APPLY (FN &REST SPREAD-ARGUMENTS)   (EU:APPLY #'EU:APPLY (COERCE-TO-FUNCTION FN) SPREAD-ARGUMENTS)) (DEFUN FUNCALL (FN &REST ARGUMENTS)   (EU:APPLY (COERCE-TO-FUNCTION FN) ARGUMENTS))Not much code for either side.The thing which makes this so easy going both directions is the agreementon making the FUNCTION type something that you can get leverage outof.The issue of how you deal with that type in any given function isinteresting, but need not (and I think should not) be intimately tiedup with this much more important issue that we probably can and shouldall agree upon.You might say that this is so little code that we should go the extralittle bit and just agree to make the mechanisms the same, but I don'tthink that would be wise. To go further for us would compromise largebodies of existing code and built-in philosophies about Lisp and whatit can do for them. To go further for the Eulisp guys might compromisetheir existing code and their philosophies. I think that either sidehas a defensible reason for maintaining their ground and that it isappropriate to agree not to agree on this issue.*start*01855 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 07 JUN 87 13:00:04 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 7 Jun 87  12:52:16 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 7 Jun 87 15:51:42-EDTDate: Sun, 7 Jun 87 15:51 EDTMessage-ID: <FAHLMAN.12308664162.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: FUNCTION-TYPE In-reply-to: Msg of 7 Jun 1987  14:49-EDT from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>I think the issues involved in FUNCTION-TYPE are now clearly drawn andwe may as well settle this whole package one way or the other, ratherthan separating the issue into parts, settling the type cleanup now, andletting the related questions hang in limbo for another six months.It's a bit frightening to me personally to propose this, since I won'tbe at the Boston meeting, but I'd rather have a clear decision in favorof ANY of the three proposals than to let this hang indefinitely.It is reasonable to let questions hang if we're waiting for some relatedissues to be resolved or if technical work needs to be done (as insolving the macro problem for Lisp-1) or if people really need time tostudy the implications of a proposed change.  I don't see any of thosefactors at work in the FUNCTION-TYPE issue -- it is a straightforwardquestion of whether we want to remove some ugly tangles from thelanguage at the expense of breaking some existing code.  This questionis not going to get any easier, and until it is decided we all have tocode defensively.Shall I attempt to write up FUNCTION-TYPE as a three-option proposalthat can be debated and voted on in Boston?-- Scott*start*01948 00024 US Return-Path: <@SAIL.STANFORD.EDU:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 07 JUN 87 13:19:20 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 7 Jun 87  13:18:22 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 166175; Sun 7-Jun-87 16:17:14 EDTDate: Sun, 7 Jun 87 16:17 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: FUNCTION-TYPETo: Fahlman@C.CS.CMU.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12308664162.BABYL@C.CS.CMU.EDU>Message-ID: <870607161700.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>I do not believe that all that can be usefully said about FUNCTION-TYPEhas been said. For example, I would like to discuss further this issueyou raised of providing a function to get the original s-expression froma coerced function (of clean-type FUNCTION). T has such a function.Its mere presence doesn't make everything ok, but it might contributeto some overall theory. Before making a proposal, I need to study theconsequences of having it a bit more -- and I have no time to do thatright in the next couple of weeks. The details of this issue couldaffect my view on the proposal currently on the table.For reasons such as this, I feel that it would be premature to bringFUNCTION-TYPE to the table at this meeting. I'd rather see this broughtto X3J13 only when we were sure we had things carefully thought out, topreclude wasting valuable time in in-person meetings due to inadequatepreparation. The fact that Steele (and you?) will not be at the Bostonmeeting is another good reason to wait.Let's just keep this one on hold for two more months. I don't see howthat much time can hurt a lot, and I do see how it can help. It's notlike we don't have enough else to keep us all busy in the interim.*start*01904 00024 US Return-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 07 JUN 87 13:49:19 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 7 Jun 87  13:48:13 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 7 Jun 87 16:47:37-EDTDate: Sun, 7 Jun 87 16:47 EDTMessage-ID: <FAHLMAN.12308674344.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: FUNCTION-TYPEIn-reply-to: Msg of 7 Jun 1987  16:17-EDT from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>Well, I'll leave it to the others to decide whether it is reasonable todelay the whole decision process for several months because you haven'tyet decided what your position is.  If several people on the committeeare uneasy about this FUNCTION-TYPE issue because of the points you haveraised (or because of other problems), we should probably wait anddiscuss it some more; if it's just you, I don't think you have a vetoeither over the proposal itself or over the decision that it's time tovote on it.  (You may, however, have a legitimate parliamentaryobjection if the proposal being voted on has not been on the table for asufficient time prior to a vote.)It's possible that this can be discussed in Boston and settled by aletter ballot shortly thereafter.  Unlike most of these "garbage"issues, I think this one is worth some of our precious face-to-facetime.By the way, I thought I had told people on Cleanup this, but I guess Ijust told certain individuals: I will not be able to be at the Bostonmeeting.  I had already made plans to be in England when this meeting'sdate was settled in Palo Alto.  I'd like to be at the meeting, but Itrust the members of X3J13 not to do anything too horrible in myabsence.-- Scott*start*00825 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 07 JUN 87 16:32:57 PDTDate: 07 Jun 87 16:32 PDTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE To: cl-cleanup@SAIL.STANFORD.EDU I'm sorry I used the word ``inconsistency'' when I meant to use the phrase``multiplicity of rules.'' To new users, an abundance of rules where onewould seem to be necessary is often viewed by such users as either aninconsistency in design philosphy among the various parts of the languageor an inconsistency in the sanity of the designers of the language.I rephrase my cynical design rule:``Changes that introduce or retain a multiplicity of rules where a singlerule will do are preferable to changes that cause old programs to stopworking.''			-rpg-*start*01209 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 07 JUN 87 16:50:01 PDTDate: 07 Jun 87 16:48 PDTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE and EuLispTo: cl-cleanup@SAIL.STANFORD.EDU I said in a message:``Our position with respect to EuLisp will be more difficult....''KMP goes on to argue various positions the EuLisp folks might have. Isuppose a reasonable way to proceed is to set up KMP and some other peopleto simulate the EuLisp folks and assume positions they might have, and wecan see how well our arguments might apply to those positions, but what Imeant by my remark is that if we moved as far as the cleanest formulationof the FUNCTION-TYPE issue, that would be seen as an act of good faith onour part and would cause the two groups to move much closer together andto proceed with a common design much more easily.If, for example, we changed Common Lisp to be a Lisp1 dialect, the groupswould merge. By ``position'' I meant negotiation position. I don't expectthis group to understand the process of negotiating with the EuLisp folks,so there is no point in arguing the merits here.			-rpg-*start*01185 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 09 JUN 87 18:24:04 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 9 Jun 87  18:21:50 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 09 JUN 87 18:21:23 PDTDate: 9 Jun 87 18:21 PDTFrom: Masinter.paSubject: Issue: FUNCTION-TYPETo: cl-cleanup@sail.stanford.eduMessage-ID: <870609-182123-1906@Xerox>Will Clinger mentioned to me at the last X3J13 one important reason forthe stronger interpretation which I hadn't thought of. The issue isgarbage collection of unused functions. The idea is to gc all functionsin the system which aren't called, at the point of building anapplication. However, when funcall and friends can automatically coercesymbols, then any funcall potentially becomes a reference to anysymbol-named function in the environment (without some really hairy andimpossible flow analysis.) If there is no automatic coercion, and therearen't any explicit symbol-functions, then you can be guaranteed that ifyou don't see a call to FOO or a #'FOO somewhere, then FOO isn'treferenced and its definition can be GC'd. *start*00672 00024 US Date: Tue,  9 Jun 87 18:36:04 PDTFrom: Pavel.paSubject: Re: Issue: FUNCTION-TYPEIn-reply-to: <870609-182123-1906@Xerox>To: MasinterCc: cl-cleanup@sail.stanford.edu  Date: 9 Jun 87 18:21 PDT  From: Masinter.pa  If there is no automatic coercion, and there  aren't any explicit symbol-functions, then you can be guaranteed that if  you don't see a call to FOO or a #'FOO somewhere, then FOO isn't  referenced and its definition can be GC'd.One can always use manual coercion, via EVAL, so you'll also have to outlaw any calls to thatt function in the application.  It starts seeming like this isn't such a compelling argument.	Pavel*start*01057 00024 US Return-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 06 JUN 87 16:30:49 PDTDate: 06 Jun 87 16:30 PDTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE To: cl-cleanup@SAIL.STANFORD.EDU I regard this issue as a put-up-or-shut-up affair. I preferthe formulation that states that APPLY and FUNCALL take functions,and you have to coerce symbols and lambda-expressions to be functionsbefore you can APPLY or FUNCALL them to more lenient formulations.If we do not go with this formulation, then I would say animportant design criterion of the cleanup is:Changes that introduce or retain inconsistencies which confuse new usersand which complicate the rules of the language are preferable to changesthat cause old programs to stop working.I think Common Lisp is so messed up that the cleanest change tofunction types will not effect major improvements. Our positionwith respect to EuLisp will be more difficult.Put up or shut up: I don't care which you choose.			-rpg-*start*02301 00024 US Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 JUN 87 21:30:48 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 10 Jun 87  21:29:12 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 169946; Wed 10-Jun-87 22:54:29 EDTDate: Wed, 10 Jun 87 22:54 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: FUNCTION-TYPE To: Dick Gabriel <RPG@SAIL.STANFORD.EDU>cc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: The message of 6 Jun 87 19:30 EDT from Dick Gabriel <RPG@SAIL.STANFORD.EDU>Message-ID: <870610225426.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 06 Jun 87  1630 PDT    From: Dick Gabriel <RPG@SAIL.STANFORD.EDU>    I regard this issue as a put-up-or-shut-up affair. I prefer    the formulation that states that APPLY and FUNCALL take functions,    and you have to coerce symbols and lambda-expressions to be functions    before you can APPLY or FUNCALL them to more lenient formulations.    If we do not go with this formulation, then I would say an    important design criterion of the cleanup is:[updated version of the following quote from a later message substitutedfor the original]    ``Changes that introduce or retain a multiplicity of rules where a single    rule will do are preferable to changes that cause old programs to stop    working.''Perhaps I should just keep my mouth shut, but I think that quite aplausible case can be made that requiring an explicit coercion beforecalling APPLY or FUNCALL would be introducing an extra rule and would bemore confusing to new users than permitting the coercion.  I don't thinkthere is one "right" position on this issue, I think it is a matter oftaste and style.  I don't think incompatibility with existing programsis the primary point of resistance on this issue.I'd really prefer that this matter of taste not hold up agreement on theimportant FUNCTION-TYPE proposal.  Can we separate out the coercion ofsymbols and lambda expressions by function calling into a separate issue?Dick, I don't know what you meant by "put-up-or-shut-up"; would treatingthis as two separate issues be somehow unacceptable to you?*start*01679 00024 USaReturn-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 10 JUN 87 23:26:36 PDTDate: 10 Jun 87 23:25 PDTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: Put Up or Shut Up  To: cl-cleanup@SAIL.STANFORD.EDU I think a user has to put a multiplicity of rules in his mind when hereads that FUNCALL calls the function..., when it really invokes thefunction or coerces a symbol or a list with a LAMBDA CAR (though thatmight fail) to a function and calls that. But a user has fewer rules inmind when he knows that FUNCALL invokes the function and that there is astandard way to coerce (COERCE).What I mean by ``put up or shut up'' is very innocent: This is an issue inwhich we either choose to make a true cleanup for aesthetic and politicalreasons or we choose not to. If we choose the former, I feel we haveammunition to use to gain a compromise with EuLisp and Scheme - this wouldbe fine with me. If we choose the latter, I feel we have to keep CommonLisp away from being a Lisp (unmodified name) standard, and we must makesure that ISO Lisp is really ISO EuLisp or some such - this would be finewith me. Y'all get to put up or shut up, and I get to observe the outcomeand begin to act accordingly, assuming someone wishes me to act at all.From my own standpoint, I prefer the cleaner formulation, but I amperfectly happy with the one currently stated in the FUNCTION-TYPEwriteup; if either makes it to the floor of X3J13, I will vote for it.I am happy to treat the important, undisputed part of the FUNCTION-TYPEproposal as separate from the only-aesthetic, disputed part of the proposal.			-rpg-*start*03129 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 JUN 87 10:44:09 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 12 Jun 87  10:40:44 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 12 JUN 87 10:24:45 PDTDate: 12 Jun 87 10:24 PDTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE  To: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <870612-102445-1632@Xerox>My idea with FUNCTION-TYPE is to bring out a proposal which includes theautomatic coercion of symbols to functions, puts forward the removal ofthe coercion in the discussion section (as possibly a new proposal) andfor this to be a discussion item at X3J13. It will be hard for it to bea discussion item if it doesn't go out in the mail. The discussionsection of the proposal should say something like "The cleanup committeegenerally supports this proposal, as far as it goes. Some members of thecommittee feel strongly that it does not go far enough. We believe thisis an issue which deserves wider discussion in the community, since itaffects the position of X3J13 and Common Lisp with respect to the EuLispcommunity."Is that OK?I'm trying hard to keep the administration of this uncolored by my ownopinion on the issues. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Here's my opinion on the issue:I promised a message on the issue of compatibility and our negotiatingposition with EuLisp and ISO. I am finding it very difficult to compose.The X3J13 statement clearly includes as one of the options we are ableto take is to propose a layered implementation strategy, i.e., thatthere are simpler subsets of Common Lisp, full Common Lisp, andsupersets of full Common Lisp.I believe that our current goal is to properly remove the ambiguities infull Common Lisp and, where warrented, consider minor enhancements.When dealing with subsets and supersets, I think that we also haveadditional goals, that the layers properly nest (programs in a subsetwill run in a superset), that it be possible (either by static analysisor runtime) to tell whether a program in a superset would run in asubset, etc.I believe the proper position with regard to EuLisp and ISO's desire fora simpler language as a standard is for it to be a subset. In the case of the FUNCTION-TYPE issue, it is critical that the FUNCTIONtype be well specified in full Common Lisp, if it is a first-class typein any subset. Otherwise, programs which depended on a clean dynamiclyaccurate FUNCTIONP would not run in (arbitrary) full Common Lispimplementations.However, there is no need to remove the automatic coercion of symbolsand LAMBDA expressions in FUNCALL, APPLY and friends. It is certainlypossible to have a subset which does not include coercions which thefull language provides.With regard to simplicity and coercions, the automatic coercion ofsymbols and lambda expressions to their designated functions is not alot more complex than the coercion of (symbols?) and strings topathnames, or possibly even integers to complex floats.*start*00946 00024 USaReturn-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 11 JUN 87 18:47:48 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 11 Jun 87  18:46:04 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 11 JUN 87 16:49:30 PDTDate: 11 Jun 87 16:49 PDTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE  In-reply-to: Dick Gabriel <RPG@SAIL.STANFORD.EDU>'s message of 10 Jun 87 23:25 PDTTo: RPG@SAIL.STANFORD.EDUcc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <870611-164930-206@Xerox>I missed this message, sorry.I think we have agreement to release the form of FUNCTION-TYPE whichallows implicit coercion in FUNCALL and APPLY.  Can someone produce anew version of the proposal? It would be good if we could release it byX3J13.Richard, I think that your position about the EULisp community isunnecessarily extreme, but I will address that in a separate message.*start*01193 00024 US Return-Path: <FAHLMAN@C.CS.CMU.EDU>Received: from C.CS.CMU.EDU by Xerox.COM ; 12 JUN 87 17:12:29 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Fri 12 Jun 87 20:12:07-EDTDate: Fri, 12 Jun 87 20:12 EDTMessage-ID: <FAHLMAN.12310022293.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Masinter.paCc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-TYPE  In-reply-to: Msg of 12 Jun 1987  13:24-EDT from Masinter.pa at Xerox.COMI think that if we agree to settle on the coercing version of thisproposal now and to discuss the more radical version later, we almostguarantee that the radical version will not be seriously considered inour lifetimes.  We will have established a new status quo that istolerable, more or less, and it will be very hard to move away from thatto something better (if we decide it is indeed better).I think that it would be best to present both plans to X3J13 and todiscuss the merits of each at the meeting, and then if the coercingversion is the best we can do, so be it; we shouldn't kid ourselves thata more radical cleanup of this issue will be considered later.-- Scott*start*01379 00024 US Date: 12 Jun 87 22:54 PDTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE  In-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Fri, 12 Jun 87 20:12 EDTTo: Fahlman@C.CS.CMU.EDUcc: Masinter.pa, cl-cleanup@SAIL.STANFORD.EDUPuerhaps I wasn't clear. I think that the discussion of the coercion of FUNCALL and APPLY is a central, and very important to discuss, at this X3J13. However, I think it is separable from the issue of the FUNCTION type, and the changes to FUNCTIONP and TYPEP of FUNCTION.    And, it seems valuable to separate them, since, while they are both compatible changes, there is not necessarily any correlation between whether one supports one and the other, since their justifications and motivations are not identical. My proposal is to separate them. One issue is FUNCTION-TYPE.  What is the other issue called? I had tentatively named it FUNCTION-COERCION. A proposal just arrived from Will Clinger, with selective linking as the central theme (I alluded to this in an earlier message.)   I will mail this out in a separate message (EVAL-DEFEATS-LINKER).  If your sentiment is that we should not release one issue without the other, I agree, it seems poor form and might let one get lost in the face of the other. If you would like to keep them together in the same proposal, please explain.Thanks,Larry*start*01696 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 12 JUN 87 22:57:05 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 12 Jun 87  22:55:41 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 12 JUN 87 22:54:31 PDTDate: 12 Jun 87 22:54 PDTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE  In-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Fri, 12 Jun 87 20:12 EDTTo: Fahlman@C.CS.CMU.EDUcc: Masinter.pa, cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <870612-225431-2538@Xerox>Puerhaps I wasn't clear. I think that the discussion of the coercion ofFUNCALL and APPLY is a central, and very important to discuss, at thisX3J13. However, I think it is separable from the issue of the FUNCTIONtype, and the changes to FUNCTIONP and TYPEP of FUNCTION.    And, itseems valuable to separate them, since, while they are both compatiblechanges, there is not necessarily any correlation between whether onesupports one and the other, since their justifications and motivationsare not identical. My proposal is to separate them. One issue is FUNCTION-TYPE.  What isthe other issue called? I had tentatively named it FUNCTION-COERCION. Aproposal just arrived from Will Clinger, with selective linking as thecentral theme (I alluded to this in an earlier message.)   I will mailthis out in a separate message (EVAL-DEFEATS-LINKER).  If your sentimentis that we should not release one issue without the other, I agree, itseems poor form and might let one get lost in the face of the other. Ifyou would like to keep them together in the same proposal, pleaseexplain.Thanks,Larry*start*00923 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 16 JUN 87 23:37:13 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 16 Jun 87  23:36:08 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 JUN 87 15:18:19 PDTDate: 16 Jun 87 15:17 PDTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE (version 5)In-reply-to: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>'s message of Tue, 16 Jun 87 09:07 EDTTo: Fahlman@C.CS.CMU.EDUcc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <870616-151819-260@Xerox>Thanks, Scott.Given that some important members of the community don't have regularmail access, I think it would disenfranchise them to *not* mail thisissue out. I think your rewrite looks very good. Since I'm mailing theother issues this afternoon, I am going to release your version, intact.I will precede it with an introduction.*start*14908 00024 USfDate: 16 Jun 87 15:33 PDTFrom: Masinter.paTo: X3J13@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-TYPE (Version 5)Reply-to: CL-Cleanup@Sail.Stanford.Educc: MasinterFUNCTION-TYPE is one of the more difficult issues facing the cleanup committee. This is a tough but important issue that involves some fundamental trade-offs, so discussion by the whole X3J13 committee is called for.I am distributing version 5, even though the full cleanup committee has not read or commented on it. Scott Fahlman worked hard to produce Version 5;  I think Scott's summary of the issues and arguments is excellent. However, to repeat, because of insufficient time, this proposal does not reflect a consensus of opinion, either on the proposal or on the form in which it is presented.This version presents the two options the committee discussed the most as alternatives.  We hope to be able to discuss (and revise) this proposal before the Boston meeting.  The proposal has two parts, one less controversial than the other. It is  possible that the group will decide to postpone the difficult issues and just vote on the simpler one.The writing up of these two options was not meant to preclude others. One other proposal was discussed, which would require a symbol's function cell to accept symbols and lambda expressions as well as true functions and to return unchanged whatever was put there. We do not yet have an exposition of this point of view.Since Scott Fahlman won't be at X3J13, he included his own position at the end. Sincerely,Larry MasinterIssue:          FUNCTION-TYPEReferences:     functions (pg 32), types (pg 33), FUNCTIONP (pg 76),                SYMBOL-FUNCTION (pg 90), APPLY (pg 107).Category:     	CHANGE/CLARIFICATIONEdit History:   Version 1 by Gabriel 02/26/87                Version 2 by cleanup committee 15-Mar-87                Version 3 by Fahlman 10-May-87                Version 4 by Masinter 29-May-87 incorporate comments                Version 5 by Fahlman 15-June-87 include two optionsProblem Description:The definition of the term `function' in CLtL includes all symbols andmany lists in addition to true functions.  The type named `function' istherefore not a useful type, and its presence complicates the typehierarchy. The language would be improved if functions were treated as atype in a consistent and useful manner.  This would also make it easierto integrate the function data type into the CLOS class hierarchy.At present, it is not the case that (FUNCTIONP x) is equivalent to(TYPEP x 'FUNCTION), because the latter form is illegal under a strictreading of the manual.  On page 47 it is stated that the FUNCTION typespecifier can only be used for declaration and not for discrimination.Some of the original Common Lisp designers maintain that thisrestriction on the use of the FUNCTION specifier was meant to apply onlyto long-form FUNCTION specifiers.  In any event, this issue blursthe status of the FUNCTION data-type.The current confused situation came about mostly because of a desire inthe original Common Lisp definition to retain compatibility with olderLisp dialects, but in the context of Common Lisp some of these ancientdesign decisions are inappropriate.Two alternative proposals are presented here:Proposal FUNCTION-TYPE:STRICT-REDEFINITION1. Under this proposal FUNCTION is a full-fledged data type that can beused both for declaration and discrimination.  The list form of theFUNCTION type specifier may still be used only for declaration.Symbols (whether or not the symbol is FBOUNDP) and lambda expressionsare not of type FUNCTION under this proposal.The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION arepairwise disjoint.  In particular, a list may not be used to implementany FUNCTION subtype.No sub-types of FUNCTION are defined in Common Lisp, but implementationsare free to define subtypes of FUNCTION.  Examples might beCOMPILED-FUNCTION and INTERPRETED-FUNCTION.  Note that this is a changefrom the current Common Lisp definition which explicitly defines aCOMPILED-FUNCTION type.  This proposal removes the predicateCOMPILED-FUNCTION-P from the standard language.2. The behavior of FUNCTIONP is defined to be exactly equivalent to#'(LAMBDA (X) (TYPEP X 'FUNCTION)).  In particular, FUNCTIONP is nolonger true of symbols and lambda lists.3. FUNCALL and APPLY will now accept only a true function as thefunctional argument.  This restriction is inherited by MAPCAR and otherfunctions in Common Lisp that take a functional argument suitable forFUNCALL or APPLY.  It is no longer legal to pass a symbol or lambdaexpression as the functional argument to any of these functions; to doso "is an error".4. In all non-error situations, the result of evaluating a FUNCTIONspecial form is required to be of type FUNCTION.  It is an error to usethe special form FUNCTION on a symbol that does not denote a function inthe lexical environment in which the special form appears.Specifically, it is an error to use the FUNCTION special form on asymbol that denotes a macro or special form.  (Some implementations maychoose not to signal this error for performance reasons.)5. If SYMBOL-FUNCTION is called on a symbol that names a function in thenull lexical context, it returns that function (which, of course, is oftype FUNCTION).  It is an error to call SYMBOL-FUNCTION on anythingelse.  In particular, it is an error to call SYMBOL-FUNCTION on a symbolthat names a macro or special form in the null lexical context; it isunpredictable what will be returned in this case.It is an error to pass anything other than a (true) function as thevalue to (SETF (SYMBOL-FUNCTION symbol) value).  Some implementationswill signal an error in this case; others may accept the bogus objectand fail only when the supposed function is called.6. The description of COMPILE must be changed, since it is no longermeaningful to speak of a symbol with a definition that "is alambda-expression".  Where CLtL says "a definition that is alambda-expression", substitute "a definition from which theimplementation is able to reconstruct a lambda-expression".Proposal FUNCTION-TYPE:COERCING-REDEFINITIONThis is identical to FUNCTION-TYPE:STRICT-REDEFINITION except forsection 3:3. The text descriptions of FUNCALL, APPLY, MAPCAR and other functionsin Common Lisp which take functional arguments are modified to statethey will accept (true) functions, symbols, or lists that representlambda-expressions.  A symbol or lambda expression is coerced to afunction using the null lexical environment, and the resulting functionis used.  Note that this is not a change to the current behavior ofCommon Lisp; the descriptions must be changed to accommodate the newdefinition of the FUNCTION data type.RATIONALE:Both proposals provide a clean, useful definition for the FUNCTIONdata-type in Common Lisp.  Under the current definition, FUNCTIONP isnearly useless, since it is defined to be true of all symbols, includingthose that do not have functional definitions.The STRICT-REDEFINITION proposal consistently uses the new, strictdefinition of FUNCTION in all of the obvious places.The COERCING-REDEFINITION proposal cleans up the definition of theFUNCTION data type, but attempts to minimize the impact on existing codeby providing implicit coercions in FUNCALL and APPLY.  Current Practice:Current Common Lisp implementations vary in the way they handleFUNCTIONP and TYPEP of FUNCTION.  They also vary in what they will allowto be put into a SYMBOL-FUNCTION cell.  No current Common Lispimplementation has exactly the semantics described in either of theseproposals, however.Adoption Cost:For either proposal, the type predicates would have to be brought intocompliance, but that should require little effort.Compiled functions are true functions in almost all currentimplementations, but in some implementations interpreted functions andclosures are represented as lists.  Such lists would have to be changedto structures or to some special internal data type.  The behavior ofCOMPILE, STEP, TRACE, and possibly ED would have to be modifiedto deal with functions that are not lists (but from which the list formcan be easily reconstructed if necessary).If STRICT-REDEFINE is adopted, implementations may choose to convertFUNCALL and APPLY to the new stricter form, but they are not required todo so.  Since the use of a symbol or lambda expression in place of afunction "is an error", an implementation may handle these cases as alocal extension.  Most implementations that continue to provide thecoercion will at least want to install an optional warning in FUNCALLand APPLY to flag the use of this non-portable feature in user code.BENEFITS:By resurrecting FUNCTION as a useful concept, this proposal (eitherversion) will eliminate a lot of confusion and will make it easier totalk about situations in which (true) functions are passed around asLisp objects.By eliminating some tangles in the type hierarchy, this proposalsimplifies the task of mapping Common Lisp types into CLOS classes.  Italso brings Common Lisp into closer alignment with Scheme.CONVERSION COST:The COERCING-REDEFINITION proposal attempts to minimize the impact onuser code by allowing APPLY, FUNCALL, and related functions to acceptsymbols and lambda lists, as they currently do.  One impact onuser-level code would be a change in the operation of certain typepredicates.  Such cases should be relatively easy to find and fix.The STRICT-REDEFINITION proposal would require some additional changesto user code.  An explicit coercion would have to be added whenever asymbol or lambda expression is used as a functional argument.  Many suchcases can be identified at compile time, but not all.  One strategy forautomatic conversion is to replace every call to FUNCALL, APPLY, etc.with a call to an equivalent function or macro that tests the functionalargument at runtime and coerces the argument to a true function ifnecessary.  If implemented carefully, this should not cost significantlymore than doing a built-in coercion within FUNCALL and APPLY.Users might also convert their code by running for a time in animplementation that still does the coercion in FUNCALL and APPLY, butthat issues a warning message whenever the coercion is actually needed.This will flag all of the non-portable situations in parts of theprogram that have actually been executed during the test period.In some current Common Lisp implementations, SETF of SYMBOL-FUNCTIONwill accept a symbol or lambda expression and SYMBOL-FUNCTION willreturn this item unchanged.  If a symbol FOO is used as the functionaldefinition of BAR, then any change to FOO will affect BAR as well.  Someold code (MACSYMA is one example) depends on this behavior and wouldhave to be modified if either of these proposals is adopted.  However,such code is not currently portable because many existing Common Lispimplementations already violate these assumptions.  CLtL does notclearly state what values SETF of SYMBOL-FUNCTION will accept and howthat object may be modified.Under either proposal, user code which uses COMPILED-FUNCTION-P would nolonger be valid or portable.AESTHETICS:Making the concept of a function well-defined will probably be perceivedas a simplification.The STRICT-REDEFINITION proposal is perceived by most members of thecleanup committee as the simpler and cleaner of the two proposals.  TheCOERCING-REDEFINITION proposal adds some complexity in the name ofcompatibility.DISCUSSION:This has been discussed at great length within the cleanup committee.All of us agree that the definition of the FUNCTION data type must berevised, but there is no clear consensus on what to do about thecoercions.  Since the cleanup of the type hierarchy is important to theCLOS group, there is some urgency to this part of the proposal, atleast.Some committee members (Gabriel and Fahlman) have argued that the strictform of the proposal is preferable because it is simpler: it defines aFUNCTION data type and then requires every object used as a function tobe a FUNCTION.  The strict proposal requires a somewhat greaterconversion effort for user code, but it seems better to make this effortonce than to live forever with runtime coercion of functional argumentsand the resulting complexity.Members of the Eulisp group have argued strongly for what amounts to theSTRICT-REDEFINITION proposal.  They feel that this would remove oneimportant difference between their view of Lisp (similar to Scheme inthis instance) and ours.Moon has argued that the coercing form of the proposal is no morecomplex than the strict form; it is all a matter of taste.Several members of the committee argued in favor of presenting bothproposals to X3J13, since the tradeoff between simplicity and conversioneffort must be discussed by the whole community.White suggested that if the coercing version of the proposal isadopted, we might need an APPLICABLE-P predicate that is true of anyobject that is legal as a functional argument to APPLY and FUNCALL.FUNCTIONP will not do this job.Pitman has argued that items 4 and 5 (either proposal) will break a lotof code that depends on being able to use lambda expressions and symbolsas function definitions, and that it will be hard to fix such problems.He may produce a third proposal before the X3J13 meeting that deals withthese problems.  He has suggested that we may wish to settle the typeredefinition issues (points 1 and 2 above) now, while deferring adecision on the more controversial coercion issues.Fahlman feels that the issues are now clearly drawn and that we shouldgo ahead and make a decision on the whole package.Clinger has suggested that the strict form is preferable because it makesit possible to reduce the total size of a delivered application program.Only those Common Lisp functions that are actually called need to beincluded, but implicit function coercions tends to create loopholesthrough which *every* function might be called.The cleanup committee believes that the definition of COMPILE needsclarification, but that it should be done in a separate proposal. Thechange to COMPILE in this proposal is the minimum necessary.Fahlman and Gabriel support FUNCTION-TYPE:STRICT-REDEFINITION.        TITAN          
TIMESROMAN           TITAN           
TIMESROMAN 
                        `                                          n                                               +      +       -      Z             A             $             *       
                                @             
      8 !z*start*03095 00024 UShReturn-Path: <NGALL@G.BBN.COM>Received: from G.BBN.COM by Xerox.COM ; 22 JUN 87 22:36:06 PDTDate: 23 Jun 87 01:34 EDTSender: NGALL@G.BBN.COMSubject: Re: Issue: FUNCTION-TYPE (Version 5)From: NGALL@G.BBN.COMTo: CL-Cleanup@SAIL.STANFORD.EDUCc: Masinter.paMessage-ID: <[G.BBN.COM]23-Jun-87 01:34:43.NGALL>In-Reply-To: <870616-155121-101@Xerox>	    Date: 16 Jun 87 15:33 PDT    From: Masinter.pa@Xerox.COM            FUNCTION-TYPE is one of the more difficult issues facing the cleanup    committee. This is a tough but important issue that involves some    fundamental trade-offs, so discussion by the whole X3J13 committee is    called for.    My main concern about losing symbols as valid function objects (i.e.,things that can be given to apply and funcall) is that it will makethe "functional style" of Lisp more difficult to debug.For example, I use the following reader macro to allow function names(symbols) to be used as arguments when my code is in the debuggingphase and "true" fucntions to be used when my code is "finished".(defun |#!-reader| (stream subchar arg)  (declare (ignore subchar arg))  (let ((fname (read stream t nil t)))    (if *debugging-p*      `',fname      `#',fname)))(set-dispatch-macro-character  #\#  #\!  (if *debugging-p* '|#!-reader| #'|#!-reader|))Then, I can code the following (in most implementations):(proclaim '(optimze (speed 0) (safety 3)))(proclaim '(notinline froz))(eval-when (compile load eval) (defparameter *debugging-p* t))(defun froz ...)...(funcall #!froz ...)......(mapcar #!froz ...)...(defparameter *action-seq* `(,#!froz ,#!zorf ,#!(lambda ...) ...))...(apply (elt *action-seq* i) ...)I can at any time trace froz in order to find out what is going on(besides tracing I may also do some types of profiling). (Cf. trace,pg 441.)  And what is probably even more important, when myobservation of the behavior of froz leads me to redefine froz, everypiece of code or data-structure that references the function name frozwill correctly get the new definition.As CLtL is currently vague as to when it is permissable to dereferencea function name to its definition (compile-time, load-time, orapply-time),  I have to avoid implementations that do not deference atapply-time.Under the strict redefinition proposal, I would have to recompileevery data structure that contained #'froz.  In other words, it wouldmake functional objects impratical to debug.Under both proposals. function names (i.e., symbols andlambda-expressions) are (virtually) eliminated as functional objects.This is great way to "purify" the semantics of the language, but itputs a big burden on implementors to come up with  development environmentsthat have the ease of debugging that function names provided.I think I have probably mixed up a few issues here (it is late forme), but I wanted to put in my warning that flushing function namesthat can be passed around as functions has some major consequences onLisp style due to debugging/redefinition issues.-- Nick*start*01547 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 23 JUN 87 08:10:39 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 23 Jun 87  08:09:41 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 23 Jun 87 10:57:54-EDTDate: Tue, 23 Jun 87 10:57 EDTMessage-ID: <FAHLMAN.12312804981.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: NGALL@G.BBN.COMCc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-TYPE (Version 5)In-reply-to: Msg of 23 Jun 1987  01:34-EDT from NGALL at G.BBN.COMThere are lots of ways in which an implementation could provide tracingfacilities for anonymous function objects.  For human-interfacepurposes, function objects would be identified using some label that isderived from the original name under which the funciton was defined.This information could be hidden in some slot of the function object or(somewhat more portably) associated with it in a hashtable.I haven't thought this through, but I bet that one could develop a tracefacility like the one you describe, but using anonymous stand-infunctions that print something and then call the original function(which can be redefined) rather than using a symbol as a wrapper.  Thismight even be strictly portable, which your hack is not.If the same debugging functionality can be achieved in a different way,I don't see the elimination of one dubious hack as a strong argument forkeeping the status quo.-- Scott*start*02172 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:edsel!kent-state!eb@navajo.stanford.edu>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 23 JUN 87 09:52:02 PDTReceived: from NAVAJO.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 23 Jun 87  09:48:42 PDTReceived: by navajo.stanford.edu; Tue, 23 Jun 87 09:45:40 PDTReceived: from kent-state.edsel.uucp by edsel.uucp (3.2/SMI-2.0)	id AA12003; Tue, 23 Jun 87 09:15:21 PDTReceived: by kent-state.edsel.uucp (3.2/SMI-3.2)	id AA08001; Tue, 23 Jun 87 09:16:28 PDTDate: Tue, 23 Jun 87 09:16:28 PDTFrom: edsel!kent-state!eb@navajo.stanford.edu (Eric Benson)Message-Id: <8706231616.AA08001@kent-state.edsel.uucp>To: navajo!NGALL%G.BBN.COM@navajo.stanford.eduCc: navajo!cl-cleanup%sail@navajo.stanford.eduIn-Reply-To: navajo!NGALL@G.BBN.COM's message of 23 Jun 1987 01:34-EDT <[G.BBN.COM]23-Jun-87 01:34:43.NGALL>Subject: Issue: FUNCTION-TYPE (Version 5)   Date: 23 Jun 1987 01:34-EDT   Sender: navajo!NGALL@G.BBN.COM   From: navajo!NGALL@G.BBN.COM   My main concern about losing symbols as valid function objects (i.e.,   things that can be given to apply and funcall) is that it will make   the "functional style" of Lisp more difficult to debug.   For example, I use the following reader macro to allow function names   (symbols) to be used as arguments when my code is in the debugging   phase and "true" fucntions to be used when my code is "finished".   (defun |#!-reader| (stream subchar arg)     (declare (ignore subchar arg))     (let ((fname (read stream t nil t)))       (if *debugging-p*	 `',fname	 `#',fname)))   (set-dispatch-macro-character     #\#     #\!     (if *debugging-p* '|#!-reader| #'|#!-reader|))Here's a version of your debugging environment that adheres to thestrict definition of functions:(defun |#!-reader| (stream subchar arg)  (declare (ignore subchar arg))  (let ((fname (read stream t nil t)))    (if (consp fname)	`#',fname	(if *debugging-p*	    `#'(lambda (&rest x) (apply #',fname x))	    `#',fname))))(set-dispatch-macro-character  #\#  #\!  (if *debugging-p*       #'(lambda (&rest x) (apply #'|#!-reader| x))      #'|#!-reader|))*start*02703 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:NGALL@G.BBN.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 23 JUN 87 11:49:09 PDTReceived: from G.BBN.COM by SAIL.STANFORD.EDU with TCP; 23 Jun 87  11:44:55 PDTDate: 23 Jun 87 14:43 EDTSender: NGALL@G.BBN.COMSubject: Re: Issue: FUNCTION-TYPE (Version 5)From: NGALL@G.BBN.COMTo: Fahlman@C.CS.CMU.EDUCc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <[G.BBN.COM]23-Jun-87 14:43:05.NGALL>In-Reply-To: <FAHLMAN.12312804981.BABYL@C.CS.CMU.EDU>	    Date: Tue, 23 Jun 1987  10:57 EDT    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    ...    I haven't thought this through, but I bet that one could develop a trace    facility like the one you describe, but using anonymous stand-in    functions that print something and then call the original function    (which can be redefined) rather than using a symbol as a wrapper.  This    might even be strictly portable, which your hack is not.That's the problem.  No implementations (except perhaps Symbolics)seem to have thought through encapsulation issues (of which tracing isbut one example).  Thus in many implementations, tracing functionscalled from compiled code, even with speed 0 and safety 3 andnotinlines, does not work, or only works in some situtations.    If the same debugging functionality can be achieved in a different way,    I don't see the elimination of one dubious hack as a strong argument for    keeping the status quo.That's a big IF in my opinion, given that most implementations have sofar only provided the crudest of tracing and breaking facilities(which all depend on apply-time deferencing of function-names).It is not entirely clear from your response what you consider to be mydubious hack.  If you mean that depending on implementations todereference function-names (i.e., symbols) at apply time (unlessdeclarations permit otherwise), then I must disagree with you.Virtually all Lisp interpreters have this behavior, it is thecompilers that cause inconsistent behavior.  And since one of CommonLisp's major goals is to "impose identical semantics" on compiled andinterpreted code, I claim that my examples were perfectly correct CLprograms and compilers that don't enforce proper dereferencing arebroken.The ability to apply function names (and have them deferenced as lateas possible) may have gotten into Lisp fordubious reasons, but it has been a very strong reason why Lisp hassucceeded as a flexible, incremental, and rapid developmentenvironment.  If we remove this feature without alternative mechanismsALREADY IN PLACE, we will make Lisp debugging more primitive thanconventional language debugging.-- Nick*start*04419 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:RAM@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 23 JUN 87 15:40:58 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 23 Jun 87  15:38:19 PDTReceived: ID <RAM@C.CS.CMU.EDU>; Tue 23 Jun 87 18:37:27-EDTDate: Tue, 23 Jun 87 18:37 EDTMessage-ID: <RAM.12312888633.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: NGALL@G.BBN.COMCc: CL-Cleanup@SAIL.STANFORD.EDU, Fahlman@C.CS.CMU.EDUSubject: Issue: FUNCTION-TYPE (Version 5)In-reply-to: Msg of 23 Jun 1987  14:43-EDT from NGALL at G.BBN.COMSince this message addresses compiler semantics, I thought I'd commenton it...    Date: Tuesday, 23 June 1987  14:43-EDT    From: NGALL at G.BBN.COM    To:   Fahlman at C.CS.CMU.EDU    Re:   Issue: FUNCTION-TYPE (Version 5)    [...]  It is not entirely clear from your response what you    consider to be my dubious hack.  If you mean that depending on    implementations to dereference function-names (i.e., symbols) at    apply time (unless declarations permit otherwise), then I must    disagree with you.  Virtually all Lisp interpreters have this    behavior, it is the compilers that cause inconsistent behavior.    And since one of Common Lisp's major goals is to "impose identical    semantics" on compiled and interpreted code, I claim that my    examples were perfectly correct CL programs and compilers that    don't enforce proper dereferencing are broken.Perhaps unfortunately, it isn't possible to implement anything thatcould reasonably be called a "compiler" so that it has exactly thesame semantics as traditional interpreters.  The entire purpose of acompiler is to make use of compile-time information in order totransform the program into a more efficient and more specific program.In my compiler cleanup proposal, I argue that Common Lisp shouldn'ttalk about the semantics of compiled v.s. interpreted code, instead itshould define "evaluation" in a way that is broad enough to encompassboth compiled and interpreted evaluation strategies.  This mostlyamounts to saying "It is an error to write a program that cannot becompiled.", since there are few things a compiler can do thatinterpreters don't.    The ability to apply function names (and have them deferenced as    late as possible) may have gotten into Lisp for dubious reasons,    but it has been a very strong reason why Lisp has succeeded as a    flexible, incremental, and rapid development environment.This is a valid point, but it doesn't directly translate into marchingorders for Common Lisp standardization.  We should attempt to designCommon Lisp so that it doesn't preclude useful environment features,but we are not obligated to provide them directly in the language.I agree with you that it should be possible to force compilers to dofull function call, but the issues aren't totally clear.  For example,the functions that are being expanded inline are presumably standardCommon Lisp functions.  It is all very well to say "NOTINLINE inhibitsinline expansion", but this capability is of little use unless you canredefine standard functions.  [Which was discussed to death oncommon-lisp a while back.]You must always remember that when Common Lisp says that something "isan error", implementations are not forbidden to assign meaning to thatusage.  If there is a feature that is needed to support an environmentso amazing mind-bogglingly whizzy that you can't live without it, theneverybody will want that kind of environment support, and all"reasonable" implementations will provide it.  This in itself is not aparticularly strong argument for standardizing the *feature thatsupports the environment*.  It is only when we start talking aboutportable environment facilities that we become concerned.The concept of a "reasonable" implementation is also important.Common Lisp does not reqire implementations to be reasonable; it onlyrequires that programs meeting the specification run in allimplementations (subject to resource limitations and other ill-definedvaguenesses.)   It is not a valid argument to say "X must be in CommonLisp because I refuse to use a system that doesn't support X."  Youmust demonstrate that X aids significantly in writing interestingportable programs, rather than simply allowing you to hack in themanner to which you have become accustomed.  Rob*start*15912 00024 USfReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 16 JUN 87 06:10:55 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 16 Jun 87  06:08:12 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 16 Jun 87 09:07:25-EDTDate: Tue, 16 Jun 87 09:07 EDTMessage-ID: <FAHLMAN.12310949843.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-TYPE (version 5)I have written up a version of this proposal that presents the twooptions we have discussed the most as alternatives.  The idea is that wecan perhaps debug this proposal before the Boston meeting, and then havesomething concrete and written-down to discuss with the whole X3J13group.  Perhaps that discussion will lead to some consensus or at leastto a clear view of which way the majority of X3J13 wants to go.  A mailballot after the meeting could make things official in that case.  Ofcourse, it is also possible that people will decide to postpone thedifficult issues and just vote on the type cleanup, without deciding howthe resulting types may be used.By writing up these two options, I do not mean to preclude others.However, the only other proposal that has appeared is the one from KMPthat we require a symbol's function cell to accept symbols and lambdaexpressions as well as true functions and to return unchanged whateverwas put there.  Kent has indicated some ambivalence about whether hewants to press forward with this option, which has not received anysupport from others on the committee.  If he does want to press this,he should write up this option himself, since I don't really understandthe fine points of his position.Since I won't be there, I have included my own vote at the end.  I havealso included what I believe to be RPG's position, since he has made hisviews known repeatedly.  I'm not sure exactly where the rest of youstand at present.Many small things had to be changed to make this a two-option proposal,so it is probably best for you to consider this a new proposal and readit over carefully.  The major substantive change is in point 3 (now intwo distinct versions).  There are also some changes in "cost ofconversion" -- see if you believe my argument that mechanical conversionof old code to adhere to the strict form of the proposal is possibleand that the result is not significantly less efficient than buildingthe coercions into FUNCALL and APPLY.  Also, look over the discussionsection and see if I have seriously misrepresented anyone's views.-- Scott---------------------------------------------------------------------------Status:         To be discussed at X3J13 meeting (?).  This is a                tough but important issue that involves some fundamental                trade-offs, so discussion by the whole X3J13 committee                is called for.Issue:          FUNCTION-TYPEReferences:     functions (pg 32), types (pg 33), FUNCTIONP (pg 76),                SYMBOL-FUNCTION (pg 90), APPLY (pg 107).Category:     	CHANGE/CLARIFICATIONEdit History:   Version 1 by Gabriel 02/26/87                Version 2 by cleanup committee 15-Mar-87                Version 3 by Fahlman 10-May-87                Version 4 by Masinter 29-May-87 incorporate comments                Version 5 by Fahlman 15-June-87 include two optionsProblem Description:The definition of the term `function' in CLtL includes all symbols andmany lists in addition to true functions.  The type named `function' istherefore not a useful type, and its presence complicates the typehierarchy. The language would be improved if functions were treated as atype in a consistent and useful manner.  This would also make it easierto integrate the function data type into the CLOS class hierarchy.At present, it is not the case that (FUNCTIONP x) is equivalent to(TYPEP x 'FUNCTION), because the latter form is illegal under a strictreading of the manual.  On page 47 it is stated that the FUNCTION typespecifier can only be used for declaration and not for discrimination.Some of the original Common Lisp designers maintain that thisrestriction on the use of the FUNCTION specifier was meant to apply onlyto long-form FUNCTION specifiers.  In any event, this issue blursthe status of the FUNCTION data-type.The current confused situation came about mostly because of a desire inthe original Common Lisp definition to retain compatibility with olderLisp dialects, but in the context of Common Lisp some of these ancientdesign decisions are inappropriate.Two alternative proposals are presented here:Proposal FUNCTION-TYPE:STRICT-REDEFINITION1. Under this proposal FUNCTION is a full-fledged data type that can beused both for declaration and discrimination.  The list form of theFUNCTION type specifier may still be used only for declaration.Symbols (whether or not the symbol is FBOUNDP) and lambda expressionsare not of type FUNCTION under this proposal.The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION arepairwise disjoint.  In particular, a list may not be used to implementany FUNCTION subtype.No sub-types of FUNCTION are defined in Common Lisp, but implementationsare free to define subtypes of FUNCTION.  Examples might beCOMPILED-FUNCTION and INTERPRETED-FUNCTION.  Note that this is a changefrom the current Common Lisp definition which explicitly defines aCOMPILED-FUNCTION type.  This proposal removes the predicateCOMPILED-FUNCTION-P from the standard language.2. The behavior of FUNCTIONP is defined to be exactly equivalent to#'(LAMBDA (X) (TYPEP X 'FUNCTION)).  In particular, FUNCTIONP is nolonger true of symbols and lambda lists.3. FUNCALL and APPLY will now accept only a true function as thefunctional argument.  This restriction is inherited by MAPCAR and otherfunctions in Common Lisp that take a functional argument suitable forFUNCALL or APPLY.  It is no longer legal to pass a symbol or lambdaexpression as the functional argument to any of these functions; to doso "is an error".4. In all non-error situations, the result of evaluating a FUNCTIONspecial form is required to be of type FUNCTION.  It is an error to usethe special form FUNCTION on a symbol that does not denote a function inthe lexical environment in which the special form appears.Specifically, it is an error to use the FUNCTION special form on asymbol that denotes a macro or special form.  (Some implementations maychoose not to signal this error for performance reasons.)5. If SYMBOL-FUNCTION is called on a symbol that names a function in thenull lexical context, it returns that function (which, of course, is oftype FUNCTION).  It is an error to call SYMBOL-FUNCTION on anythingelse.  In particular, it is an error to call SYMBOL-FUNCTION on a symbolthat names a macro or special form in the null lexical context; it isunpredictable what will be returned in this case.It is an error to pass anything other than a (true) function as thevalue to (SETF (SYMBOL-FUNCTION symbol) value).  Some implementationswill signal an error in this case; others may accept the bogus objectand fail only when the supposed function is called.6. The description of COMPILE must be changed, since it is no longermeaningful to speak of a symbol with a definition that "is alambda-expression".  Where CLtL says "a definition that is alambda-expression", substitute "a definition from which theimplementation is able to reconstruct a lambda-expression".Proposal FUNCTION-TYPE:COERCING-REDEFINITIONThis is identical to FUNCTION-TYPE:STRICT-REDEFINITION except forsection 3:3. The text descriptions of FUNCALL, APPLY, MAPCAR and other functionsin Common Lisp which take functional arguments are modified to statethey will accept (true) functions, symbols, or lists that representlambda-expressions.  A symbol or lambda expression is coerced to afunction using the null lexical environment, and the resulting functionis used.  Note that this is not a change to the current behavior ofCommon Lisp; the descriptions must be changed to accommodate the newdefinition of the FUNCTION data type.RATIONALE:Both proposals provide a clean, useful definition for the FUNCTIONdata-type in Common Lisp.  Under the current definition, FUNCTIONP isnearly useless, since it is defined to be true of all symbols, includingthose that do not have functional definitions.The STRICT-REDEFINITION proposal consistently uses the new, strictdefinition of FUNCTION in all of the obvious places.The COERCING-REDEFINITION proposal cleans up the definition of theFUNCTION data type, but attempts to minimize the impact on existing codeby providing implicit coercions in FUNCALL and APPLY.  Current Practice:Current Common Lisp implementations vary in the way they handleFUNCTIONP and TYPEP of FUNCTION.  They also vary in what they will allowto be put into a SYMBOL-FUNCTION cell.  No current Common Lispimplementation has exactly the semantics described in either of theseproposals, however.Adoption Cost:For either proposal, the type predicates would have to be brought intocompliance, but that should require little effort.Compiled functions are true functions in almost all currentimplementations, but in some implementations interpreted functions andclosures are represented as lists.  Such lists would have to be changedto structures or to some special internal data type.  The behavior ofCOMPILE, STEP, TRACE, and possibly ED would have to be modifiedto deal with functions that are not lists (but from which the list formcan be easily reconstructed if necessary).If STRICT-REDEFINE is adopted, implementations may choose to convertFUNCALL and APPLY to the new stricter form, but they are not required todo so.  Since the use of a symbol or lambda expression in place of afunction "is an error", an implementation may handle these cases as alocal extension.  Most implementations that continue to provide thecoercion will at least want to install an optional warning in FUNCALLand APPLY to flag the use of this non-portable feature in user code.BENEFITS:By resurrecting FUNCTION as a useful concept, this proposal (eitherversion) will eliminate a lot of confusion and will make it easier totalk about situations in which (true) functions are passed around asLisp objects.By eliminating some tangles in the type hierarchy, this proposalsimplifies the task of mapping Common Lisp types into CLOS classes.  Italso brings Common Lisp into closer alignment with Scheme.CONVERSION COST:The COERCING-REDEFINITION proposal attempts to minimize the impact onuser code by allowing APPLY, FUNCALL, and related functions to acceptsymbols and lambda lists, as they currently do.  One impact onuser-level code would be a change in the operation of certain typepredicates.  Such cases should be relatively easy to find and fix.The STRICT-REDEFINITION proposal would require some additional changesto user code.  An explicit coercion would have to be added whenever asymbol or lambda expression is used as a functional argument.  Many suchcases can be identified at compile time, but not all.  One strategy forautomatic conversion is to replace every call to FUNCALL, APPLY, etc.with a call to an equivalent function or macro that tests the functionalargument at runtime and coerces the argument to a true function ifnecessary.  If implemented carefully, this should not cost significantlymore than doing a built-in coercion within FUNCALL and APPLY.Users might also convert their code by running for a time in animplementation that still does the coercion in FUNCALL and APPLY, butthat issues a warning message whenever the coercion is actually needed.This will flag all of the non-portable situations in parts of theprogram that have actually been executed during the test period.In some current Common Lisp implementations, SETF of SYMBOL-FUNCTIONwill accept a symbol or lambda expression and SYMBOL-FUNCTION willreturn this item unchanged.  If a symbol FOO is used as the functionaldefinition of BAR, then any change to FOO will affect BAR as well.  Someold code (MACSYMA is one example) depends on this behavior and wouldhave to be modified if either of these proposals is adopted.  However,such code is not currently portable because many existing Common Lispimplementations already violate these assumptions.  CLtL does notclearly state what values SETF of SYMBOL-FUNCTION will accept and howthat object may be modified.Under either proposal, user code which uses COMPILED-FUNCTION-P would nolonger be valid or portable.AESTHETICS:Making the concept of a function well-defined will probably be perceivedas a simplification.The STRICT-REDEFINITION proposal is perceived by most members of thecleanup committee as the simpler and cleaner of the two proposals.  TheCOERCING-REDEFINITION proposal adds some complexity in the name ofcompatibility.DISCUSSION:This has been discussed at great length within the cleanup committee.All of us agree that the definition of the FUNCTION data type must berevised, but there is no clear consensus on what to do about thecoercions.  Since the cleanup of the type hierarchy is important to theCLOS group, there is some urgency to this part of the proposal, atleast.Some committee members (Gabriel and Fahlman) have argued that the strictform of the proposal is preferable because it is simpler: it defines aFUNCTION data type and then requires every object used as a function tobe a FUNCTION.  The strict proposal requires a somewhat greaterconversion effort for user code, but it seems better to make this effortonce than to live forever with runtime coercion of functional argumentsand the resulting complexity.Members of the Eulisp group have argued strongly for what amounts to theSTRICT-REDEFINITION proposal.  They feel that this would remove oneimportant difference between their view of Lisp (similar to Scheme inthis instance) and ours.Moon has argued that the coercing form of the proposal is no morecomplex than the strict form; it is all a matter of taste.Several members of the committee argued in favor of presenting bothproposals to X3J13, since the tradeoff between simplicity and conversioneffort must be discussed by the whole community.White suggested that if the coercing version of the proposal isadopted, we might need an APPLICABLE-P predicate that is true of anyobject that is legal as a functional argument to APPLY and FUNCALL.FUNCTIONP will not do this job.Pitman has argued that items 4 and 5 (either proposal) will break a lotof code that depends on being able to use lambda expressions and symbolsas function definitions, and that it will be hard to fix such problems.He may produce a third proposal before the X3J13 meeting that deals withthese problems.  He has suggested that we may wish to settle the typeredefinition issues (points 1 and 2 above) now, while deferring adecision on the more controversial coercion issues.Fahlman feels that the issues are now clearly drawn and that we shouldgo ahead and make a decision on the whole package.Clinger has suggested that the strict form is preferable because it makesit possible to reduce the total size of a delivered application program.Only those Common Lisp functions that are actually called need to beincluded, but implicit function coercions tends to create loopholesthrough which *every* function might be called.The cleanup committee believes that the definition of COMPILE needsclarification, but that it should be done in a separate proposal. Thechange to COMPILE in this proposal is the minimum necessary.Fahlman and Gabriel support FUNCTION-TYPE:STRICT-REDEFINITION.*start*02108 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:barmar@AQUINAS.THINK.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 17 JUN 87 08:46:22 PDTReceived: from [192.5.104.1] by SAIL.STANFORD.EDU with TCP; 17 Jun 87  08:44:15 PDTReceived: from POLYCARP.THINK.COM by AQUINAS.THINK.COM via CHAOS with CHAOS-MAIL id 32813; Wed 17-Jun-87 11:46:53 EDTDate: Wed, 17 Jun 87 11:40 EDTFrom: Barry Margolin <barmar@AQUINAS.THINK.COM>Subject: Issue: FUNCTION-TYPE (Version 5)To: CL-Cleanup@sail.stanford.educc: X3J13@sail.stanford.edu, Masinter.paIn-Reply-To: <870616-155121-101@Xerox>Message-ID: <870617114008.1.BARMAR@POLYCARP.THINK.COM>I think STRICT-REDEFINITION is reasonable, although I think I wouldprobably vote for COERCE-REDEFINITION because it has less impact onexisting code.    The STRICT-REDEFINITION proposal would require some additional changes    to user code.  An explicit coercion would have to be added whenever a    symbol or lambda expression is used as a functional argument.  Many such    cases can be identified at compile time, but not all.  One strategy for    automatic conversion is to replace every call to FUNCALL, APPLY, etc.    with a call to an equivalent function or macro that tests the functional    argument at runtime and coerces the argument to a true function if    necessary.  If implemented carefully, this should not cost significantly    more than doing a built-in coercion within FUNCALL and APPLY.There is also a big hole in STRICT-REDEFINITION as currently proposed.This paragraph suggests that one might coerce a symbol or lambda list toa function at runtime, but the proposal doesn't mention any new functionthat one would call to do this.  There needs to be a MAKE-FUNCTIONfunction, which takes a symbol or lambda list and returns thecorresponding function.  It probably should have an optional environmentargument, too.  It might be equivalent to(defun make-function (thing &optional env)  (eval `(function ,thing) env))However, it should probably be a primitive so that implimentations cando it optimally.						barmar*start*04401 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 17 JUN 87 12:14:00 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 17 Jun 87  11:50:22 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Wed 17 Jun 87 14:49:41-EDTDate: Wed, 17 Jun 87 14:49 EDTMessage-ID: <FAHLMAN.12311274316.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: X3J13@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-TYPE (Version 5)In reply to: Barry Margolin <barmar at AQUINAS.THINK.COM>    There is also a big hole in STRICT-REDEFINITION as currently proposed.    This paragraph suggests that one might coerce a symbol or lambda list to    a function at runtime, but the proposal doesn't mention any new function    that one would call to do this.  There needs to be a MAKE-FUNCTION    function, which takes a symbol or lambda list and returns the    corresponding function.  It probably should have an optional environment    argument, too.  It might be equivalent to    (defun make-function (thing &optional env)      (eval `(function ,thing) env))    However, it should probably be a primitive so that implimentations can    do it optimally.I see no big hole here.The coercion is so trivial that I figured anyone writing a package toconvert old code to run under the STRICT-REDEFINITION rules could figureout how to do it with no problem.  And since this is a temporary crutchfor use on onconverted old code, I certainly don't think that we want toadd anything like MAKE-FUNCTION to the language; for all new code, userswill invoke FUNCTION for themselves in the appropriate places.We do NOT want to add an environment argument to MAKE-FUNCTION.  APPLYand FUNCALL currently interpret symbols and lambda expressions in thenull lexical environment, not the surrounding one.  That must be thecase, since the symbol or lambda may have come from some very differentpart of the program.Here's the way I would re-code APPLY, using a macro.  FUNCALL, et al,would be treated in a similar way.  The covnersion tool would simply bea code-walker (or perhaps even an editor macro) that turns every APPLYinto COERCING-APPLY unless the argument being passed in is sitting rightthere and its type can be determined at conversion time.(defmacro coercing-apply (funarg &rest other-args)  `(apply (let ((x ,funarg))	    (typecase x	      (function x)	      (symbol (symbol-function x))	      (t (eval (list 'function x)))))	  ,@other-args))Assuming that the implementation has a good implementation of TYPECASEand a quick test for the FUNCTION data type, this should add very littleextra cost to the APPLY call, except in the case where a raw lambda-listneeds to be function-ized.  Some smart compilers may optimize away aTYPECASE statement if the type of the object can be determined byanalysis at compile time.Note that COERCING-APPLY is almost identical to what APPLY would looklike in the coercing version of the proposal, except that thetype-dispatch and coercion is outside the APPLY rather than inside.Anyone arguing that the strict form of the proposal is unacceptablebecause this fully-mechanized method of conversion introducesinefficiency should realize that this same inefficiency is currentlybuilt into *every* FUNCALL and APPLY, and would continue to be under thecoercing version of the proposal.  Under the strict form, it onlyappears in mechanically converted code, and then only in cases where thetype of the functional argument is not easily determined atconversion/compile time.  But I think that the overhead is so smallcompared to an APPLY-type function call that efficiency is not a strongargument for either side.If code size is a bigger issue than the speed of APPLY, COERCING-APPLYcould be coded as a function rather than as a macro, or it could be doneas an inline function, letting the user control the tradeoff viadeclarations.  There are very few programs around in which the code sizewould grow by more than 1%, even in the macro case.So, fully mechanized conversion of old code is feasible under theSTRICT-REDEFINITION proposal.  The question is whether we are willing toaccept even this small inconvenience in order to get a cleaner language(if indeed you believe that the strict form is cleaner).-- Scott*start*03426 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:barmar@Think.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 17 JUN 87 13:06:56 PDTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 17 Jun 87  12:46:48 PDTReceived: from polycarp by Think.COM via CHAOS; Wed, 17 Jun 87 15:49:07 EDTDate: Wed, 17 Jun 87 15:47 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: FUNCTION-TYPE (Version 5)To: Scott E. Fahlman <Fahlman@c.cs.cmu.edu>Cc: X3J13@sail.stanford.eduIn-Reply-To: <FAHLMAN.12311274316.BABYL@C.CS.CMU.EDU>Message-Id: <870617154704.1.BARMAR@POLYCARP.THINK.COM>    Date: Wed, 17 Jun 1987  14:49 EDT    From: "Scott E. Fahlman" <Fahlman@c.cs.cmu.edu>    In reply to: Barry Margolin <barmar at AQUINAS.THINK.COM>	There is also a big hole in STRICT-REDEFINITION as currently proposed.	This paragraph suggests that one might coerce a symbol or lambda list to	a function at runtime, but the proposal doesn't mention any new function	that one would call to do this.  There needs to be a MAKE-FUNCTION	function, which takes a symbol or lambda list and returns the	corresponding function.  It probably should have an optional environment	argument, too.  It might be equivalent to	(defun make-function (thing &optional env)	  (eval `(function ,thing) env))	However, it should probably be a primitive so that implimentations can	do it optimally.    We do NOT want to add an environment argument to MAKE-FUNCTION.  APPLY    and FUNCALL currently interpret symbols and lambda expressions in the    null lexical environment, not the surrounding one.  That must be the    case, since the symbol or lambda may have come from some very different    part of the program.I now agree with this.As for whether MAKE-FUNCTION should be added, I still think it shouldbe.  If STRICT-REDEFINITION is adopted, then programmers who want toturn lambda lists into functions will need a reasonable way to do this.Yes, (EVAL `(FUNCTION ,LAMBDA-LIST)) will do it, but I don't think usersshould have to write this.  Generally, Lisp programmers are taught thatthey should rarely need to invoke EVAL directly, unless they areimplementing an embedded language or something along those lines.Consider the function:(defun read-apply-print-loop ()  (loop (print (apply (make-function (read)))))This isn't an embedded language, and there's no reason it should have tocall EVAL directly.    The coercion is so trivial that I figured anyone writing a package to    convert old code to run under the STRICT-REDEFINITION rules could figure    out how to do it with no problem.  And since this is a temporary crutch    for use on onconverted old code, I certainly don't think that we want to    add anything like MAKE-FUNCTION to the language; for all new code, users    will invoke FUNCTION for themselves in the appropriate places.I don't agree that this is a temporary crutch only for old code.  Thereis no way to write the above function without manually coercing lambdalists to functions, because the lambda list that it is trying to applydid not come from another program, it was generated on the fly (in thiscase by the reader).  There is no way for read to return a functionobject (actually, there is a disgusting way, q.v.), it can only return alambda list.Here's the disgusting way to make READ return a function: the user cantype "#.#'(lambda ...)".						barmar*start*01480 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 17 JUN 87 13:13:53 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 17 Jun 87  13:12:21 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 175697; Wed 17-Jun-87 16:11:37 EDTDate: Wed, 17 Jun 87 16:11 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE (Version 5)To: X3J13@SAIL.STANFORD.EDUcc: CL-Cleanup@Sail.Stanford.EduIn-Reply-To: <870616-155121-101@Xerox>Message-ID: <870617161131.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Since apparently we're going to discuss this proposal at length on theX3J13 mailing list, I just wanted to point out one minor hole in it.    CONVERSION COST:    One strategy for    automatic conversion is to replace every call to FUNCALL, APPLY, etc.    with a call to an equivalent function or macro that tests the functional    argument at runtime and coerces the argument to a true function if    necessary.  If implemented carefully, this should not cost significantly    more than doing a built-in coercion within FUNCALL and APPLY.There is a large number of functions hiding inside that little "etc."By my count there are 61 functions in Common Lisp that take :test or :keyarguments.  There are probably a few other functions that call FUNCALLor APPLY internally.*start*00851 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 26 JUN 87 00:08:54 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 25 Jun 87  23:33:06 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 182745; Fri 26-Jun-87 01:43:35 EDTDate: Fri, 26 Jun 87 01:43 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: FUNCTION-TYPE: not allowing symbols to be used as functionsTo: CL-Cleanup@sail.stanford.eduMessage-ID: <870626014327.5.MOON@EUPHRATES.SCRC.Symbolics.COM>*MACROEXPAND-HOOK* is another one you overlooked.  Its default valueis the symbol FUNCALL, and its value gets funcalled, therefore itrelies on funcalling a symbol and would need to be reworked.*start*01638 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:FAHLMAN@C.CS.CMU.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 18 JUN 87 10:47:25 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 18 Jun 87  07:36:26 PDTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Thu 18 Jun 87 10:35:41-EDTDate: Thu, 18 Jun 87 10:35 EDTMessage-ID: <FAHLMAN.12311490219.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: X3J13@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-TYPE (Version 5)In-reply-to: Msg of 17 Jun 1987  16:11-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>In response to Moon:I tried to respond to this yesterday, but it looks like the mail systemate my message.  My apologies if anyone sees this twice.        One strategy for        automatic conversion is to replace every call to FUNCALL, APPLY, etc...    There is a large number of functions hiding inside that little "etc."    By my count there are 61 functions in Common Lisp that take :test or :key    arguments.  There are probably a few other functions that call FUNCALL    or APPLY internally.This is true.  However, it still is not particularly hard for acode-walker or even a smart editor macro to find all of these :test and:key arguments and to see if they need repair.  In the overwhelmingmajority of these cases, the functional argument is sitting thereexplicitly after the keyword, either quoted or already wrapped in aFUNCTION.  The former can be fixed trivially, and the latter need nofixing.  Very few of these cases will end up requiring a runtimetype-test.-- Scott*start*01833 00024 UShReturn-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 18 JUN 87 10:47:52 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 18 Jun 87  10:01:15 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 176524; Thu 18-Jun-87 12:59:36 EDTDate: Thu, 18 Jun 87 12:59 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE (Version 5)To: Scott E. Fahlman <Fahlman@C.CS.CMU.EDU>cc: X3J13@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12311490219.BABYL@C.CS.CMU.EDU>Message-ID: <870618125936.5.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 18 Jun 1987  10:35 EDT    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    In response to Moon:	    One strategy for	    automatic conversion is to replace every call to FUNCALL, APPLY, etc...	There is a large number of functions hiding inside that little "etc."	By my count there are 61 functions in Common Lisp that take :test or :key	arguments.  There are probably a few other functions that call FUNCALL	or APPLY internally.    This is true.  However, it still is not particularly hard for a    code-walker or even a smart editor macro to find all of these :test and    :key arguments and to see if they need repair.  In the overwhelming    majority of these cases, the functional argument is sitting there    explicitly after the keyword, either quoted or already wrapped in a    FUNCTION.  The former can be fixed trivially, and the latter need no    fixing.  Very few of these cases will end up requiring a runtime    type-test.Scott, the "automatic strategy" sentence that I quoted out of contextwas in the context of discussing how to put in run-time type tests.*start*00497 00024 UShReturn-Path: <RPG@SAIL.STANFORD.EDU>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 18 JUN 87 13:29:08 PDTDate: 18 Jun 87 11:32 PDTFrom: Dick Gabriel <RPG@SAIL.STANFORD.EDU>Subject: FUNCTION-TYPE  (Version 5)   To: cl-cleanup@SAIL.STANFORD.EDU BARMAR's correct, we forgot to include an extension to COERCE on pages51-52 to coerce symbols and certain lists to functions. I recall formulating an intention to mail such a proposal, but it seems I forgot.			-rpg-*start*01306 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Received: from SAIL.STANFORD.EDU by Xerox.COM ; 13 JUL 87 12:58:35 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 13 Jul 87  12:54:07 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 13 JUL 87 12:54:07 PDTDate: 13 Jul 87 12:53 PDTFrom: Masinter.paSubject: Issue: FUNCTION-TYPETo: cl-cleanup@Sail.stanford.eduMessage-ID: <870713-125407-2098@Xerox>We are tasked with producing a new version of FUNCTION-TYPE forconsideration at the next X3J13. The new version should reflect thediscussion held so far. My notes and memory are poor. Does anyone elsehave any notes?My notes include that point 6 (the description of COMPILE) should beremoved from this proposal, that there was some sentiment forconsidering a proposal where symbols coerced to their symbol-functionbut lists did not, consideration of APPLICABLE-P, a proposal whereFUNCTION and FUNCTIONP stayed the same but there was a new typePROCEDURE and PROCEDUREP, that we be more consistent about justifyingremoving COMPILED-FUNCTION-P (i.e., why bother?), that the proposalmention selective linking.Some of the discussion centered around the merits of Dynamic Linking andthe Value of Lisp, the behavior of COERCE and the FUNCTION type. *start*01521 00024 US Return-Path: <@SAIL.STANFORD.EDU:Masinter.pa@Xerox.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 22 SEP 87 14:36:11 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 22 Sep 87  14:34:10 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 22 SEP 87 14:20:17 PDTDate: 22 Sep 87 14:11 PDTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPETo: cl-cleanup@Sail.stanford.educc: willc%tekchips.tek.com@RELAY.CS.NETMessage-ID: <870922-142017-12589@Xerox>I've thought about FUNCTION-TYPE on and off over the summer, as one ofthe more important issues for us to revisit.  I've changed my mind; I amnow in favor of STRICT-REDEFINITION as long as the proposal thatspecifies that it "is an error" to give symbols to functions that expectfunctions. ) as long as the restriction is "is an error" rather than"signals an error".I think that the proposal has technical (linking, analysis) andaesthetic (cleaner language semantic) advantages, and that backwardcompatibility is well-served by noting that many implementations willcontinue to support automatic coercion.I think we owe X3J13 a new draft of the proposal with fewer (rather thanmore) alternatives expressed. All of the alternatives expressed so far have some flaws. I'm willing towork on the STRICT-REDEFINITION proposal to correct its problems (e.g.,deal with *MACROEXPAND-HOOK*, add COERCE to type FUNCTION).Are there any volunteers to work on any of the other proposals?*start*13802 00024 USfDate: 23 Oct 87 11:51 PDTFrom: Masinter.paTo: CL-CLEANUP@SAIL.STANFORD.EDUcc: willc%tekchips.tek.com@RELAY.CS.NETSubject: Issue: FUNCTION-TYPE (Version 6)cc: Masinterline-fold: 80(I fixed a couple of minor typo's, and cc'd Clinger in this message.)As I promised back in July, here is a revised version of the STRICT-REDEFINITION option of FUNCTION-TYPE. In this version, I also added to the Problem Description some of the issues in EVAL-DEFEATS-LINKER. I left COMPILED-FUNCTION and COMPILED-FUNCTION-P as subtypes of FUNCTION. I attempted to move "discussion" items into the body where appropriate, and eliminated them where they duplicated arguments already in the body of the proposal. I added a proposal to extend COERCE to allow (COERCE x 'FUNCTION).As this is a controversial proposal, avoiding controversy is impossible, and so I have not attempted it. I am vaguely uneasy that some of the alternatives and considerations discussed at X3J13 were not mentioned here -- it *was* a lengthy session. Anyone remember better than I any other points brought up at the time?Issue:          FUNCTION-TYPEReferences:     functions (p. 32), types (p. 33), FUNCTIONP (p. 76),                SYMBOL-FUNCTION (p. 90), APPLY (p. 107).Category:     	CHANGE/CLARIFICATIONEdit History:   Version 1 by Gabriel 02/26/87                Version 2 by cleanup committee 15-Mar-87                Version 3 by Fahlman 10-May-87                Version 4 by Masinter 29-May-87 incorporate comments                Version 5 by Fahlman 15-June-87 include two options                Version 6 by Masinter 23-Oct-87, only STRICT-REDEFINITIONProblem Description:The definition of the term `function' in CLtL includes all symbols andmany lists in addition to true functions.  The type named `function' istherefore not a useful type, and its presence complicates the typehierarchy. The language would be improved if functions were treated as atype in a consistent and useful manner.  This would also make it easierto integrate the function data type into the CLOS class hierarchy.At present, it is not the case that (FUNCTIONP x) is equivalent to (TYPEP x 'FUNCTION), because the latter form is illegal under a strict reading of the manual.  On page 47 it is stated that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers.  In any event, this issue blurs the status of the FUNCTION data-type.The current confused situation came about mostly because of a desire in the original Common Lisp definition to retain compatibility with older Lisp dialects, but in the context of Common Lisp some of these ancient design decisions are inappropriate.In addition, the practice that APPLY, FUNCALL and the numerous functions that take functional arguments (such as MAPC, MAPCAR, FIND-IF) can potentially do the equivalent of  SYMBOL-FUNCTION to go from a symbol to its functional-value is a serious impediment to program analysis which require the ability to determine by examining a program which functional definitions might be accessed from it. For example, "selective linking" (which would allow a delivery system to include only those parts of the Common Lisp library actually accessed) is seriously hampered by the numerous implicit coercions of symbols to functions.Proposal FUNCTION-TYPE:STRICT-REDEFINITION1. Under this proposal FUNCTION is a full-fledged data type that can be used both for declaration and discrimination.  The list form of the FUNCTION type specifier may still be used only for declaration.Symbols (whether or not the symbol is FBOUNDP) and lambda expressions are not of type FUNCTION under this proposal.The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION are pairwise disjoint.  In particular, a list may not be used to implement any FUNCTION subtype.The COMPILED-FUNCTION subtype of FUNCTION is defined; implementations are free to define subtypes of FUNCTION, e.g., INTERPRETED-FUNCTION.  2. The behavior of FUNCTIONP is defined to be exactly equivalent to #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  In particular, FUNCTIONP is no longer true of symbols and lambda lists.3. FUNCALL and APPLY will now accept only a true function as the functional argument.  This restriction is inherited by MAPCAR and other functions in Common Lisp that take a functional argument suitable for FUNCALL or APPLY.  It is no longer legal to pass a symbol or lambda expression as the functional argument to any of these functions; to do so "is an error".4. In all non-error situations, the result of evaluating a FUNCTION special form is required to be of type FUNCTION.  It is an error to use the special form FUNCTION on a symbol that does not denote a function in the lexical environment in which the special form appears. Specifically, it is an error to use the FUNCTION special form on a symbol that denotes a macro or special form.  (Some implementations may choose not to signal this error for performance reasons.)5. If SYMBOL-FUNCTION is called on a symbol that names a function in the null lexical context, it returns that function (which, of course, is of type FUNCTION).  It is an error to call SYMBOL-FUNCTION on anything else.  In particular, it is an error to call SYMBOL-FUNCTION on a symbol that names a macro or special form in the null lexical context; it is unpredictable what will be returned in this case.It is an error to pass anything other than a (true) function as the value to (SETF (SYMBOL-FUNCTION symbol) value).  Some implementations will signal an error in this case; others may accept the object and fail only when the supposed function is called.6. The description of COMPILE must be changed, since it is no longer meaningful to speak of a symbol with a definition that "is a lambda-expression".  Where CLtL says "a definition that is a lambda-expression", substitute "a definition from which the implementation is able to reconstruct a lambda-expression".7. Extend the definition of COERCE to allow coercion of objects to type FUNCTION. That is, "Some symbols and lists may be converted to functions." (COERCE SYMBOL 'FUNCTION) performs SYMBOL-FUNCTION (getting the top level function definition, the current lexical context is not relevant), while (COERCE LIST 'FUNCTION) is equivalent to (EVAL `(FUNCTION ,LIST)), i.e., it creates a function from a LAMBDA expression by interpreting it as a list in the top level lexical environment.8.  Modify the description of the macro expansion process to say that the value of *MACROEXPAND-HOOK* is coerced to a function before being called as the expansion interface hook by MACROEXPAND-1. Rationale:This proposal provides a clean, useful definition for the FUNCTION data-type in Common Lisp.  Under the current definition, FUNCTIONP is nearly useless, since it is defined to be true of all symbols, including those that do not have functional definitions.It also enhances the semantics of Common Lisp functional arguments to be more consistent with other programming languages, and allows better program analysis tools.Current Practice:Current Common Lisp implementations vary in the way they handle FUNCTIONP and TYPEP of FUNCTION.  They also vary in what they will allow to be put into a SYMBOL-FUNCTION cell.  No current Common Lisp implementation has exactly the semantics described in this proposal, however, although it corresponds more closely to Scheme and to the work of the EuLisp community.Adoption Cost:Bringing type predicates (FUNCTIONP, etc.)  into compliance should require little effort.Compiled functions are true functions in almost all current implementations, but in some implementations interpreted functions and closures are represented as lists.  Such lists would have to be changed to structures or to some special internal data type.  The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be modified to deal with functions that are not lists (but from which the list form can be easily reconstructed if necessary).Implementations may choose to convert FUNCALL and APPLY to the new stricter form, but they are not required to do so.  Since the use of a symbol or lambda expression in place of afunction "is an error", an implementation may handle these cases as a local extension.  Most implementations that continue to provide the coercion will at least want to install an optional warning in FUNCALL and APPLY to flag the use of this non-portable feature in user code.Benefits:By resurrecting FUNCTION as a useful concept, this proposal (either version) will eliminate a lot of confusion and will make it easier to talk about situations in which (true) functions are passed around as Lisp objects.By eliminating some tangles in the type hierarchy, this proposal simplifies the task of mapping Common Lisp types into CLOS classes.This proposal brings Common Lisp into closer alignment with Scheme and the work of the EuLisp committee.This proposal allows for better program analysis tools, enhances the ability to do "selective linking" correctly. It makes it possible to reduce the total size of a delivered application program. Only those Common Lisp functions that are actually called need to beincluded; implicit coercions tend to create loopholes through which *every* function might be called.Conversion cost:This proposal may have a high conversion cost for some existing Common Lisp programs. The changes to FUNCTIONP and the FUNCTION type declaration is relatively easy to deal with. However, the strict redefinition of FUNCALL, APPLY and functional arguments will require the addition of an explicit coercion would have to be added whenever a symbol or lambda expression is used as a functional argument. Many suchcases can be identified at compile time, but not all. Some implementations might provide tools to assist in detecting implicit coercion of symbols to functions. For example, an implementation might add run-time test in which the implementation still does the coercion but that issues a warning message whenever the coercion is actually needed. Alternatively, a "smart" code-walker or editor macro might find all of the calls to FUNCALL, APPLY, and the 61 Common Lisp functions that take :TEST or :KEY arguments and, if the argument is not already an explicitly quoted FUNCTION form, wrap a COERCE around the body.  In some current Common Lisp implementations, SETF of SYMBOL-FUNCTION will accept a symbol or lambda expression and SYMBOL-FUNCTION will return this item unchanged.  If a symbol FOO is used as the functional definition of BAR, then any change to FOO will affect BAR as well.  Some old code depends on this behavior and would have to be modified if this proposal is adopted; doing so will be difficult as these uses cannot easily be detected from simple examination of the program. (Such code is not currently portable because many existing Common Lisp implementations already violate these assumptions.  CLtL does not clearly state what values SETF of SYMBOL-FUNCTION will accept and how that object may be modified.)Aesthetics:Making the concept of a function well-defined is a simplification of the language. This proposal is the cleanest of the alternatives; it defines a FUNCTION data type and then requires every object used as a function to be a FUNCTION. While many argue that removing automatic coercion results in a simpler, cleaner, and more aesthetic language definition, others have argued otherwise ("its all a matter of taste.")Discussion:This proposal has been discussed at great length; this section attempts only to summarize the important points.There is general agreement that the definition of the FUNCTION data type must be revised. (There was one suggestion to create a new type name and to leave FUNCTION alone, but it was not generally perceived as acceptable.) The cleanup of the type hierarchy is important to the CLOS group. There is much more disagreement about disallowing implicit coercions; cleanup of implicit coercions are important for compatibility with other Lisp standards work.Some argue that it seems better to make this effort once than to live forever with runtime coercion of functional arguments and the resulting complexity.Some have argued that the coercing form of the proposal is no more complex than the strict form; it is all a matter of taste.If coercing was continued to be allowed, Common Lisp might need an APPLICABLE-P predicate that is true of any object that is legal as a functional argument to APPLY and FUNCALL, since FUNCTIONP would no longer do this job.The cleanup committee believes that the definition of COMPILE needs clarification, but that it should be done in a separate proposal. The change to COMPILE in this proposal is the minimum necessary.This proposal interacts with the proposal on compiler semantics: some claim that strict-redefinition would allow further compiler optimizations, since compiled FUNCALL is not required to go through extensive inline checks. Fahlman, Gabriel and Masinter support FUNCTION-TYPE:STRICT-REDEFINITION.Pitman and Moon have expressed support for an alternative proposal which would continue to allow coercion.        TITAN          TITAN           
TIMESROMAN 
          
TIMESROMAN 
           Q       #             <                                          n                           Z                    +                                p                    
      ?                                             4L  z*start*00878 00024 US Return-Path: <dcm%hpfclp@hplabs.HP.COM>Received: from hplabs.HP.COM ([15.255.16.7]) by Xerox.COM ; 23 OCT 87 12:18:53 PDTReceived: from hpfcla.HP.COM (hpfcla) by hplabs.HP.COM with SMTP ; Fri, 23 Oct 87 12:18:28 PDTReceived: from hpfclp.HP.COM by hpfcla.HP.COM; Fri, 23 Oct 87 13:07:24 mdtReceived: from hpfcdcm.HP.COM by hpfclp.HP.COM; Fri, 23 Oct 87 13:07:00 mdtReceived: from hpfcdcm by hpfcdcm.HP.COM; Fri, 23 Oct 87 13:07:14 mdtReturn-Path: <dcm@hpfcdcm>To: CL-CLEANUP@SAIL.STANFORD.EDUCc: Masinter.paSubject: Re: Issue: FUNCTION-TYPE (Version 6) X-Mailer: mh6.5In-Reply-To: Your message of 23 Oct 87 11:45:00 -0700.             <871023-114622-1090@Xerox> Date: Fri, 23 Oct 87 13:07:08 MSTMessage-Id: <1367.562014428@hpfcdcm>From: Dave Matthews <dcm%hpfclp@hplabs.HP.COM>I support FUNCTION-TYPE:STRICT-REDEFINITION.Dave Matthews*start*01408 00024 US Return-Path: <@SAIL.Stanford.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 15:05:06 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 25 Oct 87  15:02:37 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 25 Oct 87 18:02:38-ESTDate: Sun, 25 Oct 87 18:02 ESTMessage-ID: <FAHLMAN.12345399085.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: CL-CLEANUP@SAIL.STANFORD.EDUCc: willc%tekchips.tek.com@RELAY.CS.NETSubject: Issue: FUNCTION-TYPE (Version 6)In-reply-to: Msg of 23 Oct 1987  14:51-EDT from Masinter.pa at Xerox.COMI (still) support FUNCTION-TYPE: STRICT-REDEFINITION.A couple of minor comments on this presentation:There needs to be a heading, "Rationale", I think, after point 8 of theproposal proper.  You want to clearly mark the transition from proposalto argument.I still don't subscribe to Clinger's view of selective linking, but thecomments in this proposal do no harm.Now that there is no discussion of a coercing version of the proposal,some of the material in the discussion section has dangling pointers.To fix this, just say at the start of the discussion section that oneoption discussed earlier was similar to this one, but allowed FUNCALL,etc. to take anything that can be coerced to a function.-- Scott*start*01394 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 NOV 87 13:36:26 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 8 Nov 87  13:34:02 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 274813; Sun 8-Nov-87 16:33:50 ESTDate: Sun, 8 Nov 87 16:34 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE (Version 6)To: CL-CLEANUP@SAIL.STANFORD.EDUcc: willc%tekchips.tek.com@RELAY.CS.NETIn-Reply-To: <871023-115213-1106@Xerox>Message-ID: <19871108213400.8.MOON@EUPHRATES.SCRC.Symbolics.COM>On the whole I favor this proposal, provided the corrections notedin Fahlman's message of 25 October are made.However I continue to dislike the coupling of the proposal to remove theimplicit coercion from FUNCALL, to the proposal to tighten up thedefinition of the FUNCTION type.  In my opinion this coupling islogically unnecessary and has been done only for parliamentary reasons,to prevent people from voting against removing the implicit coercion.This coupling of two proposals prevents us from getting an unbiased pollof X3J13's opinion on the tradeoff between the incompatible change andthe language simplification associated with removing the coercion.*start*13642 00024 USfDate:  9 Nov 87 14:02 PSTFrom: Masinter.paTo: CL-CLEANUP@SAIL.STANFORD.EDUcc: willc%tekchips.tek.com@RELAY.CS.NETSubject: Issue: FUNCTION-TYPE (Version 7)cc: Masinterline-fold: 80I incorporated Scott's comments.I wanted, but didn't know how, to include David's objection to the coupling of the two proposals. I thought them necessary to couple because redefining the function type without redefining FUNCALL would require at least a rewriting of all of the descriptions of FUNCALL, APPLY, the definition of "a function" and several other points in CLtL.In preparing Version 6, I had overlooked a note that we had decided (at one point) to remove section 6 on COMPILE and delegate it to a remark in the discussion section. I did this and renumbered the subsequent sections.Issue:          FUNCTION-TYPEReferences:     functions (p. 32), types (p. 33), FUNCTIONP (p. 76),                SYMBOL-FUNCTION (p. 90), APPLY (p. 107), COERCE (pp. 51-52)                ... :TEST :KEY arguments (61 occurrances).Category:     	CHANGE/CLARIFICATIONEdit History:   Version 1 by Gabriel 02/26/87                Version 2 by cleanup committee 15-Mar-87                Version 3 by Fahlman 10-May-87                Version 4 by Masinter 29-May-87 incorporate comments                Version 5 by Fahlman 15-June-87 include two options                Version 6 by Masinter 23-Oct-87, only STRICT-REDEFINITION                Version 7 by Masinter  9-Nov-87, minor cleanupProblem Description:The definition of the term `function' in CLtL includes all symbols andmany lists in addition to true functions.  The type named `function' istherefore not a useful type, and its presence complicates the typehierarchy. The language would be improved if functions were treated as atype in a consistent and useful manner.  This would also make it easierto integrate the function data type into the CLOS class hierarchy.At present, it is not the case that (FUNCTIONP x) is equivalent to (TYPEP x 'FUNCTION), because the latter form is illegal under a strict reading of the manual.  On page 47 it is stated that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers.  In any event, this issue blurs the status of the FUNCTION data-type.The current confused situation came about mostly because of a desire in the original Common Lisp definition to retain compatibility with older Lisp dialects, but in the context of Common Lisp some of these ancient design decisions are inappropriate.In addition, the practice that APPLY, FUNCALL and the numerous functions that take functional arguments (such as MAPC, MAPCAR, FIND-IF) can potentially do the equivalent of  SYMBOL-FUNCTION to go from a symbol to its functional-value is a serious impediment to program analysis which require the ability to determine by examining a program which functional definitions might be accessed from it. For example, "selective linking" (which would allow a delivery system to include only those parts of the Common Lisp library actually accessed) is seriously hampered by the numerous implicit coercions of symbols to functions.Proposal FUNCTION-TYPE:STRICT-REDEFINITION1. Under this proposal FUNCTION is a full-fledged data type that can be used both for declaration and discrimination.  The list form of the FUNCTION type specifier may still be used only for declaration.Symbols (whether or not the symbol is FBOUNDP) and lambda expressions are not of type FUNCTION under this proposal.The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION are pairwise disjoint.  In particular, a list may not be used to implement any FUNCTION subtype.The COMPILED-FUNCTION subtype of FUNCTION is defined; implementations are free to define subtypes of FUNCTION, e.g., INTERPRETED-FUNCTION.  2. The behavior of FUNCTIONP is defined to be exactly equivalent to #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  In particular, FUNCTIONP is no longer true of symbols and lambda lists.3. FUNCALL and APPLY will now accept only a true function as the functional argument.  This restriction is inherited by all functions in Common Lisp that take a functional argument suitable for FUNCALL or APPLY.  It is no longer legal to pass a symbol or lambda expression as the functional argument to any of these functions; to do so "is an error".4. In all non-error situations, the result of evaluating a FUNCTION special form is required to be of type FUNCTION.  It is an error to use the special form FUNCTION on a symbol that does not denote a function in the lexical environment in which the special form appears. Specifically, it is an error to use the FUNCTION special form on a symbol that denotes a macro or special form.  (Some implementations may choose not to signal this error for performance reasons.)5. If SYMBOL-FUNCTION is called on a symbol that names a function in the null lexical context, it returns that function (which, of course, is of type FUNCTION).  It is an error to call SYMBOL-FUNCTION on anything else.  In particular, it is an error to call SYMBOL-FUNCTION on a symbol that names a macro or special form in the null lexical context; it is unpredictable what will be returned in this case.It is an error to pass anything other than a (true) function as the value to (SETF (SYMBOL-FUNCTION symbol) value).  Some implementations will signal an error in this case; others may accept the object and fail only when the supposed function is called.6. Extend the definition of COERCE to allow coercion of objects to type FUNCTION. That is, "Some symbols and lists may be converted to functions." (COERCE SYMBOL 'FUNCTION) performs SYMBOL-FUNCTION (getting the top level function definition, the current lexical context is not relevant), while (COERCE LIST 'FUNCTION) is equivalent to (EVAL `(FUNCTION ,LIST)), i.e., it creates a function from a LAMBDA expression by interpreting it as a list in the top level lexical environment.7.  Modify the description of the macro expansion process to say that the value of *MACROEXPAND-HOOK* is coerced to a function before being called as the expansion interface hook by MACROEXPAND-1. Rationale:This proposal provides a clean, useful definition for the FUNCTION data-type in Common Lisp.  Under the current definition, FUNCTIONP is nearly useless, since it is defined to be true of all symbols, including those that do not have functional definitions.It also enhances the semantics of Common Lisp functional arguments to be more consistent with other programming languages, and allows better program analysis tools.Current Practice:Current Common Lisp implementations vary in the way they handle FUNCTIONP and TYPEP of FUNCTION.  They also vary in what they will allow to be put into a SYMBOL-FUNCTION cell.  No current Common Lisp implementation has exactly the semantics described in this proposal, however, although it corresponds more closely to Scheme and to the work of the EuLisp community.Adoption Cost:Bringing type predicates (FUNCTIONP, etc.)  into compliance should require little effort.Compiled functions are true functions in almost all current implementations, but in some implementations interpreted functions and closures are represented as lists.  Such lists would have to be changed to structures or to some special internal data type.  The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be modified to deal with functions that are not lists (but from which the list form can be easily reconstructed if necessary).Implementations may choose to convert FUNCALL and APPLY to the new stricter form, but they are not required to do so.  Since the use of a symbol or lambda expression in place of a function "is an error", an implementation may handle these cases as a local extension.  Most implementations that continue to provide the coercion will at least want to install an optional warning in FUNCALL and APPLY to flag the use of this non-portable feature in user code.Benefits:By resurrecting FUNCTION as a useful concept, this proposal (either version) will eliminate a lot of confusion and will make it easier to talk about situations in which (true) functions are passed around as Lisp objects.By eliminating some tangles in the type hierarchy, this proposal simplifies the task of mapping Common Lisp types into CLOS classes.This proposal brings Common Lisp into closer alignment with Scheme and the work of the EuLisp committee.This proposal allows for better program analysis tools, enhances the ability to do "selective linking" correctly. It makes it possible to reduce the total size of a delivered application program. Only those Common Lisp functions that are actually called need to be included; implicit coercions tend to create loopholes through which *every* function might be called.Conversion cost:This proposal may have a high conversion cost for some existing Common Lisp programs. The changes to FUNCTIONP and the FUNCTION type declaration is relatively easy to deal with. However, the strict redefinition of FUNCALL, APPLY and functional arguments will require the addition of an explicit coercion would have to be added whenever a symbol or lambda expression is used as a functional argument. Many suchcases can be identified at compile time, but not all. Some implementations might provide tools to assist in detecting implicit coercion of symbols to functions. For example, an implementation might add run-time test in which the implementation still does the coercion but that issues a warning message whenever the coercion is actually needed. Alternatively, a "smart" code-walker or editor macro might find all of the calls to FUNCALL, APPLY, and the 61 Common Lisp functions that take :TEST or :KEY arguments and, if the argument is not already an explicitly quoted FUNCTION form, wrap a COERCE around the body.  In some current Common Lisp implementations, SETF of SYMBOL-FUNCTION will accept a symbol or lambda expression and SYMBOL-FUNCTION will return this item unchanged.  If a symbol FOO is used as the functional definition of BAR, then any change to FOO will affect BAR as well.  Some old code depends on this behavior and would have to be modified if this proposal is adopted; doing so will be difficult as these uses cannot easily be detected from simple examination of the program. (Such code is not currently portable because many existing Common Lisp implementations already violate these assumptions.  CLtL does not clearly state what values SETF of SYMBOL-FUNCTION will accept and how that object may be modified.)Aesthetics:Making the concept of a function well-defined is a simplification of the language. This proposal is the cleanest of the alternatives; it defines a FUNCTION data type and then requires every object used as a function to be a FUNCTION. While many argue that removing automatic coercion results in a simpler, cleaner, and more aesthetic language definition, others have argued otherwise ("its all a matter of taste.")Discussion:This proposal has been discussed at great length; this section attempts only to summarize the important points.There is general agreement that the definition of the FUNCTION data type must be revised. (There was one suggestion to create a new type name PROCEDURE and a new predicate PROCEDUREP and to leave FUNCTION and FUNCTIONP alone, but it was not generally perceived as acceptable.)  The cleanup of the type hierarchy is important to the CLOS group. There is much more disagreement about disallowing implicit coercions; cleanup of implicit coercions are important for compatibility with other Lisp standards work. One option discussed at length was similar to this proposal, but allowed FUNCALL, APPLY and functions that take functional arguments to accept any object that can be coerced to a function.Some argue that it seems better to make the effort once (to remove the implicit coercion) than to live forever with runtime coercion of functional arguments and the resulting complexity.Some have argued that the coercing form of the proposal is no more complex than the strict form; it is all a matter of taste.If coercing was continued to be allowed, Common Lisp might need an APPLICABLE-P predicate that is true of any object that is legal as a functional argument to APPLY and FUNCALL, since FUNCTIONP would no longer do this job.The description of COMPILE must be changed, since it is no longer meaningful to speak of a symbol with a definition that "is a lambda-expression".  We believe this is a subject for a separate proposal, as the behavior of COMPILE needs additional clarification.This proposal interacts with the proposal on compiler semantics: some claim that strict-redefinition would allow further compiler optimizations, since compiled FUNCALL is not required to go through extensive inline checks. Fahlman, Gabriel, Masinter and Matthews support FUNCTION-TYPE:STRICT-REDEFINITION.Pitman and Moon have expressed support for an alternative proposal which would continue to allow coercion.        TITAN          TITAN           
TIMESROMAN 
          
TIMESROMAN 
                                                                                            +                                p                    
      ?                                                    3 z*start*11242 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 16:02:15 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 14 Nov 87  15:59:56 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 279950; Sat 14-Nov-87 18:59:46 ESTDate: Sat, 14 Nov 87 18:59 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE (Version 8)To: CL-Cleanup@SAIL.Stanford.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <871114185936.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     COMPATIBLE CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)	      14-Nov-87, Version 8 by Pitman (major restructuring)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).Proposal FUNCTION-TYPE:CONSERVATIVE 1. Introduce a new type PROCEDURE that can be used both for declaration    and discrimination.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and PROCEDURE        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of PROCEDURE.        Implementations are free to define other subtypes of PROCEDURE.    1c. Introduce a new function, PROCEDUREP, such that	(PROCEDUREP x) == (TYPEP x 'PROCEDURE). 2. Define that a ``function'' may be a procedure, a list whose car is    the symbol LAMBDA, or any symbol (whether fbound or not).    2a. Clarify that the FUNCTION type behaves as if it had been        defined by:         (DEFUN LAMBDA-P (X) (AND (NOT (ATOM X)) (EQ (CAR X) 'LAMBDA)))         (DEFTYPE FUNCTION ()	   `(OR SYMBOL (SATISFIES LAMBDA-P) PROCEDURE))    2b. Clarify that (FUNCTIONP x) == (TYPEP x 'FUNCTION).        This change is compatible.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Clarify that FUNCALL and APPLY continue to accept functions        as arguments. However, some implementations may produce better	code for expressions such as (FUNCALL (THE PROCEDURE ...) ...)	or (APPLY (THE PROCEDURE ...) ...). 3. Clarify that the result of a FUNCTION special form must be a procedure.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE PROCEDURE (FUNCTION name)). As such, the potential	optimizations mentioned in 2e are also possible for	(FUNCALL (FUNCTION ...) ...) and (APPLY (FUNCTION ...) ...). 4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.    4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(PROCEDUREP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error,	but they are also permitted to define useful (non-portable)	interpretations.    5d. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols.	Implementations are permitted, but not required, to store	information about a global macro-function or special form	in the function cell. This definition of SYMBOL-FUNCTION	is intended to leave enough freedom for such implementations	to conveniently implement FUNCTION, SPECIAL-FORM-P, and	MACRO-FUNCTION using SYMBOL-FUNCTION as the underlying	subprimitive. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'PROCEDURE) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'PROCEDURE) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify *MACROEXPAND-HOOK* is permitted to contain any kind of function.    The function is coerced to a procedure before being called as the    expansion interface hook by MACROEXPAND-1.Rationale: The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' This proposal manages a compatible definition with most existing uses of the term ``function'' while providing a graceful upgrade path to the term ``procedure'' for use in situations that call for a higher degree of clarity.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is the same as (FUNCTIONP x). In some implementations, (TYPEP x 'FUNCTION) is the same as what this  new proposal calls (TYPEP x 'PROCEDURE). Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations are likely to have exactly the semantics described in this proposal, but most are likely to be very close.Adoption Cost: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little or no effort in most implementations. Compiled functions are true functions in almost all current implementations, but in some implementations interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, such lists would have to be changed to be procedures (implemented either as structures or to some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be easily reconstructed if necessary).Benefits: The term ``function'' would be given a useful meaning that was relatively compatible with existing usage. A new term ``procedure'' would be available for descriptional clarity. The type hierarchy would be simplified. The new PROCEDURE datatype would be useful for type discrimination in CLOS. This proposal brings Common Lisp into closer alignment with Scheme and the work of the EuLisp committee. Scheme, for example, also has the concept of a ``procedure'' which is compatible with this proposal. This proposal provides useful constraints which will be of aid to systems doing automatic program analysis for the purpose of ``selective linking.'' Such tools may in turn make it possible to reduce the total size of a delivered application program because only those Common Lisp functions that are actually called need to be included.Conversion cost: The conversion cost associated with this proposal is very low because the model of FUNCTIONP which it takes is largely consistent with existing  practice. The new features introduced by this proposal, particularly the PROCEDURE data type, can be converted to fairly lazily. Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell might have to change. Such code was  already not portable, however, since some implementations signal an error when this is done.Aesthetics: Adding the term ``procedure'' for what has previously been loosely termed a ``true function'' is an aesthetic improvement because it gives a name to a concept which had no formally defined name.Discussion: This proposal has been discussed at great length; this section attempts only to summarize the important points. There is general agreement that the definition of the FUNCTION data type must be clarified or revised. The cleanup of the type hierarchy is important to the CLOS group. There are additional issues which were formally attached to this proposal and are now separated and should be brought up independently as another issue. Key among them is the issue of whether implicit type coercion should be done by functions like APPLY, FUNCALL, MAPCAR, and so on. Or, in the terminology of this proposal, should those functions allow functions or just procedures as arguments? The description of COMPILE must be changed, since it is no longer meaningful to speak of a symbol with a definition that "is a lambda-expression".  We believe this is a subject for a separate proposal, as the behavior of COMPILE needs additional clarification. Pitman supports this restructured proposal.*start*23437 00024 USfDate: 14 Nov 87 18:04 PSTFrom: Masinter.pato: masinterSubject: Issue FUNCTION-TYPE versions 7 and 8, formattedIssue:          FUNCTION-TYPEReferences:     functions (p. 32), types (p. 33), FUNCTIONP (p. 76),                SYMBOL-FUNCTION (p. 90), APPLY (p. 107), COERCE (pp. 51-52)                ... :TEST :KEY arguments (61 occurrances).Category:     	CHANGE/CLARIFICATIONEdit History:   Version 1 by Gabriel 02/26/87                Version 2 by cleanup committee 15-Mar-87                Version 3 by Fahlman 10-May-87                Version 4 by Masinter 29-May-87 incorporate comments                Version 5 by Fahlman 15-June-87 include two options                Version 6 by Masinter 23-Oct-87, only STRICT-REDEFINITION                Version 7 by Masinter  9-Nov-87, minor cleanupProblem Description:The definition of the term `function' in CLtL includes all symbols and many lists in addition to true functions.  The type named `function' is therefore not a useful type, and its presence complicates the type hierarchy. The language would be improved if functions were treated as a type in a consistent and useful manner.  This would also make it easier to integrate the function data type into the CLOS class hierarchy.At present, it is not the case that (FUNCTIONP x) is equivalent to (TYPEP x 'FUNCTION), because the latter form is illegal under a strict reading of the manual.  On page 47 it is stated that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers.  In any event, this issue blurs the status of the FUNCTION data-type.The current confused situation came about mostly because of a desire in the original Common Lisp definition to retain compatibility with older Lisp dialects, but in the context of Common Lisp some of these ancient design decisions are inappropriate.In addition, the practice that APPLY, FUNCALL and the numerous functions that take functional arguments (such as MAPC, MAPCAR, FIND-IF) can potentially do the equivalent of  SYMBOL-FUNCTION to go from a symbol to its functional-value is a serious impediment to program analysis which require the ability to determine by examining a program which functional definitions might be accessed from it. For example, "selective linking" (which would allow a delivery system to include only those parts of the Common Lisp library actually accessed) is seriously hampered by the numerous implicit coercions of symbols to functions.Proposal FUNCTION-TYPE:STRICT-REDEFINITION1. Under this proposal FUNCTION is a full-fledged data type that can be used both for declaration and discrimination.  The list form of the FUNCTION type specifier may still be used only for declaration.Symbols (whether or not the symbol is FBOUNDP) and lambda expressions are not of type FUNCTION under this proposal.The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION are pairwise disjoint.  In particular, a list may not be used to implement any FUNCTION subtype.The COMPILED-FUNCTION subtype of FUNCTION is defined; implementations are free to define subtypes of FUNCTION, e.g., INTERPRETED-FUNCTION.  2. The behavior of FUNCTIONP is defined to be exactly equivalent to #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  In particular, FUNCTIONP is no longer true of symbols and lambda lists.3. FUNCALL and APPLY will now accept only a true function as the functional argument.  This restriction is inherited by all functions in Common Lisp that take a functional argument suitable for FUNCALL or APPLY.  It is no longer legal to pass a symbol or lambda expression as the functional argument to any of these functions; to do so "is an error".4. In all non-error situations, the result of evaluating a FUNCTION special form is required to be of type FUNCTION.  It is an error to use the special form FUNCTION on a symbol that does not denote a function in the lexical environment in which the special form appears. Specifically, it is an error to use the FUNCTION special form on a symbol that denotes a macro or special form.  (Some implementations may choose not to signal this error for performance reasons.)5. If SYMBOL-FUNCTION is called on a symbol that names a function in the null lexical context, it returns that function (which, of course, is of type FUNCTION).  It is an error to call SYMBOL-FUNCTION on anything else.  In particular, it is an error to call SYMBOL-FUNCTION on a symbol that names a macro or special form in the null lexical context; it is unpredictable what will be returned in this case.It is an error to pass anything other than a (true) function as the value to (SETF (SYMBOL-FUNCTION symbol) value).  Some implementations will signal an error in this case; others may accept the object and fail only when the supposed function is called.6. Extend the definition of COERCE to allow coercion of objects to type FUNCTION. That is, "Some symbols and lists may be converted to functions." (COERCE SYMBOL 'FUNCTION) performs SYMBOL-FUNCTION (getting the top level function definition, the current lexical context is not relevant), while (COERCE LIST 'FUNCTION) is equivalent to (EVAL `(FUNCTION ,LIST)), i.e., it creates a function from a LAMBDA expression by interpreting it as a list in the top level lexical environment.7.  Modify the description of the macro expansion process to say that the value of *MACROEXPAND-HOOK* is coerced to a function before being called as the expansion interface hook by MACROEXPAND-1. Rationale:This proposal provides a clean, useful definition for the FUNCTION data-type in Common Lisp.  Under the current definition, FUNCTIONP is nearly useless, since it is defined to be true of all symbols, including those that do not have functional definitions.It also enhances the semantics of Common Lisp functional arguments to be more consistent with other programming languages, and allows better program analysis tools.Current Practice:Current Common Lisp implementations vary in the way they handle FUNCTIONP and TYPEP of FUNCTION.  They also vary in what they will allow to be put into a SYMBOL-FUNCTION cell.  No current Common Lisp implementation has exactly the semantics described in this proposal, however, although it corresponds more closely to Scheme and to the work of the EuLisp community.Adoption Cost:Bringing type predicates (FUNCTIONP, etc.)  into compliance should require little effort.Compiled functions are true functions in almost all current implementations, but in some implementations interpreted functions and closures are represented as lists.  Such lists would have to be changed to structures or to some special internal data type.  The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be modified to deal with functions that are not lists (but from which the list form can be easily reconstructed if necessary).Implementations may choose to convert FUNCALL and APPLY to the new stricter form, but they are not required to do so.  Since the use of a symbol or lambda expression in place of a function "is an error", an implementation may handle these cases as a local extension.  Most implementations that continue to provide the coercion will at least want to install an optional warning in FUNCALL and APPLY to flag the use of this non-portable feature in user code.Benefits:By resurrecting FUNCTION as a useful concept, this proposal (either version) will eliminate a lot of confusion and will make it easier to talk about situations in which (true) functions are passed around as Lisp objects.By eliminating some tangles in the type hierarchy, this proposal simplifies the task of mapping Common Lisp types into CLOS classes.This proposal brings Common Lisp into closer alignment with Scheme and the work of the EuLisp committee.This proposal allows for better program analysis tools, enhances the ability to do "selective linking" correctly. It makes it possible to reduce the total size of a delivered application program. Only those Common Lisp functions that are actually called need to be included; implicit coercions tend to create loopholes through which *every* function might be called.Conversion cost:This proposal may have a high conversion cost for some existing Common Lisp programs. The changes to FUNCTIONP and the FUNCTION type declaration is relatively easy to deal with. However, the strict redefinition of FUNCALL, APPLY and functional arguments will require the addition of an explicit coercion would have to be added whenever a symbol or lambda expression is used as a functional argument. Many suchcases can be identified at compile time, but not all. Some implementations might provide tools to assist in detecting implicit coercion of symbols to functions. For example, an implementation might add run-time test in which the implementation still does the coercion but that issues a warning message whenever the coercion is actually needed. Alternatively, a "smart" code-walker or editor macro might find all of the calls to FUNCALL, APPLY, and the 61 Common Lisp functions that take :TEST or :KEY arguments and, if the argument is not already an explicitly quoted FUNCTION form, wrap a COERCE around the body.  In some current Common Lisp implementations, SETF of SYMBOL-FUNCTION will accept a symbol or lambda expression and SYMBOL-FUNCTION will return this item unchanged.  If a symbol FOO is used as the functional definition of BAR, then any change to FOO will affect BAR as well.  Some old code depends on this behavior and would have to be modified if this proposal is adopted; doing so will be difficult as these uses cannot easily be detected from simple examination of the program. (Such code is not currently portable because many existing Common Lisp implementations already violate these assumptions.  CLtL does not clearly state what values SETF of SYMBOL-FUNCTION will accept and how that object may be modified.)Aesthetics:Making the concept of a function well-defined is a simplification of the language. This proposal is the cleanest of the alternatives; it defines a FUNCTION data type and then requires every object used as a function to be a FUNCTION. While many argue that removing automatic coercion results in a simpler, cleaner, and more aesthetic language definition, others have argued otherwise ("its all a matter of taste.")Discussion:This proposal has been discussed at great length; this section attempts only to summarize the important points.There is general agreement that the definition of the FUNCTION data type must be revised. (There was one suggestion to create a new type name PROCEDURE and a new predicate PROCEDUREP and to leave FUNCTION and FUNCTIONP alone, but it was not generally perceived as acceptable.)  The cleanup of the type hierarchy is important to the CLOS group. There is much more disagreement about disallowing implicit coercions; cleanup of implicit coercions are important for compatibility with other Lisp standards work. One option discussed at length was similar to this proposal, but allowed FUNCALL, APPLY and functions that take functional arguments to accept any object that can be coerced to a function.Some argue that it seems better to make the effort once (to remove the implicit coercion) than to live forever with runtime coercion of functional arguments and the resulting complexity.Some have argued that the coercing form of the proposal is no more complex than the strict form; it is all a matter of taste.If coercing was continued to be allowed, Common Lisp might need an APPLICABLE-P predicate that is true of any object that is legal as a functional argument to APPLY and FUNCALL, since FUNCTIONP would no longer do this job.The description of COMPILE must be changed, since it is no longer meaningful to speak of a symbol with a definition that "is a lambda-expression".  We believe this is a subject for a separate proposal, as the behavior of COMPILE needs additional clarification.This proposal interacts with the proposal on compiler semantics: some claim that strict-redefinition would allow further compiler optimizations, since compiled FUNCALL is not required to go through extensive inline checks. Fahlman, Gabriel, Masinter and Matthews support FUNCTION-TYPE:STRICT-REDEFINITION.Pitman and Moon have expressed support for an alternative proposal which would continue to allow coercion.Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     COMPATIBLE CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)	      14-Nov-87, Version 8 by Pitman (major restructuring)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).Proposal FUNCTION-TYPE:CONSERVATIVE 1. Introduce a new type PROCEDURE that can be used both for declaration    and discrimination.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and PROCEDURE        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of PROCEDURE.        Implementations are free to define other subtypes of PROCEDURE.    1c. Introduce a new function, PROCEDUREP, such that	(PROCEDUREP x) == (TYPEP x 'PROCEDURE). 2. Define that a ``function'' may be a procedure, a list whose car is    the symbol LAMBDA, or any symbol (whether fbound or not).    2a. Clarify that the FUNCTION type behaves as if it had been        defined by:         (DEFUN LAMBDA-P (X) (AND (NOT (ATOM X)) (EQ (CAR X) 'LAMBDA)))         (DEFTYPE FUNCTION ()	   `(OR SYMBOL (SATISFIES LAMBDA-P) PROCEDURE))    2b. Clarify that (FUNCTIONP x) == (TYPEP x 'FUNCTION).        This change is compatible.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Clarify that FUNCALL and APPLY continue to accept functions        as arguments. However, some implementations may produce better	code for expressions such as (FUNCALL (THE PROCEDURE ...) ...)	or (APPLY (THE PROCEDURE ...) ...). 3. Clarify that the result of a FUNCTION special form must be a procedure.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE PROCEDURE (FUNCTION name)). As such, the potential	optimizations mentioned in 2e are also possible for	(FUNCALL (FUNCTION ...) ...) and (APPLY (FUNCTION ...) ...). 4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.    4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(PROCEDUREP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error,	but they are also permitted to define useful (non-portable)	interpretations.    5d. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols.	Implementations are permitted, but not required, to store	information about a global macro-function or special form	in the function cell. This definition of SYMBOL-FUNCTION	is intended to leave enough freedom for such implementations	to conveniently implement FUNCTION, SPECIAL-FORM-P, and	MACRO-FUNCTION using SYMBOL-FUNCTION as the underlying	subprimitive. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'PROCEDURE) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'PROCEDURE) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify *MACROEXPAND-HOOK* is permitted to contain any kind of function.    The function is coerced to a procedure before being called as the    expansion interface hook by MACROEXPAND-1.Rationale: The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' This proposal manages a compatible definition with most existing uses of the term ``function'' while providing a graceful upgrade path to the term ``procedure'' for use in situations that call for a higher degree of clarity.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is the same as (FUNCTIONP x). In some implementations, (TYPEP x 'FUNCTION) is the same as what this  new proposal calls (TYPEP x 'PROCEDURE). Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations are likely to have exactly the semantics described in this proposal, but most are likely to be very close.Adoption Cost: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little or no effort in most implementations. Compiled functions are true functions in almost all current implementations, but in some implementations interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, such lists would have to be changed to be procedures (implemented either as structures or to some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be easily reconstructed if necessary).Benefits: The term ``function'' would be given a useful meaning that was relatively compatible with existing usage. A new term ``procedure'' would be available for descriptional clarity. The type hierarchy would be simplified. The new PROCEDURE datatype would be useful for type discrimination in CLOS. This proposal brings Common Lisp into closer alignment with Scheme and the work of the EuLisp committee. Scheme, for example, also has the concept of a ``procedure'' which is compatible with this proposal. This proposal provides useful constraints which will be of aid to systems doing automatic program analysis for the purpose of ``selective linking.'' Such tools may in turn make it possible to reduce the total size of a delivered application program because only those Common Lisp functions that are actually called need to be included.Conversion cost: The conversion cost associated with this proposal is very low because the model of FUNCTIONP which it takes is largely consistent with existing  practice. The new features introduced by this proposal, particularly the PROCEDURE data type, can be converted to fairly lazily. Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell might have to change. Such code was  already not portable, however, since some implementations signal an error when this is done.Aesthetics: Adding the term ``procedure'' for what has previously been loosely termed a ``true function'' is an aesthetic improvement because it gives a name to a concept which had no formally defined name.Discussion: This proposal has been discussed at great length; this section attempts only to summarize the important points. There is general agreement that the definition of the FUNCTION data type must be clarified or revised. The cleanup of the type hierarchy is important to the CLOS group. There are additional issues which were formally attached to this proposal and are now separated and should be brought up independently as another issue. Key among them is the issue of whether implicit type coercion should be done by functions like APPLY, FUNCALL, MAPCAR, and so on. Or, in the terminology of this proposal, should those functions allow functions or just procedures as arguments? The description of COMPILE must be changed, since it is no longer meaningful to speak of a symbol with a definition that "is a lambda-expression".  We believe this is a subject for a separate proposal, as the behavior of COMPILE needs additional clarification. Pitman supports this restructured proposal.        TITAN 
          TITAN 
         TITAN 
                                                                               +                                p                    
      ?                                             )      Z9 z*start*00939 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 15 NOV 87 18:55:16 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 15 Nov 87  18:53:24 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 15 Nov 87 21:53:00-ESTDate: Sun, 15 Nov 87 21:52 ESTMessage-ID: <FAHLMAN.12350946040.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Issue: FUNCTION-TYPE (Version 8)In-reply-to: Msg of 14 Nov 1987  18:59-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>I still favor version 7.  Maybe splitting this into two distinctproposals makes sense, but I'm not sure that I want either part if Ican't have both, so there's also a case to be made for keeping it in onelump.-- Scott*start*01711 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 NOV 87 14:44:13 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 23 Nov 87  14:42:24 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 NOV 87 14:41:29 PSTDate: 23 Nov 87 14:41 PSTFrom: Masinter.paSubject: Re: Issue: FUNCTION-TYPE (Version 8)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Sat, 14 Nov 87 18:59 ESTTo: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <871123-144129-2814@Xerox>I believe this issue may well come to a vote -- i.e., not decided byconsensus. There are fairly strong feelings on both sides of thecoercion issue. I don't think it is ready for a vote until it is clear that the folksvoting understand the issue and its ramification. There were enoughquestions and incorrect assumptions at X3J13 that I believe we need towork harder to explain the issues.There were several folks who believed that removing coercion removedlate binding in several circumstances.One example:(mapcar 'frob my-list)if, during the course of execution of frob, one should hit a breakpointand redefine frob, would subsequent iterations get the new definition?More examples of the coercion are called for, I think.Frankly, I didn't detect any large amount of enthusiasm for introducinga new name PROCEDURE in order to avoid stepping on the currentdefinition of FUNCTION. Do any of you have any additional comments onthis, one way or another?Someone afterward said that Kent had put up an example of why coercingwas important ... this seems important to add to the proposal.*start*01316 00024 USaReturn-Path: <@STONY-BROOK.SCRC.Symbolics.COM,@RIO-DE-JANEIRO.SCRC.Symbolics.COM:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 23 NOV 87 15:27:18 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 287239; 23 Nov 87 18:27:04 ESTDate: Mon, 23 Nov 87 18:26 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-TYPE (Version 8)To: Masinter.pacc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <871123-144129-2814@Xerox>Message-ID: <871123182652.2.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>[CL-Cleanup removed.]If you like, I would be happy to write up a straw-man proposal fora new topic, FUNCTION-COERCION (to make up for having dropped it outof revision 8 of FUNCTION-TYPE). I will cast the proposal in thepositive form as if it were written by Will and just make a notein the discussion saying that I don't concur. Someone can then takeit and clean it up to be more firm if they don't think I did a good job.I had some comments on my FUNCTION-TYPE that I think are importantto add to motivation based on discussions I had with people, etc.I may submit another round of revision on that to flesh it out.*start*17781 00024 US Date: 13 Feb 88 16:14 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE (version 9)TO: CL-CLEANUP@SAIL.STANFORD.EDULINE-FOLD: NOcc: MasinterI've left the CONSERVATIVE proposal pretty much intact, and attempted to add back in the STRICT-REDEFINITION proposal as an alternative proposal with a shared cost/benefit analysis. We really owe X3J13 a version they can vote on, and I think that this is one issue that is big enough and thorny enough that we can ask for votes on more than one alternative. Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     COMPATIBLE CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)              14-Nov-87, Version 8 by Pitman (major restructuring)              13-Feb-88, Version 9 by Masinter, (add back 2nd option)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).Proposal FUNCTION-TYPE:CONSERVATIVE 1. Introduce a new type PROCEDURE that can be used both for declaration    and discrimination.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and PROCEDURE        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of PROCEDURE.        Implementations are free to define other subtypes of PROCEDURE.    1c. Introduce a new function, PROCEDUREP, such that	(PROCEDUREP x) == (TYPEP x 'PROCEDURE). 2. Define that a ``function'' may be a procedure, a list whose car is    the symbol LAMBDA, or any symbol (whether fbound or not).    2a. Clarify that the FUNCTION type behaves as if it had been        defined by:         (DEFUN LAMBDA-P (X) (AND (NOT (ATOM X)) (EQ (CAR X) 'LAMBDA)))         (DEFTYPE FUNCTION ()	   `(OR SYMBOL (SATISFIES LAMBDA-P) PROCEDURE))    2b. Clarify that (FUNCTIONP x) == (TYPEP x 'FUNCTION).        This change is compatible.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Clarify that FUNCALL and APPLY continue to accept functions        as arguments. However, some implementations may produce better	code for expressions such as (FUNCALL (THE PROCEDURE ...) ...)	or (APPLY (THE PROCEDURE ...) ...). 3. Clarify that the result of a FUNCTION special form must be a procedure.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE PROCEDURE (FUNCTION name)). As such, the potential	optimizations mentioned in 2e are also possible for	(FUNCALL (FUNCTION ...) ...) and (APPLY (FUNCTION ...) ...). 4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.    4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(PROCEDUREP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error,	but they are also permitted to define useful (non-portable)	interpretations.    5d. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols.	Implementations are permitted, but not required, to store	information about a global macro-function or special form	in the function cell. This definition of SYMBOL-FUNCTION	is intended to leave enough freedom for such implementations	to conveniently implement FUNCTION, SPECIAL-FORM-P, and	MACRO-FUNCTION using SYMBOL-FUNCTION as the underlying	subprimitive. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'PROCEDURE) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'PROCEDURE) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify *MACROEXPAND-HOOK* is permitted to contain any kind of function.    The function is coerced to a procedure before being called as the    expansion interface hook by MACROEXPAND-1.Proposal FUNCTION-TYPE:STRICT-REDEFINITIONSTRICT-REDEFINITION is similar to CONSERVATIVE, except that it redefinesthe type FUNCTION instead of adding a new type PROCEDURE, and it restrictscoercion by functions that take functions as arguments. The numbering ofCONSERVATIVE is preserved for comparison. 1.  Redefine the type FUNCTION so that it can be used for discrimination     as well as declaration.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of FUNCTION.        Implementations are free to define other subtypes of FUNCTION. 2. Define that a ``function'' as used throughout the CLtL is restricted    to be exactly those objects of type FUNCTION.    2a. This type no longer includes objects of type SYMBOL or lists        with CAR = LAMBDA.    2b. The behavior of FUNCTIONP is defined to be exactly equivalent to        #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  This is an incompatible        change.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Change FUNCALL and APPLY such that they accept only a function        as the functional argument.  This restriction is inherited by        all functions in Common Lispthat take a functional argument.         It is no longer legal to pass a symbol or lambda expression as        the functional argument to any of these functions; to do so        "is an error". 3. Clarify that the result of a FUNCTION special form must be a function.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	  as (THE FUNCTION (FUNCTION name)).  4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.        4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(FUNCTIONP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error.    5d.  The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'FUNCTION) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'FUNCTION) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify that the value of *MACROEXPAND-HOOK* is first coerced to a    function before being called as the    expansion interface hook by MACROEXPAND-1.Rationale:Since the two proposals are similar, they are discussed together. Wheremotiviation and justification differ, the proposals are referred to byname (STRICT-REDEFINITION, CONSERVATIVE.) The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' CONSERVATIVE manages a compatible definition with most existing uses of the term ``function'' while providing a graceful upgrade path to the term ``procedure'' for use in situations that call for a higher degree of clarity. STRICT-REDEFINITION avoids introducing a new term at the cost of incompatible change.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is the same as (FUNCTIONP x). In some implementations, (TYPEP x 'FUNCTION) is the same as what this  new proposal calls (TYPEP x 'PROCEDURE). Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations are likely to have exactly the semantics described in either. CONSERVATIVE is more compatible with current practice than STRICT-REDEFINITION, however.Cost to Implementors: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little effort in most implementations. While STRICT-REDEFINITION makes it an error to pass non-function arguments to APPLY, FUNCALL etc, there is no requirement to check for that error. Compiled functions are true functions in almost all current implementations, but in some implementations interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, such lists would have to be changed to be procedures (implemented either as structures or to some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be reconstructed if necessary).Cost to Users: The conversion cost associated with CONSERVATIVE is very low because the model of FUNCTIONP which it takes is largely consistent with existing  practice. The new features introduced by CONSERVATIVE, particularly the PROCEDURE data type, can be converted to fairly lazily. The conversion cost for the STRICT-REDEFINITION proposal is higher. The changes to FUNCTIONP and the FUNCTION type declaration is relatively easy to deal with. However, the strict redefinition of FUNCALL, APPLY and functional arguments will require the addition of an explicit coercion would have to be added whenever a symbol or lambda expression is used as a functional argument. Many such cases can be identified at compile time, but not all.  Some implementations might provide tools to assist in detecting implicit coercion of symbols to functions. For example, an implementation might add run-time test in which the implementation still does the coercion but that issues a warning message whenever the coercion is actually needed. Alternatively, a "smart" code-walker or editor macro might find all of the calls to FUNCALL, APPLY, and the 61 Common Lisp functions that take :TEST or :KEY arguments and, if the argument is not already an explicitly quoted FUNCTION form, wrap a COERCE around the body.   For either proposal: Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell might have to change. Such code was  already not portable, however, since some implementations signal an error when this is done.Benefits: For CONSERVATIVE:   The term ``function'' would be given a useful meaning that was relatively   compatible with existing usage.   A new term ``procedure'' would be available for descriptional clarity.   The new PROCEDURE datatype would be useful for type discrimination in CLOS. For STRICT-REDEFINITION:   The term ``function'' would be given a useful and precise meaning.   The FUNCTION datatype would be useful for type discrimination in CLOS. STRICT-REDEFINITION provides useful constraints which will be of aid to systems doing automatic program analysis for the purpose of ``selective linking.'' Such tools may in turn make it possible to reduce the total size of a delivered application program because only those Common Lisp functions that are actually called need to be included. For either proposal:   The type hierarchy would be simplified.   Either proposal brings Common Lisp into closer alignment with Scheme and   the work of the EuLisp committee. Scheme, for example, also has the concept   of a ``procedure'' which is compatible with this proposal.Aesthetics: Both proposals improve the aesthetics of the language.Discussion: These proposals have been discussed at great length; this section attempts only to summarize the important points. There is general agreement that the definition of the FUNCTION data type must be clarified or revised. The cleanup of the type hierarchy is important to the CLOS group. The description of COMPILE must be changed, since it is no longer meaningful to speak of a symbol with a definition that "is a lambda-expression".  We believe this is a subject for a separate proposal, as the behavior of COMPILE needs additional clarification. Many different alternatives have been discussed both in the cleanup committee and X3J13. These two proposals are the distillation of the alternatives.  The CONSERVATIVE proposal offers the advantage of backward compatibility, and considerably more flexibility in the language. The STRICT-REDEFINITION proposal offers the advantage of a slightly cleaner resulting language.  Some concerns were raised about STRICT-REDEFINITION in a previous discussion about "late binding" of function definitions. Neither proposal disallows late binding of symbols to functions. For example, in the call  (MAPCAR #'FROB my-list)  the effect of the FUNCTION special form (as generated by the #' read macro) is to obtain the function definition of FROB at the time the #'FROB is evaluated. Neither proposal changes this.  Currently, it is allowed to write  (MAPCAR 'FROB my-list) while this form would no longer be allowed under the STRICT-REDEFINITION clause. Currently, neither CLtL nor the CONSERVATIVE proposal addresses the question of the time at which FROB's function definition is obtained; if, during the processing of my-list, FROB is redefined, it is not clear whether the processing of subsequent elements would be changed.        TITAN 
          TITAN 
         
TIMESROMAN 
                       +                   e                          \             m       
                   D z*start*17918 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 FEB 88 16:18:25 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Feb 88  16:15:04 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 13 FEB 88 16:15:39 PSTDate: 13 Feb 88 16:14 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE (version 9)TO: CL-CLEANUP@SAIL.STANFORD.EDULINE-FOLD: NOcc: Masinter.paMessage-ID: <880213-161539-10473@Xerox>I've left the CONSERVATIVE proposal pretty much intact, and attempted to add back in the STRICT-REDEFINITION proposal as an alternative proposal with a shared cost/benefit analysis. We really owe X3J13 a version they can vote on, and I think that this is one issue that is big enough and thorny enough that we can ask for votes on more than one alternative. !Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     COMPATIBLE CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)              14-Nov-87, Version 8 by Pitman (major restructuring)              13-Feb-88, Version 9 by Masinter, (add back 2nd option)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).Proposal FUNCTION-TYPE:CONSERVATIVE 1. Introduce a new type PROCEDURE that can be used both for declaration    and discrimination.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and PROCEDURE        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of PROCEDURE.        Implementations are free to define other subtypes of PROCEDURE.    1c. Introduce a new function, PROCEDUREP, such that	(PROCEDUREP x) == (TYPEP x 'PROCEDURE). 2. Define that a ``function'' may be a procedure, a list whose car is    the symbol LAMBDA, or any symbol (whether fbound or not).    2a. Clarify that the FUNCTION type behaves as if it had been        defined by:         (DEFUN LAMBDA-P (X) (AND (NOT (ATOM X)) (EQ (CAR X) 'LAMBDA)))         (DEFTYPE FUNCTION ()	   `(OR SYMBOL (SATISFIES LAMBDA-P) PROCEDURE))    2b. Clarify that (FUNCTIONP x) == (TYPEP x 'FUNCTION).        This change is compatible.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Clarify that FUNCALL and APPLY continue to accept functions        as arguments. However, some implementations may produce better	code for expressions such as (FUNCALL (THE PROCEDURE ...) ...)	or (APPLY (THE PROCEDURE ...) ...). 3. Clarify that the result of a FUNCTION special form must be a procedure.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE PROCEDURE (FUNCTION name)). As such, the potential	optimizations mentioned in 2e are also possible for	(FUNCALL (FUNCTION ...) ...) and (APPLY (FUNCTION ...) ...). 4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.    4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarifythat it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(PROCEDUREP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error,	but they are also permitted to define useful (non-portable)	interpretations.    5d. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols.	Implementations are permitted, but not required, to store	information about a global macro-function or special form	in the function cell. This definition of SYMBOL-FUNCTION	is intended to leave enough freedom for such implementations	to conveniently implement FUNCTION, SPECIAL-FORM-P, and	MACRO-FUNCTION using SYMBOL-FUNCTION as the underlying	subprimitive. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'PROCEDURE) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'PROCEDURE) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify *MACROEXPAND-HOOK* is permitted to contain any kind of function.    The function is coerced to a procedure before being called as the    expansion interface hook by MACROEXPAND-1.!Proposal FUNCTION-TYPE:STRICT-REDEFINITIONSTRICT-REDEFINITION is similar to CONSERVATIVE, except that it redefinesthe type FUNCTION instead of adding a new type PROCEDURE, and it restrictscoercion by functions that take functions as arguments. The numbering ofCONSERVATIVE is preserved for comparison. 1.  Redefine the type FUNCTION so that it can be used for discrimination     as well as declaration.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of FUNCTION.        Implementations are free to define other subtypes of FUNCTION. 2. Define that a ``function'' as used throughout the CLtL is restricted    to be exactly those objects of type FUNCTION.    2a. This type no longer includes objects of type SYMBOL or lists        with CAR = LAMBDA.    2b. The behavior of FUNCTIONP is defined to be exactly equivalent to        #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  This is an incompatible        change.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Change FUNCALL and APPLY such that they accept only a function        as the functional argument.  This restriction is inherited by        all functions in Common Lispthat take a functional argument.         It is no longer legal to pass a symbol or lambda expression as        the functional argument to any of these functions; to do so        "is an error". 3. Clarify that the result of a FUNCTION special form must be a function.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	  as (THE FUNCTION (FUNCTION name)).  4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.        4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(FUNCTIONP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error.    5d.  The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'FUNCTION) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'FUNCTION) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify that the value of *MACROEXPAND-HOOK* is first coerced to a    function before being called as the    expansion interface hook by MACROEXPAND-1.!Rationale:Since the two proposals are similar, they are discussed together. Wheremotiviation and justification differ, the proposals are referred to byname (STRICT-REDEFINITION, CONSERVATIVE.) The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' CONSERVATIVE manages a compatible definition with most existing uses of the term ``function'' while providing a graceful upgrade path to the term ``procedure'' for use in situations that call for a higher degree of clarity. STRICT-REDEFINITION avoids introducing a new term at the cost of incompatible change.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is the same as (FUNCTIONP x). In some implementations, (TYPEP x 'FUNCTION) is the same as what this  new proposal calls (TYPEP x 'PROCEDURE). Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations are likely to have exactly the semantics described in either. CONSERVATIVE is more compatible with current practice than STRICT-REDEFINITION, however.Cost to Implementors: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little effort in most implementations. While STRICT-REDEFINITION makes it an error to pass non-function arguments to APPLY, FUNCALL etc, there is no requirement to check for that error. Compiled functions are true functions in almost all current implementations, but in some implementations interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, such lists would have to be changed to be procedures (implemented either as structures or to some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be reconstructed if necessary).Cost to Users: The conversion cost associated with CONSERVATIVE is very low because the model of FUNCTIONP which it takes is largely consistent with existing  practice. The new features introduced by CONSERVATIVE, particularly the PROCEDURE data type, can be converted to fairly lazily. The conversion cost for the STRICT-REDEFINITION proposal is higher. The changes to FUNCTIONP and the FUNCTION type declaration is relatively easy to deal with. However, the strict redefinition of FUNCALL, APPLY and functional arguments will require the addition of an explicit coercion would have to be added whenever a symbol or lambda expression is used as a functional argument. Many such cases can be identified at compile time, but not all.  Some implementations might provide tools to assist in detecting implicit coercion of symbols to functions. For example, an implementation might add run-time test in which the implementation still does the coercion but that issues a warning message whenever the coercion is actually needed. Alternatively, a "smart" code-walker or editor macro might find all of the calls to FUNCALL, APPLY, and the 61 Common Lisp functions that take :TEST or :KEY arguments and, if the argument is not already an explicitly quoted FUNCTION form, wrap a COERCE around the body.   For either proposal: Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell might have to change. Such code was  already not portable, however, since some implementations signal an error when this is done.Benefits: For CONSERVATIVE:   The term ``function'' would be given a useful meaning that was relatively   compatible with existing usage.   A new term ``procedure'' would be available for descriptional clarity.   The new PROCEDURE datatype would be useful for type discrimination in CLOS. For STRICT-REDEFINITION:   The term ``function'' would be given a useful and precise meaning.   The FUNCTION datatype would be useful for type discrimination in CLOS. STRICT-REDEFINITION provides useful constraints which will be of aid to systems doing automatic program analysis for the purpose of ``selective linking.'' Such tools may in turn make it possible to reduce the total size of a delivered application program because only those Common Lisp functions that are actually called need to be included. For either proposal:   The type hierarchy would be simplified.   Either proposal brings Common Lisp into closer alignment with Scheme and   the work of the EuLisp committee. Scheme, for example, also has the concept   of a ``procedure'' which is compatible with this proposal.Aesthetics: Both proposals improve the aesthetics of the language.Discussion: These proposals have been discussed at great length; this section attempts only to summarize the important points. There is general agreement that the definition of the FUNCTION data type must be clarified or revised. The cleanup of the type hierarchy is important to the CLOS group. The description of COMPILE must be changed, since it is no longer meaningful to speak of a symbol with a definition that "is a lambda-expression".  We believe this is a subject for a separate proposal, as the behavior of COMPILE needs additional clarification. Many different alternatives have been discussed both in the cleanup committee and X3J13. These two proposals are the distillation of the alternatives.  The CONSERVATIVE proposal offers the advantage of backward compatibility, and considerably more flexibility in the language. The STRICT-REDEFINITION proposal offers the advantage of a slightly cleaner resulting language.  Some concerns were raised about STRICT-REDEFINITION in a previous discussion about "late binding" of function definitions. Neither proposal disallows late binding of symbols to functions. For example, in the call  (MAPCAR #'FROB my-list)  the effect of the FUNCTION special form (as generated by the #' read macro) is to obtain the function definition of FROB at the time the #'FROB is evaluated. Neither proposal changes this.  Currently, it is allowed to write  (MAPCAR 'FROB my-list) while this form would no longer be allowed under the STRICT-REDEFINITION clause. Currently, neither CLtL nor the CONSERVATIVE proposal addresses the question of the time at which FROB's function definition is obtained; if, during the processing of my-list, FROB is redefined, it is not clear whether the processing of subsequent elements would be changed.*start*17764 00024 US Date: 14 Feb 88 12:55 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE (version 9)To: X3J13@Sail.stanford.educc: Masinterreply-to: CL-CLEANUP@Sail.Stanford.EDULINE-FOLD: NOThis is a difficult issue. The issue was discussed both at the June and November 1987 meetings. There seem to be strong opinions along several different dimensions.This version of the issue writeup contains two different proposals.Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)              14-Nov-87, Version 8 by Pitman (major restructuring)              13-Feb-88, Version 9 by Masinter, (add back 2nd option)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).There are two proposals for dealing with this issue.Proposal FUNCTION-TYPE:CONSERVATIVE 1. Introduce a new type PROCEDURE that can be used both for declaration    and discrimination.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and PROCEDURE        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of PROCEDURE.        Implementations are free to define other subtypes of PROCEDURE.    1c. Introduce a new function, PROCEDUREP, such that	(PROCEDUREP x) == (TYPEP x 'PROCEDURE). 2. Define that a ``function'' may be a procedure, a list whose car is    the symbol LAMBDA, or any symbol (whether fbound or not).    2a. Clarify that the FUNCTION type behaves as if it had been        defined by:         (DEFUN LAMBDA-P (X) (AND (NOT (ATOM X)) (EQ (CAR X) 'LAMBDA)))         (DEFTYPE FUNCTION ()	   `(OR SYMBOL (SATISFIES LAMBDA-P) PROCEDURE))    2b. Clarify that (FUNCTIONP x) == (TYPEP x 'FUNCTION).        This change is compatible.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Clarify that FUNCALL and APPLY continue to accept functions        as arguments. However, some implementations may produce better	code for expressions such as (FUNCALL (THE PROCEDURE ...) ...)	or (APPLY (THE PROCEDURE ...) ...). 3. Clarify that the result of a FUNCTION special form must be a procedure.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE PROCEDURE (FUNCTION name)). As such, the potential	optimizations mentioned in 2e are also possible for	(FUNCALL (FUNCTION ...) ...) and (APPLY (FUNCTION ...) ...). 4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.    4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(PROCEDUREP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error,	but they are also permitted to define useful (non-portable)	interpretations.    5d. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols.	Implementations are permitted, but not required, to store	information about a global macro-function or special form	in the function cell. This definition of SYMBOL-FUNCTION	is intended to leave enough freedom for such implementations	to conveniently implement FUNCTION, SPECIAL-FORM-P, and	MACRO-FUNCTION using SYMBOL-FUNCTION as the underlying	subprimitive. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'PROCEDURE) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'PROCEDURE) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify *MACROEXPAND-HOOK* is permitted to contain any kind of function.    The function is coerced to a procedure before being called as the    expansion interface hook by MACROEXPAND-1.Proposal FUNCTION-TYPE:STRICT-REDEFINITIONSTRICT-REDEFINITION is similar to CONSERVATIVE, except that it redefinesthe type FUNCTION instead of adding a new type PROCEDURE, and it restrictscoercion by functions that take functions as arguments. The numbering ofCONSERVATIVE is preserved for comparison. 1.  Redefine the type FUNCTION so that it can be used for discrimination     as well as declaration.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of FUNCTION.        Implementations are free to define other subtypes of FUNCTION. 2. Define that a ``function'' as used throughout the CLtL is restricted    to be exactly those objects of type FUNCTION.    2a. This type no longer includes objects of type SYMBOL or lists        with CAR = LAMBDA.    2b. The behavior of FUNCTIONP is defined to be exactly equivalent to        #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  This is an incompatible        change.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Change FUNCALL and APPLY such that they accept only a function        as the functional argument.  This restriction is inherited by        all functions in Common Lispthat take a functional argument.         It is no longer legal to pass a symbol or lambda expression as        the functional argument to any of these functions; to do so        "is an error". 3. Clarify that the result of a FUNCTION special form must be a function.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	  as (THE FUNCTION (FUNCTION name)).  4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.        4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(FUNCTIONP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error.    5d.  The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'FUNCTION) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'FUNCTION) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify that the value of *MACROEXPAND-HOOK* is first coerced to a    function before being called as the    expansion interface hook by MACROEXPAND-1.Rationale:Since the two proposals are similar, they are discussed together. Wheremotiviation and justification differ, the proposals are referred to byname (STRICT-REDEFINITION, CONSERVATIVE.) The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' CONSERVATIVE manages a compatible definition with most existing uses of the term ``function'' while providing a graceful upgrade path to the term ``procedure'' for use in situations that call for a higher degree of clarity. STRICT-REDEFINITION avoids introducing a new term at the cost of incompatible change.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is the same as (FUNCTIONP x). In some implementations, (TYPEP x 'FUNCTION) is the same as what CONSERVATIVE calls (TYPEP x 'PROCEDURE). Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations are likely to have exactly the semantics described in either. CONSERVATIVE is more compatible with current practice than STRICT-REDEFINITION, however.Cost to Implementors: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little effort in most implementations. While STRICT-REDEFINITION makes it an error to pass non-function arguments to APPLY, FUNCALL etc, there is no requirement to check for that error. Compiled functions are true functions in almost all current implementations, but in many implementations, interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, this representation would have to be different (implemented either as structures or to some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be reconstructed if necessary).Cost to Users: The conversion cost associated with CONSERVATIVE is very low because the model of FUNCTIONP which it takes is largely consistent with existing  practice. The new features introduced by CONSERVATIVE, particularly the PROCEDURE data type, can be converted to fairly lazily. The conversion cost for the STRICT-REDEFINITION proposal is higher. The changes to FUNCTIONP and the FUNCTION type declaration is relatively easy to deal with. However, the strict redefinition of FUNCALL, APPLY and functional arguments will require the addition of an explicit coercion would have to be added whenever a symbol or lambda expression is used as a functional argument. Many such cases can be identified at compile time, but not all.  Some implementations might provide tools to assist in detecting implicit coercion of symbols to functions. For example, an implementation might add run-time test in which the implementation still does the coercion but that issues a warning message whenever the coercion is actually needed. Alternatively, a "smart" code-walker or editor macro might find all of the calls to FUNCALL, APPLY, and the 61 Common Lisp functions that take :TEST or :KEY arguments and, if the argument is not already an explicitly quoted FUNCTION form, wrap a COERCE around the body.   For either proposal: Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell might have to change. Such code was  already not portable, however, since some implementations signal an error when this is done.Benefits:For CONSERVATIVE: The term ``function'' would be given a useful meaning that was relatively compatible with existing usage. A new term ``procedure'' would be available for descriptional clarity. The new PROCEDURE datatype would be useful for type discrimination in CLOS.For STRICT-REDEFINITION: The term ``function'' would be given a useful and precise meaning. The FUNCTION datatype would be useful for type discrimination in CLOS. STRICT-REDEFINITION provides useful constraints which will be of aid to systems doing automatic program analysis for the purpose of ``selective linking.'' Such tools may in turn make it possible to reduce the total size of a delivered application program because only those Common Lisp functions that are actually called need to be included.For either proposal:The type hierarchy would be simplified.Either proposal brings Common Lisp into closer alignment with Scheme andthe work of the EuLisp committee. Scheme, for example, also has the conceptof a ``procedure'' which is compatible with this proposal.Aesthetics: Both proposals improve the aesthetics of the language.Discussion:These proposals have been discussed at great length; this section attemptsonly to summarize the important points.There is general agreement that the definition of the FUNCTION data typemust be clarified or revised. The cleanup of the type hierarchy is importantto the CLOS group.The description of COMPILE must be changed, since it is no longermeaningful to speak of a symbol with a definition that "is alambda-expression".  We believe this is a subject for a separateproposal, as the behavior of COMPILE needs additional clarification.Many different alternatives have been discussed both in the cleanup committeeand X3J13. These two proposals are the distillation of the alternatives. The CONSERVATIVE proposal offers the advantage of backward compatibility,and considerably more flexibility in the language.The STRICT-REDEFINITION proposal offers the advantage of a slightly cleanerresulting language. Some concerns were raised about STRICT-REDEFINITION in a previous discussionabout "late binding" of function definitions. Neither proposal disallowslate binding of symbols to functions. For example, in the call  (MAPCAR #'FROB my-list)the effect of the FUNCTION special form (as generated by the #' read macro)is to obtain the function definition of FROB at the time the #'FROB isevaluated. Neither proposal changes this.Currently, it is allowed to write(MAPCAR 'FROB my-list)while this form would no longer be allowed under the STRICT-REDEFINITIONclause. Currently, neither CLtL nor the CONSERVATIVE proposal addressesthe question of the time at which FROB's function definition is obtained;if, during the processing of my-list, FROB is redefined, it is not clearwhether the processing of subsequent elements would be changed.        TITAN 
          TITAN 
                                     s                           #                    $      *       +                   e                          W             m       
      *              :                   D z*start*01343 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 FEB 88 09:41:39 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 16 Feb 88  09:39:23 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA23751; Tue, 16 Feb 88 10:39:08 MSTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA25191; Tue, 16 Feb 88 10:39:04 MSTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8802161739.AA25191@orion.utah.edu>Date: Tue, 16 Feb 88 10:39:02 MSTSubject: FUNCTION-TYPE:STRICT-REDEFINITION proposalTo: cl-cleanup@sail.stanford.eduSections 1a and 6 of this proposal refer to the PROCEDURE type.  Iassume this is really supposed to be the FUNCTION type?Also, I have a question about 1b, where it states that COMPILED-FUNCTIONis a subtype of FUNCTION.  Does this imply that it must be a *proper*subtype?  For example, in the Lisp I've been working on sporadically formy Atari, the interpreted version of (FUNCTION (LAMBDA ...)) returns acompiled function object (it's a closure which will apply the lambdaexpression to the function arguments).  Likewise I can conceive ofimplementations which compile everything and don't have an "interpreter"at all.  I think this needs to be clarified.-Sandra-------*start*01520 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 19 FEB 88 14:37:22 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 19 Feb 88  14:34:11 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 19 FEB 88 14:17:33 PSTDate: 19 Feb 88 14:17 PSTFrom: Masinter.paSubject: Re: FUNCTION-TYPE:STRICT-REDEFINITION proposalIn-reply-to: sandra%orion@cs.utah.edu (Sandra J Loosemore)'s message of Tue, 16 Feb 88 10:39:02 MSTTo: sandra%orion@cs.utah.educc: cl-cleanup@sail.stanford.eduMessage-ID: <880219-141733-9723@Xerox>"Sections 1a and 6 of this proposal refer to the PROCEDURE type.  Iassume this is really supposed to be the FUNCTION type?"Yes, looks like a typo on my part."Also, I have a question about 1b, where it states that COMPILED-FUNCTIONis a subtype of FUNCTION.  Does this imply that it must be a *proper*subtype?  For example, in the Lisp I've been working on sporadically formy Atari, the interpreted version of (FUNCTION (LAMBDA ...)) returns acompiled function object (it's a closure which will apply the lambdaexpression to the function arguments).  Likewise I can conceive ofimplementations which compile everything and don't have an "interpreter"at all.  I think this needs to be clarified."I intended not to require that it not be a "proper" subtype in the sense thatthere may be no data items that are FUNCTIONP but not COMPILED-FUNCTIONP.This can be clarified. *start*01597 00024 US Return-Path: <edsel!jonl@labrea.Stanford.EDU>Received: from labrea.Stanford.EDU by Xerox.COM ; 24 FEB 88 10:14:38 PSTReceived: by labrea.Stanford.EDU; Wed, 24 Feb 88 09:35:20 PSTReceived: from bhopal.lucid.com by edsel id AA21578g; Wed, 24 Feb 88 10:03:43 PSTReceived: by bhopal id AA26979g; Wed, 24 Feb 88 10:09:26 PSTDate: Wed, 24 Feb 88 10:09:26 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8802241809.AA26979@bhopal.lucid.com>To: Masinter.paCc: sandra%orion@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: Masinter.pa@Xerox.COM's message of 19 Feb 88 14:17 PST <880219-141733-9723@Xerox>Subject: FUNCTION-TYPE:STRICT-REDEFINITION proposalre: I intended not to require that it not be a "proper" subtype in the     sense that there may be no data items that are FUNCTIONP but not     COMPILED-FUNCTIONP.Lucid Common Lisp distinguishes "compiled" closures which exist for thepurpose of supporting entry into the interpreter from functions which aretruly compiled.  It only takes a bit in a header word.  If an implementationreally doesn't support an interpreter, then having every function beCOMPILED-FUNCTIONP  doesn't sound like much of a loss.  But most implementations in fact do support an interpreter -- which typically runs code at anywhere from 30 to 600 times slower than whencompiled.  Thus it seems reasonable to require COMPILED-FUNCTIONP inthose implementations to be false on, say,	(eval '#'(lambda (x) (list x)))no matter what underlying technique is used to support interpreter closures.-- JonL --*start*02043 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 19 MAR 88 17:53:45 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 19 Mar 88  15:21:15 PSTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA12899; Sat, 19 Mar 88 16:22:01 MSTFrom: sandra@cs.utah.edu (Sandra J Loosemore)Message-Id: <8803192322.AA12899@cs.utah.edu>Date: Sat, 19 Mar 88 16:22:00 MSTSubject: FUNCTION-TYPE proposalTo: cl-cleanup@sail.stanford.eduI just wanted to clarify the question about item 5 of the FUNCTION-TYPEproposal that I brought up at the meeting.  The current language in CLtL*requires* FBOUNDP to return true for a symbol naming a macro or specialform.  The proposal says that *it is permissible* for FBOUNDP to returntrue in this situation, which in my mind leaves open the possibilitythat it might not return true, and seems to be just the opposite of aclarification.Assuming that FBOUNDP must be true of macros and special forms, the implication of item 5b is that SYMBOL-FUNCTION must *not* return afunction if the symbol names a macro or special form.  In particular,the language on p. 144 of CLtL makes it clear that macro functions areordinary functions of two arguments and that macro-ness is a propertyof the symbol they are attached to, not the function which is used toproduce the expansion of the macro.Since item 5a says that SYMBOL-FUNCTION must return *something* if itsargument names a macro or special form, and since that something can'tbe a function, is there any reason why we couldn't say exactly whatit should return in those situations?  For example, if it returned T,one could use a bit of code like (AND (FBOUNDP f) (SYMBOL-FUNCTION f))to test whether the symbol "f" has some interpretation when it appearsas the CAR of a list.  A return value of NIL would also have its uses.Certainly either one would be more useful than wimping out and sayingit's not well-defined.-Sandra-------*start*17764 00024 USmDate: 14 Feb 88 12:55 PSTFrom: Masinter.paSubject: Issue: FUNCTION-TYPE (version 9)To: X3J13@Sail.stanford.educc: Masinterreply-to: CL-CLEANUP@Sail.Stanford.EDULINE-FOLD: NOThis is a difficult issue. The issue was discussed both at the June and November 1987 meetings. There seem to be strong opinions along several different dimensions.This version of the issue writeup contains two different proposals.Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)              14-Nov-87, Version 8 by Pitman (major restructuring)              13-Feb-88, Version 9 by Masinter, (add back 2nd option)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).There are two proposals for dealing with this issue.Proposal FUNCTION-TYPE:CONSERVATIVE 1. Introduce a new type PROCEDURE that can be used both for declaration    and discrimination.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and PROCEDURE        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of PROCEDURE.        Implementations are free to define other subtypes of PROCEDURE.    1c. Introduce a new function, PROCEDUREP, such that	(PROCEDUREP x) == (TYPEP x 'PROCEDURE). 2. Define that a ``function'' may be a procedure, a list whose car is    the symbol LAMBDA, or any symbol (whether fbound or not).    2a. Clarify that the FUNCTION type behaves as if it had been        defined by:         (DEFUN LAMBDA-P (X) (AND (NOT (ATOM X)) (EQ (CAR X) 'LAMBDA)))         (DEFTYPE FUNCTION ()	   `(OR SYMBOL (SATISFIES LAMBDA-P) PROCEDURE))    2b. Clarify that (FUNCTIONP x) == (TYPEP x 'FUNCTION).        This change is compatible.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Clarify that FUNCALL and APPLY continue to accept functions        as arguments. However, some implementations may produce better	code for expressions such as (FUNCALL (THE PROCEDURE ...) ...)	or (APPLY (THE PROCEDURE ...) ...). 3. Clarify that the result of a FUNCTION special form must be a procedure.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE PROCEDURE (FUNCTION name)). As such, the potential	optimizations mentioned in 2e are also possible for	(FUNCALL (FUNCTION ...) ...) and (APPLY (FUNCTION ...) ...). 4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.    4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(PROCEDUREP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error,	but they are also permitted to define useful (non-portable)	interpretations.    5d. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols.	Implementations are permitted, but not required, to store	information about a global macro-function or special form	in the function cell. This definition of SYMBOL-FUNCTION	is intended to leave enough freedom for such implementations	to conveniently implement FUNCTION, SPECIAL-FORM-P, and	MACRO-FUNCTION using SYMBOL-FUNCTION as the underlying	subprimitive. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'PROCEDURE) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'PROCEDURE) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify *MACROEXPAND-HOOK* is permitted to contain any kind of function.    The function is coerced to a procedure before being called as the    expansion interface hook by MACROEXPAND-1.Proposal FUNCTION-TYPE:STRICT-REDEFINITIONSTRICT-REDEFINITION is similar to CONSERVATIVE, except that it redefinesthe type FUNCTION instead of adding a new type PROCEDURE, and it restrictscoercion by functions that take functions as arguments. The numbering ofCONSERVATIVE is preserved for comparison. 1.  Redefine the type FUNCTION so that it can be used for discrimination     as well as declaration.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION        are pairwise disjoint.  In particular, a list may not be used 	to implement any PROCEDURE subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of FUNCTION.        Implementations are free to define other subtypes of FUNCTION. 2. Define that a ``function'' as used throughout the CLtL is restricted    to be exactly those objects of type FUNCTION.    2a. This type no longer includes objects of type SYMBOL or lists        with CAR = LAMBDA.    2b. The behavior of FUNCTIONP is defined to be exactly equivalent to        #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  This is an incompatible        change.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Change FUNCALL and APPLY such that they accept only a function        as the functional argument.  This restriction is inherited by        all functions in Common Lispthat take a functional argument.         It is no longer legal to pass a symbol or lambda expression as        the functional argument to any of these functions; to do so        "is an error". 3. Clarify that the result of a FUNCTION special form must be a function.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	  as (THE FUNCTION (FUNCTION name)).  4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.        4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that it is permissible for FBOUNDP to return true for a macro    or special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound,	(FUNCTIONP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).    5c. The effect of        (SETF (SYMBOL-FUNCTION symbol) non-procedure)	is not defined. Implementations are permitted to signal an error.    5d.  The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols. 6. COERCE is extended to allow objects to be coerced to type procedure.    6a. (COERCE symbol 'FUNCTION) extracts the symbol-function of the        given symbol, signalling an error if SYMBOL is not fbound or if	the contents of the symbol-function cell is not a procedure.    6b. (COERCE lambda-expression 'FUNCTION) is equivalent to        (EVAL `(FUNCTION ,lambda-expression)). 7. Clarify that the value of *MACROEXPAND-HOOK* is first coerced to a    function before being called as the    expansion interface hook by MACROEXPAND-1.Rationale:Since the two proposals are similar, they are discussed together. Wheremotiviation and justification differ, the proposals are referred to byname (STRICT-REDEFINITION, CONSERVATIVE.) The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' CONSERVATIVE manages a compatible definition with most existing uses of the term ``function'' while providing a graceful upgrade path to the term ``procedure'' for use in situations that call for a higher degree of clarity. STRICT-REDEFINITION avoids introducing a new term at the cost of incompatible change.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is the same as (FUNCTIONP x). In some implementations, (TYPEP x 'FUNCTION) is the same as what CONSERVATIVE calls (TYPEP x 'PROCEDURE). Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations are likely to have exactly the semantics described in either. CONSERVATIVE is more compatible with current practice than STRICT-REDEFINITION, however.Cost to Implementors: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little effort in most implementations. While STRICT-REDEFINITION makes it an error to pass non-function arguments to APPLY, FUNCALL etc, there is no requirement to check for that error. Compiled functions are true functions in almost all current implementations, but in many implementations, interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, this representation would have to be different (implemented either as structures or to some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be reconstructed if necessary).Cost to Users: The conversion cost associated with CONSERVATIVE is very low because the model of FUNCTIONP which it takes is largely consistent with existing  practice. The new features introduced by CONSERVATIVE, particularly the PROCEDURE data type, can be converted to fairly lazily. The conversion cost for the STRICT-REDEFINITION proposal is higher. The changes to FUNCTIONP and the FUNCTION type declaration is relatively easy to deal with. However, the strict redefinition of FUNCALL, APPLY and functional arguments will require the addition of an explicit coercion would have to be added whenever a symbol or lambda expression is used as a functional argument. Many such cases can be identified at compile time, but not all.  Some implementations might provide tools to assist in detecting implicit coercion of symbols to functions. For example, an implementation might add run-time test in which the implementation still does the coercion but that issues a warning message whenever the coercion is actually needed. Alternatively, a "smart" code-walker or editor macro might find all of the calls to FUNCALL, APPLY, and the 61 Common Lisp functions that take :TEST or :KEY arguments and, if the argument is not already an explicitly quoted FUNCTION form, wrap a COERCE around the body.   For either proposal: Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell might have to change. Such code was  already not portable, however, since some implementations signal an error when this is done.Benefits:For CONSERVATIVE: The term ``function'' would be given a useful meaning that was relatively compatible with existing usage. A new term ``procedure'' would be available for descriptional clarity. The new PROCEDURE datatype would be useful for type discrimination in CLOS.For STRICT-REDEFINITION: The term ``function'' would be given a useful and precise meaning. The FUNCTION datatype would be useful for type discrimination in CLOS. STRICT-REDEFINITION provides useful constraints which will be of aid to systems doing automatic program analysis for the purpose of ``selective linking.'' Such tools may in turn make it possible to reduce the total size of a delivered application program because only those Common Lisp functions that are actually called need to be included.For either proposal:The type hierarchy would be simplified.Either proposal brings Common Lisp into closer alignment with Scheme andthe work of the EuLisp committee. Scheme, for example, also has the conceptof a ``procedure'' which is compatible with this proposal.Aesthetics: Both proposals improve the aesthetics of the language.Discussion:These proposals have been discussed at great length; this section attemptsonly to summarize the important points.There is general agreement that the definition of the FUNCTION data typemust be clarified or revised. The cleanup of the type hierarchy is importantto the CLOS group.The description of COMPILE must be changed, since it is no longermeaningful to speak of a symbol with a definition that "is alambda-expression".  We believe this is a subject for a separateproposal, as the behavior of COMPILE needs additional clarification.Many different alternatives have been discussed both in the cleanup committeeand X3J13. These two proposals are the distillation of the alternatives. The CONSERVATIVE proposal offers the advantage of backward compatibility,and considerably more flexibility in the language.The STRICT-REDEFINITION proposal offers the advantage of a slightly cleanerresulting language. Some concerns were raised about STRICT-REDEFINITION in a previous discussionabout "late binding" of function definitions. Neither proposal disallowslate binding of symbols to functions. For example, in the call  (MAPCAR #'FROB my-list)the effect of the FUNCTION special form (as generated by the #' read macro)is to obtain the function definition of FROB at the time the #'FROB isevaluated. Neither proposal changes this.Currently, it is allowed to write(MAPCAR 'FROB my-list)while this form would no longer be allowed under the STRICT-REDEFINITIONclause. Currently, neither CLtL nor the CONSERVATIVE proposal addressesthe question of the time at which FROB's function definition is obtained;if, during the processing of my-list, FROB is redefined, it is not clearwhether the processing of subsequent elements would be changed.        TITAN 
          TITAN 
                                     s                           #                    $      *       +                   e                          W             m       
      *              :                   D z*start*01762 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 21 MAY 88 02:09:22 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 21 May 88  02:07:48 PDTReceived: by labrea.stanford.edu; Sat, 21 May 88 02:08:07 PDTReceived: from bhopal.lucid.com by edsel id AA19226g; Sat, 21 May 88 01:58:30 PDTReceived: by bhopal id AA07793g; Sat, 21 May 88 02:02:10 PDTDate: Sat, 21 May 88 02:02:10 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805210902.AA07793@bhopal.lucid.com>To: CL-CLEANUP@sail.stanford.eduSubject: Issue: FUNCTION-TYPE (version 10)re: 5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. Assuming that symbol is fbound[sic],	(FUNCTIONP (SYMBOL-FUNCTION symbol))	implies	(AND (NOT (MACRO-FUNCTION symbol))	     (NOT (SPECIAL-FORM-P symbol))).I don't understand the motivation behind this point (5b).  Since (5a) saysthat SYMBOL-FUNCTION is permitted to return "something", and is not"well-defined" in the case when the symbol names a macro or special form,then what is the advantage of preventing it from returning a function?I've seen lots of CL code like:    (defun foo-expander (x) `(QUOTE ,x))    (setf (macro-function 'FOO) #'foo-expander)How will one fetch the current "expander function" for this macro?  Is the issue merely that some implementations will have to cons in order toreturn a value for MACRO-FUNCTION?  In that case, maybe we need a predicateMACRO-P, just as there is a predicate SPECIAL-FORM-P.-- JonL --*start*03335 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAY 88 13:31:30 PDTReceived: from hudson.dec.com by SAIL.Stanford.EDU with TCP; 23 May 88  13:29:22 PDTDate: 23 May 88 16:09:00 EDTFrom: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>Subject: Re: issue FUNCTION-TYPETo: "cl-cleanup" <cl-cleanup@sail.stanford.edu>cc: vanroggen@hudson.dec.com Reply-To: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>A couple of concerns:It seems to me that the combination of #2e:  ... the functions FUNCALL and APPLY ... will accept any object that  can be coerced to a FUNCTION ...and #6a:  (COERCE symbol 'FUNCTION) extracts the symbol-function of the  given symbol, signalling an error if SYMBOL is not fbound or if  the contents of the symbol-function cell is not a procedure.requires implementations to signal errors for any undefined symbol.I don't think the standard should require such error checking, forreasons of efficiency in some implementations.  (Of course it shouldbe encouraged.)Perhaps the reason for this language is that COERCE is expected tosignal an error.  That may be another issue; but for this issue Idon't think we should imply COERCE is actually used for every FUNCALLor APPLY.The other concern I had was that unlike the earlier FUNCTION-TYPE:STRICT-REDEFINITION proposal, both symbols and lambda-expressions(i.e., lists whose car is LAMBDA and whose cadr is a list) areassumed to be acceptable to FUNCALL or APPLY.  I had thought thatat the meeting we had agreed that #2e should refer to whatevercoerceable to a FUNCTION, but that what was coerceable was stillan issue.In particular, I'd very much like to see lists not be FUNCALLable orAPPLYable.  I think there are too many aesthetic and efficiencyreasons against continuing to allow lambda-expressions be treated as"functions".So far I haven't seen some of those reasons written down.Here's an aesthetic/counter-intuitive-to-the-novice one:Lambda-expressions don't obey the normal, apparent scoping rules becausefree variables can't refer to lexical bindings.  This is becausecoercing a list to a function means (EVAL `(FUNCTION ,list)).The following code does -not- count the number of nodes in a graph:  ...  (let ((counter 0))    (traverse-thing '(lambda (node) (incf counter))                    (thing-root)))  ...since it is not the same as  ...  (let ((counter 0))    (traverse-thing #'(lambda (node) (incf counter))                    (thing-root)))  ...which does pass around a closure incrementing the LET variable.(This assumes COUNTER wasn't DEFVAR'd.)Here's an efficiency reason:At run-time FUNCALL or APPLY must check to see if its first argumentis a list, so that it can decide to call EVAL (or internal-equivalent).In some implementations, this is deemed to be too expensive.Of course some implementations may decide to handle lists forcompatibility reasons.Anyway, these kinds of arguments really ought to be in this proposalso everyone is aware of the issues.  I'd rather make sure this proposalresolves the question than postpone it with yet another proposal,especially since that was what the original proposal was about.			---Walter------*start*01263 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 20 MAY 88 19:23:38 PDTReceived: from JASPER.SCRC.Symbolics.COM ([128.81.41.58]) by SAIL.Stanford.EDU with TCP; 20 May 88  19:21:28 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by JASPER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 191385; Fri 20-May-88 22:21:02 EDTDate: Fri, 20 May 88 22:21 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-TYPE (version 10)To: masinter.pacc: CL-CLEANUP@SAIL.STANFORD.EDUIn-Reply-To: <880519-144631-1033@Xerox>Message-ID: <19880521022111.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoApproved, except for one thing.  The word "procedure" appearsthree times without being defined.  One occurrence is legitimate,but I believe these two are typos for "function".  5c. The effect of      (SETF (SYMBOL-FUNCTION symbol) non-procedure)      is not defined. Implementations are permitted to signal an error.  6a. (COERCE symbol 'FUNCTION) extracts the symbol-function of the      given symbol, signalling an error if SYMBOL is not fbound or if      the contents of the symbol-function cell is not a procedure.*start*11982 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 14:28:36 PDTReceived: from hudson.dec.com by SAIL.Stanford.EDU with TCP; 24 May 88  14:25:24 PDTDate: 24 May 88 17:20:00 EDTFrom: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>Subject: issue: FUNCTION-TYPE (version 11)To: "cl-cleanup" <cl-cleanup@sail.stanford.edu>cc: vanroggen@hudson.dec.com Reply-To: "AITG::VANROGGEN" <vanroggen%aitg.decnet@hudson.dec.com>Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)              14-Nov-87, Version 8 by Pitman (major restructuring)              13-Feb-88, Version 9 by Masinter, (add back 2nd option)              19-May-88, Version 10 by Masinter, (modify as per X3J13)              24-May-88, Version 11 by van Roggen                            (don't coerce lists, relax SYMBOL-FUNCTION reqs)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).Proposal FUNCTION-TYPE:X3J13-MARCH-88This proposal is basically the STRICT-REDEFINITION proposal of version 9of this issue, correcting a few typos, changing section 2E asagreed upon at X3J13 March 1988, allowing symbols but not lists tobe FUNCALLed or APPLYed, and relaxing some SYMBOL-FUNCTION/FBOUNDPrequirements. 1.  Redefine the type FUNCTION so that it can be used for discrimination     as well as declaration.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION        are pairwise disjoint.  In particular, a list may not be used        to implement any FUNCTION subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of FUNCTION.        Implementations are free to define other subtypes of FUNCTION. 2. Define that a ``function'' as used throughout the CLtL is restricted    to be exactly those objects of type FUNCTION.    2a. This type no longer includes objects of type SYMBOL or lists        whose CAR is LAMBDA.    2b. The behavior of FUNCTIONP is defined to be exactly equivalent to        #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  This is an incompatible        change.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Clarify FUNCALL and APPLY and all Common Lisp functions that	take functional arguments such that they accept objects that	are coerceable to a FUNCTION as the functional argument.  It	is an error if the functional argument is not coerceable to a	FUNCTION. 3. Clarify that the result of a FUNCTION special form must be a function.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE FUNCTION (FUNCTION name)).  4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.        4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that FBOUNDP must return true for a symbol naming a macro or    a special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. SETF of SYMBOL-FUNCTION requires a FUNCTION as the new value.	It is an error to set the SYMBOL-FUNCTION of a symbol to a	symbol or a list or the value returned by SYMBOL-FUNCTION on	the name of a macro or a special form.    5c. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols. 6. COERCE is extended to allow objects to be coerced to type FUNCTION.    6a. (COERCE symbol 'FUNCTION) extracts the SYMBOL-FUNCTION of the        given symbol, signalling an error if the symbol is not FBOUNDP or	if the symbol names a macro or a special-form.    6b. Implementations are free to extend the set of objects which	are coerceable to a FUNCTION, particularly lambda-expressions	for compatibility.  However, such extensions will not be portable. 7. Clarify that the value of *MACROEXPAND-HOOK* is first coerced to a    function before being called as the expansion interface hook by    MACROEXPAND-1.Rationale: The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' This proposal is a compromise between a CONSERVATIVE proposal (which left FUNCTION alone and introduced a new type), and a STRICT-REDEFINITION proposal, which incompatibly changed not only the FUNCTION type and SYMBOL-FUNCTION, but also the behavior of FUNCALL, APPLY and functions with functional arguments. For compatibility reasons symbols are still acceptable to FUNCALL et al., but for aesthetic reasons lambda-expressions (lists whose CAR is LAMBDA and whose CADR is a list) are no longer acceptable.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is true for values   returned by FUNCTION, symbols that are FBOUNDP, and lambda expressions.  In some implementations, (TYPEP x 'FUNCTION) is true only for values   returned by FUNCTION. Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations have exactly the semantics described in this proposal.Cost to Implementors: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little effort in most implementations. Compiled functions are true functions in almost all current implementations, but in many implementations, interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, this representation would have to be different (implemented either as structures or as some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be reconstructed if necessary).Cost to Users: The changes to FUNCTIONP and the FUNCTION type declaration are relatively easy to deal with.  Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell, or expected lists back, will have to change. Such code was already not portable, however, since some implementations signal an error when this is done. The original STRICT-REDEFINITION proposal required users to deal with the use of symbols and lambda-expressions as functional arguments.  However this proposal is compatible with current CLtL definition in the use of symbols, which would be the hardest change to make.  There are probably relatively few uses of lambda-expressions as ``functions'', which can be dealt with by (EVAL `(FUNCTION ,lambda-expresssion)).Benefits: The term ``function'' would be given a useful and precise meaning. The FUNCTION datatype would be useful for type discrimination in CLOS. The type hierarchy would be simplified. This proposal brings Common Lisp slightly closer to Scheme and the work of the EuLisp committee. Scheme, for example, also has the concept of a ``procedure'' which is compatible with the FUNCTION type.Aesthetics: This proposal improves the aesthetics of the language. Lambda-expressions do not obey the normal, apparent scoping rules because free variables cannot refer to lexical bindings.  This is because coercing a list to a function would mean (EVAL `(FUNCTION ,list)). The following code does -not- count the number of nodes in a graph:  (LET ((COUNTER 0))    (TRAVERSE-THING '(LAMBDA (NODE) (INCF COUNTER))                    (THING-ROOT))) since it is not the same as  (LET ((COUNTER 0))    (TRAVERSE-THING #'(LAMBDA (NODE) (INCF COUNTER))                    (THING-ROOT))) which does pass around a closure incrementing the LET variable. (These examples assume COUNTER wasn't PROCLAIMed SPECIAL.) Making the coercion of lambda-expressions to functions explicit with the use of EVAL will encourage less confusing code and also highlight that use of EVAL.Discussion:This issue has been discussed at great length; this section attemptsonly to summarize the important points.There is general agreement that the definition of the FUNCTION data typemust be clarified or revised. The cleanup of the type hierarchy is importantto the CLOS group.The description of COMPILE must be changed, since it is no longermeaningful to speak of a symbol with a definition that "is alambda-expression".  We believe this is a subject for a separateproposal, as the behavior of COMPILE needs additional clarification.Many different alternatives have been discussed both in the cleanup committeeand X3J13. Two proposals were circulated at the March 1988 meeting of X3J13;this version is the result of discussions at that meeting. It is a compromisebetween the conflicting goals of backward compatibility, flexibility in thelanguage, and simple semantics. This proposal does not address the issue of when coercion to functions occur.For example, it is allowed to write(MAPCAR 'FROB my-list)It is not specified when the coercion of FROB to its SYMBOL-FUNCTION occurs. For example, (DEFUN FROB (X)    (WHEN (> X 0) (SETF (SYMBOL-FUNCTION 'FROB) #'(LAMBDA (X) NIL)))   T)(MAPCAR 'FROB '(-1 -1 1 1))may return different results if MAPCAR coerces its functional argumentonce rather than for each element. This may require a separatecleanup issue.------*start*12376 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU by Xerox.COM ; 07 JUN 88 16:15:07 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Jun 88  15:59:29 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 07 JUN 88 15:59:26 PDTDate: 7 Jun 88 15:59 PDTFrom: Masinter.pato: X3J13@Sail.stanford.educc: Masinter.paSubject: Issue: FUNCTION-TYPE (version 11)line-fold: NOMessage-ID: <880607-155926-1276@Xerox>Due to a combination of circumstances, I've been unable to work on cleanup activities. The committee has proceeded admirably, but I've been behind in summarizing. Since I've been behind, any decisions made at X3J13 will be preliminary. I will bring some hardcopy of these issues to the meeting.However, the issue FUNCTION-TYPE was discussed at length at the last X3J13. This version is our attempt to recast it according to the wishes expressed at the last meeting.!Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)              14-Nov-87, Version 8 by Pitman (major restructuring)              13-Feb-88, Version 9 by Masinter, (add back 2nd option)              19-May-88, Version 10 by Masinter, (modify as per X3J13)              24-May-88, Version 11 by van Roggen                            (don't coerce lists, relax SYMBOL-FUNCTION reqs)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).Proposal FUNCTION-TYPE:X3J13-MARCH-88This proposal is basically the STRICT-REDEFINITION proposal of version 9of this issue, correcting a few typos, changing section 2E asagreed upon at X3J13 March 1988, allowing symbols but not lists tobe FUNCALLed or APPLYed, and relaxing some SYMBOL-FUNCTION/FBOUNDPrequirements. 1.  Redefine the type FUNCTION so that it can be used for discrimination     as well as declaration.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION        are pairwise disjoint.  In particular, a list may not be used        to implement any FUNCTION subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of FUNCTION.        Implementations are free to define other subtypes of FUNCTION. 2. Define that a ``function'' as used throughout the CLtL is restricted    to be exactly those objects of type FUNCTION.    2a. This type no longer includes objects of type SYMBOL or lists        whose CAR is LAMBDA.    2b. The behavior of FUNCTIONP is defined to be exactly equivalent to        #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  This is an incompatible        change.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Clarify FUNCALL and APPLY and all Common Lisp functions that	take functional arguments such that they accept objects that	are coerceable to a FUNCTION as the functional argument.  It	is an error if the functional argument is not coerceable to a	FUNCTION. 3. Clarify that the result of a FUNCTION special form must be a function.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE FUNCTION (FUNCTION name)).  4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.        4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that FBOUNDP must return true for a symbol naming a macro or    a special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. SETF of SYMBOL-FUNCTION requires a FUNCTION as the new value.	It is an error to set the SYMBOL-FUNCTION of a symbol to a	symbol or a list or the value returned by SYMBOL-FUNCTION on	the name of a macro or a special form.    5c. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols. 6. COERCE is extended to allow objects to be coerced to type FUNCTION.    6a. (COERCE symbol 'FUNCTION) extracts the SYMBOL-FUNCTION of the        given symbol, signalling an error if the symbol is not FBOUNDP or	if the symbol names a macro or a special-form.    6b. Implementations are free to extend the set of objects which	are coerceable to a FUNCTION, particularly lambda-expressions	for compatibility.  However, such extensions will not be portable. 7. Clarify that the value of *MACROEXPAND-HOOK* is first coerced to a    function before being called as the expansion interface hook by    MACROEXPAND-1.Rationale: The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' This proposal is a compromise between a CONSERVATIVE proposal (which left FUNCTION alone and introduced a new type), and a STRICT-REDEFINITION proposal, which incompatibly changed not only the FUNCTION type and SYMBOL-FUNCTION, but also the behavior of FUNCALL, APPLY and functions with functional arguments. For compatibility reasons symbols are still acceptable to FUNCALL et al., but for aesthetic reasons lambda-expressions (lists whose CAR is LAMBDA and whose CADR is a list) are no longer acceptable.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is true for values   returned by FUNCTION, symbols that are FBOUNDP, and lambda expressions.  In some implementations, (TYPEP x 'FUNCTION) is true only for values   returned by FUNCTION. Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations have exactly the semantics described in this proposal.Cost to Implementors: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little effort in most implementations. Compiled functions are true functions in almost all current implementations, but in many implementations, interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, this representation would have to be different (implemented either as structures or as some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be reconstructed if necessary).Cost to Users: The changes to FUNCTIONP and the FUNCTION type declaration are relatively easy to deal with.  Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell, or expected lists back, will have to change. Such code was already not portable, however, since some implementations signal an error when this is done. The original STRICT-REDEFINITION proposal required users to deal with the use of symbols and lambda-expressions as functional arguments.  However this proposal is compatible with current CLtL definition in the use of symbols, which would be the hardest change to make.  There are probably relatively few uses of lambda-expressions as ``functions'', which can be dealt with by (EVAL `(FUNCTION ,lambda-expresssion)).Benefits: The term ``function'' would be given a useful and precise meaning. The FUNCTION datatype would be useful for type discrimination in CLOS. The type hierarchy would be simplified. This proposal brings Common Lisp slightly closer to Scheme and the work of the EuLisp committee. Scheme, for example, also has the concept of a ``procedure'' which is compatible with the FUNCTION type.Aesthetics: This proposal improves the aesthetics of the language. Lambda-expressions do not obey the normal, apparent scoping rules because free variables cannot refer to lexical bindings.  This is because coercing a list to a function would mean (EVAL `(FUNCTION ,list)). The following code does -not- count the number of nodes in a graph:  (LET ((COUNTER 0))    (TRAVERSE-THING '(LAMBDA (NODE) (INCF COUNTER))                    (THING-ROOT))) since it is not the same as  (LET ((COUNTER 0))    (TRAVERSE-THING #'(LAMBDA (NODE) (INCF COUNTER))                    (THING-ROOT))) which does pass around a closure incrementing the LET variable. (These examples assume COUNTER wasn't PROCLAIMed SPECIAL.) Making the coercion of lambda-expressions to functions explicit with the use of EVAL will encourage less confusing code and also highlight that use of EVAL.Discussion:This issue has been discussed at great length; this section attemptsonly to summarize the important points.There is general agreement that the definition of the FUNCTION data typemust be clarified or revised. The cleanup of the type hierarchy is importantto the CLOS group.The description of COMPILE must be changed, since it is no longermeaningful to speak of a symbol with a definition that "is alambda-expression".  We believe this is a subject for a separateproposal, as the behavior of COMPILE needs additional clarification.Many different alternatives have been discussed both in the cleanup committeeand X3J13. Two proposals were circulated at the March 1988 meeting of X3J13;this version is the result of discussions at that meeting. It is a compromisebetween the conflicting goals of backward compatibility, flexibility in thelanguage, and simple semantics. This proposal does not address the issue of when coercion to functions occur.For example, it is allowed to write(MAPCAR 'FROB my-list)It is not specified when the coercion of FROB to its SYMBOL-FUNCTION occurs. For example, (DEFUN FROB (X)    (WHEN (> X 0) (SETF (SYMBOL-FUNCTION 'FROB) #'(LAMBDA (X) NIL)))   T)(MAPCAR 'FROB '(-1 -1 1 1))may return different results if MAPCAR coerces its functional argumentonce rather than for each element. This may require a separatecleanup issue.*start*12407 00024 USfDate:  7 Jun 88 15:59 PDTFrom: Masinter.pato: X3J13@Sail.stanford.educc: MasinterSubject: Issue: FUNCTION-TYPE (version 11)line-fold: NODue to a combination of circumstances, I've been unable to work on cleanup activities. The committee has proceeded admirably, but I've been behind in summarizing. Since I've been behind, any decisions made at X3J13 will be preliminary. I will bring some hardcopy of these issues to the meeting.However, the issue FUNCTION-TYPE was discussed at length at the last X3J13. This version is our attempt to recast it according to the wishes expressed at the last meeting.Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)              14-Nov-87, Version 8 by Pitman (major restructuring)              13-Feb-88, Version 9 by Masinter, (add back 2nd option)              19-May-88, Version 10 by Masinter, (modify as per X3J13)              24-May-88, Version 11 by van Roggen                            (don't coerce lists, relax SYMBOL-FUNCTION reqs)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).Proposal FUNCTION-TYPE:X3J13-MARCH-88This proposal is basically the STRICT-REDEFINITION proposal of version 9of this issue, correcting a few typos, changing section 2E asagreed upon at X3J13 March 1988, allowing symbols but not lists tobe FUNCALLed or APPLYed, and relaxing some SYMBOL-FUNCTION/FBOUNDPrequirements. 1.  Redefine the type FUNCTION so that it can be used for discrimination     as well as declaration.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION        are pairwise disjoint.  In particular, a list may not be used        to implement any FUNCTION subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of FUNCTION.        Implementations are free to define other subtypes of FUNCTION. 2. Define that a ``function'' as used throughout the CLtL is restricted    to be exactly those objects of type FUNCTION.    2a. This type no longer includes objects of type SYMBOL or lists        whose CAR is LAMBDA.    2b. The behavior of FUNCTIONP is defined to be exactly equivalent to        #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  This is an incompatible        change.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. Clarify FUNCALL and APPLY and all Common Lisp functions that	take functional arguments such that they accept objects that	are coerceable to a FUNCTION as the functional argument.  It	is an error if the functional argument is not coerceable to a	FUNCTION. 3. Clarify that the result of a FUNCTION special form must be a function.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE FUNCTION (FUNCTION name)).  4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.        4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that FBOUNDP must return true for a symbol naming a macro or    a special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. SETF of SYMBOL-FUNCTION requires a FUNCTION as the new value.	It is an error to set the SYMBOL-FUNCTION of a symbol to a	symbol or a list or the value returned by SYMBOL-FUNCTION on	the name of a macro or a special form.    5c. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols. 6. COERCE is extended to allow objects to be coerced to type FUNCTION.    6a. (COERCE symbol 'FUNCTION) extracts the SYMBOL-FUNCTION of the        given symbol, signalling an error if the symbol is not FBOUNDP or	if the symbol names a macro or a special-form.    6b. Implementations are free to extend the set of objects which	are coerceable to a FUNCTION, particularly lambda-expressions	for compatibility.  However, such extensions will not be portable. 7. Clarify that the value of *MACROEXPAND-HOOK* is first coerced to a    function before being called as the expansion interface hook by    MACROEXPAND-1.Rationale: The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' This proposal is a compromise between a CONSERVATIVE proposal (which left FUNCTION alone and introduced a new type), and a STRICT-REDEFINITION proposal, which incompatibly changed not only the FUNCTION type and SYMBOL-FUNCTION, but also the behavior of FUNCALL, APPLY and functions with functional arguments. For compatibility reasons symbols are still acceptable to FUNCALL et al., but for aesthetic reasons lambda-expressions (lists whose CAR is LAMBDA and whose CADR is a list) are no longer acceptable.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is true for values   returned by FUNCTION, symbols that are FBOUNDP, and lambda expressions.  In some implementations, (TYPEP x 'FUNCTION) is true only for values   returned by FUNCTION. Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations have exactly the semantics described in this proposal.Cost to Implementors: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little effort in most implementations. Compiled functions are true functions in almost all current implementations, but in many implementations, interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, this representation would have to be different (implemented either as structures or as some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be reconstructed if necessary).Cost to Users: The changes to FUNCTIONP and the FUNCTION type declaration are relatively easy to deal with.  Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell, or expected lists back, will have to change. Such code was already not portable, however, since some implementations signal an error when this is done. The original STRICT-REDEFINITION proposal required users to deal with the use of symbols and lambda-expressions as functional arguments.  However this proposal is compatible with current CLtL definition in the use of symbols, which would be the hardest change to make.  There are probably relatively few uses of lambda-expressions as ``functions'', which can be dealt with by (EVAL `(FUNCTION ,lambda-expresssion)).Benefits: The term ``function'' would be given a useful and precise meaning. The FUNCTION datatype would be useful for type discrimination in CLOS. The type hierarchy would be simplified. This proposal brings Common Lisp slightly closer to Scheme and the work of the EuLisp committee. Scheme, for example, also has the concept of a ``procedure'' which is compatible with the FUNCTION type.Aesthetics: This proposal improves the aesthetics of the language. Lambda-expressions do not obey the normal, apparent scoping rules because free variables cannot refer to lexical bindings.  This is because coercing a list to a function would mean (EVAL `(FUNCTION ,list)). The following code does -not- count the number of nodes in a graph:  (LET ((COUNTER 0))    (TRAVERSE-THING '(LAMBDA (NODE) (INCF COUNTER))                    (THING-ROOT))) since it is not the same as  (LET ((COUNTER 0))    (TRAVERSE-THING #'(LAMBDA (NODE) (INCF COUNTER))                    (THING-ROOT))) which does pass around a closure incrementing the LET variable. (These examples assume COUNTER wasn't PROCLAIMed SPECIAL.) Making the coercion of lambda-expressions to functions explicit with the use of EVAL will encourage less confusing code and also highlight that use of EVAL.Discussion:This issue has been discussed at great length; this section attemptsonly to summarize the important points.There is general agreement that the definition of the FUNCTION data typemust be clarified or revised. The cleanup of the type hierarchy is importantto the CLOS group.The description of COMPILE must be changed, since it is no longermeaningful to speak of a symbol with a definition that "is alambda-expression".  We believe this is a subject for a separateproposal, as the behavior of COMPILE needs additional clarification.Many different alternatives have been discussed both in the cleanup committeeand X3J13. Two proposals were circulated at the March 1988 meeting of X3J13;this version is the result of discussions at that meeting. It is a compromisebetween the conflicting goals of backward compatibility, flexibility in thelanguage, and simple semantics. This proposal does not address the issue of when coercion to functions occur.For example, it is allowed to write(MAPCAR 'FROB my-list)It is not specified when the coercion of FROB to its SYMBOL-FUNCTION occurs. For example, (DEFUN FROB (X)    (WHEN (> X 0) (SETF (SYMBOL-FUNCTION 'FROB) #'(LAMBDA (X) NIL)))   T)(MAPCAR 'FROB '(-1 -1 1 1))may return different results if MAPCAR coerces its functional argumentonce rather than for each element. This may require a separatecleanup issue.        TITAN 
         TITAN 
          
TIMESROMAN 
                 d       x                            s                                               &      E             s                                       \       
                   l             l      / z*start*12391 00024 USfDate:  4 Sep 88 13:39 PDTFrom: Masinter.pato: X3J13@Sail.stanford.educc: MasinterSubject: Issue: FUNCTION-TYPE (version 12)line-fold: NOThis is the final version of the FUNCTION-TYPE issue, as passed at the June 88 X3J13 meeting; that is, it incorporates the amendments that were adopted before the issue was adopted.I hope to be getting issues out to the X3J13 list as the cleanup committee comes to some final agreement on them, over the next two weeks. Issue:        FUNCTION-TYPEReferences:   functions (p32), types (p33), FUNCTIONP (p76),              SYMBOL-FUNCTION (p90), APPLY (p107), COERCE (pp51-52)Category:     CHANGEEdit History: 26-Feb-87, Version 1 by Gabriel              15-Mar-87, Version 2 by Cleanup Committee              10-May-87, Version 3 by Fahlman              29-May-87, Version 4 by Masinter (incorporate comments)              15-Jun-87, Version 5 by Fahlman (include two options)              23-Oct-87, Version 6 by Masinter (only STRICT-REDEFINITION)              09-Nov-87, Version 7 by Masinter (minor cleanup)              14-Nov-87, Version 8 by Pitman (major restructuring)              13-Feb-88, Version 9 by Masinter, (add back 2nd option)              19-May-88, Version 10 by Masinter, (modify as per X3J13)              24-May-88, Version 11 by van Roggen                            (don't coerce lists, relax SYMBOL-FUNCTION reqs)		   4-Sep-88, Version 12 by Masinter		 	(incorporate amendments adopted at June 88 X3J13)Problem Description: The definition of the term ``function'' in CLtL includes all symbols and many lists in addition to `true' functions. Also, page 47 of CLtL states that the FUNCTION type specifier can only be used for declaration and not for discrimination. Some of the original Common Lisp designers maintain that this restriction on the use of the FUNCTION specifier was meant to apply only to long-form FUNCTION specifiers, but since this intent was not explicitly stated, the status of FUNCTION as a type is blurred.  A consequence of the p47 confusion is that (FUNCTIONP x) cannot portably be relied upon to be equivalent to (TYPEP x 'FUNCTION).Proposal FUNCTION-TYPE:X3J13-MARCH-88This proposal is basically the STRICT-REDEFINITION proposal of version 9of this issue, correcting a few typos, changing section 2E asagreed upon at X3J13 March 1988, allowing symbols but not lists tobe FUNCALLed or APPLYed, and relaxing some SYMBOL-FUNCTION/FBOUNDPrequirements. 1.  Redefine the type FUNCTION so that it can be used for discrimination     as well as declaration.    1a. The types CONS, SYMBOL, ARRAY, NUMBER, CHARACTER, and FUNCTION        are pairwise disjoint.  In particular, a list may not be used        to implement any FUNCTION subtype.    1b. Define that the type COMPILED-FUNCTION is a subtype of FUNCTION.        Implementations are free to define other subtypes of FUNCTION. 2. Define that a ``function'' as used throughout the CLtL is restricted    to be exactly those objects of type FUNCTION.    2a. This type no longer includes objects of type SYMBOL or lists        whose CAR is LAMBDA.    2b. The behavior of FUNCTIONP is defined to be exactly equivalent to        #'(LAMBDA (X) (TYPEP X 'FUNCTION)).  This is an incompatible        change.    2c. Clarify that the list form of the FUNCTION type specifier may        still only be used for declaration.    2d. Clarify that the symbol form of the FUNCTION type specifier may        be used for type discrimination.    2e. FUNCALL and APPLY and all Common Lisp functions that	take function arguments to also take a symbol, which will	be coerced to a function as if by SYMBOL-FUNCTION.    2f. This is an incompatible change in that it is an error to pass	  anything other than a function or symbol as the functional	  argument. 3. Clarify that the result of a FUNCTION special form must be a function.    3a. This implies that some (FUNCTION name) may be implicitly interpreted	as (THE FUNCTION (FUNCTION name)).  4. Clarify that it is an error to use the special form FUNCTION on a    symbol that does not denote a function in the lexical environment in    which the special form appears. Specifically, it is an error to use the    FUNCTION special form on a symbol that denotes a macro or special form.        4a. Some implementations may choose not to signal this error for        performance reasons, but implementations are forbidden from        defining the failure to signal an error as a `useful' behavior. 5. Clarify that FBOUNDP must return true for a symbol naming a macro or    a special form, and that it is permissible to call SYMBOL-FUNCTION    on any symbol for which FBOUNDP returns true.    5a. The value returned by SYMBOL-FUNCTION when FBOUNDP returns true        but the symbol denotes a macro or special form is not well-defined,        but SYMBOL-FUNCTION will not signal an error.     5b. SETF of SYMBOL-FUNCTION requires a FUNCTION as the new value.	It is an error to set the SYMBOL-FUNCTION of a symbol to a	symbol or a list or the value returned by SYMBOL-FUNCTION on	the name of a macro or a special form.    5c. The motivation for this distinction between FUNCTION and 	SYMBOL-FUNCTION is that FUNCTION is intended for day-to-day	use within programs while SYMBOL-FUNCTION is a data structure	accessor used primarily for meta-level applications and not	recommended for general use. It is provided primarily to	complete the set of accessors on symbols. 6. COERCE is extended to allow objects to be coerced to type FUNCTION.    6a. (COERCE symbol 'FUNCTION) extracts the SYMBOL-FUNCTION of the        given symbol, signalling an error if the symbol is not FBOUNDP or	if the symbol names a macro or a special-form.    6b. (COERCE x 'FUNCTION), where the value of x is a list that		 begins with LAMBDA, will return a FUNCTION similar to		 (EVAL '(FUNCTION ,x)). 7. Clarify that the value of *MACROEXPAND-HOOK* is first coerced to a    function before being called as the expansion interface hook by    MACROEXPAND-1.Rationale: The fuzzy definition of ``function'' has descended from older dialects of Lisp, such as Maclisp. Many places in existing code make assumptions about the current meaning, making any change painful. It is very important both for documentation clarity and for program type discrimination (such as CLOS) to have a clear term which denotes a  ``true function.'' This proposal is a compromise between a CONSERVATIVE proposal (which left FUNCTION alone and introduced a new type), and a STRICT-REDEFINITION proposal, which incompatibly changed not only the FUNCTION type and SYMBOL-FUNCTION, but also the behavior of FUNCALL, APPLY and functions with functional arguments. For compatibility reasons symbols are still acceptable to FUNCALL et al., but for aesthetic reasons lambda-expressions (lists whose CAR is LAMBDA and whose CADR is a list) are no longer acceptable.Current Practice: In some implementations, (TYPEP x 'FUNCTION) signals an error. In some implementations, (TYPEP x 'FUNCTION) is true for values   returned by FUNCTION, symbols that are FBOUNDP, and lambda expressions.  In some implementations, (TYPEP x 'FUNCTION) is true only for values   returned by FUNCTION. Implementations vary on what my go into the function cell, depending on how much error checking they want to have to do at function call time, and depending on whether they store other kinds of information (such as special form information) in the function cell. Few current Common Lisp implementations have exactly the semantics described in this proposal.Cost to Implementors: Bringing type predicates (FUNCTIONP, etc.) and higher order functions (APPLY, etc.) into compliance should require little effort in most implementations. Compiled functions are true functions in almost all current implementations, but in many implementations, interpreted functions and closures stored in the function cell of a symbol are represented as lists. Under this proposal, this representation would have to be different (implemented either as structures or as some special internal data type). The behavior of COMPILE, STEP, TRACE, and possibly ED would have to be  modified to deal with functions that are not lists (but from which the list form can be reconstructed if necessary).Cost to Users: The changes to FUNCTIONP and the FUNCTION type declaration are relatively easy to deal with.  Because CLtL's language was somewhat fuzzy about what might go into the function cell of a symbol, some code that explicitly deposited symbols or lists in a symbol's function cell, or expected lists back, will have to change. Such code was already not portable, however, since some implementations signal an error when this is done. The original STRICT-REDEFINITION proposal required users to deal with the use of symbols and lambda-expressions as functional arguments.  However this proposal is compatible with current CLtL definition in the use of symbols, which would be the hardest change to make.  There are probably relatively few uses of lambda-expressions as ``functions'', which can be dealt with by (EVAL `(FUNCTION ,lambda-expresssion)).Benefits: The term ``function'' would be given a useful and precise meaning. The FUNCTION datatype would be useful for type discrimination in CLOS. The type hierarchy would be simplified. This proposal brings Common Lisp slightly closer to Scheme and the work of the EuLisp committee. Scheme, for example, also has the concept of a ``procedure'' which is compatible with the FUNCTION type.Aesthetics: This proposal improves the aesthetics of the language. Lambda-expressions do not obey the normal, apparent scoping rules because free variables cannot refer to lexical bindings.  This is because coercing a list to a function would mean (EVAL `(FUNCTION ,list)). The following code does -not- count the number of nodes in a graph:  (LET ((COUNTER 0))    (TRAVERSE-THING '(LAMBDA (NODE) (INCF COUNTER))                    (THING-ROOT))) since it is not the same as  (LET ((COUNTER 0))    (TRAVERSE-THING #'(LAMBDA (NODE) (INCF COUNTER))                    (THING-ROOT))) which does pass around a closure incrementing the LET variable. (These examples assume COUNTER wasn't PROCLAIMed SPECIAL.) Making the coercion of lambda-expressions to functions explicit with the use of EVAL will encourage less confusing code and also highlight that use of EVAL.Discussion:This issue has been discussed at great length; this section attemptsonly to summarize the important points.There is general agreement that the definition of the FUNCTION data typemust be clarified or revised. The cleanup of the type hierarchy is importantto the CLOS group.The description of COMPILE must be changed, since it is no longermeaningful to speak of a symbol with a definition that "is alambda-expression".  We believe this is a subject for a separateproposal, as the behavior of COMPILE needs additional clarification.Many different alternatives have been discussed both in the cleanup committeeand X3J13. Two proposals were circulated at the March 1988 meeting of X3J13;this version is the result of discussions at that meeting. It is a compromisebetween the conflicting goals of backward compatibility, flexibility in thelanguage, and simple semantics. This proposal does not address the issue of when coercion to functions occur.For example, it is allowed to write(MAPCAR 'FROB my-list)It is not specified when the coercion of FROB to its SYMBOL-FUNCTION occurs. For example, (DEFUN FROB (X)    (WHEN (> X 0) (SETF (SYMBOL-FUNCTION 'FROB) #'(LAMBDA (X) NIL)))   T)(MAPCAR 'FROB '(-1 -1 1 1))may return different results if MAPCAR coerces its functional argumentonce rather than for each element. This may require a separatecleanup issue.        TITAN 
         TITAN 
          
TIMESROMAN 
          
TIMESROMAN 
                  \                                   s                           E                    &                   	z             s                                       \       
                   l             l      . z*start*01697 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 19 SEP 88 18:55:59 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03895g; Mon, 19 Sep 88 17:55:36 PSTReceived: by bhopal id AA15915g; Mon, 19 Sep 88 18:55:04 PDTDate: Mon, 19 Sep 88 18:55:04 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809200155.AA15915@bhopal>To: barmar@Think.COMCc: Masinter.pa, X3J13@sail.stanford.eduIn-Reply-To: Barry Margolin's message of Tue, 13 Sep 88 11:39 EDT <19880913153928.7.BARMAR@OCCAM.THINK.COM>Subject: Issue: FUNCTION-TYPE (version 12)re: First of all, not all implementations will bother creating a closure for    a function that is in the null lexical environment (Symbolics doesn't),    so it would be wrong to specify that it returns a closure.See CLtL, p87: "If fn is a lambda-expression, then a ``lexical closure''is returned, that is a function that when invoked will execute the bodyof the lambda-expresssion in such a way as to observe the rules oflexical scoping properly."   This applies regardless of whether or notthe lexical environment is null.What many persons miss is the fact that a perfectly ordinary compiledfunction with a null lexical environment satisfies the definition of"closure".  Possibly they are misled, as you may have been, by thefact that some vendors have a lower-level data-type that distinguishesfunctions closed over the null lexical environment  from those closedover something more significant.Incidentally, I thought this was a "Cleanup" subcommittee issue, and onlynow notice that is beng cc'd to X3J13 as a whole.  Was this a mistake?-- JonL --