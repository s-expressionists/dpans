*start*00653 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 JUL 88 09:28:28 PDTReceived: from ucbvax.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 12 Jul 88  09:26:29 PDTReceived: by ucbvax.Berkeley.EDU (5.59/1.28)	id AA25515; Tue, 12 Jul 88 09:24:27 PDTFrom: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUReceived: by trwrb (5.51/1.36)	id AA02189; Mon, 11 Jul 88 13:03:49 PDTDate: Mon, 11 Jul 88 13:03:49 PDTMessage-Id: <8807112003.AA02189@trwrb>To: cl-cleanup@sail.stanford.eduSubject: package-clutter:reduceI support this proposal.*start*01346 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 08 JUL 88 05:43:05 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 8 Jul 88  05:42:08 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 430362; 8 Jul 88 08:41:44 EDTReturn-path: <spt!gz@EDDIE.MIT.EDU>Received: from EDDIE.MIT.EDU by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 430319; 8 Jul 88 03:38:09 EDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA17985@EDDIE.MIT.EDU>; Fri, 8 Jul 88 03:37:44 EDTReceived: by spt.entity.com (smail2.5); 8 Jul 88 03:02:56 EDT (Fri)Date: 8 Jul 88 03:02:56 EDT (Fri)From: gz@spt.entity.com (Gail Zacharias)To: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <880707160733.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 1)Message-Id: <8807080302.AA14914@spt.entity.com>Resent-To: CL-Cleanup@SAIL.Stanford.EDUResent-From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Resent-Date: Fri, 8 Jul 88 08:41 EDTResent-Message-ID: <880708084135.3.KMP@PEWEE.SCRC.Symbolics.COM>How about the use of LISP package symbols for property names?*start*06412 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 JUL 88 13:09:43 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Jul 88  13:08:04 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 430072; Thu 7-Jul-88 16:07:49 EDTDate: Thu, 7 Jul 88 16:07 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880707160733.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        PACKAGE-CLUTTERReferences:   LISP package (p181)Category:     CHANGE/CLARIFICATIONEdit history: 07-Jul-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  CLtL specifies that   ``The package named LISP contains the primitives of     the Common Lisp system. Its external symbols include     all of the user-visible functions and global variables     that are present in the Common Lisp system, such as     CAR, CDR, *PACKAGE*, etc. Almost all other packages will     want to use LISP so that these symbosl will be accessible     without qualification.''  It specifies "all" but not "all and only".  Some implementations place their extensions in the Lisp package.  Nothing in CLtL prohibits this, but it leads to problems in general.  For example:  - A user defining a function by a name not mentioned in CLtL may be    surprised to clobber a system function in some implementations  - In one particular implementation, the variable HELP was a system    constant, so that ((LAMBDA (HELP) ...HELP...) "Press ? for help.")    signalled a correctable error (asking what variable to bind    instead of HELP :-).Proposal (PACKAGE-CLUTTER:REDUCE):  Specify that the LISP package must contain not only all the symbols  mentioned as part of the LISP package in standard, but only those symbols.  Specify that symbols in the LISP package may not have definitions other  than those specified.Examples:  #1: The symbol HELP may not be on the LISP package because it is not      mentioned in CLtL.  #2: The symbol VARIABLE is specified to be on the LISP package (because      it is a valid second argument to the DOCUMENTATION function). Since      it is not defined as a variable, type, or function, however, it may      not be bound, defined as a type, or defined as a function, macro or      special form.Rationale:  If extra symbols are permitted in the LISP package, users may be surprised  by relationships between the LISP package and other packages which they  did not expect, or may be surprised by functionality that they did not  expect. The degenerate case is:   (DEFCONSTANT LISP:A 'YOU-LOSE)   (DEFCONSTANT LISP:B 'YOU-LOSE)   (DEFCONSTANT LISP:C 'YOU-LOSE)      ...   (DEFCONSTANT LISP:AA 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   ...etc.  Given such an implementation, even things like (LAMBDA (X) X) are not  valid because they attempt to bind "system constants". It is necessary  that the programmer be able to know for sure that an arbitrary name is  "free for use" and best way to conveniently assure this is to require  that the LISP package be unadulterated.  As for the additional definitions, there are situations where additional  definitions would cause a problem. For example, if a symbol on the Lisp  package were declared as a special variable even though that value was  not mentioned in the standard, that variable would behave incorrectly when  used as a lexical variable. Similarly, if a symbol in the lisp package  were defined as an implementation-dependent special form, problems might  result if a user redefined or even bound (as by FLET or MACROLET) that  name.  The LISP package is the foothold from which portable programs establish  their desired environment. Careful control is desirable to make sure  everyone is starting off on the right foot.Current Practice:  Some implementations have been known to add additional symbols (usually  functional and/or variable extensions) to the LISP package.  Symbolics Genera currently has exactly the set of symbols on it which is  prescribed by CLtL. A few symbols, such as EVALHOOK, ROOM, and APPLYHOOK  are spuriously defined as special variables. The symbol LAMBDA is defined  as a macro. There may be a few other exceptions like this.Cost to Implementors:  The actual cost of moving the symbols out of the LISP package in cases  where they are not already gone is quite small. However, if any  implementation really has to do this, it may have a number of suppositions  about what is in what package, and the changes could potentially be extensive.Cost to Users:  This change is upward compatible with any portable program, but users  of a particular implementation's extensions may be forced to find their  functions in a different package, so there may be a measurable practical  cost.  In many cases where an extension symbol FOO is simply expected to have  been directly available (due to :USE "LISP"), it will work to just just  do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is  declared.  In many cases where an extension symbol FOO is used by explicit package  prefix, such as LISP:FOO, it should be easy to search for `LISP:FOO' or  even `LISP:' to find the cases.Cost of Non-Adoption:  The potential for the LISP package to be adulterated and for supposedly  portable programs to have difficulty getting a foothold in some  implementations will be `noticeably non-zero'.Benefits:  Portability of some programs will be enhanced.Aesthetics:  This change probably supports the naive expectation of most programmers  writing portable code.Discussion:  This issue came up a while back on Common-Lisp list. It got bogged down in  discussions of what the USER package and other system-specific packages might  contain. This proposal avoids the sticky issue of whether the USER package may  contain symbols other than those specified in the standard. The smart programmer  of portable code will never rely on the contents of the USER package anyway.  Pitman supports PACKAGE-CLUTTER:REDUCE.*start*02279 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 SEP 88 09:35:02 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 14 Sep 88  09:33:56 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 458973; Wed 14-Sep-88 12:32:42 EDTDate: Wed, 14 Sep 88 12:32 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTERTo: vanroggen%aitg.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8809141446.AA04055@decwrl.dec.com>Message-ID: <19880914163208.0.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Wed, 14 Sep 88 07:46:51 PDT    From: vanroggen%aitg.DEC@decwrl.dec.com    I think this issue also needs to address the default value for :USEd    packages.  (Or else the name should be changed to something more    specific like LISP-PACKAGE-CONTENTS.)    If we allow the default value for :USE to be implementation dependent,    I think users would be most happy.  If someone really wants just Common    Lisp, they would be able to say :USE '("LISP").  Otherwise they would    be able to get the same environment that the USER package has, since    implementations would have the flexibility to make them the same and    as rich as they would like to make them.    I think this is what resulted from those CL discussions a few years ago.    I'd guess that this is also what several implementations do.  Anyone    care to comment?Symbolics defaults :USE the way CLtL specifies, that is, to just theLISP package.  I'm really not sure that I agree with you that thedefault should be changed.  A program that wants a specific set ofimplementation dependent extensions really ought to ask for them by name[i.e. (make-package 'foo :use '(gulf-and-western-common-lisp))] so itcan be sure of what it's getting.  A program that wants the sameextensions as the user package can do so [i.e. (make-package 'foo:use (package-use-list (find-package 'user)))].I'm not sure how much this default matters.  I don't think I have everseen a defpackage that didn't specify :use explicitly.*start*01294 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 SEP 88 07:49:10 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 14 Sep 88  07:48:10 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA04055; Wed, 14 Sep 88 07:46:51 PDTDate: Wed, 14 Sep 88 07:46:51 PDTMessage-Id: <8809141446.AA04055@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: PACKAGE-CLUTTERI think this issue also needs to address the default value for :USEdpackages.  (Or else the name should be changed to something morespecific like LISP-PACKAGE-CONTENTS.)If we allow the default value for :USE to be implementation dependent,I think users would be most happy.  If someone really wants just CommonLisp, they would be able to say :USE '("LISP").  Otherwise they wouldbe able to get the same environment that the USER package has, sinceimplementations would have the flexibility to make them the same andas rich as they would like to make them.I think this is what resulted from those CL discussions a few years ago.I'd guess that this is also what several implementations do.  Anyonecare to comment?			---Walter*start*01857 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 SEP 88 10:11:37 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 14 Sep 88  10:10:39 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 459027; Wed 14-Sep-88 13:09:24 EDTDate: Wed, 14 Sep 88 13:08 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTERTo: Moon@STONY-BROOK.SCRC.Symbolics.COM, vanroggen%aitg.DEC@decwrl.dec.comcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <19880914163208.0.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <8809141446.AA04055@decwrl.dec.com>Message-ID: <880914130830.2.KMP@GRYPHON.SCRC.Symbolics.COM>I don't think the idea of making the default for :USE be implementationdependent is a very good one. It introduces incompatibility to no goodend.In Cloe, LISP:IN-PACKAGE defaults to :USE "LISP" but CLOE:IN-PACKAGEdefaults to :USE "CLOE". Since the USER package uses CLOE, doing(IN-PACKAGE "FOO") in that package is the same as doing (CLOE:IN-PACKAGE "FOO" :USE "CLOE").Users must do (LISP:IN-PACKAGE "FOO") if they want the effect of(LISP:IN-PACKAGE "FOO" :USE "LISP") without specifying an explicit:USE argument.Or they can, as various people have recommended in this discussion, do(IN-PACKAGE "FOO" :USE "LISP"). This will get them package somethingthat uses "LISP" whether they're getting CLOE:IN-PACKAGE orLISP:IN-PACKAGE.This may seem a little complicated, but practical experience shows thatit feels like the right thing. After all, we're not changing the meaningof LISP symbols, so anyone who requests LISP explicitly gets exactlywhat CLtL tells them to expect.*start*01811 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 16 SEP 88 17:53:07 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Sep 88  17:51:57 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 SEP 88 15:47:41 PDTDate: 16 Sep 88 15:47 PDTFrom: masinter.paSubject: Re: Issue: PACKAGE-CLUTTERIn-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 14 Sep 88 13:08 EDTTo: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880916-154741-1618@Xerox>I concur with the sentiment that the portability of default :USE is moreimportant than the slight ease of use, especially given the simple workaroundused by CLOE.The proposal as worded says "Specify that the LISP package must contain not onlyall the symbols  mentioned as part of the LISP package in standard, but only those symbols."I don't think you intend to disallow *internal* symbols in the LISP package,just *external* symbols, right?Also, it should say that the USER package should have *no* symbols, right? I.e.,USER uses LISP, is empty, and LISP has no symbols. This gives you a way ofwriting portable code that you know is portable..... (well, insofar as othersymbols are defined.)We should be careful about the word "must". Normally, "must" is associated withthe action of user programs: a user program "must" supply an integer to thisfunction otherwise it "is an error". However, this proposal is a constraint onCommon Lisp implementors and not on Common Lisp programs. Perhaps we can rely onthe editor to make the transition to the correct case, but is there a simple wayof expressing it in terms of valid programs? Perhaps that is an issue for theeditorial committee.*start*01373 00024 US Return-Path: <Scott.Fahlman@sef1.slisp.cs.cmu.edu>Received: from SEF1.SLISP.CS.CMU.EDU ([128.2.218.13]) by Xerox.COM ; 16 SEP 88 23:05:30 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 17 Sep 88 02:04:05 EDTTo: masinter.pacc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: PACKAGE-CLUTTER In-reply-to: Your message of 16 Sep 88 15:47:00 -0700.             <880916-154741-1618@Xerox> Date: Sat, 17 Sep 88 02:02:12 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU    Also, it should say that the USER package should have *no* symbols, right? I.e.,    USER uses LISP, is empty, and LISP has no symbols. This gives you a way of    writing portable code that you know is portable..... (well, insofar as other    symbols are defined.)    If you're saying what I think you're saying, I am opposed to this.  Backwhen we all agreed that LISP should export only the symbols mentioned inCLtL (or the standard that replaces it), I thought that we also agreed thatUSER was the place where an implementation was allowed to provide itsdefault environment.  This means CLtL symbols plus whatever other stuff animplementation wants to define as extensions: debugging functions, graphicsstuff, or whatever.If someone wants a completely empty package that uses only Lisp, theyshould create one.  That's easy and portable.-- Scott*start*02907 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 17 SEP 88 12:38:13 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 460923; Sat 17-Sep-88 15:03:25 EDTDate: Sat, 17 Sep 88 15:03 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PACKAGE-CLUTTER To: Scott.Fahlman@B.GP.CS.CMU.EDU, Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: The message of 17 Sep 88 02:02 EDT from Scott.Fahlman@B.GP.CS.CMU.EDU,             <880916-154741-1618@Xerox> Message-ID: <880917150318.6.KMP@GRYPHON.SCRC.Symbolics.COM>We had extensive discussions of what should go in the USER package awhile back on Common-Lisp. I was an advocate of a pure USER package,but I eventually decided it was not a battle to be won and have sincecome to believe that it is even the right thing for the USER packageto contain implementation-dependent junk.This time around, I deliberately avoided the issue of the USER packagein this proposal because I think it's a lost cause. If we just tellpeople that the USER package's sole purpose in life is for you to have apackage to stand in initially while you type (IN-PACKAGE'something-else), and if we tell people straight out that no portableprograms should ever expect to run in USER, I think we will be in fineshape.I am susceptible to the idea of LISP containing internal symbols, butI don't want to say that if we don't have to. The reason is that itdoes affect what DO-SYMBOLS will do, and so it will be a place whereportable programs will behave differently on a documented package.It also means that we may get opposition to later extensions becausesomeone has a LISP::something which collides unfavorably with a LISP:something that is proposed. All in all, I see no reason for systemprogramming not to be done in SYSTEM or some such and (DEFUN LISP:xxx ...)done where appropriate.Another problem this will avoid is the Zetalisp problem where they havea few things like EVALHOOK which are both exported functions and internal(special) variables. The internal variable accidentally shows throughbecause of an unintended name collision. This sort of thing is easilyfixed once noticed, but is just another error waiting to happen whichcould be avoided by programming in another package and accessing LISPonly when you mean to. [Arguably this is yet another indictment of thepackage system as a whole. Oh well.]I hope this doesn't launch into an interminable discussion on thisissue. The bottom line is that I want to keep hands off of USER and Iam prepared to immediately give in on allowing LISP internal symbols ifit looks like a fight will ensue. [Whatever we decide about the internal/external issue should be explicitly stated to avoid confusion.]*start*01514 00024 US Date: 17 Sep 88 13:18 PDTFrom: masinter.paSubject: Re: Issue: PACKAGE-CLUTTER In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Sat, 17 Sep 88 15:03 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Scott.Fahlman@B.GP.CS.CMU.EDU, Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUSometimes when you write a treaty, you just don't talk about the things that you think you might not agree about. However, a language specification has to be a bit more precise, especially in those areas where there really is a question.I think that either the standard should be completely silent about USER -- e.g., say "the initial package should be something other than LISP and the implementation should document what it is...", or else be explicit about it. What's the point of requiring this otherwise useless package? Again, this is a requirement for implementation rather than programs. If we want to point out to implementors in the notes the risk of internal uses of external symbols, I think that's OK as an 'implementation note', but I don't think its a good reason for forbidding the use of internal symbols in LISP. And that DO-SYMBOLS  might differ from implementation to implementation is not significantly different than the fact that DO-ALL-SYMBOLS might do so also.This reminds me of my desire to have a general non-exclusive registry of package, feature and module names. I'm thinking about how to best set it up.., but that's a separate topic.  *start*02079 00024 US Return-Path: <Scott.Fahlman@sef1.slisp.cs.cmu.edu>Received: from SEF1.SLISP.CS.CMU.EDU ([128.2.218.13]) by Xerox.COM ; 17 SEP 88 14:12:16 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 17 Sep 88 17:10:49 EDTTo: masinter.pacc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: PACKAGE-CLUTTER In-reply-to: Your message of 17 Sep 88 13:18:00 -0700.             <880917-131810-2375@Xerox> Date: Sat, 17 Sep 88 17:10:24 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU    I think that either the standard should be completely silent about USER -- e.g.,    say "the initial package should be something other than LISP and the    implementation should document what it is...", or else be explicit about it.    What's the point of requiring this otherwise useless package? Again, this is a    requirement for implementation rather than programs.     I agree that users should be told that the initial package may be somethingother than Lisp, and that it may have implementation=specific stuff in itwhich is presumably documented.  I see no harm in saying that this initaialpackage is named USER, but that its contents will differ from oneimplementation to another.  Then people who see this package name will atleast know what is going on.  On the other hand, there's no compellingreason why a standard name is needed for this non-standard thing.  As longas we're allowed to keep calling it USER, I don't really care whethereveryone is forced to call it that.  Some implementaitons might want tocome up with LISP as the default, I suppose.I think that there will definitely be at least a minor fight if someoneproposes to eliminate all the internal symbols of LISP.  That's anincompatible change, for us at least, and the only reason for it is toprevent errors when a user is doing something wrong in the first place.You don't live in Lisp unless you're the implementor; others should justUSE it.  As with any package, if you get into its insides, you areresponsible for knowing about what's already in there.-- Scott*start*01188 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 22:22:57 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 19 Sep 88  22:22:11 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 20 Sep 88 01:20:11 EDTTo: David N Gray <Gray@DSG.csc.ti.com>cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PACKAGE-CLUTTER In-reply-to: Your message of Mon, 19 Sep 88 19:40:57 -0500.             <2799708057-5084423@Kelvin> Date: Tue, 20 Sep 88 01:20:02 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU    I thought the idea was that the USER package would use the    implementation-dependent package(s), not that the implementation-dependent    features would reside in the USER package.    Sure.  Careless wording on my part.  I don't see what difference thismakes, however: the point is that there can be symbols accessible in USERthat are not among those named in CLtL.  One would hope that eachimplementation would document all these sysmbols, but I don't think thestandard has any business requiring this.-- Scott*start*01333 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 17:52:23 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 19 Sep 88  17:51:52 PDTReceived: by ti.com id AA18628; Mon, 19 Sep 88 19:49:35 CDTReceived: from Kelvin by tilde id AA15142; Mon, 19 Sep 88 19:39:40 CDTMessage-Id: <2799708057-5084423@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 19 Sep 88 19:40:57 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Scott.Fahlman@B.GP.CS.CMU.EDUCc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: PACKAGE-CLUTTER In-Reply-To: Msg of Sat, 17 Sep 88 02:02:12 EDT from Scott.Fahlman@B.GP.CS.CMU.EDU>      Back> when we all agreed that LISP should export only the symbols mentioned in> CLtL (or the standard that replaces it), I thought that we also agreed that> USER was the place where an implementation was allowed to provide its> default environment.  This means CLtL symbols plus whatever other stuff an> implementation wants to define as extensions: debugging functions, graphics> stuff, or whatever.I thought the idea was that the USER package would use theimplementation-dependent package(s), not that the implementation-dependentfeatures would reside in the USER package.*start*04630 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 00:22:24 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 20 Sep 88  00:21:59 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04084g; Mon, 19 Sep 88 23:20:21 PSTReceived: by bhopal id AA16980g; Tue, 20 Sep 88 00:19:47 PDTDate: Tue, 20 Sep 88 00:19:47 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809200719.AA16980@bhopal>To: vanroggen%aitg.DEC@decwrl.dec.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: vanroggen%aitg.DEC@decwrl.dec.com's message of Wed, 14 Sep 88 07:46:51 PDT <8809141446.AA04055@decwrl.dec.com>Subject: Issue: PACKAGE-CLUTTERre: I think this issue also needs to address the default value for :USEd    packages.  (Or else the name should be changed to something more    specific like LISP-PACKAGE-CONTENTS.)Agreed.  Either change the issue name, or add an amendment addressingthe default value for the :use argument to make-package.re: If we allow the default value for :USE to be implementation dependent,    I think users would be most happy.  If someone really wants just Common    Lisp, they would be able to say :USE '("LISP").  Otherwise they would    be able to get the same environment that the USER package has, since    implementations would have the flexibility to make them the same and    as rich as they would like to make them.From the vendors point of view, I think this is an overriding issue.  Nearly every vendor sells to a customer base in which users write code *primarily* for that vendor's Lisp.  Only a *very few* research establishments are propogating ideas in the form of portable code; and a couple of tools builders are supplying their product on many vendor's platforms.  Since there is only one option available for the :use default, Lucid has already decided to give the very tiny bias towards the overwhelmingly larger customer base.  The advantages to this larger "base" are:   (1) Greater conformance of the vendor's documentation with what is       actually available in the default package -- USER -- and in a       new package made with the default options.   (2) No need to insist that the vendor document all his extensions       as, say, ACME-COMMON-LISP:WONDERFUL, but his manual can simply        say WONDERFUL without "qualification".   (3) A few keystrokes less when typing MAKE-PACKAGE (or IN-PACKAGE).Now, the downside for those actually writing portable code seems to be exactly null.  At worst it would merely mean that they would have to add an explicit :use argument to each call to MAKE-PACKAGE  (or to IN-PACKAGE).However, as a practical matter, it turns out they have done this already. I remember Dave Plummer of Symbolics mentioning two years ago that even when not writing portable code, he never allowed the :use argument to be defaulted. [Why? I'm not sure, but having survived several internal changes myself, I suspect it was to insulate onself from the shifting winds of developement cycles.]The issue is not portability, but rather deciding which part of the user community has to type those extra keystrokes.re: I think this is what resulted from those CL discussions a few years ago.    I'd guess that this is also what several implementations do.  Anyone    care to comment?I think so too.  [In fact, Lucid changed it's layout about a year ago to conform to what you describe].  In those discussions of 1986, I remember three main highlights:   (1) The LISP package should not contain any symbols other than the 775        found in CLtL (which of course must be external);  several mail        iterations were required to get the several vendors to agree on        the specific list of 775.  Most people agreed on this issue, but       there may have been one or two holdouts.   (2) Vendor-specific extensions should not be put into *any* of the       CLtL specified packages -- not even SYSTEM -- since by definition        they will not be portable, and since a coincidence of names in the       "extensions" package between two different vendors would probably       not imply the same functionality.   (3) The favored suggestion (which may not have had consensus) for the        vendor-specific extensions was that they should be placed into a       package named like ACME-COMMON-LISP for the "Acme" company.  Paul       the greek even volunteered to maintain a registry of names for        such packages (but alas ...).-- JonL --*start*00908 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 00:39:32 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 20 Sep 88  00:39:01 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 20 SEP 88 00:37:38 PDTDate: 20 Sep 88 00:37 PDTFrom: masinter.paSubject: Re: Issue: PACKAGE-CLUTTERIn-reply-to: Jon L White <jonl@lucid.com>'s message of Tue, 20 Sep 88 00:19:47 PDTTo: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduMessage-ID: <880920-003738-3287@Xerox>When you're about to release Lucid Common Lisp version  17, you'll be glad thatwe made the default for :USE be LISP so that you could support users who want to:USE '("LUCID-3-0") ?What's today a vendor-to-vendor issue is as likely to become aversion-to-version issue for you, no?*start*02973 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 23 SEP 88 00:19:53 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA07282g; Thu, 22 Sep 88 23:19:22 PSTReceived: by bhopal id AA08357g; Fri, 23 Sep 88 00:18:50 PDTDate: Fri, 23 Sep 88 00:18:50 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809230718.AA08357@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 20 Sep 88 00:37 PDT <880920-003738-3287@Xerox>Subject: Issue: PACKAGE-CLUTTERre: When you're about to release Lucid Common Lisp version  17, you'll be     glad that we made the default for :USE be LISP so that you could support     users who want to    :USE '("LUCID-3-0") ?    What's today a vendor-to-vendor issue is as likely to become a    version-to-version issue for you, no?Absolutely not; in fact, I think you have it backwards.  The simple pathof porting from and old version release to a newer one is SURELY thwarted if the end user's code has calls like:	(make-package ... :use '("LUCID-3-0"))Only when the customer takes the default use list will he get the documentedenvironment.  Consider when *default-make-package-use-list* changes from	("LISP" "LUCID-COMMON-LISP") to:	("LISP" "LUCID-COMMON-LISP" "LU-GRAPHICS")[I did mention didn't I that the extensions are found in a package that is not version dependent -- namely, LUCID-COMMON-LISP.]  In effect, Lucidhas guaranteed that at least the LISP and LUCID-COMMON-LISP packages will be around, and that they will be changed to meet the demands of the Common Lisp Language and of Lucid's primary extensions thereto.The place for the explicit :use list is for "portable" code -- it doesn'twant any of the vendor-specific stuff from the old release, and it doesn'twant any from the new release either!One must remember that porting code from older releases to newer ones does require user involvement.  For a programmer who makes use of the vendor-specific extensions, it cannot be solved merely by restricting the packageuse list.  Successive releases of Vendor Common Lisp will no doubt have a few more symbols in them than earlier releases had [sigh, not likely that very many will be removed].  An explicit :use list in customer package creations will not shield him against such additions or deletions; but in fact could put him in an partial environment that doesn't make much sense.  Of course, there will be applications which do want to supply an explicit,non-default :use list -- for example:	("LISP" "SYSTEM" "VENDOR-COMMON-LISP" "GRAPHICS")and these will require more than the usual amount of  attention when thevendor inflicts a major release cycle upon that community.  Not only will such users have to peruse the differential documentation, but they will have to peruse all their code for :use lists that may no longer be workable.-- JonL --*start*08999 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 SEP 88 01:25:39 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Sep 88  01:24:51 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 23 SEP 88 01:15:03 PDTDate: 23 Sep 88 01:15 PDTFrom: masinter.paSubject: Issue: PACKAGE-CLUTTER (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880923-011503-3968@Xerox>I've made several changes to the proposal, only some of which were justified bythe discussion:	I explicitly said that LISP might have additional internal symbols.	I eliminated the requirement that there be a SYSTEM package. 		(This is out of the blue. Exactly what belonged in SYSTEM vs STORAGE-ALLOCATOR			or FILE-SYSTEM always baffled me. )	I made explict that USER might contain implementation-specific symbols, 		as well as using implementation-specific packages.  	I mentioned that CLOS and the condition system might have their	own packages. I think we might be able to pass a package-clutter issue and deal with a newissue  MAKE-PACKAGE-USE-DEFAULT separately, or possibly as an amendment to thisone.!Issue:        PACKAGE-CLUTTERReferences:   LISP, USER, SYSTEM packages (p181)		   Issue: DEFPACKAGE		  Issue: IN-PACKAGE-FUNCTIONALITYCategory:     CHANGE/CLARIFICATIONEdit history: 07-Jul-88, Version 1 by Pitman		23-Sep-88, Version 2 by MasinterProblem Description:  CLtL specifies that   ``The package named LISP contains the primitives of     the Common Lisp system. Its external symbols include     all of the user-visible functions and global variables     that are present in the Common Lisp system, such as     CAR, CDR, *PACKAGE*, etc. Almost all other packages will     want to use LISP so that these symbosl will be accessible     without qualification.''  It specifies "all" but not "all and only".  Some implementations place their extensions in the Lisp package.  Nothing in CLtL explicitly prohibits this, but it leads to problems   in general.  For example:  - A user defining a function by a name not mentioned in CLtL may be    surprised to clobber a system function in some implementations  - In one particular implementation, the variable HELP was a system    constant, so that ((LAMBDA (HELP) ...HELP...) "Press ? for help.")    signalled a correctable error (asking what variable to bind    instead of HELP :-).Proposal (PACKAGE-CLUTTER:REDUCE):  Specify that, not only must the LISP package  contain at least all of the  symbols listed in the standard, it will have no other external symbols.  (The LISP package may have additional internal symbols.)  Those symbols with function, variable, macro, setf, constant definitions  or uses as properties or tokens may have no other additional definitions  other than those specified.  Eliminate the requirement that the initial Common Lisp system   have a package named "SYSTEM". Specify that implementations may  have several other packages available.  Clarify that the "USER" package may have additional symbols interned  within it and that it may :USE other implementation-specific packages.  Examples:  #1: The symbol HELP may not be on the LISP package because it is not      mentioned in CLtL.  #2: The symbol VARIABLE is specified to be on the LISP package (because      it is a valid second argument to the DOCUMENTATION function). Since      it is not defined as a variable, type, or function, however, it may      not be bound, defined as a type, or defined as a function, macro or      special form.Rationale:  If extra symbols are permitted in the LISP package, users may be surprised  by relationships between the LISP package and other packages which they  did not expect, or may be surprised by functionality that they did not  expect. The degenerate case is:   (DEFCONSTANT LISP:A 'YOU-LOSE)   (DEFCONSTANT LISP:B 'YOU-LOSE)   (DEFCONSTANT LISP:C 'YOU-LOSE)      ...   (DEFCONSTANT LISP:AA 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   ...etc.  Given such an implementation, even things like (LAMBDA (X) X) are not  valid because they attempt to bind "system constants". It is necessary  that the programmer be able to know for sure that an arbitrary name is  "free for use" and best way to conveniently assure this is to require  that the LISP package be unadulterated.  As for the additional definitions, there are situations where additional  definitions would cause a problem. For example, if a symbol on the Lisp  package were declared as a special variable even though that value was  not mentioned in the standard, that variable would behave incorrectly when  used as a lexical variable. Similarly, if a symbol in the lisp package  were defined as an implementation-dependent special form, problems might  result if a user redefined or even bound (as by FLET or MACROLET) that  name.  The LISP package is the foothold from which portable programs establish  their desired environment. Careful control is desirable to make sure  everyone is starting off on the right foot.Current Practice:  Some implementations have been known to add additional symbols (usually  functional and/or variable extensions) to the LISP package.  Symbolics Genera currently has exactly the set of symbols on it which is  prescribed by CLtL. A few symbols, such as EVALHOOK, ROOM, and APPLYHOOK  are spuriously defined as special variables. The symbol LAMBDA is defined  as a macro. There may be a few other exceptions like this.Cost to Implementors:  The actual cost of moving the symbols out of the LISP package in cases  where they are not already gone is quite small. However, if any  implementation really has to do this, it may have a number of suppositions  about what is in what package, and the changes could potentially be extensive.Cost to Users:  This change is upward compatible with any portable program, but users  of a particular implementation's extensions may be forced to find their  functions in a different package, so there may be a measurable practical  cost.  In many cases where an extension symbol FOO is simply expected to have  been directly available (due to :USE "LISP"), it will work to just just  do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is  declared.  In many cases where an extension symbol FOO is used by explicit package  prefix, such as LISP:FOO, it should be easy to search for `LISP:FOO' or  even `LISP:' to find the cases.Cost of Non-Adoption:  The potential for the LISP package to be adulterated and for supposedly  portable programs to have difficulty getting a foothold in some  implementations will be `noticeably non-zero'.Benefits:  Portability of some programs will be enhanced.Aesthetics:  This change probably supports the naive expectation of most programmers  writing portable code.Discussion:  This issue came up a while back on Common-Lisp list. The issue  of whether the   USER package may contain symbols other than those   specified in the standard was controversial.  The smart programmer  of portable code will never rely on the contents of the  USER package.    However, if someone wants a completely empty   package that uses only Lisp, it's easy and portable to create one.  While it would improve portability slightly to disallow additional internal  symbols in the LISP package (since it affects what DO-SYMBOLS will do)  explicitly prohibiting a common practice didn't seem like the best way  to discourage a possibly troublesome implementation technique.   Implementors should be especially careful about accidentally   exporting unwanted additional definitions for symbols,e.g., a variable   definition for EVALHOOK which might show through because of   an unintended name collision.  It is likely that the recently included portions of the standard (CLOS and  the signal mechanism) will reside in their own packages. These externally  defined packages should have the same constraints as outlined for  the LISP package here.  There has been a suggestion that vendor-specific extensions should  be placed in a package named like ACME-COMMON-LISP for the "Acme"  company.   A registry of packages (as well as features, modules and other global  names) would be useful, although probably not a part of the language  standard, per se.  There is considerable debate in the cleanup committee whether the default  value for the :USE keyword in IN-PACKAGE, MAKE-PACKAGE (and  the proposed DEFPACKAGE) should be changed to be implementation    specific. This version of the proposal leaves the default value as specified  in CLtL, namely, that it is the "LISP" package.  There was not consensus on this sub-issue; it could be handled as a separate  issue, if this proposal is endorsed by X3J13.*start*00934 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 26 SEP 88 17:22:29 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA09628g; Mon, 26 Sep 88 16:21:48 PSTReceived: by bhopal id AA02450g; Mon, 26 Sep 88 17:21:20 PDTDate: Mon, 26 Sep 88 17:21:20 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809270021.AA02450@bhopal>To: masinter.paCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: masinter.pa@Xerox.COM's message of 23 Sep 88 01:15 PDT <880923-011503-3968@Xerox>Subject: Issue: PACKAGE-CLUTTER (Version 2)re: Current Practice:    . . .     Symbolics Genera currently has exactly the set of symbols on it which is    prescribed by CLtL. Lucid has exactly such set in the Lisp package.  In fact, several iterationsbetween Dan Weinreb, Penny (last name?), and myself were required duringthe summer of 1986 to get it right.-- JonL --*start*01303 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 26 SEP 88 17:54:38 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 466064; Mon 26-Sep-88 20:54:10 EDTDate: Mon, 26 Sep 88 20:54 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 2)To: Jon L White <jonl@lucid.com>cc: masinter.pa, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8809270021.AA02450@bhopal>Message-ID: <19880927005412.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Mon, 26 Sep 88 17:21:20 PDT    From: Jon L White <jonl@lucid.com>    re: Current Practice:	. . . 	Symbolics Genera currently has exactly the set of symbols on it which is	prescribed by CLtL.     Lucid has exactly such set in the Lisp package.  In fact, several iterations    between Dan Weinreb, Penny (last name?), Parkinson.					     					     and myself were required during    the summer of 1986 to get it right.Agreed.  If I recall what I heard about this, the problem is that it's difficultto extract from CLtL the set of symbols that are specified to be in the Lisppackage, since a few of them are not in the index.*start*01822 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 21:03:27 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Sep 88  21:03:18 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 466128; Tue 27-Sep-88 00:02:00 EDTDate: Tue, 27 Sep 88 00:02 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <880923-011503-3968@Xerox>Message-ID: <19880927040206.4.MOON@EUPHRATES.SCRC.Symbolics.COM>  Those symbols with function, variable, macro, setf, constant definitions  or uses as properties or tokens may have no other additional definitions  other than those specified.I cannot support this as stated.  The word "definitions" is not defined.It is unclear why this restriction applies only to a subset of the symbolsexported by the LISP package instead of all those symbols.  I'm not surethe generalization from SPECIAL proclamations (the original complaint)to all "definitions" is justified, and I'm sure I don't understand allof its ramifications.If that paragraph were changed to something like the following I thinkI could support the proposal.  I'd want to check the rest of the detailsa bit more carefully.  Implementations are not permitted to proclaim SPECIAL additional  external symbols of the LISP package beyond the symbols defined by  Common Lisp to be variables or constants.I think the next specification of Common Lisp needs to contain acomprehensive list of every symbol exported by the LISP package andthe characteristics of that symbol.*start*01618 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 10:06:31 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Sep 88  10:06:22 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 466365; Tue 27-Sep-88 13:04:57 EDTDate: Tue, 27 Sep 88 13:04 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 2)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <19880927040206.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <880927130442.2.KMP@GRYPHON.SCRC.Symbolics.COM>I'm concerned about things mentioned in the spec as functionswhich turn out to also be variables and vice versa. Ditto fortypes. If either the system or any user application defines such,it gets forced down everyone's throat and potentially clobberssomeone else's supposedly private application. It also reducesthe level of error checking provided to users who think they'regetting strict CLtL by just using things on LISP.How would you feel about something like the following. It'sbroader, but still tries to be specific... Symbols on the LISP package may have function or macro definitions, variable definitions or SPECIAL proclamations, or type definitions only if explicitly permitted in the specification. Neither users nor implementors are permitted to add new kinds of definitions for these symbols.*start*01508 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 19:28:33 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 27 Sep 88  19:28:35 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 27 Sep 88 22:24:27 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: PACKAGE-CLUTTER (Version 2) In-reply-to: Your message of Tue, 27 Sep 88 13:04:00 -0400.             <880927130442.2.KMP@GRYPHON.SCRC.Symbolics.COM> Date: Tue, 27 Sep 88 22:23:54 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU     Symbols on the LISP package may have function or macro     definitions, variable definitions or SPECIAL proclamations, or     type definitions only if explicitly permitted in the specification.     Neither users nor implementors are permitted to add new kinds of     definitions for these symbols.    I don't know what "variable definitions" means.Does this mean that I, as a user, am not allowed to use symbols such asLIST, MEMBER, or SYMBOL as a lexical variable in my own protable code?  Ifso, I am very strongly opposed to this.  The conversion cost would be veryhigh, and I don't see any safety issue that would force us to restrict theuser in this way.  If that is not the intended meaning, perhaps someclearer wording is needed.I'd go along with the other cases.-- Scott*start*02104 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 09:15:06 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Sep 88  09:14:11 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 467007; Wed 28-Sep-88 12:12:34 EDTDate: Wed, 28 Sep 88 12:12 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: PACKAGE-CLUTTER (Version 2) To: Scott.Fahlman@B.GP.CS.CMU.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: The message of 27 Sep 88 22:23 EDT from Scott.Fahlman@B.GP.CS.CMU.EDUMessage-ID: <880928121218.6.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Tue, 27 Sep 88 22:23:54 EDT    From: Scott.Fahlman@B.GP.CS.CMU.EDU	Date: Tue, 27 Sep 88 13:04:00 EDT	From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>	 Symbols on the LISP package may have function or macro	 definitions, variable definitions or SPECIAL proclamations, or	 type definitions only if explicitly permitted in the specification.	 Neither users nor implementors are permitted to add new kinds of	 definitions for these symbols.        I don't know what "variable definitions" means.    Does this mean that I, as a user, am not allowed to use symbols such as    LIST, MEMBER, or SYMBOL as a lexical variable in my own protable code?  If    so, I am very strongly opposed to this.  The conversion cost would be very    high, and I don't see any safety issue that would force us to restrict the    user in this way.  If that is not the intended meaning, perhaps some    clearer wording is needed.    I'd go along with the other cases.I wasn't really thinking about this issue, but I'd be happy if youcouldn't have global definitions of LIST, MEMBER, etc. or SPECIALbindings of them. But it's ok with me if you have lexical bindings of them.Would that satisfy you. Does that seem to inconsistent to anyone?*start*01448 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 11:57:20 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 28 Sep 88  11:56:37 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 28 Sep 88 14:53:42 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: PACKAGE-CLUTTER (Version 2) In-reply-to: Your message of Wed, 28 Sep 88 12:12:00 -0400.             <880928121218.6.KMP@GRYPHON.SCRC.Symbolics.COM> Date: Wed, 28 Sep 88 14:53:08 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU    I wasn't really thinking about this issue, but I'd be happy if you    couldn't have global definitions of LIST, MEMBER, etc. or SPECIAL    bindings of them. But it's ok with me if you have lexical bindings of them.    Would that satisfy you. Does that seem to inconsistent to anyone?    It would satisfy me to say that can't be proclaimed special (they'respelled wrong for that anyway -- not surrounded by stars), and that it isan error to special-bind any of these.  I'm wary of the cost is we say"signals an error".As for global bindings, it depends on what that "global" ends up meaning.I can't think about that yet, since I have not totally internalized theimplications of the various proposals flying around.-- Scott*start*00962 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 13:08:48 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Sep 88  13:07:18 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00937g; Wed, 28 Sep 88 12:04:46 PSTReceived: by bhopal id AA09299g; Wed, 28 Sep 88 13:04:19 PDTDate: Wed, 28 Sep 88 13:04:19 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809282004.AA09299@bhopal>To: Scott.Fahlman@B.GP.CS.CMU.EDUCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Wed, 28 Sep 88 14:53:08 EDT <8809281858.AA00875@lucid.com>Subject: Issue: PACKAGE-CLUTTER (Version 2) Say, you guys have been discussing the LISP-SYMBOL-REDEFINITION issueunder the banner of "Issue: PACKAGE-CLUTTER".  Wanna switch?-- JonL --*start*01791 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 13:13:14 PDTReceived: from ELEPHANT-BUTTE.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 28 Sep 88  13:11:47 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by ELEPHANT-BUTTE.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 323211; Wed 28-Sep-88 16:09:17 EDTDate: Wed, 28 Sep 88 16:09 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 2) To: jonl@lucid.comcc: Scott.Fahlman@B.GP.CS.CMU.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8809282004.AA09299@bhopal>Message-ID: <880928160917.3.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Wed, 28 Sep 88 13:04:19 PDT    To: Scott.Fahlman@B.GP.CS.CMU.EDU    Cc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDU    In-Reply-To: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Wed, 28 Sep 88 14:53:08 EDT <8809281858.AA00875@lucid.com>    Subject: Issue: PACKAGE-CLUTTER (Version 2)     Say, you guys have been discussing the LISP-SYMBOL-REDEFINITION issue    under the banner of "Issue: PACKAGE-CLUTTER".  Wanna switch?    -- JonL --I guess I accidentally broadened the issue when I changed some sentencethat said "the system can't provide..." to say "no one can..." or somesuch thing. It's just as dangerous for the user to do it as the system,so the issues are related. Would it make sense to merge the issues asa single new issue LISP-SYMBOL-DEFINITION? I'd prefer to do that ratherthan ask people to talk about only half the subject at a time. If aftermore discussion we needed to break it back out into two topics, we couldstill do so...*start*02139 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 16:46:18 PDTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 28 Sep 88  16:45:37 PDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA09075@EDDIE.MIT.EDU>; Wed, 28 Sep 88 19:43:21 EDTReceived: by spt.entity.com (smail2.5); 28 Sep 88 18:08:31 EDT (Wed)To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: Scott.Fahlman@B.GP.CS.CMU.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Wed, 28 Sep 88 12:12 EDT <880928121218.6.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 2) Message-Id: <8809281808.AA29619@spt.entity.com>Date: 28 Sep 88 18:08:31 EDT (Wed)From: gz@spt.entity.com (Gail Zacharias)   Date: Wed, 28 Sep 88 12:12 EDT   From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>   I wasn't really thinking about this issue, but I'd be happy if you   couldn't have global definitions of LIST, MEMBER, etc. or SPECIAL   bindings of them. But it's ok with me if you have lexical bindings of them.   Would that satisfy you. Does that seem to inconsistent to anyone?Yes.  I sometimes find it useful to put temporary special declarations onnormally-lexical variables as a q&d debugging technique.  I don't see why Ishouldn't be allowed to do this for a variable named LIST.  I also don't seewhy I shouldn't be allowed to have a macro named MOST-POSITIVE-FIXNUM.  Infact I don't really understand the motivation for putting ANY restrictions onUSERS wrt this issue.  It seems to be mainly a matter of style or goodprogramming practice but then so is putting *'s around specials, and thestandard isn't going to require that.  If a programmer doesn't choose to beconcerned about co-existing with other programs in the same lisp, that's hisbusiness.  He might even know what he's doing. Implementations might want toissue warnings in such cases, but that's not the same as making such programsarbitrarily illegal.*start*01554 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 18:41:28 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Sep 88  17:55:05 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01347g; Wed, 28 Sep 88 16:52:46 PSTReceived: by bhopal id AA10573g; Wed, 28 Sep 88 17:52:20 PDTDate: Wed, 28 Sep 88 17:52:20 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809290052.AA10573@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: Scott.Fahlman@B.GP.CS.CMU.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Wed, 28 Sep 88 16:09 EDT <880928160917.3.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 2) re: ... Would it make sense to merge the issues as    a single new issue LISP-SYMBOL-DEFINITION? I'd prefer to do that rather    than ask people to talk about only half the subject at a time. ...I thought the PACKAGE-CLUTTER issue successfully attacked the problemof what symbols should be present in the LISP package.  The constraintabout vendors not putting additional definitions on LISP packagesymbols seems ok in this context, but widening it out to a proscriptionagains the user "using" these names seem better suited to the contextof LISP-SYMBOL-REDEFINITION.The former issue seems to be (finally!) non-controversial; but the latter is sure to have ongoing dissension.-- JonL --*start*01063 00024 US Return-Path: <spt!gz@EDDIE.MIT.EDU>Received: from EDDIE.MIT.EDU ([18.62.0.6]) by Xerox.COM ; 23 SEP 88 03:37:09 PDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA26442@EDDIE.MIT.EDU>; Fri, 23 Sep 88 06:37:02 EDTReceived: by spt.entity.com (smail2.5); 23 Sep 88 06:29:20 EDT (Fri)To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 23 Sep 88 01:15 PDT <880923-011503-3968@Xerox>Subject: Issue: PACKAGE-CLUTTER (Version 2)Message-Id: <8809230629.AA07711@spt.entity.com>Date: 23 Sep 88 06:29:20 EDT (Fri)From: gz@spt.entity.com (Gail Zacharias)   Date: 23 Sep 88 01:15 PDT   From: masinter.pa@Xerox.COM     Those symbols with function, variable, macro, setf, constant definitions     or uses as properties or tokens may have no other additional definitions     other than those specified.This might be interpreted as saying that LISP: symbols cannot have anyadditional properties, rather than saying that they cannot be used as names ofproperties, which (I hope) is the intent.*start*02587 00024 US Return-Path: <Scott.Fahlman@sef1.slisp.cs.cmu.edu>Received: from SEF1.SLISP.CS.CMU.EDU ([128.2.218.13]) by Xerox.COM ; 23 SEP 88 07:07:44 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 23 Sep 88 10:06:53 EDTTo: masinter.pacc: CL-Cleanup@SAIL.Stanford.EDUSubject: Re: Issue: PACKAGE-CLUTTER (Version 2) In-reply-to: Your message of 23 Sep 88 01:15:00 -0700.             <880923-011503-3968@Xerox> Date: Fri, 23 Sep 88 10:06:14 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU      Those symbols with function, variable, macro, setf, constant definitions      or uses as properties or tokens may have no other additional definitions      other than those specified.      ...      #2: The symbol VARIABLE is specified to be on the LISP package (because          it is a valid second argument to the DOCUMENTATION function). Since          it is not defined as a variable, type, or function, however, it may          not be bound, defined as a type, or defined as a function, macro or          special form.      ...      As for the additional definitions, there are situations where additional      definitions would cause a problem. For example, if a symbol on the Lisp      package were declared as a special variable even though that value was      not mentioned in the standard, that variable would behave incorrectly when      used as a lexical variable. Similarly, if a symbol in the lisp package      were defined as an implementation-dependent special form, problems might      result if a user redefined or even bound (as by FLET or MACROLET) that      name.Where did this come from?  I am vehemently opposed to this, if you intendthis restriction to apply to users as well as to implementors.  We've got alanguage that, for better or worse, has separate namespaces for functionsand variables, and additional namespaces for properties and flags ofvarious kinds.  Just because Lisp pre-empts the use of some symbol as afunction name does not mean that users should be prevented from using it asa variable name or marker in a property list.If we impose this restriction now, we are creating a very large "cost ofadoption".  Just as one example, every user program that uses LIST orSYMBOL or MEMBER as a local variable will have to be altered.If we want to say anything along these lines, we should say that*implementors* must not use these exposed symbols in additional,undocumented ways within their implementations, since users can get hold ofthese symbols and use them in conflicting ways.-- Scott*start*01865 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 OCT 88 14:35:16 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 4 Oct 88  14:31:42 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 470483; Tue 4-Oct-88 17:30:13 EDTDate: Tue, 4 Oct 88 17:29 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 2)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <880927130442.2.KMP@GRYPHON.SCRC.Symbolics.COM>Message-ID: <19881004212955.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 27 Sep 88 13:04 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    How would you feel about something like the following. It's    broader, but still tries to be specific...     Symbols on the LISP package may have function or macro     definitions, variable definitions or SPECIAL proclamations, or     type definitions only if explicitly permitted in the specification.     Neither users nor implementors are permitted to add new kinds of     definitions for these symbols.I agree with those who have commented that it is not Common Lisp(the language)'s business to prohibit users from doing this.  Itwould make sense to advise users that it's a dangerous practice.I like the analogy with the advise to users to enclose names ofspecial variables in asterisks.As for the system, I agree with what I think is your intent, butthe wording would need to be much more unambiguous for this to beviable in a language specification.  I was going to try to helpwith the wording, but decided I didn't have time.*start*00868 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 15:52:01 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Oct 88  15:51:31 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 05 OCT 88 15:28:14 PDTDate: 5 Oct 88 15:15 PDTFrom: masinter.paSubject: Re: Issue: PACKAGE-CLUTTER (Version 3)In-reply-to: masinter.pa's message of 5 Oct 88 14:08 PDTTo: masinter.pacc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881005-152814-1619@Xerox>I forgot to include the summary of changes at the beginning of the message.I think I responded to most of the criticisms; I left the prohibitions ofwhat the user might do to LISP-SYMBOL-REDEFINITION, expanded on the problemdescription, current practice and description sections.*start*00507 00024 US Date:  5 Oct 88 15:15 PDTFrom: masinter.paSubject: Re: Issue: PACKAGE-CLUTTER (Version 3)In-reply-to: masinter.pa's message of 5 Oct 88 14:08 PDTTo: masinter.pacc: CL-Cleanup@SAIL.Stanford.EDUI forgot to include the summary of changes at the beginning of the message. I think I responded to most of the criticisms; I left the prohibitions of what the user might do to LISP-SYMBOL-REDEFINITION, expanded on the problem description, current practice and description sections.*start*02309 00024 US Return-Path: <@STONY-BROOK.SCRC.Symbolics.COM,@BOBOLINK.SCRC.Symbolics.COM:KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 06 OCT 88 01:31:09 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 471580; 6 Oct 88 04:31:24 EDTDate: Thu, 6 Oct 88 04:31 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 3)To: masinter.pacc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <880923-011503-3968@Xerox>Message-ID: <881006043113.3.KMP@BOBOLINK.SCRC.Symbolics.COM>A few comments...    Date: 5 Oct 88 14:08 PDT    From: masinter.pa@Xerox.COM    ...    Issue:        PACKAGE-CLUTTER    ...    Proposal (PACKAGE-CLUTTER:REDUCE):    ...      That is, a program is valid Common Lisp if it assumes that      this is true; for example, FBOUNDP will be false for all      external symbols of the LISP package except those documented      to be functions or macros; BOUNDP will be false for all      those except those documented to be functions or macros,Don't you mean "variables"?    ...      Eliminate the requirement that the initial Common Lisp system      have a package named "SYSTEM". Specify that implementations may      have several other packages available.I'm not sure I agree with doing this. The purpose of "SYSTEM" is not sousers can rely on it, but rather so they'll know what -not- to use.Since some systems have other packages locked up as well, maybe that'sa weak argument. Maybe your package registry is the only way to go...      Clarify that the "USER" package may have additional symbols interned      within it and that it may :USE other implementation-specific packages.Why not say "USER" is empty but uses other packages, includingimplementation-specific ones? I don't see any reason why that couldn'tbe trivially made to be true.      Examples:     ...      #2: Since it is not defined as a variable, type, or function, however,           it may not be bound, defined as a type, or defined as a function,          macro or special form."may not be initially bound, ..." would make this consistent with yourdesire not to trample on LISP-SYMBOL-REDEFINITION.*start*08802 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 14:17:30 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Oct 88  14:16:58 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 05 OCT 88 14:09:38 PDTDate: 5 Oct 88 14:08 PDTFrom: masinter.paSubject: Issue: PACKAGE-CLUTTER (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880923-011503-3968@Xerox>!Issue:        PACKAGE-CLUTTERReferences:   LISP, USER, SYSTEM packages (p181)Related issues: LISP-SYMBOL-REDEFINITION, DEFPACKAGE, 		MAKE-PACKAGE-USE-DEFAULT, IN-PACKAGE-FUNCTIONALITY		 Category:     CHANGE/CLARIFICATIONEdit history: 07-Jul-88, Version 1 by Pitman		23-Sep-88, Version 2 by Masinter		 5-Oct-88, Version 3 by MasinterProblem Description:  CLtL specifies that   ``The package named LISP contains the primitives of     the Common Lisp system. Its external symbols include     all of the user-visible functions and global variables     that are present in the Common Lisp system, such as     CAR, CDR, *PACKAGE*, etc. Almost all other packages will     want to use LISP so that these symbosl will be accessible     without qualification.''  It specifies "all" but not "all and only".  Some implementations place their extensions in the Lisp package.  Nothing in CLtL explicitly prohibits this, but it leads to problems   in general.  For example:  - A user defining a function by a name not mentioned in CLtL may be    surprised to clobber a system function in some implementations  - In one particular implementation, the variable HELP was a system    constant, so that ((LAMBDA (HELP) ...HELP...) "Press ? for help.")    signalled a correctable error (asking what variable to bind    instead of HELP :-).Proposal (PACKAGE-CLUTTER:REDUCE):  Specify that, not only must the LISP package  contain at least all of the  symbols listed in the standard, it will have no other external symbols.  (The LISP package may have additional internal symbols.) Symbols on the LISP package may have function or macro definitions, top level value or SPECIAL proclamations, or type definitions only if explicitly permitted in the specification. That is, a program is valid Common Lisp if it assumes that  this is true; for example, FBOUNDP will be false for all  external symbols of the LISP package except those documented  to be functions or macros; BOUNDP will be false for all  those except those documented to be functions or macros,  and portable programs can use symbols in the LISP package as local lexical variables with the presumption that the variables  are not proclaimed special, except for those variables specified  as constants or variables.  (The proposal LISP-SYMBOL-REDEFINITION addresses the  converse; that is, what user programs are allowed to do.)  Eliminate the requirement that the initial Common Lisp system   have a package named "SYSTEM". Specify that implementations may  have several other packages available.  Clarify that the "USER" package may have additional symbols interned  within it and that it may :USE other implementation-specific packages.  Examples:  #1: The symbol HELP may not be on the LISP package because it is not      mentioned in CLtL.  #2: The symbol VARIABLE is specified to be on the LISP package (because      it is a valid second argument to the DOCUMENTATION function). Since      it is not defined as a variable, type, or function, however, it may      not be bound, defined as a type, or defined as a function, macro or      special form.Rationale:  If extra symbols are permitted in the LISP package, users may be surprised  by relationships between the LISP package and other packages which they  did not expect, or may be surprised by functionality that they did not  expect. The degenerate case is:   (DEFCONSTANT LISP:A 'YOU-LOSE)   (DEFCONSTANT LISP:B 'YOU-LOSE)   (DEFCONSTANT LISP:C 'YOU-LOSE)      ...   (DEFCONSTANT LISP:AA 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   ...etc.  Given such an implementation, even things like (LAMBDA (X) X) are not  valid because they attempt to bind "system constants". It is necessary  that the programmer be able to know for sure that an arbitrary name is  "free for use" and best way to conveniently assure this is to require  that the LISP package be unadulterated.  As for the additional definitions, there are situations where additional  definitions would cause a problem. For example, if a symbol on the Lisp  package were declared as a special variable even though that value was  not mentioned in the standard, that variable would behave incorrectly when  used as a lexical variable. Similarly, if a symbol in the lisp package  were defined as an implementation-dependent special form, problems might  result if a user redefined or even bound (as by FLET or MACROLET) that  name.  The LISP package is the foothold from which portable programs establish  their desired environment. Careful control is desirable to make sure  everyone is starting off on the right foot.Current Practice:  Some implementations have been known to add additional symbols (usually  functional and/or variable extensions) to the LISP package.  Several implementations have restricted the LISP package to only contain  those symbols in CLtL. (The exact set was difficult to extract because not all  LISP package symbols appeared in the index of CLtL.)  Even in those implementations that have only the prescribed symbols in CLtL,  there can be extra definitions for those symbols. For example, in  Symbolics Genera,  the symbols EVALHOOK, ROOM, and APPLYHOOK  are spuriously defined as special variables, and the symbol LAMBDA is defined  as a macro. Performance Impact:NoneCost to Implementors:  The actual cost of moving the symbols out of the LISP package in cases  where they are not already gone is quite small. However, if any  implementation really has to do this, it may have a number of suppositions  about what is in what package, and the changes could potentially be extensive.Cost to Users:  This change is upward compatible with any portable program, but users  of a particular implementation's extensions may be forced to find their  functions in a different package, so there may be a measurable practical  cost.  In many cases where an extension symbol FOO is simply expected to have  been directly available (due to :USE "LISP"), it will work to just just  do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is  declared.  In many cases where an extension symbol FOO is used by explicit package  prefix, such as LISP:FOO, it should be easy to search for `LISP:FOO' or  even `LISP:' to find the cases.Cost of Non-Adoption:  The potential for the LISP package to be adulterated and for supposedly  portable programs to have difficulty getting a foothold in some  implementations will be `noticeably non-zero'.Benefits:  Portability of some programs will be enhanced.Aesthetics:  This change probably supports the naive expectation of most programmers  writing portable code.Discussion:  This issue came up a while back on Common-Lisp list. The issue  of whether the   USER package may contain symbols other than those   specified in the standard was controversial.  The smart programmer  of portable code will never rely on the contents of the  USER package.    However, if someone wants a completely empty   package that uses only Lisp, it's easy and portable to create one.  While it would improve portability slightly to disallow additional internal  symbols in the LISP package (since it affects what DO-SYMBOLS will do)  explicitly prohibiting a common practice didn't seem like the best way  to discourage a possibly troublesome implementation technique.   Implementors should be especially careful about accidentally   exporting unwanted additional definitions for symbols,e.g., a variable   definition for EVALHOOK which might show through because of   an unintended name collision.  It is likely that the recently included portions of the standard (CLOS and  the signal mechanism) will reside in their own packages. These externally  defined packages should have the same constraints as outlined for  the LISP package here.  There has been a suggestion that vendor-specific extensions should  be placed in a package named like ACME-COMMON-LISP for the "Acme"  company.   A registry of packages (as well as features, modules and other global  names) would be useful, although probably not a part of the language  standard, per se.*start*09860 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 OCT 88 21:50:34 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Oct 88  21:50:05 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 07 OCT 88 18:54:38 PDTDate: 7 Oct 88 18:54 PDTFrom: masinter.paSubject: Issue: PACKAGE-CLUTTER (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881007-185438-1615@Xerox>As for removing SYSTEM; it is no worse than the other packages that mightbe in an implementation. Its not just package names, its also packagenicknames, right?I don't see any reason not to also allow USER to have symbols, if it can:USE other packages. For example, what if your system first reads an initfile and the init file is in-package "USER", then the first thing that the"real" user will see might have a few symbols from the init file actuallyinterned in "USER". As long as it doesn't have to be empty, there's noreason to make it only :USE other packages, is there?I've modified the proposal in response to Kent's other comments.!Issue:        PACKAGE-CLUTTERReferences:   LISP, USER, SYSTEM packages (p181)Related issues: LISP-SYMBOL-REDEFINITION, DEFPACKAGE, 		MAKE-PACKAGE-USE-DEFAULT, IN-PACKAGE-FUNCTIONALITY		 Category:     CHANGE/CLARIFICATIONEdit history: 07-Jul-88, Version 1 by Pitman		23-Sep-88, Version 2 by Masinter		 5-Oct-88, Version 3 by MasinterProblem Description:  CLtL specifies that   ``The package named LISP contains the primitives of     the Common Lisp system. Its external symbols include     all of the user-visible functions and global variables     that are present in the Common Lisp system, such as     CAR, CDR, *PACKAGE*, etc. Almost all other packages will     want to use LISP so that these symbosl will be accessible     without qualification.''  It specifies "all" but not "all and only".  Some implementations place their extensions in the Lisp package.  Nothing in CLtL explicitly prohibits this, but it leads to problems   in general.  For example:  - A user defining a function by a name not mentioned in CLtL may be    surprised to clobber a system function in some implementations  - In one particular implementation, the variable HELP was a system    constant, so that ((LAMBDA (HELP) ...HELP...) "Press ? for help.")    signalled a correctable error (asking what variable to bind    instead of HELP :-).Proposal (PACKAGE-CLUTTER:REDUCE):  Specify that, not only must the LISP package  contain at least all of the symbols listed in the standard, it will have no other external symbols.  (The LISP package may have additional internal symbols.) Symbols on the LISP package may have function or macro definitions, top level value or SPECIAL proclamations, or type definitions only if explicitly permitted in the specification. That is, a program is valid Common Lisp if it assumes that  this is true; for example, FBOUNDP will be false for all  external symbols of the LISP package except those documented  to be functions or macros; BOUNDP will be false for all  those except those documented to be variables,  and portable programs can use symbols in the LISP package  as local lexical variables with the presumption that the variables  are not proclaimed special, except for those variables specified  as constants or variables.  (The proposal LISP-SYMBOL-REDEFINITION addresses the  converse; that is, what user programs are allowed to do.)  Eliminate the requirement that the initial Common Lisp system   have a package named "SYSTEM". Specify that implementations may  have several other packages available, that these should be  documented. If it is appropriate, the standard might contain  as an example that implementations might have a package named  "SYSTEM".  Clarify that the "USER" package may have additional symbols interned  within it and that it may :USE other implementation-specific packages.  Examples:  #1: The symbol HELP may not be on the LISP package because it is not      mentioned in CLtL.  #2: The symbol VARIABLE is specified to be on the LISP package (because      it is a valid second argument to the DOCUMENTATION function). Since      it is not defined as a variable, type, or function, however, it will      not initially be bound, defined as a type, or defined as a function,      macro or special form.Rationale:  If extra symbols are permitted in the LISP package, users may besurprised  by relationships between the LISP package and other packages which they  did not expect, or may be surprised by functionality that they did not  expect. The degenerate case is:   (DEFCONSTANT LISP:A 'YOU-LOSE)   (DEFCONSTANT LISP:B 'YOU-LOSE)   (DEFCONSTANT LISP:C 'YOU-LOSE)      ...   (DEFCONSTANT LISP:AA 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   ...etc.  Given such an implementation, even things like (LAMBDA (X) X) are not  valid because they attempt to bind "system constants". It is necessary  that the programmer be able to know for sure that an arbitrary name is  "free for use" and best way to conveniently assure this is to require  that the LISP package be unadulterated.  As for the additional definitions, there are situations where additional  definitions would cause a problem. For example, if a symbol on the Lisp  package were declared as a special variable even though that value was  not mentioned in the standard, that variable would behave incorrectlywhen  used as a lexical variable. Similarly, if a symbol in the lisp package  were defined as an implementation-dependent special form, problems might  result if a user redefined or even bound (as by FLET or MACROLET) that  name.  The LISP package is the foothold from which portable programs establish  their desired environment. Careful control is desirable to make sure  everyone is starting off on the right foot.Current Practice:  Some implementations have been known to add additional symbols (usually  functional and/or variable extensions) to the LISP package.  Several implementations have restricted the LISP package to only contain  those symbols in CLtL. (The exact set was difficult to extract becausenot all  LISP package symbols appeared in the index of CLtL.)  Even in those implementations that have only the prescribed symbols inCLtL,  there can be extra definitions for those symbols. For example, inSymbolics Genera,  the symbols EVALHOOK, ROOM, and APPLYHOOK  are spuriously defined as special variables, and the symbol LAMBDA isdefined  as a macro. Performance Impact:NoneCost to Implementors:  The actual cost of moving the symbols out of the LISP package in cases  where they are not already gone is quite small. However, if any  implementation really has to do this, it may have a number ofsuppositions  about what is in what package, and the changes could potentially beextensive.Cost to Users:  This change is upward compatible with any portable program, but users  of a particular implementation's extensions may be forced to find their  functions in a different package, so there may be a measurable practical  cost.  In many cases where an extension symbol FOO is simply expected to have  been directly available (due to :USE "LISP"), it will work to just just  do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is  declared.  In many cases where an extension symbol FOO is used by explicit package  prefix, such as LISP:FOO, it should be easy to search for `LISP:FOO' or  even `LISP:' to find the cases.Cost of Non-Adoption:  The potential for the LISP package to be adulterated and for supposedly  portable programs to have difficulty getting a foothold in some  implementations will be `noticeably non-zero'.Benefits:  Portability of some programs will be enhanced.Aesthetics:  This change probably supports the naive expectation of most programmers  writing portable code.Discussion:  This proposal basically affects what implementors are allowed to do;  it says that portable programs can rely on a standard initial package  structure with the same symbols in it. A separate proposal,   LISP-SYMBOL-REDEFINITION, discusses the restrictions on portable  programs as far as redefining LISP symbols.  Whether the USER package may contain symbols other than those   specified in the standard was controversial.  The smart programmer  of portable code will never rely on the contents of the  USER package. However, if someone wants a completely empty   package that uses only Lisp, it's easy and portable to create one.    While it would improve portability slightly to disallow additionalinternal  symbols in the LISP package (since it affects what DO-SYMBOLS will do)  explicitly prohibiting a common practice didn't seem like the best way  to discourage a possibly troublesome implementation technique.   Implementors should be especially careful about accidentally   exporting unwanted additional definitions for symbols,e.g., a variable   definition for EVALHOOK which might show through because of   an unintended name collision.  It is likely that the recently included portions of the standard (CLOSand  the signal mechanism) will reside in their own packages. These externally  defined packages should have the same constraints as outlined for  the LISP package here.  There has been a suggestion that vendor-specific extensions should  be placed in a package named like ACME-COMMON-LISP for the "Acme"  company.   A registry of packages (as well as features, modules and other global  names) would be useful, although probably not a part of the language  standard, per se.*start*09379 00024 USfDate:  8 Oct 88 20:40 PDTSender: masinter.paSubject: Issue: PACKAGE-CLUTTER (Version 4)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:        PACKAGE-CLUTTERReferences:   LISP, USER, SYSTEM packages (p181)Related issues: LISP-SYMBOL-REDEFINITION, DEFPACKAGE, 		    MAKE-PACKAGE-USE-DEFAULT, IN-PACKAGE-FUNCTIONALITY		 Category:     CHANGE/CLARIFICATIONEdit history: 07-Jul-88, Version 1 by Pitman		  23-Sep-88, Version 2 by Masinter		  5-Oct-88, Version 3 by Masinter		  7-Oct-88, Version 4 by Masinter (response to KMP)Problem Description:  CLtL specifies that   ``The package named LISP contains the primitives of     the Common Lisp system. Its external symbols include     all of the user-visible functions and global variables     that are present in the Common Lisp system, such as     CAR, CDR, *PACKAGE*, etc. Almost all other packages will     want to use LISP so that these symbosl will be accessible     without qualification.''  It specifies "all" but not "all and only".  Some implementations place their extensions in the Lisp package.  Nothing in CLtL explicitly prohibits this, but it leads to problems   in general.  For example:  - A user defining a function by a name not mentioned in CLtL may be    surprised to clobber a system function in some implementations  - In one particular implementation, the variable HELP was a system    constant, so that ((LAMBDA (HELP) ...HELP...) "Press ? for help.")    signalled a correctable error (asking what variable to bind    instead of HELP :-).Proposal (PACKAGE-CLUTTER:REDUCE):  Specify that, not only must the LISP package  contain at least all of the symbols listed in the standard, it will have no other external symbols.  (The LISP package may have additional internal symbols.) Symbols on the LISP package may have function or macro definitions, top level value or SPECIAL proclamations, or type definitions only if explicitly permitted in the specification. That is, a program is valid Common Lisp if it assumes that  this is true; for example, FBOUNDP will be false for all  external symbols of the LISP package except those documented  to be functions or macros; BOUNDP will be false for all  those except those documented to be variables,  and portable programs can use symbols in the LISP package  as local lexical variables with the presumption that the variables  are not proclaimed special, except for those variables specified  as constants or variables.  (The proposal LISP-SYMBOL-REDEFINITION addresses the  converse; that is, what user programs are allowed to do.)  Eliminate the requirement that the initial Common Lisp system   have a package named "SYSTEM". Specify that implementations may  have several other packages available, that these should be  documented. If it is appropriate, the standard might contain  as an example that implementations might have a package named  "SYSTEM".  Clarify that the "USER" package may have additional symbols interned  within it and that it may :USE other implementation-specific packages.  Examples:  #1: The symbol HELP may not be on the LISP package because it is not      mentioned in CLtL.  #2: The symbol VARIABLE is specified to be on the LISP package (because      it is a valid second argument to the DOCUMENTATION function). Since      it is not defined as a variable, type, or function, however, it will      not initially be bound, defined as a type, or defined as a function,      macro or special form.Rationale:  If extra symbols are permitted in the LISP package, users may be surprised  by relationships between the LISP package and other packages which they  did not expect, or may be surprised by functionality that they did not  expect. The degenerate case is:   (DEFCONSTANT LISP:A 'YOU-LOSE)   (DEFCONSTANT LISP:B 'YOU-LOSE)   (DEFCONSTANT LISP:C 'YOU-LOSE)      ...   (DEFCONSTANT LISP:AA 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   ...etc.  Given such an implementation, even things like (LAMBDA (X) X) are not  valid because they attempt to bind "system constants". It is necessary  that the programmer be able to know for sure that an arbitrary name is  "free for use" and best way to conveniently assure this is to require  that the LISP package be unadulterated.  As for the additional definitions, there are situations where additional  definitions would cause a problem. For example, if a symbol on the Lisp  package were declared as a special variable even though that value was  not mentioned in the standard, that variable would behave incorrectly when  used as a lexical variable. Similarly, if a symbol in the lisp package  were defined as an implementation-dependent special form, problems might  result if a user redefined or even bound (as by FLET or MACROLET) that  name.  The LISP package is the foothold from which portable programs establish  their desired environment. Careful control is desirable to make sure  everyone is starting off on the right foot.Current Practice:  Some implementations have been known to add additional symbols (usually  functional and/or variable extensions) to the LISP package.  Several implementations have restricted the LISP package to only contain  those symbols in CLtL. (The exact set was difficult to extract because not all  LISP package symbols appeared in the index of CLtL.)  Even in those implementations that have only the prescribed symbols in CLtL,  there can be extra definitions for those symbols. For example, in Symbolics Genera,  the symbols EVALHOOK, ROOM, and APPLYHOOK  are spuriously defined as special variables, and the symbol LAMBDA is defined  as a macro. Performance Impact:  NoneCost to Implementors:  The actual cost of moving the symbols out of the LISP package in cases  where they are not already gone is quite small. However, if any  implementation really has to do this, it may have a number of suppositions  about what is in what package, and the changes could potentially be extensive.Cost to Users:  This change is upward compatible with any portable program, but users  of a particular implementation's extensions may be forced to find their  functions in a different package, so there may be a measurable practical  cost.  In many cases where an extension symbol FOO is simply expected to have  been directly available (due to :USE "LISP"), it will work to just just  do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is  declared.  In many cases where an extension symbol FOO is used by explicit package  prefix, such as LISP:FOO, it should be easy to search for `LISP:FOO' or  even `LISP:' to find the cases.Cost of Non-Adoption:  The potential for the LISP package to be adulterated and for supposedly  portable programs to have difficulty getting a foothold in some  implementations will be `noticeably non-zero'.Benefits:  Portability of some programs will be enhanced.Aesthetics:  This change probably supports the naive expectation of most programmers  writing portable code.Discussion:  This proposal basically affects what implementors are allowed to do;  it says that portable programs can rely on a standard initial package  structure with the same symbols in it. A separate proposal,   LISP-SYMBOL-REDEFINITION, discusses the restrictions on portable  programs as far as redefining LISP symbols.  Whether the USER package may contain symbols other than those   specified in the standard was controversial.  The smart programmer  of portable code will never rely on the contents of the  USER package. However, if someone wants a completely empty   package that uses only Lisp, it's easy and portable to create one.    While it would improve portability slightly to disallow additional internal  symbols in the LISP package (since it affects what DO-SYMBOLS will do)  explicitly prohibiting a common practice didn't seem like the best way  to discourage a possibly troublesome implementation technique.   Implementors should be especially careful about accidentally   exporting unwanted additional definitions for symbols,e.g., a variable   definition for EVALHOOK which might show through because of   an unintended name collision.  It is likely that the recently included portions of the standard (CLOS and  the signal mechanism) will reside in their own packages. These externally  defined packages should have the same constraints as outlined for  the LISP package here.  There has been a suggestion that vendor-specific extensions should  be placed in a package named like ACME-COMMON-LISP for the "Acme"  company.   A registry of packages (as well as features, modules and other global  names) would be useful, although probably not a part of the language  standard, per se.        TITAN 
         TITAN 
                                       $              d                                                #                                                           	             +                                  
       3              e                   # #z*start*01469 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:07:46 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:50:33 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476075; Thu 13-Oct-88 18:49:02 EDTDate: Thu, 13 Oct 88 18:48 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013184853.6.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...X3J13 meeting: Haflich had a comment about IMPORT that I didn't understand. Sandra: Good but doesn't go far enough. It should also say that	 LISPxLISP properties were not ok -- ie, that you could 	 have implementations with initial properties on LISP	 symbols only if indicators were non-LISP symbols, and	 symbols with LISP indicators if those symbols were	 not on LISP. JonL: Clarify relation to LISP-SYMBOL-REDEFINITION. In particular,       users -should- be permitted to put LISP-package properties       on other LISP symbols, mostly for interactive convenience.       The practice might be discouraged in production-quality       systems for reasons of modularity hygiene but LISP shouldn't       complain if it occurs.*start*01261 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:39:51 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:38:33 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA21463; Thu, 13 Oct 88 15:36:52 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19912; Thu, 13 Oct 88 15:36:50 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132136.AA19912@defun.utah.edu>Date: Thu, 13 Oct 88 15:36:49 MDTSubject: issue PACKAGE-CLUTTERTo: cl-cleanup@sail.stanford.eduI generally like this proposal.  At the meeting I mentioned that Ithought the property lists were also a problem and Larry mentionedthat some extremely complicated-sounding wording to deal with theproblem could be added to the proposal.  Actually, I would be happywith a simple statement that the implementation must not use anykeywords or external symbols in the Lisp package as indicators on theproperty list of any symbol.  I don't care if the system puts thingson property lists behind my back, as long as it doesn't use indicatorsthat I might accidentally want to use myself.-Sandra-------*start*01571 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 13:41:01 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 18 Oct 88  13:39:54 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA06196g; Tue, 18 Oct 88 13:39:47 PDTReceived: by bhopal id AA01190g; Tue, 18 Oct 88 12:31:06 PDTDate: Tue, 18 Oct 88 12:31:06 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810181931.AA01190@bhopal>To: sandra%defun@cs.utah.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Thu, 13 Oct 88 15:36:49 MDT <8810132136.AA19912@defun.utah.edu>Subject: issue PACKAGE-CLUTTERre: . . . Actually, I would be happy    with a simple statement that the implementation must not use any    keywords or external symbols in the Lisp package as indicators on the    property list of any symbol.  I don't care if the system puts things ...I like to plead again to please separate the PACKAGE-CLUTTER issue fromthe LISP-SYMBOL-REDEFINITION issue.  Walter had a good idea some timeago to rename PACKAGE-CLUTTER as LISP-PACKAGE-CONTENTS.  Larry has said that he would "group together" related issues like this; but I think the issue of LISP-PACKAGE-CONTENTS is _critical_ to a portable language, whereas the issue of LISP-SYMBOL-REDEFINITION simply helps smooth over some minor irritants.  More to the point, the former is at last non-controversial, while the latter still boils and stews.-- JonL --*start*01430 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 NOV 88 15:42:33 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Nov 88  15:39:01 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 23 NOV 88 14:20:34 PSTDate: 23 Nov 88 14:20 PSTFrom: masinter.paSubject: Re: Issue: PACKAGE-CLUTTER (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUcc: boyer@cli.comMessage-ID: <881123-142034-13274@Xerox>Are system-internal (non-LISP package) properties "visible"? I.e., if we are going to allow the system to put its ownsystem-dependent properties on any symbol (USER,LISP or wherever), can those properties be added atany time?The following example was sent to me by Bob Boyer:Date: Wed, 23 Nov 88 15:50:16 CSTFrom: Robert S. Boyer <boyer@CLI.COM>...Here's a little point.  When one executes "symbol-name" in KCL, a sideeffect to the property list of the symbol takes place.  This sort ofclobbering of the property lists has been around since the earliestdays of Lisp.  Interlisp and Symbolics have done this sort of thingwilly-nilly.  But is it legal for a supposedly side-effect free CommonLisp function to touch property lists?Example:KCl (Kyoto Common Lisp)  June 3, 1987>(symbol-plist 'foo)NIL>(symbol-name 'foo)"FOO">(symbol-plist 'foo)(SYSTEM:PNAME "FOO")>*start*12295 00024 US Date: 23 Nov 88 14:17 PSTFrom: masinter.paSubject: Issue: PACKAGE-CLUTTER (Version 4)To: boyer@cli.comcc: Masinterreply-to: cl-cleanup@Sail.stanford.eduWell, this issue really talks about what things the system can do "behind your back". Certainly "side effect free" functions like SYMBOL-NAME can do things like invoke a GC. Can it do something the user can see? We have to decide if system-dependent properties on user symbols are visible.     ----- Begin Forwarded Messages -----Date:  8 Oct 88 20:40 PDTSender: masinter.paSubject: Issue: PACKAGE-CLUTTER (Version 4)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:        PACKAGE-CLUTTERReferences:   LISP, USER, SYSTEM packages (p181)Related issues: LISP-SYMBOL-REDEFINITION, DEFPACKAGE, 		    MAKE-PACKAGE-USE-DEFAULT, IN-PACKAGE-FUNCTIONALITY		 Category:     CHANGE/CLARIFICATIONEdit history: 07-Jul-88, Version 1 by Pitman		  23-Sep-88, Version 2 by Masinter		  5-Oct-88, Version 3 by Masinter		  7-Oct-88, Version 4 by Masinter (response to KMP)Problem Description:  CLtL specifies that   ``The package named LISP contains the primitives of     the Common Lisp system. Its external symbols include     all of the user-visible functions and global variables     that are present in the Common Lisp system, such as     CAR, CDR, *PACKAGE*, etc. Almost all other packages will     want to use LISP so that these symbosl will be accessible     without qualification.''  It specifies "all" but not "all and only".  Some implementations place their extensions in the Lisp package.  Nothing in CLtL explicitly prohibits this, but it leads to problems   in general.  For example:  - A user defining a function by a name not mentioned in CLtL may be    surprised to clobber a system function in some implementations  - In one particular implementation, the variable HELP was a system    constant, so that ((LAMBDA (HELP) ...HELP...) "Press ? for help.")    signalled a correctable error (asking what variable to bind    instead of HELP :-).Proposal (PACKAGE-CLUTTER:REDUCE):  Specify that, not only must the LISP package  contain at least all of the symbols listed in the standard, it will have no other external symbols.  (The LISP package may have additional internal symbols.) Symbols on the LISP package may have function or macro definitions, top level value or SPECIAL proclamations, or type definitions only if explicitly permitted in the specification. That is, a program is valid Common Lisp if it assumes that  this is true; for example, FBOUNDP will be false for all  external symbols of the LISP package except those documented  to be functions or macros; BOUNDP will be false for all  those except those documented to be variables,  and portable programs can use symbols in the LISP package  as local lexical variables with the presumption that the variables  are not proclaimed special, except for those variables specified  as constants or variables.  (The proposal LISP-SYMBOL-REDEFINITION addresses the  converse; that is, what user programs are allowed to do.)  Eliminate the requirement that the initial Common Lisp system   have a package named "SYSTEM". Specify that implementations may  have several other packages available, that these should be  documented. If it is appropriate, the standard might contain  as an example that implementations might have a package named  "SYSTEM".  Clarify that the "USER" package may have additional symbols interned  within it and that it may :USE other implementation-specific packages.  Examples:  #1: The symbol HELP may not be on the LISP package because it is not      mentioned in CLtL.  #2: The symbol VARIABLE is specified to be on the LISP package (because      it is a valid second argument to the DOCUMENTATION function). Since      it is not defined as a variable, type, or function, however, it will      not initially be bound, defined as a type, or defined as a function,      macro or special form.Rationale:  If extra symbols are permitted in the LISP package, users may be surprised  by relationships between the LISP package and other packages which they  did not expect, or may be surprised by functionality that they did not  expect. The degenerate case is:   (DEFCONSTANT LISP:A 'YOU-LOSE)   (DEFCONSTANT LISP:B 'YOU-LOSE)   (DEFCONSTANT LISP:C 'YOU-LOSE)      ...   (DEFCONSTANT LISP:AA 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   ...etc.  Given such an implementation, even things like (LAMBDA (X) X) are not  valid because they attempt to bind "system constants". It is necessary  that the programmer be able to know for sure that an arbitrary name is  "free for use" and best way to conveniently assure this is to require  that the LISP package be unadulterated.  As for the additional definitions, there are situations where additional  definitions would cause a problem. For example, if a symbol on the Lisp  package were declared as a special variable even though that value was  not mentioned in the standard, that variable would behave incorrectly when  used as a lexical variable. Similarly, if a symbol in the lisp package  were defined as an implementation-dependent special form, problems might  result if a user redefined or even bound (as by FLET or MACROLET) that  name.  The LISP package is the foothold from which portable programs establish  their desired environment. Careful control is desirable to make sure  everyone is starting off on the right foot.Current Practice:  Some implementations have been known to add additional symbols (usually  functional and/or variable extensions) to the LISP package.  Several implementations have restricted the LISP package to only contain  those symbols in CLtL. (The exact set was difficult to extract because not all  LISP package symbols appeared in the index of CLtL.)  Even in those implementations that have only the prescribed symbols in CLtL,  there can be extra definitions for those symbols. For example, in Symbolics Genera,  the symbols EVALHOOK, ROOM, and APPLYHOOK  are spuriously defined as special variables, and the symbol LAMBDA is defined  as a macro. Performance Impact:  NoneCost to Implementors:  The actual cost of moving the symbols out of the LISP package in cases  where they are not already gone is quite small. However, if any  implementation really has to do this, it may have a number of suppositions  about what is in what package, and the changes could potentially be extensive.Cost to Users:  This change is upward compatible with any portable program, but users  of a particular implementation's extensions may be forced to find their  functions in a different package, so there may be a measurable practical  cost.  In many cases where an extension symbol FOO is simply expected to have  been directly available (due to :USE "LISP"), it will work to just just  do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is  declared.  In many cases where an extension symbol FOO is used by explicit package  prefix, such as LISP:FOO, it should be easy to search for `LISP:FOO' or  even `LISP:' to find the cases.Cost of Non-Adoption:  The potential for the LISP package to be adulterated and for supposedly  portable programs to have difficulty getting a foothold in some  implementations will be `noticeably non-zero'.Benefits:  Portability of some programs will be enhanced.Aesthetics:  This change probably supports the naive expectation of most programmers  writing portable code.Discussion:  This proposal basically affects what implementors are allowed to do;  it says that portable programs can rely on a standard initial package  structure with the same symbols in it. A separate proposal,   LISP-SYMBOL-REDEFINITION, discusses the restrictions on portable  programs as far as redefining LISP symbols.  Whether the USER package may contain symbols other than those   specified in the standard was controversial.  The smart programmer  of portable code will never rely on the contents of the  USER package. However, if someone wants a completely empty   package that uses only Lisp, it's easy and portable to create one.    While it would improve portability slightly to disallow additional internal  symbols in the LISP package (since it affects what DO-SYMBOLS will do)  explicitly prohibiting a common practice didn't seem like the best way  to discourage a possibly troublesome implementation technique.   Implementors should be especially careful about accidentally   exporting unwanted additional definitions for symbols,e.g., a variable   definition for EVALHOOK which might show through because of   an unintended name collision.  It is likely that the recently included portions of the standard (CLOS and  the signal mechanism) will reside in their own packages. These externally  defined packages should have the same constraints as outlined for  the LISP package here.  There has been a suggestion that vendor-specific extensions should  be placed in a package named like ACME-COMMON-LISP for the "Acme"  company.   A registry of packages (as well as features, modules and other global  names) would be useful, although probably not a part of the language  standard, per se.     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:07:46 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:50:33 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476075; Thu 13-Oct-88 18:49:02 EDTDate: Thu, 13 Oct 88 18:48 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013184853.6.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...X3J13 meeting: Haflich had a comment about IMPORT that I didn't understand. Sandra: Good but doesn't go far enough. It should also say that	 LISPxLISP properties were not ok -- ie, that you could 	 have implementations with initial properties on LISP	 symbols only if indicators were non-LISP symbols, and	 symbols with LISP indicators if those symbols were	 not on LISP. JonL: Clarify relation to LISP-SYMBOL-REDEFINITION. In particular,       users -should- be permitted to put LISP-package properties       on other LISP symbols, mostly for interactive convenience.       The practice might be discouraged in production-quality       systems for reasons of modularity hygiene but LISP shouldn't       complain if it occurs.     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:39:51 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:38:33 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA21463; Thu, 13 Oct 88 15:36:52 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19912; Thu, 13 Oct 88 15:36:50 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132136.AA19912@defun.utah.edu>Date: Thu, 13 Oct 88 15:36:49 MDTSubject: issue PACKAGE-CLUTTERTo: cl-cleanup@sail.stanford.eduI generally like this proposal.  At the meeting I mentioned that Ithought the property lists were also a problem and Larry mentionedthat some extremely complicated-sounding wording to deal with theproblem could be added to the proposal.  Actually, I would be happywith a simple statement that the implementation must not use anykeywords or external symbols in the Lisp package as indicators on theproperty list of any symbol.  I don't care if the system puts thingson property lists behind my back, as long as it doesn't use indicatorsthat I might accidentally want to use myself.-Sandra-------     ----- End Forwarded Messages -----*start*09927 00024 USfDate:  8 Dec 88 18:10 PSTFrom: masinter.paTo: cl-cleanup@sail.stanford.eduSubject: Issue: PACKAGE-CLUTTER (Version 5)cc: masinterline-fold: noThis version has wording to outlaw property lists.I tried to "clarify the relationship to LISP-SYMBOL-REDEFINITION",too.Issue:        PACKAGE-CLUTTERReferences:   LISP, USER, SYSTEM packages (p181)Related issues: LISP-SYMBOL-REDEFINITION, DEFPACKAGE, 		    MAKE-PACKAGE-USE-DEFAULT, IN-PACKAGE-FUNCTIONALITY		 Category:     CHANGE/CLARIFICATIONEdit history: 07-Jul-88, Version 1 by Pitman		  23-Sep-88, Version 2 by Masinter		  5-Oct-88, Version 3 by Masinter		  7-Oct-88, Version 4 by Masinter (response to KMP)		   8-Dec-88, Version 5 by Masinter			(add property lists)Problem Description:  CLtL specifies that   ``The package named LISP contains the primitives of     the Common Lisp system. Its external symbols include     all of the user-visible functions and global variables     that are present in the Common Lisp system, such as     CAR, CDR, *PACKAGE*, etc. Almost all other packages will     want to use LISP so that these symbosl will be accessible     without qualification.''  It specifies "all" but not "all and only".  Some implementations place their extensions in the Lisp package.  Nothing in CLtL explicitly prohibits this, but it leads to problems   in general.  For example:  - A user defining a function by a name not mentioned in CLtL may be    surprised to clobber a system function in some implementations  - In one particular implementation, the variable HELP was a system    constant, so that ((LAMBDA (HELP) ...HELP...) "Press ? for help.")    signalled a correctable error (asking what variable to bind    instead of HELP :-).Proposal (PACKAGE-CLUTTER:REDUCE):  Specify that, not only must the LISP package  contain at least all of the  symbols listed in the standard, it will have no other external symbols.  (The LISP package may have additional internal symbols.)  Symbols on the LISP package may have function or macro  definitions, top level value or SPECIAL proclamations, or  type definitions only if explicitly permitted in the specification.  That is, a program is valid Common Lisp if it assumes that  this is true; for example, FBOUNDP will be false for all  external symbols of the LISP package except those documented  to be functions or macros; BOUNDP will be false for all  those except those documented to be variables,  and portable programs can use symbols in the LISP package  as local lexical variables with the presumption that the variables  are not proclaimed special, except for those variables specified  as constants or variables.  A valid implimentation may have or put additional properties  on symbols (even user created symbols) as long as the  property indicators are not in the LISP, KEYWORD or USER  package.  This proposal constrains implementations as to what their  initial package configuration must be. That is, valid programs  can assume that the conformal Lisp implementation will not  have prohibited properties.  The proposal LISP-SYMBOL-REDEFINITION  addresses the converse; that is, what user programs are allowed  to do.  Eliminate the requirement that the initial Common Lisp system   have a package named "SYSTEM". Specify that implementations may  have several other packages available, that these should be  documented. If it is appropriate, the standard might contain  as an example that implementations might have a package named  "SYSTEM".  Clarify that the "USER" package may have additional symbols interned  within it and that it may :USE other implementation-specific packages.  Examples:  #1: The symbol HELP may not be on the LISP package because it is not      mentioned in CLtL.  #2: The symbol VARIABLE is specified to be on the LISP package (because      it is a valid second argument to the DOCUMENTATION function). Since      it is not defined as a variable, type, or function, however, it will      not initially be bound, defined as a type, or defined as a function,      macro or special form.Rationale:  If extra symbols are permitted in the LISP package, users may be surprised  by relationships between the LISP package and other packages which they  did not expect, or may be surprised by functionality that they did not  expect. The degenerate case is:   (DEFCONSTANT LISP:A 'YOU-LOSE)   (DEFCONSTANT LISP:B 'YOU-LOSE)   (DEFCONSTANT LISP:C 'YOU-LOSE)      ...   (DEFCONSTANT LISP:AA 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   ...etc.  Given such an implementation, even things like (LAMBDA (X) X) are not  valid because they attempt to bind "system constants". It is necessary  that the programmer be able to know for sure that an arbitrary name is  "free for use" and best way to conveniently assure this is to require  that the LISP package be unadulterated.  As for the additional definitions, there are situations where additional  definitions would cause a problem. For example, if a symbol on the Lisp  package were declared as a special variable even though that value was  not mentioned in the standard, that variable would behave incorrectly when  used as a lexical variable. Similarly, if a symbol in the lisp package  were defined as an implementation-dependent special form, problems might  result if a user redefined or even bound (as by FLET or MACROLET) that  name.  The LISP package is the foothold from which portable programs establish  their desired environment. Careful control is desirable to make sure  everyone is starting off on the right foot.Current Practice:  Some implementations have been known to add additional symbols (usually  functional and/or variable extensions) to the LISP package.  Several implementations have restricted the LISP package to only contain  those symbols in CLtL. (The exact set was difficult to extract because not all  LISP package symbols appeared in the index of CLtL.)  Even in those implementations that have only the prescribed symbols in CLtL,  there can be extra definitions for those symbols. For example, in Symbolics Genera,  the symbols EVALHOOK, ROOM, and APPLYHOOK  are spuriously defined as special variables, and the symbol LAMBDA is defined  as a macro. Performance Impact:  NoneCost to Implementors:  The actual cost of moving the symbols out of the LISP package in cases  where they are not already gone is quite small. However, if any  implementation really has to do this, it may have a number of suppositions  about what is in what package, and the changes could potentially be extensive.Cost to Users:  This change is upward compatible with any portable program, but users  of a particular implementation's extensions may be forced to find their  functions in a different package, so there may be a measurable practical  cost.  In many cases where an extension symbol FOO is simply expected to have  been directly available (due to :USE "LISP"), it will work to just just  do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is  declared.  In many cases where an extension symbol FOO is used by explicit package  prefix, such as LISP:FOO, it should be easy to search for `LISP:FOO' or  even `LISP:' to find the cases.Cost of Non-Adoption:  The potential for the LISP package to be adulterated and for supposedly  portable programs to have difficulty getting a foothold in some  implementations will be `noticeably non-zero'.Benefits:  Portability of some programs will be enhanced.Aesthetics:  This change probably supports the naive expectation of most programmers  writing portable code.Discussion:  This proposal basically affects what implementors are allowed to do;  it says that portable programs can rely on a standard initial package  structure with the same symbols in it. A separate proposal,   LISP-SYMBOL-REDEFINITION, discusses the restrictions on portable  programs as far as redefining LISP symbols.  Whether the USER package may contain symbols other than those   specified in the standard was controversial.  The smart programmer  of portable code will never rely on the contents of the  USER package. However, if someone wants a completely empty   package that uses only Lisp, it's easy and portable to create one.  While it would improve portability slightly to disallow additional internal  symbols in the LISP package (since it affects what DO-SYMBOLS will do)  explicitly prohibiting a common practice didn't seem like the best way  to discourage a possibly troublesome implementation technique.   Implementors should be especially careful about accidentally   exporting unwanted additional definitions for symbols,e.g., a variable   definition for EVALHOOK which might show through because of   an unintended name collision.  It is likely that the recently included portions of the standard (CLOS and  the signal mechanism) will reside in their own packages. These externally  defined packages should have the same constraints as outlined for  the LISP package here.  There has been a suggestion that vendor-specific extensions should  be placed in a package named like ACME-COMMON-LISP for the "Acme"  company.   A registry of packages (as well as features, modules and other global  names) would be useful, although probably not a part of the language  standard, per se.        TITAN 
         TITAN 
           ]              
                                   $              d                                                #      {                                                     	             +                                  
       3              e                   %# &z*start*09896 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 18:45:42 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  18:44:33 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 08 DEC 88 18:25:29 PSTDate: 8 Dec 88 18:10 PSTFrom: masinter.paTo: cl-cleanup@sail.stanford.eduSubject: Issue: PACKAGE-CLUTTER (Version 5)cc: masinter.paline-fold: noMessage-ID: <881208-182529-5127@Xerox>This version has wording to outlaw property lists.I tried to "clarify the relationship to LISP-SYMBOL-REDEFINITION",too.!Issue:        PACKAGE-CLUTTERReferences:   LISP, USER, SYSTEM packages (p181)Related issues: LISP-SYMBOL-REDEFINITION, DEFPACKAGE, 		    MAKE-PACKAGE-USE-DEFAULT, IN-PACKAGE-FUNCTIONALITY		 Category:     CHANGE/CLARIFICATIONEdit history: 07-Jul-88, Version 1 by Pitman		  23-Sep-88, Version 2 by Masinter		  5-Oct-88, Version 3 by Masinter		  7-Oct-88, Version 4 by Masinter (response to KMP)		   8-Dec-88, Version 5 by Masinter			(add property lists)Problem Description:  CLtL specifies that   ``The package named LISP contains the primitives of     the Common Lisp system. Its external symbols include     all of the user-visible functions and global variables     that are present in the Common Lisp system, such as     CAR, CDR, *PACKAGE*, etc. Almost all other packages will     want to use LISP so that these symbosl will be accessible     without qualification.''  It specifies "all" but not "all and only".  Some implementations place their extensions in the Lisp package.  Nothing in CLtL explicitly prohibits this, but it leads to problems   in general.  For example:  - A user defining a function by a name not mentioned in CLtL may be    surprised to clobber a system function in some implementations  - In one particular implementation, the variable HELP was a system    constant, so that ((LAMBDA (HELP) ...HELP...) "Press ? for help.")    signalled a correctable error (asking what variable to bind    instead of HELP :-).Proposal (PACKAGE-CLUTTER:REDUCE):  Specify that, not only must the LISP package  contain at least all of the  symbols listed in the standard, it will have no other external symbols.  (The LISP package may have additional internal symbols.)  Symbols on the LISP package may have function or macro  definitions, top level value or SPECIAL proclamations, or  type definitions only if explicitly permitted in the specification.  That is, a program is valid Common Lisp if it assumes that  this is true; for example, FBOUNDP will be false for all  external symbols of the LISP package except those documented  to be functions or macros; BOUNDP will be false for all  those except those documented to be variables,  and portable programs can use symbols in the LISP package  as local lexical variables with the presumption that the variables  are not proclaimed special, except for those variables specified  as constants or variables.  A valid implimentation may have or put additional properties  on symbols (even user created symbols) as long as the  property indicators are not in the LISP, KEYWORD or USER  package.  This proposal constrains implementations as to what their  initial package configuration must be. That is, valid programs  can assume that the conformal Lisp implementation will not  have prohibited properties.  The proposal LISP-SYMBOL-REDEFINITION  addresses the converse; that is, what user programs are allowed  to do.  Eliminate the requirement that the initial Common Lisp system   have a package named "SYSTEM". Specify that implementations may  have several other packages available, that these should be  documented. If it is appropriate, the standard might contain  as an example that implementations might have a package named  "SYSTEM".  Clarify that the "USER" package may have additional symbols interned  within it and that it may :USE other implementation-specific packages.  Examples:  #1: The symbol HELP may not be on the LISP package because it is not      mentioned in CLtL.  #2: The symbol VARIABLE is specified to be on the LISP package (because      it is a valid second argument to the DOCUMENTATION function). Since      it is not defined as a variable, type, or function, however, it will      not initially be bound, defined as a type, or defined as a function,      macro or special form.Rationale:  If extra symbols are permitted in the LISP package, users may be surprised  by relationships between the LISP package and other packages which they  did not expect, or may be surprised by functionality that they did not  expect. The degenerate case is:   (DEFCONSTANT LISP:A 'YOU-LOSE)   (DEFCONSTANT LISP:B 'YOU-LOSE)   (DEFCONSTANT LISP:C 'YOU-LOSE)      ...   (DEFCONSTANT LISP:AA 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   ...etc.  Given such an implementation, even things like (LAMBDA (X) X) are not  valid because they attempt to bind "system constants". It is necessary  that the programmer be able to know for sure that an arbitrary name is  "free for use" and best way to conveniently assure this is to require  that the LISP package be unadulterated.  As for the additional definitions, there are situations where additional  definitions would cause a problem. For example, if a symbol on the Lisp  package were declared as a special variable even though that value was  not mentioned in the standard, that variable would behave incorrectly when  used as a lexical variable. Similarly, if a symbol in the lisp package  were defined as an implementation-dependent special form, problems might  result if a user redefined or even bound (as by FLET or MACROLET) that  name.  The LISP package is the foothold from which portable programs establish  their desired environment. Careful control is desirable to make sure  everyone is starting off on the right foot.Current Practice:  Some implementations have been known to add additional symbols (usually  functional and/or variable extensions) to the LISP package.  Several implementations have restricted the LISP package to only contain  those symbols in CLtL. (The exact set was difficult to extract because not all  LISP package symbols appeared in the index of CLtL.)  Even in those implementations that have only the prescribed symbols in CLtL,  there can be extra definitions for those symbols. For example, in Symbolics Genera,  the symbols EVALHOOK, ROOM, and APPLYHOOK  are spuriously defined as special variables, and the symbol LAMBDA is defined  as a macro. Performance Impact:  NoneCost to Implementors:  The actual cost of moving the symbols out of the LISP package in cases  where they are not already gone is quite small. However, if any  implementation really has to do this, it may have a number of suppositions  about what is in what package, and the changes could potentially be extensive.Cost to Users:  This change is upward compatible with any portable program, but users  of a particular implementation's extensions may be forced to find their  functions in a different package, so there may be a measurable practical  cost.  In many cases where an extension symbol FOO is simply expected to have  been directly available (due to :USE "LISP"), it will work to just just  do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is  declared.  In many cases where an extension symbol FOO is used by explicit package  prefix, such as LISP:FOO, it should be easy to search for `LISP:FOO' or  even `LISP:' to find the cases.Cost of Non-Adoption:  The potential for the LISP package to be adulterated and for supposedly  portable programs to have difficulty getting a foothold in some  implementations will be `noticeably non-zero'.Benefits:  Portability of some programs will be enhanced.Aesthetics:  This change probably supports the naive expectation of most programmers  writing portable code.Discussion:  This proposal basically affects what implementors are allowed to do;  it says that portable programs can rely on a standard initial package  structure with the same symbols in it. A separate proposal,   LISP-SYMBOL-REDEFINITION, discusses the restrictions on portable  programs as far as redefining LISP symbols.  Whether the USER package may contain symbols other than those   specified in the standard was controversial.  The smart programmer  of portable code will never rely on the contents of the  USER package. However, if someone wants a completely empty   package that uses only Lisp, it's easy and portable to create one.  While it would improve portability slightly to disallow additional internal  symbols in the LISP package (since it affects what DO-SYMBOLS will do)  explicitly prohibiting a common practice didn't seem like the best way  to discourage a possibly troublesome implementation technique.   Implementors should be especially careful about accidentally   exporting unwanted additional definitions for symbols,e.g., a variable   definition for EVALHOOK which might show through because of   an unintended name collision.  It is likely that the recently included portions of the standard (CLOS and  the signal mechanism) will reside in their own packages. These externally  defined packages should have the same constraints as outlined for  the LISP package here.  There has been a suggestion that vendor-specific extensions should  be placed in a package named like ACME-COMMON-LISP for the "Acme"  company.   A registry of packages (as well as features, modules and other global  names) would be useful, although probably not a part of the language  standard, per se.*start*02000 00024 US Return-Path: <gsb@ALDERAAN.SCRC.Symbolics.COM>Received: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by Xerox.COM ; 09 DEC 88 17:18:57 PSTReceived: from GANG-GANG.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 250404; Fri 9-Dec-88 20:19:09 ESTDate: Fri, 9 Dec 88 20:19 ESTFrom: Glenn S. Burke <gsb@ALDERAAN.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 5)To: masinter.paIn-Reply-To: <881208-182529-5127@Xerox>Message-ID: <19881210011901.8.GSB@GANG-GANG.SCRC.Symbolics.COM>    Date: 8 Dec 88 18:10 PST    From: masinter.pa@Xerox.COM    . . .    Issue:        PACKAGE-CLUTTER    . . .    Proposal (PACKAGE-CLUTTER:REDUCE):      Specify that, not only must the LISP package  contain at least all of the      symbols listed in the standard, it will have no other external symbols.      (The LISP package may have additional internal symbols.)      Symbols on the LISP package may have function or macro      definitions, top level value or SPECIAL proclamations, or      . . .I would say "External symbols in the LISP package..." to not lead thereader astray in the topic sentence.      . . .    Cost to Users:      This change is upward compatible with any portable program, but users      of a particular implementation's extensions may be forced to find their      functions in a different package, so there may be a measurable practical      cost.      In many cases where an extension symbol FOO is simply expected to have      been directly available (due to :USE "LISP"), it will work to just just      do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is      declared.More likely the extension symbols would be moved to one or moreextensions packages, e.g. ACME-COMMON-LISP, so user packages in whichthe extensions were desired could simply :USE the extensions package(s).This method of removing offending symbols from LISP could also be gentlysuggested.*start*00858 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 DEC 88 15:50:07 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 11 Dec 88  15:49:17 PSTDate: Sun, 11 Dec 88 14:56:27 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue PACKAGE-CLUTTER (Version 5)To: cl-cleanup@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUMessage-ID: <12453663438.21.IIM@ECLA.USC.EDU>Paragraph 2 of the Proposal section says:    " ... FBOUNDP will be false for all external symbols of the LISP package    except those documented to be functions or macros; ... "What about special-forms?  From CLtL, page 90-91, the definition of FBOUNDPsays:     "Note that FBOUNDP is true when the symbol names a special form or macro."kab-------*start*10275 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 14:24:27 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  14:00:29 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 12 DEC 88 13:45:36 PSTDate: 12 Dec 88 13:44 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: PACKAGE-CLUTTER (Version 6)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-134536-5049@Xerox>!Issue:        PACKAGE-CLUTTERReferences:   LISP, USER, SYSTEM packages (p181)Related issues: LISP-SYMBOL-REDEFINITION, DEFPACKAGE, 		    MAKE-PACKAGE-USE-DEFAULT, IN-PACKAGE-FUNCTIONALITY		 Category:     CHANGE/CLARIFICATIONEdit history: 07-Jul-88, Version 1 by Pitman		  23-Sep-88, Version 2 by Masinter		  5-Oct-88, Version 3 by Masinter		  7-Oct-88, Version 4 by Masinter (response to KMP)		   8-Dec-88, Version 5 by Masinter			(add property lists)		  12-Dec-88, Version 6 by Masinter (respond to comments)Problem Description:  CLtL specifies that   ``The package named LISP contains the primitives of     the Common Lisp system. Its external symbols include     all of the user-visible functions and global variables     that are present in the Common Lisp system, such as     CAR, CDR, *PACKAGE*, etc. Almost all other packages will     want to use LISP so that these symbosl will be accessible     without qualification.''  It specifies "all" but not "all and only".  Some implementations place their extensions in the Lisp package.  Nothing in CLtL explicitly prohibits this, but it leads to problems   in general.  For example:  - A user defining a function by a name not mentioned in CLtL may be    surprised to clobber a system function in some implementations  - In one particular implementation, the variable HELP was a system    constant, so that ((LAMBDA (HELP) ...HELP...) "Press ? for help.")    signalled a correctable error (asking what variable to bind    instead of HELP :-).Proposal (PACKAGE-CLUTTER:REDUCE):  Specify that, not only must the LISP package  contain at least all of the  symbols listed in the standard, it will have no other external symbols.  (The LISP package may have additional internal symbols.)  External symbols of the LISP package may have function, macro, or  special form definitions, top level value or SPECIAL proclamations,  or type definitions only if explicitly permitted in the specification.  That is, a program is valid Common Lisp if it assumes that  this is true; for example, FBOUNDP will be false for all  external symbols of the LISP package except those documented  to be functions, macros or special forms; BOUNDP will be false  for all those except those documented to be variables,  and portable programs can use symbols in the LISP package  as local lexical variables with the presumption that the variables  are not proclaimed special, except for those variables specified  as constants or variables.  A valid implimentation may have or put additional properties  on symbols (even user created symbols) as long as the  property indicators are not in the LISP, KEYWORD or USER  package.  This proposal constrains implementations as to what their  initial package configuration must be. That is, valid programs  can assume that the conformal Lisp implementation will not  have prohibited properties.  The proposal LISP-SYMBOL-REDEFINITION  addresses the converse; that is, what user programs are allowed  to do.  Eliminate the requirement that the initial Common Lisp system   have a package named "SYSTEM". Specify that implementations may  have several other packages available, that these should be  documented. If it is appropriate, the standard might contain  as an example that implementations might have a package named  "SYSTEM".  Clarify that the "USER" package may have additional symbols interned  within it and that it may :USE other implementation-specific packages.  Examples:  #1: The symbol HELP may not be on the LISP package because it is not      mentioned in CLtL.  #2: The symbol VARIABLE is specified to be on the LISP package (because      it is a valid second argument to the DOCUMENTATION function). Since      it is not defined as a variable, type, or function, however, it will      not initially be bound, defined as a type, or defined as a function,      macro or special form.Rationale:  If extra symbols are permitted in the LISP package, users may be surprised  by relationships between the LISP package and other packages which they  did not expect, or may be surprised by functionality that they did not  expect. The degenerate case is:   (DEFCONSTANT LISP:A 'YOU-LOSE)   (DEFCONSTANT LISP:B 'YOU-LOSE)   (DEFCONSTANT LISP:C 'YOU-LOSE)      ...   (DEFCONSTANT LISP:AA 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   (DEFCONSTANT LISP:AB 'YOU-LOSE)   ...etc.  Given such an implementation, even things like (LAMBDA (X) X) are not  valid because they attempt to bind "system constants". It is necessary  that the programmer be able to know for sure that an arbitrary name is  "free for use" and best way to conveniently assure this is to require  that the LISP package be unadulterated.  As for the additional definitions, there are situations where additional  definitions would cause a problem. For example, if a symbol on the Lisp  package were declared as a special variable even though that value was  not mentioned in the standard, that variable would behave incorrectly when  used as a lexical variable. Similarly, if a symbol in the lisp package  were defined as an implementation-dependent special form, problems might  result if a user redefined or even bound (as by FLET or MACROLET) that  name.  The LISP package is the foothold from which portable programs establish  their desired environment. Careful control is desirable to make sure  everyone is starting off on the right foot.Current Practice:  Some implementations have been known to add additional symbols (usually  functional and/or variable extensions) to the LISP package.  Several implementations have restricted the LISP package to only contain  those symbols in CLtL. (The exact set was difficult to extract because not all  LISP package symbols appeared in the index of CLtL.)  Even in those implementations that have only the prescribed symbols in CLtL,  there can be extra definitions for those symbols. For example, in Symbolics Genera,  the symbols EVALHOOK, ROOM, and APPLYHOOK  are spuriously defined as special variables, and the symbol LAMBDA is defined  as a macro. Performance Impact:  NoneCost to Implementors:  The actual cost of moving the symbols out of the LISP package in cases  where they are not already gone is quite small. However, if any  implementation really has to do this, it may have a number of suppositions  about what is in what package, and the changes could potentially be extensive.Cost to Users:  This change is upward compatible with any portable program, but users  of a particular implementation's extensions may be forced to find their  functions in a different package, so there may be a measurable practical  cost.  In many cases where an extension symbol FOO is simply expected to have  been directly available (due to :USE "LISP"), it will work to just just  do (IMPORT 'new-home-package-for-foo:FOO) where the user's package is  declared.  More likely the extension symbols would be moved to one or more  extensions packages, e.g. ACME-COMMON-LISP, so user packages in which  the extensions were desired could simply :USE the extensions package(s).  Implementations might want to use this way of conforming with this  proposal in order to minimize cost to users.  In many cases where an extension symbol FOO is used by explicit package  prefix, such as LISP:FOO, it should be easy to search for `LISP:FOO' or  even `LISP:' to find the cases.Cost of Non-Adoption:  The potential for the LISP package to be adulterated and for supposedly  portable programs to have difficulty getting a foothold in some  implementations will be `noticeably non-zero'.Benefits:  Portability of some programs will be enhanced.Aesthetics:  This change probably supports the naive expectation of most programmers  writing portable code.Discussion:  This proposal basically affects what implementors are allowed to do;  it says that portable programs can rely on a standard initial package  structure with the same symbols in it. A separate proposal,   LISP-SYMBOL-REDEFINITION, discusses the restrictions on portable  programs as far as redefining LISP symbols.  Whether the USER package may contain symbols other than those   specified in the standard was controversial.  The smart programmer  of portable code will never rely on the contents of the  USER package. However, if someone wants a completely empty   package that uses only Lisp, it's easy and portable to create one.  While it would improve portability slightly to disallow additional internal  symbols in the LISP package (since it affects what DO-SYMBOLS will do)  explicitly prohibiting a common practice didn't seem like the best way  to discourage a possibly troublesome implementation technique.   Implementors should be especially careful about accidentally   exporting unwanted additional definitions for symbols,e.g., a variable   definition for EVALHOOK which might show through because of   an unintended name collision.  It is likely that the recently included portions of the standard (CLOS and  the signal mechanism) will reside in their own packages. These externally  defined packages should have the same constraints as outlined for  the LISP package here.  There has been a suggestion that vendor-specific extensions should  be placed in a package named like ACME-COMMON-LISP for the "Acme"  company.   A registry of packages (as well as features, modules and other global  names) would be useful, although probably not a part of the language  standard, per se.     ----- End Forwarded Messages -----*start*01630 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 14:49:43 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 12 Dec 88  14:48:25 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 507438; Mon 12-Dec-88 17:47:27 ESTDate: Mon, 12 Dec 88 17:47 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PACKAGE-CLUTTER (Version 5)To: masinter.pacc: cl-cleanup@sail.stanford.eduIn-Reply-To: <881208-182529-5127@Xerox>Message-ID: <881212174714.6.KMP@BOBOLINK.SCRC.Symbolics.COM>    ....      A valid implimentation may have or put additional properties      on symbols (even user created symbols) as long as the      property indicators are not in the LISP, KEYWORD or USER      package.    ....The wording should be stronger. I think it should say that it will notuse any property names which are on any user-created packages (except byinheritance). In other words, it should say that the only permissiblepackages of symbols which may be used by the system for properties arethose which are initially allocated by the system for its own use (orallocated later under some known contract between the system and user ifany implementations ever do this).Also, SETF of GET, GETF(?), and SYMBOL-PLIST need to be explicitly exceptedfor the obvious reason that they are requests by the user for the systemto violate the rules we're describing above.*start*01068 00024 US Return-Path: <rpk@goldhill.com>Received: from goldhill.com ([128.168.1.211]) by Xerox.COM ; 14 DEC 88 11:56:35 PSTReceived: by goldhill.com; Wed, 14 Dec 88 14:55:55 ESTDate: Wed, 14 Dec 88 14:55:55 ESTFrom: rpk@goldhill.com (Robert Krajewski)Message-Id: <8812141955.AA16807@goldhill.com>To: cl-cleanup@sail.stanford.eduCc: x3j13@sail.stanford.edu, masinter.paIn-Reply-To: cl-cleanup@sail.stanford.edu's message of 12 Dec 88 13:44 PST <881212-134536-5049@Xerox>Subject: Issue: PACKAGE-CLUTTER (Version 6)I just noticed two problems in this paragraph:  A valid implimentation may have or put additional properties  on symbols (even user created symbols) as long as the  property indicators are not in the LISP, KEYWORD or USER  package.1. The spelling of the third word.2. It should be OK for an implementation to use property list indicatorsthat are *internal* symbols in the LISP package.  (Of course, the ``internal''concept doesn't make sense, really, for keywords, and internal USER symbolsare the most common kind.)*start*00646 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 15:24:52 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  15:24:32 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 15:22:33 PSTDate: 2 Jan 89 15:22 PSTSender: masinter.paSubject: re: Issue: PACKAGE-CLUTTER:REDUCE (Version 6)To: cl-cleanup@sail.stanford.eduFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Message-ID: <890102-152233-1735@Xerox>YES, but note such that symbols which are documented special-forms are alsoFBOUNDP.*start*01991 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 15:06:30 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Jan 89  15:04:25 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 05 JAN 89 23:58:51 PSTDate: 5 Jan 89 23:57 PSTSender: masinter.paSubject: Issue: PACKAGE-CLUTTER (Version 6)To: cl-cleanup@sail.stanford.eduFrom: Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <890105-235851-193@Xerox>[lmm: I've been folding short comments into my Issue status file, but thisone is too long.] This leaves implementations freedom to hack any properties other than those in the LISP, KEYWORD, and USER packages.  In fact, though, the user should probably also have rights over the system in packages he creates. This will be an incompatible change -- possibly a major one -- for Genera, which uses properties named by keywords and by symbols in the LISP package. However, we think the change is worthwhile. In general, Genera tries not to distinguish "the system" from "the user". Anything the system is permitted to do, the user is permitted to do. As such, we feel a little odd about placing restrictions on the system which are not likewise placed on the user. In fact, if the system can cause problems in this way, the user can, too. This proposal is only  heuristic. We're voting "Yes" because it's probably a change for the better. But we won't be surprised if ultimately it is not seen to be the right way to achieve the high-level goal. LEXICAL, TYPE, INLINE, NOTINLINE, and FTYPE proclamations should be explicitly ruled out (just as SPECIAL is) except that TYPE is allowed if it's a CL variable, and FTYPE, INLINE, and NOTINLINE are allowed if it's a CL function. The DECLARATION proclamation probably be explicitly allowed (because  we see no reason not to permit it).