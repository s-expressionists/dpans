*start*04270 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 DEC 88 18:56:00 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Dec 88  18:53:36 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 05 DEC 88 18:23:09 PSTDate: Mon, 05 Dec 88 18:22:59 PSTFrom: Pavel.paSubject: Issue: SETF-MULTIPLE-STORE-VARIABLESTo: CL-Cleanup@SAIL.Stanford.EduCc: Pavel.paReply-To: CL-Cleanup@SAIL.Stanford.Edu, Pavel.paMessage-ID: <881205-182309-4829@Xerox>[Please note that I am no longer on the Cleanup mailing list, so anydiscussion of this should Cc me explicitly.  Thanks.  --Pavel]Issue:         SETF-MULTIPLE-STORE-VARIABLESReferences:    CLtL, pp.93-107Category:      ADDITIONEdit history:  Pavel, December 5, 1988, (Version 1)Problem description:The description of GET-SETF-METHOD-MULTIPLE-VALUE on page 107 of CLtLstates that there are no cases in Common Lisp that allow multiple values tobe stored into a generalized variable.  This is seen by some as anarbitrary decision in light of the fact that a very reasonable semanticsexists for multiple values being assigned by several Common Lisp macros,including SETF.Proposal (SETF-MULTIPLE-STORE-VARIABLES:ALLOW): Extend the semantics of themacros SETF, PSETF, SHIFTF, ROTATEF, ASSERT, CTYPECASE, and CCASE to allow"places" whose SETF methods have more than one "store variable".  In suchcases, the macros must arrange to save enough of the values of thoseexpressions whose result(s) will be assigned to a generalized-variablereference.Further, extend the long form of DEFSETF to allow the specification of morethan one "store variable", with the obvious semantics.Test Cases/Examples:(defstruct region width height)(defun region-size (region)   (values      (region-width region)      (region-height region)))(defsetf region-size (region) (width height)   `(values       (setf (region-width ,region) ,width)       (setf (region-height ,region) ,height)))(setf my-reg (make-region :width 10 :height 20))=> #S(REGION :WIDTH 10 :HEIGHT 20)(region-size my-reg)=> 10   20(setf (region-size my-reg) (values 30 40))=> 30   40(region-size my-reg)=> 30   40        Rationale:This change removes an artificial restriction on the semantics of severalCommon Lisp macros, allowing a broader set of contexts in which generalizedvariables can be used.  For example, it is not difficult to write areasonable SETF method for the VALUES function, yielding a powerfulMULTIPLE-VALUE-SETF form:	(setf (values (car a) (gethash b 'c) (aref d 13))	      (some-hairy-computation))In the language as currently defined, this example would have to be written	(multiple-value-bind (x y z)	                     (some-hairy-computation)	   (setf (car a)        x	         (gethash b 'c) y	         (aref d 13)    z))Many other (perhaps more compelling) examples of generalized variablesholding more than one value can easily be imagined.  Their use, however, isseverely discouraged by Common Lisp as defined in CLtL, since none of thebuilt-in macros will accept them.Current practice:I do not know of any implementations that allow this extension.  Xerox Lispdoes not signal an error, but this is probably due to a bug inGET-SETF-METHOD.  Lucid signals an error in GET-SETF-METHOD.Cost to Implementors:A relatively minor fix to each of the affected macros suffices.  Forexample, to fix SETF itself, one need only check for the case of multiplestore variables and emit a MUTLIPLE-VALUE-BIND instead of a LET when thereis more than one to bind.Cost to Users:This is an upward-compatible change; no user code must change.Cost of non-adoption:Yet another non-uniformity in the language, yet another piece of mechanismwithout a clear use (GET-SETF-METHOD-MULTIPLE-VALUE).Benefits:Wider applicability of a reasonably nice abstraction, the removal of anartificial prohibition.Aesthetics:People may disagree about whether this is a simplification or not.  I amfirmly on the side that believes that such removal of non-uniformities is asimplifying force in the language.Discussion:Pavel supports this proposal.*start*07819 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 DEC 88 13:47:10 PSTReceived: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by SAIL.Stanford.EDU with TCP; 6 Dec 88  13:39:05 PSTReceived: from GANG-GANG.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 248688; Tue 6-Dec-88 16:01:18 ESTDate: Tue, 6 Dec 88 16:01 ESTFrom: Glenn S. Burke <gsb@ALDERAAN.SCRC.Symbolics.COM>Subject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)To: Pavel.pacc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <881205-182309-4829@Xerox>Message-ID: <19881206210102.1.GSB@GANG-GANG.SCRC.Symbolics.COM>On the whole I am for the idea of SETF and some of its friends handlingmultiple values.  (I have implemented setf -- twice -- with an eyetowards such "upwards-compatible" extensions.)  However, there are a fewproblems with the meanings of some of the constructs which are mentionedwhen multiple values get added, and the argument aboutGET-SETF-METHOD-MULTIPLE-VALUE being a non-uniformity and unneeded isunsound.    Date: Mon, 05 Dec 88 18:22:59 PST    From: Pavel.pa@Xerox.COM    [Please note that I am no longer on the Cleanup mailing list, so any    discussion of this should Cc me explicitly.  Thanks.  --Pavel]    Issue:         SETF-MULTIPLE-STORE-VARIABLES    References:    CLtL, pp.93-107    Category:      ADDITION    Edit history:  Pavel, December 5, 1988, (Version 1)    Problem description:    The description of GET-SETF-METHOD-MULTIPLE-VALUE on page 107 of CLtL    states that there are no cases in Common Lisp that allow multiple values to    be stored into a generalized variable.  This is seen by some as an    arbitrary decision in light of the fact that a very reasonable semantics    exists for multiple values being assigned by several Common Lisp macros,    including SETF.    Proposal (SETF-MULTIPLE-STORE-VARIABLES:ALLOW): Extend the semantics of the    macros SETF, PSETF, SHIFTF, ROTATEF, ASSERT, CTYPECASE, and CCASE to allow    "places" whose SETF methods have more than one "store variable".  In such    cases, the macros must arrange to save enough of the values of those    expressions whose result(s) will be assigned to a generalized-variable    reference.SETF and PSETF are trivial, and their meanings are obvious, becausemultiple "setfs" within the form are basically independent of eachother.  SHIFTF and ROTATEF may want to require all the places involvedto deal with the same number of multiple values, but probably forconsistency with multiple-value handling elsewhere, should just quietlyuse NIL for missing values.ASSERT, CTYPECASE, and CCASE on the other hand should NOT deal withmultiple values.  Semantically, they are dealing with individual values(in the case of ASSERT, it is a list of individual values which can berespecified by the user -- individually).    Further, extend the long form of DEFSETF to allow the specification of more    than one "store variable", with the obvious semantics.I see no problem with this.    Test Cases/Examples:    (defstruct region width height)    (defun region-size (region)       (values	  (region-width region)	  (region-height region)))    (defsetf region-size (region) (width height)       `(values	   (setf (region-width ,region) ,width)	   (setf (region-height ,region) ,height)))    (setf my-reg (make-region :width 10 :height 20))    => #S(REGION :WIDTH 10 :HEIGHT 20)    (region-size my-reg)    => 10       20    (setf (region-size my-reg) (values 30 40))    => 30       40    (region-size my-reg)    => 30       40            Rationale:    This change removes an artificial restriction on the semantics of several    Common Lisp macros, allowing a broader set of contexts in which generalized    variables can be used.  For example, it is not difficult to write a    reasonable SETF method for the VALUES function, yielding a powerful    MULTIPLE-VALUE-SETF form:	    (setf (values (car a) (gethash b 'c) (aref d 13))		  (some-hairy-computation))    In the language as currently defined, this example would have to be written	    (multiple-value-bind (x y z)				 (some-hairy-computation)	       (setf (car a)        x		     (gethash b 'c) y		     (aref d 13)    z))    Many other (perhaps more compelling) examples of generalized variables    holding more than one value can easily be imagined.  Their use, however, is    severely discouraged by Common Lisp as defined in CLtL, since none of the    built-in macros will accept them.    Current practice:    I do not know of any implementations that allow this extension.  Xerox Lisp    does not signal an error, but this is probably due to a bug in    GET-SETF-METHOD.  Lucid signals an error in GET-SETF-METHOD.See end of reply.    Cost to Implementors:    A relatively minor fix to each of the affected macros suffices.  For    example, to fix SETF itself, one need only check for the case of multiple    store variables and emit a MUTLIPLE-VALUE-BIND instead of a LET when there    is more than one to bind.SHIFTF and ROTATEF get hairy (I punted), but I believe they are doable.    Cost to Users:    This is an upward-compatible change; no user code must change.    Cost of non-adoption:    Yet another non-uniformity in the language, yet another piece of mechanism    without a clear use (GET-SETF-METHOD-MULTIPLE-VALUE).See end of reply.    Benefits:    Wider applicability of a reasonably nice abstraction, the removal of an    artificial prohibition.    Aesthetics:    People may disagree about whether this is a simplification or not.  I am    firmly on the side that believes that such removal of non-uniformities is a    simplifying force in the language.See below.    Discussion:    Pavel supports this proposal.The use and distinction of GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE is quite clear:  the latter is thegeneral case, and the former is for those contexts where multiple valuesare not handled.  As such, it SHOULD give an error -- otherwise, thepoor caller that is not going to be able to deal with multiple values(consider calls from setf methods like LDB and GETF) will only have tocheck for it themselves.  It just happens that there are no predefinedsetf-methods in CL specified by the manual.  In fact, a reading of themanual implies that -- should a user correctly define a setf method onVALUES -- it should work with SETF, and I don't believe it precludescorrect handling of multiple values by any of the other setting forms(PSETF, SHIFTF, and ROTATEF) other than by use of PROG1 in descriptiveexamples.I would support a proposal which proposed the following:Clarification that SETF and PSETF do handle multiple values.Clarification of whether or not SHIFTF and ROTATEF do.  If they should,the possibility of enforcement of all the place forms having the samenumber of values arises.  I think they should handle multiple values andshould barf if they try to handle different numbers of values fromdifferent places, but haven't thought about it a whole lot and don'tfeel particularly strongly about it.Addition of a builtin setf-method for the VALUES function.Clarification of GET-SETF-METHOD to say that it signals an error if thesetf method returns other than one store variable.  I believe this to bea clarification, taking into account the wording underGET-SETF-METHOD-MULTIPLE-VALUE, and considering what other courses ofaction it could take.  (Does it just throw them away for instance andquietly let one construct broken code?  Does it not live up to the"guarantee" it is documented to provide?)*start*04130 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 DEC 88 15:21:37 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Dec 88  15:15:10 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 06 DEC 88 15:10:32 PSTDate: Tue, 06 Dec 88 15:10:26 PSTFrom: Pavel.paSubject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)In-reply-to: <19881206210102.1.GSB@GANG-GANG.SCRC.Symbolics.COM>To: CL-Cleanup@sail.stanford.eduCc: Pavel.paMessage-ID: <881206-151032-6974@Xerox>My responses to Glenn's recent message:    On the whole I am for the idea of SETF and some of its friends handling    multiple values.  (I have implemented setf -- twice -- with an eye    towards such "upwards-compatible" extensions.)  However, there are afew    problems with the meanings of some of the constructs which arementioned    when multiple values get added, and the argument about    GET-SETF-METHOD-MULTIPLE-VALUE being a non-uniformity and unneeded is    unsound.Not all of your problems with the extended semantics are correct, thoughtwo of them are (see below).  I agree that theGET-SETF-METHOD-MULTIPLE-VALUE argument is probably unnecessary and poorlystated in the first place.    SHIFTF and ROTATEF may want to require all the places involved    to deal with the same number of multiple values, but probably for    consistency with multiple-value handling elsewhere, should just quietly    use NIL for missing values.I don't think it's necessary to require all of the places to contain thesame number of values.  For consistency with the rest of Common Lisp, extravalues at each step should be ignored and missing ones defaulted to NIL.This is (coincidentally?) also the easiest semantics to implement.    ASSERT, CTYPECASE, and CCASE on the other hand should NOT deal with    multiple values.  Semantically, they are dealing with individual values    (in the case of ASSERT, it is a list of individual values which can be    respecified by the user -- individually).You point about CTYPECASE and CCASE is very well taken; consider themremoved from the proposal.  That was a bit of a thinko on my part.  ASSERT,on the other hand, should stay.  In the case of ASSERT it is NOT a list ofindividual values, but of individual PLACES.  Sure they can be individuallychanged by the user.  But doesn't that user specify an expression whosevalue will be stored?  Can't that expression return multiple values?  I amnot compelled to remove ASSERT.    The use and distinction of GET-SETF-METHOD and    GET-SETF-METHOD-MULTIPLE-VALUE is quite clear:  the latter is the    general case, and the former is for those contexts where multiplevalues    are not handled.  As such, it SHOULD give an error ...I quite agree.  I did not intend to give any other impression.    I don't believe it precludes    correct handling of multiple values by any of the other setting forms    (PSETF, SHIFTF, and ROTATEF) other than by use of PROG1 in descriptive    examples.A good point about the use of PROG1 in the examples; I suppose that oughtto be mentioned in the proposal in order to guide the document writers.    I would support a proposal which proposed the following:            ...            Addition of a builtin setf-method for the VALUES function.I wouldn't mind seeing this in the language at all, but it wasn't clear tome just what the X3J13 policy was concerning the addition of new SETFmethods.  There are a lot of other Common Lisp forms that can meaningfullybe given SETF methods (CONS, VECTOR and QUOTE, to name some provocativeexamples), but it's not clear just which ones should be ``built-in'' sincethere's nothing to prevent users adding them themselves (except collisionsbetween two users' code for the same method).  I leave this policy decisionup to the committee.    Clarification of GET-SETF-METHOD to say that it signals an error if the    setf method returns other than one store variable.I would support this clarification.*start*02106 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 20:36:26 PSTReceived: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by SAIL.Stanford.EDU with TCP; 7 Dec 88  20:25:54 PSTReceived: from GANG-GANG.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 249508; Wed 7-Dec-88 22:48:07 ESTDate: Wed, 7 Dec 88 22:47 ESTFrom: Glenn S. Burke <gsb@ALDERAAN.SCRC.Symbolics.COM>Subject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)To: Pavel.pa, CL-Cleanup@sail.stanford.eduIn-Reply-To: <881206-151032-6974@Xerox>Message-ID: <19881208034755.9.GSB@GANG-GANG.SCRC.Symbolics.COM>    Date: Tue, 06 Dec 88 15:10:26 PST    From: Pavel.pa@Xerox.COM    My responses to Glenn's recent message:	ASSERT, CTYPECASE, and CCASE on the other hand should NOT deal with	multiple values.  Semantically, they are dealing with individual values	(in the case of ASSERT, it is a list of individual values which can be	respecified by the user -- individually).    You point about CTYPECASE and CCASE is very well taken; consider them    removed from the proposal.  That was a bit of a thinko on my part.  ASSERT,    on the other hand, should stay.  In the case of ASSERT it is NOT a list of    individual values, but of individual PLACES.  Sure they can be individually    changed by the user.  But doesn't that user specify an expression whose    value will be stored?  Can't that expression return multiple values?  I am    not compelled to remove ASSERT.Right.  It is reasonable.	Addition of a builtin setf-method for the VALUES function.    I wouldn't mind seeing this in the language at all, but it wasn't clear to    me just what the X3J13 policy was concerning the addition of new SETF    methods.I can see leaving it out of a proposal which is otherwise clarificationonly.  I can also see how making multiple value handling explicit, asyou intend, will make the lack of setf method for VALUES stick out likea sore thumb.*start*01344 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 DEC 88 12:21:38 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 29 Dec 88  12:18:58 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 513216; Thu 29-Dec-88 15:17:18 ESTDate: Thu, 29 Dec 88 15:16 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)To: CL-Cleanup@SAIL.Stanford.Edu, Pavel.paIn-Reply-To: <881205-182309-4829@Xerox>Message-ID: <19881229201656.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI support this proposal, especially as modified by GSB's comments.I'd like to point out that this proposal corresponds exactly to currentpractice in Symbolics Genera (all versions from 6.0 on), except thatSHIFTF, ROTATEF, ASSERT, CTYPECASE, and CCASE only allow single values.You should update the current practice section accordingly.I think SHIFTF and ROTATEF should allow any number of values, but theother three (yes, including ASSERT) properly only allow single values.Do you plan to bring an updated version of this proposal to thenext X3J13 meeting?*start*01060 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 18:20:23 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  18:20:11 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 JAN 89 18:19:06 PSTDate: Mon, 02 Jan 89 18:18:58 PSTFrom: Pavel.paSubject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)In-reply-to: <19881229201656.8.MOON@EUPHRATES.SCRC.Symbolics.COM>To: CL-Cleanup@SAIL.Stanford.EduCc: Pavel.paMessage-ID: <890102-181906-1853@Xerox>David says,  ``ASSERT ... properly only allow[s] single values.''Why do you think so?  I assume that you disagree with my reasoning inresponse to GSB:``In the case of ASSERT it is NOT a list of individual values, but ofindividual PLACES.  Sure they can be individually changed by the user.  Butdoesn't that user specify an expression whose value will be stored?  Can'tthat expression return multiple values?''Where do we disagree?	Pavel*start*00843 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 18:22:01 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  18:21:49 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 02 JAN 89 18:20:45 PSTDate: Mon, 02 Jan 89 18:20:37 PSTFrom: Pavel.paSubject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)In-reply-to: <19881229201656.8.MOON@EUPHRATES.SCRC.Symbolics.COM>To: CL-Cleanup@SAIL.Stanford.EduCc: Pavel.paMessage-ID: <890102-182045-1856@Xerox>Oops, I forgot to answer David's other question:	``Do you plan to bring an updated version of this proposal	  to the next X3J13 meeting?''I won't be at that meeting, so I'll just send another copy to this mailing list.	Pavel*start*00743 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 JAN 89 15:24:52 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Jan 89  15:24:42 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 12 JAN 89 14:53:39 PSTDate: 12 Jan 89 14:36 PSTFrom: masinter.paSubject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)In-reply-to: Pavel.pa's message of Mon, 02 Jan 89 18:20:37 PSTTo: Pavel.pacc: CL-Cleanup@SAIL.Stanford.EduMessage-ID: <890112-145339-1095@Xerox>I'm bringing hardcopy of the "latest" drafts of issues for discussion atX3J13. If you want me to bring this one, I'll need it by tonight.*start*18349 00024 US GV-Info: masinter.pa at 17-Mar-89 22:24:34 from massunterDate: 17 Mar 89 22:23 PSTFrom: masinter.paTo: pavelcc: masinterOn 2 Jan 89, you said you'd send another copy of SETF-MULTIPLE-STORE-VARIABLES to the cl-cleanup mailing list. We're unlikely to get to this unless you do.     ----- Begin Forwarded Messages -----Date: Mon, 02 Jan 89 18:20:37 PSTFrom: Pavel.paSubject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)In-reply-to: <19881229201656.8.MOON@EUPHRATES.SCRC.Symbolics.COM>To: CL-Cleanup@SAIL.Stanford.EduCc: Pavel.paOops, I forgot to answer David's other question:	``Do you plan to bring an updated version of this proposal	  to the next X3J13 meeting?''I won't be at that meeting, so I'll just send another copy to this mailing list.	Pavel     ----- Begin Forwarded Messages -----Date: Mon, 05 Dec 88 18:22:59 PSTFrom: Pavel.paSubject: Issue: SETF-MULTIPLE-STORE-VARIABLESTo: CL-Cleanup@SAIL.Stanford.EduCc: Pavel.paReply-To: CL-Cleanup@SAIL.Stanford.Edu, Pavel.pa[Please note that I am no longer on the Cleanup mailing list, so anydiscussion of this should Cc me explicitly.  Thanks.  --Pavel]Issue:         SETF-MULTIPLE-STORE-VARIABLESReferences:    CLtL, pp.93-107Category:      ADDITIONEdit history:  Pavel, December 5, 1988, (Version 1)Problem description:The description of GET-SETF-METHOD-MULTIPLE-VALUE on page 107 of CLtLstates that there are no cases in Common Lisp that allow multiple values tobe stored into a generalized variable.  This is seen by some as anarbitrary decision in light of the fact that a very reasonable semanticsexists for multiple values being assigned by several Common Lisp macros,including SETF.Proposal (SETF-MULTIPLE-STORE-VARIABLES:ALLOW): Extend the semantics of themacros SETF, PSETF, SHIFTF, ROTATEF, ASSERT, CTYPECASE, and CCASE to allow"places" whose SETF methods have more than one "store variable".  In suchcases, the macros must arrange to save enough of the values of thoseexpressions whose result(s) will be assigned to a generalized-variablereference.Further, extend the long form of DEFSETF to allow the specification of morethan one "store variable", with the obvious semantics.Test Cases/Examples:(defstruct region width height)(defun region-size (region)   (values      (region-width region)      (region-height region)))(defsetf region-size (region) (width height)   `(values       (setf (region-width ,region) ,width)       (setf (region-height ,region) ,height)))(setf my-reg (make-region :width 10 :height 20))=> #S(REGION :WIDTH 10 :HEIGHT 20)(region-size my-reg)=> 10   20(setf (region-size my-reg) (values 30 40))=> 30   40(region-size my-reg)=> 30   40        Rationale:This change removes an artificial restriction on the semantics of severalCommon Lisp macros, allowing a broader set of contexts in which generalizedvariables can be used.  For example, it is not difficult to write areasonable SETF method for the VALUES function, yielding a powerfulMULTIPLE-VALUE-SETF form:	(setf (values (car a) (gethash b 'c) (aref d 13))	      (some-hairy-computation))In the language as currently defined, this example would have to be written	(multiple-value-bind (x y z)	                     (some-hairy-computation)	   (setf (car a)        x	         (gethash b 'c) y	         (aref d 13)    z))Many other (perhaps more compelling) examples of generalized variablesholding more than one value can easily be imagined.  Their use, however, isseverely discouraged by Common Lisp as defined in CLtL, since none of thebuilt-in macros will accept them.Current practice:I do not know of any implementations that allow this extension.  Xerox Lispdoes not signal an error, but this is probably due to a bug inGET-SETF-METHOD.  Lucid signals an error in GET-SETF-METHOD.Cost to Implementors:A relatively minor fix to each of the affected macros suffices.  Forexample, to fix SETF itself, one need only check for the case of multiplestore variables and emit a MUTLIPLE-VALUE-BIND instead of a LET when thereis more than one to bind.Cost to Users:This is an upward-compatible change; no user code must change.Cost of non-adoption:Yet another non-uniformity in the language, yet another piece of mechanismwithout a clear use (GET-SETF-METHOD-MULTIPLE-VALUE).Benefits:Wider applicability of a reasonably nice abstraction, the removal of anartificial prohibition.Aesthetics:People may disagree about whether this is a simplification or not.  I amfirmly on the side that believes that such removal of non-uniformities is asimplifying force in the language.Discussion:Pavel supports this proposal.     ----- Next Message -----Date: Tue, 6 Dec 88 16:01 ESTFrom: Glenn S. Burke <gsb@ALDERAAN.SCRC.Symbolics.COM>Subject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)To: Pavel.pacc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <881205-182309-4829@Xerox>On the whole I am for the idea of SETF and some of its friends handlingmultiple values.  (I have implemented setf -- twice -- with an eyetowards such "upwards-compatible" extensions.)  However, there are a fewproblems with the meanings of some of the constructs which are mentionedwhen multiple values get added, and the argument aboutGET-SETF-METHOD-MULTIPLE-VALUE being a non-uniformity and unneeded isunsound.    Date: Mon, 05 Dec 88 18:22:59 PST    From: Pavel.pa@Xerox.COM    [Please note that I am no longer on the Cleanup mailing list, so any    discussion of this should Cc me explicitly.  Thanks.  --Pavel]    Issue:         SETF-MULTIPLE-STORE-VARIABLES    References:    CLtL, pp.93-107    Category:      ADDITION    Edit history:  Pavel, December 5, 1988, (Version 1)    Problem description:    The description of GET-SETF-METHOD-MULTIPLE-VALUE on page 107 of CLtL    states that there are no cases in Common Lisp that allow multiple values to    be stored into a generalized variable.  This is seen by some as an    arbitrary decision in light of the fact that a very reasonable semantics    exists for multiple values being assigned by several Common Lisp macros,    including SETF.    Proposal (SETF-MULTIPLE-STORE-VARIABLES:ALLOW): Extend the semantics of the    macros SETF, PSETF, SHIFTF, ROTATEF, ASSERT, CTYPECASE, and CCASE to allow    "places" whose SETF methods have more than one "store variable".  In such    cases, the macros must arrange to save enough of the values of those    expressions whose result(s) will be assigned to a generalized-variable    reference.SETF and PSETF are trivial, and their meanings are obvious, becausemultiple "setfs" within the form are basically independent of eachother.  SHIFTF and ROTATEF may want to require all the places involvedto deal with the same number of multiple values, but probably forconsistency with multiple-value handling elsewhere, should just quietlyuse NIL for missing values.ASSERT, CTYPECASE, and CCASE on the other hand should NOT deal withmultiple values.  Semantically, they are dealing with individual values(in the case of ASSERT, it is a list of individual values which can berespecified by the user -- individually).    Further, extend the long form of DEFSETF to allow the specification of more    than one "store variable", with the obvious semantics.I see no problem with this.    Test Cases/Examples:    (defstruct region width height)    (defun region-size (region)       (values	  (region-width region)	  (region-height region)))    (defsetf region-size (region) (width height)       `(values	   (setf (region-width ,region) ,width)	   (setf (region-height ,region) ,height)))    (setf my-reg (make-region :width 10 :height 20))    => #S(REGION :WIDTH 10 :HEIGHT 20)    (region-size my-reg)    => 10       20    (setf (region-size my-reg) (values 30 40))    => 30       40    (region-size my-reg)    => 30       40            Rationale:    This change removes an artificial restriction on the semantics of several    Common Lisp macros, allowing a broader set of contexts in which generalized    variables can be used.  For example, it is not difficult to write a    reasonable SETF method for the VALUES function, yielding a powerful    MULTIPLE-VALUE-SETF form:	    (setf (values (car a) (gethash b 'c) (aref d 13))		  (some-hairy-computation))    In the language as currently defined, this example would have to be written	    (multiple-value-bind (x y z)				 (some-hairy-computation)	       (setf (car a)        x		     (gethash b 'c) y		     (aref d 13)    z))    Many other (perhaps more compelling) examples of generalized variables    holding more than one value can easily be imagined.  Their use, however, is    severely discouraged by Common Lisp as defined in CLtL, since none of the    built-in macros will accept them.    Current practice:    I do not know of any implementations that allow this extension.  Xerox Lisp    does not signal an error, but this is probably due to a bug in    GET-SETF-METHOD.  Lucid signals an error in GET-SETF-METHOD.See end of reply.    Cost to Implementors:    A relatively minor fix to each of the affected macros suffices.  For    example, to fix SETF itself, one need only check for the case of multiple    store variables and emit a MUTLIPLE-VALUE-BIND instead of a LET when there    is more than one to bind.SHIFTF and ROTATEF get hairy (I punted), but I believe they are doable.    Cost to Users:    This is an upward-compatible change; no user code must change.    Cost of non-adoption:    Yet another non-uniformity in the language, yet another piece of mechanism    without a clear use (GET-SETF-METHOD-MULTIPLE-VALUE).See end of reply.    Benefits:    Wider applicability of a reasonably nice abstraction, the removal of an    artificial prohibition.    Aesthetics:    People may disagree about whether this is a simplification or not.  I am    firmly on the side that believes that such removal of non-uniformities is a    simplifying force in the language.See below.    Discussion:    Pavel supports this proposal.The use and distinction of GET-SETF-METHOD andGET-SETF-METHOD-MULTIPLE-VALUE is quite clear:  the latter is thegeneral case, and the former is for those contexts where multiple valuesare not handled.  As such, it SHOULD give an error -- otherwise, thepoor caller that is not going to be able to deal with multiple values(consider calls from setf methods like LDB and GETF) will only have tocheck for it themselves.  It just happens that there are no predefinedsetf-methods in CL specified by the manual.  In fact, a reading of themanual implies that -- should a user correctly define a setf method onVALUES -- it should work with SETF, and I don't believe it precludescorrect handling of multiple values by any of the other setting forms(PSETF, SHIFTF, and ROTATEF) other than by use of PROG1 in descriptiveexamples.I would support a proposal which proposed the following:Clarification that SETF and PSETF do handle multiple values.Clarification of whether or not SHIFTF and ROTATEF do.  If they should,the possibility of enforcement of all the place forms having the samenumber of values arises.  I think they should handle multiple values andshould barf if they try to handle different numbers of values fromdifferent places, but haven't thought about it a whole lot and don'tfeel particularly strongly about it.Addition of a builtin setf-method for the VALUES function.Clarification of GET-SETF-METHOD to say that it signals an error if thesetf method returns other than one store variable.  I believe this to bea clarification, taking into account the wording underGET-SETF-METHOD-MULTIPLE-VALUE, and considering what other courses ofaction it could take.  (Does it just throw them away for instance andquietly let one construct broken code?  Does it not live up to the"guarantee" it is documented to provide?)     ----- Next Message -----Date: Tue, 06 Dec 88 15:10:26 PSTFrom: Pavel.paSubject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)In-reply-to: <19881206210102.1.GSB@GANG-GANG.SCRC.Symbolics.COM>To: CL-Cleanup@sail.stanford.eduCc: Pavel.paMy responses to Glenn's recent message:    On the whole I am for the idea of SETF and some of its friends handling    multiple values.  (I have implemented setf -- twice -- with an eye    towards such "upwards-compatible" extensions.)  However, there are afew    problems with the meanings of some of the constructs which arementioned    when multiple values get added, and the argument about    GET-SETF-METHOD-MULTIPLE-VALUE being a non-uniformity and unneeded is    unsound.Not all of your problems with the extended semantics are correct, thoughtwo of them are (see below).  I agree that theGET-SETF-METHOD-MULTIPLE-VALUE argument is probably unnecessary and poorlystated in the first place.    SHIFTF and ROTATEF may want to require all the places involved    to deal with the same number of multiple values, but probably for    consistency with multiple-value handling elsewhere, should just quietly    use NIL for missing values.I don't think it's necessary to require all of the places to contain thesame number of values.  For consistency with the rest of Common Lisp, extravalues at each step should be ignored and missing ones defaulted to NIL.This is (coincidentally?) also the easiest semantics to implement.    ASSERT, CTYPECASE, and CCASE on the other hand should NOT deal with    multiple values.  Semantically, they are dealing with individual values    (in the case of ASSERT, it is a list of individual values which can be    respecified by the user -- individually).You point about CTYPECASE and CCASE is very well taken; consider themremoved from the proposal.  That was a bit of a thinko on my part.  ASSERT,on the other hand, should stay.  In the case of ASSERT it is NOT a list ofindividual values, but of individual PLACES.  Sure they can be individuallychanged by the user.  But doesn't that user specify an expression whosevalue will be stored?  Can't that expression return multiple values?  I amnot compelled to remove ASSERT.    The use and distinction of GET-SETF-METHOD and    GET-SETF-METHOD-MULTIPLE-VALUE is quite clear:  the latter is the    general case, and the former is for those contexts where multiplevalues    are not handled.  As such, it SHOULD give an error ...I quite agree.  I did not intend to give any other impression.    I don't believe it precludes    correct handling of multiple values by any of the other setting forms    (PSETF, SHIFTF, and ROTATEF) other than by use of PROG1 in descriptive    examples.A good point about the use of PROG1 in the examples; I suppose that oughtto be mentioned in the proposal in order to guide the document writers.    I would support a proposal which proposed the following:            ...            Addition of a builtin setf-method for the VALUES function.I wouldn't mind seeing this in the language at all, but it wasn't clear tome just what the X3J13 policy was concerning the addition of new SETFmethods.  There are a lot of other Common Lisp forms that can meaningfullybe given SETF methods (CONS, VECTOR and QUOTE, to name some provocativeexamples), but it's not clear just which ones should be ``built-in'' sincethere's nothing to prevent users adding them themselves (except collisionsbetween two users' code for the same method).  I leave this policy decisionup to the committee.    Clarification of GET-SETF-METHOD to say that it signals an error if the    setf method returns other than one store variable.I would support this clarification.     ----- Next Message -----Date: Wed, 7 Dec 88 22:47 ESTFrom: Glenn S. Burke <gsb@ALDERAAN.SCRC.Symbolics.COM>Subject: Re: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)To: Pavel.pa, CL-Cleanup@sail.stanford.eduIn-Reply-To: <881206-151032-6974@Xerox>    Date: Tue, 06 Dec 88 15:10:26 PST    From: Pavel.pa@Xerox.COM    My responses to Glenn's recent message:	ASSERT, CTYPECASE, and CCASE on the other hand should NOT deal with	multiple values.  Semantically, they are dealing with individual values	(in the case of ASSERT, it is a list of individual values which can be	respecified by the user -- individually).    You point about CTYPECASE and CCASE is very well taken; consider them    removed from the proposal.  That was a bit of a thinko on my part.  ASSERT,    on the other hand, should stay.  In the case of ASSERT it is NOT a list of    individual values, but of individual PLACES.  Sure they can be individually    changed by the user.  But doesn't that user specify an expression whose    value will be stored?  Can't that expression return multiple values?  I am    not compelled to remove ASSERT.Right.  It is reasonable.	Addition of a builtin setf-method for the VALUES function.    I wouldn't mind seeing this in the language at all, but it wasn't clear to    me just what the X3J13 policy was concerning the addition of new SETF    methods.I can see leaving it out of a proposal which is otherwise clarificationonly.  I can also see how making multiple value handling explicit, asyou intend, will make the lack of setf method for VALUES stick out likea sore thumb.     ----- Next Message -----Date: Thu, 29 Dec 88 15:16 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 1)To: CL-Cleanup@SAIL.Stanford.Edu, Pavel.paIn-Reply-To: <881205-182309-4829@Xerox>I support this proposal, especially as modified by GSB's comments.I'd like to point out that this proposal corresponds exactly to currentpractice in Symbolics Genera (all versions from 6.0 on), except thatSHIFTF, ROTATEF, ASSERT, CTYPECASE, and CCASE only allow single values.You should update the current practice section accordingly.I think SHIFTF and ROTATEF should allow any number of values, but theother three (yes, including ASSERT) properly only allow single values.Do you plan to bring an updated version of this proposal to thenext X3J13 meeting?     ----- End Forwarded Messages -----*start*06359 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 22-Mar-89 11:44:17 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 MAR 89 11:01:53 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Mar 89  09:31:05 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 562950; Wed 22-Mar-89 12:30:11 ESTDate: Wed, 22 Mar 89 12:29 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-MULTIPLE-STORE-VARIABLES (Version 2)To: X3J13@SAIL.STANFORD.EDUcc: Pavel.pa, GSB@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <19890322172956.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoThis proposal didn't quite make it to the January meeting, due tounclear responsibilities for who was supposed to update it from thediscussion.  I have filled the gap and made the changes implied by thediscussion back in December of last year.  We can't vote on this ifsomeone invokes the two-week rule, but perhaps no one will.Issue:         SETF-MULTIPLE-STORE-VARIABLESReferences:    CLtL, pp.93-107               Lisp Pointers, v2n2, pp.27-41Category:      ADDITIONEdit history:  Version 1,  5-Dec-88, Pavel               Version 2, 22-Mar-89, Moon, simplify, update from discussionProblem description:    The description of GET-SETF-METHOD-MULTIPLE-VALUE on page 107 of CLtL  states that there are no cases in Common Lisp that allow multiple values  to be stored into a generalized variable.  This is seen by some as an  arbitrary decision in light of the fact that a very reasonable semantics  exists for multiple values being assigned by several Common Lisp macros,  including SETF.  The rationale on page 103 of CLtL suggests that this  decision might be changed in the future.Proposal (SETF-MULTIPLE-STORE-VARIABLES:ALLOW):  Extend the semantics of the macros SETF, PSETF, SHIFTF, ROTATEF, and  ASSERT to allow "places" whose SETF methods have more than one "store  variable".  In such cases, the macros accept as many values from the  newvalue form as there are store variables.  As usual, extra values  are ignored and missing values default to NIL.  Extend the long form of DEFSETF to allow the specification of more  than one "store variable", with the obvious semantics.  Clarify that GET-SETF-METHOD signals an error if there would be more  than one store-variable.Test Cases/Examples:    (defstruct region width height)    (defun region-size (region)     (values        (region-width region)        (region-height region)))    (defsetf region-size (region) (width height)     `(values         (setf (region-width ,region) ,width)         (setf (region-height ,region) ,height)))    (setf my-reg (make-region :width 10 :height 20))  => #S(REGION :WIDTH 10 :HEIGHT 20)    (region-size my-reg)  => 10     20    (setf (region-size my-reg) (values 30 40))  => 30     40    (region-size my-reg)  => 30     40        Rationale:    This change removes an artificial restriction on the semantics of  several Common Lisp macros, allowing a broader set of contexts in  which generalized variables can be used.  For example, it is not  difficult to write a reasonable SETF method for the VALUES function,  yielding a powerful MULTIPLE-VALUE-SETF form:        (setf (values (car a) (gethash b 'c) (aref d 13))              (some-hairy-computation))  In the language as currently defined, this example would have to be  written:        (multiple-value-bind (x y z)                             (some-hairy-computation)           (setf (car a)        x                 (gethash b 'c) y                 (aref d 13)    z))  Many other (perhaps more compelling) examples of generalized variables  holding more than one value can easily be imagined.  Their use,  however, is severely discouraged by Common Lisp as defined in CLtL,  since none of the built-in macros will accept them.  The clarification of GET-SETF-METHOD makes explicit what is implied  by CLtL (CLtL uses the word "guarantee", whose relationship to  signalling of errors is unclear).Current practice:  I do not know of any implementations that allow all of this extension.  Xerox Lisp does not signal an error, but this is probably due to a bug  in GET-SETF-METHOD.  Lucid signals an error in GET-SETF-METHOD.  Symbolics Genera supports the proposal in SETF and PSETF, but not in  SHIFTF, ROTATEF, and ASSERT.Cost to Implementors:  A relatively minor fix to each of the affected macros suffices.  For  example, to fix SETF itself, one need only call  GET-SETF-METHOD-MULTIPLE-VALUE instead of GET-SETF-METHOD and emit a  MULTIPLE-VALUE-BIND instead of a LET for binding the store variables.Cost to Users:  This is an upward-compatible change; no user code must change.Cost of non-adoption:  Yet another non-uniformity in the language, yet another piece of  mechanism without a clear use (GET-SETF-METHOD-MULTIPLE-VALUE).Benefits:  Wider applicability of a reasonably nice abstraction, the removal of  an artificial prohibition.Aesthetics:  People may disagree about whether this is a simplification or not.  I  am firmly on the side that believes that such removal of  non-uniformities is a simplifying force in the language.Discussion:  Pavel supports this proposal.  Moon supports this proposal except he is not sure about the  inclusion of ASSERT.  GSB suggests that this is a clarification rather than an addition,  because the lack of any predefined setf-methods that use multiple  store variables should not mean that SETF, etc. should not work with  such a setf-method if the user defined one.  The problem is that CLtL  examples such as the ones for SHIFTF on p.98 and the simplified  definition for SETF on p.107 contradict this proposal, and might have  been taken as specifications, rather than simplified examples, by  some readers.  Predefined SETF methods for such functions as VALUES, CONS, and VECTOR  could have been proposed, but we refrained.  This proposal is necessary  to allow the user to write such methods for himself, but if this  proposal is adopted those setf-methods are very easy to write in  a portable fashion.*start*01117 00024 US Date:  4 Apr 89 12:57 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: SETF-MULTIPLE-STORE-VARIABLESTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-MULTIPLE-STORE-VARIABLESTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:46:37 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:44:43 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571286; Tue 4-Apr-89 15:44:42 EDTOriginal-Date: Tue, 4 Apr 89 15:44 EDTMessage-ID: <890404154416.6.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis was on the agenda but never gotten to.I think it might come up at the next meeting since it's mostly just a clarification.*start*02604 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at  4-May-89 10:25:50 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 MAY 89 10:14:21 PDTReceived: from arisia.Xerox.COM by SAIL.Stanford.EDU with TCP; 4 May 89  09:22:39 PDTReceived: from layla.parc.Xerox.COM by arisia.Xerox.COM with SMTP	(5.61+/IDA-1.2.8/gandalf) id AA01288; Thu, 4 May 89 09:21:02 -0700Reply-To: <rao@arisia.Xerox.COM>Received: by layla. (4.0/SMI-4.0)	id AA05410; Thu, 4 May 89 09:21:58 PDTDate: Thu, 4 May 89 09:21:58 PDTFrom: Ramana Rao <rao@arisia.Xerox.COM>Message-Id: <8905041621.AA05410@layla.>To: cl-cleanup@sail.stanford.eduCc: Rao@arisia.Xerox.COM, pavel.pa, gregor@arisia.Xerox.COM, masinter.pa@arisia.Xerox.COMSubject: Issue: SETF-MULTIPLE-STORE-VARIABLEThis message is to encourage the cleanup committee to get to and accept thisproposal and to bring up a related issue having to do with setf genericfunctions in CLOS.  The case covered by the proposal is real (or at least exactly what I want to).I have a rectangle object that has accessors for retrieving the corner pointsand the extent that return two multiple values.  A motivation for doing it thisway versus with structured objects is to please users that are particularlyconcerned about consing new structures.  So both types of methods are provided.(I hacked a version of setf that allows setf of these accessors.)Example:(defmethod rectangle-min-point ((rect rectangle))	...	(make-point min-x min-y))(defmethod rectangle-min-point* ((rect rectangle))	...	(values min-x min-y))(defmethod (setf* rectangle-min-point*) (min-x min-y (rect rectangle))	---	)The related issue has to do with CLOS.  How does the setf generic function knowhow many store values to expect?  This may be a problem with having recombinedthe store varables into a single argument list.Example:Alternatives Solutions in order of preferrence:1) Change syntax of methods on setf generic function.(defmethod (setf rectangle-min-point*) (min-x min-y) ((rect rectangle))	---	)2) Extend defgeneric to allow indicating the number of store variables expectedby the setf generic function.3) Require user to generate setf expander using some provided macro.(def-generic-setf rectangle-min-point* 2) Or the following allows catching some errors at setf expansion.(def-generic-setf rectangle-min-point* (rect) (min-x min-y))(defmethod (setf rectangle-min-point*) (min-x min-y (rect rectangle))	---	)*start*01674 00024 US GV-Info: Moon@STONY-BROOK.SCRC.Symbolics.COM at  4-May-89 12:53:02 from AGReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from arisia.Xerox.COM ([13.1.100.206]) by Xerox.COM ; 04 MAY 89 12:52:18 PDTReceived: from STONY-BROOK.SCRC.SYMBOLICS.COM by arisia.Xerox.COM with SMTP	(5.61+/IDA-1.2.8/gandalf) id AA05259; Thu, 4 May 89 12:50:27 -0700Reply-To: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 589900; 4 May 89 15:52:19 EDTDate: Thu, 4 May 89 15:52 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: SETF-MULTIPLE-STORE-VARIABLETo: rao@arisia.Xerox.COMCc: cl-cleanup@sail.stanford.edu, pavel.pa, gregor@arisia.Xerox.COM, masinter.pa@arisia.Xerox.COMIn-Reply-To: <8905041621.AA05410@layla.>Message-Id: <19890504195216.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-Fold: No    Date: Thu, 4 May 89 09:21:58 PDT    From: Ramana Rao <rao@arisia.Xerox.COM>    This message is to encourage the cleanup committee to get to and accept this    proposalWe'd better!  June?    and to bring up a related issue having to do with setf generic functions in CLOS.  setf generic functions, like the short form of defsetf, only work for storing singlevalues.  To store multiple values you need to use the long form of defsetf ordefine-setf-method.  I don't think it's at all hard to make a macro that expandsinto a defmethod and a defsetf.  It's probably not worth trying to change thesyntax of defmethod to be that macro (I think we already considered that a coupleyears ago and uncovered some problems).