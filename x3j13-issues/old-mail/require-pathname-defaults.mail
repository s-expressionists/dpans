*start*05549 00024 USaReturn-Path: <@SAIL.Stanford.EDU:sandra%orion@cs.utah.edu>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 16 OCT 87 11:11:58 PDTReceived: from CS.UTAH.EDU by SAIL.STANFORD.EDU with TCP; 16 Oct 87  11:06:55 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA25574; Fri, 16 Oct 87 12:06:57 MDTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA12462; Fri, 16 Oct 87 12:06:51 MDTDate: Fri, 16 Oct 87 12:06:51 MDTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8710161806.AA12462@orion.utah.edu>Subject: proposal for modifying behavior of REQUIRETo: cl-cleanup@sail.stanford.eduIssue:         REQUIRE-PATHNAME-DEFAULTSReferences:    CLtL p. 188Category:      CHANGE, ADDITIONEdit history:  V1, 15 Oct 1987  Sandra Loosemore (sandra@cs.utah.edu)Related issues: noneProblem description:If an explicit pathname is not given to the function REQUIRE, it decideswhat files to load in an implementation-specific manner.  The proposalspecifies a portable mechanism for locating modules intended to augmentcurrent nonportable mechanisms.Proposal:*REQUIRE-PATHNAME-LIST* [Variable]The variable *REQUIRE-PATHNAME-LIST* is a list of pathnames.  Thislist is used by the function REQUIRE in determining where to look formodules an explicit pathnames are not specified.REQUIRE tests for the following cases:(1) If the pathname argument is present and non-NIL, it is a singlepathname or a list of pathnames whose files are to be loaded in order, leftto right.(2) A pathname is constructed from the module name and merged withsuccessive pathnames from the list *REQUIRE-PATHNAME-LIST*, untila matching file is found and loaded.(3) The system will determine, in some system-dependent manner, which filesto load.  This will typically involve some central registry of module namesand the associated file lists.Users will typically wish to push new pathnames onto the front of *REQUIRE-PATHNAME-LIST* to specify alternate locations where modulesmay be found.Test Case:Rationale:Because of the wide variation between implementations, leaving it up toREQUIRE to determine which files to load is very nonportable.  Providing anexplicit pathname is often impractical as well; for example, the same codemay run under two implementations with different operating systems anddifferent file naming conventions; the modules may reside in differentplaces on different machines; or it may be desirable to support alternateversions of some modules (such as a release version and an experimentalversion).This proposal provides a portable way of describing where modules can befound.  The value of the *REQUIRE-PATHNAME-LIST* can be established in astartup or initialization file, keeping a system-specific detail separatefrom portable code files.  Allowing a search list rather than a singledefault pathname gives users extra flexibility to customize the behavior ofREQUIRE.  Moreover, the current default behavior is still supported forthose programs which depend on it.Current practice:The idea of using a search list for loadable modules is modeled after theLoadDirectories* variable used by Portable Standard Lisp.  PCLS, the CLcompatibility package layered on top of PSL, currently uses a variableSYS:*REQUIRE-PATHNAME-LIST* as described in this proposal.VaxLisp (under VMS) looks for a module with the specified name first in thecurrent directory, then in the place specified by the logical nameLISP$MODULES, then in LISP$SYSTEM.Lucid's documentation does not specify how their implementation of REQUIREworks.  I was unable to get it to find modules except in*DEFAULT-PATHNAME-DEFAULTS*.KCL looks for modules only in *DEFAULT-PATHNAME-DEFAULTS*.Adoption Cost:The change is minor and isolated to a single function.  Here is a suggestedimplementation of REQUIRE:(defvar *require-pathname-list* nil    "Where REQUIRE looks for modules if you don't give an explicit pathname.")(defun require (module &optional pathname)    (cond ((member (string module) *modules* :test #'equal))          ((consp pathname)	   (dolist (p pathname)	       (load p)))	  (pathname	   (load pathname))	  ((progn	       (setq pathname (pathname module))	       (some		   #'(lambda (default)			 (load (merge-pathnames pathname (pathname default))			       :if-does-not-exist nil))		   *require-pathname-list*)))	  ((load pathname :if-does-not-exist nil))	  (t	   (cerror "Nothing will be loaded."	       "Module ~s could not be found."	       module)))    module)Cost of non-adoption:Using REQUIRE in portable code is difficult.  In KCL and Lucid, I was forcedto redefine REQUIRE in my startup file to get it to look for modules inplaces other than *DEFAULT-PATHNAME-DEFAULTS*.Benefits:See above, under "Rationale".Conversion Cost:None.  The proposal is entirely compatible with the existing definition.Esthetics:I'd ordinarily be the last person to propose extensions to Common Lisp, buthaving to learn one feature that works under all implementations is betterthan having to learn each implementation's own peculiar way of handling thesame situation.Discussion:I mentioned the idea of having a variable to specify where REQUIRE looksfor modules in passing on the CL mailing list.  There were 2 positiveresponses and no negative ones.  Cutting.pa@xerox.com proposed a searchlist rather than a single pathname, which is actually what I had in mindanyway.-------*start*02406 00024 US Originator: SenderNameTooLong%SAIL.STANFORD:EDU:XeroxDate: 12 Oct 87 22:14Subject: Re: REQUIREFrom: diamant%hpfclp%hplabs.HP:COM:XeroxTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: common-lisp@sail.stanford.eduSubject: Re: REQUIREFrom: John Diamant <diamant%hpfclp@hplabs.HP.COM>Return-Path: <@SAIL.Stanford.EDU,@Score.Stanford.EDU:diamant%hpfclp@hplabs.HP.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 OCT 87 22:14:35 PDTReceived: from SCORE.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 12 Oct 87  21:21:45 PDTReceived: from hplabs.HP.COM (hplabs.hpl.hp.com.#Internet) by SCORE.STANFORD.EDU with TCP; Mon 12 Oct 87 21:17:28-PDTReceived: from hpfcla.HP.COM (hpfcla) by hplabs.HP.COM with SMTP ; Mon, 12 Oct 87 17:57:45 PDTReceived: from hpfclp.HP.COM by hpfcla.HP.COM; Mon, 12 Oct 87 18:50:03 mdtReceived: from hpfcjrd.HP.COM by hpfclp.HP.COM; Mon, 12 Oct 87 18:49:44 mdtReceived: from hpfcjrd by hpfcjrd.HP.COM; Mon, 12 Oct 87 18:49:52 mdtReturn-Path: <diamant@hpfcjrd>X-Answer: 42X-Mailer: mh6.5 + ivomhOriginal-Date: Mon, 12 Oct 87 18:49:50 MDTMessage-Id: <29520.561084590@hpfcjrd>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI have strong beliefs about what PROVIDE/REQUIRE should do (at least whattheir purpose is in the language).They are a necessary mechanism for loading needed modules exactly once.LOAD is inadequate for loading complete subsystems as it becomes verydifficult to make sure you only load something once.  I do believe itshould occur at compile-time since many dependencies are at compile-time,not just during execution.  But even if this only covered execution-timedependencies, the purpose for REQUIRE would be clear.  If I accessfunctions in a module written by someone else, then I need to bring thatmodule into the system.  If I have several optional parts of my system,then each of my parts may need to make sure that the module is loaded.  Ifthey all used LOAD, multiple copies would be loaded, thus wasting space (atleast in many implementations it would).  With REQUIRE, I avoid that, andalso have a way of registering a module for public consumption.John DiamantFort Collins, CO                UUCP:  {hplabs,hpfcla}!hpfclp!diamantHewlett Packard Co.             ARPA Internet: diamant%hpfclp@hplabs.HP.COM*start*03382 00024 US Originator: @SAIL.Stanford.EDU:RAM%C.CS.CMU:EDU:XeroxDate: 12 Oct 87 12:05From: Ram%C.CS.CMU:EDU:XeroxSubject: REQUIREIn-Reply-to: Msg of 9 Oct 1987  12:50-EDT from sandra%orion at cs.utah.edu (Sandra J Loosemore)To: (Nobody):EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:Xerox, RWK%SCRC-YUKON:ARPA:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Ram@C.CS.CMU.EDUTo: sandra%orion@cs.utah.edu (Sandra J Loosemore)Cc: common-lisp@SAIL.STANFORD.EDU, "Robert W. Kerns" <RWK@SCRC-YUKON.ARPA>Subject: REQUIREIn-reply-to: Msg of 9 Oct 1987  12:50-EDT from sandra%orion at cs.utah.edu (Sandra J Loosemore)Return-Path: <@SAIL.Stanford.EDU:RAM@C.CS.CMU.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 OCT 87 12:05:57 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 12 Oct 87  09:58:10 PDTReceived: ID <RAM@C.CS.CMU.EDU>; Mon 12 Oct 87 12:58:23-EDTOriginal-Date: Mon, 12 Oct 87 12:58 EDTMessage-ID: <RAM.12341924875.BABYL@>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Friday, 9 October 1987  12:50-EDT    From: sandra%orion at cs.utah.edu (Sandra J Loosemore)    To:   Ram at c.cs.cmu.edu    Re:   REQUIRE        From: Ram@C.CS.CMU.EDU        This means that doing a LOAD may not make definitions available to a        following COMPILE-FILE.  This is what REQUIRE is for.    Well, maybe that's what REQUIRE was intended to be used for, but I'm    afraid it hasn't turned out that way in practice.  Portability problems    with PROVIDE and REQUIRE are currently #2 on my list, after problems    with top-level forms.  In fact, it appears that many (most?) CL    implementations insist on treating PROVIDE and REQUIRE specially when    they appear as top-level forms.This may be just a mental block on my part, but I always used towonder why anyone would use PROVIDE/REQUIRE at all.  More recently Icame to the conclusion that their reason for existence was to statecompile-time dependencies, i.e. loading macro packages at compiletime.  If you believe this, then it is obvious that the compiler mustevaluate REQUIRE at compile time.But on reading the manual just now, I don't see any support for thistheory that REQUIRE is a mechanism for dealing with compile-timedependencies.Probably anyone who either: a] Has strong beliefs about what PROVIDE/REQUIRE should do, or b] has a good solution to the compile-time dependency problemshould speak up.It does seem to be useful to have some syntax attached to the codefile that the compiler can recognize as an explicit manipulation ofits environment.    The other problem is that implementation-specific way that REQUIRE    looks for the files to load if you don't provide a specific    pathname.  [...] If it were up to me, I'd like to see a variable    named something like *REQUIRE-PATHNAME-DEFAULTS*, which specifies    where REQUIRE should look for modules if you don't give an    explicit pathname.Having some standard mechanism for specifying a library search-listseems reasonable.  We have this capability, but implement it using our"logical device" mechanism.  Note that having simple defaultinterpretation for REQUIRE without a pathname doesn't preventimplementations from providing alternate interpretations as long asthe simple version still works.  Rob*start*03382 00024 US Originator: @SAIL.Stanford.EDU:RAM%C.CS.CMU:EDU:XeroxDate: 12 Oct 87 14:49From: Ram%C.CS.CMU:EDU:XeroxSubject: REQUIREIn-Reply-to: Msg of 9 Oct 1987  12:50-EDT from sandra%orion at cs.utah.edu (Sandra J Loosemore)To: (Nobody):EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:Xerox, RWK%SCRC-YUKON:ARPA:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Ram@C.CS.CMU.EDUTo: sandra%orion@cs.utah.edu (Sandra J Loosemore)Cc: common-lisp@SAIL.STANFORD.EDU, "Robert W. Kerns" <RWK@SCRC-YUKON.ARPA>Subject: REQUIREIn-reply-to: Msg of 9 Oct 1987  12:50-EDT from sandra%orion at cs.utah.edu (Sandra J Loosemore)Return-Path: <@SAIL.Stanford.EDU:RAM@C.CS.CMU.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 OCT 87 14:49:58 PDTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 12 Oct 87  09:58:10 PDTReceived: ID <RAM@C.CS.CMU.EDU>; Mon 12 Oct 87 12:58:23-EDTOriginal-Date: Mon, 12 Oct 87 12:58 EDTMessage-ID: <RAM.12341924875.BABYL@>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Friday, 9 October 1987  12:50-EDT    From: sandra%orion at cs.utah.edu (Sandra J Loosemore)    To:   Ram at c.cs.cmu.edu    Re:   REQUIRE        From: Ram@C.CS.CMU.EDU        This means that doing a LOAD may not make definitions available to a        following COMPILE-FILE.  This is what REQUIRE is for.    Well, maybe that's what REQUIRE was intended to be used for, but I'm    afraid it hasn't turned out that way in practice.  Portability problems    with PROVIDE and REQUIRE are currently #2 on my list, after problems    with top-level forms.  In fact, it appears that many (most?) CL    implementations insist on treating PROVIDE and REQUIRE specially when    they appear as top-level forms.This may be just a mental block on my part, but I always used towonder why anyone would use PROVIDE/REQUIRE at all.  More recently Icame to the conclusion that their reason for existence was to statecompile-time dependencies, i.e. loading macro packages at compiletime.  If you believe this, then it is obvious that the compiler mustevaluate REQUIRE at compile time.But on reading the manual just now, I don't see any support for thistheory that REQUIRE is a mechanism for dealing with compile-timedependencies.Probably anyone who either: a] Has strong beliefs about what PROVIDE/REQUIRE should do, or b] has a good solution to the compile-time dependency problemshould speak up.It does seem to be useful to have some syntax attached to the codefile that the compiler can recognize as an explicit manipulation ofits environment.    The other problem is that implementation-specific way that REQUIRE    looks for the files to load if you don't provide a specific    pathname.  [...] If it were up to me, I'd like to see a variable    named something like *REQUIRE-PATHNAME-DEFAULTS*, which specifies    where REQUIRE should look for modules if you don't give an    explicit pathname.Having some standard mechanism for specifying a library search-listseems reasonable.  We have this capability, but implement it using our"logical device" mechanism.  Note that having simple defaultinterpretation for REQUIRE without a pathname doesn't preventimplementations from providing alternate interpretations as long asthe simple version still works.  Rob*start*01764 00024 UShOriginator: @SAIL.Stanford.EDU:gls%Think:COM:XeroxDate: 19 Oct 87 11:38From: gls%Think:COM:XeroxSubject: [boyer@rascal.ics.utexas.edu: CLTL]To: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.Stanford.EDU:gls@Think.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 19 OCT 87 11:38:10 PDTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 19 Oct 87  10:51:29 PDTReturn-Path: <gls@Think.COM>Received: from kali.think.com by Think.COM; Mon, 19 Oct 87 13:51:21 EDTReceived: by kali.think.com; Mon, 19 Oct 87 13:51:37 EDTOriginal-Date: Mon, 19 Oct 87 13:51:37 EDTMessage-Id: <8710191751.AA27708@kali.think.com>We can all feel good about a comment like this:     Date: Mon, 12 Oct 87 09:06:54 CDT     From: boyer@rascal.ics.utexas.edu (Bob Boyer)     I want to express to you my great gratitude for your having put     together CLTL.  J Moore and I have recently finished converting our     theorem-prover from a Franz/Zetalisp/Maclisp/PSL version to Common     Lisp.  The converted code now runs with absolutely no operating system     or dialect dependencies under Symbolics Common Lisp, Kyoto Common     Lisp, and Lucid Common Lisp.  And I half suspect that it might still     run on those systems a decade from now.  How wonderful to be relieved     of the dread that every few months a new "release" of whatever Lisp I     was using would break my code!     The only incompatibility between the three Lisps we encountered was     about the meanings of the "put in seven extremely random user     interface commands", which we just decided to avoid completely.This last paragraph seemed quite timely, apropos of the currentdiscussion about REQUIRE.--Guy*start*02391 00024 USfOriginator: @SAIL.Stanford.EDU:sandra%orion%cs.utah:EDU:XeroxDate:  9 Oct 87 10:32From: sandra%orion%cs.utah:EDU:XeroxSubject: REQUIREIn-Reply-to: Ram@C.CS.CMU.EDU, Fri, 9 Oct 1987  11:37 EDTTo: Ram%c.cs.cmu:EDU:Xeroxcc: RWK%scrc-yukon:ARPA:Xerox, common-lisp%sail.stanford:EDU:Xerox, sandra%orion%cs.utah:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Subject: REQUIRETo: Ram@c.cs.cmu.eduCc: "Robert W. Kerns" <RWK@scrc-yukon.arpa>, common-lisp@sail.stanford.edu, Sandra J Loosemore <sandra%orion@cs.utah.edu>In-Reply-To: Ram@C.CS.CMU.EDU, Fri, 9 Oct 1987  11:37 EDTReturn-Path: <@SAIL.Stanford.EDU:sandra%orion@cs.utah.edu>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 OCT 87 10:32:15 PDTReceived: from CS.UTAH.EDU by SAIL.STANFORD.EDU with TCP; 9 Oct 87  09:51:01 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA01872; Fri, 9 Oct 87 10:50:37 MDTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA16553; Fri, 9 Oct 87 10:50:32 MDTOriginal-Date: Fri, 9 Oct 87 10:50:32 MDTMessage-Id: <8710091650.AA16553@orion.utah.edu>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    From: Ram@C.CS.CMU.EDU    This means that doing a LOAD may not make definitions available to a    following COMPILE-FILE.  This is what REQUIRE is for.Well, maybe that's what REQUIRE was intended to be used for, but I'mafraid it hasn't turned out that way in practice.  Portability problemswith PROVIDE and REQUIRE are currently #2 on my list, after problemswith top-level forms.  In fact, it appears that many (most?) CLimplementations insist on treating PROVIDE and REQUIRE specially whenthey appear as top-level forms.  The other problem is thatimplementation-specific way that REQUIRE looks for the files to load ifyou don't provide a specific pathname.  I'm currently trying to get thesame bits of code to run under 4 different CL implementations (andtwo different operating systems with incompatible filename conventions,no less) and I've got the compiled files from each implementation livingin separate subdirectories....If it were up to me, I'd like to see a variable named something like*REQUIRE-PATHNAME-DEFAULTS*, which specifies where REQUIRE should lookfor modules if you don't give an explicit pathname.-Sandra-------*start*01553 00024 USfOriginator: @SAIL.Stanford.EDU:cutting.pa%Xerox:COM:XeroxDate:  9 Oct 87 13:22From: cutting:PA:XeroxSubject: Re: *REQUIRE-PATHNAME-DEFAULTS*In-Reply-to: sandra%orion@cs.utah.edu's message of Fri, 9 Oct 87 10:50:32 MDTTo: sandra%orion%cs.utah:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.Stanford.EDU:cutting.pa@Xerox.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 OCT 87 13:22:05 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 9 Oct 87  12:33:14 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 09 OCT 87 12:23:28 PDTOriginal-Date: 9 Oct 87 12:23 PDTMessage-ID: <871009-122328-1356@Xerox>  Date: Fri, 9 Oct 87 10:50:32 MDT  From: sandra%orion@cs.utah.edu (Sandra J Loosemore)  If it were up to me, I'd like to see a variable named something like  *REQUIRE-PATHNAME-DEFAULTS*, which specifies where REQUIRE should look  for modules if you don't give an explicit pathname.Yes!  To flesh out the specification:*REQUIRE-PATHNAME-DEFAULTS*   [Variable]A pathname or list of pathnames searched in order by REQUIRE when nopathname is explicitly specified.By allowing lists of pathnames we allow multiple "library" directoriesas well as multiple file types.  For example, a user could push his owndirectory on to the standard path as follows:(setq *require-pathname-defaults*  (list*   (make-pathname :directory "~/lisp" :type "lisp")   (make-pathname :directory "~/lisp" :type "fasl")   *require-pathname-defaults*))*start*01031 00024 USfReturn-Path: <@SAIL.Stanford.EDU:Masinter.pa@Xerox.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 OCT 87 17:40:44 PDTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 22 Oct 87  17:38:10 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 22 OCT 87 17:38:44 PDTDate: 22 Oct 87 17:38 PDTFrom: Masinter.paSubject: Issue: REQUIRE-PATHNAME-DEFAULTSIn-reply-to: sandra%orion@cs.utah.edu (Sandra J Loosemore)'s message of Fri, 16 Oct 87 12:06:51 MDTTo: sandra%orion@cs.utah.edu, cl-cleanup@sail.stanford.eduMessage-ID: <871022-173844-5825@Xerox> I certainly would like to see REQUIRE mean something, although I'm alittle uneasy about making it have such an operative rather thansemantic definition.Be that as it may, I'm willing to report it out as endorsed. I take GLS's recent message as an indication that some proposal iscalled for here, although I don't know whether he likes this one.Are there any other opinions, or can we release it?*start*02417 00024 USfReturn-Path: <@SAIL.Stanford.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 OCT 87 19:03:15 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 22 Oct 87  18:54:22 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 261580; Thu 22-Oct-87 21:51:55 EDTDate: Thu, 22 Oct 87 21:51 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTSTo: Masinter.pacc: sandra%orion@cs.utah.edu, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871022-173844-5825@Xerox>Message-ID: <19871023015154.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 22 Oct 87 17:38 PDT    From: Masinter.pa@Xerox.COM     I certainly would like to see REQUIRE mean something, although I'm a    little uneasy about making it have such an operative rather than    semantic definition.    Be that as it may, I'm willing to report it out as endorsed.At Symbolics we've had a lot of experience with this kind of thing on awide variety of file systems, and I don't think anything as simple asthis proposal will truly be portable across all systems.  It can befairly difficult to construct module names that will work as expected asfile names on all the different file systems in the world.  There arelength restrictions, character set restrictions, and upper case versuslower case issues.  Also the proposal codifies a fairly naive view ofhow to use hierarchical file systems.  Since the example in the proposalshows that this can be implemented in 19 lines of code, I'd prefer aproposal to remove REQUIRE from the language entirely (along withPROVIDE), and let users who find this 19-line function adequate defineit themselves.  Other users might define a different facility forfinding and loading programs.However, since the proposal doesn't change the behavior of anythingunless you SETQ this new variable, the only way it makes Common Lispworse is if more people are misled into thinking that PROVIDE andREQUIRE are going to do something useful for them.  Thus if othercommittee members feel that we ought to endorse this, I won't sayanything.Also a quibble: in the example, (pathname module) should be(pathname (string module)) so as not to interact with thePATHNAME-SYMBOL issue.*start*01545 00024 USfReturn-Path: <sandra%orion@cs.utah.edu>Received: from cs.utah.edu by Xerox.COM ; 22 OCT 87 21:35:08 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA08970; Thu, 22 Oct 87 22:34:24 MDTReceived: by orion.utah.edu (5.54/utah-1.0-slave)	id AA24625; Thu, 22 Oct 87 22:34:05 MDTDate: Thu, 22 Oct 87 22:34:05 MDTFrom: sandra%orion@cs.utah.edu (Sandra J Loosemore)Message-Id: <8710230434.AA24625@orion.utah.edu>Subject: Re: Issue: REQUIRE-PATHNAME-DEFAULTSTo: David A. Moon <Moon@scrc-stony-brook.arpa>Cc: Masinter.pa, sandra%orion@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Thu, 22 Oct 87 21:51 EDT    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    It can be    fairly difficult to construct module names that will work as expected as    file names on all the different file systems in the world.  There are    length restrictions, character set restrictions, and upper case versus    lower case issues. I've run into these myself, particularly the uppercase/lowercaseproblem, which is more of an issue with symbols since print names aregenerally uppercase and people like to use lowercase file names onsystems that care about such things.  But this is a problem withPATHNAME and PARSE-NAMESTRING, not modules specifically.  We here atUtah had terrible problems trying to figure out how to do PCLS on theCray under CTSS, where you can only have 6 character filenames, nofiletypes, and no directories!-Sandra-------*start*01115 00024 USfReturn-Path: <@SAIL.Stanford.EDU:FAHLMAN@C.CS.CMU.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 13:52:58 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 25 Oct 87  13:50:35 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Sun 25 Oct 87 16:51:05-ESTDate: Sun, 25 Oct 87 16:51 ESTMessage-ID: <FAHLMAN.12345386056.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: "David A. Moon" <Moon@SCRC-STONY-BROOK.ARPA>Cc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: REQUIRE-PATHNAME-DEFAULTSIn-reply-to: Msg of 22 Oct 1987  21:51-EDT from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>I tend to agree with Moon on this.  This proposal is a band-aid in anarea where substantial work is needed.  Patching up the pathname stuffis probably harmless, but doesn't make much sense as long as Provide andRequire themselves are so ill-defined.  This mechanism needs seriouswork as part of a comprehensive cleanup of compilation-environment andtime-of-evaluation issues.-- Scott*start*01134 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 NOV 87 19:12:33 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 3 Nov 87  19:09:51 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 03 NOV 87 19:08:02 PSTDate: Tue, 3 Nov 87 19:07 PSTFrom: Gregor.paSubject: Issue: REQUIRE-PATHNAME-DEFAULTSTo: Scott E. Fahlman <Fahlman@C.CS.CMU.EDU>cc: David A. Moon <Moon@SCRC-STONY-BROOK.ARPA>, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12345386056.BABYL@C.CS.CMU.EDU>Message-ID: <871103190737.2.GREGOR@SPIFF.isl.parc.xerox.com>Line-fold: noOn the subject of require and provide.  I have a question which is "whouses them?".  I have seen lots of people say that they are so worthlessthat they aren't good for much, I have seen lots of implementations of"portable" compile and load drivers, I haven't seen much use of requireand provide.Maybe we should either flush them or beef them up to the point that theyare really useful.  Or perhaps they are useful and I just don'tunderstand how.-------*start*01010 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 NOV 87 19:41:00 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 3 Nov 87  19:35:35 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU>; Tue 3 Nov 87 22:36:23-ESTDate: Tue, 3 Nov 87 22:36 ESTMessage-ID: <FAHLMAN.12347808214.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: Gregor.paCc: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: REQUIRE-PATHNAME-DEFAULTSIn-reply-to: Msg of 3 Nov 1987  22:07-EST from Gregor.pa at Xerox.COMRight: nobody uses Provide and Require in portable code.  Some peoplefigure out what they do in a particualr implementation and use them forcode on that system only.  A total re-thinking is in order, probably asa part of or after the cleanup of issues related to compilationenvironment and how it affects the Lisp that called for the compilation.-- Scott*start*03726 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 SEP 88 15:01:16 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 13 Sep 88  14:59:12 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA00771; Tue, 13 Sep 88 17:58:58 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA01990; Tue, 13 Sep 88 18:00:35 EDTMessage-Id: <8809132200.AA01990@mist.UUCP>To: cl-cleanup%sail.stanford.edu@multimax.ARPASubject: Issue: REQUIRE-PATHNAME-DEFAULTS (version 1)Date: Tue, 13 Sep 88 18:00:34 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>Sorry for the delay in this, but I've been waiting for preliminarycomments from an (unnamed) member of this committee...Issue:         REQUIRE-PATHNAME-DEFAULTSReferences:    *MODULES*, PROVIDE, REQUIRE, pp 188-191Category:      CHANGEEdit history:  Version 1 by Pierson 9/13/88Status:        For Internal DiscussionProblem description:PROVIDE and REQUIRE are a dual-purpose pair of functions that attemptto provide multi-file Common Lisp programs with a single mechanism todetect and correct incorrect load sequences.  These functions werealso designed to be used for general file inclusion in Common Lisp.Unfortunately, the file loading feature of REQUIRE is specified suchthat it is inherently non-portable and environment dependent.Proposal (REQUIRE-PATHNAME-DEFAULTS:DECLARATIVE):Remove the second argument from REQUIRE.  Change the description ofREQUIRE to:    The REQUIRE function tests whether a module is already present    (using a case-sensitive comparison); if the module is not present,    REQUIRE signals a correctable error of type REQUIRE-ERROR.  The    error can be corrected by loading the appropriate file(s).Note that there is no requirement that a module consist of exactly onefile. Change the "Put in seven extremely random user interface commands"discussion to suggest that PROVIDE should be put at the end of thefile rather than the beginning.Test Cases/Examples:(REQUIRE 'fft)Would still be legal.(REQUIRE 'fft "fft")Would no longer be Common Lisp.  However implementations could stillprovide this as an extension.Rationale:The file loading feature of REQUIRE is non-portable.  Since we can'tfigure out an acceptable portable solution, the feature should beflushed.  Making REQUIRE signal a correctable error gives the user aneasy out in interactive situations.Putting PROVIDE at the beginning of a file is a mistake because thefile will still appear to be PROVIDEd if it fails to load.  This maycause files loaded later to fail mysteriously because the first failedfile didn't define expected constants or macros, etc.Current practice:All implementations that I know of currently support a second argumentto REQUIRE.  Lucid and KCL use the second argment at the pathname toload relative to the current working directory.Cost to Implementors:All currently conforming implementations will have to make a smallchange.Cost to Users:Any (non-portable) user programs that rely on the current behaviour ofREQUIRE will have to change.  On the other hand, porting Common Lispprograms from one system to another may well be simplified becauseREQUIRE errors will always correctable.Cost of non-Adoption:Part of the documented functionality of REQUIRE will continue tounavailable to portable (and many non-portable) programs.Benefits:PROVIDE and REQUIRE will be clearly restricted to a portable,checking role.Aesthetics:This simplifies the language by removing an environment-dependentfeature. Discussion:Pierson supports this proposal.*start*02172 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 SEP 88 15:52:20 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Sep 88  15:50:48 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 458636; Tue 13-Sep-88 18:49:51 EDTDate: Tue, 13 Sep 88 18:49 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (version 1)To: CL-Cleanup@SAIL.Stanford.EDU, pierson%mist@MULTIMAX.ARPAIn-Reply-To: <8809132200.AA01990@mist.UUCP>Message-ID: <880913184907.6.KMP@GRYPHON.SCRC.Symbolics.COM>This is an improvement, but I personally still consider the wholePROVIDE/REQUIRE feature to be bankrupt for another reason, unrelatedto the file issue. Specifically:If PROVIDE is at the top of a file, that will make mutually dependentsystems loadable. If it's at the bottom of a file, then mutuallydependent systems will recursively load ad nauseum (or will go backand forth erring, depending on whether you have Pierson's cleanup).That would seem to argue for putting PROVIDE at the top. But then, ifa file blows out, you've provided the module already and there is noprovision to have the PROVIDE undone.Unless we require PROVIDE to cooperate with LOAD and to have thePROVIDE info persist only if LOAD does a normal (i.e., non-erring, non-throwing, ...) return would I really believein PROVIDE and REQUIRE. I could -really- get behind PROVIDE and REQUIREif we could work out the details of this kind of cooperation to everyone'ssatisfaction.I would also buy into a further restriction on PROVIDE and REQUIRE whichsaid that it was not to be used for mutually dependent systems, andthat PROVIDE was recommended for use only after having actually donethe providing -- not at the head of the set of file(s).In the absence of those concessions, I agree that Dan's cleanup isreasonable, but I don't know to what good end. In my opinion, he'soptimizing a still-worthless utility.*start*02524 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 SEP 88 23:32:26 PDTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 13 Sep 88  23:31:39 PDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA09763@EDDIE.MIT.EDU>; Wed, 14 Sep 88 02:30:16 EDTReceived: by spt.entity.com (smail2.5); 14 Sep 88 02:11:45 EDT (Wed)To: CL-Cleanup@SAIL.Stanford.EDUCc: KMP@STONY-BROOK.SCRC.Symbolics.COM, pierson%mist@MULTIMAX.ARPAIn-Reply-To: Kent M Pitman's message of Tue, 13 Sep 88 18:49 EDT <880913184907.6.KMP@GRYPHON.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (version 1)Message-Id: <8809140211.AA10382@spt.entity.com>Date: 14 Sep 88 02:11:45 EDT (Wed)From: gz@spt.entity.com (Gail Zacharias)It would be a lot easier for implementations to give PROVIDE/REQUIREreasonable semantics if CL wasn't so damn specific about how these functionsmust be implemented.  As I recall CLtL basically states that PROVIDE mustimmediately push the module name onto the user-visible variable *MODULES*,and REQUIRE must check if the module name is on *MODULES*.  This doesn't leavemuch room for improvement, in that any divergence from this proscription couldbe detected by some theoretical program manipulating/examining *MODULES*directly.Coral decided that in practice the mutually dependent systems problem is moreimportant than strict conformance, so our REQUIRE checks a separatelymaintained list of modules being loaded and punts on them even if they're noton *MODULES*.  Nobody has ever complained.From my point of view, the ideal solution would be for *MODULES* to be removedfrom the language, or at least make its relationship to PROVIDE/REQUIRE lessimmediate.  Then we can talk about what PROVIDE/REQUIRE should do withoutworrying about explicit manipulation of *MODULES* by user code.As long as there is a chance that PROVIDE/REQUIRE could be fixed up, I thinkit would be a mistake to state, as this proposal does, that PROVIDE shouldappear at the bottom of the file.  Much of the descriptive power of PROVIDE islost if you have to put it (and hence the module name) out of view.  It'scertainly easy enough for implementations to achive the desired effectregardless of where the provide happens to physically occur (if only providewasn't specified in terms of immediate effects on *modules*), so why put theburden on the user.*start*01348 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 SEP 88 01:24:52 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Sep 88  01:23:47 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 14 SEP 88 01:20:05 PDTDate: 14 Sep 88 01:20 PDTFrom: masinter.paSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (version 1)In-reply-to: gz@spt.entity.com (Gail Zacharias)'s message of 14 Sep 88 02:11:45 EDT (Wed)To: gz@spt.entity.com (Gail Zacharias)cc: CL-Cleanup@SAIL.Stanford.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COM, pierson%mist@MULTIMAX.ARPAMessage-ID: <880914-012005-1082@Xerox>What I remember from a subcommittee meeting (that only included a small subsetof the people on the mailing list, unfortunately) is that we informally agreedto do something of the sort; that is, to remove any operative definition ofPROVIDE and REQUIRE. The exact wording is tricky. The issue I think is whether we think that programs that have recursiverequirements should be portable. I think so -- it is consistent with currentpractice and the users issue.I wonder if part of the way of handling this is to be more explicit about whatwe all know: that LOAD, PROVIDE and REQUIRE have to cooperate to make this workright.*start*01147 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 SEP 88 10:32:29 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Sep 88  10:31:31 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 14 SEP 88 10:17:45 PDTDate: Wed, 14 Sep 88 09:55 PDTFrom: Gregor.paSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (version 1)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDU, pierson%mist@MULTIMAX.ARPAFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: <880913184907.6.KMP@GRYPHON.SCRC.Symbolics.COM>Message-ID: <19880914165511.9.GREGOR@PORTNOY.parc.xerox.com>Line-fold: noI sure would like to see require and provide removed from the language.As a maintainer of a portable program, people are always asking me to"use them".  The only thing is that I have never been able to figure outa way to do that that works in the 14 Common Lisp implementations I knowof.  I also can't understand what it could possibly mean for programsthat span multiple files.-------*start*02039 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 15 SEP 88 16:34:58 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 15 Sep 88  16:33:45 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA01587; Thu, 15 Sep 88 16:20:53 EDTReceived: by ti.com id AA17748; Thu, 15 Sep 88 15:18:59 CDTReceived: from Kelvin by tilde id AA08543; Thu, 15 Sep 88 15:03:48 CDTMessage-Id: <2799345941-16254274@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Thu, 15 Sep 88 15:05:41 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "Dan L. Pierson" <pierson%mist@MULTIMAX.ARPA>Cc: cl-cleanup%sail.stanford.edu@MULTIMAX.ARPASubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (version 1)In-Reply-To: Msg of Tue, 13 Sep 88 18:00:34 EDT from "Dan L. Pierson" <pierson%mist@MULTIMAX.ARPA>> Unfortunately, the file loading feature of REQUIRE is specified such> that it is inherently non-portable and environment dependent.I think this could be specified in a portable way.  Suppose we say thatthe second argument of REQUIRE is a string or list of strings.  Eachstring must begin with a letter and contain only letters and digits.  Thenif the indicated module is not present, REQUIRE calls the loader, usingeach string as the name field of a pathname, defaulting the version to:NEWEST and the rest of the pathname components to be the same as the filein which the REQUIRE form was found, truncating the name if necessary tomake it legal.  In other words, it loads additional files from the samedirectory.  I think this would work on all five of the file systems that Iuse.  Would it be useful enough to be worthwhile?> Change the "Put in seven extremely random user interface commands"> discussion to suggest that PROVIDE should be put at the end of the> file rather than the beginning.I agree with Zacharias that it's OK for PROVIDE to be at the beginning,but an aborted load needs to un-do it.  -- David Gray*start*01840 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 14:30:53 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 19 Sep 88  14:28:51 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA02472; Mon, 19 Sep 88 17:28:32 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA08987; Mon, 19 Sep 88 17:30:10 EDTMessage-Id: <8809192130.AA08987@mist.UUCP>To: David N Gray <Gray%DSG.csc.ti.com@multimax.ARPA>Cc: cl-cleanup%sail.stanford.edu@multimax.ARPASubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (version 1) In-Reply-To: Your message of Thu, 15 Sep 88 15:05:41 -0500.             <2799345941-16254274@Kelvin> Date: Mon, 19 Sep 88 17:30:08 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>    I think this could be specified in a portable way.  Suppose we say that    the second argument of REQUIRE is a string or list of strings.  Each    string must begin with a letter and contain only letters and digits.  Then    if the indicated module is not present, REQUIRE calls the loader, using    each string as the name field of a pathname, defaulting the version to    :NEWEST and the rest of the pathname components to be the same as the file    in which the REQUIRE form was found, truncating the name if necessary to    make it legal.  In other words, it loads additional files from the same    directory.  I think this would work on all five of the file systems that I    use.  Would it be useful enough to be worthwhile?    This works iff you believe that all of the files are in the samedirectory.  I find that highly unlikely for any large system and wouldoppose this as it seems like an attempt to standardize an at bestold-fashioned way to organize source files.*start*05548 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 14:32:56 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 19 Sep 88  14:31:14 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA02504; Mon, 19 Sep 88 17:30:54 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA09008; Mon, 19 Sep 88 17:32:33 EDTMessage-Id: <8809192132.AA09008@mist.UUCP>To: cl-cleanup%sail.stanford.edu@multimax.ARPASubject: Issue: REQUIRE-PATHNAME-DEFAULTS (version 2)Date: Mon, 19 Sep 88 17:32:30 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>Issue:         REQUIRE-PATHNAME-DEFAULTSReferences:    *MODULES*, PROVIDE, REQUIRE, pp 188-191               LOAD, pp 426-427Category:      CHANGEEdit history:  Version 1 by Pierson 9/13/88               Version 2 by Pierson 9/19/88, change PROVIDE stuff per commentsStatus:        For Internal DiscussionProblem description:PROVIDE and REQUIRE are a dual-purpose pair of functions that attemptto provide multi-file Common Lisp programs with a single mechanism todetect and correct incorrect load sequences.  These functions werealso designed to be used for general file inclusion in Common Lisp.Unfortunately, the file loading feature of REQUIRE is specified suchthat it is inherently non-portable and environment dependent.The instructions on CLtL pp. 189-191 on the placement of PROVIDE andREQUIRE don't work because they ignore interactions with LOAD.  IfPROVIDE is placed at the head of a file which fails to load correctly,the module will be incorrectly recorded as loaded.  If PROVIDE isplaced at the end of the file, as is the unofficial current practicein some groups, it is not possible to REQUIRE a file that REQUIREs thecurrent file; thus mutually dependent modules cannot be correctlydefined. Proposal (REQUIRE-PATHNAME-DEFAULTS:DECLARATIVE):Remove the second argument from REQUIRE.  Change the description ofREQUIRE to:    The REQUIRE function tests whether a module is already present    (using a case-sensitive comparison); if the module is not present,    REQUIRE signals a correctable error of type REQUIRE-ERROR.  The    error can be corrected by loading the appropriate file(s).Note that there is no requirement that a module consist of exactly onefile. Change the description of PROVIDE to:   "The PROVIDE function adds a new module name to the list of    modules maintained in the variable *MODULES* and possibly performs    other implementation-dependant actions to indicate that the module    in question has been loaded."(There is no need to make a corresponding change to the definition ofREQUIRE, because it doesn't mention *MODULES*.)Add a new second paragraph to the section on LOAD (CLtL 23.4):    "Top level PROVIDE functions in files being loaded are handled     specially.  The PROVIDE is executed in a temporary environment     such that the module will appear to have been loaded during the     remainder of the load of the current file and any files loaded,     whether directly or by REQUIRE, during the loading of the current     file.  If an error occurs during the loading of the current file,     all modules PROVIDEd during the load of the current file will be     forgotten.  Otherwise, all these modules will be "confirmed" at     this level of nested loading.  (Note that an implementation which     uses *MODULES* as the only loaded module database can support all     of this by simply rebinding *MODULES* appropriately internally     and pushing the new modules onto the old binding at the end.)"Test Cases/Examples:(REQUIRE 'fft)Would still be legal.(REQUIRE 'fft "fft")Would no longer be Common Lisp.Rationale:The file loading feature of REQUIRE is non-portable.  Since we can'tfigure out an acceptable portable solution, the feature should beflushed.  Making REQUIRE signal a correctable error gives the user aneasy out in interactive situations.Current practice:All implementations that I know of currently support a second argumentto REQUIRE.  Lucid and KCL use the second argment at the pathname toload relative to the current working directory.Cost to Implementors:All currently conforming implementations will have to make a smallchange.Cost to Users:Any (non-portable) user programs that rely on the current behaviour ofREQUIRE will have to change.  On the other hand, porting Common Lispprograms from one system to another may well be simplified becauseREQUIRE errors will always correctable.Cost of non-Adoption:Part of the documented functionality of REQUIRE will continue tounavailable to portable (and many non-portable) programs.Benefits:PROVIDE and REQUIRE will be clearly restricted to a portable,checking role.Aesthetics:This simplifies the language by removing an environment-dependentfeature. Discussion:Pierson supports this proposal.This proposal creates an asymmetry in the handling of *MODULES* thatmay bother some people.Several people would like to simply eliminate PROVIDE and REQUIRE fromthe language and either leave this language space empty or provide aportable DEFSYSTEM standard.  Others believe that PROVIDE and REQUIREare useful as a safety-net even in the presence of DEFSYSTEM.  Thisproposal attempts to reduce PROVIDE and REQUIRE to a well-definedsafety-net and leaves the question of DEFSYSTEM to a separateproposal (which I don't intend to write).*start*05430 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 SEP 88 17:18:50 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Sep 88  17:18:04 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA06107g; Wed, 21 Sep 88 16:15:57 PSTReceived: by bhopal id AA03021g; Wed, 21 Sep 88 17:15:24 PDTDate: Wed, 21 Sep 88 17:15:24 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809220015.AA03021@bhopal>To: pierson%mist@MULTIMAX.ENCORE.COMCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Dan L. Pierson's message of Tue, 13 Sep 88 18:00:34 EDT <8809132200.AA01990@mist.UUCP>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (version 1)I support this proposal.  It's definitely the most positive step short of flushing REQUIRE that can be taken with the modules mess.  Note that I'm not in favor of flushing REQUIRE/PROVIDE simply because they don't meet the overexpectations outlined below.  Rather, given the acceptance of your proposal, they would play the limited role of a "safety net" underneath the currently-vendor-specific DEFSYSTEM facilities, and they would be fully portable in that role.In particular, there are many persons in the community who confuse the PROVIDE/REQUIRE pair with some limited sort of DEFSYSTEM.  This is a major mistake.  Symbolics provides it's own propietary DEFSYSTEM with it's product; and Lucid is providing a similar sort of thing with it's release 3.0 (LUMEN).  However, I don't believe we are currently in a position to discuss standardizing a more complete, portable module dependency and system building facility (via ordered file compiling, loading, etc.). In the meantime, your proposal should cut out the wart on REQUIRE that tempts so many to treat it as some kind of cheap replacement for a DEFSYSTEM.  That is, a REQUIRE statement should not be viewed as expressing merely a "latent" dependency of one module upon another, butrather as a way of saying "do not proceed until this facility is fullyavailable".  This is especially useful when loading files, since irreparable damage can be done *** merely by reading in a file *** if thepackages which the current package inherits from are not fully "set up".  Also, there is often a tendency to confuse package and modules; asdefined in CLtL, the only clear course is to treat them as orthogonalfacilities that intersect only in so far as the initialization of apackage layout may be performed by a REQUIRED module.In fact, a *very* reasonable scenario is to have several modules all "in"the same package, and the specify, in whatever implementation-dependentway one can,  that the very first file/module to be loaded is the onethat creates all the packages needed by the subsystem.  If this packagecreator file is a module all by itself, then a REQUIRE for it from other files isn't so much an attempt to lazyily create the needed packages, but simply to ensure that the other files will not be loaded before the requisite packages are fully set up.  It is in this role that REQUIRE can be most useful -- in giving an early error signal when something is being done out of order, rather than the late signal raised by "name conflicts".. . . Another facet of "module" often overlooked is that it is an abstract notion that need not be co-incident with a file.  You could just as easily "provide" the facilities encompassed in the module by compiling "in core", by SETQ'ing, and so on, as you can by loading in some specific named file.  [Indeed, this kind of dynamic is Lisp's beauty over the "conventional" programming languages].  The PROVIDE function is merely the announcement that the "facility" is available.  Of course, it goes without saying that one may call REQUIRE from places other than the toplevel forms of a file.Consequently ,I take it as obvious that a module which is contained in a file (i.e., it is "provided" by loading the file) cannot truly be said to be "provided" until the whole file is loaded in.   In such a case, it means putting the PROVIDE statement at the end of a file, as you suggest. At least one vendor I know of recommends putting the PROVIDE first, and has buggered its LOAD function to notice these top-level calls and to call UNPROVIDE if the file loading is aborted.  The flaw in this is that during the dynamic interval of loading, the value of *MODULES* is "lying" in that the remaining portions are not in fact available.  Similarly,if a file is aborted after being half loaded (and the module is unprovided)then *MODULES* will still be lying, since the earlier facilities indeed have been "provided".About the only excuse I've heard for requesting this behaviour (the "lying"PROVIDE) is that one wants to have two mutually-dependent files, but not to specify that one must be loaded first before the other one is loaded.Quickly, you see the long arm of the "cheap shot" DEFSYSTEM intruding again.-- JonL --P.S. This note was delayed due to a mail system gaff.  However, looking     ahead into the mails, I see that you were already proposing to     accommodate the mututally-requiring files by suggesting the LOAD     time "back out" of an early PROVIDE.  I hope the above comments can     provide some a basis for agreeing not bugger LOAD this way after all.*start*05414 00024 US Date:  8 Oct 88 21:30 PDTSender: masinter.paSubject: Issue: REQUIRE-PATHNAME-DEFAULTS (version 2)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:         REQUIRE-PATHNAME-DEFAULTSReferences:    *MODULES*, PROVIDE, REQUIRE, pp 188-191               LOAD, pp 426-427Category:      CHANGEEdit history:  Version 1 by Pierson 9/13/88               Version 2 by Pierson 9/19/88, change PROVIDE stuff per commentsProblem description:PROVIDE and REQUIRE are a dual-purpose pair of functions that attemptto provide multi-file Common Lisp programs with a single mechanism todetect and correct incorrect load sequences.  These functions werealso designed to be used for general file inclusion in Common Lisp.Unfortunately, the file loading feature of REQUIRE is specified suchthat it is inherently non-portable and environment dependent.The instructions on CLtL pp. 189-191 on the placement of PROVIDE andREQUIRE don't work because they ignore interactions with LOAD.  IfPROVIDE is placed at the head of a file which fails to load correctly,the module will be incorrectly recorded as loaded.  If PROVIDE isplaced at the end of the file, as is the unofficial current practicein some groups, it is not possible to REQUIRE a file that REQUIREs thecurrent file; thus mutually dependent modules cannot be correctlydefined. Proposal (REQUIRE-PATHNAME-DEFAULTS:DECLARATIVE):Remove the second argument from REQUIRE.  Change the description ofREQUIRE to:    The REQUIRE function tests whether a module is already present    (using a case-sensitive comparison); if the module is not present,    REQUIRE signals a correctable error of type REQUIRE-ERROR.  The    error can be corrected by loading the appropriate file(s).Note that there is no requirement that a module consist of exactly onefile. Change the description of PROVIDE to:   "The PROVIDE function adds a new module name to the list of    modules maintained in the variable *MODULES* and possibly performs    other implementation-dependant actions to indicate that the module    in question has been loaded."(There is no need to make a corresponding change to the definition ofREQUIRE, because it doesn't mention *MODULES*.)Add a new second paragraph to the section on LOAD (CLtL 23.4):    "Top level PROVIDE functions in files being loaded are handled     specially.  The PROVIDE is executed in a temporary environment     such that the module will appear to have been loaded during the     remainder of the load of the current file and any files loaded,     whether directly or by REQUIRE, during the loading of the current     file.  If an error occurs during the loading of the current file,     all modules PROVIDEd during the load of the current file will be     forgotten.  Otherwise, all these modules will be "confirmed" at     this level of nested loading.  (Note that an implementation which     uses *MODULES* as the only loaded module database can support all     of this by simply rebinding *MODULES* appropriately internally     and pushing the new modules onto the old binding at the end.)"Test Cases/Examples:(REQUIRE 'fft)Would still be legal.(REQUIRE 'fft "fft")Would no longer be Common Lisp.Rationale:The file loading feature of REQUIRE is non-portable.  Since we can'tfigure out an acceptable portable solution, the feature should beflushed.  Making REQUIRE signal a correctable error gives the user aneasy out in interactive situations.Current practice:All implementations that I know of currently support a second argumentto REQUIRE.  Lucid and KCL use the second argment at the pathname toload relative to the current working directory.Cost to Implementors:All currently conforming implementations will have to make a smallchange.Cost to Users:Any (non-portable) user programs that rely on the current behaviour ofREQUIRE will have to change.  On the other hand, porting Common Lispprograms from one system to another may well be simplified becauseREQUIRE errors will always correctable.Cost of non-Adoption:Part of the documented functionality of REQUIRE will continue tounavailable to portable (and many non-portable) programs.Benefits:PROVIDE and REQUIRE will be clearly restricted to a portable,checking role.Aesthetics:This simplifies the language by removing an environment-dependentfeature. Discussion:Pierson supports this proposal.This proposal creates an asymmetry in the handling of *MODULES* thatmay bother some people.Several people would like to simply eliminate PROVIDE and REQUIRE fromthe language and either leave this language space empty or provide aportable DEFSYSTEM standard.  Others believe that PROVIDE and REQUIREare useful as a safety-net even in the presence of DEFSYSTEM.  Thisproposal attempts to reduce PROVIDE and REQUIRE to a well-definedsafety-net and leaves the question of DEFSYSTEM to a separateproposal (which I don't intend to write).        TITAN 
         TITAN 
                                       H                            m                    2                    _                                          M                            }       
       O              N             @       z*start*01405 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 18:12:22 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  18:05:07 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476107; Thu 13-Oct-88 19:06:36 EDTDate: Thu, 13 Oct 88 19:06 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013190628.6.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: It was thought we should divide this into two issues: What does it do (signals an error, doesn't try to load) and where should it go in the file (relation to load, other environment issues).X3J13 meeting: Masinter: Maybe we should note that it might be extended on a per-implementation	   basis to offer arguments saying how to load for implementations	   that want to offer such. I (KMP) made a note to myself about the fact that we shouldn't encourage people to add optional arguments to things -- maybe we should have a policy that vendor extensions to arguments must be by keyword to help avoid  and/or detect portability conflicts.*start*01405 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 19:14:33 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  18:05:07 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476107; Thu 13-Oct-88 19:06:36 EDTDate: Thu, 13 Oct 88 19:06 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013190628.6.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: It was thought we should divide this into two issues: What does it do (signals an error, doesn't try to load) and where should it go in the file (relation to load, other environment issues).X3J13 meeting: Masinter: Maybe we should note that it might be extended on a per-implementation	   basis to offer arguments saying how to load for implementations	   that want to offer such. I (KMP) made a note to myself about the fact that we shouldn't encourage people to add optional arguments to things -- maybe we should have a policy that vendor extensions to arguments must be by keyword to help avoid  and/or detect portability conflicts.*start*01251 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 19:25:43 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  15:37:43 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA26464; Thu, 13 Oct 88 16:36:03 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19961; Thu, 13 Oct 88 16:36:01 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132236.AA19961@defun.utah.edu>Date: Thu, 13 Oct 88 16:36:00 MDTSubject: issue REQUIRE-PATHNAME-DEFAULTSTo: cl-cleanup@sail.stanford.eduAgain, I agree with the general direction here.  I approve of thedecision to remove the part about mangling LOAD.I'd like the description of REQUIRE changed to make it more clear thatit's the responsibility of the user, not REQUIRE, to load files afterthe correctible error is signalled.  How about replacing the lastsentence with:    This gives the user the opportunity to load the appropriate files    from the debugger before continuing.The "Rationale" section should include some mention of the motivationfor not requiring REQUIRE not to use *MODULES*.-Sandra-------*start*04902 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 OCT 88 15:13:46 PDTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 17 Oct 88  15:11:50 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA03508; Mon, 17 Oct 88 16:09:47 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA11848; Mon, 17 Oct 88 16:13:44 EDTMessage-Id: <8810172013.AA11848@mist.UUCP>To: cl-cleanup%sail.stanford.edu@MULTIMAX.ENCORE.COMCc: "sandra%defun@cs.utah.edu"@MULTIMAX.ENCORE.COMSubject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)Date: Mon, 17 Oct 88 16:13:42 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>Almost done.  Please note the second paragraph of the new Rationale.Would it be better to just restrict REQUIRE to the *MODULES* list?  Iseem to remember that at least one implementation was unhappy with that.Issue:         REQUIRE-PATHNAME-DEFAULTSReferences:    *MODULES*, PROVIDE, REQUIRE, pp 188-191               LOAD, pp 426-427Category:      CHANGEEdit history:  Version 1 by Pierson 9/13/88               Version 2 by Pierson 9/19/88, change PROVIDE stuff per comments               Version 3 by Pierson 10/17/88, remove PROVIDE locaction specs.Status:        For Internal DiscussionProblem description:PROVIDE and REQUIRE are a dual-purpose pair of functions that attemptto provide multi-file Common Lisp programs with a single mechanism todetect and correct incorrect load sequences.  These functions werealso designed to be used for general file inclusion in Common Lisp.Unfortunately, the file loading feature of REQUIRE is specified suchthat it is inherently non-portable and environment dependent.Proposal (REQUIRE-PATHNAME-DEFAULTS:DECLARATIVE):Remove the second argument from REQUIRE.  Change the description ofREQUIRE to:    The REQUIRE function tests whether a module is already present    (using a case-sensitive comparison); if the module is not present,    REQUIRE signals a correctable error of type REQUIRE-ERROR.    This gives the user the opportunity to load the appropriate files    from the debugger before continuing.Note that there is no requirement that a module consist of exactly onefile. Change the description of PROVIDE to:   "The PROVIDE function adds a new module name to the list of    modules maintained in the variable *MODULES* and possibly performs    other implementation-dependant actions to indicate that the module    in question has been loaded."(There is no need to make a corresponding change to the definition ofREQUIRE, because it doesn't mention *MODULES*.)Test Cases/Examples:(REQUIRE 'fft)Would still be legal.(REQUIRE 'fft "fft")Would no longer be Common Lisp.Rationale:The file loading feature of REQUIRE is non-portable.  Since we can'tfigure out an acceptable portable solution, the feature should beflushed.  Making REQUIRE signal a correctable error gives the user aneasy out in interactive situations.REQUIRE is not required to use *MODULES* as it's database of loadedmodules in order to permit environment-specific extensions whichderive the loaded module database from other information.  While it isalways safe, and good practice, to explicitly PROVIDE every module, itmay not be necessary in all implementations.  Current practice:All implementations that I know of currently support a second argumentto REQUIRE.  Lucid and KCL use the second argment at the pathname toload relative to the current working directory.Cost to Implementors:All currently conforming implementations will have to make a smallchange.Cost to Users:Any (non-portable) user programs that rely on the current behaviour ofREQUIRE will have to change.  On the other hand, porting Common Lispprograms from one system to another may well be simplified becauseREQUIRE errors will always correctable.Cost of non-Adoption:Part of the documented functionality of REQUIRE will continue tounavailable to portable (and many non-portable) programs.Benefits:PROVIDE and REQUIRE will be clearly restricted to a portable,checking role.Aesthetics:This simplifies the language by removing an environment-dependentfeature. Discussion:Pierson supports this proposal.This proposal creates an asymmetry in the handling of *MODULES* thatmay bother some people.Several people would like to simply eliminate PROVIDE and REQUIRE fromthe language and either leave this language space empty or provide aportable DEFSYSTEM standard.  Others believe that PROVIDE and REQUIREare useful as a safety-net even in the presence of DEFSYSTEM.  Thisproposal attempts to reduce PROVIDE and REQUIRE to a well-definedsafety-net and leaves the question of DEFSYSTEM to a separateproposal (which I don't intend to write).*start*01503 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 08:42:41 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 18 Oct 88  08:40:52 PDTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.0-cs)	id AA29861; Tue, 18 Oct 88 09:40:15 MDTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA22872; Tue, 18 Oct 88 09:40:04 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810181540.AA22872@defun.utah.edu>Date: Tue, 18 Oct 88 09:40:02 MDTSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)To: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>Cc: cl-cleanup@sail.stanford.eduIn-Reply-To: Dan L. Pierson <pierson%mist@multimax.ARPA>, Mon, 17 Oct 88 16:13:42 EDTThis looks better, but I feel really uncomfortable with the idea thatan implementation would be allowed to decide on its own that moduleswhich haven't been PROVIDE'd have been loaded anyway.  If I say(REQUIRE "foo") and if I haven't done a (PROVIDE "foo"), I want to getan error.  I don't want the implementation to decide on its own thatmodule "foo" has been loaded just because I've loaded a file named"foo", for example.  The file named "foo" might contain only part ofthe module "foo", or it might contain the system definition (definedusing some variant of DEFSYSTEM) for module "foo", or it might containsomething else entirely.-Sandra-------*start*01778 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 09:11:23 PDTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 18 Oct 88  09:10:01 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA09562; Tue, 18 Oct 88 12:09:08 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA13058; Tue, 18 Oct 88 12:13:05 EDTMessage-Id: <8810181613.AA13058@mist.UUCP>To: "sandra%defun@cs.utah.edu"@MULTIMAX.ENCORE.COM (Sandra J Loosemore)Cc: cl-cleanup%sail.stanford.edu@MULTIMAX.ENCORE.COMSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Your message of Tue, 18 Oct 88 09:40:02 -0600.             <8810181540.AA22872@defun.utah.edu> Date: Tue, 18 Oct 88 12:13:03 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>    This looks better, but I feel really uncomfortable with the idea that    an implementation would be allowed to decide on its own that modules    which haven't been PROVIDE'd have been loaded anyway.  If I say    (REQUIRE "foo") and if I haven't done a (PROVIDE "foo"), I want to get    an error.  I don't want the implementation to decide on its own that    module "foo" has been loaded just because I've loaded a file named    "foo", for example.  The file named "foo" might contain only part of    the module "foo", or it might contain the system definition (defined    using some variant of DEFSYSTEM) for module "foo", or it might contain    something else entirely.    I was thinking similar thoughts while writing the rationale.  If theperson who requested this feature (JonL?) doesn't come up with aconvincing defense soon, I'll probably remove it.*start*02320 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 10:21:08 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 18 Oct 88  10:19:51 PDTReceived: by ti.com id AA08910; Tue, 18 Oct 88 12:19:33 CDTReceived: from Kelvin by tilde id AA13138; Tue, 18 Oct 88 12:15:01 CDTMessage-Id: <2802186955-10350987@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 18 Oct 88 12:15:55 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "Dan L. Pierson" <pierson%mist@MULTIMAX.ENCORE.COM>Cc: CL-Cleanup@SAIL.Stanford.edu, sandra%defun@cs.utah.edu, Bartley@MIPS.csc.ti.comSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)In-Reply-To: Msg of Mon, 17 Oct 88 16:13:42 EDT from Dan L. Pierson <pierson%mist@multimax.ARPA>>     The REQUIRE function tests whether a module is already present>     (using a case-sensitive comparison); if the module is not present,>     REQUIRE signals a correctable error of type REQUIRE-ERROR.>     This gives the user the opportunity to load the appropriate files>     from the debugger before continuing.Is this saying that it is not appropriate for the system to load thenecessary files automatically if it knows how?  I agree that there is nohope of trying to standardize on something like DEFSYSTEM, but it shouldbe possible (and encouraged) that REQUIRE be a standard interface toload a group of files that has been specified in someimplementation-dependent way.  Signalling a correctable error for theuser to do something is appropriate if no definition of the module isavailable.I liked the specification of the interaction between LOAD and PROVIDEthat was included in version 2 but has been removed from version 3.  Ithink that JonL's objections to a "lying PROVIDE" might be satisfied byclarifying that the temporary behavior relates only to the relationbetween PROVIDE and REQUIRE, and the user-visible *MODULES* list is notactually updated until LOAD reaches the end of the file containing thePROVIDE.If this approach is not adopted, the the proposal needs to specifyinstead a change to the specification currently on pages 189 and 191 ofCLtL to say that PROVIDE should be at the end of the file instead of thebeginning.*start*01339 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 10:27:11 PDTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 18 Oct 88  10:25:38 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA00302; Tue, 18 Oct 88 13:24:33 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA13169; Tue, 18 Oct 88 13:28:29 EDTMessage-Id: <8810181728.AA13169@mist.UUCP>To: David N Gray <Gray%DSG.csc.ti.com@MULTIMAX.ENCORE.COM>Cc: CL-Cleanup%SAIL.Stanford.edu@MULTIMAX.ENCORE.COM, sandra%defun%cs.utah.edu@MULTIMAX.ENCORE.COMSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Your message of Tue, 18 Oct 88 12:15:55 -0500.             <2802186955-10350987@Kelvin> Date: Tue, 18 Oct 88 13:28:20 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>We decided at the cleanup meeting last week to separate the REQUIREsecond argument issue from the issue of where to put PROVIDE.  Sincethere seemed to a strong split in the committee with a lot ofsentiment toward not mandating either solution for the PROVIDEquestion, I haven't written a proposal for that part.  Please feelfree to write one if you wish, I'd suggest PROVIDE-LOCATION as theissue name.*start*02469 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 13:41:05 PDTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 18 Oct 88  12:24:32 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA01977; Tue, 18 Oct 88 15:23:34 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA13501; Tue, 18 Oct 88 15:27:29 EDTMessage-Id: <8810181927.AA13501@mist.UUCP>To: gz%spt.entity.com@MULTIMAX.ENCORE.COM (Gail Zacharias)Cc: cl-cleanup%sail.stanford.edu@MULTIMAX.ENCORE.COMSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Your message of Tue, 18 Oct 88 13:51:04 -0400.             <8810181351.AA19036@spt.entity.com> Date: Tue, 18 Oct 88 15:27:25 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>    If (PROVIDE x) can't be anything but (push x *modules*) and    (REQUIRE x) can't be anything but (or (member x *modules*) (error    'require-error x)), what's the point of putting these two    functions in the language?  Users can just be told that one neato    way of specifying interdependencies is by pushing things on a    variable called *modules*.  I don't see any point in having    PROVIDE/REQUIRE if nothing magical is allowed to happen and if    users have to write their own system-loading functions even in the    simplest cases.  They just take up two nice names that users might    be able to put to a better use.The first proposal _was_ to just remove these from the language.  JonLconvinced several of us that this shouldn't be done because thefunctions are useful as a safety net behind a real defsystemfacility.  If we can't agree on the stripped versions of PROVIDE andREQUIRE, the total removal proposal will probably resurface becausethe current definitions simply aren't portable and can't be madeportable without a lot more environment definition that anyone seemswilling to mandate.Personally, I totally oppose any proposal that makes PROVIDE andREQUIRE only work if all of your files are in the same directory; mostsystems have tree-structured directories, they're there for a reason,and large systems (the type that most need this feature) need to havetheir sources distributed across multiple directories.By the way, the proposed definition of REQUIRE is closer to: (or (member x *modules*) (cerror 'require-error x))*start*02025 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 13:41:21 PDTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 18 Oct 88  11:48:08 PDTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA19864@EDDIE.MIT.EDU>; Tue, 18 Oct 88 14:46:54 EDTReceived: by spt.entity.com (smail2.5); 18 Oct 88 13:51:04 EDT (Tue)To: sandra%defun@cs.utah.eduCc: pierson%mist@MULTIMAX.ENCORE.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Tue, 18 Oct 88 09:40:02 MDT <8810181540.AA22872@defun.utah.edu>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)Message-Id: <8810181351.AA19036@spt.entity.com>Date: 18 Oct 88 13:51:04 EDT (Tue)From: gz@spt.entity.com (Gail Zacharias)Coral currently "decides that a module has been provided" if the module hasbeen loaded as the result of a previous REQUIRE or is in the process of beingloaded as the result of a REQUIRE.  This mode of operation has the advantageof making it possible to handle both aborted loads and recursive dependenciescorrectly.  I realize that the concept of "loaded as the result of a REQUIRE"is less clear with the current proposal, but I'm not convinced that it becomesentirely meaningless and would not want to disallow these sorts of extensionsout of hand.If (PROVIDE x) can't be anything but (push x *modules*) and (REQUIRE x) can'tbe anything but (or (member x *modules*) (error 'require-error x)), what's thepoint of putting these two functions in the language?  Users can just be toldthat one neato way of specifying interdependencies is by pushing things on avariable called *modules*.  I don't see any point in having PROVIDE/REQUIRE ifnothing magical is allowed to happen and if users have to write their ownsystem-loading functions even in the simplest cases.  They just take up twonice names that users might be able to put to a better use.*start*01296 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 15:40:23 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 18 Oct 88  15:39:17 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 18 OCT 88 14:23:05 PDTDate: 18 Oct 88 14:13 PDTFrom: masinter.paSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-reply-to: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>'s message of Tue, 18 Oct 88 15:27:25 EDTTo: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>cc: gz%spt.entity.com@MULTIMAX.ENCORE.COM (Gail Zacharias), cl-cleanup@sail.stanford.eduMessage-ID: <881018-142305-5087@Xerox>The thing that distinguishes PROVIDE and REQUIRE from their obviousimplementations is that they have declarative rather than operativesemantics. Program walkers, DEFSYSTEM constructors as well as compilersmight be expected to pay special heed to PROVIDE and REQUIRE, but not payany special heed to direct manipulation of *MODULES*.We should be careful in the standard to distinguish between what thingsmean and how they may be implemented, but doubly so in the case of macrosand special forms that may get processed at times other than EVAL-time.*start*01688 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 OCT 88 15:48:35 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 18 Oct 88  14:51:27 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA06295g; Tue, 18 Oct 88 14:51:18 PDTReceived: by bhopal id AA01791g; Tue, 18 Oct 88 14:49:45 PDTDate: Tue, 18 Oct 88 14:49:45 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810182149.AA01791@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Thu, 13 Oct 88 19:06 EDT <881013190628.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 2)re:  I (KMP) made a note to myself about the fact that we shouldn't encourage     people to add optional arguments to things -- maybe we should have a      policy that vendor extensions to arguments must be by keyword to help      avoid and/or detect portability conflicts.Sounds like good advice.  But the situation re REQUIRE is a bit thorniersince the proposal is to make the incompatible change of flushing the&optional argument.  I had imagined that Lucid's implementation wouldaccommodate to this merely by "doing nothing" (except retracting abit of documentation); this is so that those few souls here at Lucidthat actually use the second argument wouldn't be inconvenienced.If your "good advice" about extending a standardized argument spectrumis adopted seriously, then I don't suppose it would really pose a hardshipon these "few souls" at Lucid to modify their code.-- JonL --*start*02962 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 OCT 88 12:48:35 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Oct 88  12:46:31 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 479491; Thu 20-Oct-88 15:46:21 EDTDate: Thu, 20 Oct 88 15:46 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)To: pierson%mist@MULTIMAX.ENCORE.COMcc: sandra%defun@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: <8810172013.AA11848@mist.UUCP>Message-ID: <881020154612.7.KMP@BOBOLINK.SCRC.Symbolics.COM>    ...    Current practice:    ...If (REQUIRE arg1 arg2) is done and arg1 is not present,Symbolics Genera does (LOAD-SYSTEM arg2). With Genera'sLOAD-SYSTEM comes a theory of how to register things sothey will be found, regardless of what directory theyare on.I'd like to have the current practice being by saying thatviews on how to treat the arg2 vary pretty widely and thencite Lucid/Vaxlisp vs Genera as examples. To an extent, thisis the real rationale for flushing the arg2 -- there is noportable alternative.    ...    Discussion: This proposal creates an asymmetry in    the handling of *MODULES* that may bother some people.I didn't understand this reference. I think it should be spelled out.    Several people would like to simply eliminate PROVIDE and REQUIRE from    the language and either leave this language space empty or provide a    portable DEFSYSTEM standard.  Others believe that PROVIDE and REQUIRE    are useful as a safety-net even in the presence of DEFSYSTEM.  This    proposal attempts to reduce PROVIDE and REQUIRE to a well-defined    safety-net and leaves the question of DEFSYSTEM to a separate    proposal (which I don't intend to write).I think this should be promoted to Rationale, and expanded to includethis. The Rationale should say outright that the only two realistic optionsare flushing the functions altogether or retaining them in thislabotomized form, and should then go on to give the reasons:Larry's remarks about PROVIDE/REQUIRE having a declarative feel (whichcan be easily grokked by a code walker) while a condition error signallingmechanism such as GZ wants to fall back to would have an imperativefeel that would be largely opaque to code walkers.Regarding JonL's remarks, I wonder if we should mention explicitly in theproposal that implementations are permitted to extend the syntax to permitan implementation-specific, optional second argument which specifies howto find the module if it is not present.Regarding the proposal as a whole, I buy into Larry's arguments and thinkthat this streamlined definition of REQUIRE/PROVIDE is the right way to go.*start*01651 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 OCT 88 13:34:59 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 25 Oct 88  13:33:35 PDTReceived: by ti.com id AA01008; Mon, 24 Oct 88 18:34:06 CDTReceived: from Kelvin by tilde id AA28622; Mon, 24 Oct 88 18:23:26 CDTMessage-Id: <2802727517-1153780@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 24 Oct 88 18:25:17 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Sandra J Loosemore <sandra%defun@CS.UTAH.EDU>Cc: "Dan L. Pierson" <pierson%mist@MULTIMAX.ENCORE.COM>, CL-Cleanup@SAIL.Stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)In-Reply-To: Msg of Tue, 18 Oct 88 09:40:02 MDT from Sandra J Loosemore <sandra%defun@CS.UTAH.EDU>> This looks better, but I feel really uncomfortable with the idea that> an implementation would be allowed to decide on its own that modules> which haven't been PROVIDE'd have been loaded anyway. It makes sense in the scenario where you say (REQUIRE "foo") where youhave defined in some implementation-dependent way what to do to install"foo", then it would be reasonable to assume that after doing that,"foo" has now been provided even if there wasn't an explicit PROVIDEcall in one of the files.  This would permit a user to define a modulename for a group of files without having to edit a file to add aPROVIDE.  For example, on the Explorer, REQUIRE with one argument callsMAKE-SYSTEM, and MAKE-SYSTEM calls PROVIDE when it is finished.  Can you feel comfortable with permitting that?*start*01781 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 OCT 88 13:45:29 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 25 Oct 88  13:44:07 PDTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.0-cs)	id AA02305; Tue, 25 Oct 88 14:43:13 MDTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA28871; Tue, 25 Oct 88 14:42:57 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810252042.AA28871@defun.utah.edu>Date: Tue, 25 Oct 88 14:42:56 MDTSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)To: David N Gray <Gray@DSG.csc.ti.com>Cc: Sandra J Loosemore <sandra%defun@CS.ARPA>, "Dan L. Pierson" <pierson%mist@MULTIMAX.ENCORE.COM>, CL-Cleanup@SAIL.Stanford.eduIn-Reply-To: David N Gray <Gray@DSG.csc.ti.com>, Mon, 24 Oct 88  18:25:17 CDT> Date: Mon, 24 Oct 88  18:25:17 CDT> From: David N Gray <Gray@DSG.csc.ti.com>> > For example, on the Explorer, REQUIRE with one argument calls> MAKE-SYSTEM, and MAKE-SYSTEM calls PROVIDE when it is finished.  > Can you feel comfortable with permitting that?I think it's reasonable for MAKE-SYSTEM (or LOAD-SYSTEM, or whatever)to implicitly or explicitly do a PROVIDE, since MAKE-SYSTEM is notpart of standard Common Lisp.  I'm more concerned about forbiddingthings that -are- part of the standard language (like LOAD) fromhaving side effects that make REQUIRE behave differently in differentimplementations.Also, I don't think that making REQUIRE automatically do a MAKE-SYSTEMis in the spirit of this proposal, which is intended to make REQUIREstrictly declarative and never cause anything to be loaded withoutuser intervention.-Sandra-------*start*02067 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 OCT 88 16:57:52 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 25 Oct 88  16:55:41 PDTReceived: by ti.com id AA02863; Tue, 25 Oct 88 18:50:53 CDTReceived: from Kelvin by tilde id AA21593; Tue, 25 Oct 88 18:31:40 CDTMessage-Id: <2802814400-1415862@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 25 Oct 88 18:33:20 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: sandra%defun@cs.utah.edu (Sandra J Loosemore)Cc: "Dan L. Pierson" <pierson%mist@MULTIMAX.ENCORE.COM>, CL-Cleanup@SAIL.Stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)In-Reply-To: Msg of Tue, 25 Oct 88 14:42:56 MDT from sandra%defun@cs.utah.edu (Sandra J Loosemore)> I think it's reasonable for MAKE-SYSTEM (or LOAD-SYSTEM, or whatever)> to implicitly or explicitly do a PROVIDE, since MAKE-SYSTEM is not> part of standard Common Lisp.I thought that was the intent of the phrase "permit environment-specificextensions", but evidently it needs to be clarified.>    I'm more concerned about forbidding> things that -are- part of the standard language (like LOAD) from> having side effects that make REQUIRE behave differently in different> implementations.Agreed.> Also, I don't think that making REQUIRE automatically do a MAKE-SYSTEM> is in the spirit of this proposal, which is intended to make REQUIRE> strictly declarative and never cause anything to be loaded without> user intervention.Right; that's what is bothering me.  This proposal really does two things: 1. It eliminates the second argument of REQUIRE. 2. It changes the meaning of calling REQUIRE with one argument from what    CLtL says at the bottom of page 188.I agree with the first change.  I do not agree with the second change, andthere is nothing in the "rationale" to justify it.  All of the discussionhas been addressing the first change only.  Where did this second changecome from?*start*03062 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 OCT 88 17:24:45 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 25 Oct 88  17:23:30 PDTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.0-cs)	id AA12825; Tue, 25 Oct 88 18:22:42 MDTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA28990; Tue, 25 Oct 88 18:22:35 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810260022.AA28990@defun.utah.edu>Date: Tue, 25 Oct 88 18:22:33 MDTSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)To: David N Gray <Gray@DSG.csc.ti.com>Cc: sandra%defun@cs.ARPA (Sandra J Loosemore), "Dan L. Pierson" <pierson%mist@MULTIMAX.ENCORE.COM>, CL-Cleanup@SAIL.Stanford.eduIn-Reply-To: David N Gray <Gray@DSG.csc.ti.com>, Tue, 25 Oct 88  18:33:20 CDT> Date: Tue, 25 Oct 88  18:33:20 CDT> From: David N Gray <Gray@DSG.csc.ti.com>> > This proposal really does two things:> >  1. It eliminates the second argument of REQUIRE.>  2. It changes the meaning of calling REQUIRE with one argument from what>     CLtL says at the bottom of page 188.> > I agree with the first change.  I do not agree with the second change, and> there is nothing in the "rationale" to justify it.  All of the discussion> has been addressing the first change only.  Where did this second change> come from?The problem with calling REQUIRE without an argument, as it'scurrently defined, is that you have no guarantee that it will knowwhere to find the right files.  There is not much point in having thelanguage specify a standard mechanism like this, if there is noportable way to use it.  So, when the proposal says that thefile-loading feature of REQUIRE is nonportable, it's referring to boththe case where you give it an explicit pathname, and the case whereyou don't.My original proposal on this issue specified how REQUIRE should lookfor files to load, using a search list of pathnames to be merged withthe module name.  (Implementations could still use some othernonportable module registry mechanism if that failed to findanything.) For various reasons, this idea was discarded by the cleanupcommittee and for a time there was talk of flushing PROVIDE andREQUIRE entirely.  Just about anything would be better than thecurrent situation, and I really don't have any problems with thecurrent proposal other than the one nit I've already brought up. The variation between implementations on what they do to REQUIREwithout a pathname argument is ridiculous.  As you've already noted,the Explorer treats REQUIRE as a hook into DEFSYSTEM.  PCLS and HPCL-Iuse a search list similar to what I originally was proposing, probablybecause PSL had something similar.  VaxLisp (at least on VMS) uses alogical name for the directory containing the files.  KCL looks onlyin *DEFAULT-PATHNAME-DEFAULTS*, and I think that's what Lucid does too(their documentation doesn't say).-Sandra-------*start*01735 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 09:07:57 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 26 Oct 88  09:05:51 PDTReceived: by ti.com id AA08516; Wed, 26 Oct 88 11:04:39 CDTReceived: from Kelvin by tilde id AA12560; Wed, 26 Oct 88 10:47:28 CDTMessage-Id: <2802872949-4933586@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 26 Oct 88 10:49:09 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: sandra%defun@cs.utah.edu (Sandra J Loosemore)Cc: "Dan L. Pierson" <pierson%mist@MULTIMAX.ENCORE.COM>, CL-Cleanup@SAIL.Stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)In-Reply-To: Msg of Tue, 25 Oct 88 18:22:33 MDT from sandra%defun@cs.utah.edu (Sandra J Loosemore)> The variation between implementations on what they do to REQUIRE> without a pathname argument is ridiculous.  As you've already noted,> the Explorer treats REQUIRE as a hook into DEFSYSTEM.  PCLS and HPCL-I> use a search list similar to what I originally was proposing, probably> because PSL had something similar.  VaxLisp (at least on VMS) uses a> logical name for the directory containing the files.  KCL looks only> in *DEFAULT-PATHNAME-DEFAULTS*, and I think that's what Lucid does too> (their documentation doesn't say).Suppose we said that REQUIRE uses an implementation-defined registry ofmodule names and actions to be performed, if the implementation providessuch a feature, but that it does not try to guess what to do in theabsence of any kind of module definition.  I think that would permit whatI want to do, while ruling out surprising or unwanted behavior.*start*02541 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 19:12:48 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Oct 88  19:11:34 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 482703; Wed 26-Oct-88 22:11:12 EDTDate: Wed, 26 Oct 88 22:10 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)To: David N Gray <Gray@DSG.csc.ti.com>, Sandra J Loosemore <sandra%defun@cs.utah.edu>, Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Jon L White <jonl@lucid.com>, Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>, Gail Zacharias <gz@spt.entity.com>cc: Gail Zacharias <gz%spt.entity.com@MULTIMAX.ENCORE.COM>, David N Gray <Gray%DSG.csc.ti.com@MULTIMAX.ENCORE.COM>, Sandra J Loosemore <"sandra%defun@cs.utah.edu"@MULTIMAX.ENCORE.COM>, cl-cleanup%sail.stanford.edu@MULTIMAX.ENCORE.COM, CL-Cleanup@SAIL.Stanford.edu, sandra%defun%cs.utah.edu@MULTIMAX.ENCORE.COM, Bartley@MIPS.csc.ti.comIn-Reply-To: <2802872949-4933586@Kelvin>,             <8810260022.AA28990@defun.utah.edu>,             <2802814400-1415862@Kelvin>,             <8810252042.AA28871@defun.utah.edu>,             <2802727517-1153780@Kelvin>,             <881020154612.7.KMP@BOBOLINK.SCRC.Symbolics.COM>,             <8810182149.AA01791@bhopal>,             <8810181927.AA13501@mist.UUCP>,             <8810181351.AA19036@spt.entity.com>,             <8810181728.AA13169@mist.UUCP>,             <2802186955-10350987@Kelvin>,             <8810181613.AA13058@mist.UUCP>,             <8810181540.AA22872@defun.utah.edu>,             <8810172013.AA11848@mist.UUCP>Message-ID: <19881027021053.7.MOON@EUPHRATES.SCRC.Symbolics.COM>This whole discussion has strongly reinforced my belief that PROVIDE andREQUIRE are ill-conceived and should be removed from the language.  I alsofeel far too much of the limited remaining time has been spent on thistrivial issue.If PROVIDE and REQUIRE are really trying to be DEFSYSTEM, there is littlechance of converging on a concensus of what they should be within the nexttwo months.  On the other hand, if REQUIRE is nothing but a way to checkwhether a flag has been set, the language already contains global variablesand IF statements, so why duplicate a mechanism the user could implementfor himself?*start*01631 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 OCT 88 19:01:40 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 27 Oct 88  18:59:53 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01634g; Thu, 27 Oct 88 18:57:57 PDTReceived: by bhopal id AA12623g; Thu, 27 Oct 88 18:56:24 PDTDate: Thu, 27 Oct 88 18:56:24 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810280156.AA12623@bhopal>To: Gray@DSG.csc.ti.comCc: sandra%defun@cs.utah.edu, pierson%mist@MULTIMAX.ENCORE.COM, CL-Cleanup@SAIL.Stanford.eduIn-Reply-To: David N Gray's message of Wed, 26 Oct 88  10:49:09 CDT <2802872949-4933586@Kelvin>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)re: Suppose we said that REQUIRE uses an implementation-defined registry of    module names and actions to be performed, if the implementation provides    such a feature, . . . Well, that is more-or-less what CLtL says now for the case when the secondargument "is NIL ..." (CLtL, p188).  Since the force of this proposal is to retract any _standard_ way to hook REQUIRE into LOAD/DEFSYSTEM, then it would still be OK for an implementation to extend REQUIRE in an essentially upwards compatible way.  The point you are trying to make, if I read it right, is that previously this "essentially upwards compatible" way was applicable to forms like (REQUIRE <module>), but now would only be applicable to those like (REQUIRE <module> <more-stuff>).  How serious a problem is this change?-- JonL --*start*02079 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 OCT 88 09:08:16 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 28 Oct 88  09:06:39 PDTReceived: by ti.com id AA25541; Fri, 28 Oct 88 11:05:02 CDTReceived: from Kelvin by tilde id AA06817; Fri, 28 Oct 88 10:53:49 CDTMessage-Id: <2803046004-4897841@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 28 Oct 88 10:53:24 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Jon L White <jonl@lucid.com>Cc: sandra%defun@cs.utah.edu, pierson%mist@MULTIMAX.ENCORE.COM, CL-Cleanup@SAIL.Stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)In-Reply-To: Msg of Thu, 27 Oct 88 18:56:24 PDT from Jon L White <jonl@lucid.com>>   ... Since the force of this proposal is to > retract any _standard_ way to hook REQUIRE into LOAD/DEFSYSTEM, then it > would still be OK for an implementation to extend REQUIRE in an essentially > upwards compatible way. The current proposal says:  ... if the module is not present, REQUIRE signals a correctable error of  type REQUIRE-ERROR.According to the new error terminology, this seems to rule out anypossibility of an implementation extension.  An "implementation may beextended" clause would need to be added if the intent is to permitextensions.>    The point you are trying to make, if I read it > right, is that previously this "essentially upwards compatible" way was > applicable to forms like (REQUIRE <module>), but now would only be applicable > to those like (REQUIRE <module> <more-stuff>).My point is that the behavior for the one-argument case that was requiredby CLtL is now forbidden, and without an adequate reason.>  How serious a problem is this change?If REQUIRE cannot ever automatically cause the module to be loaded, then Ithink it is worthless.   I would rather see it dropped from the standard,leaving the description in CLtL as a common extension, than to have itsmeaning completely changed.  *start*01495 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 OCT 88 13:43:47 PDTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 28 Oct 88  13:41:40 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA03194; Fri, 28 Oct 88 16:40:26 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA25763; Fri, 28 Oct 88 16:44:21 EDTMessage-Id: <8810282044.AA25763@mist.UUCP>To: David N Gray <Gray%DSG.csc.ti.com@MULTIMAX.ENCORE.COM>Cc: CL-Cleanup%SAIL.Stanford.edu@MULTIMAX.ENCORE.COMSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Your message of Fri, 28 Oct 88 10:53:24 -0500.Date: Fri, 28 Oct 88 16:44:18 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>It seems to me that several implementors have serious problems withthe proposed restriction that gives REQUIRE a portable meaning.  I putthe restriction in there because without it I feel that REQUIREcontributes much more to non-portability than portability.Given these objections I now think that the best (least bad?) optionis to admit that PROVIDE and REQUIRE supply only trivial portablefunctionality and remove them from the language.  This will require noimplementations to change but will clearly indicate to users thatthese constructs are not useful in portable code.Can we decide to do this now and move on to more important topics?*start*01445 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 OCT 88 13:59:31 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Oct 88  13:58:17 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 483904; Fri 28-Oct-88 16:55:09 EDTDate: Fri, 28 Oct 88 16:54 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) To: pierson%mist@MULTIMAX.ENCORE.COMcc: Gray@DSG.CSC.TI.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8810282044.AA25763@mist.UUCP>Message-ID: <881028165459.3.KMP@BOBOLINK.SCRC.Symbolics.COM>    Date: Fri, 28 Oct 88 16:44:18 EDT    From: Dan L. Pierson <pierson%mist@multimax.ARPA>    ... I feel that REQUIRE contributes much more to non-portability    than portability. ... Given these objections I now think that the    best (least bad?) option is to admit that PROVIDE and REQUIRE    supply only trivial portable functionality and remove them from    the language.  This will require no implementations to change    but will clearly indicate to users that these constructs are not    useful in portable code.Excellent analysis.    Can we decide to do this now and move on to more important topics?Great idea.*start*00986 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 OCT 88 14:05:03 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 28 Oct 88  14:03:16 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 28 Oct 88 16:59:29 EDTTo: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-reply-to: Your message of Fri, 28 Oct 88 16:44:18 -0400.             <8810282044.AA25763@mist.UUCP> Date: Fri, 28 Oct 88 16:59:10 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUI favor flushing PROVIDE and REQUIRE from the standard.  Maybe somedaywe'll figure out what we really want instead, but not in this round ofdiscussion.  I'm now pretty sure that "the right thing" will look nothinglike the current PROVIDE and REQUIRE mechanisms, and that nothing is to begained by tightening them up slightly.-- Scott*start*03927 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 31 OCT 88 10:00:55 PSTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 31 Oct 88  09:57:25 PSTReceived:  by multimax.ARPA (5.51/25-eef)	id AA29649; Mon, 31 Oct 88 12:56:21 ESTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA28263; Mon, 31 Oct 88 13:00:15 ESTMessage-Id: <8810311800.AA28263@mist.UUCP>To: cl-cleanup%sail.stanford.edu@MULTIMAX.ENCORE.COMSubject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 4)Date: Mon, 31 Oct 88 13:00:12 ESTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>Here's the reversal.  The Current Practice section is intentionallyabstracted because the proposed change is incompatible with everyone.Issue:         REQUIRE-PATHNAME-DEFAULTSReferences:    *MODULES*, PROVIDE, REQUIRE, pp 188-191               LOAD, pp 426-427Category:      CHANGEEdit history:  Version 1 by Pierson 9/13/88               Version 2 by Pierson 9/19/88, change PROVIDE stuff per comments               Version 3 by Pierson 10/17/88, remove PROVIDE locaction specs.	       Version 4 by Pierson 10/31/88, remove from languageStatus:        For Internal DiscussionProblem description:PROVIDE and REQUIRE are a dual-purpose pair of functions that attemptto provide multi-file Common Lisp programs with a single mechanism todetect and correct incorrect load sequences.  These functions werealso designed to be used for general file inclusion in Common Lisp.Unfortunately, the file loading feature of REQUIRE is specified suchthat it is inherently non-portable and environment dependent.Proposal (REQUIRE-PATHNAME-DEFAULTS:ELIMINATE):Remove PROVIDE and REQUIRE from the Common Lisp standard.Test Cases/Examples:(PROVIDE 'fft)Would not be Common Lisp.(REQUIRE 'fft)Would not be Common Lisp.Rationale:The file loading feature of REQUIRE is non-portable.  The remainingfunctionality of PROVIDE and REQUIRE (pushing and testing *MODULES*)can easily be implemented by user code.  Since some implementationswill retain the automatic module loading features of REQUIRE and somewon't, use of REQUIRE will almost always make code less portable.Current practice:All implementations currently support some sort of file loading viaREQUIRE.  In general, the Lisp Machine implementations use the secondargument to invoke the system module building/loading facility whilethe Unix implementations simply try to load a file in the currentdirectory.Cost to Implementors:Implementations will have to move PROVIDE and REQUIRE to their package forimplementation extensions and change their documentation to indicatethat PROVIDE and REQUIRE are non-standard.  This is a fairly small change.Cost to Users:Any (non-portable) user programs that rely on PROVIDE and REQUIRE mayhave to change.  Since most implementations will probably keep thesefunctions as extensions to Common Lisp, this change will probably onlybe required by user programs that wish to be portable.  Since thecurrent behavior is decidedly non-portable, these programs wouldprobably have to change anyway.Cost of non-Adoption:PROVIDE and REQUIRE will continue as impediments to portability.Benefits:The non-portability of PROVIDE and REQUIRE will be made obvious.Aesthetics:This simplifies the language by removing an environment-dependentfeature. Discussion:Pierson, Pitman, Fahlman, and Gregor support this proposal.The cleanup committee tried to come up with a proposal to restrictPROVIDE and REQUIRE to the portable subset of their functionality.This failed because several implementors objected that it compelledthem to significantly reduce the functionality they provided users inorder to create a trivial feature which any user could easily writefor herself.*start*02050 00024 US Return-Path: <Gray@DSG.csc.ti.com>Received: from ti.com ([10.7.0.46]) by Xerox.COM ; 01 NOV 88 15:42:45 PSTReceived: by ti.com id AA29001; Tue, 1 Nov 88 17:41:53 CSTReceived: from Kelvin by tilde id AA20735; Tue, 1 Nov 88 16:22:38 CSTMessage-Id: <2803415069-6078218@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Tue, 1 Nov 88 16:24:29 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "Dan L. Pierson" <pierson%mist@MULTIMAX.ENCORE.COM>Cc: masinter.paSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 4)In-Reply-To: Msg of Mon, 31 Oct 88 13:00:12 EST from "Dan L. Pierson" <pierson%mist@MULTIMAX.ENCORE.COM>> Rationale:> > The file loading feature of REQUIRE is non-portable.  The remaining> functionality of PROVIDE and REQUIRE (pushing and testing *MODULES*)> can easily be implemented by user code.  Since some implementations> will retain the automatic module loading features of REQUIRE and some> won't, use of REQUIRE will almost always make code less portable.It bothers me that the discussion still does not make a distinctionbetween the one-argument REQUIRE and the two-argument REQUIRE.  Thereare different considerations that apply to each.> Current practice:> > All implementations currently support some sort of file loading via> REQUIRE.  In general, the Lisp Machine implementations use the second> argument to invoke the system module building/loading facilityThat's not correct; the _first_ argument is used as the argument toMAKE-SYSTEM if there isn't any second argument.> The cleanup committee tried to come up with a proposal to restrict> PROVIDE and REQUIRE to the portable subset of their functionality.> This failed because several implementors objected that it compelled> them to significantly reduce the functionality they provided users in> order to create a trivial feature which any user could easily write> for herself.I think it failed because people felt it was not worth furtherdiscussion, not because no acceptable portable definition could befound.*start*02241 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 NOV 88 23:33:03 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 1 Nov 88  23:31:33 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00254g; Tue, 1 Nov 88 23:29:45 PSTReceived: by bhopal id AA11190g; Tue, 1 Nov 88 23:28:11 PSTDate: Tue, 1 Nov 88 23:28:11 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811020728.AA11190@bhopal>To: Gray@DSG.csc.ti.comCc: sandra%defun@cs.utah.edu, pierson%mist@MULTIMAX.ENCORE.COM, CL-Cleanup@SAIL.Stanford.eduIn-Reply-To: David N Gray's message of Fri, 28 Oct 88  10:53:24 CDT <2803046004-4897841@Kelvin>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)re: >   ... Since the force of this proposal is to     > retract any _standard_ way to hook REQUIRE into LOAD/DEFSYSTEM, then it     > would still be OK for an implementation to extend REQUIRE in an     > essentially upwards compatible way.     . . .     According to the new error terminology, this seems to rule out any    possibility of an implementation extension.  An "implementation may be    extended" clause would need to be added if the intent is to permit    extensions.Read on!re: My point is that the behavior for the one-argument case that was required    by CLtL is now forbidden, and without an adequate reason.But the two-argument case is the one in which I suggested that animplementation can extend in an "upward-compatible" way.  That is,the vendor's extension is upward-compatible with the portable definitionproviding he achieves the "old" behaviour by doing (REQUIRE <file> NIL).re: If REQUIRE cannot ever automatically cause the module to be loaded, then I    think it is worthless.   The problem is that the specification of how to do this can only be animplementation-dependent extension.  Unless someone solves theuniversal file name problem.   But removing them totally from thelanguage is much worse since that even breaks the code of those whouse PROVIDE/REQUIRE as a standardized "handshaking" signal (i.e.without the interdependence to defsystem).-- JonL --*start*01802 00024 US Return-Path: <@multimax.ARPA:pierson%mist@multimax.ARPA>Received: from multimax.ARPA ([192.5.63.14]) by Xerox.COM ; 01 NOV 88 16:28:10 PSTReceived:  by multimax.ARPA (5.51/25-eef)	id AA00544; Tue, 1 Nov 88 19:27:21 ESTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA01032; Tue, 1 Nov 88 19:31:17 ESTMessage-Id: <8811020031.AA01032@mist.UUCP>To: David N Gray <Gray%DSG.csc.ti.com@MULTIMAX.ENCORE.COM>Cc: masinter.pa%Xerox.COM@MULTIMAX.ENCORE.COMSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 4) In-Reply-To: Your message of Tue, 01 Nov 88 16:24:29 -0600.             <2803415069-6078218@Kelvin> Date: Tue, 01 Nov 88 19:31:13 ESTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>I'll come out with a new version addressing your points, but:    It bothers me that the discussion still does not make a distinction    between the one-argument REQUIRE and the two-argument REQUIRE.  There    are different considerations that apply to each.    OK, you're right.  It's loading with the one-argument REQUIRE that'sinherenly non-portable.  The two-argument version is portable iff youbelieve that pathnames are portable.    > Current practice:    >     > All implementations currently support some sort of file loading via    > REQUIRE.  In general, the Lisp Machine implementations use the second    > argument to invoke the system module building/loading facility        That's not correct; the _first_ argument is used as the argument to    MAKE-SYSTEM if there isn't any second argument.    Sorry, I'll fix this.    I think it failed because people felt it was not worth further    discussion, not because no acceptable portable definition could be    found.I'm not convinced.  Maybe you'd like to supply an existence proof?*start*00890 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 OCT 88 13:40:02 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Oct 88  13:37:59 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 30 OCT 88 13:37:20 PSTDate: Sun, 30 Oct 88 13:37 PSTFrom: Gregor.paSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) To: Scott.Fahlman@B.GP.CS.CMU.EDUcc: CL-Cleanup@sail.stanford.eduFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: The message of 28 Oct 88 13:59 PDT from Scott.Fahlman@B.GP.CS.CMU.EDUMessage-ID: <19881030213708.9.GREGOR@PORTNOY.parc.xerox.com>Line-fold: no    Date: Fri, 28 Oct 88 16:59:10 EDT    From: Scott.Fahlman@B.GP.CS.CMU.EDU    I favor flushing PROVIDE and REQUIRE from the standard.  I agree.-------*start*02912 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 NOV 88 16:15:26 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 2 Nov 88  16:11:32 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00923g; Wed, 2 Nov 88 16:09:56 PSTReceived: by bhopal id AA17334g; Wed, 2 Nov 88 16:08:31 PSTDate: Wed, 2 Nov 88 16:08:31 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811030008.AA17334@bhopal>To: Gray@DSG.csc.ti.comCc: pierson%mist@MULTIMAX.ENCORE.COM, cl-cleanup@sail.stanford.eduIn-Reply-To: David N Gray's message of Wed, 2 Nov 88  15:17:04 CST <2803497424-11026245@Kelvin>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)re: [implementationd-dependent extension] ...    Similarly, (REQUIRE "FOO") should be defined as a standard way    to invoke whatever module loading feature the implementation provides.    You don't have to standardize how it is done in order to standardize how    to ask it to be done.Hey, I'll buy that.  This permits backwards compatibility for thoseimplementations that hook REQUIRE into their vendor-specific defsystem,while at the same time permits those that don't have it to get the"safety-net" feature.  I.e., the "hook" is merely a cerror call.This still isn't going back on any part of the proposal that flushesthe second argument.  Dan: would it be acceptable to you to alter the proposal and say that the action when the module isn't present is extendible by invoking anyimplementation-specific "hooks"?I still think (version 3) is an acceptable proposal -- especially after being emmended as above -- without superseding it with (version 4).  It is the least disturbance to the status quo that retracts the non-portabilityparts.  Since there are many user's that do use the "safety-net" --and do so in a portable way, I can't see flushing it simply in order tocontinue the non-portable, non-standard usages.  I liked Larry's rationalefor it:    Date: 18 Oct 88 14:13 PDT    From: masinter.pa@Xerox.COM    Subject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)     In-Reply-To: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>'s message of     Tue, 18 Oct 88 15:27:25 EDT    The thing that distinguishes PROVIDE and REQUIRE from their obvious    implementations is that they have declarative rather than operative    semantics. Program walkers, DEFSYSTEM constructors as well as compilers    might be expected to pay special heed to PROVIDE and REQUIRE, but not pay    any special heed to direct manipulation of *MODULES*.    We should be careful in the standard to distinguish between what things    mean and how they may be implemented, but doubly so in the case of macros    and special forms that may get processed at times other than EVAL-time.-- JonL --*start*02958 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 NOV 88 14:04:34 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 9 Nov 88  14:02:45 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA06580; Wed, 9 Nov 88 17:00:37 ESTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA11136; Wed, 9 Nov 88 17:04:32 ESTMessage-Id: <8811092204.AA11136@mist.UUCP>To: cl-cleanup%sail.stanford.edu@multimax.encore.comCc: Jon L White <jonl%LUCID.COM@multimax.encore.com>, "sandra%defun@CS.UTAH.EDU"@multimax.encore.comSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Your message of Wed, 02 Nov 88 15:17:04 -0600.             <2803497424-11026245@Kelvin> Date: Wed, 09 Nov 88 17:04:28 ESTFrom: Dan L. Pierson <pierson@mist.ARPA>    Date: Wed, 2 Nov 88  15:17:04 CST    From: David N Gray <Gray@DSG.csc.ti.com>    Consider the function ED.  It is a standard way to invoke an editor; the    ED function is specified without having to define a standard editor; the    function is simply a way to invoke whatever editor the implementation    provides.  Similarly, (REQUIRE "FOO") should be defined as a standard way    to invoke whatever module loading feature the implementation provides.    You don't have to standardize how it is done in order to standardize how    to ask it to be done.There is a major difference between ED and REQUIRE in this respect.ED is an environmental feature which is very unlikely to be used by aprogram (i.e. while a program may well call ED to put the user in theeditor, it is very unlikely that a program will call ED, then try totalk to the editor itself).REQUIRE is intended to be built into programs.  A non-loading REQUIREcan be used as a portable safety net per JonL's comments.  A loadingREQUIRE is a very powerful (and valuable) file inclusion directive.Most users of the implementation will come to depend on REQUIRE toload files in multi-file applications.  This will tend to cause anyprogram from an implementation with a loading REQUIRE to fail to portto non-loading implementations.  The triviality of the porting bugswill be inversely proportional to the sophistication of theimplementation's REQUIRE.In summary I claim that a loading REQUIRE has two unacceptable traits: - People will use and depend on the loading feature. - This will make REQUIRE an obstacle to portable code.Therefore, I oppose any proposal that allows REQUIRE to load files.If we're going to make the feature non-portable we should remove itfrom the portable language so that users of powerful implementationswill not be unnecessarily misled by the standard.  However, if thepeople in this committee feel that we should vote on all threealternatives (ELIMINATE, DECLARATIVE, and STATUS-QUO), I'll write themall up.*start*02927 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 09:52:52 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 10 Nov 88  09:51:16 PSTReceived: by ti.com id AA20395; Thu, 10 Nov 88 11:50:23 CSTReceived: from Kelvin by tilde id AA13118; Thu, 10 Nov 88 11:35:01 CSTMessage-Id: <2804175396-3579026@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Thu, 10 Nov 88 11:36:36 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "Dan L. Pierson" <pierson%mist@MULTIMAX.ENCORE.COM>Cc: cl-cleanup@sail.stanford.edu, Jon L White <jonl@LUCID.COM>, sandra%defun@CS.UTAH.EDU, Bartley@MIPS.csc.ti.comSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Msg of Wed, 09 Nov 88 17:04:28 EST from "Dan L. Pierson" <pierson@mist>> In summary I claim that a loading REQUIRE has two unacceptable traits:>  - People will use and depend on the loading feature.>  - This will make REQUIRE an obstacle to portable code.That would seem to me to be an argument for making file loading arequired part of the functionality.  It is trivial to define a way toassociate a module name with a list of file names to be loaded; therereally isn't any reason why every implementation couldn't have a way todo that.  The hard part about defining a file-loading utility is to haveit compile files that need to be compiled and to do the compiling andloading in the right order, but it is quite sufficient for REQUIRE tojust load previously compiled files.  As an existence proof I offer thefollowing portable implementation of REQUIRE.  The call to DEFINE-MODULEis necessarily implementation dependent because of pathname syntax anddirectory usage, but re-doing it or its equivalent for eachimplementation ported to would not be a big problem.(DEFVAR *MODULES* NIL "List of modules marked present with PROVIDE.") (DEFUN PROVIDE (MODULE)  "Mark MODULE as being already loaded."  (PUSHNEW (STRING MODULE) *MODULES* :TEST #'STRING=)  (VALUES))(DEFVAR *MODULE-HASH-TABLE* (MAKE-HASH-TABLE :TEST #'EQUAL))(DEFUN DEFINE-MODULE (NAME &REST FILE-NAMES)  "Specify which files REQUIRE should load for module NAME."  (SETF (GETHASH (STRING NAME) *MODULE-HASH-TABLE*)	(MAPCAR #'MERGE-PATHNAMES FILE-NAMES))  NAME)(DEFUN REQUIRE (MODULE)  "Ensure that MODULE is loaded."  (LET ((NAME (STRING MODULE)))    (LOOP      (IF (MEMBER NAME *MODULES* :TEST #'STRING=)	  (RETURN)	(LET ((FILES (GETHASH NAME *MODULE-HASH-TABLE* NIL)))	  (IF (NULL FILES)	      (CERROR "Re-try the REQUIRE call after manually loading the module."		      "Required module ~S is neither loaded nor defined." NAME)	    (LET ((MODULES *MODULES*))	      (UNWIND-PROTECT		  (PROGN (MAPC #'LOAD FILES)			 (PROVIDE NAME)			 (SETQ MODULES *MODULES*))		(SETQ *MODULES* MODULES))	      (RETURN)))))))  (VALUES))*start*02406 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 NOV 88 12:57:44 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 10 Nov 88  12:56:11 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03569g; Thu, 10 Nov 88 12:54:13 PSTReceived: by bhopal id AA06593g; Thu, 10 Nov 88 12:52:54 PSTDate: Thu, 10 Nov 88 12:52:54 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811102052.AA06593@bhopal>O: Gray@DSG.csc.ti.com, Cc: pierson%mist@MULTIMAX.ENCORE.COM, cl-cleanup@sail.stanford.edu, sandra%defun@CS.UTAH.EDU, Bartley@MIPS.csc.ti.comIn-Reply-To: David N Gray's message of Thu, 10 Nov 88  11:36:36 CST <2804175396-3579026@Kelvin>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) I think we are very close to agreement here, providing we can stayclear of the deeply controversial areas.  Dan objects to having non-portable features be a required part of the standard; and you(Dave) object to having no reference to the implementation-dependent way in which file-loading can be accomplished to "provide" a module.How about a compromise along the lines I suggested on Nov 2?  First,say that implementations may extend REQUIRE to hook into animplementation-specific module loading system; but Second say thatany such extension should provide a means of disabling it.  That way,one can check-out portable, pure "safety-net" applications by turning off the defsystem hook-in [the turning off would be in an implementationspecific way, but that should be fine.]-- JonL --P.S.: Your example DEFINE-MODULE is slanted towards a simple loading      scheme, and certainly could be useful as it stands.  However, I       would prefer to see the notion of module "provision" a bit more       abstract.  In particular, the error strings to CERROR could be like:       "Require'd module ~S is not present."      rather than:       "Required module ~S is neither loaded nor defined."      and the continuation string culd be more like:       "Re-try the REQUIRE call [after perhaps manually providing the module]"      rather than:       "Re-try the REQUIRE call after manually loading the module."      Still, it must be admitted that we are not at all close to specifying      a standard for defsystem-like facilities.*start*01171 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 09:07:55 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 11 Nov 88  08:21:08 PSTReceived: by ti.com id AA28512; Fri, 11 Nov 88 10:20:08 CSTReceived: from Kelvin by tilde id AA10441; Fri, 11 Nov 88 10:15:34 CSTMessage-Id: <2804257054-8485159@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Fri, 11 Nov 88 10:17:34 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: Jon L White <jonl@LUCID.COM>Cc: pierson%mist@MULTIMAX.ENCORE.COM, cl-cleanup@SAIL.STANFORD.EDU, sandra%defun@CS.UTAH.EDU, Bartley@mips.csc.ti.comSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Msg of Thu, 10 Nov 88 12:52:54 PST from Jon L White <jonl@LUCID.COM>> How about a compromise along the lines I suggested on Nov 2?  First,> say that implementations may extend REQUIRE to hook into an> implementation-specific module loading system; but Second say that> any such extension should provide a means of disabling it.If that makes you feel better about it, that's fine with me.*start*03860 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 10:47:50 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 11 Nov 88  10:36:36 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA24737; Fri, 11 Nov 88 13:32:20 ESTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA01642; Fri, 11 Nov 88 13:36:14 ESTMessage-Id: <8811111836.AA01642@mist.UUCP>To: "sandra%defun@cs.utah.edu"@multimax.encore.com (Sandra J Loosemore)Cc: cl-cleanup%SAIL.STANFORD.EDU@multimax.encore.com, Bartley%mips.csc.ti.com@multimax.encore.comSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Your message of Fri, 11 Nov 88 09:35:42 -0700.             <8811111635.AA00216@defun.utah.edu> Date: Fri, 11 Nov 88 13:36:13 ESTFrom: Dan L. Pierson <pierson@mist.ARPA>    How about wording the proposal to indicate that implementations    can extend REQUIRE to load files automagically only if the user has    *explicitly* indicated (using some implementation-specific mechanism)    which files make up that module?        That would allow             (defsystem foo ....)        (require "FOO")        to work, but would prevent            (require "FOO")        from trying to load some random file named "FOO", which (as I've pointed    out earlier), may or may not contain the module "FOO".    I'm still trying to think of an acceptable compromise based on JonL'sidea.  Unfortunately, this is a perfect example of what I can't acceptfor the following reason:Let's assume that the DEFSYSTEM's and REQUIRE's are part of a large,real, potentially portable application.  Say 50 files in fourdirectories.  Somewhere in that complexity is one (or maybe four)files containing one or more invocations of DEFSYSTEM.  Almost everyone of the 50 or so files contains at least one REQUIRE.  Since thesystem was developed in an environment where all of this works, thefiles with DEFSYSTEM are correctly loaded first thus causing all theREQUIRE's to load files iff needed.Let's further assume that all the rest of the code in the applicationis portable because the author wanted to write a portable applicationand was careful about it.OK, now it's time to port it all.  Load up a portable DEFSYSTEM (wecarefully used a simple subset of the fancy native DEFSYSTEM) and loadand compile the rest.  Pity it didn't work because none of theREQUIRE's did their normal loading functions in the new Common Lispimplementation.  Pity it's a pain to debug because all the crossreferences are implicit in this maze of REQUIRE's that _used_ to work.It really would have been much easier if the author had simply avoidedREQUIRE and represented all the dependencies in a DEFSYSTEM file thatshe knew was non-portable.  There's also the question: "if theimplementation had a DEFSYSTEM, why did she need to use REQUIRE toload files?"Once again, if you allow REQUIRE to load files it isn't portable andcode written in implementations that support it will be harder toport (I haven't thought enough about the possible problems of goingfrom a non-loading implementation to a loading implementation).If the feature isn't portable, why keep it in the language?  Animplementation can still support whatever version of REQUIRE it wantsas an extension to Common Lisp but: 1. Users won't be fooled into believing it's a portable construct. 2. Static portablility checks will be required to warn about it.Almost the only compromise I can think of is something that forces youto declare the non-portable loading intent in every use of REQUIRE, say: (REQUIRE "foo" :LOAD T)It would be useful to hear from someone other than the 3-4 of us whokeep arguing this one.*start*01294 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 12:30:18 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 11 Nov 88  12:28:36 PSTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 11 Nov 88 15:27:21 ESTTo: cl-cleanup@sail.stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-reply-to: Your message of Fri, 11 Nov 88 13:36:13 -0500.             <8811111836.AA01642@mist.UUCP> Date: Fri, 11 Nov 88 15:27:15 ESTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU    Almost the only compromise I can think of is something that forces you    to declare the non-portable loading intent in every use of REQUIRE, say:     (REQUIRE "foo" :LOAD T)        It would be useful to hear from someone other than the 3-4 of us who    keep arguing this one.    OK.  I still think that the only reasonable course is to flush PROVIDE andREQUIRE from the standard.  The discussions among those of you trying topatch it up have only reinforced this view.  It didn't seem useful to keepasserting this periodically, but that is my position until you hearotherwise.  I suspect that many others share this view.-- Scott*start*02431 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 13:40:38 PSTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 11 Nov 88  13:39:04 PSTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA20009@EDDIE.MIT.EDU>; Fri, 11 Nov 88 16:36:51 ESTReceived: by spt.entity.com (smail2.5); 11 Nov 88 14:29:22 EST (Fri)To: sandra%defun@cs.utah.eduCc: Gray@DSG.csc.ti.com, jonl@LUCID.COM, pierson%mist@MULTIMAX.ENCORE.COM, cl-cleanup@SAIL.STANFORD.EDU, Bartley@mips.csc.ti.comIn-Reply-To: Sandra J Loosemore's message of Fri, 11 Nov 88 09:35:42 MST <8811111635.AA00216@defun.utah.edu>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) Message-Id: <8811111429.AA25742@spt.entity.com>Date: 11 Nov 88 14:29:22 EST (Fri)From: gz@spt.entity.com (Gail Zacharias)   From: sandra%defun@cs.utah.edu (Sandra J Loosemore)   Date: Fri, 11 Nov 88 09:35:42 MST   How about wording the proposal to indicate that implementations   can extend REQUIRE to load files automagically only if the user has   *explicitly* indicated (using some implementation-specific mechanism)   which files make up that module?Hey, I've got an idea!  How about	 (REQUIRE module list-of-files-which-make-up-the-module) ?But seriously, I'm not sure what "explicitly" means.  The user has to evaluatesome Lisp expression involving the module name?  What if the underlyingoperating system provides some similar concept, is the Lisp allowed to use itor would it still have to force the user to retype it in the Lisp?  How abouta search-path-based mechanims: is it ok if the user evaluates some Lispexpression specifying a search path but not mentioning the module nameexplicitly?  How about a default search path?  Is that allowed, or must itstart out empty regardless of local cultural conventions?  What aboutvendor-provided modules?  Can we continue to tell our users to say (require'quickdraw) and have that work in the off-the-shelf product, or would theyhave to take some additional explicit action to allow this to work?    but would prevent       (require "FOO")   from trying to load some random file named "FOO", which (as I've pointed   out earlier), may or may not contain the module "FOO".How about (REQUIRE "FOO" :if-not-present :error)?  Only half-kidding...*start*02487 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 14:22:36 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 11 Nov 88  14:20:45 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA02482; Fri, 11 Nov 88 17:18:01 ESTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA02053; Fri, 11 Nov 88 17:21:56 ESTMessage-Id: <8811112221.AA02053@mist.UUCP>To: gz%spt.entity.com@multimax.encore.com (Gail Zacharias)Cc: cl-cleanup%SAIL.STANFORD.EDU@multimax.encore.com, Bartley%mips.csc.ti.com@Multimax.encore.comSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Your message of Fri, 11 Nov 88 14:29:22 -0500.             <8811111429.AA25742@spt.entity.com> Date: Fri, 11 Nov 88 17:21:53 ESTFrom: Dan L. Pierson <pierson@mist.ARPA>    But seriously, I'm not sure what "explicitly" means.  The user has    to evaluate some Lisp expression involving the module name?  What    if the underlying operating system provides some similar concept,    is the Lisp allowed to use it or would it still have to force the    user to retype it in the Lisp?  How about a search-path-based    mechanims: is it ok if the user evaluates some Lisp expression    specifying a search path but not mentioning the module name    explicitly?  How about a default search path?  Is that allowed, or    must it start out empty regardless of local cultural conventions?This is a good examples of why most of us gave up on a portableREQUIRE that loads files.    What about vendor-provided modules?  Can we continue to tell our    users to say (require 'quickdraw) and have that work in the    off-the-shelf product, or would they have to take some additional    explicit action to allow this to work?    If REQUIRE is removed from the standard language you can continue toprovide it as an implementation extension and tell your users anythingyou want.  This would seem to be ideal for your example: "quickdraw"sounds like an archtypical non-portable vendor provided module.  IfI'm going to use it, I don't care that the construct which obtains itis non-standard.  (As I understand the status of other proposals, yourREQUIRE would have to be in a package other than LISP, but since thedefault user package could use your extensions package, there would beno visible change for most users.)*start*01735 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 15:19:24 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 11 Nov 88  14:30:57 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.1-cs)	id AA10201; Fri, 11 Nov 88 15:23:58 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA00501; Fri, 11 Nov 88 15:22:48 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8811112222.AA00501@defun.utah.edu>Date: Fri, 11 Nov 88 15:22:46 MSTSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) To: gz@spt.entity.com (Gail Zacharias)Cc: sandra%defun@cs.utah.edu, Gray@DSG.csc.ti.com, jonl@LUCID.COM, pierson%mist@MULTIMAX.ENCORE.COM, cl-cleanup@SAIL.STANFORD.EDU, Bartley@mips.csc.ti.comIn-Reply-To: gz@spt.entity.com (Gail Zacharias), 11 Nov 88 14:29:22 EST (Fri)Sigh, I really don't like the idea of having REQUIRE load things, butI thought there was a compromise being reached here.  It appears thatisn't the case after all.To summarize my position on this issue, the current definition ofREQUIRE is broken due to the way it tries to load files withoutproviding the user with any portable way to say which files should beloaded.  (Passing a pathname as the second argument is not portable.)It doesn't appear that we will be able to come up with aDEFSYSTEM-like utility for specifying what files correspond with whichmodules in the near future.  Therefore, I think the best solutionwould be to either remove REQUIRE entirely, or just to get rid of itsfile-loading behavior, whichever is the most acceptible to everybody else.-Sandra-------*start*00996 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 18:13:18 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Nov 88  18:10:50 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 11 NOV 88 17:59:14 PSTDate: Fri, 11 Nov 88 17:59 PSTFrom: Gregor.paSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) To: Scott.Fahlman@B.GP.CS.CMU.EDUcc: cl-cleanup@sail.stanford.eduFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: The message of 11 Nov 88 12:27 PST from Scott.Fahlman@B.GP.CS.CMU.EDUMessage-ID: <19881112015907.4.GREGOR@PORTNOY.parc.xerox.com>Line-fold: noI too would still like to see REQUIRE and PROVIDE removed from thelanguage.  In my experience with PCL, they have never proved useful.Worse, the fact that some people thought they were useful and keptinsisiting that I should use them has been annoying.-------*start*04365 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 NOV 88 18:34:39 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 13 Nov 88  18:33:06 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA05643g; Sun, 13 Nov 88 18:02:39 PSTReceived: by bhopal id AA19970g; Sun, 13 Nov 88 18:01:22 PSTDate: Sun, 13 Nov 88 18:01:22 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811140201.AA19970@bhopal>To: pierson@mist.encore.COMCc: sandra%defun@cs.utah.edu, cl-cleanup@SAIL.STANFORD.EDU, Bartley@mips.csc.ti.comIn-Reply-To: Dan L. Pierson's message of Fri, 11 Nov 88 13:36:13 EST <8811111836.AA01642@mist.UUCP>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) re: Once again, if you allow REQUIRE to load files it isn't portable and    code written in implementations that support it will be harder to    port (I haven't thought enough about the possible problems of going    from a non-loading implementation to a loading implementation).    If the feature isn't portable, why keep it in the language?  ...Sorry to have to "chime in" again, but this goes to the crux of thematter.  [Anyway, I think it's likely that only the four of us aredeeply concerned about the issue, and that if we can come to someagreement amongst ourselves, then that will carry much weight withthe committee as a whole.  If the four us can't agree by deadlinetime, then it's surely hopeless.]David (Gray) suggested not that the standard allow REQUIRE to "loadfiles", but that an allowable extension be the interface to animplementation-specific "defsystem", if one is available.  Thus he wants to reserve space for an interface, which in some implementations will just be an interface to the null feature!  A programmer who comes to depend on a given vendor's defsystem has a porting problem completelyindependent of whether or not that vendor also made a non-portableextension to REQUIRE.  [by the way, I use "DEFSYSTEM" to refer to thisinterface, despite the fact that an entry from REQUIRE probably calls"MAKE-SYSTEM; it's just that MAKE-SYSTEM is usuless without DEFSYSTEM.]The advantage of this is that ***if*** one ports his code to a systemwith a compatible defsystem, or ***if*** he ports his system specificationfirst, then the module-name interface in the one-argument version ofREQUIRE doesn't need any further porting.On the other hand a truly _portable_ program must disable any defsystemhooks.  I don't particularly mind if such disablement isn't standardized;it all "comes with the territory" when you buy the big hamburger from a Lisp vendor.  Namely, the portable program writer has to figure out how toconfigure his "hamburger" to have only the standardized, portable features,in order to certify his work as portable.  And as we all agree, the only portable part of REQUIRE is the "safety net" part -- not the incestuous hook-in.  Remember FIXNUM-NON-PORTABLE!Thus I'd rather add a new special-variable parameter with values T orNIL than to force the step of backwards incompatibility on the currentREQUIRE users.  Many of these users are quite happy to see their(REQUIRE "foo") simply load the file "foo" from the connected directory.Forcing these people to go back and change all their code WHICH THEYWOULD NEVER BE PORTING ANYWAY is not a guaranteed way to win friends andinfluence people favorably towards this proposal.Still, I don't see the situation as all that bad, because there really aren't that many programs around that are intended to be fully portable. [Of course, the coder of such ported programs may suffer complaints fromend-users who notice that he didn't hook into their own defsystem; butwe can at least take REQUIRE off this particular hot-seat.]  In fact, most Lisp users run on precisely one vendor's system, and could care less about full portability.  As some have suggested, what CL gives us is "portability of programmers" more than portability of particularprograms.The "compromise", as I see it, is aimed a retaining a useful portablemeaning for REQUIRE, but not breaking existing code.  That is why wehave to say something about allowable, implementation-specific extensions, and how to disable them.-- JonL --*start*01709 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 09:38:47 PSTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 11 Nov 88  09:37:14 PSTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.1-cs)	id AA01669; Fri, 11 Nov 88 10:35:43 MSTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA00216; Fri, 11 Nov 88 09:35:43 MSTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8811111635.AA00216@defun.utah.edu>Date: Fri, 11 Nov 88 09:35:42 MSTSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) To: David N Gray <Gray@DSG.csc.ti.com>Cc: Jon L White <jonl@LUCID.COM>, pierson%mist@MULTIMAX.ENCORE.COM, cl-cleanup@SAIL.STANFORD.EDU, sandra%defun@cs.utah.edu, Bartley@mips.csc.ti.comIn-Reply-To: David N Gray <Gray@DSG.csc.ti.com>, Fri, 11 Nov 88  10:17:34 CSTAllowing REQUIRE to load files as an extension seems like a lousy ideato me for the same reason that I gave against having modules magicallyPROVIDE themselves -- namely, it might assume a file/modulecorrespondence other than what the user intended, and load the wrongfile. How about wording the proposal to indicate that implementationscan extend REQUIRE to load files automagically only if the user has*explicitly* indicated (using some implementation-specific mechanism)which files make up that module?That would allow     (defsystem foo ....)    (require "FOO")to work, but would prevent    (require "FOO")from trying to load some random file named "FOO", which (as I've pointedout earlier), may or may not contain the module "FOO".-Sandra-------*start*01423 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 NOV 88 17:25:39 PSTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 11 Nov 88  17:23:18 PSTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA23644@EDDIE.MIT.EDU>; Fri, 11 Nov 88 20:22:36 ESTReceived: by spt.entity.com (smail2.5); 11 Nov 88 20:16:42 EST (Fri)To: pierson@mist.encore.COMCc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: Dan L. Pierson's message of Fri, 11 Nov 88 17:21:53 EST <8811112221.AA02053@mist.UUCP>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) Message-Id: <8811112016.AA26928@spt.entity.com>Date: 11 Nov 88 20:16:42 EST (Fri)From: gz@spt.entity.com (Gail Zacharias)   Date: Fri, 11 Nov 88 17:21:53 EST   From: Dan L. Pierson <pierson@mist>   If REQUIRE is removed from the standard language you can continue to   provide it as an implementation extension and tell your users anything   you want.That's exactly right.  I have no objections to removing REQUIRE from thelanguage.  What I have problems with is leaving it in the language while (a)breaking *all* current uses of it (since by definition (CLtL p.188) currentusage means loading) and (b) putting restrictions on the ability ofimplementations to continue supporting current usage as an extension.*start*01279 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 09:21:00 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 14 Nov 88  09:19:36 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 491941; Mon 14-Nov-88 12:12:20 ESTDate: Mon, 14 Nov 88 12:11 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) To: gls@Think.COMcc: Gregor.pa, Scott.Fahlman@b.gp.cs.cmu.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: <8811141649.AA10899@joplin.think.com>Message-ID: <19881114171153.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Mon, 14 Nov 88 11:49:27 EST    From: gls@Think.COM    I would be happy to see PROVIDE and REQUIRE flushed.  The biggest    problem is coming up with a new mnemonic sentence.  I propose    "Insert Some Extremely Useless Interface Commands".  Doesn't quite    have the kick of the original, though.The combination of several pending cleanup proposals should eliminateentirely the need for any variant of that mnemonic sentence.*start*01614 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 09:27:10 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 14 Nov 88  08:52:31 PSTReceived: from fafnir.think.com by Think.COM; Mon, 14 Nov 88 11:30:37 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Mon, 14 Nov 88 11:49:32 ESTReceived: from joplin.think.com by verdi.think.com; Mon, 14 Nov 88 11:49:31 ESTReceived: by joplin.think.com; Mon, 14 Nov 88 11:49:27 ESTDate: Mon, 14 Nov 88 11:49:27 ESTFrom: gls@Think.COMMessage-Id: <8811141649.AA10899@joplin.think.com>To: Gregor.paCc: Scott.Fahlman@b.gp.cs.cmu.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: Gregor.pa@xerox.com's message of Fri, 11 Nov 88 17:59 PST <19881112015907.4.GREGOR@PORTNOY.parc.xerox.com>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)    Date: Fri, 11 Nov 88 17:59 PST   From: Gregor.pa@xerox.com   Fcc: BD:>Gregor>mail>outgoing-mail-4.text.newest   Line-Fold: no   I too would still like to see REQUIRE and PROVIDE removed from the   language.  In my experience with PCL, they have never proved useful.   Worse, the fact that some people thought they were useful and kept   insisiting that I should use them has been annoying.   -------I would be happy to see PROVIDE and REQUIRE flushed.  The biggestproblem is coming up with a new mnemonic sentence.  I propose"Insert Some Extremely Useless Interface Commands".  Doesn't quitehave the kick of the original, though.--Guy*start*01417 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 09:27:23 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 14 Nov 88  06:20:46 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 491797; Mon 14-Nov-88 09:19:30 ESTDate: Mon, 14 Nov 88 09:19 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) To: jonl@lucid.comcc: pierson@mist.encore.COM, sandra%defun@cs.utah.edu, cl-cleanup@SAIL.STANFORD.EDU, Bartley@mips.csc.ti.comIn-Reply-To: <8811140201.AA19970@bhopal>Message-ID: <881114091906.1.KMP@BOBOLINK.SCRC.Symbolics.COM>I think the key is in this concept of deprecation.The problem Gregor has indicated is that REQUIRE's presence theremeans he has to put up with people saying he shouldn't be writingDEFSYSTEM stuff but rather should be using REQUIRE/PROVIDE since``they wouldn't be there if you weren't intended to use them.''I have to say I've run into this same attitude.I think it's acceptable to retain the 1-argument case in the specfor sake of compatibility, but that we should throw it into thedeprecated bin so that it's clear that its mere presence there isnot an endorsement.*start*01169 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 12:25:33 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 14 Nov 88  12:23:51 PSTReceived: from snail.Sun.COM by Sun.COM (4.0/SMI-4.0)	id AA24721; Mon, 14 Nov 88 12:19:40 PSTReceived: from denali.sun.com by snail.Sun.COM (4.0/SMI-4.0)	id AA19402; Mon, 14 Nov 88 12:21:42 PSTReceived: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA19640; Mon, 14 Nov 88 11:43:48 PSTMessage-Id: <8811141943.AA19640@denali.sun.com>To: gls@Think.COMCc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3) In-Reply-To: Your message of Mon, 14 Nov 88 11:49:27 -0500;	<8811141649.AA10899@joplin.think.com> .Date: Mon, 14 Nov 88 11:43:46 -0800From: peck@Sun.COM>I would be happy to see PROVIDE and REQUIRE flushed.  The biggest>problem is coming up with a new mnemonic sentence.  I propose>"Insert Some Extremely Useless Interface Commands".  Doesn't quite>have the kick of the original, though.How about "Use DEFPACKAGE as appropriate"?*start*02726 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 13:49:55 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 14 Nov 88  13:47:32 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00449g; Mon, 14 Nov 88 13:39:48 PSTReceived: by bhopal id AA21540g; Mon, 14 Nov 88 13:38:32 PSTDate: Mon, 14 Nov 88 13:38:32 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811142138.AA21540@bhopal>To: gls@Think.COMCc: Gregor.pa, Scott.Fahlman@b.gp.cs.cmu.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: gls@Think.COM's message of Mon, 14 Nov 88 11:49:27 EST <8811141649.AA10899@joplin.think.com>Subject: more to do with DEFPACKAGE than with REQUIRE-PATHNAME-DEFAULTSre: I would be happy to see PROVIDE and REQUIRE flushed.  The biggest    problem is coming up with a new mnemonic sentence.  . . . The main reason I like keeping, at least, the "safety net" version ofREQUIRE in the standard is so that one can "call a halt" if a file is*** about to be loaded *** but the packages which it depends on are notyet set up.  Some problems with delayed package creation can be sosevere as to be almost intractable.  See the DEFPACKAGE proposal fordeatils.Good standard practice would be to have a file of package and interfacecreations, which PROVIDEs the "setup" module; and then every other filewould have, say, a (REQUIRE "phlogistion-setup") near the beginning.Admittedly there is much less need for a user to remember the mnemonicif he sticks just to this discipline; but of course lots of wizards willnot only want to "roll their own", but will demand to know what is goingon.  The Discussion section of the DEFPACKAGE proposal offers a newmnemonic, based on the ordering constraints derived therein:  It has been suggested that the "Put IN Seven EXtremely Random USEr  Interface COmmands" mnemonic described in CLtL p.191 could be removed;  and with possibly a few exceptions, the special handling of them by  COMPILE-FILE could be removed.  As this would be an incompatible change,   it is not part of this proposal.  However, a new mnemonic can be offered,   to help remember the ordering constraints mentioned above:	    I REmember Six USEr Interface Expressions  Each word in the sentence corresponds to one operation listed below:     I				IN-PACKAGE	;"foot" to stand on     REmember			REQUIRE		;ensure pre-requisite packages     Six			SHADOW		;block multiple-inheritances     USEr			USE-PACKAGE	;go for it!     Interface			IMPORT		;bring in "foreign" symbols     EXpressions		EXPORT		;a "face" to show to others.-- JonL --*start*04768 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 NOV 88 13:01:40 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 15 Nov 88  11:39:49 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA25709; Tue, 15 Nov 88 14:38:33 ESTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA06734; Tue, 15 Nov 88 14:42:28 ESTMessage-Id: <8811151942.AA06734@mist.UUCP>To: cl-cleanup%sail.stanford.edu@multimax.encore.comSubject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5)Date: Tue, 15 Nov 88 14:42:25 ESTFrom: Dan L. Pierson <pierson@mist.ARPA>The user impact and discussion have been rewritten.Bugs in current practice have been fixed.The proposal itself is unchanged (eliminate).Issue:         REQUIRE-PATHNAME-DEFAULTSReferences:    *MODULES*, PROVIDE, REQUIRE, pp 188-191               LOAD, pp 426-427Category:      CHANGEEdit history:  Version 1 by Pierson 9/13/88               Version 2 by Pierson 9/19/88, change PROVIDE stuff per comments               Version 3 by Pierson 10/17/88, remove PROVIDE locaction specs.	       Version 4 by Pierson 10/31/88, remove from language               Version 5 by Pierson 11/15/88, cleanup, fix discussionStatus:        Ready For ReleaseProblem description:PROVIDE and REQUIRE are a dual-purpose pair of functions that attemptto provide multi-file Common Lisp programs with a single mechanism todetect and correct incorrect load sequences.  These functions werealso designed to be used for general file inclusion in Common Lisp.Unfortunately, the file loading feature of REQUIRE is specified suchthat it is inherently non-portable and environment dependent.Proposal (REQUIRE-PATHNAME-DEFAULTS:ELIMINATE):Remove PROVIDE and REQUIRE from the Common Lisp standard.Test Cases/Examples:(PROVIDE 'fft)Would not be Common Lisp.(REQUIRE 'fft)Would not be Common Lisp.Rationale:The file loading feature of REQUIRE is non-portable.  The remainingfunctionality of PROVIDE and REQUIRE (pushing and testing *MODULES*)can easily be implemented by user code.  Since some implementationswill retain the automatic module loading features of REQUIRE and somewon't, use of REQUIRE will almost always make code less portable.Current practice:All implementations currently support some sort of file loading viasingle-argument REQUIRE.  In general, the Lisp Machine implementationsinvoke the system module building/loading facility while the Uniximplementations simply try to load a file in the current directory.Cost to Implementors:Implementations will have to move PROVIDE and REQUIRE to their packagefor implementation extensions and change their documentation toindicate that PROVIDE and REQUIRE are non-standard.  This is a fairlysmall change.Cost to Users:Non-portable programs that rely on PROVIDE and REQUIRE will probablybe unaffected since implementations will probably maintain theirexisting functionality.  Since the current behavior is decidedlynon-portable, portable programs have to aviod or special-case PROVIDEand REQUIRE anyway.Cost of non-Adoption:PROVIDE and REQUIRE will continue as impediments to portability.Benefits:The non-portability of PROVIDE and REQUIRE will be made obvious.Aesthetics:This simplifies the language by removing an environment-dependentfeature. Discussion:The cleanup committee tried to come up with a proposal to restrictPROVIDE and REQUIRE to the portable subset of their functionality.This failed because several implementors objected that it compelledthem to significantly reduce the functionality they provided users inorder to create a trivial feature which any user could easily writefor herself.Fahlman, Gregor, Grey, Loosemore, Moon, Pierson, Pitman, Steele, andZacharias have expressed support for removing PROVIDE and REQUIRE fromthe language, at least as the lesser of several evils.JonL would much rather see PROVIDE and REQUIRE remain in the languageas a safety net behind any implementation-specific system buildingfacility.  Pierson likes the safety net idea, but doesn't think it'sworkable without forbidding REQUIRE from loading files.Pitman suggested that PROVIDE and REQUIRE should be depricated ratherthan removed entirely.  Pierson agrees, but notes that Larry wants usto deal with deprication versus elimination as a separate global topic.Several people have expressed a desire not to break existing usercode.  If accepted, this proposal should not break existing codebecause all implementations are expected to retain their currentPROVIDE and REQUIRE functionality as an extension to Common Lisp.*start*00866 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 23:38:44 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  23:37:50 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 DEC 88 23:37:03 PSTDate: 8 Dec 88 23:36 PSTFrom: masinter.paSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5)In-reply-to: Dan L. Pierson <pierson@mist.ARPA>'s message of Tue, 15 Nov 88 14:42:25 ESTTo: Dan L. Pierson <pierson@mist.ARPA>cc: cl-cleanup@sail.stanford.eduMessage-ID: <881208-233703-5515@Xerox>Its a little late, but I just noticed: if you take out PROVIDE and REQUIRE,shouldn't you also remove *MODULES*?I don't know why the "safety net" idea isn't workable without forbiddingREQUIRE from loading files.*start*01448 00024 US Return-Path: <@multimax.encore.com:pierson@mist.encore.com>Received: from multimax.encore.com ([192.5.63.14]) by Xerox.COM ; 09 DEC 88 08:38:17 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA07986; Fri, 9 Dec 88 11:37:37 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA09540; Fri, 9 Dec 88 11:37:46 ESTMessage-Id: <8812091637.AA09540@mist.>To: masinter.paCc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) In-Reply-To: Your message of 08 Dec 88 23:36:00 -0800.             <881208-233703-5515@Xerox> Date: Fri, 09 Dec 88 11:37:43 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    Its a little late, but I just noticed: if you take out PROVIDE and REQUIRE,    shouldn't you also remove *MODULES*?    OK, new version will be out in a minute.    I don't know why the "safety net" idea isn't workable without forbidding    REQUIRE from loading files.    Because people using implementations in which REQUIRE loads fileswon't just use it as a safety net (because it doesn't act like one, infact it silently acts as just the opposite).  Then, when applicationsfrom such implementations are ported to "safety net" implementationserrors will occur.  While this does not mean the feature is bad, itdoes mean that it will harm rather than aid code portability.  Assuch, it does not belong in the standard, portable language.*start*04744 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 08:46:30 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 9 Dec 88  08:41:57 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA08110; Fri, 9 Dec 88 11:40:51 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA09555; Fri, 9 Dec 88 11:41:00 ESTMessage-Id: <8812091641.AA09555@mist.>To: cl-cleanup@sail.stanford.eduSubject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 6)Date: Fri, 09 Dec 88 11:40:58 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>Remove *MODULES* along with PROVIDE and REQUIRE.Issue:         REQUIRE-PATHNAME-DEFAULTSReferences:    *MODULES*, PROVIDE, REQUIRE, pp 188-191               LOAD, pp 426-427Category:      CHANGEEdit history:  Version 1 by Pierson 9/13/88               Version 2 by Pierson 9/19/88, change PROVIDE stuff per comments               Version 3 by Pierson 10/17/88, remove PROVIDE locaction specs.	       Version 4 by Pierson 10/31/88, remove from language               Version 5 by Pierson 11/15/88, cleanup, fix discussion               Version 6 by Pierson 12/9/88, remove *MODULES* as wellStatus:        For Internal DiscussionProblem description:PROVIDE and REQUIRE are a dual-purpose pair of functions that attemptto provide multi-file Common Lisp programs with a single mechanism todetect and correct incorrect load sequences.  These functions werealso designed to be used for general file inclusion in Common Lisp.Unfortunately, the file loading feature of REQUIRE is specified suchthat it is inherently non-portable and environment dependent.Proposal (REQUIRE-PATHNAME-DEFAULTS:ELIMINATE):Remove PROVIDE, REQUIRE, and *MODULES* from the Common Lisp standard.Test Cases/Examples:(PROVIDE 'fft)Would not be Common Lisp.(REQUIRE 'fft)Would not be Common Lisp.Rationale:The file loading feature of REQUIRE is non-portable.  The remainingfunctionality of PROVIDE and REQUIRE (pushing and testing *MODULES*)can easily be implemented by user code.  Since some implementationswill retain the automatic module loading features of REQUIRE and somewon't, use of REQUIRE will almost always make code less portable.Current practice:All implementations currently support some sort of file loading viasingle-argument REQUIRE.  In general, the Lisp Machine implementationsinvoke the system module building/loading facility while the Uniximplementations simply try to load a file in the current directory.Cost to Implementors:Implementations will have to move PROVIDE and REQUIRE to their packagefor implementation extensions and change their documentation toindicate that PROVIDE and REQUIRE are non-standard.  This is a fairlysmall change.Cost to Users:Non-portable programs that rely on PROVIDE and REQUIRE will probablybe unaffected since implementations will probably maintain theirexisting functionality.  Since the current behavior is decidedlynon-portable, portable programs have to aviod or special-case PROVIDEand REQUIRE anyway.Cost of non-Adoption:PROVIDE and REQUIRE will continue as impediments to portability.Benefits:The non-portability of PROVIDE and REQUIRE will be made obvious.Aesthetics:This simplifies the language by removing an environment-dependentfeature. Discussion:The cleanup committee tried to come up with a proposal to restrictPROVIDE and REQUIRE to the portable subset of their functionality.This failed because several implementors objected that it compelledthem to significantly reduce the functionality they provided users inorder to create a trivial feature which any user could easily writefor herself.Fahlman, Gregor, Grey, Loosemore, Moon, Pierson, Pitman, Steele, andZacharias have expressed support for removing PROVIDE and REQUIRE fromthe language, at least as the lesser of several evils.JonL would much rather see PROVIDE and REQUIRE remain in the languageas a safety net behind any implementation-specific system buildingfacility.  Pierson likes the safety net idea, but doesn't think it'sworkable without forbidding REQUIRE from loading files.Pitman suggested that PROVIDE and REQUIRE should be depricated ratherthan removed entirely.  Pierson agrees, but notes that Larry wants usto deal with deprication versus elimination as a separate global topic.Several people have expressed a desire not to break existing usercode.  If accepted, this proposal should not break existing codebecause all implementations are expected to retain their currentPROVIDE and REQUIRE functionality as an extension to Common Lisp.*start*01119 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 09:26:55 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  09:25:50 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 09:18:52 PSTDate: 9 Dec 88 09:17 PSTFrom: masinter.paSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) In-reply-to: Dan L. Pierson <pierson@mist.encore.com>'s message of Fri, 09 Dec 88 11:37:43 ESTTo: Dan L. Pierson <pierson@mist.encore.com>cc: cl-cleanup@sail.stanford.eduMessage-ID: <881209-091852-6190@Xerox>But isn't that exactly the safety net? That is, if someone sends me aprogram where they expected PROVIDE and REQUIRE to load, and myimplementation doesn't load, I'll try to load the files myself in the rightorder. If I get it wrong, I'll get an error message-- saved from making amistake, thus a safety net.I'm not sure how it harms rather than aids portability, since you also saythat you expect vendors to provide their own version of it anyway.*start*00330 00024 US Return-Path: <@multimax.encore.com:pierson@mist.encore.com>Received: from multimax.encore.com ([192.5.63.14]) by Xerox.COM ; 09 DEC 88 11:09:37 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA01877; Fri, 9 Dec 88 14:09:21 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	*start*02148 00024 US Return-Path: <@multimax.encore.com:pierson@mist.encore.com>Received: from multimax.encore.com ([192.5.63.14]) by Xerox.COM ; 09 DEC 88 11:09:37 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA01877; Fri, 9 Dec 88 14:09:21 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA09692; Fri, 9 Dec 88 14:09:31 ESTMessage-Id: <8812091909.AA09692@mist.>To: masinter.paCc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) In-Reply-To: Your message of 09 Dec 88 09:17:00 -0800.             <881209-091852-6190@Xerox> Date: Fri, 09 Dec 88 14:09:28 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    But isn't that exactly the safety net? That is, if someone sends me a    program where they expected PROVIDE and REQUIRE to load, and my    implementation doesn't load, I'll try to load the files myself in the right    order. If I get it wrong, I'll get an error message-- saved from making a    mistake, thus a safety net.    While this is true, and useful in programs that consist of a fewfiles, it is much less useful with large, multi-directory programs.Getting an error for (REQUIRE 'QX-DEFS) in a program that has 100files spread across 15 directories (some with sub-directories) isbetter than no immediate error, but less that helpful.  Admittedly,most programs aren't this large, but some are and it's the largeprograms that need help the most.    I'm not sure how it harms rather than aids portability, since you also say    that you expect vendors to provide their own version of it anyway.    But if PROVIDE and REQUIRE aren't in the standard, anyone who usesthem will know that they are dealing with non-portable constructs.This will encourage people who want to write portable programs toprovide a truely portable means of getting them loaded correctly.CLOS is an excellent example here.  As one of the largest publicportable Common Lisp programs, it includes its own portable DEFSTRUCT_and_ its author supports removing PROVIDE and REQUIRE from thelanguage (if only to make people quit asking him to use them).*start*02151 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 11:13:00 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 9 Dec 88  11:11:49 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA01978; Fri, 9 Dec 88 14:10:52 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA09711; Fri, 9 Dec 88 14:11:02 ESTMessage-Id: <8812091911.AA09711@mist.>To: cl-cleanup@sail.stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) Date: Fri, 09 Dec 88 14:11:00 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    But isn't that exactly the safety net? That is, if someone sends me a    program where they expected PROVIDE and REQUIRE to load, and my    implementation doesn't load, I'll try to load the files myself in the right    order. If I get it wrong, I'll get an error message-- saved from making a    mistake, thus a safety net.    While this is true, and useful in programs that consist of a fewfiles, it is much less useful with large, multi-directory programs.Getting an error for (REQUIRE 'QX-DEFS) in a program that has 100files spread across 15 directories (some with sub-directories) isbetter than no immediate error, but less that helpful.  Admittedly,most programs aren't this large, but some are and it's the largeprograms that need help the most.    I'm not sure how it harms rather than aids portability, since you also say    that you expect vendors to provide their own version of it anyway.    But if PROVIDE and REQUIRE aren't in the standard, anyone who usesthem will know that they are dealing with non-portable constructs.This will encourage people who want to write portable programs toprovide a truely portable means of getting them loaded correctly.CLOS is an excellent example here.  As one of the largest publicportable Common Lisp programs, it includes its own portable DEFSTRUCT_and_ its author supports removing PROVIDE and REQUIRE from thelanguage (if only to make people quit asking him to use them).*start*02130 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 17:33:22 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 9 Dec 88  17:32:31 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02141g; Fri, 9 Dec 88 17:29:20 PSTReceived: by bhopal id AA07286g; Fri, 9 Dec 88 17:31:12 PSTDate: Fri, 9 Dec 88 17:31:12 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812100131.AA07286@bhopal>To: masinter.pa, pierson@mist.encore.comCc: Gray@DSG.csc.ti.com, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 9 Dec 88 09:17 PST <881209-091852-6190@Xerox>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) Larry, I would very much like to see a second alternative in thisproposal.  I think the idea of a "safety-net" version of REQUIRE isfully portable, and backwards compatible with those implementations that hook into their own "defsystem".  All the arguments against it, that have been sent out in discussion so far, are simply confusing the issue of REQUIRE portability with that of DEFSYSTEM portability.  If someone uses implementation A's DEFSYSTEM, his code won't be portable to implementation B (unless B has cloned A's DEFSYSTEM).  There is just no reason to indict REQUIRE of cuplability here.My "compromise" proposal, that Gray seemed to agree to, was to insistthat implementations which "hook" their REQUIRE into some  kind of DEFSYSTEM -- as an implementation- specific extension -- must also provide a special variable flag that disengages any such "hook-up".  While it is true that many people will persist in writing non-portable code, the portable use of REQUIRE to ensure that required package definitions are "already loaded in" is of paramount importance.  There is no other portable feature to help ensure that.If you and Dan are amenable, I'd write the additional part -- from previous mails, it should only take 10 or 20 minutes at most.  Eitherof you could probably write it too.-- JonL --*start*01178 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 17:36:05 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 9 Dec 88  17:35:19 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02165g; Fri, 9 Dec 88 17:32:44 PSTReceived: by bhopal id AA07293g; Fri, 9 Dec 88 17:34:40 PSTDate: Fri, 9 Dec 88 17:34:40 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812100134.AA07293@bhopal>To: pierson@mist.encore.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Dan L. Pierson's message of Fri, 09 Dec 88 14:11:00 EST <8812091911.AA09711@mist.>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) re: CLOS is an excellent example here.  As one of the largest public    portable Common Lisp programs, it includes its own portable DEFSTRUCT    _and_ its author supports removing PROVIDE and REQUIRE from the    language (if only to make people quit asking him to use them).You meant DEFSYS, of course.  Proof in point that it is DEFSYSTEM, notREQUIRE, that is currently not in a portable state.-- JonL --*start*02466 00024 US Date: Sun, 11 Dec 88 10:45 PSTFrom: Gregor.paSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) To: Jon L White <jonl@lucid.com>cc: masinter.pa, pierson@mist.encore.com, Gray@DSG.csc.ti.com, cl-cleanup@sail.stanford.eduFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: <8812100131.AA07286@bhopal>Message-ID: <19881211184511.8.GREGOR@PORTNOY.parc.xerox.com>Line-fold: no    Date: Fri, 9 Dec 88 17:31:12 PST    From: Jon L White <jonl@lucid.com>    Larry, I would very much like to see a second alternative in this    proposal.  I think the idea of a "safety-net" version of REQUIRE is    fully portable, and backwards compatible with those implementations     that hook into their own "defsystem".  All the arguments against it,     that have been sent out in discussion so far, are simply confusing the     issue of REQUIRE portability with that of DEFSYSTEM portability.  If     someone uses implementation A's DEFSYSTEM, his code won't be portable     to implementation B (unless B has cloned A's DEFSYSTEM).  There is just     no reason to indict REQUIRE of cuplability here.    My "compromise" proposal, that Gray seemed to agree to, was to insist    that implementations which "hook" their REQUIRE into some  kind of     DEFSYSTEM -- as an implementation- specific extension -- must also     provide a special variable flag that disengages any such "hook-up".      While it is true that many people will persist in writing non-portable     code, the portable use of REQUIRE to ensure that required package     definitions are "already loaded in" is of paramount importance.  There is     no other portable feature to help ensure that.I don't buy this.  You can do it portably with find-package and intern.You might claim that is gross, but I don't believe it.  The point isthat REQUIRE "suggests" more than it can possibly do.  It need to knowthat the sub-system I depend on really is completely loaded, up andrunning.  Any program that is "portably" going to require the existenceof other programs takes work,  it takes some sort of defsystem facility.REQUIRE can't possibly provide that, all it can do is confuse peopleinto thinking that they might be getting it.    If you and Dan are amenable, I'd write the additional part -- from     previous mails, it should only take 10 or 20 minutes at most.  Either    of you could probably write it too.    -- JonL ---------*start*01985 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 09 DEC 88 17:31:52 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02141g; Fri, 9 Dec 88 17:29:20 PSTReceived: by bhopal id AA07286g; Fri, 9 Dec 88 17:31:12 PSTDate: Fri, 9 Dec 88 17:31:12 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812100131.AA07286@bhopal>To: masinter.pa, pierson@mist.encore.comCc: Gray@DSG.csc.ti.com, cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 9 Dec 88 09:17 PST <881209-091852-6190@Xerox>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) Larry, I would very much like to see a second alternative in thisproposal.  I think the idea of a "safety-net" version of REQUIRE isfully portable, and backwards compatible with those implementations that hook into their own "defsystem".  All the arguments against it, that have been sent out in discussion so far, are simply confusing the issue of REQUIRE portability with that of DEFSYSTEM portability.  If someone uses implementation A's DEFSYSTEM, his code won't be portable to implementation B (unless B has cloned A's DEFSYSTEM).  There is just no reason to indict REQUIRE of cuplability here.My "compromise" proposal, that Gray seemed to agree to, was to insistthat implementations which "hook" their REQUIRE into some  kind of DEFSYSTEM -- as an implementation- specific extension -- must also provide a special variable flag that disengages any such "hook-up".  While it is true that many people will persist in writing non-portable code, the portable use of REQUIRE to ensure that required package definitions are "already loaded in" is of paramount importance.  There is no other portable feature to help ensure that.If you and Dan are amenable, I'd write the additional part -- from previous mails, it should only take 10 or 20 minutes at most.  Eitherof you could probably write it too.-- JonL --*start*01983 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 09:31:52 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 12 Dec 88  09:29:31 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA00380; Mon, 12 Dec 88 12:28:24 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA10731; Mon, 12 Dec 88 11:17:09 ESTMessage-Id: <8812121617.AA10731@mist.>To: Jon L White <jonl@lucid.com>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) In-Reply-To: Your message of Fri, 09 Dec 88 17:31:12 -0800.             <8812100131.AA07286@bhopal> Date: Mon, 12 Dec 88 11:17:06 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    If you and Dan are amenable, I'd write the additional part -- from     previous mails, it should only take 10 or 20 minutes at most.  Either    of you could probably write it too.    Well, I still disagree with the substance and will almost certainlyvote against such an alternative (see Gregor's reply to your messagefor my reasoning).  The only thing that might change my vote would be:    1. Standardizing the control variable, and    2. Making its default value be no loading or DEFSYS interaction.This would force all of Grey, etc.'s users to explictly enable thenon-portable feature if they wanted it.  I suspect that Coral, atleast, would oppose this because they evidently document REQUIRE asthe way to enable (load) proprietary extensions such as Macintoshgraphics support.One the other hand, I'm getting the feeling that a substatial part ofcleanup disagrees with me.  Given that, and the amount of time we'vespent discussing this, I think that it is quite approptiate for you toadd a second alternative to the proposal, give it a couple of days forcleanup comments, and send the combination to x3j13 for voting.*start*01936 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 09:31:58 PSTReceived: from multimax.encore.com by SAIL.Stanford.EDU with TCP; 12 Dec 88  09:29:50 PSTReceived: from mist.encore.COM by multimax.encore.com (5.59/25-eef)	id AA00392; Mon, 12 Dec 88 12:28:35 ESTReceived: from localhost by mist. (4.0/SMI-4.0)	id AA10740; Mon, 12 Dec 88 11:25:39 ESTMessage-Id: <8812121625.AA10740@mist.>To: Jon L White <jonl@lucid.com>Cc: cl-cleanup@sail.stanford.eduSubject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) In-Reply-To: Your message of Fri, 09 Dec 88 17:34:40 -0800.             <8812100134.AA07293@bhopal> Date: Mon, 12 Dec 88 11:25:37 ESTFrom: Dan L. Pierson <pierson@mist.encore.com>    You meant DEFSYS, of course.  Proof in point that it is DEFSYSTEM, not    REQUIRE, that is currently not in a portable state.    Of course.I disagree in that I think both are currently not in a portable state.In case any of this argument has given people the wrong impression, Iwould strongly support almost any reasonable proposal for adding aportable DEFSYSTEM to the standard.  (I haven't put one forwardbecause it seems that it would have no chance).  The history of Unixfor the last decade or so is a perfect demonstration of the tremendousadvantages of such a facility even if the facility itself is far shortof perfection.  While simple, standard DEFSYSTEM would be a great aid to portable CLsoftware distribution, it needn't compete with implementors superiorproprietary system definition packages at all.  Since the prime goalsof a standard DEFSYSTEM would be portability, simplicity, and minimumnecessary functionality, it should be simple to enhance any of theproprietary packages to cons up a portable DEFSYSTEM file when thetime came to distribute the software.*start*04763 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 14:48:34 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  14:27:43 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 14:26:26 PSTDate: 12 Dec 88 14:26 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 6)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-142626-5215@Xerox>This issue has consumed a large number of "cleanup" committeecycles. (I have over 80 messages filed on this one topic.)We hope to have another proposal available as a possibleresolution of the same issue...!Issue:         REQUIRE-PATHNAME-DEFAULTSReferences:    *MODULES*, PROVIDE, REQUIRE, pp 188-191               LOAD, pp 426-427Category:      CHANGEEdit history:  Version 1 by Pierson 9/13/88               Version 2 by Pierson 9/19/88, change PROVIDE stuff per comments               Version 3 by Pierson 10/17/88, remove PROVIDE locaction specs.               Version 4 by Pierson 10/31/88, remove from language               Version 5 by Pierson 11/15/88, cleanup, fix discussion               Version 6 by Pierson 12/9/88, remove *MODULES* as wellProblem description:PROVIDE and REQUIRE are a dual-purpose pair of functions that attemptto provide multi-file Common Lisp programs with a single mechanism todetect and correct incorrect load sequences.  These functions werealso designed to be used for general file inclusion in Common Lisp.Unfortunately, the file loading feature of REQUIRE is specified suchthat it is inherently non-portable and environment dependent.Proposal (REQUIRE-PATHNAME-DEFAULTS:ELIMINATE):Remove PROVIDE, REQUIRE, and *MODULES* from the Common Lisp standard.Test Cases/Examples:(PROVIDE 'fft)Would not be Common Lisp.(REQUIRE 'fft)Would not be Common Lisp.Rationale:The file loading feature of REQUIRE is non-portable.  The remainingfunctionality of PROVIDE and REQUIRE (pushing and testing *MODULES*)can easily be implemented by user code.  Since some implementationswill retain the automatic module loading features of REQUIRE and somewon't, use of REQUIRE will almost always make code less portable.Current practice:All implementations currently support some sort of file loading viasingle-argument REQUIRE.  In general, the Lisp Machine implementationsinvoke the system module building/loading facility while the Uniximplementations simply try to load a file in the current directory.Cost to Implementors:Implementations will have to move PROVIDE and REQUIRE to their packagefor implementation extensions and change their documentation toindicate that PROVIDE and REQUIRE are non-standard.  This is a fairlysmall change.Cost to Users:Non-portable programs that rely on PROVIDE and REQUIRE will probablybe unaffected since implementations will probably maintain theirexisting functionality.  Since the current behavior is decidedlynon-portable, portable programs have to aviod or special-case PROVIDEand REQUIRE anyway.Cost of non-Adoption:PROVIDE and REQUIRE will continue as impediments to portability.Benefits:The non-portability of PROVIDE and REQUIRE will be made obvious.Aesthetics:This simplifies the language by removing an environment-dependentfeature. Discussion:The cleanup committee tried to come up with a proposal to restrictPROVIDE and REQUIRE to the portable subset of their functionality.This failed because several implementors objected that it compelledthem to significantly reduce the functionality they provided users inorder to create a trivial feature which any user could easily writefor herself.Fahlman, Gregor, Grey, Loosemore, Moon, Pierson, Pitman, Steele, andZacharias have expressed support for removing PROVIDE and REQUIRE fromthe language, at least as the lesser of several evils.JonL would much rather see PROVIDE and REQUIRE remain in the languageas a safety net behind any implementation-specific system buildingfacility.  Pierson likes the safety net idea, but doesn't think it'sworkable without forbidding REQUIRE from loading files.Pitman suggested that PROVIDE and REQUIRE should be depricated ratherthan removed entirely.  Pierson agrees, but notes that Larry wants usto deal with deprication versus elimination as a separate global topic.Several people have expressed a desire not to break existing usercode.  If accepted, this proposal should not break existing codebecause all implementations are expected to retain their currentPROVIDE and REQUIRE functionality as an extension to Common Lisp.*start*03158 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 13 DEC 88 22:39:51 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA06973g; Tue, 13 Dec 88 22:37:36 PSTReceived: by bhopal id AA11971g; Tue, 13 Dec 88 22:39:35 PSTDate: Tue, 13 Dec 88 22:39:35 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812140639.AA11971@bhopal>To: Gregor.paCc: masinter.pa, pierson@mist.encore.com, Gray@DSG.csc.ti.com, cl-cleanup@sail.stanford.eduIn-Reply-To: Gregor.pa@Xerox.COM's message of Sun, 11 Dec 88 10:45 PST <19881211184511.8.GREGOR@PORTNOY.parc.xerox.com>Subject: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 5) re: 	My "compromise" proposal, that Gray seemed to agree to, was to insist	that implementations which "hook" their REQUIRE into some  kind of 	DEFSYSTEM -- as an implementation- specific extension -- must also 	provide a special variable flag that disengages any such "hook-up".  	While it is true that many people will persist in writing non-portable 	code, the portable use of REQUIRE to ensure that required package 	definitions are "already loaded in" is of paramount importance.  There        is no other portable feature to help ensure that.    I don't buy this.  You can do it portably with find-package and intern.    You might claim that is gross, but I don't believe it.  . . . The point underlying this claim has been re-iterated several times duringthe discussion of this issue, but let me try again.  -- a REQUIRE used in an implementation that can hook into a defsystem     will trigger that loading.  There is no portable way to do so now     [doesn't matter that the hook merely errors out for implementations     that don't have a defsystem, or for which the user failed to supply     the appropriate database].  REQUIREs which supply explicit filenames     are not portable -- that's precisely how this proposal got started.  -- any REQUIRE is expression of intent on the part of the programmer.     REQUIREs are in common usage around the community, and they are      especially useful in package "requirements".  All such expressions     are portable.  But I have no idea what you mean by suggesting that these usages ofREQUIRE can be replaced by some idiosyncratic usage of FIND-PACKAGE etc.Incidentally, the point about "expression of intent" was said muchbetter by Larry last October:    Date: 18 Oct 88 14:13 PDT    From: masinter.pa@Xerox.COM    Subject: Re: Issue: REQUIRE-PATHNAME-DEFAULTS (Version 3)     The thing that distinguishes PROVIDE and REQUIRE from their obvious    implementations is that they have declarative rather than operative    semantics. Program walkers, DEFSYSTEM constructors as well as compilers    might be expected to pay special heed to PROVIDE and REQUIRE, but not pay    any special heed to direct manipulation of *MODULES*.    We should be careful in the standard to distinguish between what things    mean and how they may be implemented, but doubly so in the case of macros    and special forms that may get processed at times other than EVAL-time.-- JonL --*start*02233 00024 US Date:  4 Apr 89 13:30 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: REQUIRE-PATHNAME-DEFAULTSTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REQUIRE-PATHNAME-DEFAULTSTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 13:11:56 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:41:57 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571274; Tue 4-Apr-89 15:41:50 EDTOriginal-Date: Tue, 4 Apr 89 15:41 EDTMessage-ID: <890404154124.5.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say... A motion to reconsider this issue was made. The motion to reconsider passed 5-4. A motion was made to deprecate rather than to remove.  Pitman proposed an amendment to make these macros instead of functions,  thinking that REQUIRE and PROVIDE were part of the magic functions we  were trying to eliminate.  He tried to withdraw the motion to amend  when someone observed that they are not supposed to be specially treated  but others still wanted them to be macros for some reason. Anyway, the  amendment failed on a vote of 4-11. The original motion to deprecate instead of remove was voted on. The first count was 7-7, but someone asked for a recount. The next count was 7-8, but someone was late raising his hand and didn't think his vote had counted right. The next vote was 8-7. At this point, Pitman requested a roll call vote so there would be no dispute later. The results were:  IBM		   No  DEC		   Yes  RWK(!)	   Yes  TI		   No  IIM		   Yes  Univ of Utah     No  Apple		   Yes  Franz		   Yes  Think		   Yes  Encore	   Yes  Honeywell	   No  Johnson Controls No  MCC		   No  Xerox		   No  Lucid		   Yes  SMBX		   No The motion failed 8-8, so the result voted on at the previous meeting stands.*start*00847 00024 US Date: 26 Mar 89 13:37 PSTSender: Larry Masinter:PARC:xeroxFrom: masinter:PARC:XeroxSubject: Re: issue IN-PACKAGE-FUNCTIONALITY, version 7In-Reply-to: jonl%lucid:COM's message of Saturday, March 25, 1989 11:31 pmTo: jonl%lucid:COM:Xeroxcc: masinter:PA:XeroxReply-to: masinter:PARC:XeroxShould we also re-debate MAKE-PACKAGE-USE-DEFAULT?I think everyone who voted for removing REQUIRE & PROVIDE knew what they were doing. The only issues that I think we should revisit are those for which there were repercusions we had not considered.This doesn't seem to be the case for the REQUIRE-PATHNAME-DEFAULTS issue,or for many of the others that were decided in waysthat I personally disagree with.I don't think removing REQUIRE & PROVIDE seriously damage Common Lisp, and that revisiting it is a waste of time.*start*04073 00024 USaDate:  4 Apr 89 16:48 PDTFrom: jonl%lucid:COM:XeroxSubject: issue IN-PACKAGE-FUNCTIONALITY, version 7In-Reply-to: masinter.PARC@Xerox.COM's message of 26 Mar 89 13:37:30 PST (Sunday) <890326-133756-10306@Xerox>To: masinter:PARC:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <jonl@lucid.com>To: masinter.PARCIn-Reply-To: masinter.PARC@Xerox.COM's message of 26 Mar 89 13:37:30 PST (Sunday) <890326-133756-10306@Xerox>Subject: issue IN-PACKAGE-FUNCTIONALITY, version 7Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 04 APR 89 16:32:13 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA16910g; Tue, 4 Apr 89 16:26:25 PDTReceived: by bhopal id AA11139g; Tue, 4 Apr 89 16:32:58 PDTOriginal-Date: Tue, 4 Apr 89 16:32:58 PDTMessage-Id: <8904042332.AA11139@bhopal>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: Should we also re-debate MAKE-PACKAGE-USE-DEFAULT?    . . .     I don't think removing REQUIRE & PROVIDE seriously damage Common Lisp, and    that revisiting it is a waste of time.You are quite wrong in asserting that this removal does no damage.  It seriously impairs those clients of it, who are *not* limited to one vendor, or one site -- for new implementors of Common Lisp on a compatibleoperating system will likely not include it; and current vendors (say,Franz and Lucid) will most likely "fix" it in incompatible ways.  Thestandardization process will have failed in a most spectacular way.Standardization must be an essentially conservative process when it comes to backwards compatiblity; my motto "If you can't 'fix it', then bloody well don't break it!".  [Remember how KMP conceded that the users of COMPILER-LET were in fact probably limited to just the handful at Symbolics?that allowed me, and perhaps others, to vote to remove since there is no portability question involved.]  And, yes, provide and require are fully and satisfactorily portable *among* the six implementations of Common Lisp that run on a Sun workstation; should any of these clients port to, say, a Symbolics machine, the portability problems of provide and require will be among the least of their troubles.Except for you and one other person, *all* of the "no" votes came from sites that are intensively Symbolics -- and they use the non-standard DEFSYSTEM (thereby thinking that provide and require have no place in the standard since defsystem is "better"); Gray is in this camp, since the TI software essentially follows Symbolics.Worse yet, by failing to vote your conscience and your good sense, we will now have to waste even more time by reconsidering this issue again  -- several X3J13 members who weren't in the room when the vote was taken are in favor of restoring provide/require to "deprecated" status.   And more end-users are finding out about this senseless incompatibility that is being perpetated on them primarily by the LispMachine gang.re: MAKE-PACKAGE-USE-DEFAULTI know you thought you were being "cute" with this remark, but infact we should reconsider it if, as I said above, "it seriously impairs those clients of it".   The call for such argumentation went out inHawaii, and as I correctly predicted, there is *no* such impairment.All allegedly portable programs in fact supply the argument ratherthan allowing it to be defaulted.  So, sure, go ahead and bring itup again if you want; certainly bring it up if you find real evidenceof widespread exposure to backwards incompatibility; but please pleasedon't bring it up just as a private, personal vendetta. -- JonL --P.S. The "most spectacular way", in case you hadn't figured it out, is     that a proposal intended to _facilitate portability_ [by throwing     the baby out with the bath water?] has precisely the opposite effect:     namely the scores of users who find it portable among the implementations     of interest to them, are guaranteed that such portability will be     broken in the future.*start*02611 00024 US GV-Info: masinter.pa at  9-Apr-89 20:20:47 from massunterDate:  9 Apr 89 20:20 PDTFrom: masinter.paSubject: REQUIRE-PATHNAME-DEFAULTSIn-reply-to: jonl%lucid:COM:Xerox's message of 4 Apr 89 16:48 PDTTo: jonl@lucid.COMcc: masinterPerhaps this is justification after the fact, but the fact is that I didn't want to consider a motion to reinstate PROVIDE and REQUIRE ** as they are in CLtL ** because it still left unresolved the original motivation that brought up the issue, namely, that the whole notion of the default pathname for them was missing. If you want to seriously work on the issue, try to come up with an alternate solution. Maybe you just want to go back to version 5? Or version 4?You said, "Larry, I would very much like to see a second alternative in thisproposal.  I think the idea of a "safety-net" version of REQUIRE isfully portable, and backwards compatible with those implementations that hook into their own "defsystem".  All the arguments against it, that have been sent out in discussion so far, are simply confusing the issue of REQUIRE portability with that of DEFSYSTEM portability.  If someone uses implementation A's DEFSYSTEM, his code won't be portable to implementation B (unless B has cloned A's DEFSYSTEM).  There is just no reason to indict REQUIRE of cuplability here.My "compromise" proposal, that Gray seemed to agree to, was to insistthat implementations which "hook" their REQUIRE into some  kind of DEFSYSTEM -- as an implementation- specific extension -- must also provide a special variable flag that disengages any such "hook-up".  While it is true that many people will persist in writing non-portable code, the portable use of REQUIRE to ensure that required package definitions are "already loaded in" is of paramount importance.  There is no other portable feature to help ensure that.If you and Dan are amenable, I'd write the additional part -- from previous mails, it should only take 10 or 20 minutes at most.  Eitherof you could probably write it too."But you didn't offer this at the Mar X3J13; I think you mighthave gotten a lot more votes, depending on how it came out. I don't know how you can specify REQUIRE in terms of some unspecifiedimplementation-dependent DEFSYSTEM. Frankly, I can think of lots of ways of 'fixing' REQUIRE and PROVIDEwhich themselves have their own problems (make them special forms,make LOAD recognize them, etc. etc.) but I wasn't going to voteto reconsider when there weren't any better alternatives beingproposed, and when Gregor had been so emphatic.*start*01140 00024 US GV-Info: jonl@lucid.com at 12-Apr-89 06:27:26 from AGReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 12 APR 89 06:27:22 PDTReceived: from bhopal ([192.43.178.13]) by heavens-gate.lucid.com id AA03193g; Wed, 12 Apr 89 06:27:25 PDTReceived: by bhopal id AA20746g; Wed, 12 Apr 89 06:27:17 PDTDate: Wed, 12 Apr 89 06:27:17 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8904121327.AA20746@bhopal>To: masinter.paCc: jonl@lucid.comIn-Reply-To: masinter.pa@Xerox.COM's message of 9 Apr 89 20:20 PDT <890409-202053-3383@Xerox>Subject: REQUIRE-PATHNAME-DEFAULTSFrankly, Larry, I just gave up on "fixing" provide and require.  Thebasic problem, as alluded to in my previous message, is that the LispMachine types won't be satisfied with anything less than a hookup intoDEFSYSTEM;  And that is a bit too radical to be acceptable to the severalcurrent user's of provide/require that I talk to frequently (myselfexcepted).  A Solomon I wasn't.If you offered some such compromise, it might carry more weight now,since you were in the Nay votes at Fairfax.-- JonL --