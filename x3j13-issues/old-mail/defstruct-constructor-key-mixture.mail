*start*03982 00024 USfReturn-Path: <peck@Sun.COM>Received: from Sun.COM ([10.7.0.2]) by Xerox.COM ; 20 SEP 88 20:02:56 PDTReceived: from snail.sun.com by Sun.COM (4.0/SMI-4.0)	id AA22646; Tue, 20 Sep 88 20:00:40 PDTReceived: from denali.sun.com by snail.sun.com (4.0/SMI-4.0)	id AA04367; Tue, 20 Sep 88 20:03:34 PDTReceived: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA08825; Tue, 20 Sep 88 20:05:16 PDTMessage-Id: <8809210305.AA08825@denali.sun.com>To: Masinter.paSubject: Re: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE In-Reply-To: Your message of 02 Sep 88 16:38:00 -0700;	<880902-163909-7438@Xerox> .Date: Tue, 20 Sep 88 20:05:14 -0700From: peck@Sun.COMOk, here it is, I hope i got the form right. I'll let you review it to make sure I have the form filled out correctly. Subject: New issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREIssue:         DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREReferences:    CLtL page 316Category:      CHANGEEdit history:  20-Sep-88, Version 1Problem description:  Currently, defstruct constructor functions can be either the defaultconstructor function, with *only* keyword arguments, or it can be a so-called "By Order of Arguments" constructor function with explicitly*no* keyword arguments.  Other functions in Common Lisp allow a freemix of required, optional, and keyword arguments.   With the current restriction, it is necessary to hand code a function thatwill accept optional and keyword arguments and parse the supplied-pvariables explicitly.  Even so, it is not obvious to the casual programmerhow to provide the same semantics as destruct does with respect to defaultvalues and the defstruct init-forms.Proposal: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE:ALLOW-KEY  It should be possible to write forms like this:(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)					    &key (d 2)					    &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))and have the same behavior for the OPTIONAL and KEYWORD argumentswith respect to lambda list defaults and defstruct init-forms.The current wording in CLtL (p314):    "In addition, the keywords &optional, &rest, and &aux are recognised     in the argument list. They work in the way you might expect ..."would be extended accordingly.Example:    See Proposal.Rationale:    Currently, it is not possible to write in Common Lisp:(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)					    &key (d 2)					    &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))The programmer is instead encouraged to so something like:(defun create-foo (a &optional b (c 'sea) &key (d 2))  ;; the exported creation function.  (CREATE-FOO% a b c d))(defstruct (foo (:constructor CREATE-FOO% (a b c d &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))Even so, the handling of foo-b is incorrect if create-foo is called withonly 1 argument.  B will be nil instead of the init-form, 2.  Coding theinit-form create-foo breaks the modularity.  CLtL: "The actions taken in the B and E cases were carefully chosen to         allow the user to specify all possible behaviors."  The intent was clearly to make this *easier* for programmers...Current practice:    Current implementations tend to signal an error.Cost to Implementors:    My guess is that &key would not be any harder than &optionalCost to Users:    No cost, this is upward compatible.Cost of non-adoption:    The current situation is non-intuitive and needless restrictive.Benefits:    Much easier for users to write the constructor function they want.Probably implementation code would be reduced, since this would no longer be an error.Esthetics:    Obvious.    The biggest problem i can forsee is that editorial references to"By-position", "positional", and "By Order of Arguments" constructorfunction might need to be changed to something else.  We could still callthem BOA-constructors, though, couldn't we?  :)Discussion:*start*03333 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 SEP 88 01:11:51 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Sep 88  01:11:18 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 21 SEP 88 01:02:33 PDTDate: 21 Sep 88 01:02 PDTFrom: masinter.paSubject: Re: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE to: cl-cleanup@sail.stanford.eduMessage-ID: <880921-010233-5636@Xerox>This is Peck's proposal. I mainly edited it to put it in third instead of firstperson, moved a few things around to fit the proposal format a bit better.!Subject: New issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREIssue:         DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREReferences:    CLtL page 316Category:      CHANGEEdit history:  20-Sep-88, Version 1, Peck		21-Sep-88, Version 2, Masinter, minor revisionsProblem description:  Currently, defstruct constructor functions can be either the defaultconstructor function, with *only* keyword arguments, or it can be a so-called "By Order of Arguments" constructor function with explicitly*no* keyword arguments.  Other functions in Common Lisp allow a freemix of required, optional, and keyword arguments.   With the current restriction, it is necessary to hand code a function thatwill accept optional and keyword arguments and parse the supplied-pvariables explicitly.  Even so, it is not obvious to the casual programmerhow to provide the same semantics as defstruct does with respect to defaultvalues and the defstruct init-forms.Proposal: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE:ALLOW-KEYAllow combination of &OPTIONAL, &KEY and &AUX arguments inconstructor forms of defstructs.The current wording in CLtL (p314):    "In addition, the keywords &optional, &rest, and &aux are recognised     in the argument list. They work in the way you might expect ..."would be extended accordingly.Example:  It should be possible to write forms like this:(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)					    &key (d 2)					    &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))(create-foo 10) => #S(foo a 10 b 2 c sea d 2 e nil f eff)(create-foo 10 'bee 'see :d 'dee) => #S(foo a 10 b bee c see d dee e nil f eff)Rationale:This is a logical extension of the specification which makes someprogramming easier.Current practice:Some implementations to signal an error. Envos Medley (Xerox Common Lisp)  implements the proposed behavior.Cost to Implementors:The modifications to allow intermixed keywords and optionals in implementationsthat don't already are likely simple.Cost to Users:    No cost, this is upward compatible.Cost of non-adoption:    The current situation is non-intuitive and needless restrictive.Benefits:    Much easier for users to write the constructor function they want.Probably implementation code would be reduced, since this would no longer be an error.Esthetics:    Minor improvement since it removes a needless restriction.Discussion: Possibly  references to "By-position", "positional", and "By Order ofArguments" constructor function might need to be changed to something else inthe standard.  (They can still be called BOA-constructors, though, right?  :-)*start*02876 00024 US Date:  6 Oct 88 20:12 PDTFrom: masinter.paSubject: Re: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE to: x3J13@sail.stanford.educc: masinterREPLY-TO: Cl-cleanup@sail.stanford.eduline-fold: NOapologies if you get this twice; more mailer problems...Issue:         DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREReferences:    CLtL page 316Category:      CHANGEEdit history:  20-Sep-88, Version 1, Peck		21-Sep-88, Version 2, Masinter, minor revisionsProblem description:  Currently, defstruct constructor functions can be either the defaultconstructor function, with *only* keyword arguments, or it can be a so-called "By Order of Arguments" constructor function with explicitly*no* keyword arguments.  Other functions in Common Lisp allow a freemix of required, optional, and keyword arguments.   With the current restriction, it is necessary to hand code a function thatwill accept optional and keyword arguments and parse the supplied-pvariables explicitly.  Even so, it is not obvious to the casual programmerhow to provide the same semantics as defstruct does with respect to defaultvalues and the defstruct init-forms.Proposal: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE:ALLOW-KEYAllow combination of &OPTIONAL, &KEY and &AUX arguments inconstructor forms of defstructs.The current wording in CLtL (p314):    "In addition, the keywords &optional, &rest, and &aux are recognised     in the argument list. They work in the way you might expect ..."would be extended accordingly.Example:  It should be possible to write forms like this:(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)					    &key (d 2)					    &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))(create-foo 10) => #S(foo a 10 b 2 c sea d 2 e nil f eff)(create-foo 10 'bee 'see :d 'dee) => #S(foo a 10 b bee c see d dee e nil f eff)Rationale:This is a logical extension of the specification which makes someprogramming easier.Current practice:Some implementations to signal an error. Envos Medley (Xerox Common Lisp)  implements the proposed behavior.Cost to Implementors:The modifications to allow intermixed keywords and optionals in implementationsthat don't already are likely simple.Cost to Users:    No cost, this is upward compatible.Cost of non-adoption:    The current situation is non-intuitive and needless restrictive.Benefits:    Much easier for users to write the constructor function they want.Probably implementation code would be reduced, since this would no longer be an error.Esthetics:    Minor improvement since it removes a needless restriction.Discussion: Possibly  references to "By-position", "positional", and "By Order ofArguments" constructor function might need to be changed to something else inthe standard.  (They can still be called BOA-constructors, though, right?  :-)*start*03200 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 21:12:52 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Oct 88  20:58:09 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 06 OCT 88 20:12:18 PDTDate: 6 Oct 88 20:12 PDTFrom: masinter.paSubject: Re: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE to: x3J13@sail.stanford.educc: masinter.paREPLY-TO: Cl-cleanup@sail.stanford.eduline-fold: NOMessage-ID: <881006-201218-2044@Xerox>apologies if you get this twice; more mailer problems...!Issue:         DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREReferences:    CLtL page 316Category:      CHANGEEdit history:  20-Sep-88, Version 1, Peck		21-Sep-88, Version 2, Masinter, minor revisionsProblem description:  Currently, defstruct constructor functions can be either the defaultconstructor function, with *only* keyword arguments, or it can be a so-called "By Order of Arguments" constructor function with explicitly*no* keyword arguments.  Other functions in Common Lisp allow a freemix of required, optional, and keyword arguments.   With the current restriction, it is necessary to hand code a function thatwill accept optional and keyword arguments and parse the supplied-pvariables explicitly.  Even so, it is not obvious to the casual programmerhow to provide the same semantics as defstruct does with respect to defaultvalues and the defstruct init-forms.Proposal: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE:ALLOW-KEYAllow combination of &OPTIONAL, &KEY and &AUX arguments inconstructor forms of defstructs.The current wording in CLtL (p314):    "In addition, the keywords &optional, &rest, and &aux are recognised     in the argument list. They work in the way you might expect ..."would be extended accordingly.Example:  It should be possible to write forms like this:(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)					    &key (d 2)					    &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))(create-foo 10) => #S(foo a 10 b 2 c sea d 2 e nil f eff)(create-foo 10 'bee 'see :d 'dee) => #S(foo a 10 b bee c see d dee e nil f eff)Rationale:This is a logical extension of the specification which makes someprogramming easier.Current practice:Some implementations to signal an error. Envos Medley (Xerox Common Lisp)  implements the proposed behavior.Cost to Implementors:The modifications to allow intermixed keywords and optionals in implementationsthat don't already are likely simple.Cost to Users:    No cost, this is upward compatible.Cost of non-adoption:    The current situation is non-intuitive and needless restrictive.Benefits:    Much easier for users to write the constructor function they want.Probably implementation code would be reduced, since this would no longer be an error.Esthetics:    Minor improvement since it removes a needless restriction.Discussion: Possibly  references to "By-position", "positional", and "By Order ofArguments" constructor function might need to be changed to something else inthe standard.  (They can still be called BOA-constructors, though, right?  :-)*start*00826 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:13:55 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:14:05 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475786; Thu 13-Oct-88 16:12:00 EDTDate: Thu, 13 Oct 88 16:11 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013161151.5.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Deemed ready to vote.X3J13 meeting: No vote was attempted.*start*03124 00024 USfDate:  5 Dec 88 16:42 PSTFrom: masinter.pato: masinterSubject: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE (Version 2)Forum:         CleanupIssue:         DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREReferences:    CLtL page 316Category:      CHANGEEdit history:  20-Sep-88, Version 1, Peck               21-Sep-88, Version 2, Masinter, minor revisionsProblem description:  Currently, defstruct constructor functions can be either the defaultconstructor function, with *only* keyword arguments, or it can be a so-called "By Order of Arguments" constructor function with explicitly*no* keyword arguments.  Other functions in Common Lisp allow a freemix of required, optional, and keyword arguments.   With the current restriction, it is necessary to hand code a function thatwill accept optional and keyword arguments and parse the supplied-pvariables explicitly.  Even so, it is not obvious to the casual programmerhow to provide the same semantics as defstruct does with respect to defaultvalues and the defstruct init-forms.Proposal: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE:ALLOW-KEYAllow combination of &OPTIONAL, &KEY and &AUX arguments inconstructor forms of defstructs.The current wording in CLtL (p314):    "In addition, the keywords &optional, &rest, and &aux are recognised     in the argument list. They work in the way you might expect ..."would be extended accordingly.Example:  It should be possible to write forms like this:(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)					    &key (d 2)					    &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))(create-foo 10) => #S(foo a 10 b 2 c sea d 2 e nil f eff)(create-foo 10 'bee 'see :d 'dee) => #S(foo a 10 b bee c see d dee e nil f eff)Rationale:This is a logical extension of the specification which makes someprogramming easier.Current practice:Some implementations to signal an error. Envos Medley (Xerox Common Lisp)implements the proposed behavior.Cost to Implementors:The modifications to allow intermixed keywords and optionals in implementationsthat don't already are likely simple.Cost to Users:    No cost, this is upward compatible.Cost of non-adoption:    The current situation is non-intuitive and needless restrictive.Benefits:    Much easier for users to write the constructor function they want.Probably implementation code would be reduced, since this would no longer be an error.Esthetics:    Minor improvement since it removes a needless restriction.Discussion: Possibly  references to "By-position", "positional", and "By Order ofArguments" constructor function might need to be changed to something else inthe standard.  (They can still be called BOA-constructors, though, right?  :-)        TITAN 
         TITAN 
           I       !       7       "                                          \             ›       6      1       	      X              Y              m              w              )              F       
                      @              æ      
Æ  zº*start*01621 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 14:55:14 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  14:54:57 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 14:53:09 PSTDate: 2 Jan 89 14:52 PSTSender: masinter.paSubject: re: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE (Version 2)To: cl-cleanup@sail.stanford.eduFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Message-ID: <890102-145309-1706@Xerox>DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE:ALLOW-KEY	Version 2, 21-Sep-88, Mailed 6 Oct 88While I support the concept, the wording needs cleanup.  If these problems arefixed, then I'll vote YES.1. The proposal explicitely says to allow &OPTIONAL, &KEY, and &AUX keywords,but fails to mention &REST and &ALLOW-OTHER-KEYS.2. The proposal does not say how defaulting is to be done when the programmerdoesn't supply a default value for a keyword argument.  I assume that theintent is that it will do defaulting in the same way &OPTIONAL arguments arespecified to default in CLtL, ie. if no default is supplied in the lambda-listthen use the slot initform, else undefined.3. The proposal does not say which of key/var gets matched to the slot name inkeyword parameter specifiers of the form ((key var) [default [svar]]).  Iassume that it should be var that gets matched, since that gives the programmerthe most options, but this needs to be stated explicitely.Note for Current Practice:  The latest version of IIM Common Lisp implementsthis.*start*04720 00024 USfDate:  8 Jan 89 01:06 PSTFrom: masinter.pato: cl-cleanup@sail.stanford.eduline-fold: NOcc: masinterSubject: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE (Version 3)I shouldn't work on these things late at night....The discussion from Kim Barrett mentioned "supplied-p" arguments.I tried to think of uses of supplied-p arguments, and I thoughtthey were most useful in helping with some of the otherinitialization variables. So must supplied-p arguments nameslots? If not, are arguments allowed which don't name slotsbut are only used in the computation of &AUX or other &OPTIONAL or &KEY defaults? I'm guessing so and proposethis amendment which enhances the proposal.Let me know if you think this is a bad idea.Forum:         CleanupIssue:         DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREReferences:    CLtL page 316Category:      CHANGEEdit history:  20-Sep-88, Version 1, Peck               21-Sep-88, Version 2, Masinter, minor revisions                8-Jan-89, Version 3, MasinterProblem description:Currently, DEFSTRUCT constructor functions can be either the defaultconstructor function, with *only* keyword arguments, or it can be a so-called "By Order of Arguments" constructor function with explicitly*no* keyword arguments.  Other functions in Common Lisp allow a freemix of required, optional, and keyword arguments. With the current restriction, it is necessary to hand code a function thatwill accept optional and keyword arguments and parse the supplied-pvariables explicitly.  Even so, it is not obvious to the casual programmerhow to provide the same semantics as defstruct does with respect to defaultvalues and the defstruct init-forms.Proposal: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE:ALLOW-KEYAllow &KEY keyword arguments in constructor forms of DEFSTRUCTsand the &ALLOW-OTHER-KEYS token in addition to the &OPTIONAL,&REST and &AUX arguments already allowed. Keyword arguments defaultin a manner similar to that of &OPTIONAL arguments: if no defaultis supplied in the lambda-list then the slot initform is used;otherwise the slot is not initialized -- its initial value isundefined.If keyword arguments of the form ((key var) [default [svar]])are specified, the "slot name" is matched with VAR (and not KEY).Additional arguments that do not correspond to slot names butare merely present to supply values used in subsequent initialization computations are allowed.Examples:It should be possible to write forms like this:(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)					    &key (d 2)					    &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))(create-foo 10) => #S(foo a 10 b 2 c sea d 2 e nil f eff)(create-foo 10 'bee 'see :d 'dee) => #S(foo a 10 b bee c see d dee e nil f eff)In the definition:(defstruct (frob (:constructor create-frob		(a &key (b 3 have-b) (c-token 'c) 		        (c (list c-token (if have-b 7 2))))))	a b c)the c-token argument is used merely to supply a value used in the initialization of the c slot. The "supplied-p" arguments ofkeyword arguments might be of this form.Rationale:This is a logical extension of the specification which makes someprogramming easier.Current practice:Many implementations signal an error if given &KEY arguments orarguments that are not slot names. The latest version of IIM Common Lisp allows &KEY arguments in this manner. Envos Medley(Xerox Common Lisp) implements the proposal. Cost to Implementors:The modifications to allow intermixed keywords and optionals in implementationsthat don't already are likely simple. Cost to Users:No cost, this is upward compatible.Cost of non-adoption:The current situation is non-intuitive and needless restrictive.Benefits:Much easier for users to write the constructor function they want.Probably implementation code would be reduced, since this would no longer be an error.Esthetics:Minor improvement since it removes a needless restriction.Discussion:Possibly  references to "By-position", "positional", and "By Order ofArguments" constructor function might need to be changed to something else inthe standard.  (They can still be called BOA-constructors, though, right?  :-)Version 2 of this proposal was on the January 1989 ballot.        TITAN 
          TITAN 
        ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))            h              !      f       "                                          Š             —       6      °       
      ›              X              ì              x              &              C              œ              =                    ¾ !zº*start*04675 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JAN 89 01:14:07 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Jan 89  01:13:41 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 JAN 89 01:07:13 PSTDate: 8 Jan 89 01:06 PSTFrom: masinter.pato: cl-cleanup@sail.stanford.eduline-fold: NOcc: masinter.paSubject: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE (Version 3)Message-ID: <890108-010713-3036@Xerox>I shouldn't work on these things late at night....The discussion from Kim Barrett mentioned "supplied-p" arguments.I tried to think of uses of supplied-p arguments, and I thoughtthey were most useful in helping with some of the otherinitialization variables. So must supplied-p arguments nameslots? If not, are arguments allowed which don't name slotsbut are only used in the computation of &AUX or other &OPTIONAL or &KEY defaults? I'm guessing so and proposethis amendment which enhances the proposal.Let me know if you think this is a bad idea.!Forum:         CleanupIssue:         DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREReferences:    CLtL page 316Category:      CHANGEEdit history:  20-Sep-88, Version 1, Peck               21-Sep-88, Version 2, Masinter, minor revisions                8-Jan-89, Version 3, MasinterProblem description:Currently, DEFSTRUCT constructor functions can be either the defaultconstructor function, with *only* keyword arguments, or it can be a so-called "By Order of Arguments" constructor function with explicitly*no* keyword arguments.  Other functions in Common Lisp allow a freemix of required, optional, and keyword arguments. With the current restriction, it is necessary to hand code a function thatwill accept optional and keyword arguments and parse the supplied-pvariables explicitly.  Even so, it is not obvious to the casual programmerhow to provide the same semantics as defstruct does with respect to defaultvalues and the defstruct init-forms.Proposal: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE:ALLOW-KEYAllow &KEY keyword arguments in constructor forms of DEFSTRUCTsand the &ALLOW-OTHER-KEYS token in addition to the &OPTIONAL,&REST and &AUX arguments already allowed. Keyword arguments defaultin a manner similar to that of &OPTIONAL arguments: if no defaultis supplied in the lambda-list then the slot initform is used;otherwise the slot is not initialized -- its initial value isundefined.If keyword arguments of the form ((key var) [default [svar]])are specified, the "slot name" is matched with VAR (and not KEY).Additional arguments that do not correspond to slot names butare merely present to supply values used in subsequent initialization computations are allowed.Examples:It should be possible to write forms like this:(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)					    &key (d 2)					    &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))(create-foo 10) => #S(foo a 10 b 2 c sea d 2 e nil f eff)(create-foo 10 'bee 'see :d 'dee) => #S(foo a 10 b bee c see d dee e nil f eff)In the definition:(defstruct (frob (:constructor create-frob		(a &key (b 3 have-b) (c-token 'c) 		        (c (list c-token (if have-b 7 2))))))	a b c)the c-token argument is used merely to supply a value used in the initialization of the c slot. The "supplied-p" arguments ofkeyword arguments might be of this form.Rationale:This is a logical extension of the specification which makes someprogramming easier.Current practice:Many implementations signal an error if given &KEY arguments orarguments that are not slot names. The latest version of IIM Common Lisp allows &KEY arguments in this manner. Envos Medley(Xerox Common Lisp) implements the proposal. Cost to Implementors:The modifications to allow intermixed keywords and optionals in implementationsthat don't already are likely simple. Cost to Users:No cost, this is upward compatible.Cost of non-adoption:The current situation is non-intuitive and needless restrictive.Benefits:Much easier for users to write the constructor function they want.Probably implementation code would be reduced, since this would no longer be an error.Esthetics:Minor improvement since it removes a needless restriction.Discussion:Possibly  references to "By-position", "positional", and "By Order ofArguments" constructor function might need to be changed to something else inthe standard.  (They can still be called BOA-constructors, though, right?  :-)Version 2 of this proposal was on the January 1989 ballot.*start*04605 00024 US Date: 11 Jan 89 23:55 PSTSender: masinter.paSubject: Issue: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE (Version 3)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinterline-fold: NoSeveral people endorsed a proposed change from Kim Barrettto add &ALLOW-OTHER-KEY.This version does that, and also adds a possibly controversial feature of allowing arguments that don't name slots butare only used in the computation of other (default or &AUX)values.For discussion.Forum:         CleanupIssue:         DEFSTRUCT-CONSTRUCTOR-KEY-MIXTUREReferences:    CLtL page 316Category:      CHANGEEdit history:  20-Sep-88, Version 1, Peck               21-Sep-88, Version 2, Masinter, minor revisions                8-Jan-89, Version 3, MasinterProblem description:Currently, DEFSTRUCT constructor functions can be either the defaultconstructor function, with *only* keyword arguments, or it can be a so-called "By Order of Arguments" constructor function with explicitly*no* keyword arguments.  Other functions in Common Lisp allow a freemix of required, optional, and keyword arguments. With the current restriction, it is necessary to hand code a function thatwill accept optional and keyword arguments and parse the supplied-pvariables explicitly.  Even so, it is not obvious to the casual programmerhow to provide the same semantics as defstruct does with respect to defaultvalues and the defstruct init-forms.Proposal: DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE:ALLOW-KEYAllow &KEY keyword arguments in constructor forms of DEFSTRUCTsand the &ALLOW-OTHER-KEYS token in addition to the &OPTIONAL,&REST and &AUX arguments already allowed. Keyword arguments defaultin a manner similar to that of &OPTIONAL arguments: if no defaultis supplied in the lambda-list then the slot initform is used;otherwise the slot is not initialized -- its initial value isundefined.If keyword arguments of the form ((key var) [default [svar]])are specified, the "slot name" is matched with VAR (and not KEY).Additional arguments that do not correspond to slot names butare merely present to supply values used in subsequent initialization computations are allowed.Examples:It should be possible to write forms like this:(defstruct (foo (:constructor CREATE-FOO (a &optional b (c 'sea)					    &key (d 2)					    &aux e (f 'eff))))  (a 1) (b 2) (c 3) (d 4) (e 5) (f 6))(create-foo 10) => #S(foo a 10 b 2 c sea d 2 e nil f eff)(create-foo 10 'bee 'see :d 'dee) => #S(foo a 10 b bee c see d dee e nil f eff)In the definition:(defstruct (frob (:constructor create-frob		(a &key (b 3 have-b) (c-token 'c) 		        (c (list c-token (if have-b 7 2))))))	a b c)the c-token argument is used merely to supply a value used in the initialization of the c slot. The "supplied-p" arguments ofkeyword arguments might be of this form.Rationale:This is a logical extension of the specification which makes someprogramming easier.Current practice:Many implementations signal an error if given &KEY arguments orarguments that are not slot names. The latest version of IIM Common Lisp allows &KEY arguments in this manner. Envos Medley(Xerox Common Lisp) implements the proposal. Cost to Implementors:The modifications to allow intermixed keywords and optionals in implementationsthat don't already are likely simple. Cost to Users:No cost, this is upward compatible.Cost of non-adoption:The current situation is non-intuitive and needless restrictive.Benefits:Much easier for users to write the constructor function they want.Probably implementation code would be reduced, since this would no longer be an error.Esthetics:Minor improvement since it removes a needless restriction.Discussion:Possibly  references to "By-position", "positional", and "By Order ofArguments" constructor function might need to be changed to something else inthe standard.  (They can still be called BOA-constructors, though, right?  :-)Version 2 of this proposal was on the January 1989 ballot.     ----- End Forwarded Messages -----        
TIMESROMAN           TITAN 
          TITAN 
        ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))            >       !              „      J       "                                          Š             —       6      °       
      ›              X              ì              x              &              C              œ              =             !       )      ! #zº*start*00983 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 JAN 89 03:37:05 PSTReceived: from ECLA.USC.EDU by SAIL.Stanford.EDU with TCP; 14 Jan 89  03:36:28 PSTDate: Mon, 9 Jan 89 18:54:32 PSTFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: Issue DEFSTRUCT-CONSTRUCTOR-KEY-MIXTURE, v3To: cl-cleanup@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUMessage-ID: <12461308956.25.IIM@ECLA.USC.EDU>> Additional arguments that do not correspond to slot names but are merely> present to supply values used in subsequent initialization computations are> allowed. Actually, this wasn't what I had intended when I included [svar].  I wasassuming that svar would also have to match a slot name (and that's how Iimplemented it).  CLtL doesn't say anything about svars at all in DEFSTRUCTconstructors.  I think your proposal is probably more generally useful.kab-------