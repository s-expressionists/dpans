*start*03832 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 23 AUG 88 07:40:26 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 23 Aug 88  07:39:58 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 23 Aug 88 10:38:02 EDTTo: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUcc: cl-cleanup@sail.stanford.eduSubject: Re: Issue "Eliminate forced consing" re-visited In-reply-to: Your message of Mon, 22 Aug 88 21:39:05 -0700.             <8808230439.AA15416@trwrb.TRW.COM> Date: Tue, 23 Aug 88 10:37:55 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDULet me repeat and amplify the response I made to this proposal when itfirst came out.The destructive versions of the various sequence functions are ratherdangerous to use, and are the source of confusing and hard-to-find bugs incode written by people who don't appreciate these dangers.  On the otherhand, we are trying to produce and industrial-strength language here, andwe must provide users with SOME way to do non-consing operations onsequences.  The presence of DELETE in the language shows that were arewilling to accept the added complexity and danger when the only otherchoice is inefficiency.  The question is not whether the language shouldallow efficient, non-consing sequence operations, but how we can bestpackage them to reduce the danger.At present, the principal alternative to using CONS-intensive sequencefunctions is to write your own loops in an iterative style.  Unfortunately,we have poor tools for iterative programming.  I was not at the recentmeeting, but I believe that the iteration committee is now functioning andplans to propose a version of the LOOP macro as an addition to thestandard.  If this comes to pass, I believe that the sequence functionswill end up being used only for the simplest kinds of loops -- akind of shorthand that makes the programmer's intention clear in the mostcommon cases -- and that the more complex options in the sequence functionswill tend to atrophy from disuse.  If that is right, then it makes littlesense to add another layer of complexity to these things, just at the timewhen we are providing a decent alternative in the LOOP facility.I find that even without the LOOP facility, I tend to use the sequencefunctions only in simple ways, and move over to a DO loop if the situationbecomes at all complex.  The positive side of this is that I make fewermistakes in coding, because I'm telling the program exactly what I want itto do rather than guessing what the sequence function would do.  Withsequence functions, it is easier to see at a glance what the programmer istrying to do, but harder to tell if he's doing it exactly right.  I'm notsure if others share this preference, however.So I believe it comes down to two questions:1. Do we really believe that LOOP or something very close to it will beadopted in the near future?2. Do we believe that if the LOOP facility were part of the standard, itwould provide a better way of writing complex, non-consing loops than wouldbe provided by the sequence functions augmented with :TARGET or whatever?If the answer to both questions is yes, then it makes no sense to put inthis target stuff right now.  Were it not for the problem of breakingexisting code, we might even want to eliminate some of the more complexoptions from the existing sequence functions.  On the other hand, if theanswer to either question is no, then :TARGET or something like it shouldgo in.I'd be interested in hearing opinions on this from the people who have beenusing LOOP heavily, and also any informed views on when and whether we canexpect a proposal on improved iteration machinery.-- Scott*start*02601 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 23 AUG 88 08:20:03 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 23 Aug 88  08:19:29 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA00525; Tue, 23 Aug 88 11:19:14 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA12481; Tue, 23 Aug 88 11:20:55 EDTMessage-Id: <8808231520.AA12481@mist.UUCP>To: "trwrb!smpvax1!jrg@ucbvax.Berkeley.EDU"@multimax.ARPACc: cl-cleanup%sail.stanford.edu@Multimax.ARPASubject: Re: Issue "Eliminate forced consing" re-visited In-Reply-To: Your message of Mon, 22 Aug 88 21:39:05 -0700.             <8808230439.AA15416@trwrb.TRW.COM> Date: Tue, 23 Aug 88 11:20:52 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>I support the general idea of this proposal.  It fits in our charter,fills a real need, and is well enough specified to be considered.However, the form of the proposal needs some more work.- The name should probably be changed to something like  "SEQUENCE-FUNCTION-CONSING" to come to fit our naming convention.  As Larry said about another recent proposal, I doubt that you  could find "ELIMINATE" in CLtI and even you could it probably  wouldn't point to sequence functions.- I'd suggest "SEQUENCE-FUNCTION-CONSING:TARGET-KEYWORDS" as a  proposal name.- The proposal text should be rewritten as if it were the new parts  of the manual/standards document.  I'd certainly understand some  abbreviation to keep from having to rewrite the whole sequence  chapter and a large part of the list chapter.- The CONCATENATE and APPEND additions should either be moved into  the proposal section or into a second issue (which I would probably  also support).All-in-all, this has moved from what I remember as more a philosophicalstatement than a cleanup proposal to something that I think we can,and should, pass unless we are prepared to "depreciate" the sequencefunctions entirely.The main objection to this proposal seems to be Scott's belief thatLOOP can and will replace the sequence functions for most purposes.  Ihalf agree in that: while I don't think replacing sequence functions byLOOP is a good thing, I do think that replacing them by OSS would begood.  The critical difference is that OSS provides the functionalview of these operations that is important for some programmingstyles.  You could say that it comes back down to C versus Lisp again;if I have to write everything as DO-loops, why am I using Lisp?*start*02903 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 23 AUG 88 11:15:03 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 23 Aug 88  11:13:52 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa04760; 23 Aug 88 18:41 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Tue, 23 Aug 88 18:59:01 BSTMessage-Id: <29596.8808231759@subnode.aiai.ed.ac.uk>To: trwrb.uucp!smpvax1!jrg@ucbvax.berkeley.edu, pierson <@multimax.arpa:pierson@mist>Subject: Re: Issue "Eliminate forced consing" re-visitedCc: cl-cleanup@sail.stanford.edu> Date: Tue, 23 Aug 88 11:20:52 EDT> From: "Dan L. Pierson" <pierson%mist@arpa.multimax>> However, the form of the proposal needs some more work.> - The proposal text should be rewritten as if it were the new parts>   of the manual/standards document.  I'd certainly understand some>   abbreviation to keep from having to rewrite the whole sequence>   chapter and a large part of the list chapter.Really?  Do we supposedly even know what the format is yet?> All-in-all, this has moved from what I remember as more a philosophical> statement than a cleanup proposal to something that I think we can,> and should, pass unless we are prepared to "depreciate" the sequence> functions entirely.I think that is going a bit far.  Surely the sequence functions arenot nearly useless without this change.  (Recall, for example, thatsome of them just search.)I would be interested in an informed opinion on how much of theexcess allocation can be eliminated by soemthing like OSS and howmuch still requires destructive operations.  I also wonder whetherOSS-like optimizations could be added to ordinary CL compilers forsome class of operations involving the normal sequence functions.> The main objection to this proposal seems to be Scott's belief that> LOOP can and will replace the sequence functions for most purposes.I do not thing LOOP will really do this.  Think of concatenation.It's much easier to call CONCATENATE than to write the loop, soone would probably end up writing a destructive procedure withLOOP inside it rather than using LOOP directly.BTW, one useful weapon in the war against C would be the ability toread n characters into a buffer (string?, array?, I don't care).It's a pain to scan a file allocating a string for every READ-LINE.Destructive READ-LINE might do, I suppose.  It also would be useful(as was suggested in the proposal) to be able to refer to asubsequence without actually extracting it.  DESIGNATE-SUBSEQ can probably be written in CL (sort of like locatives are writtenin T), but not efficiently (and you couldn't have the normalsequence functions work on them (except maybe via CLOS)).-- Jeff*start*04410 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 23 AUG 88 11:58:23 PDTReceived: from multimax.ARPA by SAIL.Stanford.EDU with TCP; 23 Aug 88  11:57:48 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA03620; Tue, 23 Aug 88 14:57:44 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA12684; Tue, 23 Aug 88 14:59:25 EDTMessage-Id: <8808231859.AA12684@mist.UUCP>To: Jeff Dalton <"jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK"@multimax.ARPA>Cc: cl-cleanup%sail.stanford.edu@Multimax.ARPASubject: Re: Issue "Eliminate forced consing" re-visited In-Reply-To: Your message of Tue, 23 Aug 88 18:59:01 -0000.             <29596.8808231759@subnode.aiai.ed.ac.uk> Date: Tue, 23 Aug 88 14:59:23 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>    > All-in-all, this has moved from what I remember as more a philosophical    > statement than a cleanup proposal to something that I think we can,    > and should, pass unless we are prepared to "depreciate" the sequence    > functions entirely.        I think that is going a bit far.  Surely the sequence functions are    not nearly useless without this change.  (Recall, for example, that    some of them just search.)    Sorry, I don't mean that the sequence functions are useless withoutthis change.  "Depreciate" is a technical term from some otherlanguage standard (Fortran?) that means the feature is left in thisversion of the language but may (will?) be removed in a futureversion.  My point was that if we consider the sequence functions adesirable part of the language, this enhancement is worthwhile.  If wedon't want to enhance them because we expect them to become obsoletewe should also make that clear.    I would be interested in an informed opinion on how much of the    excess allocation can be eliminated by soemthing like OSS and how    much still requires destructive operations.  I also wonder whether    OSS-like optimizations could be added to ordinary CL compilers for    some class of operations involving the normal sequence functions.    The only class of OSS functions that have to cons are some of thereducers (I don't believe that anything else does cons at run time,but haven't gone over the source to make sure).  For example:Rlist items  => list  This function creates a list of the elements in items in order.This could easily be extended to:Rlist items &optional list  => list  This function creates a list of the elements in items in order.  If  an optional list is supplied the items are placed in it ...,  otherwise a new list is created.There are only two sequence functions not supported by OSS: REVERSE,and SORT (and their variants).  As I understand it, the problem withsupporting OSS by compiler optimization with no extensions is thatefficient compilation of compositions of OSS functions depends onadherence to a specific set of constraints.  The OSS package checksfor and either corrects or signals violations of these constraints.For example (using some examples from part one of Dick's manual): This works:   (OR (Rfirst (Tpositions (EQ ITEMP (Elist UNIVERSE)))) This doesn't work:  (letS* ((VALUES (Evector VALUE-VECTOR))          (WEIGHTS (Evector WEIGHT-VECTOR))	  (SQUARES (* VALUES VALUES))          (WEIGHTED-SQUARES (* SQUARES WEIGHTS)))    (LIST (Rvector SQUARES) (Rvector WEIGHTED-SQUARES))) This works:  (letS* (((VALUES WEIGHTS) (Tcotruncate (Evector VALUE-VECTOR)			                 (Evector WEIGHT-VECTOR)))	  (SQUARES (* VALUES VALUES))          (WEIGHTED-SQUARES (* SQUARES WEIGHTS)))    (LIST (Rvector SQUARES) (Rvector WEIGHTED-SQUARES)))It seems likely that an "ordinary CL compiler" could support someOSS-style optimization, but it would probably be restricted to a muchsmaller subset of compositions of sequence operations than OSS.  Itwould also be harder for a compiler to deal with cases it couldn'toptimize because, since the programmer hadn't declared any intent, thecompiler would be unable to distinguish between normal code to whichan optimization didn't apply and a programmer error that prevented anintended optimization.  For these reasons, I think that something likeOSS is needed.  However anything accepted in CL should certainly fitbetter into the CL naming world.  *start*01245 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 23 AUG 88 23:08:26 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Aug 88  23:08:11 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 23 AUG 88 23:05:42 PDTFrom: masinter.PADate: 23 Aug 88 23:04:02 PDTSubject: Re: Issue "Eliminate forced consing" re-visitedIn-reply-to: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDU's message of Mon, 22 Aug 88 21:39:05 PDT, <8808230439.AA15416@trwrb.TRW.COM>To: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUcc: cl-cleanup@sail.stanford.EDUMessage-ID: <880823-230542-1393@Xerox>I've not been as quick as I should have; the issue name should be something likeSEQUENCE-FUNCTIONS-CONSING and the proposal name something likeSEQUENCE-FUNCTIONS-CONSING:ADD-TARGET.It might help if you were prepared to offer a portable implementation of thesefunctions. Do you have evidence that they are implementable efficiently? The discussion section is much too long. We've opted for terseness, its helped,and will be especially important if we have as many issues as I hope we will.Can the main points be summarized, in outline form?*start*01302 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 23 AUG 88 23:17:34 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 23 Aug 88  23:17:37 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 23 AUG 88 23:12:43 PDTFrom: masinter.PADate: 23 Aug 88 23:11:02 PDTSubject: Re: Issue "Eliminate forced consing" re-visitedIn-reply-to: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Tue, 23 Aug 88 10:37:55 EDTTo: Scott.Fahlman@B.GP.CS.CMU.EDUcc: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDU, cl-cleanup@sail.stanford.EDUMessage-ID: <880823-231243-1402@Xerox>What do you think about the possibility of putting (some/all/most) of thesequence functions and also the iteration macros in the same category of"required library"? The category is that: any conforming implementation of the standard must providethem. However, they are only available to programs that REQUIRE them. So, if youwant to use LOOP, you must say (require "LOOP"). If you want to use sequencefunctions, you must say (require "SEQUENCE") or some such.The reason is that it reduces the size of the mimimal image, but allows programsto assume that the facilities are available if they're really needed. *start*03263 00024 US Return-Path: <Scott.Fahlman@sef1.slisp.cs.cmu.edu>Received: from SEF1.SLISP.CS.CMU.EDU ([128.2.218.13]) by Xerox.COM ; 24 AUG 88 08:07:13 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 24 Aug 88 11:06:24 EDTTo: masinter.PAcc: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDU, cl-cleanup@sail.stanford.EDUSubject: Re: Issue "Eliminate forced consing" re-visited In-reply-to: Your message of 23 Aug 88 23:11:02 -0700.             <880823-231243-1402@Xerox> Date: Wed, 24 Aug 88 11:06:09 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU    What do you think about the possibility of putting (some/all/most) of the    sequence functions and also the iteration macros in the same category of    "required library"?     I don't see what this suggestion buys us.  If these modules are notrequired to be provided by every implementation, then they can't be used inportable code.  If they are required, as you are proposing, then theimplementors have to do the work and the library modules aresitting out there taking up disk space.  Implementations are already freeto provide a GC-for-delivery facility that flushes everything not requiredby a given application; they are also free to provide an autoload facilitythat doesn't load this stuff until someone touches it.  All your proposaldoes is to replace this autoload with an explicit require, hassling theuser.Furthermore, I think that if both iteration and sequence libraries arestandardly available, both will be used to some extent and both librarieswill almost always be loaded.  The problem is that you don't want to dragin the version with all the hairy optimizers for obscure cases just becausethe user happened to call MEMBER.  If you're going to play thisminimal-core game, you want to partition these packages and drag in onlythe relevant chunks.  I suspect that sooner or later this business ofcreating minimal core images for delivery of finished applications willbecome an area of competition among the vendors.  We don't want toforeclose their options by mandating a single crude partioning.My objection to including both a LOOP facility and further extensions tothe sequence functions had nothing to do with core image size; the cost Iwas worried about was the added conceptual load on the user of learning twodistinct ways of doing the same thing, both of which are rather complex anddangerous for the careless.By the way, I don't really buy Ginder's argument that the :target extensionis good because it will force people teaching Common Lisp to mentionconsing issues.  I think they will either do that or not, depending on theinterests of the teacher and the goals of the course.  Having some obscurekeyword in the language that drags this in will not make a difference invery many cases.  DELETE is already present, so if Ginder were right, theproblem is already solved.However, I do put some weight on his comments about people preferring touse the sequence functions even when a good iteration facility ispresent, largely because it makes it clear what the program is trying todo.  If others agree with this observation, I'm ready to support thisproposal in principle, though some details need to be fixed up.-- Scott*start*00888 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 21 JUL 88 12:08:56 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 436667; Thu 21-Jul-88 15:08:59 EDTDate: Thu, 21 Jul 88 15:08 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: proposal: eliminate forced consingTo: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <8807202200.AA15976@trwrb.TRW.COM>Message-ID: <880721150829.8.KMP@PEWEE.SCRC.Symbolics.COM>[Others removed.]I assume we're going to call this issue ELIMINATE-FORCED-CONSING.We should document somewhere the convention about issue namesbeing suitable file names (and the somewhat less importantconvention about the first word trying to be some indexed item in CLtL).*start*01000 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 12:11:45 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 21 Jul 88  12:11:27 PDTReceived: from PEWEE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 436665; Thu 21-Jul-88 15:07:09 EDTDate: Thu, 21 Jul 88 15:06 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: proposal: eliminate forced consingTo: trwrb!smpvax1!jrg@ucbvax.berkeley.educc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8807202200.AA15976@trwrb.TRW.COM>Message-ID: <880721150632.7.KMP@PEWEE.SCRC.Symbolics.COM>Or we might just use the type argument and the new CLOS type EQL: (LET ((X (MAKE-STRING 3 :INITIAL-ELEMENT #\a)))   (EQ (MAP `(EQL ,X) #'CHAR-UPCASE X) X)):-)[I have not yet formulated a serious opinion on this issue.]*start*12602 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 20 JUL 88 17:54:50 PDTReceived: from ucbvax.berkeley.edu by SAIL.Stanford.EDU with TCP; 20 Jul 88  17:51:41 PDTReceived: by ucbvax.berkeley.edu (5.59/1.28)	id AA09616; Wed, 20 Jul 88 15:56:24 PDTFrom: trwrb!smpvax1!jrg@ucbvax.berkeley.eduReceived: by trwrb.TRW.COM (5.51/1.36)	id AA15976; Wed, 20 Jul 88 15:00:44 PDTDate: Wed, 20 Jul 88 15:00:44 PDTMessage-Id: <8807202200.AA15976@trwrb.TRW.COM>To: cl-cleanup@sail.stanford.eduSubject: proposal: eliminate forced consingIssue:         ELIMINATE FORCED CONSINGReferences:    CLtL section 14.1,3,5; 15.2,5; 17.4; 18.3; 21.2Category:      ADDITIONEdit history:  Version 1, 20-Jul-88, GinderProblem description:The sequence functions included in CLtL encourage a programming stylethat causes excessive storage allocation compared to libraries ofroutines with similar functionality in other languages, notably C.The only options available to the Common Lisp programmer who usesthese functions are to generate a newly-allocated sequence or todestructively modify the argument sequence(s) given the function.Proposal:Add a :TARGET keyword argument to those sequence functions where such anargument is useful, as specified below, which allows passing a targetargument sequence into which the result of the sequence computation isto be placed.  The sequence function returns the target sequencemodified as specified below:	(1) The target sequence must accomodate elements of the type(s)	in the source sequence.  Thus it would be an error to give a	target string argument if the source sequence had elements that	were not of type STRING-CHAR.	(2a) A non-list target sequence should have an allocated length	long enough to accomodate the normal result of the sequence	function.  It is permissable for the target sequence to have a	fill pointer; in this case, the fill pointer is set to point	immediately after the last element filled in by the sequence	computation.  If the target sequence is longer than necessary,	the unneeded trailing elements are unchanged.	(2b) A list target sequence argument is extended with new conses	to be as long as necessary to accomodate the resulting sequence,	if not enough conses are supplied and the :TARGET-FROM-END keyword	is nil.  The tail of the target list sequence not used to	accomodate the sequence computation is returned as a second	value by the sequence function, but remains linked as the tail	of the target sequence.  [It might be desirable to return a	third value, the last cons of the part of the list used for	the result sequence, permitting the programmer to null-terminate	that part of the target sequence, breaking the link with the	unused tail, if appropriate.]	(3) A :TARGET-FROM-END keyword is supported.  If non-nil, the	target sequence is filled with new elements starting at the	end of the target seqeunce, effectively reversing the order of	elements of the resulting sequence in the target.  In this case,	an error is signalled if the target sequence is not long enough	for the result.  If the target sequence is longer than necessary,	leading elements are unchanged.	(4) :TARGET-START and :TARGET-END keywords are supported.	TARGET-START and TARGET-END determine where in the target	sequence the result of the sequence computation is placed.	An error is signalled if the sub-length of the target	sequence specified by these arguments is not long enough to	accomodate the resulting sequence computation.  If a longer	than necessary sub-length is specified, then the elements in	the unneeded part of the specified sub-length are unchanged.Affected sequence functions:	subseq, copy-seq, reverse, remove, remove-if, remove-if-not,	remove-duplicates, substitute, substitute-if, substitute-if-not,	mergeAffected list functions:	copy-list, butlast	copy-alist, copy-tree, adjoin, union, intersection, set-difference,	set-exclusive-or 	  [no TARGET-START/END or TARGET-FROM-END, just destructive	   use of the :TARGET conses]Affected string functions:	string-trim, string-left-trim, string-right-trim, string-upcase,	string-downcase, string-capitalize Examples:(copy-seq '(1 2 3) :target '(a b c d e f g))	=> (1 2 3 d e f g)(copy-seq '(1 2 3) :target '(a b c d e f g) :target-from-end t :end 5)	=> (a b 3 2 1 f g)(remove 'a '(b b a b b a b b a b b) :count 1 :target '(3))	=> (b b b b a b b a b b)   ; EQ to :TARGET arg, CDR is new conses.;;; Note, the :TARGET arg has a fill pointer.(substitute #\a #\b "This is a string with 2 a's"	    :target "0123456789012345678901234567890123456")	=> "This is b string with 2 b's"In a related addition, provide extended versions of concatenate, append,revappend, and make-string-output-stream as follows:	concatenate-into target &rest sequences	  Like CONCATENATE, but the result type is determined to be	  the type of TARGET.  The result is TARGET containing as many	  of the elements of SEQUENCES as can be accomodated by the	  allocated length of TARGET.  TARGET's fill pointer, if	  present is set according to how many elements of TARGET ar	  filled by this operation.	concatenate-into-subseq target start end &rest sequences	  Like concatenate-into, but copied from SEQUENCES into	the	  sub-sequence of TARGET specified by START and END.	append-into target &rest lists	  Like APPEND, but the copied list arguments are copied into	  conses taken from TARGET.  The last list in LISTS	  is not copied, as in APPEND, rather, the last cons used	  from TARGET is given the last list in LISTS as its cdr.	  The result is EQ to TARGET (unless a single list is appended),	  but contains only those conses needed to hold the appended	  lists' elements.  The tail of unused conses from TARGET is	  returned as a second value; new conses are allocated if	  TARGET supplies an insufficient number of conses.	revappend-into target x y	  Like REVAPPEND, but the new conses are taken from TARGET.	  The result is EQ to TARGET, but contains only those conses	  needed to hold X's elements.  The tail of unused conses	  from TARGET is returned as a second value; new conses are	  allocated if TARGET supplies an insufficient number of conses.	make-string-output-stream &optional string	  Like the current MAKE-STRING-OUTPUT-STREAM, except if STRING	  is provided, make the string-stream write to it rather than	  a newly-allocated string.  An error is signalled if the output	  overflows the supplied string.A related optimization that compilers should be encouraged to supportis to recognize:   (concatenate 'string (subseq ...) (subseq ...) (subseq ...) ...)as being optimizable so as to avoid the allocation of storage forintermediate SUBSEQ results.  This is a very common programming idiomthat can, of course, be expressed using the proposed extensions to avoidintermediate consing.  However, the extensions do not provide as conciseand readable a mechanism for re-espressing this idiom as may others.Other extensions might be considered to address this:	(1) Provide a CONCATENATE function that takes a &rest	argument of sequence/start/end triples.	(2) Provide a special form like:	       (designate-subseq sequence start end)	that didn't actually allocate anything but provided an imple-	mentation-specific "handle" on the subsequence for use	in such expressions as the CONCATENATE expression above.	(They'd print as the subseq, and setf's of their elements	would destructively modify the original sequence.)	However, there is no precedent in CLtL for (1).  And (2) seems like acomplex, sweeping change (for implementors) of limited benefit somewhatin conflict (though more general than) displaced arrays.  So I don'twant to propose either.Rationale:It is sometimes better to use a more complex programming construct forsake of efficiency than to use a less complex, more expensive one.Excessive storage allocation is one of Lisp's most widely publicized andleast understood faults.Current practice:Similar functionality is provided for bit-vectors, as specified in CLtL17.4.  A related capability is provided in the destructive versions ofsome of the functions extended above.When functionality similar to this is required, users must "roll theirown".  My experience in several commercial Lisp applications is thatavoiding storage allocation by using programming techniques such as thismay be critical to the success of a project.  The current sequence,list, and string functions encourage an "expensive", albeit easier touse, programming style that invites the creation of programs whoseperformance suffers greatly in comparison to a program written to solvethe same problem written in C.Cost to Implementors:The cost of implementation of these extra sequence function arguments issignificant, but would not be burdensome compared to the utilityprovided.  (In my humble opinion, of course.)Cost to Users:No cost, this is upward compatible.Cost of non-adoption:I submit that the cost of NOT implementing this sort of functionality isthat Common Lisp deserves the reputation it is rapidly gaining of beingvery expensive to use, not in programmer productivity, but in theresources required by the resulting programs.  While it is certainlyeasier to write programs that always allocate new storage for results,it is very expensive compared to what average programmers write in otherlanguages.  Sometimes the correct trade-off is to invest the extraprogramming effort in development of a product in exchange for thelowered resource requirements in the delivered system.  This isparticularly true when the deployed Lisp application may have thousandsof instances.  It may well be worth several extra man-years of effort touse facilities such as those mentioned above rather than pay theincreased cost of deployment thousands of times!  (These costs are inthe form of more expensive hardware for deployment.  This might be dueto higher memory requirements or larger disk space requirements tosupport a large virtual memory image.) If Common Lisp does not providethis capability; programmers under serious performance constraints willchoose a different tool.Benefits:Those programmers choosing to invest the extra effort needed tocorrectly use such facilities can do so with less overhead thanpreviously required, and will see performance improvement.  Programmerslearning Common Lisp will be challenged to understand the differencebetween allocating new storage and re-using old storage as theyunderstand why these arguments are supported.  This is one of the chiefproblems that most programmers encounter as they write Lisp programs.I've encountered MANY occurances of this problem in helping people whoare trying to write Lisp programs as part of a real-world applicationthat is intended to be delivered on hardware for which someone must payreal $$.  The problem encountered is that the program is too slow, orrequires hardware too expensive for practical deployment.  The mostcommon result is that the programmer gives up, proclaiming that Lisp istoo slow or too resource intensive, and rewrites his program in C.Although these enhancements alone are not sufficient to solve the citedproblem, something along these lines is necessary as part of a morecomplete solution that might include better training of Lispprogrammers, stack consing, and ephemeral GC.  The real benefit ofadopting this extension to sequence functions and similar extensions isan increased chance of survival for Lisp as a viable tool for creatingdeliverable applications.Esthetics:This proposal is likely to cause flames from the "functionalprogramming" camp (unless they've all left for Scheme).  It isconsistent (syntactically) with the existing keyword arguments tosequence functions.  It adds to the plethora of keyword arguments alreadypresent for many of these functions.Discussion:I'd likely tolerate any sort of statements in the new CL manual warningnaive users of the dangers of this programming style.  I agree that itcan be mis-used; but sometimes the benefit is worth the risk.  I simplywant Common Lisp to provide the choice.Would adoption of these arguments eliminate the need for paralleldestructive versions for some of the affected functions?  (E.g., doesREMOVE with a :TARGET argument eliminate the need for DELETE.)--Joe Ginder, Inference*start*00925 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 21 JUL 88 06:45:30 PDTReceived: from SEF1.SLISP.CS.CMU.EDU ([128.2.218.13]) by SAIL.Stanford.EDU with TCP; 21 Jul 88  06:43:27 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 20 Jul 88 23:12:33 EDTTo: trwrb!smpvax1!jrg@ucbvax.berkeley.educc: cl-cleanup@sail.stanford.eduSubject: Re: proposal: eliminate forced consing In-reply-to: Your message of Wed, 20 Jul 88 15:00:44 -0700.             <8807202200.AA15976@trwrb.TRW.COM> Date: Wed, 20 Jul 88 23:12:29 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUI wonder if anyone would use this TARGET stuff once we have a gooditeration facility built into the language.  I suspect that the existingsequence functions will end up being used only in very straightforwardcases.-- Scott*start*05957 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 27 AUG 88 11:11:59 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Aug 88  11:11:40 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 451384; Sat 27-Aug-88 14:10:15 EDTDate: Sat, 27 Aug 88 14:10 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue ELIMINATE FORCED CONSING (Version 2)  [formerly "Eliminate forced consing" re-visited]To: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUcc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8808230439.AA15416@trwrb.TRW.COM>Message-ID: <19880827181012.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 22 Aug 88 21:39:05 PDT    From: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUI think this is a reasonable proposal that needs a bit more work and somesimplification.  One can argue about whether it's better to provide thesestorage reusing operations or to provide a good garbage collector, but Ithink it makes a great deal of sense, in the context of Common Lisp, toprovide both.I think the name :OVERWRITE would be more consistent with the rest ofCommon Lisp than the name :TARGET.  It makes it clearer that thisargument is storage to be overwritten with new information.When you say    (1) The target sequence must accomodate elements of the type(s) in the    source sequence.I believe this is wrong.  It should refer to the type of the elements of the-result- of the function, not the source.I don't understand the need for the :TARGET-FROM-END feature and I thinkyou should drop it from the proposal.    The last cons of the target list whose CAR was filled by the computation is    returned as a second value.  The CDR of this cons is that tail of the    target list not used to accomodate the sequence computation.I think this feature is unnecessary and should be discarded.  I thinkextra conses should simply be thrown away.  Most people exploiting thisnon-consing feature are more likely to use vectors than lists, I feel.If the feature is kept, the second value should be the cdr of what youpropose it to be, and the result should be null-terminated in thecorrect place; that should not be left to the caller to do.Another idea would be to allow the user to pass in a function that iscalled whenever storage is to be allocated.  Perhaps it would take twoarguments and the default would be #'APPLY.  The first argument wouldbe one of #'CONS, #'MAKE-LIST, or #'MAKE-ARRAY, the second argumentwould be a list of arguments with dynamic extent.  I'm not real fondof this idea, but it does provide maximum generality.    (4) :TARGET-START and :TARGET-END keywords are supported.These seem useful but should be named :OVERWRITE-START and :OVERWRITE-END.The functions SUBSEQ, COPY-SEQ, COPY-LIST, and BUTLAST need not bemodified, because the functionality is already available from REPLACE.The functions COPY-ALIST and COPY-TREE should not be modified, becausetheir use of storage is too complex to fit into this model (they don'tdeal in linear sequences).  The function ADJOIN should not be modified,because a non-consing version is trivial for a user to write, andbecause the consumption of storage is conditional, which wouldcomplicate the interface.I don't think UNION, INTERSECTION, SET-DIFFERENCE, and SET-EXCLUSIVE-ORshould be modified, because their conditional consumption of storagewould complicate the interface (unused storage has to be handed back tothe caller) and because the destructive versions that already exist cansolve the same problem, in my experience.  (They aren't completelynon-consing, but they minimize consing.)  You forgot to mention SUBST,but I think the same reasoning applies and SUBST should not be modified.This leaves REVERSE, MERGE, REMOVE, REMOVE-IF, REMOVE-IF-NOT,REMOVE-DUPLICATES, SUBSTITUTE, SUBSTITUTE-IF, SUBSTITUTE-IF-NOT,STRING-TRIM, STRING-LEFT-TRIM, STRING-RIGHT-TRIM, STRING-UPCASE,STRING-DOWNCASE, STRING-CAPITALIZE.  I think it's reasonable tomodify these in the way you suggest.  Doing just these makes fora much simpler proposal that is easier to understand.MAKE-STRING-OUTPUT-STREAM should follow the same rules asWITH-OUTPUT-TO-STRING when a string is supplied, instead ofthe different rule you suggested.  With that change to make itconsistent, I support what you propose.This leaves CONCATENATE, APPEND, REVAPPEND, and MAP (which you forgot,but which has been discussed in the past), which take &rest argumentsand therefore are a problem.  I don't think the -into-subseq version isuseful enough to justify the extra complexity.  I also don't think theextra complexity of allowing the caller to pass in too many conses toAPPEND and REVAPPEND and get back the unused ones as a second value isjustified.  In fact, I think I would prefer to omit APPEND-INTO from theproposal (CONCATENATE-INTO and NCONC should suffice) and therefore toomit REVAPPEND-INTO also.  I support CONCATENATE-INTO and MAP-INTO.Current practice:  Symbolics Common Lisp already has MAP-INTO.	    (2) Provide a special form like:		   (designate-subseq sequence start end)	    that didn't actually allocate anything but provided an imple-	    mentation-specific "handle" on the subsequence for use	    in such expressions as the CONCATENATE expression above.	    (They'd print as the subseq, and setf's of their elements	    would destructively modify the original sequence.)	This is identical to displaced arrays, unless you propose it to workfor lists as well, in which case it is nearly unimplementable.  I thinkit should be dropped.I'd support your proposal if you simplify it more or less along the linesI suggested.  I don't support version 2 because there is too much in it.*start*02948 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 25 AUG 88 10:58:35 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 25 Aug 88  10:55:36 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa05999; 25 Aug 88 18:16 BSTFrom: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Date: Thu, 25 Aug 88 18:39:00 BSTMessage-Id: <16024.8808251739@aiai.ed.ac.uk>To: pierson <@multimax.arpa:pierson@mist>Subject: Re: Issue "Eliminate forced consing" re-visitedCc: cl-cleanup@sail.stanford.edu> Date: Tue, 23 Aug 88 14:59:23 EDT> From: "Dan L. Pierson" <pierson%mist@arpa.multimax>>     >    > and should, pass unless we are prepared to "depreciate" the sequence>    > functions entirely.>   >    I think that is going a bit far.  Surely the sequence functions are>    not nearly useless without this change.>> Sorry, I don't mean that the sequence functions are useless without> this change.  "Depreciate" is a technical term [...]  the feature [...]> may (will?) be removed in a future version.  If we don't want to enhance> them because we expect them to become obsolete we should also make that> clear.I don't see how this explanation invalidates my point.  This change isnot: something we should pass unless we think the sequence functions areobsolete/perhaps-subject-to-removal anyway (and so not worth bothering toimprove).  That is, we might think the sequence functions are worth havingand still not want this change.> As I understand it, the problem with supporting OSS by compiler> optimization with no extensions is that efficient compilation of> compositions of OSS functions depends on adherence to a specific set> of constraints.  The OSS package checks for and either corrects or> signals violations of these constraints.[I don't insist on *no* extensions.]> It seems likely that an "ordinary CL compiler" could support some> OSS-style optimization, but it would probably be restricted to a much> smaller subset of compositions of sequence operations than OSS.Why is this?  It can detect the cases where the constraints aren'tmet.  Isn't this the same as recognizing the cases where they can bemet?  OK, it can't "correct" any cases that violate the constraints.How much depends on corrections?> It would also be harder for a compiler to deal with cases it couldn't> optimize because, since the programmer hadn't declared any intent, the> compiler would be unable to distinguish between normal code to which> an optimization didn't apply and a programmer error that prevented an> intended optimization.All that this seems to amount to is that the compiler can't signal anerror: all it can do is not make the optimization.  But that's whatcompilers normally do when they can't make an optimization.*start*04270 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 23 AUG 88 17:45:30 PDTReceived: from ucbvax.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 23 Aug 88  16:50:43 PDTReceived: by ucbvax.Berkeley.EDU (5.59/1.30)	id AA07440; Tue, 23 Aug 88 16:46:32 PDTFrom: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUReceived: by trwrb.TRW.COM (5.51/1.36)	id AA07858; Tue, 23 Aug 88 16:18:22 PDTDate: Tue, 23 Aug 88 16:18:22 PDTMessage-Id: <8808232318.AA07858@trwrb.TRW.COM>To: cl-cleanup@sail.stanford.edu, fahlman@c.cs.cmu.eduSubject: loop vs. sequence functionsAt Inference, we've been using an iteration facility based on the Interlispiterator facility heavily for several years.  We provide a public, supportedversion of this to our customers as part of ART, our expert system buildingtool.  The iterator facility is much like the LOOP facility, to my under-standing, though I believe that the LOOP facility may clean up a few of theless-clean aspects of using iterators.  My point is that we've had a largeuser base writing Common Lisp programs in an environment where a good iterationfacility is available.  They still use sequence functions.  Many write iterations, but almost all use sequence functions in addition, often inpreference to iteration.  Sometimes this is based on the judgement that thesequence functions are easier to read.  Sometimes this is based on the(almost always mistaken) belief that the Lisp compiler will turn a sequenceoperation with appropriate declarations into better code than the iterationexpands into.  More often the reason is the former, for sake of clarity.I'm arguing that in our experience, a good iteration facility did not eliminateuse of the sequence functions (else I wouldn't have proposed the :targetargument).In addition, I have another motive in this.  Part of the problem is one ofeducation.  People take courses that teach them Common Lisp syntax.  Thesecourses rarely teach how to write reasonably efficient programs -- at leastthe students don't come away able to write efficient programs.  These coursestend to focus on teaching what Common Lisp functions do and what the variousarguments are used for, then ask students to write programs using them toshow that they understand the explanation.  They usually don't get intoperformance considerations to any significant degree.  Perhaps if we addeda :target argument for re-using conses, it would be taught and explained asa way to avoid consing were that is appropriate.  This would provide atangible syntactic mechanism that would be taught and explained in a mannerthat made it clear to students that storage was being allocated when sequencefunctions are used in the straightforward manner versus when the :targetargument was used.  Granted, this depends on the structure of the course,etc, but at least there would be some piece of syntax that could be matchedwith teaching this important concept.Another part of the proposal was sort of an addendum to address this sameissue in non-sequence, list, or string functions.  This part of the proposalhas parts that are analogous to the :target argument and thus either redundantor not based on the expected utility of LOOP.  But other parts would not beaddressed by LOOP, namely the make-string-output-stream function.Just to throw some fuel onto the fire, an alternative to the :target argumentwould be to support a FREE-SEQUENCE function that returned a sequence to Lispfor later re-use.  When the Lisp could make use of this previously-allocatedstorage rather than cons new storage, it would, particularly in the sequence,list, and string functions in preference to new allocation.  The advantageto this is that it adds less syntactic baggage to the language.  The dis-advantage is that is makes it less obvious where the underlying implementa-tion is re-using storage, leaving much to the implementation.  For productssuch as ART, which are marketed as minimizing the need for garbage collection,this might pose a problem since we need to be very sure that the implementationis re-using storage as much as possible.  Of course, we could have both...*start*01711 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 24 AUG 88 21:12:19 PDTReceived: from ucbvax.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 24 Aug 88  21:11:27 PDTReceived: by ucbvax.Berkeley.EDU (5.59/1.31)	id AA06670; Wed, 24 Aug 88 20:17:10 PDTFrom: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUReceived: by trwrb.TRW.COM (5.51/1.36)	id AA04491; Wed, 24 Aug 88 20:13:32 PDTDate: Wed, 24 Aug 88 20:13:32 PDTMessage-Id: <8808250313.AA04491@trwrb.TRW.COM>To: cl-cleanup@sail.stanford.eduSubject: brief summary of issue "Eliminate Forced Consing"Common Lisp programmers need a way of specifying already-allocated datastructures as the source of sequence, list, and string computations.Allow this via use of a :target keyword argument for those functionswhere this is useful.  The TARGET argument should be a sequence of theappropriate type which is filled in with the result of the computationThis is returned rather than a newly-allocated data structure.  Theproposal also mentioned a couple of analogous additions to allow similarspecification of storage to use as the result of appending and concatenating,along with allowing specification of a string to use for string-output-streams.Jeff Dalton pointed out that you'd like to be able to read into a specifiedbuffer sometimes instead of consing, particularly with READ-LINE.The whole idea is to allow re-use of old data structures to minimize GC'sand new allocation.Skip the discussion and just read the preceding parts of the message toavoid the admittedly verbose discussion but still get the changes suggested.*start*14572 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 22 AUG 88 22:42:08 PDTReceived: from ucbvax.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 22 Aug 88  22:40:51 PDTReceived: by ucbvax.Berkeley.EDU (5.59/1.30)	id AA18157; Mon, 22 Aug 88 22:36:40 PDTFrom: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUReceived: by trwrb.TRW.COM (5.51/1.36)	id AA15416; Mon, 22 Aug 88 21:39:05 PDTDate: Mon, 22 Aug 88 21:39:05 PDTMessage-Id: <8808230439.AA15416@trwrb.TRW.COM>To: cl-cleanup@sail.stanford.eduSubject: Issue "Eliminate forced consing" re-visitedWow, what a yawn.  (In response to my original proposal.)  After waiting amonth for comments, flames, whatever, I decided to re-send an edited versionof my original proposal in an attempt to generate some discussion.  Is anyoneelse trying to compete with C programs for efficiency?  Here it is:=======================Issue:         ELIMINATE FORCED CONSINGReferences:    CLtL section 14.1,3,5; 15.2,5; 17.4; 18.3; 21.2Category:      ADDITIONEdit history:  Version 1, 20-Jul-88, Ginder               Version 2, 22-Aug-88, Ginder                   Moved discussion to the discussion section.                   Changed multiple value proposal, clarified                   certain points.Problem description:Some sequence, list, and string functions in CLtL encourage aprogramming style that uses excessive storage allocation compared tolibraries of routines with similar functionality in other languages,notably C.  The only options available to the Common Lisp programmer whouses these functions are to generate a newly-allocated sequence or todestructively modify the argument sequence(s) given the function.  Theoption of providing a sequence, list, or string into which the result ofa sequence operation should be placed is not available.Proposal:Add a :TARGET keyword argument to those sequence, list, and stringfunctions where such an argument is useful, as specified below, whichallows passing a target argument sequence into which the result of thesequence computation is to be placed.  The sequence function returns thetarget sequence modified as specified below:(1) The target sequence must accomodate elements of the type(s) in thesource sequence.  Thus it would be an error to give a target stringargument if the source sequence had elements that were not of typeSTRING-CHAR.(2a) A non-list target sequence should have an allocated length longenough to accomodate the normal result of the sequence function.  It ispermissable for the target sequence to have a fill pointer; in thiscase, the fill pointer is set to point immediately after the lastelement filled in by the sequence computation.  If the target sequenceis longer than necessary, the unneeded trailing elements are unchanged.(2b) A list target sequence argument is extended with new conses to beas long as necessary to accomodate the resulting sequence, if not enoughconses are supplied and the :TARGET-FROM-END keyword is nil.  The lastcons of the target list whose CAR was filled by the computation isreturned as a second value.  The CDR of this cons is that tail of thetarget list not used to accomodate the sequence computation.  (I.e., Theunused conses remain as a tail of the target list that is returned.)This permits the programmer to save the unused conses and thennull-terminate the head of the list used for the result.(3) A :TARGET-FROM-END keyword is supported.  If non-nil, the targetsequence is filled with new elements starting at the end of the targetseqeunce, effectively reversing the order of elements of the resultingsequence in the target.  In this case, an error is signalled if thetarget sequence is not long enough for the result.  If the targetsequence is longer than necessary, leading elements are unchanged.(4) :TARGET-START and :TARGET-END keywords are supported.  TARGET-STARTand TARGET-END determine where in the target sequence the result of thesequence computation is placed.  An error is signalled if the sub-lengthof the target sequence specified by these arguments is not long enoughto accomodate the resulting sequence computation.  If a longer thannecessary sub-length is specified, then the elements in the unneededpart of the specified sub-length are unchanged.Changed sequence functions:	subseq, copy-seq, reverse, remove, remove-if, remove-if-not,	remove-duplicates, substitute, substitute-if, substitute-if-not,	mergeChanged list functions:	copy-list, butlast	copy-alist, copy-tree, adjoin, union, intersection, set-difference,	set-exclusive-or 	  [no TARGET-START/END or TARGET-FROM-END, just destructive	   use of the :TARGET conses]Changed string functions:	string-trim, string-left-trim, string-right-trim, string-upcase,	string-downcase, string-capitalize Examples:(copy-seq '(1 2 3) :target '(a b c d e f g))	=> (1 2 3 d e f g)(copy-seq '(1 2 3) :target '(a b c d e f g) :target-from-end t :end 5)	=> (a b 3 2 1 f g)(remove 'a '(b b a b b a b b a b b) :count 1 :target '(3))	=> (b b b b a b b a b b)   ; EQ to :TARGET arg, CDR is new conses.;;; Note, the :TARGET arg has a fill pointer.(substitute #\a #\b "This is a string with 2 a's"	    :target "0123456789012345678901234567890123456")	=> "This is b string with 2 b's"In a related addition, included here since it addresses the same problemas the one above, provide extended versions of concatenate, append,revappend, and make-string-output-stream as follows:	concatenate-into target &rest sequences	  Like CONCATENATE, but the result type is determined to be	  the type of TARGET.  The result is TARGET containing as many	  of the elements of SEQUENCES as can be accomodated by the	  allocated length of TARGET.  TARGET's fill pointer, if	  present is set according to how many elements of TARGET ar	  filled by this operation.	concatenate-into-subseq target start end &rest sequences	  Like concatenate-into, but copied from SEQUENCES into	the	  sub-sequence of TARGET specified by START and END.	append-into target &rest lists	  Like APPEND, but the copied list arguments are copied into	  conses taken from TARGET.  The last list in LISTS	  is not copied, as in APPEND, rather, the last cons used	  from TARGET is given the last list in LISTS as its cdr.	  The result is EQ to TARGET (unless a single list is appended),	  but contains only those conses needed to hold the appended	  lists' elements.  The tail of unused conses from TARGET is	  returned as a second value; new conses are allocated if	  TARGET supplies an insufficient number of conses.	revappend-into target x y	  Like REVAPPEND, but the new conses are taken from TARGET.	  The result is EQ to TARGET, but contains only those conses	  needed to hold X's elements.  The tail of unused conses	  from TARGET is returned as a second value; new conses are	  allocated if TARGET supplies an insufficient number of conses.	make-string-output-stream &optional string	  Like the current MAKE-STRING-OUTPUT-STREAM, except if STRING	  is provided, make the string-stream write to it rather than	  a newly-allocated string.  An error is signalled if the output	  overflows the supplied string.Rationale:It is sometimes better to use a more complex programming construct forsake of efficiency than to use a less complex, more expensive one.Providing a set of sequence, list, and string functions that do notrequire dynamic storage allocation provides a means for writing programsthat must avoid storage allocation while running as much as possible.Excessive storage allocation (sometimes expressed as "Lisp garbagecollects too often") is one of Lisp's most widely publicized and leastunderstood faults.Current practice:Similar functionality is provided for bit-vectors, as specified in CLtL17.4.  A related capability is provided in the destructive versions ofsome of the functions extended above (e.g., REMOVE vs. DELETE).When functionality similar to this is required, users must "roll theirown".Cost to Implementors:The cost of implementation of these extra sequence, list, and stringfunction arguments is significant, in that existing code to implementthese functions must be changed to use storage passed in as an argumentby the user.Cost to Users:No cost, this change upwards compatible.Cost of non-adoption:Some programmers will continue to "roll their own" storage re-usingcode.  Others will not go to this effort, but will write programs thatrequire much garbage collection.  Lisp will continue to suffer from ahandicap in promoting efficient programs when compared to C.Benefits:Those programmers choosing to invest the extra effort needed tocorrectly use such facilities can do so with less overhead thanpreviously required, and will see performance improvement.  Programmerslearning Common Lisp will be challenged to understand the differencebetween allocating new storage and re-using old storage as theyunderstand why these arguments are supported.Esthetics:Neutral.  This proposal is syntactically consistent with the existingkeyword arguments to sequence, list, and string functions.  However, itadds to the plethora of keyword arguments already present for many ofthese functions.  Stylistically, it provides stronger support for theprogramming style embodied by the use of the "destructive" versions ofmany Common Lisp functions.Discussion:My experience in several commercial Lisp applications is that avoidingstorage allocation by using programming techniques such as this may becritical to the success of a project.  The current sequence, list, andstring functions encourage an "expensive", albeit easy to use,programming style that invites the creation of programs whoseperformance suffers greatly in comparison to a C program written tosolve the same problem.  This applies particularly to string-hcakingprograms written using Common Lisp versus those written using thestandard string library for C.I submit that the cost of NOT implementing this sort of functionality isthat Common Lisp, in many cases, deserves the reputation it is gainingof being expensive to use, not in programmer productivity, but in theresources required by the resulting programs.  While it is easier towrite programs that always allocate new storage for results, it is veryexpensive compared to what average programmers write in other languages.(Asside: I realize that this dredges up the functional programmingversus side-effect programming debate.  Common Lisp already supports"destructive" versions of many functions.  Lisp compiler technology hasnot progressed to the point of eliminating unnecessary storageallocation in programs written in a purely functional style.)  Sometimesthe correct trade-off is to invest extra programming effort indevelopment of a program in exchange for lowered resource requirementsin the delivered system.  This is particularly true when the deployedLisp application may have thousands of instances.  It may well be worthseveral extra man-years of effort to use facilities such as thosementioned above rather than pay the increased cost of deploymentthousands of times!  (These costs are in the form of more expensivehardware for deployment.  This might be due to higher memoryrequirements or larger disk space requirements to support a largevirtual memory image and swap space.) If Common Lisp does not providethis capability; programmers under serious performance constraints willchoose a different language, such as C.Many programmers encounter problems writing efficient programs in Lisp.I've encountered numerous occurances of this problem in helping peoplewho are trying to write Lisp programs as part of an application that isintended to be delivered on hardware for which someone must pay realmoney.  The superficial problem encountered is that the program is tooslow, or requires hardware too expensive for practical deployment.  Themost common result is that the programmer gives up, proclaiming thatLisp is too slow or too resource intensive, and rewrites his program inC.  Although the above enhancements alone are not sufficient to solvethe cited problem, something along these lines is necessary as part of amore complete solution that might include better training of Lispprogrammers, standard support for stack consing, and ephemeral GC.  Thereal benefit of adopting this extension to Common Lisp (and relatedextensions) is an increased chance of survival for Lisp as a viable toolfor creating deliverable applications.A related sort of optimization that compilers should be encouraged tosupport is to recognize:   (concatenate 'string (subseq ...) (subseq ...) (subseq ...) ...)as being optimizable so as to avoid the allocation of storage forintermediate SUBSEQ results.  This is a very common programming idiomthat can, of course, be expressed using the proposed extensions to avoidintermediate consing.  However, the extensions do not provide as conciseand readable a mechanism for re-espressing this idiom as may others.Other extensions could be considered to address this:	(1) Provide a CONCATENATE function that takes a &rest	argument of sequence/start/end triples.	(2) Provide a special form like:	       (designate-subseq sequence start end)	that didn't actually allocate anything but provided an imple-	mentation-specific "handle" on the subsequence for use	in such expressions as the CONCATENATE expression above.	(They'd print as the subseq, and setf's of their elements	would destructively modify the original sequence.)	However, there is no precedent in CLtL for (1).  And (2) seems like acomplex, sweeping change (for implementors) of limited benefit.  Also,it is somewhat in conflict (though more general than) displaced arrays.Neither are proposed.I'd likely tolerate any sort of statements in the new CL manual warningnaive users of the dangers of this programming style.  I agree that itcan be mis-used and lead to nasty bugs; but sometimes the benefit isworth the risk.  I simply want Common Lisp to provide the choice.A related issue: would adoption of these arguments eliminate the needfor parallel destructive versions for some of the affected functions?(E.g., does REMOVE with a :TARGET argument eliminate the need forDELETE.)An alternative to :TARGET for the keyword name is :DESTROY.=======================*start*01382 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 12:27:18 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Sep 88  12:25:25 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 455682; Wed 7-Sep-88 15:22:54 EDTDate: Wed, 7 Sep 88 15:22 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: discussion of Moon's comments re: ELIMINATE-FORCED-CONSINGTo: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUcc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8809062238.AA12484@trwrb.TRW.COM>Message-ID: <19880907192224.9.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Tue, 6 Sep 88 15:38:22 PDT    From: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDU    !   I'd support your proposal if you simplify it more or less along     !   the lines I suggested.  I don't support version 2 because there    !   is too much in it.    I'll submit a modified proposal for discussion.Unfortunately the new proposal is so complicated that I'm not going tohave time to read and understand it in the near future.  I was hopingfor something a lot simpler.  If I get a chance to read it carefullyenough to comment on it, I'll send in some comments.*start*02984 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 11:55:45 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 7 Sep 88  11:55:13 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU;  7 Sep 88 14:52:18 EDTTo: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUcc: cl-cleanup@sail.stanford.eduSubject: ELIMINATE-FORCED-CONSING In-reply-to: Your message of Tue, 06 Sep 88 15:38:22 -0700.             <8809062238.AA12484@trwrb.TRW.COM> Date: Wed, 07 Sep 88 14:52:00 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUThrough some fluke of network routing, Ginder's revised proposal reached mebefore his detailed response to Moon.  When I saw the :MODIFY and :RECYCLEarguments and the complexities involved in making the latter do what youwant, my head started spinning.  I think that this is all very confusing,and I am strongly opposed to this proposal in its current form.  :MODIFYand :RECYCLE are similar enough to be easily confused, but they differ insubtle ways in their details; I never want to have to explain to a classwhen you use which one.Once I saw Ginder's other message, I realized what the problem is: I'mhappy enough to accept a :MODIFY or :OVERWRITE option in all of theappropriate places -- I have no preference for one of these names over theother -- but I really don't think that any of this recycling nonsenseshould be muddled in with the sequence functions.  To have both :MODIFY and:RECYCLE present, similar but different in subtle ways, is to inviteendless confusion.  If we accept just the :MODIFY part of the proposal, Ithink that Moon's prescriptions -- discarding excess conses, for example,are right.If there really is a need for recycling of CONS cells, I would support anexplicit RECYCLE call whose argument is a list.  This would authorize (butnot require) and implementation to CDR down the list argument, setting theCAR of each cell to NIL, and then to splice the whole thing onto a freelist of some sort; CONS would use these free cells before allocating newones.  Systems with epehemeral GC might not want to implement this since itdoesn't buy much and might result in worse storage locality than justdropping the list.  Something similar could be done for arrays, structures,etc., though that is harder to do.In the past we always stayed away from such things, since these constructslead to very confusing bugs if the program is actually holding onto therecycled structure somewhere else.  However, many programs end up creatingtheir own resource managers to reduce garbage-creation, and perhaps it istime to consider adding this to the language proper.  In any case, I thinkthat mixing this recycling concept with the sequence functions is the wrongmove.I would be prepared to support a version of this proposal that justincluded the :MODIFY parts.-- Scott*start*15542 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 00:02:03 PDTReceived: from ucbvax.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 7 Sep 88  00:01:00 PDTReceived: by ucbvax.Berkeley.EDU (5.59/1.31)	id AA13656; Tue, 6 Sep 88 23:52:14 PDTFrom: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUReceived: by trwrb.TRW.COM (5.51/1.36)	id AA12438; Tue, 6 Sep 88 15:37:57 PDTDate: Tue, 6 Sep 88 15:37:57 PDTMessage-Id: <8809062237.AA12438@trwrb.TRW.COM>To: cl-cleanup@sail.stanford.eduSubject: Revised ELIMINATE-CONSING-PROPOSAL, version 3Issue:         ELIMINATE FORCED CONSINGReferences:    CLtL section 14.1,3,5; 15.2,5; 17.4; 18.3; 21.2Category:      ADDITIONEdit history:  Version 1, 20-Jul-88, Ginder               Version 2, 22-Aug-88, Ginder                   Moved discussion to the discussion section.                   Changed multiple value proposal, clarified                   certain points.               Version 3, 31-Aug-88, Ginder                   Revised according to various comments. Much of                   my original discussion has been eliminated.Problem description:Some sequence, list, and string functions in CLtL encourage aprogramming style that uses excessive storage allocation compared tolibraries of routines with similar functionality in other languages,notably C.  The only options available to the Common Lisp programmer whouses these functions are to generate a newly-allocated sequence or todestructively modify the argument sequence(s) given the function.  Theoption of providing a sequence, list, or string into which the result ofa sequence operation should be placed is not available.Proposal:Add mutually exclusive :RECYCLE or :MODIFY keyword arguments to thosesequence, list, and string functions where such arguments are useful.:RECYCLE is used to pass a sequence to be recycled to hold the result ofthe sequence, list, or string operation.  :MODIFY is used to pass asequence that is to be modified in some manner to contain the result ofthe operation.  The distinction lies in that :MODIFY is akin todestructively modifying a useful data structure, while :RECYLE is usedto simply recycle a data structure that would otherwise be useless andpossibly garbage (i.e., a data structure whose contents are no longer ofinterest and may be altered arbitrarily).  The sequence, list, or stringfunction returns the MODIFY'd or RECYLE'd sequence as specified below.It is an error to pass both a :MODIFY and a :RECYCLE argument.[a] Support a MODIFY argument:(1) The sequence to be modified must accomodate elements of the type(s)that would have been stored in a newly-allocated sequence.  Thus itwould be an error to give a target string argument if the result of theoperation would normally have had elements that were not all of typeSTRING-CHAR.(2a) A non-list MODIFY argument should have an allocated length longenough to accomodate the normal result of the sequence function.  Thesequence to be modified may have a fill pointer.  The fill pointerremains unchanged by this operation so long as it points after themodified elements of the sequence.  If the fill pointer points prior toor in the range of the modified elements, it is set to point immediatelyafter the last element filled in by the sequence computation.  If thesequence to be modifed is longer than necessary, the unneeded trailingelements are unchanged.(2b) A list MODIFY argument is extended with new conses to be as long asnecessary to accomodate the resulting sequence, if not enough conses aresupplied and the :MODIFY-FROM-END keyword is nil.  Two values arereturned:  the first is the modified list with any unused tail remainingintact. (I.e., The unused conses remain as a tail of the modified listthat is returned.)  The second is that tail of the original list thatwas not modified by the operation.  This second value is useful forcontinued modification of the tail.(3) :MODIFY-START and :MODIFY-END keywords are supported.  MODIFY-STARTand MODIFY-END determine where in sequence the result of the sequencecomputation is placed.  It is an error if the sub-length of the sequencespecified by these arguments is not long enough to accomodate thesequence computation.  If a longer than necessary subsequence isspecified, then the elements in the unneeded part of the specifiedsubsequence are unchanged.(4) A :MODIFY-FROM-END keyword is supported.  If non-nil, the sequenceto be modified is filled with new elements starting at MODIFY-END (e.g.,the end of the sequence if MODIFY-END is not specified), effectivelyreversing the order of elements of the as the sequence is modified.  Itis an error if the supplied sequence is not long enough for the result.If the supplied sequence is longer than necessary, leading elements areunchanged.Sequence functions changed to include MODIFY, MODIFY-START, MODIFY-END,MODIFY-FROM-END:	subseq, copy-seq, reverse, remove, remove-if,	remove-if-not, remove-duplicates, substitute, substitute-if,	substitute-if-not, mergeList functions changed to include MODIFY, MODIFY-START, MODIFY-END,MODIFY-FROM-END:	copy-list, butlastString functions changed to include MODIFY, MODIFY-START, MODIFY-END,MODIFY-FROM-END:	string-trim, string-left-trim, string-right-trim, string-upcase,	string-downcase, string-capitalize[a] Support a RECYLE argument:(1) The sequence to be recycled must accomodate elements of the type(s)that would have been stored in a newly-allocated sequence.  Thus itwould be an error to give a RECYLE string argument if the result of theoperation would normally have had elements that were not all of typeSTRING-CHAR.(2a) A non-list RECYCLE argument should have an allocated length longenough to accomodate the normal result of the sequence function.  Thesequence to be recycled may have a fill pointer.  The fill pointer isset to point immediately after the last element filled in by thesequence computation.  If the sequence to be recycled is longer thannecessary, the unneeded trailing elements are unchanged.(2b) A list RECYCLE argument is extended with new conses to be as longas necessary to accomodate the resulting list, if not enough conses aresupplied.  Two values are returned:  the first is the result listterminated with NIL.  (I.e., The unused conses are spliced out of therecycled list that is returned.)  The second is that tail of theoriginal list that was not used by the recycling operation.(3) No :RECYCLE-START, :RECYCLE-END, or :RECYCLE-FROM-END arguments aresupported.Changed sequence functions:	subseq, copy-seq, reverse, remove, remove-if,        remove-if-not, remove-duplicates, substitute, substitute-if,        substitute-if-not, mergeChanged list functions:	make-list, copy-list, copy-alist, copy-tree, butlast, subst,        sublis, adjoin, union, intersection, set-difference,        set-exclusive-orChanged string functions:	string-trim, string-left-trim, string-right-trim, string-upcase,	string-downcase, string-capitalize Examples:(copy-seq '(1 2 3) :modify '(a b c d e f g))	=> (1 2 3 d e f g)(copy-seq '(1 2 3) :modify '(a b c d e f g) :modify-from-end t :modify-end 5)	=> (a b 3 2 1 f g)(remove 'a '(b b a b b a b b a b b) :count 1 :recycle '(3))	=> (b b b b a b b a b b)   ; EQ to :recycle arg, CDR is new conses.(substitute #\a #\b "This is a string with 2 a's"	    :modify (make-array 37 :element-type 'string-char :fill-pointer 0))	=> "This is b string with 2 b's" ; result EQ to MODIFY arg, 					 ; result has a fill-pointer set to 27 (substitute #\a #\b "ababa"	    :modify (make-array 10 :element-type 'string-char				   :initial-element #'q	                           :fill-pointer 10))	=> "aaaaaqqqqq" ; result EQ to MODIFY arg, 			; result has a fill-pointer set to 10 (copy-list '(a b c) :recycle '(1 2 3 4 5 6 7))	=> (a b c)    ; first value           (4 5 6 7)  ; second value(copy-list '(a b c) :modify '(1 2 3 4 5 6 7))	=> (a b c 4 5 6 7)  ; first value           (4 5 6 7)        ; second valueIn related additions, included here since they address the same problemas above, provide extended versions of concatenate, append, revappend,make-string-output-stream, and read-line as follows:  concatenate-into target &rest sequences    Like CONCATENATE, but the result type is determined to be    the type of TARGET.  The result is TARGET containing as many    of the elements of SEQUENCES as can be accomodated by the    allocated length of TARGET.  TARGET's fill pointer, if    present is set according to how many elements of TARGET are    filled by this operation.    map-into target function sequence &rest sequences    Like MAP, but the result type is determined to be the type    of TARGET.  The result of MAP-INTO is TARGET such that    element j is the result of applying FUNCTION to element j    of each of the argument sequences.  TARGET must be as long    as the shortest of the input sequences.  TARGET's fill    pointer, if present is set according to how many elements of    TARGET are filled by this operation.    append-into target &rest lists    Like APPEND, but the copied list arguments are copied into    conses taken from TARGET.  The last list in LISTS    is not copied, as in APPEND, rather, the last cons used    from TARGET is given the last list in LISTS as its cdr.    The result is EQ to TARGET (unless a single list is appended),    but contains only those conses needed to hold the appended    lists' elements.  The tail of unused conses from TARGET is    returned as a second value; new conses are allocated if    TARGET supplies an insufficient number of conses.    revappend-into target x y    Like REVAPPEND, but the new conses are taken from TARGET.    The result is EQ to TARGET, but contains only those conses    needed to hold X's elements.  The tail of unused conses    from TARGET is returned as a second value; new conses are    allocated if TARGET supplies an insufficient number of conses.    make-string-output-stream &optional string    Like the current MAKE-STRING-OUTPUT-STREAM, except if STRING    is provided, it must be a string with a fill pointer.  Output    to the resulting stream is incrementally appended to STRING,    as if using VECTOR-PUSH-EXTEND if the string is adjustable,    and otherwise using VECTOR-PUSH.    read-line-into-string string &optional input-stream eof-error-p			eof-value recursive-p    Like READ-LINE, but reads into STRING.  STRING must be a string    with a fill pointer.  The result of READ-LINE-INTO-STRING is    incrementally appended to STRING, as if using VECTOR-PUSH-EXTEND    if the string is adjustable,and otherwise using VECTOR-PUSH.In order to facilitate recycling alists and trees, the following twofunctions are proposed.  flatten-tree tree    FLATTEN-TREE would take a tree and return a linear list made    of all the conses in the tree, suitable for recycling via a    :RECYLE argument.  flatten-alist alist    FLATTEN-ALIST would take an alist and return a linear list    made of all the conses that would be copied by COPY-ALIST,    suitable for recycling via a :RECYLE argument.Rationale:It is sometimes better to use a more complex programming construct forsake of efficiency than to use a less complex, more expensive one.Providing a functions that do not require dynamic storage allocationprovides a means for writing programs that must avoid storage allocationwhile running as much as possible.  Excessive storage allocation(sometimes expressed as "Lisp garbage collects too often") is one ofLisp's most widely publicized faults.Current practice:Similar functionality is provided for bit-vectors, as specified in CLtL17.4.  A related capability is provided in the destructive versions ofsome of the functions extended above (e.g., REMOVE vs. DELETE).When functionality similar to this is required, users must "roll theirown".[from Moon] Symbolics Common Lisp already has MAP-INTO.Cost to Implementors:The cost of implementation of these extra sequence, list, and stringfunction arguments is significant, in that existing code to implementthese functions must be changed to use storage passed in as an argumentby the user.Cost to Users:No cost for existing programs, this change is upwards compatible.  Usersmay mis-use the new keyword arguments and end up with buggy code,similar to the problems encountered when using C library functions thatre-use data structures.Cost of non-adoption:Programmers will continue to "roll their own" non-standard storagere-using code.  Others will not go to this effort, but will writeprograms that require much garbage collection.  Lisp will continue tosuffer from a handicap in promoting efficient programs when compared toC.Benefits:Those programmers choosing to invest the extra effort needed tocorrectly use such facilities can do so with less overhead thanpreviously required, and will see performance improvement.Esthetics:Neutral.  This proposal is syntactically consistent with the existingkeyword arguments to sequence, list, and string functions.  However, itadds to the plethora of keyword arguments already present for many ofthese functions.  Stylistically, it provides stronger support for theprogramming style embodied by the use of the "destructive" versions ofmany Common Lisp functions.Discussion:My experience in several commercial Lisp applications is that avoidingstorage allocation by using programming techniques such as this may becritical to the success of a project.  The current sequence, list, andstring functions encourage an "expensive", albeit easy to use,programming style that invites the creation of programs whoseperformance suffers greatly in comparison to a C program written tosolve the same problem.  This applies particularly to string-hcakingprograms written using Common Lisp versus those written using thestandard string library for C.A related issue: would adoption of these arguments eliminate the needfor parallel destructive versions for some of the affected functions?(E.g., does REMOVE with a :MODIFY argument eliminate the need forDELETE.)Pierson supports the general ideas of an earlier version of thisproposal, but believes the proposal itself should be in the form thatwould appear in a revised manual.Several people responded in the negative to Fahlmans suggestion thatperhaps the new LOOP facility would relieve the need for theseextensions.  Fahlman is ready to support the proposal in principle ifcertain details are fixed up.Moon does not like returning unused conses as a second value as proposedin previous versions of this proposal.  He also does not believe thatUNION, INTERSECTION, SET-DIFFERENCE, and SET-EXCLUSIVE-OR derive muchbenfit from previously suggested extensions similar to those in thisproposal.  Neither should the functions SUBSEQ, COPY-SEQ, COPY-LIST, andBUTLAST be modified, because the functionality is already available fromREPLACE, he claims.  He thought :TARGET should be changed to :OVERWRITE.All of the above comments were made prior to version three of thisproposal.MAPCAR and friends might be considered candidates for modification inthis proposal.  However, these mapping functions likely will be madeobsolete by LOOP if they are not already obsolete.*start*10607 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 07 SEP 88 02:19:33 PDTReceived: from ucbvax.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 7 Sep 88  02:18:51 PDTReceived: by ucbvax.Berkeley.EDU (5.59/1.31)	id AA13742; Tue, 6 Sep 88 23:56:28 PDTFrom: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUReceived: by trwrb.TRW.COM (5.51/1.36)	id AA12484; Tue, 6 Sep 88 15:38:22 PDTDate: Tue, 6 Sep 88 15:38:22 PDTMessage-Id: <8809062238.AA12484@trwrb.TRW.COM>To: cl-cleanup@sail.stanford.eduSubject: discussion of Moon's comments re: ELIMINATE-FORCED-CONSING!   I think the name :OVERWRITE would be more consistent with the!   rest of Common Lisp than the name :TARGET.  It makes it clearer!   that this argument is storage to be overwritten with new!   information.The problem is that the :TARGET argument is used for two differentpurposes.  One is to fill a subsequence of a useful sequence, as infilling in a substring of a longer string.  The other is to recyclestorage (i.e., an obsolete sequence that would otherwise be garbage)without regard for the previous contents of that storage (except toinsure type compatibility).  It seems useful to regard these asdifferent operations; although, except for the list case, they often canbe conveniently denoted using the same basic syntax, as in my proposal.Some of the modifications you suggest to the proposal seem to stem fromassuming one or the other of these uses, disregarding the other.  Thus Ibelieve I should modify the proposal to have two different keywords thatcan reflect the intention of a programmer.For sake of argument, let's call the two keyword arguments :MODIFY (forchanging a subsequence of a useful sequence) and :RECYCLE (for recyclinga sequence that is otherwise garbage).  A list passed as a :RECYCLEargument is re-used as a linear list made of conses to recycle.  CAR'sare ignored (i.e., it is not a tree of conses to re-use!).!   When you say!       (1) The target sequence must accomodate elements of the!       type(s) in the source sequence.!   I believe this is wrong.  It should refer to the type of the!   elements of the -result- of the function, not the source.I believe this is correct.  My proposal will be altered to reflect this.!   I don't understand the need for the :TARGET-FROM-END feature and!   I think you should drop it from the proposal.:TARGET-FROM-END specifies that the target sequence is filled from theend with the result of the operation.  This allows the elements of theresult sequence to be placed into the target argument in reverse order.This is not essential to the proposal.  It was included for sake ofsymetry, in some sense of the word, since one might expect thiscapability after surveying the other keywords available.  It wouldbecome :MODIFY-FROM-END given the distinction in usage of the targetsequence already discussed.  I'll take it out if most people think itexcessive.!       The last cons of the target list whose CAR was filled by the!       computation is returned as a second value.  The CDR of this cons!       is that tail of the target list not used to accomodate the!       sequence computation.!!   I think this feature is unnecessary and should be discarded.  I!   think extra conses should simply be thrown away.  Most people!   exploiting this non-consing feature are more likely to use vectors!   than lists, I feel.I do not agree that this feature will usually be limited to vectorsrather than lists.  It is, however, tied to the :MODIFY/:RECYCLEdistinction.  A new proposal will address the return values in light ofthis distinction.!   If the feature is kept, the second value should be the cdr of!   what you propose it to be, and the result should be null-terminated!   in the correct place; that should not be left to the caller to do.This would prevent the use of the :TARGET argument for filling in asublist, since the sublist is terminated.  It also breaks symetry withother sequence types where a subsequence of a larger-than-needed TARGETsequence is filled.  The problem is overloading :TARGET with thesemantics of :MODIFY and :RECYCLE.  For :MODIFY semantics, you want toreturn a second value which is the tail of the list that was not used,leaving that tail linked to the head that was used.  For :RECYCLEsemantics, you want as the first value the the null-terminated head ofthe list that was used, and as the second value the tail that was notused.  The difference is whether the first list value is null terminatedor not.  In addition, for a sequence with a fill-pointer used as theRECYLE argument, the fill-pointer would be adjusted to point after thelast sequence element inserted.  As a MODIFY argument, the fill-pointerwould remain unchanged.  [Would the fill-pointer be extended if fillingthe MODIFY argument used elements after the fill-pointer?  Or wouldthose elements of the MODIFY sequence after the fill pointer remainunchanged?  I prefer the former.]I oppose any change to the proposal that causes excess conses to bethrown away.!   Another idea would be to allow the user to pass in a function that is!   called whenever storage is to be allocated.  Perhaps it would take two!   arguments and the default would be #'APPLY.  The first argument would!   be one of #'CONS, #'MAKE-LIST, or #'MAKE-ARRAY, the second argument!   would be a list of arguments with dynamic extent.  I'm not real fond!   of this idea, but it does provide maximum generality.This provides maximum generality, but requires function call overheadthat might be avoided if storage is passed directly.  One might achievethe same effect by supporting storage-freeing operations so Lisp couldkeep a "free list" of recyclable storage to re-use rather thanallocating new storage.  Of course this leads to the desire to preservestorage locality, including free-lists, thus a discussion of storageallocation areas with free-lists per area, etc.  I would not oppose sucha mechanism, however.!       (4) :TARGET-START and :TARGET-END keywords are supported.!!   These seem useful but should be named :OVERWRITE-START and!   :OVERWRITE-END.Well, I'd say :MODIFY-START and :MODIFY-END now.  :RECYCLE-START and:RECYCLE-END are redundant with the normal :START and :END argument as:RECYCLE implies the sequence passed in is just for storage recycling.The :RECYCLE argument should not be used to modify a subsequence of auseful sequence; use :MODIFY instead.!   The functions SUBSEQ, COPY-SEQ, COPY-LIST, and BUTLAST need not be!   modified, because the functionality is already available from!   REPLACE.I believe the :RECYCLE argument should be supported for these.!   The functions COPY-ALIST and COPY-TREE should not be modified,!   because their use of storage is too complex to fit into this model!   (they don't deal in linear sequences).Since it is well-defined when COPY-ALIST copies a cons, and since it iswell-defined that circularities and shared substructure are NOTpreserved in COPY-TREE, I see no reason not to include a :RECYLEargument for these functions.  While modifiying an existing alist ortree using the :MODIFY argument is ill-defined, the use of the :RECYLEargument as a glob of available, linear cons storage is quite useful.It would be useful, given the semantics above, to provide functions to"flatten" an alist or a tree.  A new proposal will address this.!   The function ADJOIN should not be modified, because a non-consing!   version is trivial for a user to write, and because the !   consumption of storage is conditional, which would complicate!   the interface.Again, for sake of symetry, I (mildly) disagree.  The unused consesshould be returned, which is the interface complication you mention, Iguess.  Of course, the TARGET argument should be changed to :RECYLE forADJOIN.!   I don't think UNION, INTERSECTION, SET-DIFFERENCE, and                  !   SET-EXCLUSIVE-OR should be modified, because their!   conditional consumption of storage would complicate!   the interface (unused storage has to be handed back to!   the caller) and because the destructive versions that!   already exist can solve the same problem, in my!   experience.  (They aren't completely non-consing, but!   they minimize consing.)  You forgot to mention SUBST,!   but I think the same reasoning applies and SUBST!   should not be modified.You're correct, I forgot SUBST.  However, I believe :RECYCLE should besupported for SUBST, UNION, INTERSECTION, SET-DIFFERENCE, andSET-EXCLUSIVE-OR.!   This leaves REVERSE, MERGE, REMOVE, REMOVE-IF, REMOVE-IF-NOT,!   REMOVE-DUPLICATES, SUBSTITUTE, SUBSTITUTE-IF, SUBSTITUTE-IF-NOT,!   STRING-TRIM, STRING-LEFT-TRIM, STRING-RIGHT-TRIM, STRING-UPCASE,!   STRING-DOWNCASE, STRING-CAPITALIZE.  I think it's reasonable to!   modify these in the way you suggest.  Doing just these makes for!   a much simpler proposal that is easier to understand.To reflect the clearer set of keywords, these would be changed tosupport RECYCLE/MODIFY in my new proposal.!   MAKE-STRING-OUTPUT-STREAM should follow the same rules as!   WITH-OUTPUT-TO-STRING when a string is supplied, instead of!   the different rule you suggested.  With that change to make it!   consistent, I support what you propose.I agree.  This was an oversight.!   This leaves CONCATENATE, APPEND, REVAPPEND, and MAP (which              !   you forgot, but which has been discussed in the past),!   which take &rest arguments and therefore are a problem.  I!   don't think the -into-subseq version is useful enough to!   justify the extra complexity.  I also don't think the!   extra complexity of allowing the caller to pass in too!   many conses to APPEND and REVAPPEND and get back the!   unused ones as a second value is justified.  In fact, I!   think I would prefer to omit APPEND-INTO from the proposal!   (CONCATENATE-INTO and NCONC should suffice) and therefore!   to omit REVAPPEND-INTO also.  I support CONCATENATE-INTO!   and MAP-INTO.OK, I'll remove the -INTO-SUBSEQ stuff.  But I disagree that passing intoo many conses and getting the unused ones back as a second value istoo complex.  I think this is a big win that is extremely useful.!   I'd support your proposal if you simplify it more or less along !   the lines I suggested.  I don't support version 2 because there!   is too much in it.I'll submit a modified proposal for discussion.-- Joe Ginder*start*01700 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 SEP 88 22:14:02 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Sep 88  22:13:16 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 14 SEP 88 22:11:31 PDTDate: 14 Sep 88 22:10 PDTFrom: masinter.paSubject: ELIMINATE-FORCED-CONSINGTo: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <880914-221131-1891@Xerox>I'd like to get a sense of the committee on this issue... my guess is that thebest we can do is to report at the October meeting on the state of ourdeliberation, and have the final issue ready by January.My opinion on the issue:I think the problem is a serious one, and that I don't want to discard theissue. However, I'm not convinced that any of the proposed solutions actuallysolve the stated problem, or are the minimum cost solutions to the problem.In my mind, making CL more complicated is a very high cost.What I remember from implementing stuff like this is that a :TARGET keyword justdoubles the size of the code for the functions, because the implementation when:TARGET is supplied is completely different than the implementation when :TARGETisn't supplied. This increases the size of the required image (because you can'tselectively compile stuff out) or else increases the complexity of the optimizer(which has to decide whether the :TARGET is supplied), and increases the size oferror checking (what if :TARGET isn't big enough), increases the size of themanual and the standard (describing all of these :TARGET arguments), and onlysaves conses for a few applications.*start*01183 00024 USfReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 21 SEP 88 00:34:40 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA05198g; Tue, 20 Sep 88 23:34:11 PSTReceived: by bhopal id AA21465g; Wed, 21 Sep 88 00:33:40 PDTDate: Wed, 21 Sep 88 00:33:40 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809210733.AA21465@bhopal>To: masinter.paCc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: masinter.pa@Xerox.COM's message of 14 Sep 88 22:10 PDT <880914-221131-1891@Xerox>Subject: ELIMINATE-FORCED-CONSINGI agree with your prognosis.  Specifically, I know of important companies that are trying to deliver Lisp-written programs to be competitive with C-written ones, and their programmers believe (rightly or wrongly) that they must do cons-free programming.  So it is a serious problem that can't be completelyignored.  Additionally, I agree with your conjecture:     In my mind, making CL more complicated is a very high cost.and would add to it that making cleanup proposals more complicatedwill be a very high cost.  There's only so much we can do betwennow and January.-- JonL --*start*01036 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:01:57 PDTReceived: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:01:45 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 229507; Thu 13-Oct-88 16:33:15 EDTDate: Thu, 13 Oct 88 16:33 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: ELIMINATE-FORCED-CONSING (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013163306.3.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...X3J13 meeting: KMP: LOOP (or any iteration facility that makes idioms explicit)      will help to address the same issue, making this less critical.Side comment (not in any meeting): Masinter: Destructive and non-destructive versions of this are very	   different, which makes things like inlining tough.*start*01639 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 31 OCT 88 18:45:18 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 31 Oct 88  18:43:07 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 31 OCT 88 11:40:44 PSTDate: 31 Oct 88 11:40 PSTFrom: masinter.paSubject: Re: Issue: ELIMINATE-FORCED-CONSING (Version 3)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 13 Oct 88 16:33 EDTTo: CL-Cleanup@SAIL.Stanford.EDU, trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUMessage-ID: <881031-114044-6089@Xerox>We need to be careful about cc'ing the relevant parties on discussion on ofissues. I've forwarded to jrg those messages that originally went tocl-cleanup only.This issue was not distributed to X3J13 prior to the meeting, I think. I amreluctant to have it on the list with its current name and am tempted, atthis late date, to rename it.(SEQUENCE-FUNCTIONS-CONSING:ADD-TARGET-KEYWORDS) or some such.Jim Allard, I believe, made the comment that, given a dynamic-extentconstruct, it is possible to do "cons-free" programming with some largerawkwardness by writing an idiom where the new sequence is generated withdynamic extent and then the old sequence is either copied or modified.I wonder whether some special purpose recognizition of idiomatic nesting ofREPLACE with a sequence function inside compilers or optimizers might wellhave the same benefit without increasing the apparent complexity of thelanguage. (I believe some APL compilers work this way.)*start*01201 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 10:27:07 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  10:25:20 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 10:10:42 PSTDate: 12 Dec 88 10:08 PSTFrom: masinter.paSubject: Re: discussion of Moon's comments re: ELIMINATE-FORCED-CONSINGIn-reply-to: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDU's message of Tue, 6 Sep 88 15:38:22 PDTTo: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUcc: cl-cleanup@sail.stanford.eduMessage-ID: <881212-101042-4317@Xerox>Joe:On 6 Sept 88 you said, in response to a critique from Moon. "I'll submit amodified proposal for discussion."There were some subsequent comments on the cl-cleanup mailing list, andwe've not heard back from you. The January 1989 meeting is fastapproaching; we don't have a new writeup on this issue to mail out inadvance; if we don't hear from you, we will not have a new version to bringthere either.Please reply if you get this note (to cl-cleanup@sail.stanford.edu), aboutyour plans with respect to this issue.*start*01602 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JAN 89 13:43:30 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Jan 89  13:41:09 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 JAN 89 13:37:33 PSTDate: 8 Jan 89 13:36 PSTFrom: masinter.paSubject: Issue: ELIMINATE-FORCED-CONSING (Version 3)To: cl-cleanup@sail.stanford.eduMessage-ID: <890108-133733-3295@Xerox>I have not heard back from Joe Ginder on this issue. Does anyone else wantto pursue this? Otherwise it will be dropped. (I personally would just aswell see it dropped at this time.)     ----- Begin Forwarded Messages -----Date: 12 Dec 88 10:08 PSTFrom: masinter.paSubject: Re: discussion of Moon's comments re: ELIMINATE-FORCED-CONSINGIn-reply-to: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDU's message of Tue, 6 Sep 88 15:38:22 PDTTo: trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUcc: cl-cleanup@sail.stanford.eduJoe:On 6 Sept 88 you said, in response to a critique from Moon. "I'll submit amodified proposal for discussion."There were some subsequent comments on the cl-cleanup mailing list, andwe've not heard back from you. The January 1989 meeting is fastapproaching; we don't have a new writeup on this issue to mail out inadvance; if we don't hear from you, we will not have a new version to bringthere either.Please reply if you get this note (to cl-cleanup@sail.stanford.edu), aboutyour plans with respect to this issue.     ----- End Forwarded Messages -----