*start*01304 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 JUN 88 15:20:07 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 23 Jun 88  15:16:52 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 23 Jun 88 18:16:42 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: FUNCTION-COMPOSITION (Version 1) In-reply-to: Your message of Thu, 23 Jun 88 17:11:00 -0400.             <880623171122.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM> Date: Thu, 23 Jun 88 18:16:22 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUPresumably the following is a typo, and you intend this to a function thatcalls the given function and then negates its argument.  Or something likethat.---------------------------------------------------------------------------   COMPLEMENT function					[Function]    Returns a function whose value is the same as the OR of the    given functions applied to the same arguments.---------------------------------------------------------------------------This all seems a bit gratuitous to me, but if the rest of you think itwould promote better programming style, I won't argue.-- Scott*start*03037 00024 UU?Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 30 JUN 88 08:08:26 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 427086; Thu 30-Jun-88 11:08:20 EDTDate: Thu, 30 Jun 88 11:08 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-COMPOSITION (Version 1)To: Masinter.PA, vanroggen%aitg.DEC@decwrl.dec.com, piazza%lisp.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8806301323.AA18500@decwrl.dec.com>,             The message of 29 Jun 88 23:55 PDT from masinter.pa@Xerox.COM,             <8806291754.AA11621@decwrl.dec.com>Message-ID: <880630110812.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Thu, 30 Jun 88 06:23:24 PDT    From: vanroggen%aitg.DEC@decwrl.dec.com      From: masinter.pa@Xerox.COM      Date: 29 Jun 88 23:55:32 PDT      I'd rather see a portable implementation circulated, frankly.        Why should these be in the standard?    To allow and encourage compiler optimizations that would otherwise    be difficult to do.Right. These are easy to write correctly in a portable way, but theportable way is not nearly as efficient as what coudl be non-portablyprovided... And I doubt anyone would spend any effort to optimize themif they weren't part of the core language.But as alluded to in the proposal, this would also get us a footholdfrom which to be able to suggest flushing the -IF-NOT functions and:TEST-NOT keywords. Those functions provide not only clutter in theform of size, but it's a pain to try to coherently explain - the default value of the :TEST and :TEST-NOT parameters, which   cannot be independent - the effect of providing both the :TEST and :TEST-NOTI'll be submitting a proposal to make that cleanup, and that proposalmight fly on its own, but it would go better (I think) if it had supportfrom a reasonably concise alternative mechanism (particularly COMPLEMENT).Also, I bet the reason there are not :TEST-AND and :TEST-OR arguments is not that ANDing and ORing predicates is less useful than NOTing them,but rather that NOT takes one argument and the rest take more and no onewanted to worry about :TEST-AND '(FOO BAR) or :TEST-AND (LIST #'FOO #'BAR)which would have had to cons a needless list. This proposal provides away to specify things so that no consing is necessary in many cases-- :TEST (CONJOIN #'FOO #'BAR) -- Stack consing might occur, or inliningmight completely unroll the need for a list at all...Aside to Jeffrey, I like COMMUTE as an addition to the set of things Ihad listed, by the way, but I didn't really like PERMUTE as described.It is a nice idea conceptually but the fact that its permuation argumentis evaluated means that it can be opaque to such optimization when theargument is not constant, and the result may be suprisingly lessefficient than the programmer may expect in those cases.*start*00946 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 30 JUN 88 15:59:10 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Jun 88  15:57:41 PDTReceived: from Burger.ms by ArpaGateway.ms ; 30 JUN 88 15:51:33 PDTFrom: masinter.paDate: 30 Jun 88 15:48:42 PDTSubject: Re: Issue: FUNCTION-COMPOSITION (Version 1)In-reply-to: vanroggen%aitg.DEC@decwrl.dec.com's message of Thu, 30 Jun 88 06:23:24 PDT, <8806301323.AA18500@decwrl.dec.com>To: vanroggen%aitg.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduMessage-ID: <880630-155133-5578@Xerox>Perhaps you could indicate the kinds of compiler optimizations that might beuseful? Would people use these functions if the compiler didn't optimize them?Souldn'sShouldn't the mythical compiler be able to do as well givenINLINE-proclaimed portable definitions?*start*00954 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 JUN 88 13:13:15 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 24 Jun 88  13:07:45 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 24 JUN 88 12:56:50 PDTDate: 24 Jun 88 12:56 PDTFrom: Masinter.paSubject: Re: Issue: FUNCTION-COMPOSITION (Version 1) In-reply-to: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Thu, 23 Jun 88 18:16:22 EDTTo: Scott.Fahlman@B.GP.CS.CMU.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880624-125650-6005@Xerox>I think this stuff might be useful, but it falls into the category of a packageof useful things that we should distribute. Compare the situation  with LOOP,where the proliferation of incompatible LOOP macros is a serious problem. Isthere a problem with proliferation of versions of these?*start*03614 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 27 JUN 88 13:58:55 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 27 Jun 88  13:57:07 PDTReceived: by labrea.stanford.edu; Mon, 27 Jun 88 13:57:02 PDTReceived: from bhopal.lucid.com by edsel id AA00331g; Mon, 27 Jun 88 12:29:22 PDTReceived: by bhopal id AA00551g; Mon, 27 Jun 88 12:29:15 PDTDate: Mon, 27 Jun 88 12:29:15 PDTFrom: Jim McDonald <edsel!jlm@labrea.stanford.edu>Message-Id: <8806271929.AA00551@bhopal.lucid.com>To: KMP@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Thu, 23 Jun 88 17:11 EDT <880623171122.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COMPOSITION (Version 1)The following is a sketch of some other possibly useful operators.Maybe some kind soul out there will adopt them and make a realproposal to add them. Note that the notions of permutation-vector are actually just afirst stab--one might really want some lambda-list -> lambda-listoperator that understands &optional, &key, &rest, etc.  It mightalso be useful to have an operator that permitted deletion orrepetition of arguments.  I think the caveat about redefinition of the given function shouldbe added to the existing proposal and apply to all the composition functions.    COMMUTE function                                    [Function]    Returns a function whose value is the same as that of the    given function applied to the same arguments with the first    two interchanged.   PERMUTE function argument-permutation           &optional value-permutation                 [Function]    Returns a function whose values are a permutation of the    values which would be returned by an application of the given    function to a permutation of its arguments.    If argument-permutation is NIL, the effect is as if all     arguments were passed to the given function without being    permuted.  If it is non-NIL, it must be a sequence of integers    containing a permutation of an initial subset of the natural     numbers, and the effect is as if each argument, at position i,    is first moved to position (elt argument-permutation i) before    the given function is called.      If values-permutation is NIL, the effect is as if values were    returned from the given function without being permuted.  If     it is non-NIL, it must be a sequence containing a permutation    of an initial subset of the natural numbers, and the effect is    as if each value, at position j, is first moved to position     (elt value-permutation j) before the result function returns.     Note that in practice such argument and value movement could    be implicit in the behavior of the result function, and the    given function might never be called.  Hence subsequent     redefinitions of the given function may have unpredictable     effects on the behavior of the result function.Examples:   (FUNCALL #'(LAMBDA (X Y) (CONS Y X)) 1 2)   ==   (FUNCALL (COMMUTE #'CONS) 1 2)    =>   (2 . 1)   (FUNCALL #'(LAMBDA (A B C D E F) (LIST C B A F E D)) 11 22 33 44 55 66)   ==   (FUNCALL (PERMUTE #'LIST #(2 1 0 5 4 3)) 10 11 12 13 14 15 16)   =>   '(12 11 10 16 15 14)   (FUNCALL #'(LAMBDA (I J)                (MULTIPLE-VALUE-BIND (Q R)                     (TRUNCATE I J)                  (VALUES R Q)))            10 3)   ==   (FUNCALL (PERMUTE #'TRUNCATE nil '(1 0)) 10 3)   =>   1   3*start*00827 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 30 JUN 88 00:05:02 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Jun 88  00:04:41 PDTReceived: from Burger.ms by ArpaGateway.ms ; 29 JUN 88 23:56:06 PDTFrom: masinter.paDate: 29 Jun 88 23:55:32 PDTSubject: Re: Issue: FUNCTION-COMPOSITION (Version 1)In-reply-to: edsel!jlm@labrea.stanford.edu's message of Mon, 27 Jun 88 12:29:15 PDT, <8806271929.AA00551@bhopal.lucid.com>To: Jim McDonald <edsel!jlm@labrea.stanford.edu>cc: KMP@stony-brook.scrc.symbolics.com, CL-Cleanup@sail.stanford.eduMessage-ID: <880629-235606-4020@Xerox>I'd rather see a portable implementation circulated, frankly.Why should these be in the standard?*start*00847 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 30 JUN 88 06:24:28 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 30 Jun 88  06:23:38 PDTReceived: by decwrl.dec.com (5.54.4/4.7.34)	id AA18500; Thu, 30 Jun 88 06:23:24 PDTDate: Thu, 30 Jun 88 06:23:24 PDTMessage-Id: <8806301323.AA18500@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Re: Issue: FUNCTION-COMPOSITION (Version 1)  From: masinter.pa@Xerox.COM  Date: 29 Jun 88 23:55:32 PDT  I'd rather see a portable implementation circulated, frankly.    Why should these be in the standard?To allow and encourage compiler optimizations that would otherwisebe difficult to do.			---Walter*start*05093 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 JUN 88 14:14:40 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Jun 88  14:12:08 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 423898; Thu 23-Jun-88 17:11:49 EDTDate: Thu, 23 Jun 88 17:11 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COMPOSITION (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880623171122.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        FUNCTION-COMPOSITIONReferences:   NoneCategory:     ADDITIONEdit history: 21-Jun-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  A number of useful functions on functions are conspicuously  absent from Common Lisp's basic set. Among them are functions  which return constant T, constant NIL, and functions which  combine functions in common, interesting ways.Proposal (FUNCTION-COMPOSITION:NEW-FUNCTIONS):  Add the following functions:   COMPOSE &REST functions				[Function]    Returns a function whose value is the same as the composition    of the given functions. eg, (FUNCALL (COMPOSE #'F #'G #'H) A B C)    is the same as (F (G (H A B C))). Also, for example, #'CAADR may    be described as (COMPOSE #'CAR #'CAR #'CDR).   CONJOIN &REST functions				[Function]    Returns a function whose value is the same as the AND of the    given functions applied to the same arguments.   DISJOIN &REST functions				[Function]    Returns a function whose value is the same as the OR of the    given functions applied to the same arguments.   COMPLEMENT function					[Function]    Returns a function whose value is the same as the OR of the    given functions applied to the same arguments.   ALWAYS value						[Function]    Returns a function whose value is always VALUE.Examples:  (MAPCAR #'(LAMBDA (X) (DECLARE (IGNORE X)) T) '(3 A 4.3))  ==  (MAPCAR (ALWAYS T) '(3 A 4.3))  => (T T T)  (MAPCAR #'(LAMBDA (X) (AND (NUMBERP X) (ZEROP X))) '(3 A 0.0))  ==  (MAPCAR (CONJOIN #'NUMBERP #'ZEROP) '(3 A 0.0))  => (NIL NIL T)  (FIND-IF #'(LAMBDA (X) (AND (INTEGERP X) (SYMBOLP X))) '(3.0 A 4))  ==  (FIND-IF (DISJOIN #'INTEGERP #'SYMBOLP) '(3.0 A 4))  => A  (FUNCALL #'(LAMBDA (&REST X) (REVERSE (APPLY #'LIST* X))) 3 4 5 '(6 7))  ==  (FUNCALL (COMPOSE #'REVERSE #'LIST*) 3 4 5 '(6 7))  => (7 6 5 4 3)  (FIND-IF-NOT #'ZEROP '(0 0 3))  ==  (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3))  => 3Rationale:  This can contribute to syntactic conciseness, and may sometimes  even make things easier for a compiler to recognize and compile  efficiently.  In principle, a proposal to flush the :TEST-NOT keywords and the  -IF-NOT functions could even be entertained if the COMPLEMENT  function were added.Current Practice:  No Common Lisp implementations provide these primitives, but they do  exist in the T language.Cost to Implementors:  A straightforward implementation is simple to cook up. The definitions  given here would suffice. Typically some additional work might be  desirable to make these open code in interesting ways.  (DEFUN COMPOSE (&REST FUNCTIONS)    (COND ((NOT FUNCTIONS)	   (ERROR "COMPOSE requires at least one function."))	  ((NOT (REST FUNCTIONS))	   (FIRST FUNCTIONS))	  (T	   (LET ((REVERSED-FUNCTIONS (REVERSE FUNCTIONS)))	     (LET ((LAST-FUNCTION   (FIRST REVERSED-FUNCTIONS))	           (OTHER-FUNCTIONS (REST  REVERSED-FUNCTIONS)))               #'(LAMBDA (&REST ARGUMENTS)                   (DO ((O OTHER-FUNCTIONS (CDR O))			(VAL (APPLY LAST-FUNCTION ARGUMENTS)			     (FUNCALL (CAR O) VAL)))		       ((NULL O) VAL))))))))  (DEFUN CONJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL T (AND VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR (NULL VAL) (NULL F)) VAL))))  (DEFUN DISJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL NIL (OR VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR VAL (NULL F)) VAL))))  (DEFUN COMPLEMENT (FUNCTION)    #'(LAMBDA (&REST ARGUMENTS)        (NOT (APPLY FUNCTION ARGUMENTS))))  (DEFUN ALWAYS (VALUE)    #'(LAMBDA (&REST ARGUMENTS)         (DECLARE (IGNORE ARGUMENTS))        VALUE))Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  (COMPLEMENT BENEFITS)Benefits:  Some code would be more clear.   Some compilers might be able to produce better code.  Takes a step toward being able to flush the -IF-NOT functions  and the :TEST-NOT keywords, both of which are high on the list  of what people are referring to when they say Common Lisp is  bloated by too much garbage.Aesthetics:  In situations where these could be used straightforwardly, the  alternatives are far less perspicuous.Discussion:  Pitman supports the inclusion of these primitives.*start*01331 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 JUN 88 09:13:29 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 24 Jun 88  09:12:06 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 424181; Fri 24-Jun-88 12:11:52 EDTDate: Fri, 24 Jun 88 12:11 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: FUNCTION-COMPOSITION (Version 1) To: Scott.Fahlman@B.GP.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: The message of 23 Jun 88 18:16 EDT from Scott.Fahlman@B.GP.CS.CMU.EDUMessage-ID: <880624121129.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Thu, 23 Jun 88 18:16:22 EDT    From: Scott.Fahlman@B.GP.CS.CMU.EDU    Presumably the following is a typo ...Yup.    ... This all seems a bit gratuitous to me, but if the rest of you    think it would promote better programming style, I won't argue.Well, I'm not passionate about this issue, but times have changed a lotsince the last time this issue came up. Functional programming stylesare much more respectable to talk about now. I just wanted to give peoplea chance to react to them anew.*start*00847 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 SEP 88 13:42:04 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 12 Sep 88  13:41:49 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA13054; Mon, 12 Sep 88 13:40:33 PDTMessage-Id: <8809122040.AA13054@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comDate: 12 Sep 88 16:35To: cl-cleanup@sail.stanford.eduSubject: Issue: FUNCTION-COMPOSITIONThis looks OK to me.Many years ago I suggested we drop -IF-NOT and :TEST-NOT by addingthe proposed COMPLEMENT and supporting the read-macro "#~".So (FIND-IF-NOT #'ZEROP '(0 0 3)) would be the same as   (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3)) would be the same as   (FIND-IF #~ZEROP '(0 0 3))*start*00571 00024 US Date: 15 Sep 88 18:35 PDTFrom: masinter.paSubject: Re: Issue: FUNCTION-COMPOSITIONIn-reply-to: vanroggen%aitg.DEC@decwrl.dec.com's message of 12 Sep 88 16:35To: vanroggen%aitg.DEC@decwrl.dec.comcc: masinterDo you want to add this to the Discussion section?"Many years ago I suggested we drop -IF-NOT and :TEST-NOT by addingthe proposed COMPLEMENT and supporting the read-macro "#~".So (FIND-IF-NOT #'ZEROP '(0 0 3)) would be the same as   (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3)) would be the same as   (FIND-IF #~ZEROP '(0 0 3))"*start*00543 00024 US Return-Path: <vanroggen%aitg.DEC@decwrl.dec.com>Received: from decwrl.dec.com ([128.45.9.1]) by Xerox.COM ; 15 SEP 88 19:06:46 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA19853; Thu, 15 Sep 88 19:06:37 PDTDate: Thu, 15 Sep 88 19:06:37 PDTMessage-Id: <8809160206.AA19853@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: masinter.paSubject: Re: Issue: FUNCTION-COMPOSITIONIt's not a big deal.  I suppose it would enhance the proposal toinclude adding the reader-syntax for COMPLEMENT, though.*start*00940 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 OCT 88 14:33:54 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Oct 88  14:34:11 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 02 OCT 88 14:32:42 PDTDate: 2 Oct 88 14:32 PDTFrom: masinter.paSubject: Re: Issue: FUNCTION-COMPOSITION (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 23 Jun 88 17:11 EDTTo: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <881002-143242-2709@Xerox>At least today, I think that adding these functions would be a good idea ifwe also remove the -IF-NOT functions. It would be a good idea given thecurrent awkwardness of preventing both a :TEST and :TEST-NOT. Are there other things that might easily be removed?How do you feel about removing :TEST-NOT and -IF-NOT?*start*00807 00024 US Return-Path: <@multimax.ARPA:pierson%mist@multimax.ARPA>Received: from multimax.ARPA ([192.5.63.14]) by Xerox.COM ; 03 OCT 88 10:13:10 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA08264; Mon, 3 Oct 88 13:13:59 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA25888; Mon, 3 Oct 88 13:15:47 EDTMessage-Id: <8810031715.AA25888@mist.UUCP>To: masinter.pa%Xerox.COM@MULTIMAX.ENCORE.COMCc: CL-Cleanup%SAIL.STANFORD.EDU@MULTIMAX.ENCORE.COMSubject: Re: Issue: FUNCTION-COMPOSITION (Version 1) In-Reply-To: Your message of 02 Oct 88 14:32:00 -0700.             <881002-143242-2709@Xerox> Date: Mon, 03 Oct 88 13:15:45 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>I favor FUNCTION-COMPOSITION, especially if we remove or depricate:TEST-NOT and -IF-NOT.*start*00947 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 OCT 88 10:14:23 PDTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 3 Oct 88  10:14:14 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA08264; Mon, 3 Oct 88 13:13:59 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA25888; Mon, 3 Oct 88 13:15:47 EDTMessage-Id: <8810031715.AA25888@mist.UUCP>To: masinter.pa%Xerox.COM@MULTIMAX.ENCORE.COMCc: CL-Cleanup%SAIL.STANFORD.EDU@MULTIMAX.ENCORE.COMSubject: Re: Issue: FUNCTION-COMPOSITION (Version 1) In-Reply-To: Your message of 02 Oct 88 14:32:00 -0700.             <881002-143242-2709@Xerox> Date: Mon, 03 Oct 88 13:15:45 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>I favor FUNCTION-COMPOSITION, especially if we remove or depricate:TEST-NOT and -IF-NOT.*start*06348 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 11:03:51 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 5 Oct 88  11:02:02 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 471008; Wed 5-Oct-88 14:00:39 EDTDate: Wed, 5 Oct 88 14:00 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COMPOSITION (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881005140026.3.KMP@BOBOLINK.SCRC.Symbolics.COM>An updated copy to reflect discussion since the first draft: - Corrected typo in description of COMPLEMENT (notice by Fahlman). - Rewrote the rationale to reflect the e-mail discussion. - Added endorsements in the Discussion section.-----Issue:          FUNCTION-COMPOSITIONReferences:     NoneCategory:       ADDITIONEdit history:   21-Jun-88, Version 1 by Pitman	        05-Oct-88, Version 2 by PitmanStatus:	        For Internal DiscussionRelated-Issues: TEST-NOT-IF-NOTProblem Description:  A number of useful functions on functions are conspicuously  absent from Common Lisp's basic set. Among them are functions  which return constant T, constant NIL, and functions which  combine functions in common, interesting ways.Proposal (FUNCTION-COMPOSITION:NEW-FUNCTIONS):  Add the following functions:   COMPOSE &REST functions				[Function]    Returns a function whose value is the same as the composition    of the given functions. eg, (FUNCALL (COMPOSE #'F #'G #'H) A B C)    is the same as (F (G (H A B C))). Also, for example, #'CAADR may    be described as (COMPOSE #'CAR #'CAR #'CDR).   CONJOIN &REST functions				[Function]    Returns a function whose value is the same as the AND of the    given functions applied to the same arguments.   DISJOIN &REST functions				[Function]    Returns a function whose value is the same as the OR of the    given functions applied to the same arguments.       COMPLEMENT function					[Function]    Returns a function whose value is the same as the NOT of the    given function applied to the same arguments.   ALWAYS value						[Function]    Returns a function whose value is always VALUE.Examples:  (MAPCAR #'(LAMBDA (X) (DECLARE (IGNORE X)) T) '(3 A 4.3))  ==  (MAPCAR (ALWAYS T) '(3 A 4.3))  => (T T T)  (MAPCAR #'(LAMBDA (X) (AND (NUMBERP X) (ZEROP X))) '(3 A 0.0))  ==  (MAPCAR (CONJOIN #'NUMBERP #'ZEROP) '(3 A 0.0))  => (NIL NIL T)  (FIND-IF #'(LAMBDA (X) (AND (INTEGERP X) (SYMBOLP X))) '(3.0 A 4))  ==  (FIND-IF (DISJOIN #'INTEGERP #'SYMBOLP) '(3.0 A 4))  => A  (FUNCALL #'(LAMBDA (&REST X) (REVERSE (APPLY #'LIST* X))) 3 4 5 '(6 7))  ==  (FUNCALL (COMPOSE #'REVERSE #'LIST*) 3 4 5 '(6 7))  => (7 6 5 4 3)  (FIND-IF-NOT #'ZEROP '(0 0 3))  ==  (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3))  => 3Rationale:  The presence of these functions will contribute to syntactic  conciseness in some cases, and more importantly will permit  a programming style which is currently discouraged by most  Common Lisp implementations.  It is technically possible to define this functionality portably,  the really important part of this proposal is that native compiler  support is needed to really do them justice. Portable implementations  are not likely to be efficient enough for serious use.  Placing these functions in the core language not only permits  but encourages a very useful set of compiler optimizations that  would otherwise be difficult to obtain.  In principle, a proposal to flush the :TEST-NOT keywords and the  -IF-NOT functions could even be entertained if the COMPLEMENT  function were added. [See issue TEST-NOT-IF-NOT.]Current Practice:  No Common Lisp implementations provide these primitives, but they do  exist in the T language.Cost to Implementors:  A straightforward implementation is simple to cook up. The definitions  given here would suffice. Typically some additional work might be  desirable to make these open code in interesting ways.  (DEFUN COMPOSE (&REST FUNCTIONS)    (COND ((NOT FUNCTIONS)	   (ERROR "COMPOSE requires at least one function."))	  ((NOT (REST FUNCTIONS))	   (FIRST FUNCTIONS))	  (T	   (LET ((REVERSED-FUNCTIONS (REVERSE FUNCTIONS)))	     (LET ((LAST-FUNCTION   (FIRST REVERSED-FUNCTIONS))	           (OTHER-FUNCTIONS (REST  REVERSED-FUNCTIONS)))               #'(LAMBDA (&REST ARGUMENTS)                   (DO ((O OTHER-FUNCTIONS (CDR O))			(VAL (APPLY LAST-FUNCTION ARGUMENTS)			     (FUNCALL (CAR O) VAL)))		       ((NULL O) VAL))))))))  (DEFUN CONJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL T (AND VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR (NULL VAL) (NULL F)) VAL))))  (DEFUN DISJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL NIL (OR VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR VAL (NULL F)) VAL))))  (DEFUN COMPLEMENT (FUNCTION)    #'(LAMBDA (&REST ARGUMENTS)        (NOT (APPLY FUNCTION ARGUMENTS))))  (DEFUN ALWAYS (VALUE)    #'(LAMBDA (&REST ARGUMENTS)         (DECLARE (IGNORE ARGUMENTS))        VALUE))Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  (COMPLEMENT BENEFITS)Benefits:  Some code would be more clear.   Some compilers might be able to produce better code.  Takes a step toward being able to flush the -IF-NOT functions  and the :TEST-NOT keywords, both of which are high on the list  of what people are referring to when they say Common Lisp is  bloated by too much garbage.Aesthetics:  In situations where these could be used straightforwardly, the  alternatives are far less perspicuous.Discussion:  Pitman and van Roggen support the proposal.  Jim McDonald (JLM@Lucid.COM) seemed supportive of this proposal  and even suggested adding more elaborate operators such as  PERMUTE and COMMUTE. eg, (COMMUTE #'CONS) would be like what  Maclisp called XCONS.  Masinter wavered on this issue, but currently seems to support it.  Fahlman thinks this slightly gratuitous but is not opposed to   it if others think it is a good idea.*start*00866 00024 USaReturn-Path: <Scott.Fahlman@sef1.slisp.cs.cmu.edu>Received: from SEF1.SLISP.CS.CMU.EDU ([128.2.218.13]) by Xerox.COM ; 06 OCT 88 08:25:45 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU;  6 Oct 88 11:24:31 EDTTo: masinter.pacc: CL-Cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: FUNCTION-COMPOSITION (Version 1) In-reply-to: Your message of 02 Oct 88 14:32:00 -0700.             <881002-143242-2709@Xerox> Date: Thu, 06 Oct 88 11:24:02 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDU    How do you feel about removing :TEST-NOT and -IF-NOT?    This would break a lot of existing user code for merely cosmetic gain.  Ihave no objection to deprecating these options and providing something moreelegant, but I wouldn't like to see them tossed out.  I could think ofseveral hundred things that are equally ugly...-- Scott*start*01357 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 13:33:32 PDTReceived: from multimax.ARPA (MULTIMAX.ENCORE.COM) by SAIL.Stanford.EDU with TCP; 5 Oct 88  12:07:25 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA02685; Wed, 5 Oct 88 15:07:08 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA29141; Wed, 5 Oct 88 15:08:55 EDTMessage-Id: <8810051908.AA29141@mist.UUCP>To: Kent M Pitman <KMP%STONY-BROOK.SCRC.Symbolics.COM@MULTIMAX.ENCORE.COM>Cc: CL-Cleanup%SAIL.Stanford.EDU@MULTIMAX.ENCORE.COMSubject: Re: Issue: FUNCTION-COMPOSITION (Version 2) In-Reply-To: Your message of Wed, 05 Oct 88 14:00:00 -0400.             <881005140026.3.KMP@BOBOLINK.SCRC.Symbolics.COM> Date: Wed, 05 Oct 88 15:08:52 EDTFrom: Dan L. Pierson <pierson%mist@MULTIMAX.ENCORE.COM>      (MAPCAR #'(LAMBDA (X) (AND (NUMBERP X) (ZEROP X))) '(3 A 0.0))      ==      (MAPCAR (CONJOIN #'NUMBERP #'ZEROP) '(3 A 0.0))      => (NIL NIL T)          (FIND-IF #'(LAMBDA (X) (AND (INTEGERP X) (SYMBOLP X))) '(3.0 A 4))      ==      (FIND-IF (DISJOIN #'INTEGERP #'SYMBOLP) '(3.0 A 4))      => A    Shouldn't that be #'(LAMBDA ... (OR ...))?      Pitman and van Roggen support the proposal.    You can add me as a supporter.*start*01394 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 13:52:45 PDTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 5 Oct 88  13:52:44 PDTReceived: from snail.sun.com by Sun.COM (4.0/SMI-4.0)	id AA06039; Wed, 5 Oct 88 13:46:44 PDTReceived: from denali.sun.com by snail.sun.com (4.0/SMI-4.0)	id AA18198; Wed, 5 Oct 88 13:49:37 PDTReceived: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA13846; Wed, 5 Oct 88 13:51:25 PDTMessage-Id: <8810052051.AA13846@denali.sun.com>To: gls@Think.COMCc: KMP@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduSubject: Re: Issue: FUNCTION-COMPOSITION (Version 2) In-Reply-To: Your message of Wed, 05 Oct 88 16:32:02 -0400;	<8810052032.AA26451@joplin.think.com> .Date: Wed, 05 Oct 88 13:51:23 -0700From: peck@Sun.COM>Sorry I didn't catch this earlier.  I believe that this should read>>       (COND ((NULL FUNCTIONS) #'IDENTITY)>	     ...>>(1) IDENTITY is the identity element for the COMPOSE operation.>    (Actually not quite, in the case where the rightmost function>    accepts more than one argument, but close enough.)How about:	(COND ((NULL FUNCTIONS) #'VALUES)	    ...This will accept multiple arguments.ps, Anybody want to make a MULTIPLE-VALUE-CALL version of COMPOSE?*start*01898 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 14:02:15 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 5 Oct 88  13:42:31 PDTReturn-Path: <gls@Think.COM>Received: from joplin.think.com ([192.31.181.10]) by Think.COM; Wed, 5 Oct 88 15:51:56 EDTReceived: by joplin.think.com; Wed, 5 Oct 88 16:32:02 EDTDate: Wed, 5 Oct 88 16:32:02 EDTFrom: gls@Think.COMMessage-Id: <8810052032.AA26451@joplin.think.com>To: KMP@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Wed, 5 Oct 88 14:00 EDT <881005140026.3.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COMPOSITION (Version 2)   Date: Wed, 5 Oct 88 14:00 EDT   From: Kent M Pitman <KMP@stony-brook.scrc.symbolics.com>   ...   Issue:          FUNCTION-COMPOSITION   References:     None   Category:       ADDITION   Edit history:   21-Jun-88, Version 1 by Pitman		   05-Oct-88, Version 2 by Pitman   Status:	        For Internal Discussion   Related-Issues: TEST-NOT-IF-NOT   ...   Cost to Implementors:     A straightforward implementation is simple to cook up. The definitions     given here would suffice. Typically some additional work might be     desirable to make these open code in interesting ways.     (DEFUN COMPOSE (&REST FUNCTIONS)       (COND ((NOT FUNCTIONS)	      (ERROR "COMPOSE requires at least one function."))	     ...Sorry I didn't catch this earlier.  I believe that this should read       (COND ((NULL FUNCTIONS) #'IDENTITY)	     ...(1) IDENTITY is the identity element for the COMPOSE operation.    (Actually not quite, in the case where the rightmost function    accepts more than one argument, but close enough.)(2) NULL is more appropriate than NOT (this is a nit).--Guy*start*05930 00024 USfDate:  8 Oct 88 17:20 PDTSender: masinter.paSubject: DRAFT Issue: FUNCTION-COMPOSITION (Version 2)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterThe comments on this issue so far deal with the possibilityof removing :TEST-NOT, and some minor problems with thedefinition of COMPOSE. (E.g., (COMPOSE) might return#'VALUES.)However, comment on the main issue, whether this is importantenough to add to the language, is welcome.Status:	DRAFTIssue:          FUNCTION-COMPOSITIONReferences:     NoneCategory:       ADDITIONEdit history:   21-Jun-88, Version 1 by Pitman	        05-Oct-88, Version 2 by PitmanRelated-Issues: TEST-NOT-IF-NOTProblem Description:  A number of useful functions on functions are conspicuously  absent from Common Lisp's basic set. Among them are functions  which return constant T, constant NIL, and functions which  combine functions in common, interesting ways.Proposal (FUNCTION-COMPOSITION:NEW-FUNCTIONS):  Add the following functions:   COMPOSE &REST functions				[Function]    Returns a function whose value is the same as the composition    of the given functions. eg, (FUNCALL (COMPOSE #'F #'G #'H) A B C)    is the same as (F (G (H A B C))). Also, for example, #'CAADR may    be described as (COMPOSE #'CAR #'CAR #'CDR).   CONJOIN &REST functions				[Function]    Returns a function whose value is the same as the AND of the    given functions applied to the same arguments.   DISJOIN &REST functions				[Function]    Returns a function whose value is the same as the OR of the    given functions applied to the same arguments.       COMPLEMENT function					[Function]    Returns a function whose value is the same as the NOT of the    given function applied to the same arguments.   ALWAYS value						[Function]    Returns a function whose value is always VALUE.Examples:  (MAPCAR #'(LAMBDA (X) (DECLARE (IGNORE X)) T) '(3 A 4.3))  ==  (MAPCAR (ALWAYS T) '(3 A 4.3))  => (T T T)  (MAPCAR #'(LAMBDA (X) (AND (NUMBERP X) (ZEROP X))) '(3 A 0.0))  ==  (MAPCAR (CONJOIN #'NUMBERP #'ZEROP) '(3 A 0.0))  => (NIL NIL T)  (FIND-IF #'(LAMBDA (X) (AND (INTEGERP X) (SYMBOLP X))) '(3.0 A 4))  ==  (FIND-IF (DISJOIN #'INTEGERP #'SYMBOLP) '(3.0 A 4))  => A  (FUNCALL #'(LAMBDA (&REST X) (REVERSE (APPLY #'LIST* X))) 3 4 5 '(6 7))  ==  (FUNCALL (COMPOSE #'REVERSE #'LIST*) 3 4 5 '(6 7))  => (7 6 5 4 3)  (FIND-IF-NOT #'ZEROP '(0 0 3))  ==  (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3))  => 3Rationale:  The presence of these functions will contribute to syntactic  conciseness in some cases, and more importantly will permit  a programming style which is currently discouraged by most  Common Lisp implementations.  It is technically possible to define this functionality portably,  the really important part of this proposal is that native compiler  support is needed to really do them justice. Portable implementations  are not likely to be efficient enough for serious use.  Placing these functions in the core language not only permits  but encourages a very useful set of compiler optimizations that  would otherwise be difficult to obtain.  In principle, a proposal to flush the :TEST-NOT keywords and the  -IF-NOT functions could even be entertained if the COMPLEMENT  function were added. [See issue TEST-NOT-IF-NOT.]Current Practice:  No Common Lisp implementations provide these primitives, but they do  exist in the T language.Cost to Implementors:  A straightforward implementation is simple to cook up. The definitions  given here would suffice. Typically some additional work might be  desirable to make these open code in interesting ways.  (DEFUN COMPOSE (&REST FUNCTIONS)    (COND ((NOT FUNCTIONS)	   (ERROR "COMPOSE requires at least one function."))	  ((NOT (REST FUNCTIONS))	   (FIRST FUNCTIONS))	  (T	   (LET ((REVERSED-FUNCTIONS (REVERSE FUNCTIONS)))	     (LET ((LAST-FUNCTION   (FIRST REVERSED-FUNCTIONS))	           (OTHER-FUNCTIONS (REST  REVERSED-FUNCTIONS)))               #'(LAMBDA (&REST ARGUMENTS)                   (DO ((O OTHER-FUNCTIONS (CDR O))			(VAL (APPLY LAST-FUNCTION ARGUMENTS)			     (FUNCALL (CAR O) VAL)))		       ((NULL O) VAL))))))))  (DEFUN CONJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL T (AND VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR (NULL VAL) (NULL F)) VAL))))  (DEFUN DISJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL NIL (OR VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR VAL (NULL F)) VAL))))  (DEFUN COMPLEMENT (FUNCTION)    #'(LAMBDA (&REST ARGUMENTS)        (NOT (APPLY FUNCTION ARGUMENTS))))  (DEFUN ALWAYS (VALUE)    #'(LAMBDA (&REST ARGUMENTS)         (DECLARE (IGNORE ARGUMENTS))        VALUE))Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  (COMPLEMENT BENEFITS)Benefits:  Some code would be more clear.   Some compilers might be able to produce better code.  Takes a step toward being able to flush the -IF-NOT functions  and the :TEST-NOT keywords, both of which are high on the list  of what people are referring to when they say Common Lisp is  bloated by too much garbage.Aesthetics:  In situations where these could be used straightforwardly, the  alternatives are far less perspicuous.Discussion:  Pitman and van Roggen support the proposal.  Jim McDonald (JLM@Lucid.COM) seemed supportive of this proposal  and even suggested adding more elaborate operators such as  PERMUTE and COMMUTE. eg, (COMMUTE #'CONS) would be like what  Maclisp called XCONS.  Masinter wavered on this issue, but currently seems to support it.  Fahlman thinks this slightly gratuitous but is not opposed to   it if others think it is a good idea.*start*01571 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:10:32 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:10:18 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475898; Thu 13-Oct-88 17:08:46 EDTDate: Thu, 13 Oct 88 17:08 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COMPOSITION (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013170837.6.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: RPG opposed the proposal. Pitman asked if he could say why in just a couple of setences. RPG said "2 sentences? ok... I don't like it. I really don't." We decided to try to get a sense of X3J13 on this when it came up at the meeting...X3J13 meeting: Greenblatt: If adopted, maybe use less "generic" names. JonL: Gratuitous.       Also, no existing implementations have this.       [He didn't seem willing to count the T language. -kmp] RPG: Ditto. Haflich: This woudl encourage good optimizations. Masinter: A no vote on this is not a vote against functional 	   programming. KMP: That's nonsense. Of course it is. Passing this proposal would      encourage a particular style of programming, and failing to      pass it would (in the absence of other compensating proposals)      discourage it.*start*01268 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 14:11:56 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  14:10:48 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA20481; Thu, 13 Oct 88 15:09:11 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19879; Thu, 13 Oct 88 15:09:09 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132109.AA19879@defun.utah.edu>Date: Thu, 13 Oct 88 15:09:08 MDTSubject: issue FUNCTION-COMPOSITIONTo: cl-cleanup@sail.stanford.eduI tend to agree with the general sentiment expressed at the meeting thatthis is an interesting concept but it's not appropriate for standardizationat this time, except for maybe the functions COMPLEMENT and ALWAYS.  I'dvote for it if it only specified those two functions, against it otherwise.If there is a serious effort made to push this idea in to the standard now,I think it would also be appropriate to define MULTIPLE-VALUE-COMPOSE:(funcall (multiple-value-compose #'f #'g #'h) a b c)is the same as(multiple-value-call #'f    (multiple-value-call #'g        (h a b c)))-Sandra-------*start*01980 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 OCT 88 12:54:05 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Oct 88  20:32:01 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00758g; Fri, 21 Oct 88 20:31:46 PDTReceived: by bhopal id AA12949g; Fri, 21 Oct 88 20:30:15 PDTDate: Fri, 21 Oct 88 20:30:15 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810220330.AA12949@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Thu, 13 Oct 88 17:08 EDT <881013170837.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: FUNCTION-COMPOSITION (Version 2)re: My notes from Fairfax meeting...    . . .      JonL: Gratuitous.       Also, no existing implementations have this.       [He didn't seem willing to count the T language. -kmp][I don't remember saying this, but if I did, it certainly would bedefensible on the grounds that we are standardizing Common Lisp, not T].As I've outlined earlier, this is the sort of gratuitious addition to the language that ought to be tested first -- tested  by it's utililty to some vendor/implementor who feels it's worth the risk to add something like itto his product.  I deplore the tendency to think that vendors shouldn't makean offering unless it is "sanctioned" by the X3J13 committee.I say "gratuitious" because  (1) no vendor/implementor supplies them now; thus it is not "existing       practice" that needs to be standardized;  (2) no fundamental problem has been exposed because of its lack; no      implementational headaches would be resolved, and few (if any) pleas      from the user community would be addressed;  (3) no confusions exists among our community as to what these functionals      (or similar such features) mean; hence no need to clarify.-- JonL --*start*01137 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 NOV 88 16:28:10 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Nov 88  16:26:52 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 07 NOV 88 15:13:03 PSTDate: 7 Nov 88 15:13 PSTFrom: masinter.paSubject: Re: Issue: FUNCTION-COMPOSITION (Version 2)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Thu, 13 Oct 88 17:08 EDTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881107-151303-1143@Xerox>The points I remember from the meeting not reflected since are:While it is useful to encourage the "functional style" of programming,these functions are *not nearly enough* to do that. That is, if you reallywanted to build a useful library, you would find these few functionsinadequate.Extensions that no current vendor offers -- even those that have extensivesets of extensions to Common Lisp in their product -- should be viewed withgreat suspicion.*start*06834 00024 USfDate:  7 Dec 88 22:42 PSTFrom: masinter.paSubject: Issue: FUNCTION-COMPOSITION (Version 3)To: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter, sandra%defun@cs.utah.eduAgain, with two "proposals", one of which a subset of the other.Forum:          CleanupIssue:          FUNCTION-COMPOSITIONReferences:     NoneCategory:       ADDITIONEdit history:   21-Jun-88, Version 1 by Pitman	        05-Oct-88, Version 2 by Pitman	         7-Dec-88, Version 3 by MasinterRelated-Issues: TEST-NOT-IF-NOTProblem Description:  A number of useful functions on functions are conspicuously  absent from Common Lisp's basic set. Among them are functions  which return constant T, constant NIL, and functions which  combine functions in common, interesting ways.Proposal (FUNCTION-COMPOSITION:NEW-FUNCTIONS):  Add the following functions:   COMPOSE &REST functions				[Function]    Returns a function whose value is the same as the composition    of the given functions. eg, (FUNCALL (COMPOSE #'F #'G #'H) A B C)    is the same as (F (G (H A B C))). Also, for example, #'CAADR may    be described as (COMPOSE #'CAR #'CAR #'CDR).   CONJOIN &REST functions				[Function]    Returns a function whose value is the same as the AND of the    given functions applied to the same arguments.   DISJOIN &REST functions				[Function]    Returns a function whose value is the same as the OR of the    given functions applied to the same arguments.       COMPLEMENT function					[Function]    Returns a function whose value is the same as the NOT of the    given function applied to the same arguments.   ALWAYS value						[Function]    Returns a function whose value is always VALUE.Proposal: FUNCTION-COMPOSITION:COMPLEMENT-AND-ALWAYSOnly add the functions COMPLEMENT and ALWAYS. Examples:  (MAPCAR #'(LAMBDA (X) (DECLARE (IGNORE X)) T) '(3 A 4.3))  ==  (MAPCAR (ALWAYS T) '(3 A 4.3))  => (T T T)  (MAPCAR #'(LAMBDA (X) (AND (NUMBERP X) (ZEROP X))) '(3 A 0.0))  ==  (MAPCAR (CONJOIN #'NUMBERP #'ZEROP) '(3 A 0.0))  => (NIL NIL T)  (FIND-IF #'(LAMBDA (X) (AND (INTEGERP X) (SYMBOLP X))) '(3.0 A 4))  ==  (FIND-IF (DISJOIN #'INTEGERP #'SYMBOLP) '(3.0 A 4))  => A  (FUNCALL #'(LAMBDA (&REST X) (REVERSE (APPLY #'LIST* X))) 3 4 5 '(6 7))  ==  (FUNCALL (COMPOSE #'REVERSE #'LIST*) 3 4 5 '(6 7))  => (7 6 5 4 3)  (FIND-IF-NOT #'ZEROP '(0 0 3))  ==  (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3))  => 3Rationale:  The presence of these functions will contribute to syntactic  conciseness in some cases. The NEW-FUNCTIONS proposal  will permit  a programming style which is currently awkward  in most Common Lisp implementations.Current Practice:  No Common Lisp implementations provide these functions,  but they do exist in the T language.Cost to Implementors:  A straightforward implementation is simple to cook up. The definitions  given here would suffice. Typically some additional work might be  desirable to make these open code in interesting ways.  (DEFUN COMPOSE (&REST FUNCTIONS)    (COND ((NOT FUNCTIONS)	   (ERROR "COMPOSE requires at least one function."))	  ((NOT (REST FUNCTIONS))	   (FIRST FUNCTIONS))	  (T	   (LET ((REVERSED-FUNCTIONS (REVERSE FUNCTIONS)))	     (LET ((LAST-FUNCTION   (FIRST REVERSED-FUNCTIONS))	           (OTHER-FUNCTIONS (REST  REVERSED-FUNCTIONS)))               #'(LAMBDA (&REST ARGUMENTS)                   (DO ((O OTHER-FUNCTIONS (CDR O))			(VAL (APPLY LAST-FUNCTION ARGUMENTS)			     (FUNCALL (CAR O) VAL)))		       ((NULL O) VAL))))))))  (DEFUN CONJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL T (AND VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR (NULL VAL) (NULL F)) VAL))))  (DEFUN DISJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL NIL (OR VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR VAL (NULL F)) VAL))))  (DEFUN COMPLEMENT (FUNCTION)    #'(LAMBDA (&REST ARGUMENTS)        (NOT (APPLY FUNCTION ARGUMENTS))))  (DEFUN ALWAYS (VALUE)    #'(LAMBDA (&REST ARGUMENTS)         (DECLARE (IGNORE ARGUMENTS))        VALUE))Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  (COMPLEMENT BENEFITS)Benefits:  Some code would be more clear.   Some compilers might be able to produce better code.  Takes a step toward being able to flush the -IF-NOT functions  and the :TEST-NOT keywords, both of which are high on the list  of what people are referring to when they say Common Lisp is  bloated by too much garbage.Aesthetics:  In situations where these could be used straightforwardly, the  alternatives are far less perspicuous.Discussion:  It is technically possible to define this functionality portably,  the really important part of this proposal is that native compiler  support is needed to really do them justice. Portable implementations  are not likely to be efficient enough for serious use.  Placing these functions in the core language not only permits  but encourages a very useful set of compiler optimizations that  would otherwise be difficult to obtain.  In principle, a proposal to flush the :TEST-NOT keywords and the  -IF-NOT functions could even be entertained if the COMPLEMENT  function were added. [See issue TEST-NOT-IF-NOT.]  Pitman and van Roggen support the proposal.  Jim McDonald (JLM@Lucid.COM) seemed supportive of this proposal  and even suggested adding more elaborate operators such as  PERMUTE and COMMUTE. eg, (COMMUTE #'CONS) would be like what  Maclisp called XCONS.Other comments:"I don't like it.  I really don't."The names chosen are too "generic"; pick other names.No existing implementations have functions like these, although theycould easily have added them.If COMPOSE is added, deal with multiple values, e.g., (funcall (multiple-value-compose #'f #'g #'h) a b c)is the same as(multiple-value-call #'f    (multiple-value-call #'g        (h a b c)))"this is the sort of gratuitious addition to the language that ought to be tested first -- tested  by it's utililty to some vendor/implementor who feels it's worth the risk to add something like itto his product.  I deplore the tendency to think that vendors shouldn't makean offering unless it is "sanctioned" by the X3J13 committee."        TITAN 
         TITAN 
         ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))                                                                    	              q                                   /      }       5       1       
      q                            c             9              ,                     
      ;              l             e       %z*start*06753 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 22:57:05 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Dec 88  22:46:34 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 07 DEC 88 22:43:06 PSTDate: 7 Dec 88 22:42 PSTFrom: masinter.paSubject: Issue: FUNCTION-COMPOSITION (Version 3)To: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.pa, sandra%defun@cs.utah.eduMessage-ID: <881207-224306-2820@Xerox>Again, with two "proposals", one of which a subset of the other.!Forum:          CleanupIssue:          FUNCTION-COMPOSITIONReferences:     NoneCategory:       ADDITIONEdit history:   21-Jun-88, Version 1 by Pitman	        05-Oct-88, Version 2 by Pitman	         7-Dec-88, Version 3 by MasinterRelated-Issues: TEST-NOT-IF-NOTProblem Description:  A number of useful functions on functions are conspicuously  absent from Common Lisp's basic set. Among them are functions  which return constant T, constant NIL, and functions which  combine functions in common, interesting ways.Proposal (FUNCTION-COMPOSITION:NEW-FUNCTIONS):  Add the following functions:   COMPOSE &REST functions				[Function]    Returns a function whose value is the same as the composition    of the given functions. eg, (FUNCALL (COMPOSE #'F #'G #'H) A B C)    is the same as (F (G (H A B C))). Also, for example, #'CAADR may    be described as (COMPOSE #'CAR #'CAR #'CDR).   CONJOIN &REST functions				[Function]    Returns a function whose value is the same as the AND of the    given functions applied to the same arguments.   DISJOIN &REST functions				[Function]    Returns a function whose value is the same as the OR of the    given functions applied to the same arguments.       COMPLEMENT function					[Function]    Returns a function whose value is the same as the NOT of the    given function applied to the same arguments.   ALWAYS value						[Function]    Returns a function whose value is always VALUE.Proposal: FUNCTION-COMPOSITION:COMPLEMENT-AND-ALWAYSOnly add the functions COMPLEMENT and ALWAYS. Examples:  (MAPCAR #'(LAMBDA (X) (DECLARE (IGNORE X)) T) '(3 A 4.3))  ==  (MAPCAR (ALWAYS T) '(3 A 4.3))  => (T T T)  (MAPCAR #'(LAMBDA (X) (AND (NUMBERP X) (ZEROP X))) '(3 A 0.0))  ==  (MAPCAR (CONJOIN #'NUMBERP #'ZEROP) '(3 A 0.0))  => (NIL NIL T)  (FIND-IF #'(LAMBDA (X) (AND (INTEGERP X) (SYMBOLP X))) '(3.0 A 4))  ==  (FIND-IF (DISJOIN #'INTEGERP #'SYMBOLP) '(3.0 A 4))  => A  (FUNCALL #'(LAMBDA (&REST X) (REVERSE (APPLY #'LIST* X))) 3 4 5 '(6 7))  ==  (FUNCALL (COMPOSE #'REVERSE #'LIST*) 3 4 5 '(6 7))  => (7 6 5 4 3)  (FIND-IF-NOT #'ZEROP '(0 0 3))  ==  (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3))  => 3Rationale:  The presence of these functions will contribute to syntactic  conciseness in some cases. The NEW-FUNCTIONS proposal  will permit  a programming style which is currently awkward  in most Common Lisp implementations.Current Practice:  No Common Lisp implementations provide these functions,  but they do exist in the T language.Cost to Implementors:  A straightforward implementation is simple to cook up. The definitions  given here would suffice. Typically some additional work might be  desirable to make these open code in interesting ways.  (DEFUN COMPOSE (&REST FUNCTIONS)    (COND ((NOT FUNCTIONS)	   (ERROR "COMPOSE requires at least one function."))	  ((NOT (REST FUNCTIONS))	   (FIRST FUNCTIONS))	  (T	   (LET ((REVERSED-FUNCTIONS (REVERSE FUNCTIONS)))	     (LET ((LAST-FUNCTION   (FIRST REVERSED-FUNCTIONS))	           (OTHER-FUNCTIONS (REST  REVERSED-FUNCTIONS)))               #'(LAMBDA (&REST ARGUMENTS)                   (DO ((O OTHER-FUNCTIONS (CDR O))			(VAL (APPLY LAST-FUNCTION ARGUMENTS)			     (FUNCALL (CAR O) VAL)))		       ((NULL O) VAL))))))))  (DEFUN CONJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL T (AND VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR (NULL VAL) (NULL F)) VAL))))  (DEFUN DISJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL NIL (OR VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR VAL (NULL F)) VAL))))  (DEFUN COMPLEMENT (FUNCTION)    #'(LAMBDA (&REST ARGUMENTS)        (NOT (APPLY FUNCTION ARGUMENTS))))  (DEFUN ALWAYS (VALUE)    #'(LAMBDA (&REST ARGUMENTS)         (DECLARE (IGNORE ARGUMENTS))        VALUE))Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  (COMPLEMENT BENEFITS)Benefits:  Some code would be more clear.   Some compilers might be able to produce better code.  Takes a step toward being able to flush the -IF-NOT functions  and the :TEST-NOT keywords, both of which are high on the list  of what people are referring to when they say Common Lisp is  bloated by too much garbage.Aesthetics:  In situations where these could be used straightforwardly, the  alternatives are far less perspicuous.Discussion:  It is technically possible to define this functionality portably,  the really important part of this proposal is that native compiler  support is needed to really do them justice. Portable implementations  are not likely to be efficient enough for serious use.  Placing these functions in the core language not only permits  but encourages a very useful set of compiler optimizations that  would otherwise be difficult to obtain.  In principle, a proposal to flush the :TEST-NOT keywords and the  -IF-NOT functions could even be entertained if the COMPLEMENT  function were added. [See issue TEST-NOT-IF-NOT.]  Pitman and van Roggen support the proposal.  Jim McDonald (JLM@Lucid.COM) seemed supportive of this proposal  and even suggested adding more elaborate operators such as  PERMUTE and COMMUTE. eg, (COMMUTE #'CONS) would be like what  Maclisp called XCONS.Other comments:"I don't like it.  I really don't."The names chosen are too "generic"; pick other names.No existing implementations have functions like these, although theycould easily have added them.If COMPOSE is added, deal with multiple values, e.g., (funcall (multiple-value-compose #'f #'g #'h) a b c)is the same as(multiple-value-call #'f    (multiple-value-call #'g        (h a b c)))"this is the sort of gratuitious addition to the language that ought to be tested first -- tested  by it's utililty to some vendor/implementor who feels it's worth the risk to add something like itto his product.  I deplore the tendency to think that vendors shouldn't makean offering unless it is "sanctioned" by the X3J13 committee."*start*01000 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 17:46:14 PSTReceived: from RELAY.CS.NET (GW1.CS.NET) by SAIL.Stanford.EDU with TCP; 8 Dec 88  17:45:11 PSTReceived: from relay2.cs.net by RELAY.CS.NET id al05132; 8 Dec 88 17:11 ESTReceived: from draper.com by RELAY.CS.NET id ab00694; 8 Dec 88 16:18 ESTDate: Thu, 8 Dec 88 14:37 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: FUNCTION-COMPOSITION (Version 3)To: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525The names are OK with me except for ALWAYS.  ALWAYS reminds me of theSOME/EVERY/etc. mapping functions, perhaps because it's a LOOP keyword(btw, what's the status of LOOP keywords?).  I would prefer somethinglike RETURNER.  Also, I presume it's defined as taking (&rest ignore)for an arglist.  Is that true?  Shouldn't that be specified in the proposal?*start*00868 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 21:05:42 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  21:05:12 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 DEC 88 21:04:24 PSTDate: 8 Dec 88 21:04 PSTFrom: masinter.paSubject: Re: Issue: FUNCTION-COMPOSITION (Version 3)In-reply-to: "Steve Bacher (Batchman)" <SEB1525@draper.com>'s message of Thu, 8 Dec 88 14:37 ESTTo: "Steve Bacher (Batchman)" <SEB1525@draper.com>cc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <881208-210424-5323@Xerox>Unless I get a new draft, I will ship Version 3. It says, I think, that thenames are too "generic". Frankly, I don't like returner any better thanalways.Even if it passes, we can vote in new names.*start*02052 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 10 DEC 88 04:57:14 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03562g; Sat, 10 Dec 88 04:54:50 PSTReceived: by bhopal id AA00356g; Sat, 10 Dec 88 04:56:45 PSTDate: Sat, 10 Dec 88 04:56:45 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812101256.AA00356@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.edu, sandra%defun@cs.utah.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 7 Dec 88 22:42 PST <881207-224306-2820@Xerox>Subject: Issue: FUNCTION-COMPOSITION (Version 3)Although the discussion mentions some criticism from within the subcommitte,I don't think it does full justice.  For the record, I would like torepeat my grounds for dismissing this one, and also repeat your (Larry's)negative review.    Date: Fri, 21 Oct 88 20:30:15 PDT    From: Jon L White <jonl>    Subject: Issue: FUNCTION-COMPOSITION (Version 2)    . . .     I say "gratuitious" because      (1) no vendor/implementor supplies them now; thus it is not "existing 	  practice" that needs to be standardized;      (2) no fundamental problem has been exposed because of its lack; no	  implementational headaches would be resolved, and few (if any) pleas	  from the user community would be addressed;      (3) no confusions exists among our community as to what these functionals	  (or similar such features) mean; hence no need to clarify.    Date: 7 Nov 88 15:13 PST    From: masinter.pa@Xerox.COM    Subject: Re: Issue: FUNCTION-COMPOSITION (Version 2)    . . .     While it is useful to encourage the "functional style" of programming,    these functions are *not nearly enough* to do that. That is, if you really    wanted to build a useful library, you would find these few functions    inadequate.    Extensions that no current vendor offers -- even those that have extensive    sets of extensions to Common Lisp in their product -- should be viewed with    great suspicion.-- JonL --*start*08274 00024 US Date: 12 Dec 88 11:04 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: FUNCTION-COMPOSITION (Version 4)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noForum:          CleanupIssue:          FUNCTION-COMPOSITIONReferences:     NoneCategory:       ADDITIONEdit history:   21-Jun-88, Version 1 by Pitman                05-Oct-88, Version 2 by Pitman                 7-Dec-88, Version 3 by Masinter                12-Dec-88, Version 4 by Masinter (additional comments)Related-Issues: TEST-NOT-IF-NOTProblem Description:  A number of useful functions on functions are conspicuously  absent from Common Lisp's basic set. Among them are functions  which return constant T, constant NIL, and functions which  combine functions in common, interesting ways.Proposal (FUNCTION-COMPOSITION:NEW-FUNCTIONS):  Add the following functions:   COMPOSE &REST functions				[Function]    Returns a function whose value is the same as the composition    of the given functions. eg, (FUNCALL (COMPOSE #'F #'G #'H) A B C)    is the same as (F (G (H A B C))). Also, for example, #'CAADR may    be described as (COMPOSE #'CAR #'CAR #'CDR).   CONJOIN &REST functions				[Function]    Returns a function whose value is the same as the AND of the    given functions applied to the same arguments.   DISJOIN &REST functions				[Function]    Returns a function whose value is the same as the OR of the    given functions applied to the same arguments.       COMPLEMENT function					[Function]    Returns a function whose value is the same as the NOT of the    given function applied to the same arguments.   ALWAYS value						[Function]    Returns a function whose value is always VALUE.Proposal: FUNCTION-COMPOSITION:COMPLEMENT-AND-ALWAYSOnly add the functions COMPLEMENT and ALWAYS. Examples:  (MAPCAR #'(LAMBDA (X) (DECLARE (IGNORE X)) T) '(3 A 4.3))  ==  (MAPCAR (ALWAYS T) '(3 A 4.3))  => (T T T)  (MAPCAR #'(LAMBDA (X) (AND (NUMBERP X) (ZEROP X))) '(3 A 0.0))  ==  (MAPCAR (CONJOIN #'NUMBERP #'ZEROP) '(3 A 0.0))  => (NIL NIL T)  (FIND-IF #'(LAMBDA (X) (AND (INTEGERP X) (SYMBOLP X))) '(3.0 A 4))  ==  (FIND-IF (DISJOIN #'INTEGERP #'SYMBOLP) '(3.0 A 4))  => A  (FUNCALL #'(LAMBDA (&REST X) (REVERSE (APPLY #'LIST* X))) 3 4 5 '(6 7))  ==  (FUNCALL (COMPOSE #'REVERSE #'LIST*) 3 4 5 '(6 7))  => (7 6 5 4 3)  (FIND-IF-NOT #'ZEROP '(0 0 3))  ==  (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3))  => 3Rationale:  The presence of these functions will contribute to syntactic  conciseness in some cases. The NEW-FUNCTIONS proposal  will permit  a programming style which is currently awkward  in most Common Lisp implementations.Current Practice:  No Common Lisp implementations provide these functions,  but they do exist in the T language.Cost to Implementors:  A straightforward implementation is simple to cook up. The definitions  given here would suffice. Typically some additional work might be  desirable to make these open code in interesting ways.  (DEFUN COMPOSE (&REST FUNCTIONS)    (COND ((NOT FUNCTIONS)	   (ERROR "COMPOSE requires at least one function."))	  ((NOT (REST FUNCTIONS))	   (FIRST FUNCTIONS))	  (T	   (LET ((REVERSED-FUNCTIONS (REVERSE FUNCTIONS)))	     (LET ((LAST-FUNCTION   (FIRST REVERSED-FUNCTIONS))	           (OTHER-FUNCTIONS (REST  REVERSED-FUNCTIONS)))               #'(LAMBDA (&REST ARGUMENTS)                   (DO ((O OTHER-FUNCTIONS (CDR O))			(VAL (APPLY LAST-FUNCTION ARGUMENTS)			     (FUNCALL (CAR O) VAL)))		       ((NULL O) VAL))))))))  (DEFUN CONJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL T (AND VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR (NULL VAL) (NULL F)) VAL))))  (DEFUN DISJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL NIL (OR VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR VAL (NULL F)) VAL))))  (DEFUN COMPLEMENT (FUNCTION)    #'(LAMBDA (&REST ARGUMENTS)        (NOT (APPLY FUNCTION ARGUMENTS))))  (DEFUN ALWAYS (VALUE)    #'(LAMBDA (&REST ARGUMENTS)         (DECLARE (IGNORE ARGUMENTS))        VALUE))Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  (COMPLEMENT BENEFITS)Benefits:  Some code would be more clear.   Some compilers might be able to produce better code.  Takes a step toward being able to flush the -IF-NOT functions  and the :TEST-NOT keywords, both of which are high on the list  of what people are referring to when they say Common Lisp is  bloated by too much garbage.Aesthetics:  In situations where these could be used straightforwardly, the  alternatives are far less perspicuous.Discussion:  It is technically possible to define this functionality portably,  the really important part of this proposal is that native compiler  support is needed to really do them justice. Portable implementations  are not likely to be efficient enough for serious use.  Placing these functions in the core language not only permits  but encourages a very useful set of compiler optimizations that  would otherwise be difficult to obtain.  In principle, a proposal to flush the :TEST-NOT keywords and the  -IF-NOT functions could even be entertained if the COMPLEMENT  function were added. [See issue TEST-NOT-IF-NOT.]  Pitman and van Roggen support the proposal.  Jim McDonald (JLM@Lucid.COM) seemed supportive of this proposal  and even suggested adding more elaborate operators such as  PERMUTE and COMMUTE. eg, (COMMUTE #'CONS) would be like what  Maclisp called XCONS.Other comments:"I don't like it.  I really don't."The names chosen are too "generic"; pick other names.No existing implementations have functions like these, although theycould easily have added them.If COMPOSE is added, deal with multiple values, e.g., (funcall (multiple-value-compose #'f #'g #'h) a b c)is the same as(multiple-value-call #'f    (multiple-value-call #'g        (h a b c)))"this is the sort of gratuitious addition to the language that ought to be tested first -- tested  by it's utililty to some vendor/implementor who feels it's worth the risk to add something like itto his product.  I deplore the tendency to think that vendors shouldn't makean offering unless it is "sanctioned" by the X3J13 committee."Additional Comments:"The names are OK with me except for ALWAYS.  ALWAYS reminds me of theSOME/EVERY/etc. mapping functions, perhaps because it's a LOOP keyword(btw, what's the status of LOOP keywords?).  I would prefer somethinglike RETURNER.  Also, I presume it's defined as taking (&rest ignore)for an arglist.  Is that true?  Shouldn't that be specified in the proposal?""Although the discussion mentions some criticism from within the subcommitte,I don't think it does full justice.  ....    . . .     I say "gratuitious" because      (1) no vendor/implementor supplies them now; thus it is not "existing 	  practice" that needs to be standardized;      (2) no fundamental problem has been exposed because of its lack; no	  implementational headaches would be resolved, and few (if any) pleas	  from the user community would be addressed;      (3) no confusions exists among our community as to what these functionals	  (or similar such features) mean; hence no need to clarify.    . . .     While it is useful to encourage the "functional style" of programming,    these functions are *not nearly enough* to do that. That is, if you really    wanted to build a useful library, you would find these few functions    inadequate.    Extensions that no current vendor offers -- even those that have extensive    sets of extensions to Common Lisp in their product -- should be viewed with    great suspicion."        TITAN 
          TITAN 
                                                           	                                                 /      }       5       1       
      q                            c             9              ,                     
      ;              l             	       $z*start*08222 00024 USfReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 11:51:02 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  11:29:00 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 12 DEC 88 11:17:46 PSTDate: 12 Dec 88 11:04 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: FUNCTION-COMPOSITION (Version 4)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-111746-4560@Xerox>!Forum:          CleanupIssue:          FUNCTION-COMPOSITIONReferences:     NoneCategory:       ADDITIONEdit history:   21-Jun-88, Version 1 by Pitman                05-Oct-88, Version 2 by Pitman                 7-Dec-88, Version 3 by Masinter                12-Dec-88, Version 4 by Masinter (additional comments)Related-Issues: TEST-NOT-IF-NOTProblem Description:  A number of useful functions on functions are conspicuously  absent from Common Lisp's basic set. Among them are functions  which return constant T, constant NIL, and functions which  combine functions in common, interesting ways.Proposal (FUNCTION-COMPOSITION:NEW-FUNCTIONS):  Add the following functions:   COMPOSE &REST functions				[Function]    Returns a function whose value is the same as the composition    of the given functions. eg, (FUNCALL (COMPOSE #'F #'G #'H) A B C)    is the same as (F (G (H A B C))). Also, for example, #'CAADR may    be described as (COMPOSE #'CAR #'CAR #'CDR).   CONJOIN &REST functions				[Function]    Returns a function whose value is the same as the AND of the    given functions applied to the same arguments.   DISJOIN &REST functions				[Function]    Returns a function whose value is the same as the OR of the    given functions applied to the same arguments.       COMPLEMENT function					[Function]    Returns a function whose value is the same as the NOT of the    given function applied to the same arguments.   ALWAYS value						[Function]    Returns a function whose value is always VALUE.Proposal: FUNCTION-COMPOSITION:COMPLEMENT-AND-ALWAYSOnly add the functions COMPLEMENT and ALWAYS. Examples:  (MAPCAR #'(LAMBDA (X) (DECLARE (IGNORE X)) T) '(3 A 4.3))  ==  (MAPCAR (ALWAYS T) '(3 A 4.3))  => (T T T)  (MAPCAR #'(LAMBDA (X) (AND (NUMBERP X) (ZEROP X))) '(3 A 0.0))  ==  (MAPCAR (CONJOIN #'NUMBERP #'ZEROP) '(3 A 0.0))  => (NIL NIL T)  (FIND-IF #'(LAMBDA (X) (AND (INTEGERP X) (SYMBOLP X))) '(3.0 A 4))  ==  (FIND-IF (DISJOIN #'INTEGERP #'SYMBOLP) '(3.0 A 4))  => A  (FUNCALL #'(LAMBDA (&REST X) (REVERSE (APPLY #'LIST* X))) 3 4 5 '(6 7))  ==  (FUNCALL (COMPOSE #'REVERSE #'LIST*) 3 4 5 '(6 7))  => (7 6 5 4 3)  (FIND-IF-NOT #'ZEROP '(0 0 3))  ==  (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3))  => 3Rationale:  The presence of these functions will contribute to syntactic  conciseness in some cases. The NEW-FUNCTIONS proposal  will permit  a programming style which is currently awkward  in most Common Lisp implementations.Current Practice:  No Common Lisp implementations provide these functions,  but they do exist in the T language.Cost to Implementors:  A straightforward implementation is simple to cook up. The definitions  given here would suffice. Typically some additional work might be  desirable to make these open code in interesting ways.  (DEFUN COMPOSE (&REST FUNCTIONS)    (COND ((NOT FUNCTIONS)	   (ERROR "COMPOSE requires at least one function."))	  ((NOT (REST FUNCTIONS))	   (FIRST FUNCTIONS))	  (T	   (LET ((REVERSED-FUNCTIONS (REVERSE FUNCTIONS)))	     (LET ((LAST-FUNCTION   (FIRST REVERSED-FUNCTIONS))	           (OTHER-FUNCTIONS (REST  REVERSED-FUNCTIONS)))               #'(LAMBDA (&REST ARGUMENTS)                   (DO ((O OTHER-FUNCTIONS (CDR O))			(VAL (APPLY LAST-FUNCTION ARGUMENTS)			     (FUNCALL (CAR O) VAL)))		       ((NULL O) VAL))))))))  (DEFUN CONJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL T (AND VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR (NULL VAL) (NULL F)) VAL))))  (DEFUN DISJOIN (&REST FUNCTIONS)    #'(LAMBDA (&REST ARGUMENTS)        (DO ((F FUNCTIONS (CDR F))	     (VAL NIL (OR VAL (APPLY (CAR F) ARGUMENTS))))	    ((OR VAL (NULL F)) VAL))))  (DEFUN COMPLEMENT (FUNCTION)    #'(LAMBDA (&REST ARGUMENTS)        (NOT (APPLY FUNCTION ARGUMENTS))))  (DEFUN ALWAYS (VALUE)    #'(LAMBDA (&REST ARGUMENTS)         (DECLARE (IGNORE ARGUMENTS))        VALUE))Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  (COMPLEMENT BENEFITS)Benefits:  Some code would be more clear.   Some compilers might be able to produce better code.  Takes a step toward being able to flush the -IF-NOT functions  and the :TEST-NOT keywords, both of which are high on the list  of what people are referring to when they say Common Lisp is  bloated by too much garbage.Aesthetics:  In situations where these could be used straightforwardly, the  alternatives are far less perspicuous.Discussion:  It is technically possible to define this functionality portably,  the really important part of this proposal is that native compiler  support is needed to really do them justice. Portable implementations  are not likely to be efficient enough for serious use.  Placing these functions in the core language not only permits  but encourages a very useful set of compiler optimizations that  would otherwise be difficult to obtain.  In principle, a proposal to flush the :TEST-NOT keywords and the  -IF-NOT functions could even be entertained if the COMPLEMENT  function were added. [See issue TEST-NOT-IF-NOT.]  Pitman and van Roggen support the proposal.  Jim McDonald (JLM@Lucid.COM) seemed supportive of this proposal  and even suggested adding more elaborate operators such as  PERMUTE and COMMUTE. eg, (COMMUTE #'CONS) would be like what  Maclisp called XCONS.Other comments:"I don't like it.  I really don't."The names chosen are too "generic"; pick other names.No existing implementations have functions like these, although theycould easily have added them.If COMPOSE is added, deal with multiple values, e.g., (funcall (multiple-value-compose #'f #'g #'h) a b c)is the same as(multiple-value-call #'f    (multiple-value-call #'g        (h a b c)))"this is the sort of gratuitious addition to the language that ought to be tested first -- tested  by it's utililty to some vendor/implementor who feels it's worth the risk to add something like itto his product.  I deplore the tendency to think that vendors shouldn't makean offering unless it is "sanctioned" by the X3J13 committee."Additional Comments:"The names are OK with me except for ALWAYS.  ALWAYS reminds me of theSOME/EVERY/etc. mapping functions, perhaps because it's a LOOP keyword(btw, what's the status of LOOP keywords?).  I would prefer somethinglike RETURNER.  Also, I presume it's defined as taking (&rest ignore)for an arglist.  Is that true?  Shouldn't that be specified in the proposal?""Although the discussion mentions some criticism from within the subcommitte,I don't think it does full justice.  ....    . . .     I say "gratuitious" because      (1) no vendor/implementor supplies them now; thus it is not "existing 	  practice" that needs to be standardized;      (2) no fundamental problem has been exposed because of its lack; no	  implementational headaches would be resolved, and few (if any) pleas	  from the user community would be addressed;      (3) no confusions exists among our community as to what these functionals	  (or similar such features) mean; hence no need to clarify.    . . .     While it is useful to encourage the "functional style" of programming,    these functions are *not nearly enough* to do that. That is, if you really    wanted to build a useful library, you would find these few functions    inadequate.    Extensions that no current vendor offers -- even those that have extensive    sets of extensions to Common Lisp in their product -- should be viewed with    great suspicion."*start*02782 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 14:46:06 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  14:34:17 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Mon, 12 Dec 88 16:45:18 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Mon, 12 Dec 88 17:30:37 ESTDate: Mon, 12 Dec 88 17:30 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: FUNCTION-COMPOSITION (Version 4)To: cl-cleanup@sail.stanford.eduIn-Reply-To: <881212-111746-4560@Xerox>Message-Id: <19881212223051.0.BARMAR@OCCAM.THINK.COM>    Date: 12 Dec 88 11:04 PST    From: cl-cleanup@sail.stanford.edu    !    Forum:          Cleanup    Issue:          FUNCTION-COMPOSITION    References:     None    Category:       ADDITION    Edit history:   21-Jun-88, Version 1 by Pitman		    05-Oct-88, Version 2 by Pitman		     7-Dec-88, Version 3 by Masinter		    12-Dec-88, Version 4 by Masinter (additional comments)    Related-Issues: TEST-NOT-IF-NOT    Problem Description:      A number of useful functions on functions are conspicuously      absent from Common Lisp's basic set. Among them are functions      which return constant T, constant NIL, and functions which      combine functions in common, interesting ways.    Proposal (FUNCTION-COMPOSITION:NEW-FUNCTIONS):      Add the following functions:       COMPOSE &REST functions				[Function]	Returns a function whose value is the same as the composition	of the given functions. eg, (FUNCALL (COMPOSE #'F #'G #'H) A B C)	is the same as (F (G (H A B C))). Also, for example, #'CAADR may	be described as (COMPOSE #'CAR #'CAR #'CDR).      (DEFUN COMPOSE (&REST FUNCTIONS)	(COND ((NOT FUNCTIONS)	       (ERROR "COMPOSE requires at least one function."))	      ((NOT (REST FUNCTIONS))	       (FIRST FUNCTIONS))	      (T	       (LET ((REVERSED-FUNCTIONS (REVERSE FUNCTIONS)))		 (LET ((LAST-FUNCTION   (FIRST REVERSED-FUNCTIONS))		       (OTHER-FUNCTIONS (REST  REVERSED-FUNCTIONS)))		   #'(LAMBDA (&REST ARGUMENTS)		       (DO ((O OTHER-FUNCTIONS (CDR O))			    (VAL (APPLY LAST-FUNCTION ARGUMENTS)				 (FUNCALL (CAR O) VAL)))			   ((NULL O) VAL))))))))This example implementation is not consistent with the description.  Thedescription doesn't say that at least one function is required.  I thinkthat (COMPOSE) should return #'IDENTITY, which is the identity of theCOMPOSE function.Stylistic note: Both instances of "NOT" in the above function definitionshould be "NULL", since they are testing for a list being empty, not aboolean being false.                                                barmar*start*00859 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 12:02:22 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 6 Jan 89  11:13:52 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA21890; Fri, 6 Jan 89 11:15:45 PSTReceived: from clam.sun.com ([129.144.42.62]) by snail.Sun.COM (4.1/SMI-4.0)	id AA25862; Fri, 6 Jan 89 11:01:49 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA08876; Fri, 6 Jan 89 11:01:14 PSTDate: Fri, 6 Jan 89 11:01:14 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8901061901.AA08876@clam.sun.com>To: cl-cleanup@sail.stanford.eduSubject: Issue FUNCTION-COMPOSITIONIn the letter ballot I objected to the name "ALWAYS".  I suggestthe name "CONSTANT-FN" as an alternative.*start*00983 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 15:57:52 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Jan 89  15:57:30 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 516766; Fri 6-Jan-89 18:55:49 ESTDate: Fri, 6 Jan 89 18:55 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue FUNCTION-COMPOSITIONTo: cperdue@Sun.COMcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8901061901.AA08876@clam.sun.com>Message-ID: <890106185519.1.KMP@BOBOLINK.SCRC.Symbolics.COM>I can't support any abbreviated name, and CONSTANT-FUNCTION is too long.ALWAYS is at least current practice in an existing dialect.However, if you really can't deal, how about CONSTANTLY. (MAPCAR (CONSTANTLY 7) '(A B C)) => (7 7 7)*start*00962 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 16:19:16 PSTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 6 Jan 89  16:18:50 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA28487; Fri, 6 Jan 89 16:20:38 PSTReceived: from clam.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA10478; Fri, 6 Jan 89 16:17:12 PSTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA09453; Fri, 6 Jan 89 16:18:14 PSTDate: Fri, 6 Jan 89 16:18:14 PSTFrom: cperdue@Sun.COM (Cris Perdue)Message-Id: <8901070018.AA09453@clam.sun.com>To: KMP@STONY-BROOK.SCRC.Symbolics.COM, cperdue@Sun.COMSubject: Re:  Issue FUNCTION-COMPOSITIONCc: CL-Cleanup@SAIL.Stanford.EDUCONSTANTLY?  It's kind of catchy.  I dunno.  I just thought thatALWAYS was confusing and we ought to be able to do better.Sure, CONSTANTLY is OK with me.				-Cris*start*01174 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 22:58:28 PSTReceived: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by SAIL.Stanford.EDU with TCP; 6 Jan 89  22:58:14 PSTReceived: from GANG-GANG.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via INTERNET with SMTP id 256965; 7 Jan 89 01:56:21 ESTDate: Sat, 7 Jan 89 01:55 ESTFrom: Glenn S. Burke <gsb@ALDERAAN.SCRC.Symbolics.COM>Subject: Issue FUNCTION-COMPOSITIONTo: KMP@STONY-BROOK.SCRC.Symbolics.COM, cperdue@Sun.COMcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890106185519.1.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890107065549.9.GSB@GANG-GANG.SCRC.Symbolics.COM>    Date: Fri, 6 Jan 89 18:55 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    I can't support any abbreviated name, and CONSTANT-FUNCTION is too long.    ALWAYS is at least current practice in an existing dialect.    However, if you really can't deal, how about CONSTANTLY.     (MAPCAR (CONSTANTLY 7) '(A B C)) => (7 7 7)yes to CONSTANTLY.  ALWAYS is a bad choice.*start*00653 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 06:45:08 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 9 Jan 89  06:44:18 PSTReceived: from relay2.cs.net by RELAY.CS.NET id ac16627; 9 Jan 89 8:57 ESTReceived: from draper.com by RELAY.CS.NET id ae22894; 9 Jan 89 8:41 ESTDate: Mon, 9 Jan 89 08:02 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue FUNCTION-COMPOSITIONTo: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525I like KMP's suggestion of CONSTANTLY.*start*02769 00024 US Date: 10 Feb 89 23:45 PSTFrom: masinter.paTo: cl-cleanup@sail.stanford.eduSubject: Issue: FUNCTION-COMPOSITION (Version 5)cc: masinter.paline-fold: noStatus: Passed (as amended) Jan 89 X3J13Forum:          CleanupIssue:          FUNCTION-COMPOSITIONReferences:     NoneCategory:       ADDITIONEdit history:   21-Jun-88, Version 1 by Pitman                05-Oct-88, Version 2 by Pitman                 7-Dec-88, Version 3 by Masinter                12-Dec-88, Version 4 by Masinter (additional comments)		10-Feb-89, Version 5 (as amended by X3J13 Jan 89)Related-Issues: TEST-NOT-IF-NOTProblem Description:  A number of useful functions on functions are conspicuously  absent from Common Lisp's basic set. Among them are functions  which return constant T, constant NIL, and functions which  combine functions in common, interesting ways.Proposal (FUNCTION-COMPOSITION:JAN89-X3J13):  Add the following functions:   COMPLEMENT function					[Function]    Returns a function whose value is the same as the NOT of the    given function applied to the same arguments.   CONSTANTLY value						[Function]    Returns a function whose value is always VALUE.Examples:  (MAPCAR #'(LAMBDA (X) (DECLARE (IGNORE X)) T) '(3 A 4.3))  ==  (MAPCAR (CONSTANTLY T) '(3 A 4.3))  => (T T T)  (FIND-IF-NOT #'ZEROP '(0 0 3))  ==  (FIND-IF (COMPLEMENT #'ZEROP) '(0 0 3))  => 3Rationale:  The presence of these functions will contribute to syntactic  conciseness in some cases. Current Practice:  No Common Lisp implementations provide these functions,  but they do exist in the T language.Cost to Implementors:  A straightforward implementation is simple to cook up. The definitions  given here would suffice. Typically some additional work might be  desirable to make these open code in interesting ways.  (DEFUN COMPLEMENT (FUNCTION)    #'(LAMBDA (&REST ARGUMENTS)        (NOT (APPLY FUNCTION ARGUMENTS))))  (DEFUN CONSTANTLY (VALUE)    #'(LAMBDA (&REST ARGUMENTS)         (DECLARE (IGNORE ARGUMENTS))        VALUE))Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  (COMPLEMENT BENEFITS)Benefits:  Some code would be more clear.   Some compilers might be able to produce better code.  Takes a step toward being able to flush the -IF-NOT functions  and the :TEST-NOT keywords, both of which are high on the list  of what people are referring to when they say Common Lisp is  bloated by too much garbage.Aesthetics:  In situations where these could be used straightforwardly, the  alternatives are far less perspicuous.Discussion:  Several additional functions (COMPOSE, CONJOIN) were considered and rejected at the Jan 89 X3J13 meeting.