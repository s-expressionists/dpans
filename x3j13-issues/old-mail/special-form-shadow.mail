*start*01486 00024 USaOriginator: @SAIL.Stanford.EDU:pyrnj!pyramid!bein%RUTGERS:EDU:XeroxDate: 24 Oct 87 21:09From: pyrnj!pyramid!bein%RUTGERS:EDU:XeroxSubject: macrolet/flet/labelsTo: common-lisp@sail.stanford.edu%RUTGERS:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David Bein <pyrnj!pyramid!bein@RUTGERS.EDU>Subject: macrolet/flet/labelsTo: "common-lisp@sail.stanford.edu"@RUTGERS.EDUReturn-Path: <@SAIL.Stanford.EDU:pyrnj!pyramid!bein@RUTGERS.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 OCT 87 21:09:13 PDTReceived: from RUTGERS.EDU by SAIL.STANFORD.EDU with TCP; 24 Oct 87  20:35:59 PDTReceived: by RUTGERS.EDU (5.54/1.14) with UUCP 	id AA16558; Sat, 24 Oct 87 23:39:14 EDTReceived: from pyrnova.pyramid.COM (manpyrnova) by pyramid.UUCP (5.51/OSx4.0b-870424)	id AA23234; Sat, 24 Oct 87 19:01:02 PDTReceived: by pyrnova.pyramid.COM (5.52/OSx4.0b-870424)	id AA27898; Sat, 24 Oct 87 19:02:43 PDTOriginal-Date: 24 Oct 87 18:57 PDTMessage-Id: <562125428/bein@pyrnova>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV  What is the current consensus about using a namewithin a macrolet/flet/labels construct whichis a special form? I am cleaning things up thisway and it occurred to me that things could goeither way.  I think the only really ugly one is QUOTE since mostcompilers seem to treat that specially in all kinds ofplaces. Another equally nasty one would be FUNCTION.--David*start*01318 00024 US Originator: @SAIL.Stanford.EDU:Pavel.pa%Xerox:COM:XeroxDate: 25 Oct 87 16:58From: Pavel:PA:XeroxSubject: Re: macrolet/flet/labelsIn-Reply-to: <562125428/bein@pyrnova>To: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <@SAIL.Stanford.EDU:Pavel.pa@Xerox.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 25 OCT 87 16:58:10 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 25 Oct 87  16:20:49 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 25 OCT 87 16:21:30 PSTOriginal-Date: Sun, 25 Oct 87 15:44:22 PSTMessage-ID: <871025-162130-1009@Xerox>	Date: 24 Oct 87 18:57 PDT	From: David Bein <pyrnj!pyramid!bein@RUTGERS.EDU>	  What is the current consensus about using a name	within a macrolet/flet/labels construct which	is a special form? I am cleaning things up this	way and it occurred to me that things could go	either way.I am of the opinion that the names of the special forms are reallyreserved words and that you cannot redefine them even lexically.  Thus,none of the names of special forms can be used as the defined-name inflet, labels, or macrolet.I can't imagine a case in which this could be anything but extremelyconfusing to a program reader nor can I think of any reason why it mightbe useful.	Pavel*start*02022 00024 US Originator: @SAIL.Stanford.EDU:SWM%SAPSUCKER.SCRC.Symbolics:COM:XeroxDate: 26 Oct 87 09:42From: SWM%SAPSUCKER.SCRC.Symbolics:COM:XeroxSubject: Re: macrolet/flet/labelsIn-Reply-to: <871025-162130-1009@Xerox>To: Pavel:PA:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Scott McKay <SWM@SAPSUCKER.SCRC.Symbolics.COM>Subject: Re: macrolet/flet/labelsTo: Pavel.pa, common-lisp@sail.stanford.eduIn-Reply-To: <871025-162130-1009@Xerox>Return-Path: <@SAIL.Stanford.EDU:SWM@SAPSUCKER.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 OCT 87 09:42:40 PSTReceived: from [128.81.41.223] by SAIL.STANFORD.EDU with TCP; 26 Oct 87  08:55:34 PSTReceived: from EVENING-GROSBEAK.SCRC.Symbolics.COM by SAPSUCKER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 175095; Mon 26-Oct-87 11:57:40 ESTOriginal-Date: Mon, 26 Oct 87 11:55 ESTMessage-ID: <19871026165544.1.SWM@EVENING-GROSBEAK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Sun, 25 Oct 87 15:44:22 PST    From: Pavel.pa@Xerox.COM	    Date: 24 Oct 87 18:57 PDT	    From: David Bein <pyrnj!pyramid!bein@RUTGERS.EDU>	      What is the current consensus about using a name	    within a macrolet/flet/labels construct which	    is a special form? I am cleaning things up this	    way and it occurred to me that things could go	    either way.    I am of the opinion that the names of the special forms are really    reserved words and that you cannot redefine them even lexically.  Thus,    none of the names of special forms can be used as the defined-name in    flet, labels, or macrolet.    I can't imagine a case in which this could be anything but extremely    confusing to a program reader nor can I think of any reason why it might    be useful.We subscribe to your notions here.  Our compiler warns you that you willprobably lose when you FLET/LABEL/MACROLET a special form.*start*06466 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Nov 87 00:54From: IIM%ECLA.USC:EDU:XeroxSubject: flet/labels/macroletTo: common-lisp%SAIL.STANFORD:EDU:Xeroxcc: iim%ECLA.USC:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: "Kim A. Barrett" <IIM@ECLA.USC.EDU>Subject: flet/labels/macroletTo: common-lisp@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 NOV 87 00:54:48 PSTReceived: from ECLA.USC.EDU by SAIL.STANFORD.EDU with TCP; 5 Nov 87  00:00:51 PSTOriginal-Date: Thu, 5 Nov 87 00:01:23 PSTMessage-ID: <12348118610.33.IIM@ECLA.USC.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV  It is our opinion that it is reasonable for a local function/macro to beable to shadow a special form.  If such shadowing is not allowed, it'sbasically just another totally arbitrary rule that the programmer has toremember.  It also makes for some extra work for program-analyzingprograms, either in the analysis of flet/labels/macrolet forms, where itmust check the names to see if they would shadow any of the standardspecial-forms, or at form-processing time (where it is currently impossibleto do portably).  Note that the description of how such programs should process a formwhose car is a symbol (on page 57 of CLtL) is wrong, in that it may notcorrectly handle local definitions.  The key point is that such a programis allowed to special knowledge for 'functions' other than the 24 standardspecial-forms.  If it does have such knowledge, it must first examine thelocal environment to see if its definition is being shadowed.Unfortunately, there is no portable way to examine the local environment.  Actually, as I'm sitting here writing this, my thoughts keep driftinginto a diatribe against the lack of portable mechanisms for dealing withenvironments.  If you want to write a portable code walker that accepts aninitial environment argument, either you simply can't do it ifspecial-forms can be shadowed, or you have to restrict your code walker toonly knowing about the standard special forms, which means it's stillimpossible, if the many complaints I've heard from people trying to writesuch things is any indication.  Well, if I'm going to complain about it, I suppose I should propose asolution, so here goes ...  It seems to me that the necessary functionality for examining thefunction environment is pretty easy to describe.  All you really need issomething like    (defun local-function-p (symbol environment)      "This function returns T if the specified symbol names a local       function or macro in the specified environment, and Nil otherwise.       Environment should be either the environment argument passed to a       macroexpander function (obtained with the &environment       lambda-keyword), or the environment argument to applyhook/evalhook."       ...)  I would expect that, for any given implementation, it is completelytrivial to write the code for local-function-p.  Does anyone know of acounter-example?  With this function available, when your code walker isprocessing a form which is a list whose car is a symbol, it does thefollowing  ;; special forms can be shadowed  (if (local-function-p (car form) environment)      (multiple-value-bind (newform macrop)          (macroexpand-1 form environment)        (if macrop            << recurse on newform >>            << treate the form as a function call >>            ))      << do the stuff described on page 57 of CLtL >>      )  ;; special forms cannot be shadowed  (cond ((member (car form) *the-infamous-24-built-in-special-forms-names*)         << run special code >>         )        ((local-function-p (car form) environment)         (multiple-value-bind (newform macrop)             (macroexpand-1 form environment)           (if macrop               << recurse on newform >>               << treate the form as a function call >>               )))        (t         << do the stuff described on page 57 of CLtL >>         ))  The functionality needed for augmenting environments is less obvious tome, since I haven't studied all that many code walkers to know what theirneeds are, nor all that many implementations, to know what their quirksare, as far as manipulation of environments is concerned.  I thinksomething like the following would be adequate for the walkers andimplementations I have seen, but feel free to blow holes in it.    (defun augment-function-environment           (function-list environment &optional macroletp)      "Return a new environment which is the same as environment except       that the functions specified in function-list are visible.       Environment should be an environment argument passed to a       macroexpander function or applyhook/evalhook.  Function-list is       something suitable for the second argument to flet/labels/macrolet.       If the optional third argument is true, they are added to the       environment as local macro definitions, otherwise as local       functions."      ...)  The reason for returning a new object, rather than possibly destructivelymodifying it, is so that the environment can be captured at a particularpoint without risking having it get modified during further processing.The definitions are needed for macrolet so that macroexpanding within theaugmented environment will work.  I don't know if anything clever needs tobe done with the definitions for local functions.  If so, then rather thanhaving a macroletp flag this will probably need an argument which must be(member flet labels macrolet).  Again, this seems like it should be trivialto write for a given implementation, although I feel a lot less certainabout it for augment-function-environment than I do for local-function-p.I can't offhand think of a reasonable data structure for implementingenvironments which would have problems with this, but that doesn't meanthere aren't any.  As an argument for this being sufficient, I believe that these twofunctions are all that is needed to make the PCL code walker reallyportable, up to non-standard special-forms in a particular implementation.  By the way, I have no strong attachment to the names specified above.They are only intended to be suggestive.kab-------*start*03771 00024 UU?Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Nov 87 01:59From: mincy%Think:COM:XeroxSubject: flet/labels/macroletIn-Reply-to: <12348118610.33.IIM@ECLA.USC.EDU>To: IIM%ecla.usc:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Mincy <mincy@Think.COM>Subject: flet/labels/macroletTo: IIM@ecla.usc.edu, common-lisp@sail.stanford.eduIn-Reply-To: <12348118610.33.IIM@ECLA.USC.EDU>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 NOV 87 01:59:43 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 5 Nov 87  01:16:08 PSTReturn-Path: <mincy@Think.COM>Received: from zeno by Think.COM via CHAOS; Thu, 5 Nov 87 04:15:58 ESTOriginal-Date: Thu, 5 Nov 87 04:20 ESTMessage-Id: <871105042045.8.MINCY@ZENO.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu 5 Nov 87 00:01:23-PST    From: "Kim A. Barrett" <IIM@ecla.usc.edu>      It is our opinion that it is reasonable for a local function/macro to be    able to shadow a special form.  If such shadowing is not allowed, it's    basically just another totally arbitrary rule that the programmer has to    remember.  It also makes for some extra work for program-analyzing    programs, either in the analysis of flet/labels/macrolet forms, where it    must check the names to see if they would shadow any of the standard    special-forms, or at form-processing time (where it is currently impossible    to do portably).I, just to be different, do not think that it is reasonable or desirable tohide special-forms lexically.  These forms really are special, users have to understandthem separately from other things like funtion call.  Making it so that could be lexically hidden only makes special forms superficially like other forms.You still cant funcall a special form.       It seems to me that the necessary functionality for examining the    function environment is pretty easy to describe.  All you really need is    something like	(defun local-function-p (symbol environment)	  "This function returns T if the specified symbol names a local	   function or macro in the specified environment, and Nil otherwise.	   Environment should be either the environment argument passed to a	   macroexpander function (obtained with the &environment	   lambda-keyword), or the environment argument to applyhook/evalhook."	   ...)I have had this problem as well.  One of the few places where I've *HAD* to resortto #+symbolics ..., #+lucid ...   I would suggest that it return something differentso that lexical macros can be distinguished from lexical functions.Say return multiple values where the first value is t if is a local function ormacro and the second value of t if the symbol is lexical macro.      I would expect that, for any given implementation, it is completely    trivial to write the code for local-function-p.  Does anyone know of a    counter-example?  With this function available, when your code walker is    processing a form which is a list whose car is a symbol, it does the    following      The functionality needed for augmenting environments is less obvious to    me, since I haven't studied all that many code walkers to know what their    needs are, nor all that many implementations, to know what their quirks    are, as far as manipulation of environments is concerned.  I think    something like the following would be adequate for the walkers and    implementations I have seen, but feel free to blow holes in it.I am not really convinced that this is needed.  But, I havent really thought about it.    kab-jeff*start*04621 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Nov 87 21:38From: IIM%ECLA.USC:EDU:XeroxSubject: flet/labels/macrolet & environmentsTo: common-lisp%SAIL.STANFORD:EDU:Xeroxcc: iim%ECLA.USC:EDU:Xerox, mincy%THINK:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: flet/labels/macrolet & environmentsTo: common-lisp@SAIL.STANFORD.EDUcc: iim@ECLA.USC.EDU, mincy@THINK.COMReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 NOV 87 20:30:34 PSTReceived: from ECLA.USC.EDU by SAIL.STANFORD.EDU with TCP; 5 Nov 87  19:49:57 PSTOriginal-Date: Thu, 5 Nov 87 19:49:37 PSTMessage-ID: <12348334919.24.IIM@ECLA.USC.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Thu, 5 Nov 87 04:20 EST    From: Jeff Mincy <mincy@Think.COM>      ... These forms {special-forms -- kab} really are special, users have    to understand them seperately from other things like function call. ...    You still can't funcall a special-form.   I don't think this is an adequate argument by itself.  Many macros alsohave peculiar syntax, which has to be learned on a case by case basis bythe user.  You also can't funcall macros.  But you can locally redefinethem.  There is a certain simplicity to the description of flet &etc.  It saysthat withing the specified scope, named functional references which matchthe specified names refer to the specified definitions.  If the names ofspecial-forms cannot be shadowed, you have to add a statement to thateffect as an additional caveat.  Note that I am NOT arguing that it is necessarily reasonable for a userto write such code, since it may very well break things.  But this is truefor any local redefinition, especially of 'standard' names, like thebuilt-in Common Lisp names that are in the Lisp package.  I would considerit perfectly acceptable for a compiler to issue some sort of style warningwhen it encounters a local redefinition of a standard Common Lisp function,as long as there is some way for the user to turn it off if that is REALLYwhat he means to do.  I understand that some compilers already do this.  Infact, I've just added this to my todo list, for the next time I start majorsurgery on our compiler.  Its interesting to note that everywhere else I can find where the issueof possibly redefining a special-form comes up, CLtL specifically says itis an error to do so, yet is totally silent on the subject regarding localredefinition.  Not that I'm putting this forward as an argument in favor ofallowing shadowing, since it doesn't address the question of what is theRIGHT thing to do.  I was just wondering if it was an oversight, or if itwas intentional.  As a random additional piece of dirt to throw into this mess, whathappens if you have an flet &etc in which the same name appears twice?  Myguess is that, with the usual left-to-right order of evaluation, combinedwith the scoping rules, the most obvious answer is that the LAST of thedefinitions ends up taking precedence, and the previous one(s) get ignored.Of course, the left-to-right ordering is kind of a red herring, since theorder is left undefined, like in a LET form, where the same questionarises.  Very peculiar, and probably worth a compiler warning.    ... I would suggest that it {local-function-p -- kab} return a second    value of t if the symbol is a lexical macro.  I had thought about this, and in an earlier version actually had it in,but decided it probably isn't necessary.  In the places I've seen wherethis function would get used, the second value would probably only beuseful as an efficiency hack, allowing you to avoid superflously callingmacroexpand on a form that references a local function, rather than amacro.  Not being one to sneer at efficiency issues, I think I've changedmy mind again, and agree with your suggestion.    I am not really convinced that this {augment-function-environment --    kab} is needed.  ...  You need something like augment-function-environment so that your codewalker can process an flet/labels/macrolet form and update the environmentyou are passing around in a way that keeps it compatable with the CommonLisp implementation's representation of environments, so that you can passthe updated environment to macroexpand.  Look at the PCL code walker for anexample of the horrible kludges people are forced to try in order to writesomething that is at least semi-portable.kab-------*start*00766 00024 US Date: 10 Nov 87 11:50 PSTFrom: Masinter.paTO: MasinterSubject: Issue: SPECIAL-FORM-SHADOWSubject: Re: flet/labels/macrolet & environmentsIn-reply-to: IIM@ECLA.USC.EDU's message of 5 Nov 87 21:38To: common-lisp@Sail.stanford.eduUnless some severe limits are placed on implementations as to their use of LISP functions and special forms within macro expansions of standard macros, the only reasonable *standard* for Common Lisp is to rule out completely any lexical redefinition of LISP functions and special forms.We could explicitly list some names that were portably lexically redefinable, if implementations were willing to guarantee that those names would never be used in any macro expansion. This seems awkward and baroque. *start*04743 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 87 12:06From: IIM%ECLA.USC:EDU:XeroxSubject: flet/labels/macrolet and environmentsTo: common-lisp%SAIL.STANFORD:EDU:Xeroxcc: Mincy%THINK:COM:Xerox, iim%ECLA.USC:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Subject: flet/labels/macrolet and environmentsTo: common-lisp@SAIL.STANFORD.EDUcc: Mincy@THINK.COM, iim@ECLA.USC.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 NOV 87 12:06:04 PSTReceived: from ECLA.USC.EDU by SAIL.STANFORD.EDU with TCP; 11 Nov 87  11:17:06 PSTOriginal-Date: Wed, 11 Nov 87 11:17:51 PSTMessage-ID: <12349814619.24.IIM@ECLA.USC.EDU>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV{ The mailer seems to have bounced the first time I sent this.  Apologies to anyone who receives it twice.  kab }     Date: Thu, 5 Nov 87 04:20 EST    From: Jeff Mincy <mincy@Think.COM>      ... These forms {special-forms -- kab} really are special, users have    to understand them seperately from other things like function call. ...    You still can't funcall a special-form.   I don't think this is an adequate argument by itself.  Many macros alsohave peculiar syntax, which has to be learned on a case by case basis bythe user.  You also can't funcall macros.  But you can locally redefinethem.  There is a certain simplicity to the description of flet &etc.  It saysthat within the specified scope, named functional references which matchthe specified names refer to the specified definitions.  If the names ofspecial-forms cannot be shadowed, you have to add a statement to thateffect as an additional caveat.  Note that I am NOT arguing that it is necessarily reasonable for a userto write such code, since it may very well break things.  But this is truefor any local redefinition, especially of 'standard' names, like thebuilt-in Common Lisp names that are in the Lisp package.  I would considerit perfectly acceptable for a compiler to issue some sort of style warningwhen it encounters a local redefinition of a standard Common Lisp function,as long as there is some way for the user to turn it off if that is REALLYwhat he means to do.  I understand that some compilers already do this.  Infact, I've just added this to my todo list, for the next time I start majorsurgery on our compiler.  Its interesting to note that everywhere else I can find where the issueof possibly redefining a special-form comes up, CLtL specifically says itis an error to do so, yet is totally silent on the subject regarding localredefinition.  Not that I'm putting this forward as an argument in favor ofallowing shadowing, since it doesn't address the question of what is theRIGHT thing to do.  I was just wondering if it was an oversight, or if itwas intentional.  As a random additional piece of dirt to throw into this mess, whathappens if you have an flet &etc in which the same name appears twice?  Myguess is that, with the usual left-to-right order of evaluation, combinedwith the scoping rules, the most obvious answer is that the LAST of thedefinitions ends up taking precedence, and the previous one(s) get ignored.Of course, the left-to-right ordering is kind of a red herring, since theorder is left undefined, like in a LET form, where the same questionarises.  Very peculiar, and probably worth a compiler warning.    ... I would suggest that it {local-function-p -- kab} return a second    value of t if the symbol is a lexical macro.  I had thought about this, and in an earlier version actually had it in,but decided it probably isn't necessary.  In the places I've seen wherethis function would get used, the second value would probably only beuseful as an efficiency hack, allowing you to avoid superflously callingmacroexpand on a form that references a local function, rather than amacro.  Not being one to sneer at efficiency issues, I think I've changedmy mind again, and agree with your suggestion.    I am not really convinced that this {augment-function-environment --    kab} is needed.  ...  You need something like augment-function-environment so that your codewalker can process an flet/labels/macrolet form and update the environmentyou are passing around in a way that keeps it compatable with the CommonLisp implementation's representation of environments, so that you can passthe updated environment to macroexpand.  Look at the PCL code walker for anexample of the horrible kludges people are forced to try in order to writesomething that is at least semi-portable.kab-------*start*02698 00024 UU?Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 11 Nov 87 18:44From: jbarnett%nrtc.northrop:COM:XeroxSubject: Re: Local redefs of special formsTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Barnett <jbarnett@nrtc.northrop.com>To: common-lisp@sail.stanford.eduSubject: Re: Local redefs of special formsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 NOV 87 18:44:46 PSTReceived: from NRTC.NORTHROP.COM by SAIL.STANFORD.EDU with TCP; 11 Nov 87  16:31:02 PSTReceived: by nrtc.nrtc.northrop.com id aa03871; 11 Nov 87 16:31 PSTOriginal-Date: Wed, 11 Nov 87 16:28:54 PSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIf you allow FLETS, et al, to shadow special forms, there is an implementationissue with inline function expansions nee DEFSUBSTs.  The compiler cannotsubstitute the function body and optimize as some compilers now do.  In factthe body must be (re)expanded in the null lexical environment no matter what.Consider the following example:(defsubst foo (x) (car x))(flet((car (l) (cdr l)))  (foo (car q)))The value of the flet should be (cadr q) while if the compiler is not careful,the result will be (cddr q) instead.  Note, this issue has nothing to do withspecial forms, it depends only on the interaction between an inline function,the defsubst, and local function defs, the flet.  In order to get the propersemantics AND the optimization implied by using an inline function, a compilermust mark expressions with their lexical environment.  Perhaps the expression(foo (cdr q)) in the above would need to look something like     (#<env 1> (foo (car q)))     (#<env 0) (foo (#<env 1> (car q)))     (#<env 0> (car (#<env1> (car q))))and if the flet is inlined     (#<env 0> (car (cdr (#<env 1> q))))at different times as the compiler elaborated the original.  Note, the envwrap around the variable is necesssary also:  Think about the interactionsthat might result (with more complex local fcn defs) if there is a specialdeclaration around an inline expansion    (let(...)      (declare ....)      (in-line-fcn reference ...) ...)If the subst's body is just substituted AND it binds a declared variable, allhell will break loose.I don't think that you can get out of the delemma without some sort of envwrapper.  In any event, there needs to be a good set of primitives tomanage and interagate environments so that sexy system macros and substsdon't blow the bunnies.  As long as they need to exist, why not standardize,document, and distribute them?*start*02902 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 12 Nov 87 14:49From: barmar%Think:COM:XeroxSubject: Re: Local redefs of special formsIn-Reply-to: <8711120203.AA21595@Think.COM>To: jbarnett%nrtc.northrop:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: Local redefs of special formsTo: Jeff Barnett <jbarnett@nrtc.northrop.com>Cc: common-lisp@sail.stanford.eduIn-Reply-To: <8711120203.AA21595@Think.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 NOV 87 14:48:28 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 12 Nov 87  13:54:16 PSTReturn-Path: <@occam.think.com:barmar@Think.COM>Received: from sauron.think.com by Think.COM; Thu, 12 Nov 87 13:54:29 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Thu, 12 Nov 87 13:54:24 ESTOriginal-Date: Thu, 12 Nov 87 13:56 ESTMessage-Id: <871112135607.0.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date:     Wed, 11 Nov 87 16:28:54 PST    From: Jeff Barnett <jbarnett@nrtc.northrop.com>    If you allow FLETS, et al, to shadow special forms, there is an implementation    issue with inline function expansions nee DEFSUBSTs.  The compiler cannot    substitute the function body and optimize as some compilers now do.  In fact    the body must be (re)expanded in the null lexical environment no matter what.    Consider the following example:    (defsubst foo (x) (car x))    (flet((car (l) (cdr l)))      (foo (car q)))While what you are saying is true, this particular case is not germaineto the discussion, because CAR is not a special form, it is a function.Also, if a compiler is going to do inline substitution, it should takecare to use the appropriate environment.  I tried the above on aSymbolics lispm and it simply decided not to do the inline substitution;not optimal, but within the standard.The problem you are describing DOES exist, but it is with macros.  Inthe case of inline functions, the compiler can simply punt using theexpansion if there is a name clash or use the global definition, but itdoesn't have the choice with macros.  If you change the above example to(defmacro foo (x)  `(car ,x))you will encounter the problem.  This problem that macros violatelexical scoping is well-known, and there is ongoing research on how todeal with it.  A proposed solution was the subject of a presentation atthe 1986 Lisp & Functional Programming conference, with a titlesomething like "Hygienic Macro Expansion".  There is a subcommittee ofX3J13 following the research, and if any acceptable solutions come upI'm sure they will let us know about them.                                                barmar*start*02664 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 13 Nov 87 20:58From: "Gray%dsg.csc.ti.com%RELAY.CS.NET":GV:XeroxSubject: Re: Local redefs of special formsTo: COMMON-LISP%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David N Gray <Gray%dsg.csc.ti.com@RELAY.CS.NET>To: COMMON-LISP@SAIL.STANFORD.EDUSubject: Re: Local redefs of special formsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 NOV 87 20:58:11 PSTReceived: from RELAY.CS.NET by SAIL.STANFORD.EDU with TCP; 13 Nov 87  20:15:56 PSTReceived: from relay2.cs.net by RELAY.CS.NET id ad14665; 13 Nov 87 22:27 ESTReceived: from csl.ti.com by RELAY.CS.NET id ae15242; 13 Nov 87 22:24 ESTReceived: from Kelvin by tilde id AA09293; Fri, 13 Nov 87 20:24:03 CSTMessage-Id: <2772843873-1355116@Kelvin>Original-Date: Fri, 13 Nov 87 20:24:33 CSTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> From: Jeff Barnett <jbarnett@nrtc.northrop.com>> Date: 12 Nov 87 05:21:47 GMT> > If you allow FLETS, et al, to shadow special forms, there is an implementation> issue with inline function expansions nee DEFSUBSTs.  The compiler cannot> substitute the function body and optimize as some compilers now do.  In fact> the body must be (re)expanded in the null lexical environment no matter what.> Consider the following example:> > (defsubst foo (x) (car x))> > (flet((car (l) (cdr l)))>   (foo (car q)))> > The value of the flet should be (cadr q) while if the compiler is not careful,> the result will be (cddr q) instead.   ...Jeff,But DEFSUBST is not part of Common Lisp, and I imagine that this is partof the reason it isn't.  Furthermore, DEFSUBSTs and INLINE functions arenot the same thing.  Doing it the Common Lisp way:  (proclaim '(inline foo))  (defun foo (x) (car x))the compiler is required to ensure that any inline expansion preservesthe semantics of the function call.  Rather than attempting to achievethis as a source transformation, our compiler does the expansion duringcompilation, after all local function and variable names have beenreplaced by pointers to the appropriate symbol table entries.  Thus forsomething that can be done by either a macro or inline function (aDEFSUBST is considered to be a macro in this context), it is preferableto use an inline function and let the compiler worry about getting theenvironments right.  The problem remains for things that have to beimplemented as macros because they don't follow the syntax or semanticsof a function call.    -- David Gray*start*01951 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 03:03:57 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 14 Nov 87  03:01:44 PSTReceived: ID <TOURETZKY@C.CS.CMU.EDU>; Sat 14 Nov 87 06:01:20-ESTDate: Sat, 14 Nov 87 06:01:16 ESTFrom: Dave.Touretzky@C.CS.CMU.EDUSubject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Moon@SCRC-STONY-BROOK.ARPAcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19871113002102.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <12350510652.7.TOURETZKY@C.CS.CMU.EDU>Here is an explanation of the proper role of COERCE wrt arrays:My "treat arrays as sequences" proposal was intended to do more than justextend the applicability of the sequence functions to arrays.  It was alsosupposed to change the feel of arrays in the language, by implying that shapeisn't all that important; content is what matters.To preserve the primacy of content, no matter what shape a sequence has (list,vector, or n-dimensional array), we should be able to convert it to some othershape and have the behavior of FIND, POSITION, LENGTH, ELT, etc., stay thesame.  Looked at this way, it's perfectly obvious that if ARR is a 3x3 array,then (COERCE 'LIST ARR) should return a nine element list, not a triple oftriples.As for going from lists to arrays, I suggest that  (COERCE '(ARRAY dims) SEQ)should be equivalent to  (REPLACE (MAKE-ARRAY 'dims) SEQ)Note that SEQ may be any type of sequence, including an array; its elementswill be extracted in row-major order as if ELT were used.  This definition alsopreserves the results of ELT, FIND, POSITION, etc., as long as the source anddestination objects have the same LENGTH.  If the source is longer, itsextra elements are lost; if the destination is longer, its extra elementshave undefined initial values.-- Dave-------*start*02787 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 13:41:49 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 14 Nov 87  13:39:52 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 279870; Sat 14-Nov-87 16:39:29 ESTDate: Sat, 14 Nov 87 16:39 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS (Version 4)To: Dave.Touretzky@C.CS.CMU.EDUcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <12350510652.7.TOURETZKY@C.CS.CMU.EDU>Message-ID: <19871114213919.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sat 14 Nov 87 06:01:16-EST    From: Dave.Touretzky@C.CS.CMU.EDU    Here is an explanation of the proper role of COERCE wrt arrays:    My "treat arrays as sequences" proposal was intended to do more than just    extend the applicability of the sequence functions to arrays.  It was also    supposed to change the feel of arrays in the language, by implying that shape    isn't all that important; content is what matters.Okay; this rationale should go into the SEQUENCE-FUNCTIONS-EXCLUDE-ARRAYS proposal.    To preserve the primacy of content, no matter what shape a sequence has (list,    vector, or n-dimensional array), we should be able to convert it to some other    shape and have the behavior of FIND, POSITION, LENGTH, ELT, etc., stay the    same.  Looked at this way, it's perfectly obvious that if ARR is a 3x3 array,    then (COERCE 'LIST ARR) should return a nine element list, not a triple of    triples.Sure (ignoring wrong argument order to COERCE).  Does this mean coercions fromnon-vector arrays to lists should be put back into the proposal, but with a cleardescription of what they do (unlike last time)?    As for going from lists to arrays, I suggest that      (COERCE '(ARRAY dims) SEQ)    should be equivalent to      (REPLACE (MAKE-ARRAY 'dims) SEQ)    Note that SEQ may be any type of sequence, including an array; its elements    will be extracted in row-major order as if ELT were used.  This definition also    preserves the results of ELT, FIND, POSITION, etc., as long as the source and    destination objects have the same LENGTH.  If the source is longer, its    extra elements are lost; if the destination is longer, its extra elements    have undefined initial values.This is pretty hard to understand in light of the proposal that coercing anarray to a vector should share the storage, rather than creating a new vectorand using REPLACE to copy the elements.  So is the semantics we are looking forfrom COERCE to be sharing, copying, or undefined which?*start*01727 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 14 Nov 87 14:38From: barmar%Think:COM:XeroxSubject: Re: Local redefs of special formsIn-Reply-to: <2772843873-1355116@Kelvin>To: "Gray%dsg.csc.ti.com%relay.cs.net":GV:Xeroxcc: COMMON-LISP%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: Re: Local redefs of special formsTo: David N Gray <Gray%dsg.csc.ti.com@relay.cs.net>Cc: COMMON-LISP@sail.stanford.eduIn-Reply-To: <2772843873-1355116@Kelvin>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 NOV 87 14:38:31 PSTReceived: from THINK.COM by SAIL.STANFORD.EDU with TCP; 14 Nov 87  14:05:23 PSTReturn-Path: <@Think.COM:barmar@Think.COM>Received: from sauron.think.com by Think.COM; Sat, 14 Nov 87 17:04:41 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Sat, 14 Nov 87 17:04:36 ESTOriginal-Date: Sat, 14 Nov 87 17:06 ESTMessage-Id: <871114170611.4.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Fri, 13 Nov 87  20:24:33 CST    From: David N Gray <Gray%dsg.csc.ti.com@relay.cs.net>    Jeff,    But DEFSUBST is not part of Common Lisp, and I imagine that this is part    of the reason it isn't.  Furthermore, DEFSUBSTs and INLINE functions are    not the same thing.  Doing it the Common Lisp way:      (proclaim '(inline foo))      (defun foo (x) (car x))On Symbolics Lispms, DEFSUBST is simply a macro, and	(defsubst foo (x) (car x))expands into precisely the above PROCLAIM followed by DEFUN.                                                barmar