*start*04221 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 14:39:35 PSTReceived: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by SAIL.Stanford.EDU with TCP; 6 Jan 89  14:38:35 PSTReceived: from GROUSE.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 256772; Fri 6-Jan-89 17:37:12 ESTDate: Fri, 6 Jan 89 17:36 ESTFrom: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 1)To: CL-Cleanup@Sail.Stanford.EDUcc: DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <19890106223654.4.CASSELS@GROUSE.SCRC.Symbolics.COM>Issue:        REAL-NUMBER-TYPEForum:	      CLEANUPReferences:   Table 4-1.Category:     ADDITIONEdit history: 04-JAN-89, Version 1 by Bob Cassels, Don Sakahara, Kent Pitman,                         and John AspinallStatus:	      For Internal DiscussionProblem Description:  There is no standard type specifier symbol for the CL type  '(OR RATIONAL FLOAT). Proposal (REAL-NUMBER-TYPE:REAL):  Add a standard type specifier   (REAL low high)  which means   (OR (RATIONAL low high) (FLOAT low high))  As with other such type specifiers, define that if the low and high  are omitted, the atomic specifier REAL may be used.  Clarify that NUMBER is equivalent to (OR REAL COMPLEX).Proposal (REAL-NUMBER-TYPE:REALP):  Add a specific data type predicate REALP which tests for membership in  this type.  [By analogy with NUMBERP.]Test Case:  If a programmer wishes to test for "a number between 1 and 10", the  only current CL types would be '(or (rational 1 10) (float 1 10)) or  something like '(and numberp (not complexp) (satisfies range-1-10))  with (defun range-1-10 (real) (<= 1 real 10)).  Both of these are  likely less efficient, and certainly less expressive than '(real 1 10).Rationale:  Mathematics has a name for (OR RATIONAL FLOAT) -- it is "real".  This class is important because it is all the numbers which can be  ordered.  Throughout the "Numbers" chapter, the phrase "non-complex number" is  used.  MAX, MIN, p. 198 "The arguments may be any non-complex numbers."  CIS p. 207 "The argument ... may be any non-complex number."Current Practice:  Probably nobody does this.  Cost to Implementors:  Some work is necessary to add this name.  But since the underlying  type already exists the amount of work should be minimal.  Cost to Users:  Since this is an upward-compatible extension, it may be ignored by  users.Cost of Non-Adoption:  Occassional inconvenience and/or inefficiency.Benefits:  Mathematical clarity.  Ability to define CLOS class by the same name for the purpose of  method dispatch.Aesthetics:  As mentioned under "rationale," this would be a more concise way to  express a common programming idiom.Discussion:  The name "non-complex number" is incorrect because future  implementations may wish to include numerical types which are neither  complex nor real.  [e.g. pure imaginary numbers or quaternions]    The name "scalar" is incorrect because the mathematical concept of  scalar may indeed include complex numbers.  Fortran and Pascal use the name "real" to mean what CL calls  SINGLE-FLOAT.  That should cause no significant problem, since a Lisp  program written using the type REAL will do mathematically what the  equivalent Fortran program would do.  This is because Fortran's "real"  data-type is a subtype of the CL REAL type.  The only differences  might be that the Lisp program could be less efficient and/or more  accurate.  A survey of several Fortran and Pascal books shows that the distinction  between INTEGER and REAL is that REAL numbers may have fractional  parts, while INTEGERs do not.  Later discussions explain that REALs  cover a greater range.  Much later discussions cover precision  considerations, over/underflow, etc.  So the average Fortran or Pascal  programmer should be completely comfortable with the proposed Lisp  concept of REAL.*start*00918 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 22:47:47 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Jan 89  22:45:51 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 06 JAN 89 14:54:13 PSTDate: 6 Jan 89 14:51 PSTFrom: masinter.paSubject: Re: Issue: REAL-NUMBER-TYPE (version 1)In-reply-to: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>'s message of Fri, 6 Jan 89 17:36 ESTTo: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@Sail.Stanford.EDU, DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COMMessage-ID: <890106-145413-1224@Xerox>The proposal should make REAL a CLOS class too, I think, rather than justallowing that to be done.*start*01013 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 JAN 89 01:01:12 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Jan 89  01:00:38 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate id AA08362g; Sat, 7 Jan 89 00:56:37 PSTReceived: by bhopal id AA02979g; Sat, 7 Jan 89 00:58:52 PSTDate: Sat, 7 Jan 89 00:58:52 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901070858.AA02979@bhopal>To: Cassels@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@Sail.Stanford.EDU, DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: Robert A. Cassels's message of Fri, 6 Jan 89 17:36 EST <19890106223654.4.CASSELS@GROUSE.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 1)I like this.  It's about time [but probably too late for an X3J13vote in January?].-- JonL --*start*04436 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JAN 89 08:31:38 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 8 Jan 89  08:31:18 PSTReceived: from GROUSE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 517299; Sun 8-Jan-89 11:30:01 ESTDate: Sun, 8 Jan 89 11:29 ESTFrom: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 2)To: CL-Cleanup@Sail.Stanford.EDUcc: DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COMSupersedes: <19890106223654.4.CASSELS@GROUSE.SCRC.Symbolics.COM>Message-ID: <19890108162936.5.CASSELS@GROUSE.SCRC.Symbolics.COM>Issue:        REAL-NUMBER-TYPEForum:	      CLEANUPReferences:   Table 4-1.Category:     ADDITIONEdit history: 04-JAN-89, Version 1 by Bob Cassels, Don Sakahara, Kent Pitman,                         and John Aspinall              08-JAN-89, Version 2 by Bob Cassels -- incorporate                         Masinter's suggestion and make REAL a CLOS classStatus:	      For Internal DiscussionProblem Description:  There is no standard type specifier symbol for the CL type  '(OR RATIONAL FLOAT). Proposal (REAL-NUMBER-TYPE:REAL):  Add a standard type specifier   (REAL low high)  which means   (OR (RATIONAL low high) (FLOAT low high))  As with other such type specifiers, define that if the low and high  are omitted, the atomic specifier REAL may be used.  Clarify that NUMBER is equivalent to (OR REAL COMPLEX).  Make REAL a built-in CLOS class.Proposal (REAL-NUMBER-TYPE:REALP):  Add a specific data type predicate REALP which tests for membership in  this type.  [By analogy with NUMBERP.]Test Case:  If a programmer wishes to test for "a number between 1 and 10", the  only current CL types would be '(or (rational 1 10) (float 1 10)) or  something like '(and numberp (not complexp) (satisfies range-1-10))  with (defun range-1-10 (real) (<= 1 real 10)).  Both of these are  likely less efficient, and certainly less expressive than '(real 1 10).Rationale:  Mathematics has a name for (OR RATIONAL FLOAT) -- it is "real".  This class is important because it is all the numbers which can be  ordered.  Throughout the "Numbers" chapter, the phrase "non-complex number" is  used.  MAX, MIN, p. 198 "The arguments may be any non-complex numbers."  CIS p. 207 "The argument ... may be any non-complex number."Current Practice:  Probably nobody does this.  Cost to Implementors:  Some work is necessary to add this name.  But since the underlying  type already exists the amount of work should be minimal.  Cost to Users:  Since this is an upward-compatible extension, it may be ignored by  users.Cost of Non-Adoption:  Occasional inconvenience and/or inefficiency.Benefits:  Mathematical clarity.  Ability to do CLOS method dispatch on the type.Aesthetics:  As mentioned under "rationale," this would be a more concise way to  express a common programming idiom.Discussion:  The name "non-complex number" is incorrect because future  implementations may wish to include numerical types which are neither  complex nor real.  [e.g. pure imaginary numbers or quaternions]    The name "scalar" is incorrect because the mathematical concept of  scalar may indeed include complex numbers.  Fortran and Pascal use the name "real" to mean what CL calls  SINGLE-FLOAT.  That should cause no significant problem, since a Lisp  program written using the type REAL will do mathematically what the  equivalent Fortran program would do.  This is because Fortran's "real"  data-type is a subtype of the CL REAL type.  The only differences  might be that the Lisp program could be less efficient and/or more  accurate.  A survey of several Fortran and Pascal books shows that the distinction  between INTEGER and REAL is that REAL numbers may have fractional  parts, while INTEGERs do not.  Later discussions explain that REALs  cover a greater range.  Much later discussions cover precision  considerations, over/underflow, etc.  So the average Fortran or Pascal  programmer should be completely comfortable with the proposed Lisp  concept of REAL.*start*00720 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 10:19:58 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Jan 89  10:19:56 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 JAN 89 10:15:58 PSTDate: 9 Jan 89 10:15 PSTFrom: masinter.paSubject: Re: Issue: REAL-NUMBER-TYPE (version 1)In-reply-to: "Steve Bacher (Batchman)" <SEB1525@draper.com>'s message of Mon, 9 Jan 89 08:38 ESTTo: "Steve Bacher (Batchman)" <SEB1525@draper.com>cc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <890109-101558-4153@Xerox>Surely it must use the same mechanism that <= and < do...*start*00986 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 06:45:13 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 9 Jan 89  06:44:30 PSTReceived: from relay2.cs.net by RELAY.CS.NET id aa16646; 9 Jan 89 8:57 ESTReceived: from draper.com by RELAY.CS.NET id af22894; 9 Jan 89 8:41 ESTDate: Mon, 9 Jan 89 08:38 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: REAL-NUMBER-TYPE (version 1)To: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525Hold on.  How should the following be handled: (declare (type (real 3.1415926 71/7) x))...or (typep x '(real 3.1415926 71/7))?When the type determination is made, how is the coercion of x to be done?Must x be coerced from rational to float, or from float to rational, in order to do the type check?  Should RATIONAL or RATIONALIZE be used?  ETc.,etc., etc.*start*10480 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 18:22:52 PSTReceived: from WHITE.SWW.Symbolics.COM ([128.81.57.24]) by SAIL.Stanford.EDU with TCP; 9 Jan 89  18:21:47 PSTReceived: from METAL-FLAKE.SWW.Symbolics.COM by WHITE.SWW.Symbolics.COM via CHAOS with CHAOS-MAIL id 229025; Mon 9-Jan-89 17:55:40 PSTDate: Mon, 9 Jan 89 17:57 PSTFrom: Marc Le Brun <MLB@WHITE.SWW.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 2)To: Cassels@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@Sail.Stanford.EDU, DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COM, rwg@WHITE.SWW.Symbolics.COMIn-Reply-To: <19890108162936.5.CASSELS@GROUSE.SCRC.Symbolics.COM>Message-ID: <19890110015752.6.MLB@METAL-FLAKE.SWW.Symbolics.COM>    Date: Sun, 8 Jan 89 11:29 EST    From: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>    Issue:        REAL-NUMBER-TYPE    Forum:	      CLEANUP    References:   Table 4-1.    Category:     ADDITION    Edit history: 04-JAN-89, Version 1 by Bob Cassels, Don Sakahara, Kent Pitman,			     and John Aspinall		  08-JAN-89, Version 2 by Bob Cassels -- incorporate			     Masinter's suggestion and make REAL a CLOS class    Status:	      For Internal Discussion    Problem Description:      There is no standard type specifier symbol for the CL type      '(OR RATIONAL FLOAT).     Proposal (REAL-NUMBER-TYPE:REAL):I apologize for the size of this response, but since this is sort of a "dissenting opinion" Ifelt it would be good to document the arguments as carefully as I could.There are dangers in introducing the term REAL.  It encourages the widespread confusionbetween a computer type, REAL, which of necessity denotes a countable class of symbols, withthe mathematical object (which I'll call R), which is non-denumerable.  This identification ofincommensurables has many unfortunate consequences, including ambiguous and inconsistent useof "intuitive" models.  Further, members of these sets which are commonly identified witheachother (ie real numbers and their computer images) often have incompatible semantics.The original Common Lisp specification did the world a service by eliminating this source ofpotential confusion.  If the term is to be reintroduced for pragmatic reasons, then it shouldat least done very carefully, so as not to result in further propagation, even amplification,of these problems.  It doesn't seem either responsible or forward-looking to gloss over thesedifficult issues.      Add a standard type specifier       (REAL low high)      which means       (OR (RATIONAL low high) (FLOAT low high))The Discussion section below implies that future extensions should be considered here.Suppose an implementation introduces new types which model members of R but which do notsatisfy this predicate.  (For example, quadratic fields, or symbols denoting rationalmultiples of (mathematical) pi, say).  Is the implementation allowed to extend the type REALor not?  I'd vote to allow extension, but in any case this should be stated.  (Further, mustit so extend it?)      As with other such type specifiers, define that if the low and high      are omitted, the atomic specifier REAL may be used.      Clarify that NUMBER is equivalent to (OR REAL COMPLEX).Suppose an implementation introduces new types which could considered numeric but which do notsatisfy this predicate.  (For example, quaternions, as mentioned in the Discussion).  Is theimplementation allowed to extend the type NUMBER or not?  I'd vote to allow extension, but inany case this should be stated.  (Further, must it so extend it?)      Make REAL a built-in CLOS class.    Proposal (REAL-NUMBER-TYPE:REALP):      Add a specific data type predicate REALP which tests for membership in      this type.  [By analogy with NUMBERP.]    Test Case:      If a programmer wishes to test for "a number between 1 and 10", the      only current CL types would be '(or (rational 1 10) (float 1 10)) or      something like '(and numberp (not complexp) (satisfies range-1-10))      with (defun range-1-10 (real) (<= 1 real 10)).  Both of these are      likely less efficient, and certainly less expressive than '(real 1 10).    Rationale:      Mathematics has a name for (OR RATIONAL FLOAT) -- it is "real".No.  1. As noted above R contains many "useful" elements (eg surds, mathematical pi or e) which canhave discrete symbolic representations but whose behavior is not accurately modeled by anyREAL element.2. Under many circumstances the semantics of "typical" elements of REAL are quite distinctfrom the elements of R with which they are commonly identified, leading to a variety ofsituational interpretations as "intervals", "fuzzy numbers", etc which clearly do not belongto the theory of R.3. Conversely operations on elements of R conform to a semantics of "infinite precision"obviously unattainable by REALs.4. REAL also may contain specific entities (such as -0.0) not in R.5. Because of finite range limitations REAL further does not consistently "cover" R.Sometimes this is dealt with as an error, sometimes with the introduction of non-analyticsemantics (eg setting underflows to zero), sometimes by introducing non-standard entitiespartially or wholly outside R (eg the various "infinities", or the IEEE "Not-A-Number"s which(at least in Symbolics CL) paradoxically satisfy NUMBERP!).6. Since there is no "floating canonicalization", the type REAL contains multiple distinctimages of certain elements of R (notably zero, many rationals, and many flonums which exist inmore than one so-called "precision").      This class is important because it is all the numbers which can be ordered.Agreed that the ordering property of R is important.  It might be possible to have CL sodefine REAL specifically as some kind of maximal well-ordered set (though this might betricky, in order to exclude characters as potential numbers, for example).(And, mathematically anyway, one might even ask for more rigor regarding the term "ordered",considering, for example, Conway numbers.  This would be a gratuitous comment except for IEEEhaving already opened the Pandora's box of non-standard numbers.)      Throughout the "Numbers" chapter, the phrase "non-complex number" is used.      MAX, MIN, p. 198 "The arguments may be any non-complex numbers."      CIS p. 207 "The argument ... may be any non-complex number."Presumably this is to be read as a proposal to substitute "real" for "non-complex number"?Note that these restrictions are apparently motivated by different properties: in some casesordering, in others an aversion to imaginary algebra (eg the mystifying restrictions on CIS,COMPLEX et al).  Depending on the extension policy adopted that substitution might or mightnot retain its validity under an extension (eg symbols for rational multiples of mathematicalpi aren't (OR RATIONAL FLOAT) but might be an acceptable, indeed useful, subdomain for CIS).    Current Practice:      Probably nobody does this.      Cost to Implementors:      Some work is necessary to add this name.  But since the underlying      type already exists the amount of work should be minimal.      Cost to Users:      Since this is an upward-compatible extension, it may be ignored by      users.    Cost of Non-Adoption:      Occasional inconvenience and/or inefficiency.    Benefits:      Mathematical clarity.Arguable.      Ability to do CLOS method dispatch on the type.    Aesthetics:      As mentioned under "rationale," this would be a more concise way to      express a common programming idiom.    Discussion:      The name "non-complex number" is incorrect because future      implementations may wish to include numerical types which are neither      complex nor real.  [e.g. pure imaginary numbers or quaternions]As noted above, the policy regarding possible extensions, either as future CL standards orper-implementation, should be clarified in several respects.      The name "scalar" is incorrect because the mathematical concept of      scalar may indeed include complex numbers.      Fortran and Pascal use the name "real" to mean what CL calls      SINGLE-FLOAT.  That should cause no significant problem, since a Lisp      program written using the type REAL will do mathematically what the      equivalent Fortran program would do.  This is because Fortran's "real"      data-type is a subtype of the CL REAL type.  The only differences      might be that the Lisp program could be less efficient and/or more      accurate.This needs clarification.  If by "equivalent Fortran program" is meant a FORTRAN program thatwas specifically (heroically?) written to carefully model a CL program, then this begs thequestion.  If it means "a naive translation" between languages, then this is far from obvious(eg a CL implementation might generate rationals, thereby maintain different informationthrough subsequent operations, and finally get results diverging significantly from theFORTRAN program).One could also easily imagine some careful conventional flonum-based numerical analysis beingthrown off by the introduction of a non-zero rational smaller than CL "epsilon", for example.The assignation of "more accurate" is application-dependent and implementation-dependent.      A survey of several Fortran and Pascal books shows that the distinction      between INTEGER and REAL is that REAL numbers may have fractional      parts, while INTEGERs do not.  Later discussions explain that REALs      cover a greater range.  Much later discussions cover precision      considerations, over/underflow, etc.  So the average Fortran or Pascal      programmer should be completely comfortable with the proposed Lisp      concept of REAL.Agreed, the proposed type is an extension of what's commonly meant by the name REAL.(Although there exist unusual systems where REALs are implemented by decimal rationals!)While the "average programmer" may be comfortable, the differences between CL REALs andconventional REALs and their implications should be carefully and thoroughly documented in thestandard (leaving aside the quagmire of confusion with regards to R).*start*01161 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 18:50:34 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 9 Jan 89  17:27:47 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa00610; 10 Jan 89 1:21 GMTDate: Tue, 10 Jan 89 01:23:40 GMTMessage-Id: <12536.8901100123@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: REAL-NUMBER-TYPE (version 2)To: CL-Cleanup@sail.stanford.edu> Discussion:> >   The name "non-complex number" is incorrect because future>   implementations may wish to include numerical types which are neither>   complex nor real.  [e.g. pure imaginary numbers or quaternions]>   >   The name "scalar" is incorrect because the mathematical concept of>   scalar may indeed include complex numbers.> >   Fortran and Pascal use the name "real" to mean what CL calls>   SINGLE-FLOAT.  [More about F and P.]Scheme uses REAL to mean more or less what's being proposed for CL.*start*00914 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 JAN 89 18:50:48 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 9 Jan 89  17:21:30 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa00553; 10 Jan 89 1:14 GMTDate: Tue, 10 Jan 89 01:16:52 GMTMessage-Id: <12503.8901100116@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: REAL-NUMBER-TYPE (version 1)To: CL-Cleanup@sail.stanford.eduI support this proposal.One of the advantages of Scheme over Common Lisp is that it distinguishes between abstract numbers (real, complex, rational,etc.) and representations (fixnum, ratio (well, that might beboth), etc.)  I think Common Lisp should try to do the same.*start*04699 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 06:25:26 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Jan 89  06:24:17 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 518333; Tue 10-Jan-89 09:22:23 ESTDate: Tue, 10 Jan 89 09:22 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 2)To: MLB@WHITE.SWW.Symbolics.COMcc: Cassels@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@Sail.Stanford.EDU, DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COM, rwg@WHITE.SWW.Symbolics.COMIn-Reply-To: <19890110015752.6.MLB@METAL-FLAKE.SWW.Symbolics.COM>Message-ID: <890110092213.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Would your concerns be addressed if CL adopted REAL with the provisionthat RATIONAL and FLOAT might not be an exhaustive partition of real?In that way, an IRRATIONAL type (and/or perhaps others) could be addedby implementations wanting to.Your remarks about the possibility of an irrational amount to a strengthening of the need for REAL, since it points up the fact thatanyone now using the indicated OR type is setting themselves up to beconfused by other number types which come along (either in future CL'sor in some particular present-day CL sub-dialect) which actually mightbe perfectly ok for their application. If they could say REAL, theycould permit these unexpected types in a natural way.The practical impact on CL programmers would be that they were advisedto do: (TYPECASE number   (REAL     (ETYPECASE number       (FLOAT ...)       (RATIONAL ...)))   ...)rather than: (TYPECASE number   (REAL     (TYPECASE number       (FLOAT ...)       (OTHERWISE ;presumably RATIONAL	 ...)))   ...)By the way, I'm surprised by your reaction partly because there are alreadyother things in CL (most notably a definition of COMPLEX such that RATIONALis not a subtype, and such that the real and imaginary parts must be of thesame machine representation) which are not true to mathematics already. Given this, I'm surprised you even care whether the rest of the type systemcorresponds. I would assume that any serious mathematics would want to be reconstructed atop CL rather than rely on its native partitionings, which already seem off base, as (for example) Macsyma has done. It seems clear to me that CL is not going to provide true representationsof mathematics. The real question is, should CL be permitted to provideapproximate representations? I think the answer is yes. I keep coming back to the following analogy in my mind: CL's type system is to a mathematicaltype system as floats are to reals in math ... some may legitimately saythe two have nothing to do with each other, yet you can still get usefulwork done even with the crude approximations. Indeed, the more you let the approximation -be- an approximation, themore work you're likely to get done. I think programmers don't mind makingexceptions for things Lisp might really do, but I also think the more youforce the programmer into thinking about abstract concepts which in fact do not exist in any implementation, the more the programmer can feelyou're just wasting his time and the less likely he's going to be to usethis language the next time. If CL really -had- irrationals, we would modifythe definitions of things to suit irrationals. But if CL is not going tohave irrationals, there's a fine line between the extensibility issuesyou raise and the practical day-to-day overhead of a programmer who maywonder if by the time it comes to extend the language he won't be programmingin some other language anyway...So I guess I'm willing to see a compromise, stating that RATIONAL and FLOATare not an exhaustive partition of REAL, but I'm observing that that compromise is not without cost. Beyond that, the issue is simple: programmers want a word to use. REAL isthe word which is used by other languages. We can avoid REAL if there is astrong reason to do so, but we should then have some other word. Your critical suggestions are interesting and somewhat helpful, but if younow make a constructive suggestion -- ``how should we proceed?'' -- it might be more helpful. My reading is that people are not yet so wedded tothis proposal that they wouldn't be willing to change if someone made areasonable, concrete, alternative proposal. What we most lack is time.*start*11200 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 10:43:40 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Jan 89  10:42:17 PSTReceived: from GROUSE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 518546; 10 Jan 89 13:40:31 ESTDate: Tue, 10 Jan 89 13:40 ESTFrom: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 2)To: MLB@WHITE.SWW.Symbolics.COM, Cassels@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@Sail.Stanford.EDU, DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COM, rwg@WHITE.SWW.Symbolics.COMIn-Reply-To: <19890110015752.6.MLB@METAL-FLAKE.SWW.Symbolics.COM>Message-ID: <19890110184025.0.CASSELS@GROUSE.SCRC.Symbolics.COM>    Date: Mon, 9 Jan 89 17:57 PST    From: Marc Le Brun <MLB@WHITE.SWW.Symbolics.COM>	Date: Sun, 8 Jan 89 11:29 EST	From: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>	Issue:        REAL-NUMBER-TYPE        [...]    I apologize for the size of this response, but since this is sort of a "dissenting opinion" I    felt it would be good to document the arguments as carefully as I could.    There are dangers in introducing the term REAL.  It encourages the widespread confusion    between a computer type, REAL, which of necessity denotes a countable class of symbols, with    the mathematical object (which I'll call R), which is non-denumerable.  This identification of    incommensurables has many unfortunate consequences, including ambiguous and inconsistent use    of "intuitive" models.  Further, members of these sets which are commonly identified with    eachother (ie real numbers and their computer images) often have incompatible semantics.    The original Common Lisp specification did the world a service by eliminating this source of    potential confusion.  If the term is to be reintroduced for pragmatic reasons, then it should    at least done very carefully, so as not to result in further propagation, even amplification,    of these problems.  It doesn't seem either responsible or forward-looking to gloss over these    difficult issues.	  Add a standard type specifier	   (REAL low high)	  which means	   (OR (RATIONAL low high) (FLOAT low high))    The Discussion section below implies that future extensions should be considered here.    Suppose an implementation introduces new types which model members of R but which do not    satisfy this predicate.  (For example, quadratic fields, or symbols denoting rational    multiples of (mathematical) pi, say).  Is the implementation allowed to extend the type REAL    or not?  I'd vote to allow extension, but in any case this should be stated.  (Further, must    it so extend it?)CL currently does not try to carefully restrict extensions to itself.Overall, this is probably good although there are reasons to want astrict language, too.  I think that the best we can do for any givenpoint in the development of the language is to describe what it *is* andpick the sharpest possible terms for all the concepts, so that we don't*preclude* interesting extensions.	  As with other such type specifiers, define that if the low and high	  are omitted, the atomic specifier REAL may be used.	  Clarify that NUMBER is equivalent to (OR REAL COMPLEX).... in the existing language.    Suppose an implementation introduces new types which could considered numeric but which do not    satisfy this predicate.  (For example, quaternions, as mentioned in the Discussion).  Is the    implementation allowed to extend the type NUMBER or not?  I'd vote to allow extension, but in    any case this should be stated.  (Further, must it so extend it?)Again, I don't think we should try to guess what extensions might beinteresting.  An extension should be made "the right way."	  Make REAL a built-in CLOS class.	Proposal (REAL-NUMBER-TYPE:REALP):	  Add a specific data type predicate REALP which tests for membership in	  this type.  [By analogy with NUMBERP.]	Test Case:	  If a programmer wishes to test for "a number between 1 and 10", the	  only current CL types would be '(or (rational 1 10) (float 1 10)) or	  something like '(and numberp (not complexp) (satisfies range-1-10))	  with (defun range-1-10 (real) (<= 1 real 10)).  Both of these are	  likely less efficient, and certainly less expressive than '(real 1 10).	Rationale:	  Mathematics has a name for (OR RATIONAL FLOAT) -- it is "real".    No.      1. As noted above R contains many "useful" elements (eg surds, mathematical pi or e) which can    have discrete symbolic representations but whose behavior is not accurately modeled by any    REAL element.    2. Under many circumstances the semantics of "typical" elements of REAL are quite distinct    from the elements of R with which they are commonly identified, leading to a variety of    situational interpretations as "intervals", "fuzzy numbers", etc which clearly do not belong    to the theory of R.    3. Conversely operations on elements of R conform to a semantics of "infinite precision"    obviously unattainable by REALs.    4. REAL also may contain specific entities (such as -0.0) not in R.    5. Because of finite range limitations REAL further does not consistently "cover" R.    Sometimes this is dealt with as an error, sometimes with the introduction of non-analytic    semantics (eg setting underflows to zero), sometimes by introducing non-standard entities    partially or wholly outside R (eg the various "infinities", or the IEEE "Not-A-Number"s which    (at least in Symbolics CL) paradoxically satisfy NUMBERP!).    6. Since there is no "floating canonicalization", the type REAL contains multiple distinct    images of certain elements of R (notably zero, many rationals, and many flonums which exist in    more than one so-called "precision").	  This class is important because it is all the numbers which can be ordered.    Agreed that the ordering property of R is important.  It might be possible to have CL so    define REAL specifically as some kind of maximal well-ordered set (though this might be    tricky, in order to exclude characters as potential numbers, for example).    (And, mathematically anyway, one might even ask for more rigor regarding the term "ordered",    considering, for example, Conway numbers.  This would be a gratuitous comment except for IEEE    having already opened the Pandora's box of non-standard numbers.)	  Throughout the "Numbers" chapter, the phrase "non-complex number" is used.	  MAX, MIN, p. 198 "The arguments may be any non-complex numbers."	  CIS p. 207 "The argument ... may be any non-complex number."    Presumably this is to be read as a proposal to substitute "real" for "non-complex number"?    Note that these restrictions are apparently motivated by different properties: in some cases    ordering, in others an aversion to imaginary algebra (eg the mystifying restrictions on CIS,    COMPLEX et al).  Depending on the extension policy adopted that substitution might or might    not retain its validity under an extension (eg symbols for rational multiples of mathematical    pi aren't (OR RATIONAL FLOAT) but might be an acceptable, indeed useful, subdomain for CIS).        [...]	Benefits:	  Mathematical clarity.    Arguable.	  Ability to do CLOS method dispatch on the type.	[...]	Discussion:	  The name "non-complex number" is incorrect because future	  implementations may wish to include numerical types which are neither	  complex nor real.  [e.g. pure imaginary numbers or quaternions]    As noted above, the policy regarding possible extensions, either as future CL standards or    per-implementation, should be clarified in several respects.As noted above, there should be no "policy" on future extensions.	  The name "scalar" is incorrect because the mathematical concept of	  scalar may indeed include complex numbers.	  Fortran and Pascal use the name "real" to mean what CL calls	  SINGLE-FLOAT.  That should cause no significant problem, since a Lisp	  program written using the type REAL will do mathematically what the	  equivalent Fortran program would do.  This is because Fortran's "real"	  data-type is a subtype of the CL REAL type.  The only differences	  might be that the Lisp program could be less efficient and/or more	  accurate.    This needs clarification.  If by "equivalent Fortran program" is meant a FORTRAN program that    was specifically (heroically?) written to carefully model a CL program, then this begs the    question.  If it means "a naive translation" between languages, then this is far from obvious    (eg a CL implementation might generate rationals, thereby maintain different information    through subsequent operations, and finally get results diverging significantly from the    FORTRAN program).    One could also easily imagine some careful conventional flonum-based numerical analysis being    thrown off by the introduction of a non-zero rational smaller than CL "epsilon", for example.    The assignation of "more accurate" is application-dependent and implementation-dependent.Any program which depends in any significant way on range or precisionmust *always* be translated carefully -- even when moving from oneFortran implementation to another.  Experts always need to know*exactly* how a particular computation will be done, and will alwayshave to read reference manuals carefully.	  A survey of several Fortran and Pascal books shows that the distinction	  between INTEGER and REAL is that REAL numbers may have fractional	  parts, while INTEGERs do not.  Later discussions explain that REALs	  cover a greater range.  Much later discussions cover precision	  considerations, over/underflow, etc.  So the average Fortran or Pascal	  programmer should be completely comfortable with the proposed Lisp	  concept of REAL.    Agreed, the proposed type is an extension of what's commonly meant by the name REAL.    (Although there exist unusual systems where REALs are implemented by decimal rationals!)    While the "average programmer" may be comfortable, the differences between CL REALs and    conventional REALs and their implications should be carefully and thoroughly documented in the    standard (leaving aside the quagmire of confusion with regards to R).We're not adamant about the name "real".  We do believe strongly thatthe concept should be a part of the language as a distinct named type.Suggestions for a better name are welcome.You can't seriously expect a language definition to "carefully andthoroughly" document all the differences between all other uses of aword and the use in that language.  You are certainly right that a"compatibility note" of the sort already in CLtL is warranted.  Adistilled version of your comments here would be quite appropriate.*start*02036 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 11:02:09 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Jan 89  11:01:20 PSTReceived: from GROUSE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 518575; 10 Jan 89 13:59:30 ESTDate: Tue, 10 Jan 89 13:59 ESTFrom: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 2)To: KMP@STONY-BROOK.SCRC.Symbolics.COM, MLB@WHITE.SWW.Symbolics.COMcc: Cassels@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@Sail.Stanford.EDU, DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COM, rwg@WHITE.SWW.Symbolics.COMIn-Reply-To: <890110092213.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19890110185930.1.CASSELS@GROUSE.SCRC.Symbolics.COM>    Date: Tue, 10 Jan 89 09:22 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    [..]    Beyond that, the issue is simple: programmers want a word to use.We could note here that the Symbolics Common Lisp system already has aname for the concept, and that since users have sent bug reports abouthow poorly it's implemented, they must find it useful.  The way thisconcept appears in SCL is embarrassingly wrong, so I've refrained frommentioning it so far.  But now's the time....  (NUMBER <low> <high>) is treated as equivalent to  (OR (RATIONAL <low> <high>) (FLOAT <low> <high>))Through some implementational fluke, (NUMBER * *) is equivalent toNUMBER.  Thus #C(1 2) satisfies (NUMBER * *) but not(NUMBER <IEEE minus infinity> <IEEE plus infinity>).								      REAL is    the word which is used by other languages. We can avoid REAL if there is a    strong reason to do so, but we should then have some other word. Right.  The concept is demonstrably used and useful.*start*00746 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 00:39:35 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 10 Jan 89  00:39:28 PSTReceived: from relay2.cs.net by RELAY.CS.NET id ab02627; 10 Jan 89 0:57 ESTReceived: from draper.com by RELAY.CS.NET id ac29577; 10 Jan 89 0:44 ESTDate: Tue, 10 Jan 89 00:16 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: REAL-NUMBER-TYPE (version 1)To: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525re: Surely it must use the same mechanism that <= and < do...  OK, but is this really appropriate for type checking?*start*01256 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 10 JAN 89 09:48:44 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 10 Jan 89  09:46:31 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa06415; 10 Jan 89 17:39 GMTDate: Tue, 10 Jan 89 17:41:48 GMTMessage-Id: <14751.8901101741@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: REAL-NUMBER-TYPE (version 2)To: Marc Le Brun <MLB%white.sww.symbolics.com@NSS.Cs.Ucl.AC.UK>Cc: CL-Cleanup@sail.stanford.edu   There are dangers in introducing the term REAL.  It encourages the   widespread confusion between a computer type, REAL, which of necessity   denotes a countable class of symbols, with the mathematical object (which   I'll call R), which is non-denumerable.Don't we already have such problems with COMPLEX?Hummm, maybe you're right, and we shouldn't have REAL.  Common LispCOMPLEX seems to mean the representastion rather than the set, so that     (subtypep 'rational 'complex) => NIL, TSo adding REAL seems to imply further revisions.*start*01402 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 17:36:30 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 11 Jan 89  17:22:44 PSTReceived: by ti.com id AA12536; Wed, 11 Jan 89 19:20:41 CSTReceived: from Kelvin by tilde id AA06891; Wed, 11 Jan 89 19:15:14 CSTMessage-Id: <2809559853-5576593@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 11 Jan 89 19:17:33 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "Steve Bacher (Batchman)" <SEB1525@draper.com>Cc: Cassels@STONY-BROOK.SCRC.Symbolics.COM, cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: REAL-NUMBER-TYPE (version 1)In-Reply-To: Msg of Mon, 9 Jan 89 08:38 EST from "Steve Bacher (Batchman)" <SEB1525@draper.com>> Hold on.  How should the following be handled:>  (declare (type (real 3.1415926 71/7) x))> ...or (typep x '(real 3.1415926 71/7))?> When the type determination is made, how is the coercion of x to be done?> Must x be coerced from rational to float, or from float to rational, in > order to do the type check?  Should RATIONAL or RATIONALIZE be used?  ETc.,> etc., etc.On the Explorer,  (TYPEP X '(REAL 3.1415926 71/7))  is expanded by thecompiler to  (AND (REALP X) (>= X 3.1415926) (<= X 71/7))  and then followsthe normal rules for numerical comparison from there.*start*01293 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 16:52:54 PSTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 11 Jan 89  16:51:54 PSTReceived: by ti.com id AA12442; Wed, 11 Jan 89 18:51:07 CSTReceived: from Kelvin by tilde id AA06197; Wed, 11 Jan 89 18:35:47 CSTMessage-Id: <2809557489-5434538@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Wed, 11 Jan 89 18:38:09 CSTFrom: David N Gray <Gray@DSG.csc.ti.com>To: "Robert A. Cassels" <Cassels@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@Sail.Stanford.EDUSubject: Re: Issue: REAL-NUMBER-TYPE (version 2)In-Reply-To: Msg of Sun, 8 Jan 89 11:29 EST from Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>> Proposal (REAL-NUMBER-TYPE:REAL):> >   Add a standard type specifier>    (REAL low high)>   which means>    (OR (RATIONAL low high) (FLOAT low high))...> Proposal (REAL-NUMBER-TYPE:REALP):> >   Add a specific data type predicate REALP which tests for membership in>   this type.  [By analogy with NUMBERP.]...> Current Practice:> >   Probably nobody does this.Actually, both the REAL type and REALP predicate are already supported on theTI Explorer and LMI Lambda.*start*07930 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 10:53:44 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Jan 89  10:51:58 PSTReceived: from GROUSE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 521096; Fri 13-Jan-89 13:50:20 ESTDate: Fri, 13 Jan 89 13:50 ESTFrom: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 3)To: CL-Cleanup@Sail.Stanford.EDUcc: DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COMSupersedes: <19890106223654.4.CASSELS@GROUSE.SCRC.Symbolics.COM>,            <19890108162936.5.CASSELS@GROUSE.SCRC.Symbolics.COM>Message-ID: <19890113185020.8.CASSELS@GROUSE.SCRC.Symbolics.COM>Issue:        REAL-NUMBER-TYPEForum:	      CLEANUPReferences:   Table 4-1.Category:     ADDITIONEdit history: 04-JAN-89, Version 1 by Bob Cassels, Don Sakahara, Kent Pitman,                         and John Aspinall              08-JAN-89, Version 2 by Bob Cassels -- incorporate                         Masinter's suggestion and make REAL a CLOS class              13-JAN-89, Version 3 by Cassels and Aspinall -- incorporate Marc LeBrun's                         suggestions clarifying the relationship between CL                         numeric type names and mathematical namesStatus:	      For Internal DiscussionProblem Description:  There is no standard type specifier symbol for the CL type  '(OR RATIONAL FLOAT). Proposal (REAL-NUMBER-TYPE:REAL):  Make REAL be a CL data type:  p.13 "Numbers"    Add:     The NUMBER data type encompasses all of these kinds of             numbers.  For convenience, there are names for some             subclasses of numbers.  @i[Integers] and @i[ratios] are of             type RATIONAL.  @i[Rational numbers] and @[floating-point             numbers] are of type REAL.  @i[Real numbers] and @i[complex             numbers] are of type NUMBER.	     Although the names of these types were chosen with the	     terminology of mathematics in mind, the correspondences	     are not always exact.  Integers and ratios model the	     corresponding mathematical concepts directly.  Numbers	     of the FLOAT type may be used to approximate real	     numbers, both rational and irrational.  The REAL type	     includes all Common Lisp numbers which represent	     mathematical real numbers, though there are	     mathematical real numbers (irrational numbers)	     which do not have an exact Common Lisp representation.	     Only REAL numbers may be ordered using the <, >, <=,	     and >= functions.             Compatibility note:  The Fortran standard defines the term             "real datum" to mean "a processor approximation to the value             of a real number."  In practice the Fortran "basic real" type             is the floating-point data type Common Lisp calls             SINGLE-FLOAT.  The Fortran "double precision" type is             Common Lisp's DOUBLE-FLOAT.  The Pascal "real" data type is             an "implementation-defined subset of the real numbers."  In             practice this is usually a floating-point type, often what             Common Lisp calls DOUBLE-FLOAT.             A translation of an algorithm written in Fortran or Pascal             which uses "real" data usually will use some appropriate             precision of Common Lisp's FLOAT type.  Some algorithms may             gain accuracy and/or flexibility by using Common Lisp's             RATIONAL or REAL types instead.  p.33 "Overlap, Inclusion, and Disjointness of Types":    Remove:  The types RATIONAL, FLOAT, and COMPLEX are pairwise             disjoint subtypes of NUMBER.             Rationale: It might be thought that INTEGER and RATIO ...             Rationale: It might be thought that FIXNUM and BIGNUM ...    Add:     The types RATIONAL and FLOAT are pairwise disjoint subtypes             of REAL.             The types REAL and COMPLEX are pairwise disjoint subtypes             of NUMBER.             Rationale: It might be thought that FIXNUM and BIGNUM should              form an exhaustive partition of the type INTEGER, that INTEGER             and RATIO should form an exhaustive partition of RATIONAL,             that RATIONAL and FLOAT should form an exhaustive partition of              REAL, and that REAL and COMPLEX should form an exhaustive             partition of NUMBER.  These are all purposely avoided in order              to permit compatible experimentation with extensions to the             Common Lisp number system, such as the idea of adding explicit              representations of infinity or of positive and negative infinity.   p.43 Table 4-1 "Standard Type Specifier Symbols"    Add:     REAL   p.49 "Type Specifiers that Abbreviate"     Add:    (REAL low high)             Denotes the set of real numbers between low and high.  ...             [As with RATIONAL and FLOAT.]  Make REAL a built-in CLOS class.Proposal (REAL-NUMBER-TYPE:REALP):  Add a specific data type predicate REALP which tests for membership in  this type.  [By analogy with NUMBERP.]Test Case:  If a programmer wishes to test for "a number between 1 and 10", the  only current CL types would be '(or (rational 1 10) (float 1 10)) or  something like '(and numberp (not complexp) (satisfies range-1-10))  with (defun range-1-10 (real) (<= 1 real 10)).  Both of these are  likely less efficient, and certainly less expressive than '(real 1 10).Rationale:  Mathematics has a name for (OR RATIONAL FLOAT) -- it is "real".  This class is important because it is all the numbers which can be  ordered.  Throughout the "Numbers" chapter, the phrase "non-complex number" is  used.  MAX, MIN, p. 198 "The arguments may be any non-complex numbers."  CIS p. 207 "The argument ... may be any non-complex number."Current Practice:  Probably nobody does this.  Cost to Implementors:  Some work is necessary to add this name.  But since the underlying  type already exists the amount of work should be minimal.  Cost to Users:  Since this is an upward-compatible extension, it may be ignored by  users.Cost of Non-Adoption:  Occasional inconvenience and/or inefficiency.Benefits:  Mathematical clarity.  Ability to do CLOS method dispatch on the type.Aesthetics:  As mentioned under "rationale," this would be a more concise way to  express a common programming idiom.Discussion:  The name "non-complex number" is incorrect because future  implementations may wish to include numerical types which are neither  complex nor real.  [e.g. pure imaginary numbers or quaternions]    The name "scalar" is incorrect because the mathematical concept of  scalar may indeed include complex numbers.  Fortran and Pascal use the name "real" to mean what CL calls  SINGLE-FLOAT.  That should cause no significant problem, since a Lisp  program written using the type REAL will do mathematically what the  equivalent Fortran program would do.  This is because Fortran's "real"  data-type is a subtype of the CL REAL type.  The only differences  might be that the Lisp program could be less efficient and/or more  accurate.  A survey of several Fortran and Pascal books shows that the distinction  between INTEGER and REAL is that REAL numbers may have fractional  parts, while INTEGERs do not.  Later discussions explain that REALs  cover a greater range.  Much later discussions cover precision  considerations, over/underflow, etc.  So the average Fortran or Pascal  programmer should be completely comfortable with the proposed Lisp  concept of REAL.*start*08155 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 11:29:00 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 11:28:58 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Mar 89  11:27:06 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 557635; Wed 15-Mar-89 14:24:27 ESTDate: Wed, 15 Mar 89 14:24 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 3)To: Masinter.pacc: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>, CL-Cleanup@Sail.Stanford.EDU, DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <19890113185020.8.CASSELS@GROUSE.SCRC.Symbolics.COM>Message-ID: <19890315192425.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoYour issue status for this one says  * REAL-NUMBER-TYPE  Synopsis: add REAL = (OR RATIONAL FLOAT) & range  Version 2, 08-Jan-89  Comment: lengthy dissent; discussion? coercion for comparitor?  Status: need new versionbut I think this version is ready to vote up-or-down.  Note thatthere are two proposals; the REALP predicate function has beenseparated out from the REAL data type.Date: Fri, 13 Jan 89 13:50 ESTFrom: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>Issue:        REAL-NUMBER-TYPEForum:	      CLEANUPReferences:   Table 4-1.Category:     ADDITIONEdit history: 04-JAN-89, Version 1 by Bob Cassels, Don Sakahara, Kent Pitman,			 and John Aspinall	      08-JAN-89, Version 2 by Bob Cassels -- incorporate			 Masinter's suggestion and make REAL a CLOS class	      13-JAN-89, Version 3 by Cassels and Aspinall -- incorporate Marc LeBrun's			 suggestions clarifying the relationship between CL			 numeric type names and mathematical namesStatus:	      For Internal DiscussionProblem Description:  There is no standard type specifier symbol for the CL type  '(OR RATIONAL FLOAT). Proposal (REAL-NUMBER-TYPE:REAL):  Make REAL be a CL data type:  p.13 "Numbers"    Add:     The NUMBER data type encompasses all of these kinds of	     numbers.  For convenience, there are names for some	     subclasses of numbers.  @i[Integers] and @i[ratios] are of	     type RATIONAL.  @i[Rational numbers] and @[floating-point	     numbers] are of type REAL.  @i[Real numbers] and @i[complex	     numbers] are of type NUMBER.	     Although the names of these types were chosen with the	     terminology of mathematics in mind, the correspondences	     are not always exact.  Integers and ratios model the	     corresponding mathematical concepts directly.  Numbers	     of the FLOAT type may be used to approximate real	     numbers, both rational and irrational.  The REAL type	     includes all Common Lisp numbers which represent	     mathematical real numbers, though there are	     mathematical real numbers (irrational numbers)	     which do not have an exact Common Lisp representation.	     Only REAL numbers may be ordered using the <, >, <=,	     and >= functions.	     Compatibility note:  The Fortran standard defines the term	     "real datum" to mean "a processor approximation to the value	     of a real number."  In practice the Fortran "basic real" type	     is the floating-point data type Common Lisp calls	     SINGLE-FLOAT.  The Fortran "double precision" type is	     Common Lisp's DOUBLE-FLOAT.  The Pascal "real" data type is	     an "implementation-defined subset of the real numbers."  In	     practice this is usually a floating-point type, often what	     Common Lisp calls DOUBLE-FLOAT.	     A translation of an algorithm written in Fortran or Pascal	     which uses "real" data usually will use some appropriate	     precision of Common Lisp's FLOAT type.  Some algorithms may	     gain accuracy and/or flexibility by using Common Lisp's	     RATIONAL or REAL types instead.  p.33 "Overlap, Inclusion, and Disjointness of Types":    Remove:  The types RATIONAL, FLOAT, and COMPLEX are pairwise	     disjoint subtypes of NUMBER.	     Rationale: It might be thought that INTEGER and RATIO ...	     Rationale: It might be thought that FIXNUM and BIGNUM ...    Add:     The types RATIONAL and FLOAT are pairwise disjoint subtypes	     of REAL.	     The types REAL and COMPLEX are pairwise disjoint subtypes	     of NUMBER.	     Rationale: It might be thought that FIXNUM and BIGNUM should 	     form an exhaustive partition of the type INTEGER, that INTEGER	     and RATIO should form an exhaustive partition of RATIONAL,	     that RATIONAL and FLOAT should form an exhaustive partition of 	     REAL, and that REAL and COMPLEX should form an exhaustive	     partition of NUMBER.  These are all purposely avoided in order 	     to permit compatible experimentation with extensions to the	     Common Lisp number system, such as the idea of adding explicit 	     representations of infinity or of positive and negative infinity.   p.43 Table 4-1 "Standard Type Specifier Symbols"    Add:     REAL   p.49 "Type Specifiers that Abbreviate"     Add:    (REAL low high)	     Denotes the set of real numbers between low and high.  ...	     [As with RATIONAL and FLOAT.]  Make REAL a built-in CLOS class.Proposal (REAL-NUMBER-TYPE:REALP):  Add a specific data type predicate REALP which tests for membership in  this type.  [By analogy with NUMBERP.]Test Case:  If a programmer wishes to test for "a number between 1 and 10", the  only current CL types would be '(or (rational 1 10) (float 1 10)) or  something like '(and numberp (not complexp) (satisfies range-1-10))  with (defun range-1-10 (real) (<= 1 real 10)).  Both of these are  likely less efficient, and certainly less expressive than '(real 1 10).Rationale:  Mathematics has a name for (OR RATIONAL FLOAT) -- it is "real".  This class is important because it is all the numbers which can be  ordered.  Throughout the "Numbers" chapter, the phrase "non-complex number" is  used.  MAX, MIN, p. 198 "The arguments may be any non-complex numbers."  CIS p. 207 "The argument ... may be any non-complex number."Current Practice:  Probably nobody does this.Cost to Implementors:  Some work is necessary to add this name.  But since the underlying  type already exists the amount of work should be minimal.Cost to Users:  Since this is an upward-compatible extension, it may be ignored by  users.Cost of Non-Adoption:  Occasional inconvenience and/or inefficiency.Benefits:  Mathematical clarity.  Ability to do CLOS method dispatch on the type.Aesthetics:  As mentioned under "rationale," this would be a more concise way to  express a common programming idiom.Discussion:  The name "non-complex number" is incorrect because future  implementations may wish to include numerical types which are neither  complex nor real.  [e.g. pure imaginary numbers or quaternions]  The name "scalar" is incorrect because the mathematical concept of  scalar may indeed include complex numbers.  Fortran and Pascal use the name "real" to mean what CL calls  SINGLE-FLOAT.  That should cause no significant problem, since a Lisp  program written using the type REAL will do mathematically what the  equivalent Fortran program would do.  This is because Fortran's "real"  data-type is a subtype of the CL REAL type.  The only differences  might be that the Lisp program could be less efficient and/or more  accurate.  A survey of several Fortran and Pascal books shows that the distinction  between INTEGER and REAL is that REAL numbers may have fractional  parts, while INTEGERs do not.  Later discussions explain that REALs  cover a greater range.  Much later discussions cover precision  considerations, over/underflow, etc.  So the average Fortran or Pascal  programmer should be completely comfortable with the proposed Lisp  concept of REAL.*start*02370 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 15-Mar-89 11:46:49 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 MAR 89 11:44:16 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Mar 89  11:44:52 PSTReceived: from GROUSE.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 557688; Wed 15-Mar-89 14:42:23 ESTDate: Wed, 15 Mar 89 14:42 ESTFrom: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 3)To: Moon@STONY-BROOK.SCRC.Symbolics.COM, Masinter.pacc: Cassels@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@Sail.Stanford.EDU, DySak@STONY-BROOK.SCRC.Symbolics.COM, JGA@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp-Implementors@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <19890315192425.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19890315194221.4.CASSELS@GROUSE.SCRC.Symbolics.COM>    Date: Wed, 15 Mar 89 14:24 EST    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    Your issue status for this one says      * REAL-NUMBER-TYPE      Synopsis: add REAL = (OR RATIONAL FLOAT) & range      Version 2, 08-Jan-89      Comment: lengthy dissent; discussion? coercion for comparitor?      Status: need new version    but I think this version is ready to vote up-or-down.  Note that    there are two proposals; the REALP predicate function has been    separated out from the REAL data type.    Date: Fri, 13 Jan 89 13:50 EST    From: Robert A. Cassels <Cassels@STONY-BROOK.SCRC.Symbolics.COM>    Issue:        REAL-NUMBER-TYPE    Forum:	      CLEANUP    References:   Table 4-1.    Category:     ADDITION    Edit history: 04-JAN-89, Version 1 by Bob Cassels, Don Sakahara, Kent Pitman,			     and John Aspinall		  08-JAN-89, Version 2 by Bob Cassels -- incorporate			     Masinter's suggestion and make REAL a CLOS class		  13-JAN-89, Version 3 by Cassels and Aspinall -- incorporate Marc LeBrun's			     suggestions clarifying the relationship between CL			     numeric type names and mathematical names    Status:	      For Internal DiscussionWe should change "current practice" to note that TI Lisp includes boththe REAL type and REALP predicate.*start*07499 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 17-Mar-89 00:19:30 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 00:18:34 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  00:08:54 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 16 MAR 89 23:50:31 PSTDate: 16 Mar 89 23:49 PSTFrom: masinter.paSubject: Issue: REAL-NUMBER-TYPE (version 3)To: x3J13@Sail.Stanford.EDUMessage-ID: <890316-235031-6996@Xerox>!Issue:        REAL-NUMBER-TYPEForum:	      CLEANUPReferences:   Table 4-1.Category:     ADDITIONEdit history: 04-JAN-89, Version 1 by Bob Cassels, Don Sakahara, Kent Pitman,                         and John Aspinall              08-JAN-89, Version 2 by Bob Cassels -- incorporate                         Masinter's suggestion and make REAL a CLOS class              13-JAN-89, Version 3 by Cassels and Aspinall -- incorporate Marc LeBrun's                         suggestions clarifying the relationship between CL                         numeric type names and mathematical namesStatus:	      For Internal DiscussionProblem Description:  There is no standard type specifier symbol for the CL type  '(OR RATIONAL FLOAT). Proposal (REAL-NUMBER-TYPE:REAL):  Make REAL be a CL data type:  p.13 "Numbers"    Add:     The NUMBER data type encompasses all of these kinds of             numbers.  For convenience, there are names for some             subclasses of numbers.  @i[Integers] and @i[ratios] are of             type RATIONAL.  @i[Rational numbers] and @[floating-point             numbers] are of type REAL.  @i[Real numbers] and @i[complex             numbers] are of type NUMBER.	     Although the names of these types were chosen with the	     terminology of mathematics in mind, the correspondences	     are not always exact.  Integers and ratios model the	     corresponding mathematical concepts directly.  Numbers	     of the FLOAT type may be used to approximate real	     numbers, both rational and irrational.  The REAL type	     includes all Common Lisp numbers which represent	     mathematical real numbers, though there are	     mathematical real numbers (irrational numbers)	     which do not have an exact Common Lisp representation.	     Only REAL numbers may be ordered using the <, >, <=,	     and >= functions.             Compatibility note:  The Fortran standard defines the term             "real datum" to mean "a processor approximation to the value             of a real number."  In practice the Fortran "basic real" type             is the floating-point data type Common Lisp calls             SINGLE-FLOAT.  The Fortran "double precision" type is             Common Lisp's DOUBLE-FLOAT.  The Pascal "real" data type is             an "implementation-defined subset of the real numbers."  In             practice this is usually a floating-point type, often what             Common Lisp calls DOUBLE-FLOAT.             A translation of an algorithm written in Fortran or Pascal             which uses "real" data usually will use some appropriate             precision of Common Lisp's FLOAT type.  Some algorithms may             gain accuracy and/or flexibility by using Common Lisp's             RATIONAL or REAL types instead.  p.33 "Overlap, Inclusion, and Disjointness of Types":    Remove:  The types RATIONAL, FLOAT, and COMPLEX are pairwise             disjoint subtypes of NUMBER.             Rationale: It might be thought that INTEGER and RATIO ...             Rationale: It might be thought that FIXNUM and BIGNUM ...    Add:     The types RATIONAL and FLOAT are pairwise disjoint subtypes             of REAL.             The types REAL and COMPLEX are pairwise disjoint subtypes             of NUMBER.             Rationale: It might be thought that FIXNUM and BIGNUM should              form an exhaustive partition of the type INTEGER, that INTEGER             and RATIO should form an exhaustive partition of RATIONAL,             that RATIONAL and FLOAT should form an exhaustive partition of              REAL, and that REAL and COMPLEX should form an exhaustive             partition of NUMBER.  These are all purposely avoided in order              to permit compatible experimentation with extensions to the             Common Lisp number system, such as the idea of adding explicit              representations of infinity or of positive and negative infinity.   p.43 Table 4-1 "Standard Type Specifier Symbols"    Add:     REAL   p.49 "Type Specifiers that Abbreviate"     Add:    (REAL low high)             Denotes the set of real numbers between low and high.  ...             [As with RATIONAL and FLOAT.]  Make REAL a built-in CLOS class.Proposal (REAL-NUMBER-TYPE:REALP):  Add a specific data type predicate REALP which tests for membership in  this type.  [By analogy with NUMBERP.]Test Case:  If a programmer wishes to test for "a number between 1 and 10", the  only current CL types would be '(or (rational 1 10) (float 1 10)) or  something like '(and numberp (not complexp) (satisfies range-1-10))  with (defun range-1-10 (real) (<= 1 real 10)).  Both of these are  likely less efficient, and certainly less expressive than '(real 1 10).Rationale:  Mathematics has a name for (OR RATIONAL FLOAT) -- it is "real".  This class is important because it is all the numbers which can be  ordered.  Throughout the "Numbers" chapter, the phrase "non-complex number" is  used.  MAX, MIN, p. 198 "The arguments may be any non-complex numbers."  CIS p. 207 "The argument ... may be any non-complex number."Current Practice:  Probably nobody does this.  Cost to Implementors:  Some work is necessary to add this name.  But since the underlying  type already exists the amount of work should be minimal.  Cost to Users:  Since this is an upward-compatible extension, it may be ignored by  users.Cost of Non-Adoption:  Occasional inconvenience and/or inefficiency.Benefits:  Mathematical clarity.  Ability to do CLOS method dispatch on the type.Aesthetics:  As mentioned under "rationale," this would be a more concise way to  express a common programming idiom.Discussion:  The name "non-complex number" is incorrect because future  implementations may wish to include numerical types which are neither  complex nor real.  [e.g. pure imaginary numbers or quaternions]    The name "scalar" is incorrect because the mathematical concept of  scalar may indeed include complex numbers.  Fortran and Pascal use the name "real" to mean what CL calls  SINGLE-FLOAT.  That should cause no significant problem, since a Lisp  program written using the type REAL will do mathematically what the  equivalent Fortran program would do.  This is because Fortran's "real"  data-type is a subtype of the CL REAL type.  The only differences  might be that the Lisp program could be less efficient and/or more  accurate.  A survey of several Fortran and Pascal books shows that the distinction  between INTEGER and REAL is that REAL numbers may have fractional  parts, while INTEGERs do not.  Later discussions explain that REALs  cover a greater range.  Much later discussions cover precision  considerations, over/underflow, etc.  So the average Fortran or Pascal  programmer should be completely comfortable with the proposed Lisp  concept of REAL.*start*01259 00024 US Date:  4 Apr 89 13:25 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: REAL-NUMBER-TYPETo: CL-Cleanup%SAIL.Stanford:EDU:Xeroxcc: Cassels%STONY-BROOK.SCRC.Symbolics:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPETo: CL-Cleanup@SAIL.Stanford.EDUcc: Cassels@STONY-BROOK.SCRC.Symbolics.COMReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 13:07:51 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:39:35 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571267; Tue 4-Apr-89 15:39:27 EDTOriginal-Date: Tue, 4 Apr 89 15:38 EDTMessage-ID: <890404153856.3.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVMy notes say... Barmar moved we accept ``both proposals'' (since one was obviously trying to include the other, but the wording didn't really make that clear). The motion to approve both passed 12-3.*start*07961 00024 US Date:  5 Apr 89 13:54 PDTFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: REAL-NUMBER-TYPE (version 4)To: Masinter:PA:Xeroxcc: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REAL-NUMBER-TYPE (version 4)To: Masinter.PAcc: KMP@STONY-BROOK.SCRC.Symbolics.COMReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 05 APR 89 13:18:54 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571962; Wed 5-Apr-89 16:18:38 EDTOriginal-Date: Wed, 5 Apr 89 16:18 EDTMessage-ID: <890405161809.6.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFor your archives...-----Issue:        REAL-NUMBER-TYPEForum:	      CLEANUPReferences:   Table 4-1.Category:     ADDITIONEdit history: 04-JAN-89, Version 1 by Bob Cassels, Don Sakahara, Kent Pitman,                         and John Aspinall              08-JAN-89, Version 2 by Bob Cassels -- incorporate                         Masinter's suggestion and make REAL a CLOS class              13-JAN-89, Version 3 by Cassels and Aspinall -- incorporate Marc LeBrun's                         suggestions clarifying the relationship between CL                         numeric type names and mathematical names	      05-APR-89, Version 4 by Pitman (changes per X3J13)Status:	      Accepted v3 Mar-89 by X3J13 (on a 12-3 vote) with 	      amendments. The proposal as amended is v4.Problem Description:  There is no standard type specifier symbol for the CL type  '(OR RATIONAL FLOAT). Proposal (REAL-NUMBER-TYPE:X3J13-MAR-89):  Make REAL be a CL data type:  p.13 "Numbers"    Add:     The NUMBER data type encompasses all of these kinds of             numbers.  For convenience, there are names for some             subclasses of numbers.  @i[Integers] and @i[ratios] are of             type RATIONAL.  @i[Rational numbers] and @[floating-point             numbers] are of type REAL.  @i[Real numbers] and @i[complex             numbers] are of type NUMBER.	     Although the names of these types were chosen with the	     terminology of mathematics in mind, the correspondences	     are not always exact.  Integers and ratios model the	     corresponding mathematical concepts directly.  Numbers	     of the FLOAT type may be used to approximate real	     numbers, both rational and irrational.  The REAL type	     includes all Common Lisp numbers which represent	     mathematical real numbers, though there are	     mathematical real numbers (irrational numbers)	     which do not have an exact Common Lisp representation.	     Only REAL numbers may be ordered using the <, >, <=,	     and >= functions.             Compatibility note:  The Fortran standard defines the term             "real datum" to mean "a processor approximation to the value             of a real number."  In practice the Fortran "basic real" type             is the floating-point data type Common Lisp calls             SINGLE-FLOAT.  The Fortran "double precision" type is             Common Lisp's DOUBLE-FLOAT.  The Pascal "real" data type is             an "implementation-defined subset of the real numbers."  In             practice this is usually a floating-point type, often what             Common Lisp calls DOUBLE-FLOAT.             A translation of an algorithm written in Fortran or Pascal             which uses "real" data usually will use some appropriate             precision of Common Lisp's FLOAT type.  Some algorithms may             gain accuracy and/or flexibility by using Common Lisp's             RATIONAL or REAL types instead.  p.33 "Overlap, Inclusion, and Disjointness of Types":    Remove:  The types RATIONAL, FLOAT, and COMPLEX are pairwise             disjoint subtypes of NUMBER.             Rationale: It might be thought that INTEGER and RATIO ...             Rationale: It might be thought that FIXNUM and BIGNUM ...    Add:     The types RATIONAL and FLOAT are pairwise disjoint subtypes             of REAL.             The types REAL and COMPLEX are pairwise disjoint subtypes             of NUMBER.             Rationale: It might be thought that FIXNUM and BIGNUM should              form an exhaustive partition of the type INTEGER, that INTEGER             and RATIO should form an exhaustive partition of RATIONAL,             that RATIONAL and FLOAT should form an exhaustive partition of              REAL, and that REAL and COMPLEX should form an exhaustive             partition of NUMBER.  These are all purposely avoided in order              to permit compatible experimentation with extensions to the             Common Lisp number system, such as the idea of adding explicit              representations of infinity or of positive and negative infinity.   p.43 Table 4-1 "Standard Type Specifier Symbols"    Add:     REAL   p.49 "Type Specifiers that Abbreviate"     Add:    (REAL low high)             Denotes the set of real numbers between low and high.  ...             [As with RATIONAL and FLOAT.]  Make REAL a built-in CLOS class.  Add a specific data type predicate REALP which tests for membership in  this type.  [By analogy with NUMBERP.]Test Case:  If a programmer wishes to test for "a number between 1 and 10", the  only current CL types would be '(or (rational 1 10) (float 1 10)) or  something like '(and numberp (not complexp) (satisfies range-1-10))  with (defun range-1-10 (real) (<= 1 real 10)).  Both of these are  likely less efficient, and certainly less expressive than '(real 1 10).Rationale:  Mathematics has a name for (OR RATIONAL FLOAT) -- it is "real".  This class is important because it is all the numbers which can be  ordered.  Throughout the "Numbers" chapter, the phrase "non-complex number" is  used.  MAX, MIN, p. 198 "The arguments may be any non-complex numbers."  CIS p. 207 "The argument ... may be any non-complex number."Current Practice:  Probably nobody does this.  Cost to Implementors:  Some work is necessary to add this name.  But since the underlying  type already exists the amount of work should be minimal.  Cost to Users:  Since this is an upward-compatible extension, it may be ignored by  users.Cost of Non-Adoption:  Occasional inconvenience and/or inefficiency.Benefits:  Mathematical clarity.  Ability to do CLOS method dispatch on the type.Aesthetics:  As mentioned under "rationale," this would be a more concise way to  express a common programming idiom.Discussion:  The name "non-complex number" is incorrect because future  implementations may wish to include numerical types which are neither  complex nor real.  [e.g. pure imaginary numbers or quaternions]    The name "scalar" is incorrect because the mathematical concept of  scalar may indeed include complex numbers.  Fortran and Pascal use the name "real" to mean what CL calls  SINGLE-FLOAT.  That should cause no significant problem, since a Lisp  program written using the type REAL will do mathematically what the  equivalent Fortran program would do.  This is because Fortran's "real"  data-type is a subtype of the CL REAL type.  The only differences  might be that the Lisp program could be less efficient and/or more  accurate.  A survey of several Fortran and Pascal books shows that the distinction  between INTEGER and REAL is that REAL numbers may have fractional  parts, while INTEGERs do not.  Later discussions explain that REALs  cover a greater range.  Much later discussions cover precision  considerations, over/underflow, etc.  So the average Fortran or Pascal  programmer should be completely comfortable with the proposed Lisp  concept of REAL.