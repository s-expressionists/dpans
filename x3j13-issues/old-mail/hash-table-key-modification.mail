*start*02048 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 12 SEP 88 17:27:14 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 12 Sep 88  17:27:05 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 457999; Mon 12-Sep-88 20:26:15 EDTDate: Mon, 12 Sep 88 20:25 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <19880913002519.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Issue:         HASH-TABLE-KEY-MODIFICATIONReferences:    CLtL page 282, page 168 (last paragraph in 10.2)Category:      CLARIFICATIONEdit history:  Version 1, 12-Sep-88, Moon, for discussionProblem description:CLtL is silent about what happens if you modify a component of an objectthat is used as a hash-table key.Proposal (HASH-TABLE-KEY-MODIFICATION:SPECIFY):	  In EQ and EQL hash tables, components of a key may be freely modifiedwith no effect on the table.In EQUAL hash tables, it is an error to modify a component of a key.If implementations define additional acceptable values for the :TESTargument to MAKE-HASH-TABLE, the rule is that it is an error to modifya component of a key if and only if that component affects the testfunction.  If that component cannot affect the test function, the hashtable's operation must not be affected by modifying the component.Test Cases/Examples:(setq ht (make-hash-table :test #'eq))(setq a (cons 1 2))(setf (gethash a ht) 'win)(setf (cdr a) 3)(gethash a ht 'lose) => win tThe same example with :test #'equal in the first line would be anerror.The following example is not an error, because EQUAL does not examinethe components of general vectors:(setq ht (make-hash-table :test #'equal))(setq a (vector 1 2))(setf (gethash a ht) 'win)(setf (aref a 1) *start*01710 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 16 SEP 88 01:45:44 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Sep 88  01:45:06 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 SEP 88 01:42:56 PDTDate: 16 Sep 88 01:43 PDTFrom: masinter.paSubject: Re: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 12 Sep 88 20:25 EDTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880916-014256-3857@Xerox>I have a note that there was some discussion on this issue, but I  don't see it.What I think is that this issue doesn't give us much clarification unless we canpin down what a component is (e.g., "it is an error to modify a component of akey" doesn't disallow changing the symbol-function of a symbol key, although itmight be considered a "component" of the KEY. Given that EQUAL is transitive, the operation is thatif before the operation, there is a value B suchthat (EQUAL A B), but after theoperation on A, (EQUAL A B) is false, then you've changed something that GETHASHcares about wrt EQUAL hash keys.Should implementations really be free to signal an error or behave otherwise inan undefined manner when you say (setf (car x) y) if x happens to be a key in aEQUAL hash table?I think we can and should be more precise than "is an error" when we can, andthis is such an opportunity. The value of GETHASH on B or A is unspecified afterA is modified  if the value of A is a key in the hash table....*start*01184 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 15:18:58 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 19 Sep 88  15:05:25 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 19 SEP 88 15:02:27 PDTDate: 19 Sep 88 15:02 PDTFrom: masinter.paSubject: Re: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)In-reply-to: Jon L White <jonl@lucid.com>'s message of Mon, 19 Sep 88 14:36:41 PDTTo: Jon L White <jonl@lucid.com>cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDU, GLS@Think.com, CL-Editorial@SAIL.STANFORD.EDUMessage-ID: <880919-150227-2389@Xerox>My immediate reaction to your message was that it was a hasty disqualificationof an otherwise valid issue for the cleanup committee to address. Certainly the issue needs to be addressed. If Kathy things it is reasonable todo so within the scope of the editorial board, I'm happy to allow it to beaddressed there. However, it does seem like an issue that can be well-specified without resortingto a discussion of copying garbage collectors and collision chains in thespecification.*start*05217 00024 US Return-Path: <CL-Editorial-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 14:39:41 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 19 Sep 88  14:38:59 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03479g; Mon, 19 Sep 88 13:37:14 PSTReceived: by bhopal id AA14744g; Mon, 19 Sep 88 14:36:41 PDTDate: Mon, 19 Sep 88 14:36:41 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809192136.AA14744@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.STANFORD.EDU, GLS@Think.com, CL-Editorial@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Mon, 12 Sep 88 20:25 EDT <19880913002519.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)re:    Proposal (HASH-TABLE-KEY-MODIFICATION:SPECIFY):       . . . I fear this is far too vague to be a cleanup proposal, however well-motivated it may have been.  Indeed, there was a discussion of this topic on Common-Lisp@SU-AI about a year ago (as well as a few related msgs quite recently), but the upshot of all the discussion was merely to "enlighten" more of the community about the techniques of hashing in general.  I think we should limit our efforts in this arena at giving advice to editors (such as Steele, and Chapman, etc.) on how to explain the consequences of some typical hashing techniques.First, there is no generally agreed-upon notion of what a "component" is;so the part where you say:    In EQ and EQL hash tables, components of a key may be freely modified    with no effect on the table.    In EQUAL hash tables, it is an error to modify a component of a key.isn't saying anything usable; or if it is, then it is something alreadyunderstood via channels outside this proscription.  Furthermore, it couldbog us down for months if we tried to specify "component" exactly.   Forexample, is the bit-field (byte 3 5) of a fixnum X a "component"  of X?Second, the "rule":    If implementations define additional acceptable values for the :TEST    argument to MAKE-HASH-TABLE, the rule is that it is an error to modify    a component of a key if and only if that component affects the test    function.  If that component cannot affect the test function, the hash    table's operation must not be affected by modifying the component.is completely inadequate.  You might as well say that it is an error to modify the components of list elements for any list that is passed to a sequence function with a :test argument of EQUAL.  What you probably meantto say, in the hash-table context, is:    ... it is an error to modify an object used as key in a hash table    iff such modification affects either  (1) the outcome of equivalence      test used by the hash-table, or (2) the structure of the collision    chains built up in the hash table [note that SXHASH, or a substitute     therefor, may be involved in the structure of collision chains].[There might have to be a line saying that the :test component of a hash-table is always an equivalence relation.]   However, CLtL neither specifiesthat hash-tables must use some "collision chain" technique -- alists appearto be a fully conforming implementation (albeit sloooow) -- nor does is evenspecify that any such collision tecnhique must be based on the output of SXHASH.  About the most it says is that hashing should be "fast".Unfortunately, nowhere does the discussion of HASH-TABLE-KEY-MODIFICATIONeven mention collision chains.An implementational note *might* be worth mentioning in the documentstandard about how the historical intent of EQ/EQL tables was in fact to limit the information obtained from an object to merely the pointer itself (i.e., it's address), and that this usually meant faster hashing (in MacLisp, for example).  But with the spread of copying GC's (stop-and-copy, generational, etc) this kind of dependency limitation forces some very odd behaviour on the memory-management subsystem, such as the need for rehashing after GC's, etc.  I really know of cases where an EQL table was grossly slower than an EQUAL table, simply because it forced so much more attention from the memory-management subsystem.Typically, only very "introspective" code needs to know whether, say, two strings are EQL rather EQUAL; and very often even experienced users make the mistake of thinking that EQ means speed and EQUAL means sloth.Certainly no one using Common Lisp should prefer an EQ/EQL table overan EQUAL one, unless he is actually concerned with the implementationalidentity of objects [such as in system code doing circularity checks,or "constants" coalescing, or macromemo-izing, etc.].I think the gist of these last two paragraphs is something that the standards editors could try to work into the next chapter on Hash-Tables(and possibly something about "collision chains" being a frequent partof hash-tables).  This would be preferable to having the cleanup sub-committee try to solve the unsolvable problem of anticipating every possible consequence of every possible implementation technique for hash-tables.-- JonL --*start*06764 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 SEP 88 15:43:12 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 19 Sep 88  15:41:47 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 461963; Mon 19-Sep-88 18:39:45 EDTDate: Mon, 19 Sep 88 18:39 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)To: Jon L White <jonl@lucid.com>cc: CL-Cleanup@SAIL.STANFORD.EDU, GLS@Think.com, CL-Editorial@SAIL.STANFORD.EDUIn-Reply-To: <8809192136.AA14744@bhopal>Message-ID: <19880919223934.5.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Mon, 19 Sep 88 14:36:41 PDT    From: Jon L White <jonl@lucid.com>    ....    First, there is no generally agreed-upon notion of what a "component" is;    so the part where you say:	In EQ and EQL hash tables, components of a key may be freely modified	with no effect on the table.	In EQUAL hash tables, it is an error to modify a component of a key.    isn't saying anything usable; or if it is, then it is something already    understood via channels outside this proscription.  It's true that "component" is a vague notion.  As elaborated on later inthe proposal, "component" should be defined in terms of the test function.Maybe this initial vague language should just be abandoned.							Furthermore, it could    bog us down for months if we tried to specify "component" exactly.   For    example, is the bit-field (byte 3 5) of a fixnum X a "component"  of X?Who cares, since Common Lisp does not provide any way to modify fixnums.    Second, the "rule":	If implementations define additional acceptable values for the :TEST	argument to MAKE-HASH-TABLE, the rule is that it is an error to modify	a component of a key if and only if that component affects the test	function.  If that component cannot affect the test function, the hash	table's operation must not be affected by modifying the component.    is completely inadequate.  You might as well say that it is an error to     modify the components of list elements for any list that is passed to a     sequence function with a :test argument of EQUAL.That's precisely what I would have said, if sequence functions werepermitted to create auxiliary data structures that encache informationabout their arguments from one call to the next.  Since they are not(although this is only implied by CLtL), there is no need to imposesuch a restriction on their callers.    What you probably meant    to say, in the hash-table context, is:	... it is an error to modify an object used as key in a hash table	iff such modification affects either  (1) the outcome of equivalence  	test used by the hash-table, or (2) the structure of the collision	chains built up in the hash table [note that SXHASH, or a substitute 	therefor, may be involved in the structure of collision chains].    [There might have to be a line saying that the :test component of a hash-    table is always an equivalence relation.]   However, CLtL neither specifies    that hash-tables must use some "collision chain" technique -- alists appear    to be a fully conforming implementation (albeit sloooow) -- nor does is even    specify that any such collision tecnhique must be based on the output of     SXHASH.  About the most it says is that hashing should be "fast".    Unfortunately, nowhere does the discussion of HASH-TABLE-KEY-MODIFICATION    even mention collision chains.I vehemently disagree with this, and I think you're being completely wrong-headed.  The point of the proposal was to state what are therequirements on Common Lisp programs so that they will be portableto all implementations of hash tables.  The internal details of hashtables in some particular implementation are not relevant; furthermore,discussing them can only mislead users into writing non-portableprograms.  What I meant to say was precisely what I did say.  I agreethat an editor could find more precise language than "affect thetest function" by which I mean "change the answer returned by thetest function."    An implementational note *might* be worth mentioning in the document    standard about how the historical intent of EQ/EQL tables was in fact     to limit the information obtained from an object to merely the pointer     itself (i.e., it's address), and that this usually meant faster hashing     (in MacLisp, for example).  But with the spread of copying GC's (stop-    and-copy, generational, etc) this kind of dependency limitation forces     some very odd behaviour on the memory-management subsystem, such as the     need for rehashing after GC's, etc.  I really know of cases where an EQL     table was grossly slower than an EQUAL table, simply because it forced so     much more attention from the memory-management subsystem.    Typically, only very "introspective" code needs to know whether, say, two     strings are EQL rather EQUAL; and very often even experienced users make     the mistake of thinking that EQ means speed and EQUAL means sloth.    Certainly no one using Common Lisp should prefer an EQ/EQL table over    an EQUAL one, unless he is actually concerned with the implementational    identity of objects [such as in system code doing circularity checks,    or "constants" coalescing, or macromemo-izing, etc.].    I think the gist of these last two paragraphs is something that the     standards editors could try to work into the next chapter on Hash-Tables    (and possibly something about "collision chains" being a frequent part    of hash-tables).I agree that it might be interesting to have a book that discusses theperformance tradeoffs in hash tables.  I don't think that has anything todo with the issue at hand, which is to define what characteristics of hashtables may or may not be assumed by portable programs.    This would be preferable to having the cleanup sub-    committee try to solve the unsolvable problem of anticipating every     possible consequence of every possible implementation technique for     hash-tables.If you thought that's what the HASH-TABLE-KEY-MODIFICATION issue wasabout, you misunderstood it.  It's about defining whether portableprograms may or may not perform side effects on objects used askeys of hash tables, and which side-effects can be performed.  Ican see it needs to be written up in a form that is less easyto misunderstand.  If I have time, which is not too likely, I'lldo that, otherwise I'll just forget it.*start*02051 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 22 SEP 88 23:16:39 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA07238g; Thu, 22 Sep 88 22:15:28 PSTReceived: by bhopal id AA08189g; Thu, 22 Sep 88 23:14:57 PDTDate: Thu, 22 Sep 88 23:14:57 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809230614.AA08189@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COM, Masinter.PACc: CL-Cleanup@SAIL.STANFORD.EDU, GLS@Think.com, CL-Editorial@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Mon, 19 Sep 88 18:39 EDT <19880919223934.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)re: [jonl]  ... it is an error to modify an object used as key in a hash table	  iff such modification affects either  (1) the outcome of equivalence	  test used by the hash-table, or (2) the structure of the collision	  chains built up in the hash table [note that SXHASH, or a substitute 	  therefor, may be involved in the structure of collision chains].      Unfortunately, nowhere does the discussion of HASH-TABLE-KEY-MODIFICATION      even mention collision chains.    [moon] I vehemently disagree with this, and I think you're being      completely wrong-headed.  I suggest that you get a copy of Knuth vol. 3, and read the section onHashing, especially p. 508.  To not understand the relevance of the buzzword "collision chains" to hash-tables would certainly put one at a seriousdisadvantage in understanding my msg of Mon, 19 Sep 88 14:36:41 PDT[possibly Larry needs to look at this too?].  As long as CL promises "hash tables", the user is entitled to think that this means something other than a linear-search of a pointer vector.  I did understand the intent of your proposal -- that is not a problem -- it's just that as phrased, the proposal applies equally well to SEARCHing pointer vectors, and is not directed to the unique way in which hash tables differ from linear tables.-- JonL --*start*01222 00024 US Date: 23 Sep 88 00:07 PDTFrom: masinter.paSubject: Re: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)In-reply-to: Jon L White <jonl@lucid.com>'s message of Thu, 22 Sep 88 23:14:57 PDTTo: Jon L White <jonl@lucid.com>cc: masinterSince my favorite implementation of hash tables doesn't use collision chains, I'd object if the standard required them. I think it is possible to specify what the functions do by their external behavior. If it helps to also explain some implementation notes on how things might be implemented and how fast they are, that's fine. But no where else in CL are there any promises about performance; e.g., it doesn't say that + is not order n-squared in the magnitude of its arguments, either.So if you want to say that after modifying a structure used as a key in a hash table, the results of a subsequent gethash are unspecified on the same structure or one that was test-equivalent to it before the modification, you can add in a note that the results are unspecified because it might change the hash bucket or the collision chain. This is a good explanatory note. It just isn't a specification.Does this make sense? (Its late and I'm typing this too fast.)*start*02162 00024 US Return-Path: <CL-Editorial-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 SEP 88 09:18:44 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 22 Sep 88  23:17:27 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA07238g; Thu, 22 Sep 88 22:15:28 PSTReceived: by bhopal id AA08189g; Thu, 22 Sep 88 23:14:57 PDTDate: Thu, 22 Sep 88 23:14:57 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809230614.AA08189@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COM, Masinter.PACc: CL-Cleanup@SAIL.STANFORD.EDU, GLS@Think.com, CL-Editorial@SAIL.STANFORD.EDUIn-Reply-To: David A. Moon's message of Mon, 19 Sep 88 18:39 EDT <19880919223934.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)re: [jonl]  ... it is an error to modify an object used as key in a hash table	  iff such modification affects either  (1) the outcome of equivalence	  test used by the hash-table, or (2) the structure of the collision	  chains built up in the hash table [note that SXHASH, or a substitute 	  therefor, may be involved in the structure of collision chains].      Unfortunately, nowhere does the discussion of HASH-TABLE-KEY-MODIFICATION      even mention collision chains.    [moon] I vehemently disagree with this, and I think you're being      completely wrong-headed.  I suggest that you get a copy of Knuth vol. 3, and read the section onHashing, especially p. 508.  To not understand the relevance of the buzzword "collision chains" to hash-tables would certainly put one at a seriousdisadvantage in understanding my msg of Mon, 19 Sep 88 14:36:41 PDT[possibly Larry needs to look at this too?].  As long as CL promises "hash tables", the user is entitled to think that this means something other than a linear-search of a pointer vector.  I did understand the intent of your proposal -- that is not a problem -- it's just that as phrased, the proposal applies equally well to SEARCHing pointer vectors, and is not directed to the unique way in which hash tables differ from linear tables.-- JonL --*start*02249 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 26 SEP 88 16:50:17 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA09612g; Mon, 26 Sep 88 15:49:41 PSTReceived: by bhopal id AA02313g; Mon, 26 Sep 88 16:49:13 PDTDate: Mon, 26 Sep 88 16:49:13 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809262349.AA02313@bhopal>To: masinter.paCc: jonl@lucid.comIn-Reply-To: masinter.pa@Xerox.COM's message of 23 Sep 88 00:07 PDT <880923-000731-3922@Xerox>Subject: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)re: Since my favorite implementation of hash tables doesn't use collision     chains, I'd object if the standard required them. I think it is possible     to specify what the functions do by their external behavior. I thought masInterlisp did do a collision chaining.  Even "bucketing"can come under that rubric, although many folks take it merely to meanthe "open-addressing" scheme described in Knuth.  However, as I've oftennoted, CLtL doesn't even require hash-tables to use "hashing" -- alinear-probe "table" seems to fit all the requirements therein exceptfor being "fast".    If it helps to also explain some implementation notes on how things might     be implemented and how fast they are, that's fine. But no where else in     CL are there any promises about performance; e.g., it doesn't say that +     is not order n-squared in the magnitude of its arguments, either.    So if you want to say that after modifying a structure used as a key in a     hash table, the results of a subsequent gethash are unspecified on the     same structure or one that was test-equivalent to it before the     modification, you can add in a note that the results are unspecified     because it might change the hash bucket or the collision chain.  This is     a good explanatory note. It just isn't a specification.    Does this make sense? (Its late and I'm typing this too fast.)Yea, not bad.  There's much more though, especially re EQ/EQL typetables.  I'm going to try to work on the more general lacunae inCLtL's presentation of hash-table types; have already discussed itwith most senior folks here at Lucid.-- JonL --*start*01243 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 NOV 88 15:31:52 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Nov 88  15:29:36 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 14 NOV 88 15:21:35 PSTDate: 14 Nov 88 15:21 PSTFrom: masinter.paSubject: Re: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)In-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 19 Sep 88 18:39 EDTTo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <881114-152135-2356@Xerox>David:Let me encourage you to avoid feeling provoked by JonL's reaction to thisissue, and find the time to produce a slightly modified version of theproposal which is a little more specific about the issues raised: eliminatethe "component" language in the definition except as a description ofintent (for EQUAL tables, what is a component might be different than forEQUALP tables), change the "is an error to modify" language to be morespecific in saying that the value of subsequent GETHASH calls *on that key*might be affected.Please?Larry*start*01519 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 14 NOV 88 18:55:42 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 492506; Mon 14-Nov-88 21:54:56 ESTDate: Mon, 14 Nov 88 21:54 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: HASH-TABLE-KEY-MODIFICATION (Version 1)To: masinter.paIn-Reply-To: <881114-152135-2356@Xerox>Message-ID: <19881115025447.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: 14 Nov 88 15:21 PST    From: masinter.pa@Xerox.COM    Let me encourage you to avoid feeling provoked by JonL's reaction to this    issue, and find the time to produce a slightly modified version of the    proposal which is a little more specific about the issues raised: eliminate    the "component" language in the definition except as a description of    intent (for EQUAL tables, what is a component might be different than for    EQUALP tables), change the "is an error to modify" language to be more    specific in saying that the value of subsequent GETHASH calls *on that key*    might be affected.Even in my hundreds(?) of messages of unread Common Lisp mail, I don'thave any mail with this subject.  Are you sure I was the issue author?In any case it's unlikely that I will have any time to devote to this issue,unless you think it's an important issue.  It seems secondary to me.*start*19193 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 NOV 88 13:26:59 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 16 Nov 88  13:23:53 PSTReceived: from bhopal by heavens-gate.lucid.com id AA00255g; Mon, 14 Nov 88 23:15:59 PSTReceived: by bhopal id AA25286g; Mon, 14 Nov 88 23:14:43 PSTDate: Mon, 14 Nov 88 23:14:43 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811150714.AA25286@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue: HASH-TABLE-STABILITY (version 1)Issue:      HASH-TABLE-STABILITYReferences:    CLtL, p.282 "Hash on Lisp object"	       The Art of Computer Programming, vol 3, Section 6.4 "Hashing"Category:     CLARIFICATIONEdit history: Version 1, 11-Nov-88, by JonL Problem description:The performance, and to some degree the semantics, of hash tablesdepends not only on the kind of table as specified by the :testargument to MAKE-HASH-TABLE, but also on the underlying techniquesof key transformation (into an integer) and of "collision" resolution. CLtL is not specific enough to encompass current, desirable practice.People tend to be confused as to what "Hash on EQ" means, both in termsof semantics and expected performance.  Many will often suggest usingSXHASH as the key-transformation function for EQ/EQL type tables, inorder to circumvent the well-known GC-related problem with those tables.[See, for example, the message from Barry Margolin to the common-lispmailing list dated "12 Sep 88 11:05 EDT"; it is reproduced at the end ofthe Discussion section below.]  Unfortunately, this suggestion violatesthe commonly perceived notion of what "Hash on EQ" means, even thoughCLtL nowhere explicitly would rule it out.  CLtL is not precise enoughas to what is expected of these types of tables, and certainly thephrase "commonly perceived notion" is not precise enough.A similar ambiguity can arise as to what "Hash on EQUAL" means; CLtLp.285 only indirectly implies that SXHASH should be used as thekey-transformation function for EQUAL type tables.  [See below fordefinition of "key-transformation".]The term "Hashing on Lisp objects" has come to be called "Hash on EQ", and "Hashing on Tree Structure" is called "Hash on EQUAL"; see CLtLp.282 , which describes the differences between hash-table kinds as being merely which function they use as the equivalence predicate(the :TEST function argument to MAKE-HASH-TABLE.)  However, the term "Hash Table" carries a strong connotation about how such a table is implemented; in particular, for sufficiently large tables, some techniquefor "collision resolution" must be done.  (See Knuth vol 3, p507-8).  Since CLtL merely focuses on the :test function, people -- implementors as well as end-users -- tend to be confused as to how these techniques play a central part in the notion of "hash tables; furthermore, CLtL issilent about what actions must preserve the stabililty of these "collision chains"  (i.e., the ability of the table to "find" previously entered keys).Proposal (HASH-TABLE-STABILITY:KEY-TRANSFORM-RESTRICTIONS)Summary of proposals:-- Clarify that by "hashing", we mean more than simple linear search.-- Generalize the following requirement from CLtL p.285:           (EQUAL X Y)  implies  (EQUAL (SXHASH X) (SXHASH Y))     and clarify that this requirement exactly prescribes how sensitive     hash tables can be to user-initiated data modifications.-- Characterize just what key-transformation functions may be used for     EQ, EQL, EQUAL and EQUALP hash tables.First, some terminology:"Key-Transformation".  This is a term used by Knuth to describe thehomomorphic transformation of a hash-table key argument into an integer.[See the index for "The Art of Computer Programming", vol 3; especiallysee Section 6.4 and page 512.]  It also can refer to the transformationinto a set of two or more integers (which is not really a distinctnotion considering Goedel numbering).  From this integer, the pattern of table indices to use when searching for that key will be completelycharacterized.  Knuth also uses a related term "hash function" to mean"the address where the search begins"; that term is much too subject toconfusion, and will not be used herein."Collision Chain".  This term is limited in use by Knuth to just oneparticular method of collision resolution; herein it will be used todescribe the sequence of probes specified for a given candidate entry by a particular key-transformation; i.e. a virtual "chain" of table indices (or address) to be examined.  Two different objects which "hash" to the same table address are "in conflict", and their respective collision chains may or may not be equal."Expected number of (re-)probes".  A particular algorithm for key-transformation and collision-chain specification could be analyzed toshow a graph of the "Expected" number of calls on the :test function, as a function of the fullness of the table (number of entries divided by table size).  "Expected" has a technical, mathmatical meaning here:it basically means "average", so one must be careful not to get carriedaway with particular counter examples of "badly distributed" data.  A"probe" is one comparison of the argument with the key of an entry inthe table, using the test function."%UNIQUE-NO".  The implementation of Lisp data, encoded into machine-specific data and addresses, is not part of the portable specificationof CL; but we are aware that every implemetation _must_ do some suchembedding.  Thus we will use %UNIQUE-NO to name a one-to-one functionwhich maps any Lisp object into a Lisp integer.  Normally, this willjust be the machine address of where the object is stored, possibly withsome data-type tag bits added.  But for non-stored, or "immediate" data,it doesn't matter what %UNIQUE-NO returns as long as its bijective natureis maintained.  The following equivalence is a defining characterization:    (eq x y)  <-->  (= (%unique-no x) (%unique-no y))Now for the actual proposals.1. Clarify that the term "hash table" implies the use of some techniques designed to make the expected number of probes be bounded by a small constant rather than growing linearly with the number of entries in the table [for "small constant", one could also accept "log of the number of entries"].  Although nothing in CLtL explicitly prohibits it, very few  people would accept simple linear searching as any kind of hash table. For example, the following definition is counter to our understanding:    (defun gethash (x ht &optional default)      (let ((index (position x (hash-table-key-vector ht) 			    :test (hash-table-test ht))))	(if index	    (values (svref (hash-table-value-vector ht) index)		    T)	    (values default 		    NIL))))  Such a simple definition may be functionally useful when the total number of entries is small (e.g., a couple dozen or so); but the  "Expected" number of probes grows linearly with the number of entries.   As a consequence of this requirement, the collision chain for a give item in a given table will likely not cover the whole table; otherwise, if every such chain covered a substantial fraction of the table, then the behaviour time would be linear in the size of the table.  Thus it should be noted that even though an item is entered in a hash table, it typically _cannot_ be found by searching through the wrong collision chain.2. Specify that for any equivalence relation <eqv> used as a hash table  :test function, there must be a corresponding key-transformation function  <sxh> used in that hash table such that the following implication is true for all X and Y:	 (<eqv> x y) -->  (= (<sxh> x) (<sxh> y)) This could be said to mean that a key-transformation function must be "not more discriminating" than the equivalence function it is associated with; i.e. as a numerical function, it must not create more equivalence classes  of data than the associated equivalence function does.   This requirement resembles that placed upon SXHASH [CLtL, p285], and from it, one may deduce that SXHASH is a acceptable key-transformation function for EQUAL type hash tables.  Note well, however, that there  are many many functions satisfying this property for EQUAL.  Hence  key-transformation for EQUAL tables:   (1) need not be constant over all CL implementations;   (2) need not be constant over all instances of EQUAL hash-tables in        a given implementation;   (3) need not be constant even over all entry counts for a particular        hash table in a given implementation. Note also that this requirement -- "not more discriminating" -- rules out the use of key-transformations which "notice" data modifications that are not likewise "noticed" by the test function.  Since user- initiated data modifications might conceivably affect either the equivalence relation of a hash-table (the :test function) or the associated key-transformation function, we want to ensure that the ability of the table to "find" a previously entered key is related only to the ability of the :test function to identify equivalent copies of the key.3. Clarify that %UNIQUE-NO is acceptable as a key-transformation for an EQ type table, but that it is not suitable for EQUAL or EQUALP tables. Clarify also that most SXHASH implementations are _not_ suitable for EQ  or EQL type tables. Numerous implementations have some function like %UNIQUE-NO called  either %POINTER or POINTER-TO-FIXNUM; they are generally acceptable for  EQ type tables.  But one must be careful to note that similar, unrelated functions could also be used; in particular, many "unique identification"  schemes have been employed where the integer is cached with the object by some means other than the bits of its address (e.g. a "hidden" component  inside the object). Of course, any %UNIQUE-NO defined as above would not  be acceptable for EQUAL or EQUALP tables; two EQUAL but non-EQ cons cells must have different %UNIQUE-NO values, violating the general rule stated in item 2 above. A trivial variant on %UNIQUE-NO is acceptable for EQL tables:     (if (numberp x) (sxhash x) (%unique-no x)) By itself, %UNIQUE-NO would not be acceptable since it would be too "discriminating" on numbers. Many persons have noted that the definition:     (defun sxhash (x) 5)	    ;for any random integer value of "5" meets the CLtL criterion for SXHASH.  In fact, such a constant function may be quite useful for hash-tables with entry counts below a specified mininum.  But of course it is not really suitable in general since it  would put every entry into the same collision chain; that would cause  the expected re-probe cost to be linear in the number of entries, which violates item 1 above. On the other hand, an SXHASH function suitable for use as the key transformation in an EQUAL type table is _not_ acceptable for use with an EQ or EQL table.  Every implementation the proposer has queried  returns different values for the lists (A) and (B).  Thus consider the example of hashing a list (A) into an EQ type table, and observe what  happens after altering the (first) element of this list to be B.  Let     x = the list before modification     y = the list after modificaton now clearly (EQ X Y) is true, so we would obviously like a GETHASH call after the modification has been done to find the same cons cell that  had  been entered before the update.  If SXHASH were used as the key- transform, then the collision chain selected _after_ the alteration would  be different from the one selected beforehand.   Since the two different  collision chains can not be  guaranteed to intersect, then in at least  some circumstances, GETHASH on X would find the entry, but GETHASH on Y  would fail to find it.  See also the examples section. Although SXHASH is not very tightly defined in CLtL, one must be careful not to make assumptions about whether or not it is acceptable for use in EQUALP tables.  In order to get a reasonable amount of randomization in the collision chains, a key-transformation function for EQUAL tables ought to be "more discriminating" than any minimal function acceptable  for EQUALP tables [because EQUAL partitions the object world up into  many more equivalence classes than does EQUALP].In item 2 above, there are listed three areas where key-transformationfunctions may differ: when going from one vendor to another (or from onerelease by the same vendor to another), when going from one hash-tableto another of the same type, and when increasing or decreasing the entrycount of the table.  To this list we can add another more general rule onkey-transformations.  (4) [they] need not be constant even over a particular "core image"       saving and restoration, or over a "memory reorganization" such as       a garbage collection.Of course, if a change is made at some point in time in the key-transformation algorithm being used for a particular table, then that table should be "re-hashed" to ensure the continuity of its entries.  As has been noted before, many implementations use algorithms for EQ type tables which change after any data is relocated; that is why re-hashing may be required after a "GC".Examples:It is not surprising that in the following example, the value Ycannot be found in the table after it has been altered by the firstSETF, even though it could be found before the alteration.    (setq ht (make-hash-table :test 'equal))     ==>  #<Hash-Table>   (setq x '(A (B) (C D))	 y (copy-tree x))                       ==>  (A (B) (C D))   (and (equal x y) (not (eq x y)))             ==>  T   (setf (gethash x ht) T)                      ==>  T   (setf (car (second y)) 'E)                   ==>  E   (gethash x ht)                               ==>  T   (gethash y ht)                               ==>  NILAfter all, the :test function will not be able to identify thealtered key with with the one originally entered, because at thetime gethash is called:   (equal x y)                               ==>  NILHowever, the circumstances under which the following can fail arenot at all obvious:   (setq ht (make-hash-table :test 'equal))      ==>  #<Hash-Table>   (setq x '(A #(B) (C D))	 y (copy-tree x))                        ==>  (A #(B) (C D))   (and (equal x y) (not (eq x y)))              ==>  T   (setf (gethash x ht) T)                       ==>  T   (setf (aref (second y)) 'E)                   ==>  E   (gethash x ht)                                ==>  T   (gethash y ht)                                ==>  ?Note however that:   (equal x y)                                   ==> T If the key-transformation function used in this hashtable failed to obeythe "not more discriminating" contraint imposed by item 2 above, itmight be tempted to descend into the vector #(B) in order to randomizethe keys a bit more; but EQUAL on pointer vectors is defined to be EQ.Thus X and Y, while being EQUAL, might fall into different collisionchains, and hence not be identified as the same key.On the other hand, EQ/EQL type tables should be impervious to theupdates in the above examples:   (setq ht (make-hash-table))                    ==>  #<Hash-Table>   (setq y (setq x (copy-tree '(A (B) (C D)))))   ==>  (A (B) (C D))   (setf (gethash x ht) T)                        ==>  T   (gethash x ht)                                 ==>  T   (setf (car (second y)) 'E)                     ==>  E   (gethash y ht)                                 ==>  TThus x and y are "EQ, but not EQUAL" [which only makes sense whenthey refer to the same object at different points in time]; however,the EQ/EQL-type table is not affected by this.Rationale:The performance expectations about hash-tables, and consequent implementational constraints, need to be formalized.Current practice:Every implementation that the proposer has tried *seems* to satisfythese constraints.Cost to Implementors:None.Cost to Users:None.Cost of non-adoption:Continuing confusion as to what is stable in EQ/EQL tables, and whatis stable in EQUAL tables.  Possible confusion when it comes toimplementing EQUALP tables.Performance impact:N.A.Benefits:See Cost of non-adoption.Esthetics:The proposal more closely relates the term "Hash Table" to theclassic use of it in  "The Art of Computer Programming", vol 3.Discussion:One of the attractions to Common Lisp is that many common techniques area required part of the language; C programmers who continue to re-inventhasing techniques over and over have praised CL in particular for hashtables.  After all, it is much more likely that efficient, correctlycoded algorithms will be provided by the system supplier than that everycode writer will understand and correctly apply the information foundin Knuth's "The Art of Computer Programming", vol 3.The requirement that the expected number of reprobes be bounded by a "small constant" should not be taken to extreme.  In particular, asimple trade-off of space for time can assure some compliance with it.For example, a data set of size N could be partitioned into N/20subsets; as long as the partitioning function does a fairly good jobof balancing the number of elements in each partition class, and aslong as the partition function can be quickly calculated, then the onecould say that the expected number of probes would be bounded by "abouttwenty or so".  The generally understood meanings of the :rehash-sizeand :rehash-threshold components of hash-tables may be biased towards an "open-addressing" implementation; but "bucketizing" implementationsare not arbitrarily ruled out.  This proposal is in no way intended torule out "bucketizing" implementations of hash tables.Here's an example of how one might analyze the problems relating GC and EQ/EQL type tables:  Date: Mon, 12 Sep 88 11:05 EDT  From: Barry Margolin <barmar@Think.COM>  Subject: MAKE-HASH-TABLE :TEST arg  To: "Steve Bacher (Batchman)" <SEB1525@draper.com>  Cc: common-lisp@sail.stanford.edu  . . .   Various aspects of the behavior of a hash table are dependent upon the  TEST argument.  An EQUAL hash table need not be rehashed after a copying  GC.  The hash function is generally dependent upon the test function;  for an EQUAL hash table it would be SXHASH, while for an EQ hash table  it would probably be a simple hash on the address.  I suppose you COULD use SXHASH for all hash tables, since EQ objects are  necessarily EQUAL, and you COULD rehash ALL hash tables.  Or you could  implement hash tables without actually hashing (e.g. implement them as  alists).  But if performance is an issue (which it generally is when you  use a hash table), you'll probably want to do things dependent on the  test function.						  barmarThis suggestion is not prohibited by CLtL, although it violates thecommonly accepted understanding of what "Hash on EQ" means.*start*01113 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 NOV 88 15:19:37 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 18 Nov 88  15:17:54 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02487g; Fri, 18 Nov 88 15:16:19 PSTReceived: by bhopal id AA10635g; Fri, 18 Nov 88 15:15:00 PSTDate: Fri, 18 Nov 88 15:15:00 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811182315.AA10635@bhopal>To: SEB1525@draper.comCc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: "Steve Bacher (Batchman)"'s message of Thu, 17 Nov 88 09:18 EST <8811180823.AA01976@lucid.com>Subject: Issue HASH-TABLE-STABILITYre: Concerning "EQ but not EQUAL"...    Is a CL implementation in error if it implements EQUAL by returning T if    the arguments are EQ, as a performance hack?The buzz words "EQ but not EQUAL" imply calling EQUAL at two different times; the altered item (which remains EQ to itself) is no longer EQUALto the "platonic" original version.-- JonL --*start*01373 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 NOV 88 15:23:49 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 18 Nov 88  15:22:45 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02504g; Fri, 18 Nov 88 15:21:06 PSTReceived: by bhopal id AA10651g; Fri, 18 Nov 88 15:19:52 PSTDate: Fri, 18 Nov 88 15:19:52 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811182319.AA10651@bhopal>To: jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UKCc: @sail.stanford.edu:jonl@lucid.com, cl-cleanup@sail.stanford.eduIn-Reply-To: Jeff Dalton's message of Thu, 17 Nov 88 17:17:09 GMT <17889.8811171717@subnode.aiai.ed.ac.uk>Subject: Issue: HASH-TABLE-STABILITY (version 1)re: Well said.  I can think of one "problem": you have specified the    constraints relating the :test and the key transformation so well    that it no longer seems reasonable that users are not able to provide    their own :test and key transformation.That would be superb, if Joe Random User were able to understand this"clarification".  I agree that that may be the only thing lacking for fully extensible hash-tables.  [But you, Jeff, are a somewhat advanced-to-wizard person, so you may not be the ultimate test needed.]-- JonL --*start*01554 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 NOV 88 13:59:02 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 19 Nov 88  13:57:08 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa05348; 19 Nov 88 21:09 GMTDate: Sat, 19 Nov 88 21:35:47 GMTMessage-Id: <1145.8811192135@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: HASH-TABLE-STABILITY (version 1)To: jonl <@sail.stanford.edu:jonl@lucid.com>, cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Fri, 18 Nov 88 15:19:52 PST> re: Well said.  I can think of one "problem": you have specified the>     constraints relating the :test and the key transformation so well>     that it no longer seems reasonable that users are not able to provide>     their own :test and key transformation.> > That would be superb, if Joe Random User were able to understand this> "clarification".  I agree that that may be the only thing lacking for > fully extensible hash-tables.There are many things in Lisp that users may not understand initiallyand so may get wrong.  I don't think that's necessarily a good reasonto keep something out of the language.  (And if it were, there areparts of CLOS, SETF, and packages that we would want clean out.)BTW, Pop11 allows user-specified test and hash (key transform)functions.-- Jeff*start*01998 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 NOV 88 15:20:03 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Nov 88  15:16:12 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 496880; Tue 22-Nov-88 18:15:39 ESTDate: Tue, 22 Nov 88 18:15 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: HASH-TABLE-STABILITY (version 1)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8811150714.AA25286@bhopal>Message-ID: <19881122231526.2.MOON@EUPHRATES.SCRC.Symbolics.COM>This proposal is so long that I got lost while reading it.  From theexamples, one would think it was proposing some rules about what userscan expect when they modify objects that are used as keys of hashtables.  However, I couldn't find anything actually proposed about that.Most of the proposal seems to be about what performance users of hashtables should expect, but I didn't see anything specific enough that Icould write a Common Lisp program to test whether an implementationconforms to the proposal.I think this proposal needs to be shortened and rewritten.  I wouldprefer to see it speak about the behavior a user can or cannot expectfrom a Common Lisp implementation, rather than in terms of internaldetails of how Common Lisp might be implemented.  The essay onimplementation techniques could go in the discussion section, or couldbe published separately, but I don't think it is suitable as a languagespecification.It might be a good idea to break this into two proposals, one on keymodification and a separate one on performance.  The reason I say thatis that I think standardizing performance is extremely difficult, and Iwould hate to see the problems with that sink the other proposal.*start*00916 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 DEC 88 11:32:07 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Dec 88  11:29:40 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 DEC 88 11:28:23 PSTDate: 8 Dec 88 11:22 PSTFrom: masinter.paSubject:  Issue: HASH-TABLE-KEY-MODIFICATION (and HASH-TABLE-STABILITY)To: cl-cleanup@sail.stanford.eduMessage-ID: <881208-112823-4012@Xerox>I have little hope of reaching convergence on HASH-TABLE-KEY-MODIFICATIONor HASH-TABLE-STABILITY (which I file as HASH-TABLE-KEY-MODIFICATION) intime for either to influence the Draft Standard.That is, we are not close to producing a version of either proposal/issuewrite up that we agree fairly describes the problem and the pros and consof a (set of) proposed solutions.*start*01241 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 10 DEC 88 05:36:34 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03650g; Sat, 10 Dec 88 05:34:40 PSTReceived: by bhopal id AA00429g; Sat, 10 Dec 88 05:36:37 PSTDate: Sat, 10 Dec 88 05:36:37 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812101336.AA00429@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 8 Dec 88 11:22 PST <881208-112823-4012@Xerox>Subject: Issue: HASH-TABLE-KEY-MODIFICATION (and HASH-TABLE-STABILITY)I believe we have reached convergence on HASH-TABLE-STABILITY.  There isnothing wrong with it as it stands, and it should be released.  It hasalready received extensive positive review within Lucid; and has receivedsome very positive review outside.  At worst, moon's comment must beviewed as negative, but non-productive.Since HASH-TABLE-STABILITY incorporates everything that HASH-TABLE-KEY-MODIFICATION said -- it is an upward-compatible extension of what it was trying to say -- then either the latter should be withdrawn, or submitted as a closely linked issue, just in the former fails.-- JonL --*start*20581 00024 UU?Date: 12 Dec 88 11:51 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: HASH-TABLE-STABILITY (Version 1)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noThis issue has "additional comments" at the end that are notpart of this version.Issue:      HASH-TABLE-STABILITYReferences:    CLtL, p.282 "Hash on Lisp object"	       The Art of Computer Programming, vol 3, Section 6.4 "Hashing"Category:     CLARIFICATIONEdit history: Version 1, 11-Nov-88, by JonL Problem description:The performance, and to some degree the semantics, of hash tablesdepends not only on the kind of table as specified by the :testargument to MAKE-HASH-TABLE, but also on the underlying techniquesof key transformation (into an integer) and of "collision" resolution. CLtL is not specific enough to encompass current, desirable practice.People tend to be confused as to what "Hash on EQ" means, both in termsof semantics and expected performance.  Many will often suggest usingSXHASH as the key-transformation function for EQ/EQL type tables, inorder to circumvent the well-known GC-related problem with those tables.[See, for example, the message from Barry Margolin to the common-lispmailing list dated "12 Sep 88 11:05 EDT"; it is reproduced at the end ofthe Discussion section below.]  Unfortunately, this suggestion violatesthe commonly perceived notion of what "Hash on EQ" means, even thoughCLtL nowhere explicitly would rule it out.  CLtL is not precise enoughas to what is expected of these types of tables, and certainly thephrase "commonly perceived notion" is not precise enough.A similar ambiguity can arise as to what "Hash on EQUAL" means; CLtLp.285 only indirectly implies that SXHASH should be used as thekey-transformation function for EQUAL type tables.  [See below fordefinition of "key-transformation".]The term "Hashing on Lisp objects" has come to be called "Hash on EQ", and "Hashing on Tree Structure" is called "Hash on EQUAL"; see CLtLp.282 , which describes the differences between hash-table kinds as being merely which function they use as the equivalence predicate(the :TEST function argument to MAKE-HASH-TABLE.)  However, the term "Hash Table" carries a strong connotation about how such a table is implemented; in particular, for sufficiently large tables, some techniquefor "collision resolution" must be done.  (See Knuth vol 3, p507-8).  Since CLtL merely focuses on the :test function, people -- implementors as well as end-users -- tend to be confused as to how these techniques play a central part in the notion of "hash tables; furthermore, CLtL issilent about what actions must preserve the stabililty of these "collision chains"  (i.e., the ability of the table to "find" previously entered keys).Proposal (HASH-TABLE-STABILITY:KEY-TRANSFORM-RESTRICTIONS)Summary of proposals:-- Clarify that by "hashing", we mean more than simple linear search.-- Generalize the following requirement from CLtL p.285:           (EQUAL X Y)  implies  (EQUAL (SXHASH X) (SXHASH Y))     and clarify that this requirement exactly prescribes how sensitive     hash tables can be to user-initiated data modifications.-- Characterize just what key-transformation functions may be used for     EQ, EQL, EQUAL and EQUALP hash tables.First, some terminology:"Key-Transformation".  This is a term used by Knuth to describe thehomomorphic transformation of a hash-table key argument into an integer.[See the index for "The Art of Computer Programming", vol 3; especiallysee Section 6.4 and page 512.]  It also can refer to the transformationinto a set of two or more integers (which is not really a distinctnotion considering Goedel numbering).  From this integer, the pattern of table indices to use when searching for that key will be completelycharacterized.  Knuth also uses a related term "hash function" to mean"the address where the search begins"; that term is much too subject toconfusion, and will not be used herein."Collision Chain".  This term is limited in use by Knuth to just oneparticular method of collision resolution; herein it will be used todescribe the sequence of probes specified for a given candidate entry by a particular key-transformation; i.e. a virtual "chain" of table indices (or address) to be examined.  Two different objects which "hash" to the same table address are "in conflict", and their respective collision chains may or may not be equal."Expected number of (re-)probes".  A particular algorithm for key-transformation and collision-chain specification could be analyzed toshow a graph of the "Expected" number of calls on the :test function, as a function of the fullness of the table (number of entries divided by table size).  "Expected" has a technical, mathmatical meaning here:it basically means "average", so one must be careful not to get carriedaway with particular counter examples of "badly distributed" data.  A"probe" is one comparison of the argument with the key of an entry inthe table, using the test function."%UNIQUE-NO".  The implementation of Lisp data, encoded into machine-specific data and addresses, is not part of the portable specificationof CL; but we are aware that every implemetation _must_ do some suchembedding.  Thus we will use %UNIQUE-NO to name a one-to-one functionwhich maps any Lisp object into a Lisp integer.  Normally, this willjust be the machine address of where the object is stored, possibly withsome data-type tag bits added.  But for non-stored, or "immediate" data,it doesn't matter what %UNIQUE-NO returns as long as its bijective natureis maintained.  The following equivalence is a defining characterization:    (eq x y)  <-->  (= (%unique-no x) (%unique-no y))Now for the actual proposals.1. Clarify that the term "hash table" implies the use of some techniques designed to make the expected number of probes be bounded by a small constant rather than growing linearly with the number of entries in the table [for "small constant", one could also accept "log of the number of entries"].  Although nothing in CLtL explicitly prohibits it, very few  people would accept simple linear searching as any kind of hash table. For example, the following definition is counter to our understanding:    (defun gethash (x ht &optional default)      (let ((index (position x (hash-table-key-vector ht) 			    :test (hash-table-test ht))))	(if index	    (values (svref (hash-table-value-vector ht) index)		    T)	    (values default 		    NIL))))  Such a simple definition may be functionally useful when the total number of entries is small (e.g., a couple dozen or so); but the  "Expected" number of probes grows linearly with the number of entries.   As a consequence of this requirement, the collision chain for a give item in a given table will likely not cover the whole table; otherwise, if every such chain covered a substantial fraction of the table, then the behaviour time would be linear in the size of the table.  Thus it should be noted that even though an item is entered in a hash table, it typically _cannot_ be found by searching through the wrong collision chain.2. Specify that for any equivalence relation <eqv> used as a hash table  :test function, there must be a corresponding key-transformation function  <sxh> used in that hash table such that the following implication is true for all X and Y:	 (<eqv> x y) -->  (= (<sxh> x) (<sxh> y)) This could be said to mean that a key-transformation function must be "not more discriminating" than the equivalence function it is associated with; i.e. as a numerical function, it must not create more equivalence classes  of data than the associated equivalence function does.   This requirement resembles that placed upon SXHASH [CLtL, p285], and from it, one may deduce that SXHASH is a acceptable key-transformation function for EQUAL type hash tables.  Note well, however, that there  are many many functions satisfying this property for EQUAL.  Hence  key-transformation for EQUAL tables:   (1) need not be constant over all CL implementations;   (2) need not be constant over all instances of EQUAL hash-tables in        a given implementation;   (3) need not be constant even over all entry counts for a particular        hash table in a given implementation. Note also that this requirement -- "not more discriminating" -- rules out the use of key-transformations which "notice" data modifications that are not likewise "noticed" by the test function.  Since user- initiated data modifications might conceivably affect either the equivalence relation of a hash-table (the :test function) or the associated key-transformation function, we want to ensure that the ability of the table to "find" a previously entered key is related only to the ability of the :test function to identify equivalent copies of the key.3. Clarify that %UNIQUE-NO is acceptable as a key-transformation for an EQ type table, but that it is not suitable for EQUAL or EQUALP tables. Clarify also that most SXHASH implementations are _not_ suitable for EQ  or EQL type tables. Numerous implementations have some function like %UNIQUE-NO called  either %POINTER or POINTER-TO-FIXNUM; they are generally acceptable for  EQ type tables.  But one must be careful to note that similar, unrelated functions could also be used; in particular, many "unique identification"  schemes have been employed where the integer is cached with the object by some means other than the bits of its address (e.g. a "hidden" component  inside the object). Of course, any %UNIQUE-NO defined as above would not  be acceptable for EQUAL or EQUALP tables; two EQUAL but non-EQ cons cells must have different %UNIQUE-NO values, violating the general rule stated in item 2 above. A trivial variant on %UNIQUE-NO is acceptable for EQL tables:     (if (numberp x) (sxhash x) (%unique-no x)) By itself, %UNIQUE-NO would not be acceptable since it would be too "discriminating" on numbers. Many persons have noted that the definition:     (defun sxhash (x) 5)	    ;for any random integer value of "5" meets the CLtL criterion for SXHASH.  In fact, such a constant function may be quite useful for hash-tables with entry counts below a specified mininum.  But of course it is not really suitable in general since it  would put every entry into the same collision chain; that would cause  the expected re-probe cost to be linear in the number of entries, which violates item 1 above. On the other hand, an SXHASH function suitable for use as the key transformation in an EQUAL type table is _not_ acceptable for use with an EQ or EQL table.  Every implementation the proposer has queried  returns different values for the lists (A) and (B).  Thus consider the example of hashing a list (A) into an EQ type table, and observe what  happens after altering the (first) element of this list to be B.  Let     x = the list before modification     y = the list after modificaton now clearly (EQ X Y) is true, so we would obviously like a GETHASH call after the modification has been done to find the same cons cell that  had  been entered before the update.  If SXHASH were used as the key- transform, then the collision chain selected _after_ the alteration would  be different from the one selected beforehand.   Since the two different  collision chains can not be  guaranteed to intersect, then in at least  some circumstances, GETHASH on X would find the entry, but GETHASH on Y  would fail to find it.  See also the examples section. Although SXHASH is not very tightly defined in CLtL, one must be careful not to make assumptions about whether or not it is acceptable for use in EQUALP tables.  In order to get a reasonable amount of randomization in the collision chains, a key-transformation function for EQUAL tables ought to be "more discriminating" than any minimal function acceptable  for EQUALP tables [because EQUAL partitions the object world up into  many more equivalence classes than does EQUALP].In item 2 above, there are listed three areas where key-transformationfunctions may differ: when going from one vendor to another (or from onerelease by the same vendor to another), when going from one hash-tableto another of the same type, and when increasing or decreasing the entrycount of the table.  To this list we can add another more general rule onkey-transformations.  (4) [they] need not be constant even over a particular "core image"       saving and restoration, or over a "memory reorganization" such as       a garbage collection.Of course, if a change is made at some point in time in the key-transformation algorithm being used for a particular table, then that table should be "re-hashed" to ensure the continuity of its entries.  As has been noted before, many implementations use algorithms for EQ type tables which change after any data is relocated; that is why re-hashing may be required after a "GC".Examples:It is not surprising that in the following example, the value Ycannot be found in the table after it has been altered by the firstSETF, even though it could be found before the alteration.    (setq ht (make-hash-table :test 'equal))     ==>  #<Hash-Table>   (setq x '(A (B) (C D))	 y (copy-tree x))                       ==>  (A (B) (C D))   (and (equal x y) (not (eq x y)))             ==>  T   (setf (gethash x ht) T)                      ==>  T   (setf (car (second y)) 'E)                   ==>  E   (gethash x ht)                               ==>  T   (gethash y ht)                               ==>  NILAfter all, the :test function will not be able to identify thealtered key with with the one originally entered, because at thetime gethash is called:   (equal x y)                               ==>  NILHowever, the circumstances under which the following can fail arenot at all obvious:   (setq ht (make-hash-table :test 'equal))      ==>  #<Hash-Table>   (setq x '(A #(B) (C D))	 y (copy-tree x))                        ==>  (A #(B) (C D))   (and (equal x y) (not (eq x y)))              ==>  T   (setf (gethash x ht) T)                       ==>  T   (setf (aref (second y)) 'E)                   ==>  E   (gethash x ht)                                ==>  T   (gethash y ht)                                ==>  ?Note however that:   (equal x y)                                   ==> T If the key-transformation function used in this hashtable failed to obeythe "not more discriminating" contraint imposed by item 2 above, itmight be tempted to descend into the vector #(B) in order to randomizethe keys a bit more; but EQUAL on pointer vectors is defined to be EQ.Thus X and Y, while being EQUAL, might fall into different collisionchains, and hence not be identified as the same key.On the other hand, EQ/EQL type tables should be impervious to theupdates in the above examples:   (setq ht (make-hash-table))                    ==>  #<Hash-Table>   (setq y (setq x (copy-tree '(A (B) (C D)))))   ==>  (A (B) (C D))   (setf (gethash x ht) T)                        ==>  T   (gethash x ht)                                 ==>  T   (setf (car (second y)) 'E)                     ==>  E   (gethash y ht)                                 ==>  TThus x and y are "EQ, but not EQUAL" [which only makes sense whenthey refer to the same object at different points in time]; however,the EQ/EQL-type table is not affected by this.Rationale:The performance expectations about hash-tables, and consequent implementational constraints, need to be formalized.Current practice:Every implementation that the proposer has tried *seems* to satisfythese constraints.Cost to Implementors:None.Cost to Users:None.Cost of non-adoption:Continuing confusion as to what is stable in EQ/EQL tables, and whatis stable in EQUAL tables.  Possible confusion when it comes toimplementing EQUALP tables.Performance impact:N.A.Benefits:See Cost of non-adoption.Esthetics:The proposal more closely relates the term "Hash Table" to theclassic use of it in  "The Art of Computer Programming", vol 3.Discussion:One of the attractions to Common Lisp is that many common techniques area required part of the language; C programmers who continue to re-inventhasing techniques over and over have praised CL in particular for hashtables.  After all, it is much more likely that efficient, correctlycoded algorithms will be provided by the system supplier than that everycode writer will understand and correctly apply the information foundin Knuth's "The Art of Computer Programming", vol 3.The requirement that the expected number of reprobes be bounded by a "small constant" should not be taken to extreme.  In particular, asimple trade-off of space for time can assure some compliance with it.For example, a data set of size N could be partitioned into N/20subsets; as long as the partitioning function does a fairly good jobof balancing the number of elements in each partition class, and aslong as the partition function can be quickly calculated, then the onecould say that the expected number of probes would be bounded by "abouttwenty or so".  The generally understood meanings of the :rehash-sizeand :rehash-threshold components of hash-tables may be biased towards an "open-addressing" implementation; but "bucketizing" implementationsare not arbitrarily ruled out.  This proposal is in no way intended torule out "bucketizing" implementations of hash tables.Here's an example of how one might analyze the problems relating GC and EQ/EQL type tables:  Date: Mon, 12 Sep 88 11:05 EDT  From: Barry Margolin <barmar@Think.COM>  Subject: MAKE-HASH-TABLE :TEST arg  To: "Steve Bacher (Batchman)" <SEB1525@draper.com>  Cc: common-lisp@sail.stanford.edu  . . .   Various aspects of the behavior of a hash table are dependent upon the  TEST argument.  An EQUAL hash table need not be rehashed after a copying  GC.  The hash function is generally dependent upon the test function;  for an EQUAL hash table it would be SXHASH, while for an EQ hash table  it would probably be a simple hash on the address.  I suppose you COULD use SXHASH for all hash tables, since EQ objects are  necessarily EQUAL, and you COULD rehash ALL hash tables.  Or you could  implement hash tables without actually hashing (e.g. implement them as  alists).  But if performance is an issue (which it generally is when you  use a hash table), you'll probably want to do things dependent on the  test function.						  barmarThis suggestion is not prohibited by CLtL, although it violates thecommonly accepted understanding of what "Hash on EQ" means.            ----- Additional Comments  -----"This proposal is so long that I got lost while reading it.  From theexamples, one would think it was proposing some rules about what userscan expect when they modify objects that are used as keys of hashtables.  However, I couldn't find anything actually proposed about that.Most of the proposal seems to be about what performance users of hashtables should expect, but I didn't see anything specific enough that Icould write a Common Lisp program to test whether an implementationconforms to the proposal.I think this proposal needs to be shortened and rewritten.  I wouldprefer to see it speak about the behavior a user can or cannot expectfrom a Common Lisp implementation, rather than in terms of internaldetails of how Common Lisp might be implemented.  The essay onimplementation techniques could go in the discussion section, or couldbe published separately, but I don't think it is suitable as a languagespecification.It might be a good idea to break this into two proposals, one on keymodification and a separate one on performance.  The reason I say thatis that I think standardizing performance is extremely difficult, and Iwould hate to see the problems with that sink the other proposal."        TITAN 
         TITAN 
         ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))           C                     i                            !                    ;      '       
      	              w              Y                                                               
                                        N  z*start*20506 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 12:42:10 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  12:12:16 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 11:51:33 PSTDate: 12 Dec 88 11:51 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: HASH-TABLE-STABILITY (Version 1)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881212-115133-4704@Xerox>This issue has "additional comments" at the end that are notpart of this version.!Issue:      HASH-TABLE-STABILITYReferences:    CLtL, p.282 "Hash on Lisp object"	       The Art of Computer Programming, vol 3, Section 6.4 "Hashing"Category:     CLARIFICATIONEdit history: Version 1, 11-Nov-88, by JonL Problem description:The performance, and to some degree the semantics, of hash tablesdepends not only on the kind of table as specified by the :testargument to MAKE-HASH-TABLE, but also on the underlying techniquesof key transformation (into an integer) and of "collision" resolution. CLtL is not specific enough to encompass current, desirable practice.People tend to be confused as to what "Hash on EQ" means, both in termsof semantics and expected performance.  Many will often suggest usingSXHASH as the key-transformation function for EQ/EQL type tables, inorder to circumvent the well-known GC-related problem with those tables.[See, for example, the message from Barry Margolin to the common-lispmailing list dated "12 Sep 88 11:05 EDT"; it is reproduced at the end ofthe Discussion section below.]  Unfortunately, this suggestion violatesthe commonly perceived notion of what "Hash on EQ" means, even thoughCLtL nowhere explicitly would rule it out.  CLtL is not precise enoughas to what is expected of these types of tables, and certainly thephrase "commonly perceived notion" is not precise enough.A similar ambiguity can arise as to what "Hash on EQUAL" means; CLtLp.285 only indirectly implies that SXHASH should be used as thekey-transformation function for EQUAL type tables.  [See below fordefinition of "key-transformation".]The term "Hashing on Lisp objects" has come to be called "Hash on EQ", and "Hashing on Tree Structure" is called "Hash on EQUAL"; see CLtLp.282 , which describes the differences between hash-table kinds as being merely which function they use as the equivalence predicate(the :TEST function argument to MAKE-HASH-TABLE.)  However, the term "Hash Table" carries a strong connotation about how such a table is implemented; in particular, for sufficiently large tables, some techniquefor "collision resolution" must be done.  (See Knuth vol 3, p507-8).  Since CLtL merely focuses on the :test function, people -- implementors as well as end-users -- tend to be confused as to how these techniques play a central part in the notion of "hash tables; furthermore, CLtL issilent about what actions must preserve the stabililty of these "collision chains"  (i.e., the ability of the table to "find" previously entered keys).Proposal (HASH-TABLE-STABILITY:KEY-TRANSFORM-RESTRICTIONS)Summary of proposals:-- Clarify that by "hashing", we mean more than simple linear search.-- Generalize the following requirement from CLtL p.285:           (EQUAL X Y)  implies  (EQUAL (SXHASH X) (SXHASH Y))     and clarify that this requirement exactly prescribes how sensitive     hash tables can be to user-initiated data modifications.-- Characterize just what key-transformation functions may be used for     EQ, EQL, EQUAL and EQUALP hash tables.First, some terminology:"Key-Transformation".  This is a term used by Knuth to describe thehomomorphic transformation of a hash-table key argument into an integer.[See the index for "The Art of Computer Programming", vol 3; especiallysee Section 6.4 and page 512.]  It also can refer to the transformationinto a set of two or more integers (which is not really a distinctnotion considering Goedel numbering).  From this integer, the pattern of table indices to use when searching for that key will be completelycharacterized.  Knuth also uses a related term "hash function" to mean"the address where the search begins"; that term is much too subject toconfusion, and will not be used herein."Collision Chain".  This term is limited in use by Knuth to just oneparticular method of collision resolution; herein it will be used todescribe the sequence of probes specified for a given candidate entry by a particular key-transformation; i.e. a virtual "chain" of table indices (or address) to be examined.  Two different objects which "hash" to the same table address are "in conflict", and their respective collision chains may or may not be equal."Expected number of (re-)probes".  A particular algorithm for key-transformation and collision-chain specification could be analyzed toshow a graph of the "Expected" number of calls on the :test function, as a function of the fullness of the table (number of entries divided by table size).  "Expected" has a technical, mathmatical meaning here:it basically means "average", so one must be careful not to get carriedaway with particular counter examples of "badly distributed" data.  A"probe" is one comparison of the argument with the key of an entry inthe table, using the test function."%UNIQUE-NO".  The implementation of Lisp data, encoded into machine-specific data and addresses, is not part of the portable specificationof CL; but we are aware that every implemetation _must_ do some suchembedding.  Thus we will use %UNIQUE-NO to name a one-to-one functionwhich maps any Lisp object into a Lisp integer.  Normally, this willjust be the machine address of where the object is stored, possibly withsome data-type tag bits added.  But for non-stored, or "immediate" data,it doesn't matter what %UNIQUE-NO returns as long as its bijective natureis maintained.  The following equivalence is a defining characterization:    (eq x y)  <-->  (= (%unique-no x) (%unique-no y))Now for the actual proposals.1. Clarify that the term "hash table" implies the use of some techniques designed to make the expected number of probes be bounded by a small constant rather than growing linearly with the number of entries in the table [for "small constant", one could also accept "log of the number of entries"].  Although nothing in CLtL explicitly prohibits it, very few  people would accept simple linear searching as any kind of hash table. For example, the following definition is counter to our understanding:    (defun gethash (x ht &optional default)      (let ((index (position x (hash-table-key-vector ht) 			    :test (hash-table-test ht))))	(if index	    (values (svref (hash-table-value-vector ht) index)		    T)	    (values default 		    NIL))))  Such a simple definition may be functionally useful when the total number of entries is small (e.g., a couple dozen or so); but the  "Expected" number of probes grows linearly with the number of entries.   As a consequence of this requirement, the collision chain for a give item in a given table will likely not cover the whole table; otherwise, if every such chain covered a substantial fraction of the table, then the behaviour time would be linear in the size of the table.  Thus it should be noted that even though an item is entered in a hash table, it typically _cannot_ be found by searching through the wrong collision chain.2. Specify that for any equivalence relation <eqv> used as a hash table  :test function, there must be a corresponding key-transformation function  <sxh> used in that hash table such that the following implication is true for all X and Y:	 (<eqv> x y) -->  (= (<sxh> x) (<sxh> y)) This could be said to mean that a key-transformation function must be "not more discriminating" than the equivalence function it is associated with; i.e. as a numerical function, it must not create more equivalence classes  of data than the associated equivalence function does.   This requirement resembles that placed upon SXHASH [CLtL, p285], and from it, one may deduce that SXHASH is a acceptable key-transformation function for EQUAL type hash tables.  Note well, however, that there  are many many functions satisfying this property for EQUAL.  Hence  key-transformation for EQUAL tables:   (1) need not be constant over all CL implementations;   (2) need not be constant over all instances of EQUAL hash-tables in        a given implementation;   (3) need not be constant even over all entry counts for a particular        hash table in a given implementation. Note also that this requirement -- "not more discriminating" -- rules out the use of key-transformations which "notice" data modifications that are not likewise "noticed" by the test function.  Since user- initiated data modifications might conceivably affect either the equivalence relation of a hash-table (the :test function) or the associated key-transformation function, we want to ensure that the ability of the table to "find" a previously entered key is related only to the ability of the :test function to identify equivalent copies of the key.3. Clarify that %UNIQUE-NO is acceptable as a key-transformation for an EQ type table, but that it is not suitable for EQUAL or EQUALP tables. Clarify also that most SXHASH implementations are _not_ suitable for EQ  or EQL type tables. Numerous implementations have some function like %UNIQUE-NO called  either %POINTER or POINTER-TO-FIXNUM; they are generally acceptable for  EQ type tables.  But one must be careful to note that similar, unrelated functions could also be used; in particular, many "unique identification"  schemes have been employed where the integer is cached with the object by some means other than the bits of its address (e.g. a "hidden" component  inside the object). Of course, any %UNIQUE-NO defined as above would not  be acceptable for EQUAL or EQUALP tables; two EQUAL but non-EQ cons cells must have different %UNIQUE-NO values, violating the general rule stated in item 2 above. A trivial variant on %UNIQUE-NO is acceptable for EQL tables:     (if (numberp x) (sxhash x) (%unique-no x)) By itself, %UNIQUE-NO would not be acceptable since it would be too "discriminating" on numbers. Many persons have noted that the definition:     (defun sxhash (x) 5)	    ;for any random integer value of "5" meets the CLtL criterion for SXHASH.  In fact, such a constant function may be quite useful for hash-tables with entry counts below a specified mininum.  But of course it is not really suitable in general since it  would put every entry into the same collision chain; that would cause  the expected re-probe cost to be linear in the number of entries, which violates item 1 above. On the other hand, an SXHASH function suitable for use as the key transformation in an EQUAL type table is _not_ acceptable for use with an EQ or EQL table.  Every implementation the proposer has queried  returns different values for the lists (A) and (B).  Thus consider the example of hashing a list (A) into an EQ type table, and observe what  happens after altering the (first) element of this list to be B.  Let     x = the list before modification     y = the list after modificaton now clearly (EQ X Y) is true, so we would obviously like a GETHASH call after the modification has been done to find the same cons cell that  had  been entered before the update.  If SXHASH were used as the key- transform, then the collision chain selected _after_ the alteration would  be different from the one selected beforehand.   Since the two different  collision chains can not be  guaranteed to intersect, then in at least  some circumstances, GETHASH on X would find the entry, but GETHASH on Y  would fail to find it.  See also the examples section. Although SXHASH is not very tightly defined in CLtL, one must be careful not to make assumptions about whether or not it is acceptable for use in EQUALP tables.  In order to get a reasonable amount of randomization in the collision chains, a key-transformation function for EQUAL tables ought to be "more discriminating" than any minimal function acceptable  for EQUALP tables [because EQUAL partitions the object world up into  many more equivalence classes than does EQUALP].In item 2 above, there are listed three areas where key-transformationfunctions may differ: when going from one vendor to another (or from onerelease by the same vendor to another), when going from one hash-tableto another of the same type, and when increasing or decreasing the entrycount of the table.  To this list we can add another more general rule onkey-transformations.  (4) [they] need not be constant even over a particular "core image"       saving and restoration, or over a "memory reorganization" such as       a garbage collection.Of course, if a change is made at some point in time in the key-transformation algorithm being used for a particular table, then that table should be "re-hashed" to ensure the continuity of its entries.  As has been noted before, many implementations use algorithms for EQ type tables which change after any data is relocated; that is why re-hashing may be required after a "GC".Examples:It is not surprising that in the following example, the value Ycannot be found in the table after it has been altered by the firstSETF, even though it could be found before the alteration.    (setq ht (make-hash-table :test 'equal))     ==>  #<Hash-Table>   (setq x '(A (B) (C D))	 y (copy-tree x))                       ==>  (A (B) (C D))   (and (equal x y) (not (eq x y)))             ==>  T   (setf (gethash x ht) T)                      ==>  T   (setf (car (second y)) 'E)                   ==>  E   (gethash x ht)                               ==>  T   (gethash y ht)                               ==>  NILAfter all, the :test function will not be able to identify thealtered key with with the one originally entered, because at thetime gethash is called:   (equal x y)                               ==>  NILHowever, the circumstances under which the following can fail arenot at all obvious:   (setq ht (make-hash-table :test 'equal))      ==>  #<Hash-Table>   (setq x '(A #(B) (C D))	 y (copy-tree x))                        ==>  (A #(B) (C D))   (and (equal x y) (not (eq x y)))              ==>  T   (setf (gethash x ht) T)                       ==>  T   (setf (aref (second y)) 'E)                   ==>  E   (gethash x ht)                                ==>  T   (gethash y ht)                                ==>  ?Note however that:   (equal x y)                                   ==> T If the key-transformation function used in this hashtable failed to obeythe "not more discriminating" contraint imposed by item 2 above, itmight be tempted to descend into the vector #(B) in order to randomizethe keys a bit more; but EQUAL on pointer vectors is defined to be EQ.Thus X and Y, while being EQUAL, might fall into different collisionchains, and hence not be identified as the same key.On the other hand, EQ/EQL type tables should be impervious to theupdates in the above examples:   (setq ht (make-hash-table))                    ==>  #<Hash-Table>   (setq y (setq x (copy-tree '(A (B) (C D)))))   ==>  (A (B) (C D))   (setf (gethash x ht) T)                        ==>  T   (gethash x ht)                                 ==>  T   (setf (car (second y)) 'E)                     ==>  E   (gethash y ht)                                 ==>  TThus x and y are "EQ, but not EQUAL" [which only makes sense whenthey refer to the same object at different points in time]; however,the EQ/EQL-type table is not affected by this.Rationale:The performance expectations about hash-tables, and consequent implementational constraints, need to be formalized.Current practice:Every implementation that the proposer has tried *seems* to satisfythese constraints.Cost to Implementors:None.Cost to Users:None.Cost of non-adoption:Continuing confusion as to what is stable in EQ/EQL tables, and whatis stable in EQUAL tables.  Possible confusion when it comes toimplementing EQUALP tables.Performance impact:N.A.Benefits:See Cost of non-adoption.Esthetics:The proposal more closely relates the term "Hash Table" to theclassic use of it in  "The Art of Computer Programming", vol 3.Discussion:One of the attractions to Common Lisp is that many common techniques area required part of the language; C programmers who continue to re-inventhasing techniques over and over have praised CL in particular for hashtables.  After all, it is much more likely that efficient, correctlycoded algorithms will be provided by the system supplier than that everycode writer will understand and correctly apply the information foundin Knuth's "The Art of Computer Programming", vol 3.The requirement that the expected number of reprobes be bounded by a "small constant" should not be taken to extreme.  In particular, asimple trade-off of space for time can assure some compliance with it.For example, a data set of size N could be partitioned into N/20subsets; as long as the partitioning function does a fairly good jobof balancing the number of elements in each partition class, and aslong as the partition function can be quickly calculated, then the onecould say that the expected number of probes would be bounded by "abouttwenty or so".  The generally understood meanings of the :rehash-sizeand :rehash-threshold components of hash-tables may be biased towards an "open-addressing" implementation; but "bucketizing" implementationsare not arbitrarily ruled out.  This proposal is in no way intended torule out "bucketizing" implementations of hash tables.Here's an example of how one might analyze the problems relating GC and EQ/EQL type tables:  Date: Mon, 12 Sep 88 11:05 EDT  From: Barry Margolin <barmar@Think.COM>  Subject: MAKE-HASH-TABLE :TEST arg  To: "Steve Bacher (Batchman)" <SEB1525@draper.com>  Cc: common-lisp@sail.stanford.edu  . . .   Various aspects of the behavior of a hash table are dependent upon the  TEST argument.  An EQUAL hash table need not be rehashed after a copying  GC.  The hash function is generally dependent upon the test function;  for an EQUAL hash table it would be SXHASH, while for an EQ hash table  it would probably be a simple hash on the address.  I suppose you COULD use SXHASH for all hash tables, since EQ objects are  necessarily EQUAL, and you COULD rehash ALL hash tables.  Or you could  implement hash tables without actually hashing (e.g. implement them as  alists).  But if performance is an issue (which it generally is when you  use a hash table), you'll probably want to do things dependent on the  test function.						  barmarThis suggestion is not prohibited by CLtL, although it violates thecommonly accepted understanding of what "Hash on EQ" means.!            ----- Additional Comments  -----"This proposal is so long that I got lost while reading it.  From theexamples, one would think it was proposing some rules about what userscan expect when they modify objects that are used as keys of hashtables.  However, I couldn't find anything actually proposed about that.Most of the proposal seems to be about what performance users of hashtables should expect, but I didn't see anything specific enough that Icould write a Common Lisp program to test whether an implementationconforms to the proposal.I think this proposal needs to be shortened and rewritten.  I wouldprefer to see it speak about the behavior a user can or cannot expectfrom a Common Lisp implementation, rather than in terms of internaldetails of how Common Lisp might be implemented.  The essay onimplementation techniques could go in the discussion section, or couldbe published separately, but I don't think it is suitable as a languagespecification.It might be a good idea to break this into two proposals, one on keymodification and a separate one on performance.  The reason I say thatis that I think standardizing performance is extremely difficult, and Iwould hate to see the problems with that sink the other proposal."*start*01089 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 12:15:23 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  12:12:08 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 11:51:07 PSTDate: 12 Dec 88 11:50 PSTFrom: masinter.paSubject: Re: Issue: HASH-TABLE-KEY-MODIFICATION (and HASH-TABLE-STABILITY)In-reply-to: Jon L White <jonl@lucid.com>'s message of Sat, 10 Dec 88 05:36:37 PSTTo: cl-cleanup@sail.stanford.eduMessage-ID: <881212-115107-4697@Xerox>If it is true that this issue "has already received extensive positivereview within Lucid; and has received some very positive review outside", Ihave not seen those reviews. I did see a piece of a message from Jeff Dalton included in your responseto him, but I'm missing his original message. I presume that they were notmailed to cl-cleanup.The only review I have is Moon's, which is fairly critical.Against my judgement, I will release this version.*start*00772 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 NOV 88 00:23:21 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 18 Nov 88  00:21:50 PSTReceived: from relay2.cs.net by RELAY.CS.NET id aa17890; 18 Nov 88 0:55 ESTReceived: from draper.com by RELAY.CS.NET id ad02405; 17 Nov 88 15:51 ESTDate: Thu, 17 Nov 88 09:18 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue HASH-TABLE-STABILITYTo: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525Concerning "EQ but not EQUAL"... Is a CL implementation in error if it implements EQUAL by returning T ifthe arguments are EQ, as a performance hack?*start*01010 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 18 NOV 88 03:54:53 PSTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 18 Nov 88  03:53:10 PSTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa05167; 17 Nov 88 16:52 GMTDate: Thu, 17 Nov 88 17:17:09 GMTMessage-Id: <17889.8811171717@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: HASH-TABLE-STABILITY (version 1)To: Jon L White <@sail.stanford.edu:jonl@lucid.com>, cl-cleanup@sail.stanford.eduIn-Reply-To: Jon L White's message of Mon, 14 Nov 88 23:14:43 PSTWell said.  I can think of one "problem": you have specified theconstraints relating the :test and the key transformation so wellthat it no longer seems reasonable that users are not able to providetheir own :test and key transformation.-- Jeff*start*02681 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 15 DEC 88 13:58:06 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00508g; Thu, 15 Dec 88 13:55:44 PSTReceived: by bhopal id AA19863g; Thu, 15 Dec 88 13:57:41 PSTDate: Thu, 15 Dec 88 13:57:41 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812152157.AA19863@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 12 Dec 88 11:50 PST <881212-115107-4697@Xerox>Subject: Issue: HASH-TABLE-KEY-MODIFICATION (and HASH-TABLE-STABILITY)re: I did see a piece of a message from Jeff Dalton included in your response    to him, but I'm missing his original message. I presume that they were not    mailed to cl-cleanup.Both of Jeff's comments were CC'd to cl-cleanup.  Since you included Moon'snegative comments in the mailing to x3j13, shouldn't Jeff's comments beincluded too?  Date: Thu, 17 Nov 88 17:17:09 GMT  From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>  Subject: Re: Issue: HASH-TABLE-STABILITY (version 1)  To: Jon L White <@sail.stanford.edu:jonl@lucid.com>,	  cl-cleanup@sail.stanford.edu  In-Reply-To: Jon L White's message of Mon, 14 Nov 88 23:14:43 PST  Well said.  I can think of one "problem": you have specified the  constraints relating the :test and the key transformation so well  that it no longer seems reasonable that users are not able to provide  their own :test and key transformation.  -- Jeff  Date: Sat, 19 Nov 88 21:35:47 GMT  From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>  Subject: Re: Issue: HASH-TABLE-STABILITY (version 1)  To: jonl <@sail.stanford.edu:jonl@lucid.com>, cl-cleanup@sail.stanford.edu  In-Reply-To: Jon L White's message of Fri, 18 Nov 88 15:19:52 PST  > re: Well said.  I can think of one "problem": you have specified the  >     constraints relating the :test and the key transformation so well  >     that it no longer seems reasonable that users are not able to provide  >     their own :test and key transformation.  >   > That would be superb, if Joe Random User were able to understand this  > "clarification".  I agree that that may be the only thing lacking for   > fully extensible hash-tables.  There are many things in Lisp that users may not understand initially  and so may get wrong.  I don't think that's necessarily a good reason  to keep something out of the language.  (And if it were, there are  parts of CLOS, SETF, and packages that we would want clean out.)  BTW, Pop11 allows user-specified test and hash (key transform)  functions.  -- Jeff*start*00904 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 15:24:46 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 2 Jan 89  15:24:26 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 02 JAN 89 15:21:01 PSTDate: 2 Jan 89 15:20 PSTSender: masinter.paSubject: re: Issue: HASH-TABLE-STABILITY (Version 1)To: cl-cleanup@sail.stanford.eduFrom: Kim A. Barrett <IIM@ECLA.USC.EDU>Message-ID: <890102-152101-1732@Xerox>There is a minor glitch in an aside that needs to be fixed.  Paragraph 3 ofitem 3 says that the following code would be acceptable as the <sxh> functionfor EQL tables:  (if (numberp x) (sxhash x) (%unique-no x))In general, the NUMBERP test really should be (OR (NUMBERP X) (CHARACTERP X)),to correspond properly to the definition of EQL.*start*01231 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 JAN 89 01:03:44 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 4 Jan 89  01:03:11 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04034g; Wed, 4 Jan 89 00:59:24 PSTReceived: by bhopal id AA01426g; Wed, 4 Jan 89 01:01:36 PSTDate: Wed, 4 Jan 89 01:01:36 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901040901.AA01426@bhopal>To: IIM@ECLA.USC.EDUCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Kim A. Barrett's message of 2 Jan 89 15:20 PST <890102-152101-1732@Xerox>Subject: Issue: HASH-TABLE-STABILITY (Version 1)re:   (if (numberp x) (sxhash x) (%unique-no x))    the NUMBERP test really should be (OR (NUMBERP X) (CHARACTERP X)), ...Ooops, right.  Thanks for noticing it.I've also noticed a bit of inconsistency in the use of the term"key transformation".  The "terminology" section mentions twovariant meanings for the term, but I'd prefer now to see it mademore rigorous; perhaps "hash function" could be used for the variant which is typically dependent on the table size.-- JonL --