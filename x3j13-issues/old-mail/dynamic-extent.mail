*start*01743 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 27 Jun 88 13:14Subject: Re: Issue: STACK-LET (Version 1)In-Reply-to: Your message of Mon, 27 Jun 88 14:37:00 -0400.             <880627143734.6.KMP@RIO-DE-JANEIRO.SCRC.SFrom: Scott.Fahlman%B.GP.CS.CMU:EDU:XeroxTo: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: Common-Lisp%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: Common-Lisp@SAIL.Stanford.EDUSubject: Re: Issue: STACK-LET (Version 1)In-reply-to: Your message of Mon, 27 Jun 88 14:37:00 -0400.             <880627143734.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>From: Scott.Fahlman@B.GP.CS.CMU.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 27 JUN 88 13:14:31 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 27 Jun 88  12:42:12 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU; 27 Jun 88 15:40:52 EDTOriginal-Date: Mon, 27 Jun 88 15:40:27 EDTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIs there any reason, aside from compatibility with the current Symbolicsusage, why you prefer(stack-let ((x (list a b c))) ...body ...)to(let ((x (list a b c)))  (declare (dynamic-value x))  ... body )Since the idea is to give advice to the compiler about a specific binding,it seems to me that a declaration would be more consistent with the rest ofthe language than a new special form.  For example, that's how we handleadvice about type restrictions.  Also, this would allow one to mix dynamicand non-dynamic bindings in the same LET form.-- Scott*start*04191 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 27 Jun 88 13:53From: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Re: Issue: STACK-LET (Version 1)In-Reply-to: The message of 27 Jun 88 15:40 EDT from Scott.Fahlman@B.GP.CS.CMU.EDUTo: Scott.Fahlman%B.GP.CS.CMU:EDU:Xeroxcc: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xerox, Common-Lisp%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: STACK-LET (Version 1)To: Scott.Fahlman@B.GP.CS.CMU.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Common-Lisp@SAIL.Stanford.EDUIn-Reply-To: The message of 27 Jun 88 15:40 EDT from Scott.Fahlman@B.GP.CS.CMU.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 27 JUN 88 13:53:41 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Jun 88  13:05:55 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 425412; Mon 27-Jun-88 16:04:37 EDTOriginal-Date: Mon, 27 Jun 88 16:04 EDTMessage-ID: <880627160423.1.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon, 27 Jun 88 15:40:27 EDT    From: Scott.Fahlman@B.GP.CS.CMU.EDU    Is there any reason, aside from compatibility with the current Symbolics    usage,Moon has our vote, not me. I usually leave it to him to evaluate what is goodor bad for Symbolics as a company. The extent to which Symbolics usage plays intothis is neither more or less than the extent to which any company offering thisprimitive plays into this.    why you prefer    (stack-let ((x (list a b c))) ...body ...)    to    (let ((x (list a b c)))      (declare (dynamic-value x))      ... body )    Since the idea is to give advice to the compiler about a specific binding,    it seems to me that a declaration would be more consistent with the rest of    the language than a new special form.  For example, that's how we handle    advice about type restrictions.  Also, this would allow one to mix dynamic    and non-dynamic bindings in the same LET form.    -- ScottNo really big reason. A couple of little reasons. * In implementations where a related facility (eg, Zetalisp's older   WITH-STACK-LIST and WITH-STACK-LIST* primitives) exists, it's easy to   write a macro to translate STACK-LET into the other stuff. Whether it's   easy to add a declaration depends on how declarations are implemented. * Since some implementations provide STACK-LET and not the modified LET, I   thought I'd get stronger support from people who do provide it. People   always seem to be more likely to vote for things that involve the least   work on their own part. * I was afraid that some people would see this as a hairing up of LET.   In retrospect, however, I guess you're right. It could be useful for   DO, PROG, etc. if you had the declaration. Note well, however, that it's   not useful for any case where the construction form is not lexically   apparent to the binding form. Eg,     (DEFUN F (X) (DECLARE (DYNAMIC-EXTENT X)) ...)   would violate modularity boundaries to optimize    (F (LIST 1 2 3))   although I suppose some argument could be made that in block compilation   it was ok. By putting it in a STACK-LET form, this issue is made to not   come up. * I sometimes get more results by suggesting something overly conservative   and letting people suggest that it's not right or not enough than I do by   suggesting originally the thing in full blown form. The latter strategy   often gets me not taken seriously, whereas the first strategy offers a   foot in the door to people who readily grasp the concepts of the stripped   down proposal and who might after admitting the topic for discussion still   arrive at the same position as I'd have originally wanted to propose.In fact, the modified LET is fine with me. My main criterion is to havesomething which has the highest likelihood of a yes vote in X3J13.*start*02079 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 27 Jun 88 14:21From: jrose%Sun:COM:XeroxIn-Reply-to: Kent M Pitman's message of Mon, 27 Jun 88 14:37 EDT <880627143734.6.KMP@RIO-DE-JANEIRO.SCRC.SymbolicSubject: Issue: STACK-LET (Version 1)To: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: Common-Lisp%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: jrose@Sun.COM (John Rose)To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: Common-Lisp@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Mon, 27 Jun 88 14:37 EDT <880627143734.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Subject: Issue: STACK-LET (Version 1)Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 27 JUN 88 14:20:56 PDTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 27 Jun 88  13:38:24 PDTReceived: from snail.sun.com by Sun.COM (4.0/SMI-4.0)	id AA01974; Mon, 27 Jun 88 13:36:34 PDTReceived: from lukasiewicz.sun.com by snail.sun.com (4.0/SMI-3.2)	id AA28150; Mon, 27 Jun 88 13:32:21 PDTReceived: by lukasiewicz.sun.com (4.0/SMI-4.0)	id AA21955; Mon, 27 Jun 88 13:38:40 PDTOriginal-Date: Mon, 27 Jun 88 13:38:40 PDTMessage-Id: <8806272038.AA21955@lukasiewicz.sun.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV ...       It is always permissible for STACK-LET to behave like LET.       Its use is merely advice to an implementation about the use       of a variable which might not otherwise be provable. ...  It would also be possible to unify this proposal with  REST-ARGUMENT-EXTENT. The technique would be to allow   (LET ((X (LIST ...)))     (DECLARE (DYNAMIC-EXTENT X))     ...)  to be rewritten by the compiler as:   (SYSTEM::STACK-LET ((X (LIST ...)))     ...)  for example.The DYNAMIC-EXTENT declaration is a smaller, cleaner additionthan a new STACK-LET special form.It's less of a burden on implementors and users to ignore a declarationthan to expand one special form into another.				-- John*start*01906 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 29 Jun 88 00:02From: edsel!jonl%labrea.stanford:EDU:XeroxIn-Reply-to: John Rose's message of Mon, 27 Jun 88 13:38:40 PDT <8806272038.AA21955@lukasiewicz.sun.com>Subject: Issue: STACK-LET (Version 1)To: jrose%sun:COM:Xeroxcc: Common-Lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.stanford.edu>To: jrose@sun.comCc: Common-Lisp@sail.stanford.eduIn-Reply-To: John Rose's message of Mon, 27 Jun 88 13:38:40 PDT <8806272038.AA21955@lukasiewicz.sun.com>Subject: Issue: STACK-LET (Version 1)Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 29 JUN 88 00:02:39 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 28 Jun 88  22:39:48 PDTReceived: by labrea.stanford.edu; Tue, 28 Jun 88 22:39:17 PDTReceived: from bhopal.lucid.com by edsel id AA10285g; Tue, 28 Jun 88 22:24:31 PDTReceived: by bhopal id AA11440g; Tue, 28 Jun 88 22:30:47 PDTOriginal-Date: Tue, 28 Jun 88 22:30:47 PDTMessage-Id: <8806290530.AA11440@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: The DYNAMIC-EXTENT declaration is a smaller, cleaner addition    than a new STACK-LET special form.    It's less of a burden on implementors and users to ignore a declaration    than to expand one special form into another.It was for just such reasons that Lucid chose (about one year ago) to use a DYNAMIC-EXTENT declaration rather than specialized "stack list"primtives, when implementing "stack list consing" for &rest arguments.The suggestion is entertained to extend it to more contexts, such asany LAMBDA-binding (or LET-binding if you must) where the value issomething that would have to be "consed up" afresh.-- JonL --*start*05161 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 27 Jun 88 13:20From: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: STACK-LET (Version 1)To: Common-Lisp%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: STACK-LET (Version 1)To: Common-Lisp@SAIL.Stanford.EDUReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 27 JUN 88 13:20:15 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Jun 88  11:38:03 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 425330; 27 Jun 88 14:37:47 EDTOriginal-Date: Mon, 27 Jun 88 14:37 EDTMessage-ID: <880627143734.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIssue:          STACK-LETReferences:     NoneCategory:       ADDITIONEdit history:   27-Jun-88, Version 1 by PitmanRelated-Issues: REST-ARGUMENT-EXTENTStatus:	        For Internal DiscussionProblem Description:  Sometimes a programmers knows that a particular data structure  will have only dynamic extent. In some implementations, it is  possible to allocate such structures in a way that will make them  easier to reclaim than by general purpose garbage collection  (eg, on the stack or in some temporary area). Currently, however,  there is no way to request the use of such an allocation mechanism.Proposal (STACK-LET:NEW-MACROS):  Introduce the new macros:   STACK-LET  bindings &BODY forms			[Macro]   STACK-LET* bindings &BODY forms			[Macro]    Like LET and LET*, but the objects which are the initial    values of the variables in the binding list have only    dynamic extent.    For each initial binding, the form is macroexpanded (as if    by MACROEXPAND-1) until either no further macro expansion is    possible or a form which is recognized by STACK-LET is seen.    For example:    (CONS x y) permits STACK-LET to allocate a cons on the stack.    (LIST x y z) permits STACK-LET to allocate a list on the stack.    (LIST* x y z) permits the first two conses of the resulting    list to be allocated on the stack.    (MAKE-ARRAY ...) permits an array to be allocated on the stack.    (MAKE-xxx ...) where MAKE-xxx is a defstruct constructor permits    the structure type to be allocated on the stack.    Note that an initial value form of (LIST X Y) is not the same    as (CONS X (LIST Y)) since STACK-LET may arrange for two cells    of the former to be stack-allocated, and only one cell of the    latter (the one created by CONS).     Note further that in (LIST (LIST 1 2) 3), only the top level    list (the one containing a cons and 3) may be stack allocated.    The list (1 2) must be allocated normally.    It is always permissible for STACK-LET to behave like LET.    Its use is merely advice to an implementation about the use    of a variable which might not otherwise be provable.Test Case:  (STACK-LET ((X (LIST 1 2 3)))    (PRINT X)    NIL)  prints (1 2 3)Rationale:  It permits a programmer to offer advice to an implementation about  what may be stack-allocated for efficiency.  It may be difficult or impossible for a compiler to infer this  same information statically.  Since a number of implementations offer this capability and there  is demand from users for access to the capability, this ``codifies  existing practice.''Current Practice:  Symbolics Genera and Symbolics Cloe offer this extension.Cost to Implementors:  No cost is forced since implementations are permitted to treat  STACK-LET and STACK-LET* as LET and LET*, respectively.Cost to Users:  None. This change is upward compatible.Cost of Non-Adoption:  Some portable code would be forced to run more slowly (due to  GC overhead), or to use non-portable primitives.Benefits:  The cost of non-adoption is avoided.Aesthetics:  This primitive allows a fairly low level optimization to work  by asking the user to provide only very high level information.  The alternatives (sharpsign conditionals, some of which may  lead to more bit-picky abstractions) are far less aesthetic.Discussion:  It would also be possible to unify this proposal with  REST-ARGUMENT-EXTENT. The technique would be to allow   (LET ((X (LIST ...)))     (DECLARE (DYNAMIC-EXTENT X))     ...)  to be rewritten by the compiler as:   (SYSTEM::STACK-LET ((X (LIST ...)))     ...)  for example.  Pitman supports the STACK-LET:NEW-MACROS.  A better name might be chosen, but since some existing dialects  use this name, the name STACK-LET was suggested in an attempt to  not be gratuitously incompatible. (Also, the name DYNAMIC-LET,  which might seem more intuitive, is in use in other dialects to  mean that a dynamic variable is being bound, not that a lexical  variable is being bound to a dynamic object. It might, therefore,  be confusing to recycle that name here.)*start*01634 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  1 Jul 88 01:02Subject: Re: Issue: STACK-LET (Version 1)From: masinter:PARC:XeroxIn-Reply-to: KMP%STONY-BROOK.SCRC.Symbolics:COM's message of Monday, June 27, 1988  1:53 pmReply-to: masinter:PARC:XeroxTo: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: Scott.Fahlman%B.GP.CS.CMU:EDU:Xerox, KMP%STONY-BROOK.SCRC.Symbolics:COM:Xerox, Common-Lisp%SAIL.Stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 01 JUL 88 01:02:08 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 30 Jun 88  22:56:21 PDTReceived: from Burger.ms by ArpaGateway.ms ; 30 JUN 88 22:55:28 PDTOriginal-Date: 30 Jun 88 22:54:22 PDT (Thursday)Message-ID: <880630-225528-6029@Xerox>While I would like very much to find some way to express dynamic extent withinthe language, I'm unhappy with either (declare (dynamic-value ...)) or stack-let for two reasons:a) it is disturbing to introduce a construct within which a casual change of(CONS X (LIST Y Z)) to (LIST X Y Z) could introduce a serious bug (e.g., if the tail were stashed awaysomewhere.)b) the construct really only allows dynamic extent on one-level structures . Ifyou wanted tocreate a copy of (A (B C) (D E (F G)))you would have to say something like    (stack-let* ((part2 (list 'b 'c)) (part3c (list 'f 'g)) (part3 (list 'd 'epart3c)) ((whole-thing (list 'a part2 part3))) ...)Your proposal did not mention objects other than lists; what of DEFSTRUCT orCLOS instances?*start*00984 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 01:28:11 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 20 Sep 88  01:27:42 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 20 SEP 88 01:26:21 PDTDate: 20 Sep 88 01:26 PDTFrom: masinter.paSubject: Re: Issue: STACK-LET (Version 1)To: KMP@STONY-BROOK.SCRC.Symbolics.COMcc: cl-cleanup@sail.stanford.eduMessage-ID: <880920-012621-3322@Xerox>This issue (discussed on Common-lisp@sail.stanford.edu instead of cl-cleanup, bymistake?) has had no discussion since July 1. I don't think the issue isSTACK-LET but some kind of DYNAMIC-EXTENT-VALUES if we don't want to prejudicethe issue to a specific proposal.This should certainly remain an active issue at some level, but I think thecurrent proposal is not adequate.Is it useful to bring it up to X3J13 in its current form?*start*04497 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 OCT 88 12:20:29 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 14 Oct 88  12:17:24 PDTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Fri, 14 Oct 88 15:00:58 EDTReceived: from OCCAM.THINK.COM by sauron.think.com; Fri, 14 Oct 88 15:15:52 EDTDate: Fri, 14 Oct 88 15:16 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: WITH-DYNAMIC-EXTENTTo: cl-cleanup@sail.stanford.eduMessage-Id: <19881014191630.0.BARMAR@OCCAM.THINK.COM>I just read the WITH-DYNAMIC-EXTENT proposal in CLtC-2 (Common Lisp: theCleanup Part 2), and I don't like it.  The problem, which is almosttouched on in the Discussion section, is that there may be some consinggoing on that the user isn't aware of, and which is required to be ofindefinite extent.  I don't think a vendor who allows programmers tospecify that their objects should have dynamic extent should be forcedto go through their entire system and find all the places whereWITH-INDEFINITE-EXTENT should be added; I wouldn't trust them to be ableto find all of them (I don't think it's a mechanizable process).I agree that some mechanism for this purpose should be provided.However, I would prefer a mechanism that is a little more careful thanthe current proposal.  Within a WITH-DYNAMIC-EXTENT form, a programshould have to explicitly indicate which objects should have dynamicextent.  Something like:(defun and-and-multiply (a b)  (with-dynamic-extent ()    (let ((x (dynamic (list a b)))	  (y (cons nil nil)))      (setf (car y) (apply #'+ x)	    (cdr y) (apply #'* x))      y)))Here is the full description of my WITH-DYNAMIC-EXTENT and DYNAMICforms.  Please bear in mind that I just designed these now, and haven'tthought about them a great deal.WITH-DYNAMIC-EXTENT			Macro(WITH-DYNAMIC-EXTENT (&optional (INDICATOR NIL)) &body BODY)This declares a contour during which the program may allocate objectswhose extent is specified to be within the dynamic lifetime of thisform [this wording is horrible, but you know what I mean].  To specifywhich objects may be reclaimed when exiting this form, use the DYNAMICmacro with a matching indicator.INDICATOR is not evaluated.  BODY is evaluated as an implicit PROGN.Value: the values of the last form of the body.----------DYNAMIC					Macro(DYNAMIC FORM &optional (INDICATOR NIL))The return values of FORM are specified to have the dynamic extent ofthe most recent WITH-DYNAMIC-EXTENT form with a matching indicator.FORM is evaluated, INDICATOR is not evaluated.If a return value of this form is assigned to a place that is accessedonce the matching WITH-DYNAMIC-EXTENT form is exited, or if this valueis used as the return value of the WITH-DYNAMIC-EXTENT form or oneoutside the WITH-DYNAMIC-EXTENT form (e.g. as the value in a throw to anenclosing catch), the results are undefined.Value: the values of FORM.----------An advantage of the WITH-DYNAMIC-EXTENT in the CLtC-2 proposal is thatit gives the application programmer some control over the internalconsing done by system and/or library routines.  However, I think itshould be the vendors' responsibility to make sure that these don't consany more than is necessary, if that is a concern of their customers.  Idon't think we should be providing a mechanism that allows developers tocontrol "behind the back" consing; it should only allow them explicitcontrol over the objects that they know about.I made the indicators unevaluated because I was first thinking that thiswould be a purely lexical facility.  Since I dropped that idea, it mightbe appropriate to make the indicators be evaluated.I am not wedded to the name DYNAMIC for the second operator.  PerhapsDYNAMIC-VALUE would be better.One problem with my version is that it doesn't provide a way to markobjects that are bound to variables by macros as dynamic.  For example,in a WITH-OPEN-FILE form, the OPEN form is not explicit, so it isn'tpossible to wrap DYNAMIC around it.  The programmer would have to useWITH-OPEN-STREAM in order to expose the OPEN call.  (On the other hand,in most such cases it probably would be OK for the implementation ofsuch macros to allocate the objects dynamically, so the programmerwouldn't need to).                                                barmar*start*01235 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:39:06 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:39:18 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475827; Thu 13-Oct-88 16:37:55 EDTDate: Thu, 13 Oct 88 16:37 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENT (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013163747.4.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Issue names STACK-LET, DYNAMIC-VALUE, and DYNAMIC-VALUE-EXTENT are obsolete synonyms for this issue. This issue is related to, but very different than, issue WITH-DYNAMIC-EXTENT. KMP will write this up, removing the STACK-LET proposal in favor of something declaration-based.X3J13 meeting: Masinter: This issue is related to the ISO proposal for multiple  	   values and rest arguments. KMP: Perhaps this should be mentioned in Current Practice or Discussion      of writeup.*start*00951 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 14 OCT 88 10:57:48 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476546; Fri 14-Oct-88 13:57:46 EDTDate: Fri, 14 Oct 88 13:57 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENT (Version 1)To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Masinter.pacc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881013163747.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19881014175733.9.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Thu, 13 Oct 88 16:37 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>     Masinter: This issue is related to the ISO proposal for multiple	       values and rest arguments.I haven't seen that proposal, how does one obtain it?*start*11774 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 NOV 88 13:11:24 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Nov 88  13:09:00 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 492913; Tue 15-Nov-88 16:08:59 ESTDate: Tue, 15 Nov 88 16:08 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: WITH-DYNAMIC-EXTENT (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881115160845.4.KMP@BOBOLINK.SCRC.Symbolics.COM>I got tired of having this lone piece of paper sitting on my desk with noelectronic version, so finally typed it in. Please encourage people whosubmit hardcopy cleanup items to follow them up with electronic mail!Please don't take my having done the typing as an endorsement; my commentarywill come under separate cover. -kmp-----Issue:	      WITH-DYNAMIC-EXTENTReferences:   CLtL p. 39, p. 162Category:     ENHANCEMENTEdit History: 9-Oct-88, Version 1 by Jim AllardProblem Description:Users of Common Lisp cannot write programs which explicitly perform theirown memory management and do not rely on a garbage collector.Proposal:Introduce two new macros: WITH-DYNAMIC-EXTENT and WITH-INDEFINITE-EXTENT.Add to the end of chapter 9, p. 162, the new section "Extent Declarations"."By default, data objects within Common Lisp programs have indefinite extentand so continue to exist as long as a possibility of reference to them exists.Implementations are free to reclaim (garbage collect) any objects for which itcan be proven that no possible references exist. The following macros provideprogrammers the ability to declare extra information about the extent of dataobjects.	with-dynamic-extent {form}*The forms of the body are executed as an implicit PROGN and the values of thelast form in the body are returned. This macro declares that the objectscreated within the dynamic extent of the body forms (but which are not furthernested within WITH-INDEFINITE-EXTENT forms) have dynamic extent, and may bereclaimed on exit from this form. Note that the extent of any object createdwithin the dynamic extent of a further nested WITH-DYNAMIC-EXTENT form isdetermined by the deepest nested call. This macro represents a guarantee by theprogrammer that no objects created within the body will be referenced outside ofthe body. The behavior of a reference to one of these objects outside thedynamic extent is undefined.	with-indefinite-extent {form}*The forms of the body are executed as an implicit PROGN and the values of thelast form in the body are returned. This macro declares that the objectscreated within the dynamic extent of the body forms (but which are not furthernested within WITH-DYNAMIC-EXTENT forms) have indefinite extent, and so may onlybe reclaimed when it can be proven that no references exist to these objects.This is the default behavior."Add to p.39 after "The important scope and extent rules of Common Lisp follow:""* Data objects have indefinite extent, except when created within the dynamicextent of a WITH-DYNAMIC-EXTENT form, in which case they may have dynamicextent."Rationale:Lisp has always had automatic memory management as one of its features,shielding the programmer from issues of memory usage and reclamation andtreating the machine as an abstraction. Several sophisticated garbage collectiontechniques have been developed which lessen the impact of memory management onperformance. However, the wait times and larger memory requirements imposed bygarbage collection in most implementations of Lisp are still two of the biggestpractical problems faced when fielding Lisp programs. The problem becomes evenmore serious when attempting to write real-time applications in Lisp.Most widely used computer languages today require programmers to managetheir own data structures. In Common Lisp this is not currentlypossible, since implementations are free to cons and discard objects atwill. This is especially true of the arithmetic functions. Mostimplementations happen to be good about not unnecessarily consing, andwith careful use of a subset of Common Lisp, one can resource manage allobjects other than numbers. With the addition of these two macros andmutation operations for the required subtypes of number, it becomespossible to write garbage-free Lisp code.Even in those applications where all garbage will not be eliminated,optimization of specific parts of a program which are known to be producers oflarge temporary data structures can greatly increase overall performance.Current Practice:Many vendors currently supply some form of facility which will reclaim allocatedmemory outside of normal garbage collection. On Lisp machines, the temporaryare facility provides the ability to clear a region of memory on command. Somevendors of Lisps for conventional architectures have produced the above facilityfor customers who have requested it.  Some vendors have used it themselves intheir own compiler programs.  The response to this problem in general has beento improve garbage collector performance rather than provide facilities toreduce or eliminate the need for them. Users of Common Lisp have eitherresigned themselves to the performance needs of the garbage collector, havetried to tailor their garbage creation patterns to best fit the existing garbagecollector, or have ported to other languages, such as C, which support explicitmemory management. This facility would be an added tool for the secondapproach, tailoring garbage creation patterns.Adoption Cost:Since the facility is a declaration, Common Lisp vendors may choose to notimplement any portion of this facility, and have the macros expand as PROGNs.Vendors also have the choice of determining which types of Lisp objectscould have dynamic extent. Those vendors who already have an areas-likefacility would not have significant additional work to do in the objectallocation facilities. If a system depends upon keeping objects of differenttypes within different pages, then the task is somewhat complicated, but mostvendors can use an implementation where dynamic extent objects are allocatedinto a special region of memory whose allocation pointer is reset on exit fromWITH-DYNAMIC-EXTENT back to where it was on entry to the form. Garbagecollectors may have to be modified to scan this region for pointers, but shouldnot evacuate it. Vendors will also have to evaluate how each type with dynamicextent would affect other facilities in the system. See the discussion for moredetails.Benefits:This facility allows programmers to exert greater control over the garbagecreation properties of their programs. Though automatic memory management isone of the nicest facilities for programmers in Lisp, the performance penalty ofgarbage collection is one of the biggest barriers to end user acceptance of Lispprograms. Though improvements have been made in garbage collector technology inthe 80's, not all vendors will be able to adopt these techniques, and not allapplication programmers will be able to accept even the modest loss ofperformance imposed by modern garbage collection methods. The reclamation ofgarbage objects at or near the source of their creation makes it possible toreduce or eliminate this problem.Conversion Cost:Since this is a new facility, no currently existing Common Lisp code would beaffected.Aesthetics:Questionable. Though the facility fits well as an added type of extent for Lispobjects, it can be rightly criticized as a dangerous facility when usedincorrectly. However, it does directly address a problem of garbage creation inan efficient and consistent manner. This facility can cause data corruption inmuch the same way as an incorrect type declaration. Though we do not want tooffer users invitations to hang themselves, we also do not need to treat themlike children.Discussion:This facility needs to be discussed in terms of the CLtL functions which mutatedata structures or cache consed data and depend on those values later on. Theproblems which can arise here should be addressed per implementation by choosingwhich types of objects may have dynamic extent, and choosing which operationsshould signal errors when performed within a dynamic extent context.The facilities for which this system does not have an obvious meaning are thefollowing: hash table mutation, readtable mutation, package mutation, streamoperations, random number generation, error signalling, and defining forms whichhave side effect upon the environment. The following example illustrates theproblems which can arise in given facilities.Say we have an implementation where streams and strings are allowed to havedynamic extent. A user wishes to write a program which reads and processesfiles. The user wants the file access portion of the program to not creategarbage and not require large amounts of memory. The user's program takes onthe following structure.(defun process-file (pathname)  (with-dynamic-extent    (with-open-file (input pathname)      (block read-file	(loop	  (with-dynamic-extent	    (let ((line? (read-line input nil nil)))	      (if (null line?) (return-from read-file nil))	      (with-indefinite-extent		;; Process this line		))))))))In PROCESS-THIS-FILE the user wants the extent of the stream in INPUT to bebounded within the outermost call to WITH-DYNAMIC-EXTENT. The extent of eachline of the file should be bounded within each pass through the body of theLOOP.Where this program could run into problems is within the call to READ-LINE. Ifthe stream object is mutated such that a pointer is maintained to an objectcreated within the call to READ-LINE, and that created object has dynamicextent, then on exit from WITH-DYNAMIC-EXTENT in the body of this loop thestream will have been corrupted.Several approaches may be taken within an implementation to address thisproblem. READ-LINE (and other stream mutation operations) could be written toperform its mutations so that no objects with dynamic extent are created. Thiscould be done by using data which is immediate, such as immediate fixnums forcurrent-position-in-file counters. The portions of READ-LINE which could createsuch objects, such as input buffer creation code, could themselves be wrappedwith WITH-INDEFINITE-EXTENT forms and allow these objects to be subject togarbage collection. Another approach is to resource manage any supplementalstructures, again wrapping the creation point with WITH-INDEFINITE-EXTENT, butrecycling these objects for reuse on stream close such that no actual garbage iscreated.Another approach for an implementation is to declare that the use of READ-LINE,or any other system object mutating function, within a dynamic extent contextshould be an error.The point of the facility is to allow implementations to provide some means forusers to more explicitly manage memory requirements within an application. Thechoice of which facilities should be affected and how smoothly it shouldintegrate with the rest of the system is up to each vendor. Defining thefacility in this way means that programs which use it will have to be tailoredto work within different Lisp implementation, as is the case now with producingexecutable program images. However, the inclusion of these forms in thelanguage does present implementors with an invitation to provide their userswith some method of memory use optimization, which is sorely needed.*start*09565 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 NOV 88 13:18:48 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Nov 88  13:15:03 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 492918; Tue 15-Nov-88 16:15:07 ESTDate: Tue, 15 Nov 88 16:14 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENT (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881115161453.5.KMP@BOBOLINK.SCRC.Symbolics.COM>For those who don't remember, this issue used to be called STACK-LET.There was opposition to STACK-LET and STACK-LET* with people seemingto prefer a DYNAMIC-EXTENT declaration. This is that rewrite.-----Issue:          DYNAMIC-EXTENTReferences:     NoneCategory:       ADDITIONEdit history:   27-Jun-88, Version 1 by Pitman (as issue STACK-LET)		15-Nov-88, Version 2 by Pitman (issue renamed, major revision)Related-Issues: REST-ARGUMENT-EXTENT, WITH-DYNAMIC-EXTENTStatus:	        For Internal DiscussionProblem Description:  Sometimes a programmers knows that a particular data structure  will have only dynamic extent. In some implementations, it is  possible to allocate such structures in a way that will make them  easier to reclaim than by general purpose garbage collection  (eg, on the stack or in some temporary area). Currently, however,  there is no way to request the use of such an allocation mechanism.Proposal (DYNAMIC-EXTENT:NEW-DECLARATION):  Introduce a new declaration called DYNAMIC-EXTENT. The arguments to  this declaration are names of variables. The declaration asserts that  the value which is initially held by the indicated variable will have  dynamic extent. [In the case of an iteration variable, the declaration  asserts that on every iteration, the initial value of that variable  for the iteration will have dynamic extent.]  It is permissible for an implementation to simply ignore this declaration.  In implementations which do not ignore it, the compiler (or interpreter)  is free to make whatever optimizations are appropriate given this  information; the most common optimization is to stack-allocate the  initial value of the object.  Since stack allocation of the initial value entails knowing at the  object's creation time that the object can be stack-allocated, it is  not generally useful to declare DYNAMIC-EXTENT for variables for  which have no lexically apparent initial value. For example,	(DEFUN F ()	  (LET ((X (LIST 1 2 3)))	    (DECLARE (DYNAMIC-EXTENT X))	    ...))  would permit those compilers which wish to do so to stack-allocate the  list in X. However,	(DEFUN G (X) (DECLARE (DYNAMIC-EXTENT X)) ...)	(DEFUN F () (G (LIST 1 2 3)))  could not typically permit a similar optimization in G because it would  be a modularity violation for the compiler to assume facts about G from  within F. Only an implementation which was willing to be responsible for  recompiling F if G's definition changed incompatibly could stack-allocate  the list argument to G in F.  Other interesting cases are:	(PROCLAIM '(INLINE G))	(DEFUN G (X) (DECLARE (DYNAMIC-EXTENT X)) ...)	(DEFUN F () (F (LIST 1 2 3)))    and	(DEFUN F ()	  (FLET ((G (X) (DECLARE (DYNAMIC-EXTENT X)) ...))	    (G (LIST 1 2 3))))  where some compilers might realize the optimization was possible and others  might not.  An interesting variant of this is the so-called `stack allocated rest list'  which can be achieved (in implementations supporting the optimization) by:	(DEFUN F (&REST X)	  (DECLARE (DYNAMIC-EXTENT X))	  ...)  Note here that although the initial value of X is not explicit, the F  function is responsible for assembling the list X from the passed arguments,  so the F function can be optimized by the compiler to construct a   stack-allocated list instead of a heap-allocated list in implementations  which support such.  What data types (if any) can be stack-allocated will vary from  implementation to implementation. In some implementations, it might be  possible to allocate arrays, structures, or instances, for example.  It is very important to note that it is the actual constructor operation  and not the resulting data type which determines the level of the object  referred to in the dynamic extent declaration. For example, in	(LET ((X (LIST 'A1 'B1 'C1))	      (Y (CONS 'A2 (CONS 'B2 (CONS 'C2 NIL)))))	  (DECLARE (DYNAMIC-EXTENT X Y))	  ...)  The list (A1 B1 C1) which is the initial value of X will have three cons  cells, all of which have dynamic extent. The cons (A2 . (B2 C2)) which is  the initial value of Y will have dynamic extent, but its cdr (B2 C2) will  have indefinite extent. As such, (CDR X) is not an appropriate return  value from the above LET, but (CDR Y) is an appropriate return value.  Further, in 	(LET ((X (LIST 'A 'B (LIST 'C 'D))))	  (DECLARE (DYNAMIC-EXTENT X))	  ...)  the three conses (A . <cons-cell>), (B . <cons-cell>), and   (<cons-cell> . NIL) are said to have dynamic extent, but the list (C D)  has indefinite extent. To declare the entire structure to have dynamic  extent, one must write something like:	(LET* ((TEMP (LIST 'C 'D))	       (X (LIST 'A 'B TEMP)))	  (DECLARE (DYNAMIC-EXTENT X TEMP))	  ...)  If an implementation does not recognize the constructor, it calls  MACROEXPAND-1 in hopes of seeing a constructor which it does recognize.  It iterates this process until it either sees a constructor which it  does recognize, or until no macro expansion is possible. If it is unable  to recognize the constructor, it must treat the object as if it had  indefinite extent.Test Case:  (LET ((X (LIST 1 2 3)))    (DECLARE (DYNAMIC-EXTENT X))    (PRINT X)    NIL)  prints (1 2 3)  (DO ((L (LIST-ALL-PACKAGES) (CDR L)))      ((NULL L))    (DECLARE (DYNAMIC-EXTENT L))    (PRINT (CAR L)))  prints all packages  (DEFUN ADD (&REST X) (DECLARE (DYNAMIC-EXTENT X)) (APPLY #'+ X))  (ADD 1 2 3) => 6  (DEFUN ZAP (X Y Z)    (DO ((L (LIST X Y Z) (CDR L)))	((NULL L))      (DECLARE (DYNAMIC-EXTENT L))      (PRIN1 (CAR L))))  (ZAP 1 2 3)  prints 123  (DEFUN ZAP (N M)    ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).    ;; It may be slow, but with a good compiler at least it    ;; doesn't waste much heap storage.  :-)    (LET ((A (MAKE-ARRAY N)))      (DECLARE (DYNAMIC-EXTENT A))      (DOTIMES (I N) 	(DECLARE (DYNAMIC-EXTENT I))	(SETF (AREF A I) (RANDOM (+ I 1))))      (AREF A M)))  (< (ZAP 5 3) 3) => TRationale:  This permits a programmer to offer advice to an implementation about  what may be stack-allocated for efficiency.  It may be difficult or impossible for a compiler to infer this  same information statically.  Since a number of implementations offer this capability and there  is demand from users for access to the capability, this ``codifies  existing practice.''  Because this approach is purely lexical, it does not interact badly with  other programs in the way that the macro WITH-DYNAMIC-EXTENT (see issue  by same name) would.Current Practice:  Symbolics Genera and Symbolics Cloe offer stack allocation, though not  in this strategy.  [KMP thinks that] Lucid supports the proposal.Cost to Implementors:  No cost is forced since implementations are permitted to simply  ignore the DYNAMIC-EXTENT declaration.Cost to Users:  None. This change is upward compatible.  There may be some hidden costs to debugging using this declaration (or any  feature which permits the user to access dynamic extent objects without  the compiler proving that they are appropriate). If the user misdeclares  something and returns a pointer into the stack (or stores it in the heap),  an undefined situation may result and the integrity of the Lisp storage  mechanism may be compromised. Debugging these situations may be tricky,  but users who have asked for this feature have indicated a willingness  to deal with such costs. Nevertheless, the perils should be clearly  documented and casual users should not be encouraged to use this  declaration.Cost of Non-Adoption:  Some portable code would be forced to run more slowly (due to  GC overhead), or to use non-portable language features.Benefits:  The cost of non-adoption is avoided.Aesthetics:  This declaration allows a fairly low level optimization to work  by asking the user to provide only very high level information.  The alternatives (sharpsign conditionals, some of which may  lead to more bit-picky abstractions) are far less aesthetic.Discussion:  A previous version of this proposal suggested primitives STACK-LET  and STACK-LET*. Consensus was that the more general declaration facility  would be more popular.  Pitman supports the DYNAMIC-EXTENT:NEW-DECLARATION.  Actually, a blurry issue is whether   (LENGTH (LIST (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)))   => 1  is well-defined. I refer to these stack-allocated things as being invalid  return values, but in fact we might want to say that they're ok to return  but that you just can't do any serious operations on them (ie, you can't  expect them to still be lists, etc.) Can anyone imagine a pointer into  unallocated stack causing problems for their GC? If so, we could be more  clear on this point.*start*00776 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 15 NOV 88 13:22:40 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 15 Nov 88  13:19:53 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 492922; Tue 15-Nov-88 16:20:02 ESTDate: Tue, 15 Nov 88 16:19 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENTTo: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881115161949.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Sorry. The subject line of my previous message should have referred toversion 2, not version 1.*start*01796 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 11 APR 88 10:33:39 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Apr 88  10:32:11 PDTReceived: from Salvador.ms by ArpaGateway.ms ; 11 APR 88 10:24:35 PDTDate: 11 Apr 88 10:23 PDTFrom: masinter.paSubject: Re: Issue: REST-ARGUMENT-EXTENTIn-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Sun, 10 Apr 88 18:09 EDTTo: KMP@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDU, Moon@STONY-BROOK.SCRC.Symbolics.COM, Hornig@ALDERAAN.SCRC.Symbolics.COM, PRobertson@MEAD.SCRC.Symbolics.COM, Laddaga@MEAD.SCRC.Symbolics.COMMessage-ID: <880411-102435-11763@Xerox>I find the distinction between parameters and arguments useful enough to want tochange the name of this issue. The &REST parameter is bound to a list containingthe rest of the arguments; the issue is not the extent of the argument butrather REST-PARAMETER-VALUE-EXTENT, or, more concicely although moreambiguously, REST-LIST-EXTENT. As a feature to be added to the standard, this proposal is fairly weak: it addsan optional declaration which exists in some implementations. Forimplementations that do not already have this feature, is this the "optimal"feature to add? For example, should it instead be the case that we might allowthe rest parameter to be bound to a vector (as JonL has suggested?). Note that there is a related issue, currently named REST-LIST-ALLOCATION, whichaddresses the ambiguity over whether rest lists are shared in the case whereAPPLY is used.  I think we do have some obligation to resolve ambiguities in thecurrent specification before going on to add (optional) features. *start*05567 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 APR 88 15:11:10 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 10 Apr 88  15:09:34 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 379386; Sun 10-Apr-88 18:09:16 EDTDate: Sun, 10 Apr 88 18:09 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: REST-ARGUMENT-EXTENTTo: CL-Cleanup@SAIL.STANFORD.EDUcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, Hornig@ALDERAAN.SCRC.Symbolics.COM, PRobertson@MEAD.SCRC.Symbolics.COM, Laddaga@MEAD.SCRC.Symbolics.COMMessage-ID: <880410180905.3.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>I wrote the following "straw man" proposal mostly because I'm tired ofseeing the incessant mail on Common-Lisp about this topic and I'm hopingwe can quickly work toward having something to push back at theCommon-Lisp community to appease them on this obviously important issue.I expect that this will go through a few iterations before the form andcontent settle down, but I just wanted to get something concrete (straw?)on our table...-----Issue:        REST-ARGUMENT-EXTENTReferences:   5.2.2 Lambda Expressions (pp59-66)Category:     ADDITIONEdit history: 10-Apr-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  Currently, all lists created for use with the &REST syntax in lambda lists  have indefinite extent. Many users have complained that this is not always  necessary and often creates unnecessary garbage.Proposal (REST-ARGUMENT-EXTENT:GENERAL)  Introduce a DYNAMIC-EXTENT declaration such that   (DECLARE (DYNAMIC-EXTENT variable))  would permit the implementation to make the list held by the indicated  VARIABLE to have only dynamic extent.  Example:	(DEFUN FOO (&REST L)		  (DECLARE (DYNAMIC-EXTENT L))		  (APPLY #'BAR L))  Rationale:    This would allow the programmer to declare general information about    data flow which it might be difficult or impossible for a compiler to    obtain mechanically.Proposal (REST-ARGUMENT-EXTENT:CONSERVATIVE)  Introduce a DYNAMIC-EXTENT declaration such that   (DECLARE (DOWNWARD-REST-ARGUMENT))  would permit the implementation to make the list held by the rest argument  to the immediately containing binding form have only dynamic extent. It would  be an error if the immediately containing binding form did not have an  &REST specifier to which this declaration could apply.  Example:	(DEFUN FOO (&REST L)		  (DECLARE (DOWNWARD-REST-ARGUMENT))		  (APPLY #'BAR L))  Rationale:    This would allow the programmer to declare specific information about    rest argument data flow which it might be difficult or impossible for    a compiler to obtain mechanically, but would not attempt to treat the    more general issue of how this related to other kinds of data flow.Current Practice:  Lucid implements REST-ARGUMENT-EXTENT:GENERAL [at least for rest arguments;  I don't know if they attach a meaning to its use for any other arguments. -kmp]  Symbolics Cloe implements REST-ARGUMENT-EXTENT:CONSERVATIVE.Cost to Implementors:  Since implementations are only allowed (and not required) to make any use  of this declaration, there is no forced cost. In practice, though, some  users will probably get irritated if implementations fail to do something  useful with this declaration, so some implementors may end up having to pay  even if they don't technically have to.  Fully implementing even dynamic rest lists (let alone dynamic objects of  all kinds or for other data flow paths, whatever that may mean) may not be  a small change in some implementations. There is possible interaction with  garbage collection, possible implications on hidden assumptions in code  generation for stack winding and unwinding, TYPEP, etc. depending on how the  details of how dynamic lists end up being implemented.Cost to Users:  None. This is an upward-compatible change for users.  Many users are already exploiting this feature in an implementation-dependent  way, so this change will improve the maintainability of code for those  implementations and may encourage some new implementations to offer equivalent  functionality.Cost of Non-Adoption:  Some users will continue to be discouraged with implementations that do  "gratuitous heap consing" of rest lists.Benefits:  Many implementors claim that large improvements in the performance of programs  (and their associated garbage collection) are to be had from adopting some form  of proposal such as this.Aesthetics:  Debugging program errors involving dynamic extent objects can be very tricky.  This feature should be strongly discouraged for naive programmers.Discussion:  The example above is perhaps not the best example because APPLY is something  the compiler can have primitive knowledge about, and good compilers may in fact  already optimize this case even without the need for a user declaration.  Nevertheless, if the function were MY-APPLY rather than APPLY, the case would  be made because (non-block) compilers cannot make assumptions about what  MY-APPLY would do without violating the normal rules for modular compilation.  KMP supports REST-ARGUMENT-EXTENT:CONSERVATIVE pending discussion of why  REST-ARGUMENT-EXTENT:GENERAL is not overkill.*start*03961 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 APR 88 03:49:16 PDTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 12 Apr 88  03:47:35 PDTReceived: by labrea.Stanford.EDU; Tue, 12 Apr 88 02:47:03 PSTReceived: from bhopal.lucid.com by edsel id AA23917g; Tue, 12 Apr 88 03:36:41 PDTReceived: by bhopal id AA18246g; Tue, 12 Apr 88 03:37:44 PDTDate: Tue, 12 Apr 88 03:37:44 PDTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8804121037.AA18246@bhopal.lucid.com>To: masinter.paCc: KMP@stony-brook.scrc.symbolics.com, CL-Cleanup@sail.stanford.edu, Moon@stony-brook.scrc.symbolics.com, Hornig@alderaan.scrc.symbolics.com, PRobertson@mead.scrc.symbolics.com, Laddaga@mead.scrc.symbolics.comIn-Reply-To: masinter.pa@Xerox.COM's message of 11 Apr 88 10:23 PDT <880411-102435-11763@Xerox>Subject: Issue: REST-ARGUMENT-EXTENTI generally agree with your assessment, Larry, although I am pessimisticabout bringing up &rest vectors again -- a *lot* of code already existsin the Common Lisp world  which assumes that the &rest parameter is boundto a list.On the other hand, while Kent may have noticed the large number of messagessent recently to Common-Lisp@sail on this topic, but I wonder if he read them?  The overwhelming majority of them concerned user disatisfaction with the unexpected "sharing" of rest lists -- our issue REST-LIST-ALLOCATION.  As Gail Z put it so succinctly -- if the CL spec can't get its act together to guarantee non-sharing in &rest lists, then there *must* be some construct added to the language so that the discerning user can prevent it.  In mymessage to Common-Lisp@sail of 8 Apr 88 01:00:38 PDT I quoted her:   Gail Zacharias talked about the common idiom of simply doing a COPY-LIST on    every &rest argument, to insure some normalcy.  Her reasoning seems, to me,    to bolster the case for those who claim that that CL semantics are deficient       Subject: &REST Lists       Date: 24 Mar 88 12:23:15 EST (Thu)       From: gz@spt.entity.com (Gail Zacharias)       . . .        If Common Lisp doesn't require unshared &rest lists, then I think       it must provide a declarative version of this idiom so the COPY-LIST can       be portably avoided when it's redundant.  Seems to me that the fact that       this is a common case where users find a need for conditionalization        indicates a real deficiency in Common Lisp's specification.       . . .    Of course, the problem isn't only the sharing of &rest lists, but the more    common flaw that they may, unannouncedly, have dynamic extent.  By this, I    mean the bug where a stack-allocated &rest list can creep out into global    data structures, even though it will surely disappear when the frame that    created it returns.  Allegedly, Symbolics is going to fix this bug in their    next release (and TI may have already fixed it?); but we are now five years    beyond the first CL specification!So as you say, we have a responsibility to resolve the very thorny issueof REST-LIST-ALLOCATION.On the other hand, since CL semantics already requires indefinite extentfor &rest values, and since Symbolics has been in violation of this partfor so many years, *** and because a subset of users find dynamic extentextremely userful *** then I don't think it would hurt all that muchto bless the effort to standardize the syntax for asking for it.-- JonL --P.S.: When I questioned whether Kent read the messages sent to Common-Lisp      mailing list, there was no intent to question his mental compotence.      Some months back he defended the dumping of a Symbolics internal       discussion onto the CL-Cleanup mailing list by saying that he refused       to read the allegedly voluminous Common-Lisp mails,  and thus couldn't       carry on the discussion there.*start*02223 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Apr 88 23:30From: MURRAY%cs.umass:EDU:XeroxSubject: &Rest args and OptimizationsTo: common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 APR 88 23:30:49 PDTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 5 Apr 88  22:57:35 PDTReceived: from relay2.cs.net by RELAY.CS.NET id ah00702; 6 Apr 88 2:02 EDTReceived: from cs.umass.edu by RELAY.CS.NET id cd11113; 6 Apr 88 1:50 EDTOriginal-Date: Tue, 5 Apr 88 15:38 EDTX-VMS-To: CLMAILNOTE:  The ELIOT that has been arguing about &Rest args       is Chris Eliot, and NOT Eliot Moss, as someone believed.  Sharing an &Rest list with a list given to apply is clearly an optimization,and as such, should not be required.  However, if it is allowed, destructively modifying an &rest list becomes extremely dangerous, and henceshould never be done.  In fact, it might be appropriate to say it is "an error" to modify one.  I think this is a big mistake.  The cleaner approach to this and otherissues like it is to consider the language issues first.  A well-definedlanguage that is portable, easy to understand and debug is what's important.  Optimizations are the domain of the implementation.  That's the whole idea behind DECLARE.  Smart Compilers, tricky type representations, multiple function entry points,etc, are important, but are all PERFORMANCE issues, not semantic ones.  In the case of &Rest args, it seems to me that the right way to dealwith it is to say the list is always freshly consed.  If a compilercan recognize that the list is never modified, it would be freeshare it's structure with an Apply arg.  If it can determine thelist is inaccessable on function return, it is free to stack-allocate it.Providing declarations to help the compiler are very useful, but still canbe ignored without changing the program's correctness.  In regards to &More, or whatever, I think the &Rest mechanism isperfectly adequate.  A stack consed &Rest eliminates the conses,which seems to be what people want to avoid.  *start*03541 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  5 Apr 88 23:35From: ELIOT%cs.umass:EDU:XeroxSubject: &rest replacement/additionTo: common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 APR 88 23:36:00 PDTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 5 Apr 88  23:05:25 PDTReceived: from relay2.cs.net by RELAY.CS.NET id ab00602; 6 Apr 88 1:54 EDTReceived: from cs.umass.edu by RELAY.CS.NET id bk11113; 6 Apr 88 1:43 EDTOriginal-Date: Tue, 5 Apr 88 12:55 EDTX-VMS-To: IN%"common-lisp@sail.stanford.EDU"I had hoped that the semantics of &rest lists could be completelyspecified without or before getting into murky side issues likethis.Given my position on previous issues it should not be a surprise thatI am strongly opposed to all of the &rest replacement/additonproposals.  I consider &rest to be a fine feature that is completelyadequate for solving the problems of passing indefinate numbers of arguments.  I consider it sufficiently good that it is worth spendingconsiderable effort giving it a precise specification, as we havebeen trying to do.  I don't think it needs replacement.There has only been one criticism of &Rest lists.  There is theimpression that this feature introduces an unacceptible inefficiencyin programs.  This impression is sufficiently strong that people areconsidering pulling one of Maclisp's kludgest features out of itsgrave, introducing new strange data types to Common Lisp and doingall kinds of horrible things in order to eliminate this ineficiency.From the data that is available it seems that this is justbeing scared of the dark.  The statistics I collected do notdirectly measure the bottom line efficiency of using &Rest lists.This certainly means that it is "possible" for dynamic situations toexist where the efficiency of &Rest lists is exagerated.  It is alsopossible that my data sample is somehow unrepresentative.Someone suggested that the low usage of &Rest could be explained becauseprogrammers fear its inefficiency.  This is unlikely.  The code I analyzed was Lisp Machine system code.  Most of this code was writtenas ZetaLisp code, in which &Rest lists are *more* efficient than theyare in Common Lisp.  (Because of stack consing.)  In fact, while &Restmay be less efficient in Common Lisp it may be used more, perhapsbecause it is better specified and thus more valuable from an algorithmicstandpoint.About 10% of the Common Lisp functions used &Rest arguments.  I believethis is probably an upper bound.  A great deal of effort has been spenton this mailing list thinking of ways to generalize all of the primitivesin Common Lisp.  Despite this effort to generalize the primitives, 90%of the time there has been no good reason to use &Rest lists.Furthermore, I believe there is an explanation for why people "havethe impression" that &rest/Apply must be highly optimized.  Both of theseare used in somewhat unusual coding situations that require somewhatmore thought than normal.  A tricky piece of code requires more attentionfrom the programmer.  A common trap is to think the program spends as muchtime executing code as the programmer spends writing it.Without any data to support another position all of the proposals toreplace &Rest or augment it should be rejected, and its semantics shouldbe precisely defined as I have previously proposed.*start*02955 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  6 Apr 88 10:36From: Stever%WAIKATO.S4CC.Symbolics:COM:XeroxSubject: &rest replacement/additionIn-Reply-to: Msg of 5 Apr 1988  12:55-EDT from ELIOT at cs.umass.eduTo: ELIOT%cs.umass:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Stephen Robbins <Stever@WAIKATO.S4CC.Symbolics.COM>Subject: &rest replacement/additionTo: ELIOT@cs.umass.educc: common-lisp@sail.stanford.eduIn-Reply-To: Msg of 5 Apr 1988  12:55-EDT from ELIOT at cs.umass.eduReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 06 APR 88 10:36:11 PDTReceived: from WAIKATO.S4CC.Symbolics.COM ([128.81.51.90]) by SAIL.Stanford.EDU with TCP; 6 Apr 88  09:56:26 PDTReceived: from JEWEL-CAVE.S4CC.Symbolics.COM by WAIKATO.S4CC.Symbolics.COM via CHAOS with CHAOS-MAIL id 167878; Wed 6-Apr-88 12:43:05 EDTOriginal-Date: Wed, 6 Apr 88 12:43 EDTMessage-ID: <19880406164304.2.STEVER@JEWEL-CAVE.S4CC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Tuesday, 5 April 1988  12:55-EDT    From: ELIOT at cs.umass.edu    There is the impression that this feature introduces an    unacceptible inefficiency in programs.    From the data that is available it seems that this is just being    scared of the dark.  It is also possible that my data sample is    somehow unrepresentative.    The code I analyzed was Lisp Machine system code.Last year, I wrote a window system in Common Lisp.  I needed a simpleflavors system to support it.  My generic function dispatcher used&REST and APPLY to pass arguments from the generic function to themethod handling the generic function.Since the window system was used everywhere in our product, we neededmaximum efficiency in time and space.  We found that &REST CONSing wastaking time and space we couldn't afford (the things it was doing tothe freelist! :-) So much so that we had to make it a general shoppolicy not to use &REST.Maybe this is an issue of "the compiler writers should be smarter."But we're a startup.  We can't wait for the compiler writers to getsmarter.  For that matter, we can't wait for an &REST replacement.If Common Lisp wants to be commercially viable, it needs to addressthese issues in some form, however inelegant it may be to have toworry about them.There are certainly ways around using &REST in a flavor system.  Butthey're bulky, cumbersome, and take time to write and debug.  Timethat we needed to spend writing the body of our product.  Our choice:use &REST and be too slow and too large, or program around it, makingit a useless feature.I'm not sure what the "correct" replacement/extension for it is, butin my experience, &REST \can/ be too slow and too space consumingfor use in a real, deliverable product.-- Stephen*start*01888 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 18:32:55 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Dec 88  18:30:26 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 07 DEC 88 18:07:31 PSTDate: 7 Dec 88 18:05 PSTFrom: masinter.paSubject: Re: Issue: DYNAMIC-EXTENT (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Tue, 15 Nov 88 16:14 ESTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>cc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881207-180731-2393@Xerox>Version 2 of this writeup didn't mention one of the criticisms I sent on 1July, namely:"a) it is disturbing to introduce a construct within which a casual changeof (CONS X (LIST Y Z)) to  (LIST X Y Z) could introduce a serious bug(e.g., if the tail were stashed awaysomewhere.)"and also that the proposal doesn't seem to address objects other thanlists; what of DEFSTRUCT or DEFCLASS objects?I wonder if it might be useful to think about what the semantics ofdeclaring something to be "dynamic extent" really means. For example, I think of a type declaration as a promise from the programmerto the compiler that a TYPEP assertion will at certain points (exactly whatpoints being subject to some debate).When you declare something as DYNAMIC-EXTENT, what is it you are promisingto the compiler? That the value of the variable or any part of it will notbe newly stored in any other permanent structure? It or any subpart of itwill not be referenced outside of the dynamic extent of the enclosing form?I think DYNAMIC-EXTENT and WITH-DYANMIC-EXTENT should be discussedtogether, since they seem to overlap in the problem they are attacking.They don't seem like they are ready for voting, however.*start*01649 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  2 Jul 88 12:19From: trwrb!smpvax1!jrg%ucbvax.Berkeley:EDU:XeroxSubject: dynamic extent lisp objectsTo: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JUL 88 12:19:29 PDTReceived: from ucbvax.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 2 Jul 88  11:45:05 PDTReceived: by ucbvax.Berkeley.EDU (5.59/1.28)	id AA13200; Fri, 1 Jul 88 20:21:33 PDTReceived: by trwrb (5.51/1.36)	id AA03450; Fri, 1 Jul 88 18:56:03 PDTOriginal-Date: Fri, 1 Jul 88 18:56:03 PDTMessage-Id: <8807020156.AA03450@trwrb>Speaking as a representative from a company that has a reasonablysuccessful lisp-based software product, having the ability to declare anobject to have dynamic extent is of great benefit in building apractical lisp-based product.  I strongly support this addition to thelanguage.  I prefer the declaration form for many of the same reasonsalready mentioned by its other advocates.  But I'd rather have either oreven some other syntax supporting similar functionality than nothing.While I believe several of the other clean-up language changes arebeneficial and several of the proposed additions to the language areuseful, this is the first issue that I've been motivated to activelysupport.  Being able to use a feature such as this can be the differencebetween having a practical product that many customers can use andhaving one that is impossible to deploy in many, if not most,environments.--Joe Ginder*start*01970 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  3 Jul 88 15:45From: cperdue%Sun:COM:XeroxSubject: Re:  dynamic extent lisp objectsTo: common-lisp%sail.stanford:EDU:Xerox, trwrb!smpvax1!jrg%ucbvax.Berkeley:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: cperdue@Sun.COM (Cris Perdue)To: common-lisp@sail.stanford.edu, trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUSubject: Re:  dynamic extent lisp objectsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 03 JUL 88 15:45:12 PDTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 3 Jul 88  15:09:52 PDTReceived: from snail.sun.com by Sun.COM (4.0/SMI-4.0)	id AA20651; Sun, 3 Jul 88 15:08:15 PDTReceived: from clam.sun.com by snail.sun.com (4.0/SMI-3.2)	id AA03866; Sun, 3 Jul 88 15:03:47 PDTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA16720; Sun, 3 Jul 88 15:11:07 PDTOriginal-Date: Sun, 3 Jul 88 15:11:07 PDTMessage-Id: <8807032211.AA16720@clam.sun.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> Speaking as a representative from a company that has a reasonably> successful lisp-based software product, having the ability to declare an> object to have dynamic extent is of great benefit in building a> practical lisp-based product.How clear are you on the issue of whether a declaration facilityfor variables would be adequate for your needs?One can imagine a form named something like "with-dynamic-extent" thatcauses all storage allocation "within" its body that would ordinarilybe done on the heap to be done on the stack instead.My personal guess is that the variable declarations wind up beingmore controllable, but that a "with" form would prove somewhatmore powerful.  Certainly the "with" form could handle complexbackquotes easier than variable declarations could.Any practical experience one way or the other?				-Cris*start*01649 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  2 Jul 88 12:19From: trwrb!smpvax1!jrg%ucbvax.Berkeley:EDU:XeroxSubject: dynamic extent lisp objectsTo: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JUL 88 12:19:29 PDTReceived: from ucbvax.Berkeley.EDU by SAIL.Stanford.EDU with TCP; 2 Jul 88  11:45:05 PDTReceived: by ucbvax.Berkeley.EDU (5.59/1.28)	id AA13200; Fri, 1 Jul 88 20:21:33 PDTReceived: by trwrb (5.51/1.36)	id AA03450; Fri, 1 Jul 88 18:56:03 PDTOriginal-Date: Fri, 1 Jul 88 18:56:03 PDTMessage-Id: <8807020156.AA03450@trwrb>Speaking as a representative from a company that has a reasonablysuccessful lisp-based software product, having the ability to declare anobject to have dynamic extent is of great benefit in building apractical lisp-based product.  I strongly support this addition to thelanguage.  I prefer the declaration form for many of the same reasonsalready mentioned by its other advocates.  But I'd rather have either oreven some other syntax supporting similar functionality than nothing.While I believe several of the other clean-up language changes arebeneficial and several of the proposed additions to the language areuseful, this is the first issue that I've been motivated to activelysupport.  Being able to use a feature such as this can be the differencebetween having a practical product that many customers can use andhaving one that is impossible to deploy in many, if not most,environments.--Joe Ginder*start*01970 00024 US Sender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate:  3 Jul 88 15:45From: cperdue%Sun:COM:XeroxSubject: Re:  dynamic extent lisp objectsTo: common-lisp%sail.stanford:EDU:Xerox, trwrb!smpvax1!jrg%ucbvax.Berkeley:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: cperdue@Sun.COM (Cris Perdue)To: common-lisp@sail.stanford.edu, trwrb!smpvax1!jrg@ucbvax.Berkeley.EDUSubject: Re:  dynamic extent lisp objectsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 03 JUL 88 15:45:12 PDTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 3 Jul 88  15:09:52 PDTReceived: from snail.sun.com by Sun.COM (4.0/SMI-4.0)	id AA20651; Sun, 3 Jul 88 15:08:15 PDTReceived: from clam.sun.com by snail.sun.com (4.0/SMI-3.2)	id AA03866; Sun, 3 Jul 88 15:03:47 PDTReceived: by clam.sun.com (3.2/SMI-3.2)	id AA16720; Sun, 3 Jul 88 15:11:07 PDTOriginal-Date: Sun, 3 Jul 88 15:11:07 PDTMessage-Id: <8807032211.AA16720@clam.sun.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> Speaking as a representative from a company that has a reasonably> successful lisp-based software product, having the ability to declare an> object to have dynamic extent is of great benefit in building a> practical lisp-based product.How clear are you on the issue of whether a declaration facilityfor variables would be adequate for your needs?One can imagine a form named something like "with-dynamic-extent" thatcauses all storage allocation "within" its body that would ordinarilybe done on the heap to be done on the stack instead.My personal guess is that the variable declarations wind up beingmore controllable, but that a "with" form would prove somewhatmore powerful.  Certainly the "with" form could handle complexbackquotes easier than variable declarations could.Any practical experience one way or the other?				-Cris*start*09412 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 02 JAN 89 12:02:56 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 2 Jan 89  12:02:06 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 514009; Mon 2-Jan-89 15:00:49 ESTDate: Mon, 2 Jan 89 15:00 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENT (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881115161453.5.KMP@BOBOLINK.SCRC.Symbolics.COM>,             <881207-180731-2393@Xerox>Message-ID: <19890102200018.4.MOON@EUPHRATES.SCRC.Symbolics.COM>I favor DYNAMIC-EXTENT:NEW-DECLARATION over STACK-LET, becausea declaration does seem more appropriate than a new special form.I favor it over WITH-DYNAMIC-EXTENT, because (as BarMar pointedout) saying that -all- objects consed during execution of a formhave dynamic extent is too dangerous.However I cannot support the current version of the DYNAMIC-EXTENTproposal, basically for the reason that Masinter gave.  See below.While I'm here I'll also comment on typos.    Date: Tue, 15 Nov 88 16:14 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    Issue:          DYNAMIC-EXTENT    Problem Description:->    Sometimes a programmers knows that a particular data structureprogrammer[s]    Proposal (DYNAMIC-EXTENT:NEW-DECLARATION):      Other interesting cases are:            (PROCLAIM '(INLINE G))            (DEFUN G (X) (DECLARE (DYNAMIC-EXTENT X)) ...)->          (DEFUN F () (F (LIST 1 2 3)))The second F should be G.      What data types (if any) can be stack-allocated will vary from      implementation to implementation. In some implementations, it might be      possible to allocate arrays, structures, or instances, for example.Masinter seems not to have noticed this paragraph, since he complainedthat the proposal addressed only lists, so perhaps it should be movedearlier in the proposal.  I suggest coupling this with the secondparagraph in the proposal section, which makes it clear that thedeclaration -allows- the declared object to be stack-allocatedregardless of its type, but does not -require- anything to bestack-allocated.The following is where I disagree strongly with the proposal:      It is very important to note that it is the actual constructor operation      and not the resulting data type which determines the level of the object      referred to in the dynamic extent declaration. For example, in            (LET ((X (LIST 'A1 'B1 'C1))                  (Y (CONS 'A2 (CONS 'B2 (CONS 'C2 NIL)))))              (DECLARE (DYNAMIC-EXTENT X Y))              ...)      The list (A1 B1 C1) which is the initial value of X will have three cons      cells, all of which have dynamic extent. The cons (A2 . (B2 C2)) which is      the initial value of Y will have dynamic extent, but its cdr (B2 C2) will      have indefinite extent.I think this is the wrong way to look at it in general, and furthermorethis means that backquote can't be used correctly with theDYNAMIC-EXTENT declaration, since there is no promise what backquoteexpands into.  Also this way of looking at it requires saying silly (inmy opinion) things like:      If an implementation does not recognize the constructor, it calls      MACROEXPAND-1 in hopes of seeing a constructor which it does recognize.A particular implementation might well be implemented this way, but thisshould not be the definition of the language!I propose the following instead.  I admit that this is somewhat stilted,but I think that is necessary in order to be precise and unambiguous.The meaning of a dynamic extent declaration is that execution of theforms in the scope of the declaration will not "save" any "proper part"of the initial value of the declared variable.  To "save" an objectmeans to cause a reference to that object to be accessible outside thedynamic extent of the form at the beginning of whose body thedeclaration appears.  An object can be "saved" by storing it with aside-effecting operation and not replacing it with a different valuebefore the end of the dynamic extent, by using it as a component of afreshly-allocated object that is itself "saved," by capturing it in afunction closure that is itself "saved," by returning it as a value, orby transmitting it outside the dynamic extent with THROW.  A "properpart" of an object A is any object that is accessible at the beginningof the scope of the declaration -only- by applying a function to A or toa "proper part" of A.  This means that any objects freshly allocatedduring the construction of the initial value of the declared variable,and not "saved" during the construction of that value, are "properparts" and can be allocated on a stack.Returning to the example            (LET ((X (LIST 'A1 'B1 'C1))                  (Y (CONS 'A2 (CONS 'B2 (CONS 'C2 NIL)))))              (DECLARE (DYNAMIC-EXTENT X Y))              ...)The "proper parts" of X are three conses, and the "proper parts" of Yare three other conses.  None of the symbols A1, B1, C1, A2, B2, C2, orNIL is a "proper part" of X or Y.  However, if a freshly allocateduninterned symbol had been used, it would have been a "proper part."    Test Case:          (DOTIMES (I N)             (DECLARE (DYNAMIC-EXTENT I))This is particularly instructive.  Since I is an integer by thedefinition of DOTIMES, but EQ and EQL are not necessarily equivalent forintegers, what are the "proper parts" of I, which this declarationrequires the body of the DOTIMES not to "save"?  If the value of I is 3,and the body does (SETQ FOO 3), is that an error?  The answer is no, butthe interesting thing is that it depends on the implementation-dependentbehavior of EQ on numbers.  In an implementation where EQ and EQL areequivalent for 3, then 3 is not a "proper part" because (EQ I (+ 2 1))is true, and therefore there is another way to access the object besidesgoing through I.  On the other hand, in an implementation where EQ andEQL are not equivalent for 3, then the particular 3 that is the value ofI is a "proper part", but any other 3 is not.  Thus (SETQ FOO 3) is validbut (SETQ FOO I) is erroneous.  Since (SETQ FOO I) is erroneous in someimplementations, it is erroneous in all portable programs, but some otherimplementations may not be able to detect the error.I hope no one misreads the above as an argument that my proposal is toocomplicated, since it does not derive at all from my proposal, but onlyfrom the way Common Lisp works.    Discussion:      Actually, a blurry issue is whether       (LENGTH (LIST (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)))       => 1      is well-defined. I refer to these stack-allocated things as being invalid      return values, but in fact we might want to say that they're ok to return      but that you just can't do any serious operations on them (ie, you can't      expect them to still be lists, etc.) Can anyone imagine a pointer into      unallocated stack causing problems for their GC? If so, we could be more      clear on this point.In some if not all implementations, the part of the stack above thecurrent stack pointer can have its contents changed at any time by aninterrupt, possibly to something that will cause LIST to blow out whenit stores it into the CAR of the CONS it creates.  That's animplementational point of view.  From a language point of view, I do notbelieve you can make a coherent definition of "serious operations."  Idon't think this is a blurry issue at all, I think it's quite clear thatreturning an object as a value is "saving" it regardless of what thecaller actually does with the value.  I would say that even  (PROGN (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)         NIL)is an error.    Date: 7 Dec 88 18:05 PST    From: masinter.pa@Xerox.COM    Version 2 of this writeup didn't mention one of the criticisms I sent on 1    July, namely:    "a) it is disturbing to introduce a construct within which a casual change    of (CONS X (LIST Y Z)) to  (LIST X Y Z) could introduce a serious bug    (e.g., if the tail were stashed away    somewhere.)"I quite agree with this.  My proposed alternative definition doesn't have anyproblems like this, since it is defined in terms of the actual object, not interms of how it was constructed.    I wonder if it might be useful to think about what the semantics of    declaring something to be "dynamic extent" really means.     For example, I think of a type declaration as a promise from the programmer    to the compiler that a TYPEP assertion will at certain points (exactly what    points being subject to some debate).    When you declare something as DYNAMIC-EXTENT, what is it you are promising    to the compiler? That the value of the variable or any part of it will not    be newly stored in any other permanent structure? It or any subpart of it    will not be referenced outside of the dynamic extent of the enclosing form?My proposed alternative definition addresses this, I believe.  I'd be interestedto hear if anyone can find any imprecisenesses in it.*start*03102 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 05:43:08 PSTReceived: from RELAY.CS.NET by SAIL.Stanford.EDU with TCP; 3 Jan 89  05:42:40 PSTReceived: from relay2.cs.net by RELAY.CS.NET id aa19261; 3 Jan 89 8:32 ESTReceived: from draper.com by RELAY.CS.NET id aa29726; 3 Jan 89 8:20 ESTDate: Tue, 3 Jan 89 08:11 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: DYNAMIC-EXTENT (Version 2)To: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525> From: "David A. Moon" <Moon@scrc-stony-brook.ARPA>> Subject: Issue: DYNAMIC-EXTENT (Version 2)> The following is where I disagree strongly with the proposal:>>      It is very important to note that it is the actual constructor operation>      and not the resulting data type which determines the level of the object>      referred to in the dynamic extent declaration. For example, in>>            (LET ((X (LIST 'A1 'B1 'C1))>                  (Y (CONS 'A2 (CONS 'B2 (CONS 'C2 NIL)))))>              (DECLARE (DYNAMIC-EXTENT X Y))>              ...)>>      The list (A1 B1 C1) which is the initial value of X will have three cons>      cells, all of which have dynamic extent. The cons (A2 . (B2 C2)) which is>      the initial value of Y will have dynamic extent, but its cdr (B2 C2) will>      have indefinite extent.>> I think this is the wrong way to look at it in general, and furthermore> this means that backquote can't be used correctly with the> DYNAMIC-EXTENT declaration, since there is no promise what backquote> expands into. >> ...>>            (LET ((X (LIST 'A1 'B1 'C1))>                  (Y (CONS 'A2 (CONS 'B2 (CONS 'C2 NIL)))))>              (DECLARE (DYNAMIC-EXTENT X Y))>              ...)>> The "proper parts" of X are three conses, and the "proper parts" of Y> are three other conses.  None of the symbols A1, B1, C1, A2, B2, C2, or> NIL is a "proper part" of X or Y.  However, if a freshly allocated> uninterned symbol had been used, it would have been a "proper part.">>    Date: 7 Dec 88 18:05 PST>    From: masinter.pa@Xerox.COM>>    Version 2 of this writeup didn't mention one of the criticisms I sent on 1>    July, namely:>>    "a) it is disturbing to introduce a construct within which a casual change>    of (CONS X (LIST Y Z)) to  (LIST X Y Z) could introduce a serious bug>    (e.g., if the tail were stashed away>    somewhere.)">> I quite agree with this.  My proposed alternative definition doesn't have any> problems like this, since it is defined in terms of the actual object, not in> terms of how it was constructed.>I agree strongly with the comments of Moon and Masinter.  For example, in ourimplementation, the compiler source-transforms calls to LIST into nestedcalls to CONS.  Under these circumstances, it is impossible to distinguishbetween the cases in the various examples above for the purpose of determining which conses are subject to the DYNAMIC-EXTENT constraint.*start*01183 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 03 JAN 89 09:15:16 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 3 Jan 89  08:33:55 PSTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA03107g; Tue, 3 Jan 89 08:29:18 PSTReceived: by blacksox id AA00259g; Tue, 3 Jan 89 08:31:34 pstDate: Tue, 3 Jan 89 08:31:34 pstFrom: Eric Benson <eb@lucid.com>Message-Id: <8901031631.AA00259@blacksox>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: David A. Moon's message of Mon, 2 Jan 89 15:00 EST <19890102200018.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENT (Version 2)This is very good.  The definitions of "saved" and "proper part" seemquite precise to me.  It is essential to have a definition independentof the implementation.  Still, it would be useful to give at least asketch of how this might be implemented, since it still involveslooking for functions like CONS and LIST (and whatever backquote turnsinto) about which the compiler has information.*start*00909 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 JAN 89 01:45:42 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Jan 89  01:45:38 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 JAN 89 01:37:33 PSTDate: 8 Jan 89 01:36 PSTFrom: masinter.paSubject: Re: Issue: DYNAMIC-EXTENT (Version 2)In-reply-to: Eric Benson <eb@lucid.com>'s message of Tue, 3 Jan 89 08:31:34 pstTo: Eric Benson <eb@lucid.com>cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890108-013733-3047@Xerox>I like this too.If we can have a new version of this, I think it will subsumeREST-ARGUMENT-EXTENT, WITH-DYNAMIC-EXTENT and STACK-LET.I think all that's necessary is to insert David's words in a proposal. I'ddo it now but I'm falling asleep.  *start*11172 00024 USfDate: 11 Jan 89 15:17 PSTFrom: masinter.paSubject: Issue: DYNAMIC-EXTENT (Version 3)To: CL-Cleanup@SAIL.Stanford.EDUline-fold: NOcc: masinter<<version number wrong, missing line-fold: NO>>I don't have the time to "wordsmith" this issue, but I think itis important enough to bring before X3J13; I think the ideain the proposal is fine, but I just clipped some of David's wordsinto the old one.I'd like to release this in DRAFT form, I'm less sure whatwe can vote on. Opinions? Volunteers to edit this further?Status:	        For Internal DiscussionForum:	CLEANUPIssue:          DYNAMIC-EXTENTReferences:     Scope and ExtentCategory:       ADDITIONEdit history:   27-Jun-88, Version 1 by Pitman (as issue STACK-LET)		15-Nov-88, Version 2 by Pitman (issue renamed, major revision)		11-Jan-89, Version 3 by Masinter (Moon's proposal)Related-Issues: REST-ARGUMENT-EXTENT, WITH-DYNAMIC-EXTENTProblem Description:  Sometimes a programmer knows that a particular data structure  will have only dynamic extent. In some implementations, it is  possible to allocate such structures in a way that will make them  easier to reclaim than by general purpose garbage collection  (eg, on the stack or in some temporary area). Currently, however,  there is no way to request the use of such an allocation mechanism.Proposal (DYNAMIC-EXTENT:NEW-DECLARATION):  Introduce a new declaration called DYNAMIC-EXTENT. The arguments to  this declaration are names of variables. The declaration asserts that  the value which is initially held by the indicated variable will have  dynamic extent. [In the case of an iteration variable, the declaration  asserts that on every iteration, the initial value of that variable  for the iteration will have dynamic extent.]  It is permissible for an implementation to simply ignore this declaration.  In implementations which do not ignore it, the compiler (or interpreter)  is free to make whatever optimizations are appropriate given this  information; the most common optimization is to stack-allocate the  initial value of the object. What data types (if any) can have dynamic  extent will can vary from implementation to implementation.  Since stack allocation of the initial value entails knowing at the  object's creation time that the object can be stack-allocated, it is  not generally useful to declare DYNAMIC-EXTENT for variables for  which have no lexically apparent initial value. For example,	(DEFUN F ()	  (LET ((X (LIST 1 2 3)))	    (DECLARE (DYNAMIC-EXTENT X))	    ...))  would permit those compilers which wish to do so to stack-allocate the  list in X. However,	(DEFUN G (X) (DECLARE (DYNAMIC-EXTENT X)) ...)	(DEFUN F () (G (LIST 1 2 3)))  could not typically permit a similar optimization in G because it would  be a modularity violation for the compiler to assume facts about G from  within F. Only an implementation which was willing to be responsible for  recompiling F if G's definition changed incompatibly could stack-allocate  the list argument to G in F.  Other interesting cases are:	(PROCLAIM '(INLINE G))	(DEFUN G (X) (DECLARE (DYNAMIC-EXTENT X)) ...)	(DEFUN F () (G (LIST 1 2 3)))    and	(DEFUN F ()	  (FLET ((G (X) (DECLARE (DYNAMIC-EXTENT X)) ...))	    (G (LIST 1 2 3))))  where some compilers might realize the optimization was possible and others  might not.  An interesting variant of this is the so-called `stack allocated rest list'  which can be achieved (in implementations supporting the optimization) by:	(DEFUN F (&REST X)	  (DECLARE (DYNAMIC-EXTENT X))	  ...)  Note here that although the initial value of X is not explicit, the F  function is responsible for assembling the list X from the passed arguments,  so the F function can be optimized by the compiler to construct a   stack-allocated list instead of a heap-allocated list in implementations  which support such.   The meaning of a dynamic extent declaration is that execution of the   forms in the scope of the declaration will not "save" any "proper part"   of the initial value of the declared variable.  To "save" an object   means to cause a reference to that object to be accessible outside the   dynamic extent of the form at the beginning of whose body the   declaration appears.  An object can be "saved" by storing it with a   side-effecting operation and not replacing it with a different value   before the end of the dynamic extent, by using it as a component of a   freshly-allocated object that is itself "saved," by capturing it in a   function closure that is itself "saved," by returning it as a value, or   by transmitting it outside the dynamic extent with THROW.  A "proper   part" of an object A is any object that is accessible at the beginning   of the scope of the declaration -only- by applying a function to A or to   a "proper part" of A.  This means that any objects freshly allocated   during the construction of the initial value of the declared variable,   and not "saved" during the construction of that value, are "proper   parts" and can be allocated on a stack.Examples:In            (LET ((X (LIST 'A1 'B1 'C1))                  (Y (CONS 'A2 (CONS 'B2 (CONS 'C2 NIL)))))              (DECLARE (DYNAMIC-EXTENT X Y))              ...)The "proper parts" of X are three conses, and the "proper parts" of Yare three other conses.  None of the symbols A1, B1, C1, A2, B2, C2, orNIL is a "proper part" of X or Y.  However, if a freshly allocateduninterned symbol had been used, it would have been a "proper part."- - - - - - - -          (DOTIMES (I N)             (DECLARE (DYNAMIC-EXTENT I))This is particularly instructive.  Since I is an integer by thedefinition of DOTIMES, but EQ and EQL are not necessarily equivalent forintegers, what are the "proper parts" of I, which this declarationrequires the body of the DOTIMES not to "save"?  If the value of I is 3,and the body does (SETQ FOO 3), is that an error?  The answer is no, butthe interesting thing is that it depends on the implementation-dependentbehavior of EQ on numbers.  In an implementation where EQ and EQL areequivalent for 3, then 3 is not a "proper part" because (EQ I (+ 2 1))is true, and therefore there is another way to access the object besidesgoing through I.  On the other hand, in an implementation where EQ andEQL are not equivalent for 3, then the particular 3 that is the value ofI is a "proper part", but any other 3 is not.  Thus (SETQ FOO 3) is validbut (SETQ FOO I) is erroneous.  Since (SETQ FOO I) is erroneous in someimplementations, it is erroneous in all portable programs, but some otherimplementations may not be able to detect the error.- - - - - - - -  (LET ((X (LIST 1 2 3)))    (DECLARE (DYNAMIC-EXTENT X))    (PRINT X)    NIL)  PRINT does not "save" any part of its input.  This prints (1 2 3)- - - - - - - -  (DO ((L (LIST-ALL-PACKAGES) (CDR L)))      ((NULL L))    (DECLARE (DYNAMIC-EXTENT L))    (PRINT (CAR L)))  prints all packages; none of the newly-allocated list structures are saved.- - - - - - - -  (DEFUN ADD (&REST X) (DECLARE (DYNAMIC-EXTENT X)) (APPLY #'+ X))  (ADD 1 2 3) => 6I.e., useful way to declare that &REST lists have dynamic extent- - - - - - - -  (DEFUN ZAP (X Y Z)    (DO ((L (LIST X Y Z) (CDR L)))	((NULL L))      (DECLARE (DYNAMIC-EXTENT L))      (PRIN1 (CAR L))))  (ZAP 1 2 3)  prints 123- - - - - - - -  (DEFUN ZAP (N M)    ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).    ;; It may be slow, but with a good compiler at least it    ;; doesn't waste much heap storage.  :-)    (LET ((A (MAKE-ARRAY N)))      (DECLARE (DYNAMIC-EXTENT A))      (DOTIMES (I N) 	(DECLARE (DYNAMIC-EXTENT I))	(SETF (AREF A I) (RANDOM (+ I 1))))      (AREF A M)))  (< (ZAP 5 3) 3) => T- - - - - - - -The following are in error, since the value of X is used outside of itsextent:       (LENGTH (LIST (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)))  (PROGN (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)         NIL)- - - - - - - -Rationale:  This permits a programmer to offer advice to an implementation about  what may be stack-allocated for efficiency.  It may be difficult or impossible for a compiler to infer this  same information statically.  Since a number of implementations offer this capability and there  is demand from users for access to the capability, this ``codifies  existing practice.''  Because this approach is purely lexical, it does not interact badly with  other programs in the way that the macro WITH-DYNAMIC-EXTENT (see issue  by same name) would.Current Practice:  Symbolics Genera and Symbolics Cloe offer stack allocation, though not  in this strategy.  [KMP thinks that] Lucid supports the proposal.Cost to Implementors:  No cost is forced since implementations are permitted to simply  ignore the DYNAMIC-EXTENT declaration.Cost to Users:  None. This change is upward compatible.  There may be some hidden costs to debugging using this declaration (or any  feature which permits the user to access dynamic extent objects without  the compiler proving that they are appropriate). If the user misdeclares  something and returns a pointer into the stack (or stores it in the heap),  an undefined situation may result and the integrity of the Lisp storage  mechanism may be compromised. Debugging these situations may be tricky,  but users who have asked for this feature have indicated a willingness  to deal with such costs. Nevertheless, the perils should be clearly  documented and casual users should not be encouraged to use this  declaration.Cost of Non-Adoption:  Some portable code would be forced to run more slowly (due to  GC overhead), or to use non-portable language features.Benefits:  The cost of non-adoption is avoided.Aesthetics:  This declaration allows a fairly low level optimization to work  by asking the user to provide only very high level information.  The alternatives (sharpsign conditionals, some of which may  lead to more bit-picky abstractions) are far less aesthetic.Discussion:  A previous version of this proposal suggested primitives STACK-LET  and STACK-LET*. Consensus was that the more general declaration facility  would be more popular.  Pitman supports the DYNAMIC-EXTENT:NEW-DECLARATION.  Actually, a blurry issue is whether   (LENGTH (LIST (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)))   => 1  is well-defined. I refer to these stack-allocated things as being invalid  return values, but in fact we might want to say that they're ok to return  but that you just can't do any serious operations on them (ie, you can't  expect them to still be lists, etc.) Can anyone imagine a pointer into  unallocated stack causing problems for their GC? If so, we could be more  clear on this point.The examples are tricky:"I hope no one misreads the above as an argument that my proposal is toocomplicated, since it does not derive at all from my proposal, but onlyfrom the way Common Lisp works."*start*01502 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 20:07:40 PSTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 11 Jan 89  20:07:01 PSTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA16343@EDDIE.MIT.EDU>; Wed, 11 Jan 89 22:36:07 ESTReceived: by spt.entity.com (smail2.5); 11 Jan 89 22:17:19 EST (Wed)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: masinter.pa@Xerox.COM's message of 11 Jan 89 15:16 PST <890111-151708-10854@Xerox>Subject: Issue: DYNAMIC-EXTENT (Version 2)Message-Id: <8901112217.AA15621@spt.entity.com>Date: 11 Jan 89 22:17:19 EST (Wed)From: gz@spt.entity.com (Gail Zacharias)     Actually, a blurry issue is whether      (LENGTH (LIST (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)))      => 1     is well-defined. I refer to these stack-allocated things as being invalid     return values, but in fact we might want to say that they're ok to return     but that you just can't do any serious operations on them (ie, you can't     expect them to still be lists, etc.) Can anyone imagine a pointer into     unallocated stack causing problems for their GC? If so, we could be more     clear on this point.Yes, this would lose badly in our system if the outer call to LIST were to gc.It's not pointing into unallocated stack that's the problem, it's pointing toreallocated stack.*start*03165 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 13 JAN 89 10:48:07 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 521091; Fri 13-Jan-89 13:47:23 ESTDate: Fri, 13 Jan 89 13:47 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENT (Version 3)To: Moon@STONY-BROOK.SCRC.Symbolics.COM, Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <890113134708.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Even though this is very different (more permissive) than what I'd firstwritten up, I have to say I really like this rewrite a lot. It's quiteclever in the way it presents things in order to get additional flexibility.However, I do have a few comments I'd like to see addressed before thisgets to a vote... * I like the concept "proper part" a lot but I don't like the name.   The term "proper" for proper lists has to do with well-formed-ness   and in this context you're suggesting an incompatible meaning which   is confusing.      I suggest instead a term like "internal", "intrinsic", "private",   "unshared", etc.      [The concept of "unshared" makes me immediately scared about the    whole quote-may-copy morass, but I don't have time to think through    right now whether that's an issue that needs further clarification    or if it's just a red herring.] * I like the concept of "saved" but it has the problem that it isn't   easy to bring up "out of context" since "save" has a lot of connotations.   If it were possible to come up with a more unique term, I think it   would help in lunch table conversations when people start getting   screwed by things that were `unintentionally saved' and others can't   figure out what they mean out of context. * I think your list of definitions for saved is pretty good, but I'd   still like to see an abstract definition, and then the concrete cases   listed beneath it. That way, we are protected from weird unintentional    interpretations if someone discovers that the set was not exhaustive   and needs to include their new case under the abstract description   because the concrete list doesn't accomodate things. * What about things like:   (DEFUN FOO (&REST X)     (DECLARE (DYNAMIC-EXTENT X))     (MAPL #'PRINT X)     T)   Genera's Dynamic Windows (DW) had bugs in its first release because the   window history recorded the object which was printed. Put another    way, PRINT did unexpected "saving" on some streams. The situation with   DW was treated as a bug and now DW correctly detects stack-allocated   things and does not try to save them, so this would work now.   However, it still raises the question of whether we should define   per-function for every CL function whether any of the arguments is   permitted to be "saved" so that CL programs don't get any funny surprises.   If we don't, it ends up being implementor's discretion how to resolve   cases like this, and everyone might not agree that all cases are as    obvious as this one was.*start*02051 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 15 JAN 89 05:55:49 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03812g; Sun, 15 Jan 89 05:52:06 PSTReceived: by bhopal id AA11871g; Sun, 15 Jan 89 05:54:25 PSTDate: Sun, 15 Jan 89 05:54:25 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901151354.AA11871@bhopal>To: KMP@STONY-BROOK.SCRC.Symbolics.COMCc: Moon@STONY-BROOK.SCRC.Symbolics.COM, Masinter.PA, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Fri, 13 Jan 89 13:47 EST <890113134708.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENT (Version 3)re:  However, it still raises the question of whether we should define     per-function for every CL function whether any of the arguments is     permitted to be "saved" so that CL programs don't get any funny surprises.     If we don't, it ends up being implementor's discretion how to resolve     cases like this, and everyone might not agree that all cases are as      obvious as this one was.PDP10 MacLisp had a similar problem w.r.t pdlnums.  That is why"identity" functions were so troublsome for it -- in order toreturn a guaranteed safe value, it typically had to copy it'spdlnum argument, thereby making some cases of "fast arithmetic" code much worse than interpreted code!  [Remember PRINT in MacLisp?it returns T rather than it's argument for just this reason.]It is necessary for an optimizing compiler to know something aboutwhat happens to the data it passes along to "system" functions; forexample, it could assume that GET doesn't clobber the list givento it, nor does it retain pointers to any part of it [what was theterminology in the revised proposal?  "saved"? and "proper part"?]The issue LISP-SYMBOL-REDEFINITION might help here, in that animplementation's compilers could depend upon it's own internaldatabase.  But it wouldn't hurt at all to have some of theserequirements "up front" in the standard.-- JonL --*start*15222 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 16-Mar-89 12:32:06 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 16 MAR 89 12:31:58 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 16 Mar 89  12:12:39 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 16 MAR 89 12:00:57 PSTDate: 16 Mar 89 11:59 PSTFrom: masinter.paTo: X3J13@sail.stanford.eduline-fold: NOMessage-ID: <890316-120057-5042@Xerox>I think this is one of the more important issues to consider,in that it is addresses one of the most frequently notedperformance issues in Common Lisp. We've examined a large numberof proposals and alternatives to allow declaration of dynamic extent in Common Lisp.!Forum:	CLEANUPIssue:          DYNAMIC-EXTENTReferences:     Scope and ExtentCategory:       ADDITIONEdit history:   27-Jun-88, Version 1 by Pitman (as issue STACK-LET)		15-Nov-88, Version 2 by Pitman (issue renamed, major revision)		11-Jan-89, Version 3 by Masinter (Moon's proposal)Related-Issues: REST-ARGUMENT-EXTENT, WITH-DYNAMIC-EXTENTProblem Description:  Sometimes a programmer knows that a particular data structure  will have only dynamic extent. In some implementations, it is  possible to allocate such structures in a way that will make them  easier to reclaim than by general purpose garbage collection  (eg, on the stack or in some temporary area). Currently, however,  there is no way to request the use of such an allocation mechanism.Proposal (DYNAMIC-EXTENT:NEW-DECLARATION):  Introduce a new declaration called DYNAMIC-EXTENT. The arguments to  this declaration are names of variables. The declaration asserts that  the value which is initially held by the indicated variable will have  dynamic extent. [In the case of an iteration variable, the declaration  asserts that on every iteration, the initial value of that variable  for the iteration will have dynamic extent.]  It is permissible for an implementation to simply ignore this declaration.  In implementations which do not ignore it, the compiler (or interpreter)  is free to make whatever optimizations are appropriate given this  information; the most common optimization is to stack-allocate the  initial value of the object. What data types (if any) can have dynamic  extent will can vary from implementation to implementation.  Since stack allocation of the initial value entails knowing at the  object's creation time that the object can be stack-allocated, it is  not generally useful to declare DYNAMIC-EXTENT for variables for  which have no lexically apparent initial value. For example,	(DEFUN F ()	  (LET ((X (LIST 1 2 3)))	    (DECLARE (DYNAMIC-EXTENT X))	    ...))  would permit those compilers which wish to do so to stack-allocate the  list in X. However,	(DEFUN G (X) (DECLARE (DYNAMIC-EXTENT X)) ...)	(DEFUN F () (G (LIST 1 2 3)))  could not typically permit a similar optimization in G because it would  be a modularity violation for the compiler to assume facts about G from  within F. Only an implementation which was willing to be responsible for  recompiling F if G's definition changed incompatibly could stack-allocate  the list argument to G in F.  Other interesting cases are:	(PROCLAIM '(INLINE G))	(DEFUN G (X) (DECLARE (DYNAMIC-EXTENT X)) ...)	(DEFUN F () (G (LIST 1 2 3)))    and	(DEFUN F ()	  (FLET ((G (X) (DECLARE (DYNAMIC-EXTENT X)) ...))	    (G (LIST 1 2 3))))  where some compilers might realize the optimization was possible and others  might not.  An interesting variant of this is the so-called `stack allocated rest list'  which can be achieved (in implementations supporting the optimization) by:	(DEFUN F (&REST X)	  (DECLARE (DYNAMIC-EXTENT X))	  ...)  Note here that although the initial value of X is not explicit, the F  function is responsible for assembling the list X from the passed arguments,  so the F function can be optimized by the compiler to construct a   stack-allocated list instead of a heap-allocated list in implementations  which support such.   The meaning of a dynamic extent declaration is that execution of the   forms in the scope of the declaration will not "save" any "proper part"   of the initial value of the declared variable.  To "save" an object   means to cause a reference to that object to be accessible outside the   dynamic extent of the form at the beginning of whose body the   declaration appears.  An object can be "saved" by storing it with a   side-effecting operation and not replacing it with a different value   before the end of the dynamic extent, by using it as a component of a   freshly-allocated object that is itself "saved," by capturing it in a   function closure that is itself "saved," by returning it as a value, or   by transmitting it outside the dynamic extent with THROW.  A "proper   part" of an object A is any object that is accessible at the beginning   of the scope of the declaration -only- by applying a function to A or to   a "proper part" of A.  This means that any objects freshly allocated   during the construction of the initial value of the declared variable,   and not "saved" during the construction of that value, are "proper   parts" and can be allocated on a stack.Examples:In            (LET ((X (LIST 'A1 'B1 'C1))                  (Y (CONS 'A2 (CONS 'B2 (CONS 'C2 NIL)))))              (DECLARE (DYNAMIC-EXTENT X Y))              ...)The "proper parts" of X are three conses, and the "proper parts" of Yare three other conses.  None of the symbols A1, B1, C1, A2, B2, C2, orNIL is a "proper part" of X or Y.  However, if a freshly allocateduninterned symbol had been used, it would have been a "proper part."- - - - - - - -          (DOTIMES (I N)             (DECLARE (DYNAMIC-EXTENT I))This is particularly instructive.  Since I is an integer by thedefinition of DOTIMES, but EQ and EQL are not necessarily equivalent forintegers, what are the "proper parts" of I, which this declarationrequires the body of the DOTIMES not to "save"?  If the value of I is 3,and the body does (SETQ FOO 3), is that an error?  The answer is no, butthe interesting thing is that it depends on the implementation-dependentbehavior of EQ on numbers.  In an implementation where EQ and EQL areequivalent for 3, then 3 is not a "proper part" because (EQ I (+ 2 1))is true, and therefore there is another way to access the object besidesgoing through I.  On the other hand, in an implementation where EQ andEQL are not equivalent for 3, then the particular 3 that is the value ofI is a "proper part", but any other 3 is not.  Thus (SETQ FOO 3) is validbut (SETQ FOO I) is erroneous.  Since (SETQ FOO I) is erroneous in someimplementations, it is erroneous in all portable programs, but some otherimplementations may not be able to detect the error.- - - - - - - -  (LET ((X (LIST 1 2 3)))    (DECLARE (DYNAMIC-EXTENT X))    (PRINT X)    NIL)  PRINT does not "save" any part of its input.  This prints (1 2 3)- - - - - - - -  (DO ((L (LIST-ALL-PACKAGES) (CDR L)))      ((NULL L))    (DECLARE (DYNAMIC-EXTENT L))    (PRINT (CAR L)))  prints all packages; none of the newly-allocated list structures are saved.- - - - - - - -  (DEFUN ADD (&REST X) (DECLARE (DYNAMIC-EXTENT X)) (APPLY #'+ X))  (ADD 1 2 3) => 6I.e., useful way to declare that &REST lists have dynamic extent- - - - - - - -  (DEFUN ZAP (X Y Z)    (DO ((L (LIST X Y Z) (CDR L)))	((NULL L))      (DECLARE (DYNAMIC-EXTENT L))      (PRIN1 (CAR L))))  (ZAP 1 2 3)  prints 123- - - - - - - -  (DEFUN ZAP (N M)    ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).    ;; It may be slow, but with a good compiler at least it    ;; doesn't waste much heap storage.  :-)    (LET ((A (MAKE-ARRAY N)))      (DECLARE (DYNAMIC-EXTENT A))      (DOTIMES (I N) 	(DECLARE (DYNAMIC-EXTENT I))	(SETF (AREF A I) (RANDOM (+ I 1))))      (AREF A M)))  (< (ZAP 5 3) 3) => T- - - - - - - -The following are in error, since the value of X is used outside of itsextent:       (LENGTH (LIST (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)))  (PROGN (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)         NIL)- - - - - - - -Rationale:  This permits a programmer to offer advice to an implementation about  what may be stack-allocated for efficiency.  It may be difficult or impossible for a compiler to infer this  same information statically.  Since a number of implementations offer this capability and there  is demand from users for access to the capability, this ``codifies  existing practice.''  Because this approach is purely lexical, it does not interact badly with  other programs in the way that the macro WITH-DYNAMIC-EXTENT (see issue  by same name) would.Current Practice:  Symbolics Genera and Symbolics Cloe offer stack allocation, though not  in this strategy.  [KMP thinks that] Lucid supports the proposal.Cost to Implementors:  No cost is forced since implementations are permitted to simply  ignore the DYNAMIC-EXTENT declaration.Cost to Users:  None. This change is upward compatible.  There may be some hidden costs to debugging using this declaration (or any  feature which permits the user to access dynamic extent objects without  the compiler proving that they are appropriate). If the user misdeclares  something and returns a pointer into the stack (or stores it in the heap),  an undefined situation may result and the integrity of the Lisp storage  mechanism may be compromised. Debugging these situations may be tricky,  but users who have asked for this feature have indicated a willingness  to deal with such costs. Nevertheless, the perils should be clearly  documented and casual users should not be encouraged to use this  declaration.Cost of Non-Adoption:  Some portable code would be forced to run more slowly (due to  GC overhead), or to use non-portable language features.Benefits:  The cost of non-adoption is avoided.Aesthetics:  This declaration allows a fairly low level optimization to work  by asking the user to provide only very high level information.  The alternatives (sharpsign conditionals, some of which may  lead to more bit-picky abstractions) are far less aesthetic.Discussion:  A previous version of this proposal suggested primitives STACK-LET  and STACK-LET*. Consensus was that the more general declaration facility  would be more popular.  Pitman supports the DYNAMIC-EXTENT:NEW-DECLARATION.  Actually, a blurry issue is whether   (LENGTH (LIST (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)))   => 1  is well-defined. I refer to these stack-allocated things as being invalid  return values, but in fact we might want to say that they're ok to return  but that you just can't do any serious operations on them (ie, you can't  expect them to still be lists, etc.) Can anyone imagine a pointer into  unallocated stack causing problems for their GC? If so, we could be more  clear on this point.The examples are tricky:"I hope no one misreads the above as an argument that my proposal is toocomplicated, since it does not derive at all from my proposal, but onlyfrom the way Common Lisp works."!Additional comments:... I really like this rewrite a lot. It's quiteclever in the way it presents things in order to get additional flexibility.However, I do have a few comments I'd like to see addressed before thisgets to a vote... * I like the concept "proper part" a lot but I don't like the name.   The term "proper" for proper lists has to do with well-formed-ness   and in this context you're suggesting an incompatible meaning which   is confusing.      I suggest instead a term like "internal", "intrinsic", "private",   "unshared", etc.      [The concept of "unshared" makes me immediately scared about the    whole quote-may-copy morass, but I don't have time to think through    right now whether that's an issue that needs further clarification    or if it's just a red herring.] * I like the concept of "saved" but it has the problem that it isn't   easy to bring up "out of context" since "save" has a lot of connotations.   If it were possible to come up with a more unique term, I think it   would help in lunch table conversations when people start getting   screwed by things that were `unintentionally saved' and others can't   figure out what they mean out of context. * I think your list of definitions for saved is pretty good, but I'd   still like to see an abstract definition, and then the concrete cases   listed beneath it. That way, we are protected from weird unintentional    interpretations if someone discovers that the set was not exhaustive   and needs to include their new case under the abstract description   because the concrete list doesn't accomodate things. * What about things like:   (DEFUN FOO (&REST X)     (DECLARE (DYNAMIC-EXTENT X))     (MAPL #'PRINT X)     T)   Genera's Dynamic Windows (DW) had bugs in its first release because the   window history recorded the object which was printed. Put another    way, PRINT did unexpected "saving" on some streams. The situation with   DW was treated as a bug and now DW correctly detects stack-allocated   things and does not try to save them, so this would work now.   However, it still raises the question of whether we should define   per-function for every CL function whether any of the arguments is   permitted to be "saved" so that CL programs don't get any funny surprises.   If we don't, it ends up being implementor's discretion how to resolve   cases like this, and everyone might not agree that all cases are as    obvious as this one was.- - - - - - -re:  However, it still raises the question of whether we should define     per-function for every CL function whether any of the arguments is     permitted to be "saved" so that CL programs don't get any funny surprises.     If we don't, it ends up being implementor's discretion how to resolve     cases like this, and everyone might not agree that all cases are as      obvious as this one was.PDP10 MacLisp had a similar problem w.r.t pdlnums.  That is why"identity" functions were so troublsome for it -- in order toreturn a guaranteed safe value, it typically had to copy it'spdlnum argument, thereby making some cases of "fast arithmetic" code much worse than interpreted code!  [Remember PRINT in MacLisp?it returns T rather than it's argument for just this reason.]It is necessary for an optimizing compiler to know something aboutwhat happens to the data it passes along to "system" functions; forexample, it could assume that GET doesn't clobber the list givento it, nor does it retain pointers to any part of it [what was theterminology in the revised proposal?  "saved"? and "proper part"?]The issue LISP-SYMBOL-REDEFINITION might help here, in that animplementation's compilers could depend upon it's own internaldatabase.  But it wouldn't hurt at all to have some of theserequirements "up front" in the standard.*start*03135 00024 US GV-Info: barmar@Think.COM at 16-Mar-89 13:52:26 from AGReturn-Path: <barmar@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 16 MAR 89 13:51:52 PSTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Thu, 16 Mar 89 16:49:45 ESTDate: Thu, 16 Mar 89 16:50 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: DYNAMIC-EXTENTTo: masinter.paCc: X3J13@sail.stanford.eduIn-Reply-To: <890316-120057-5042@Xerox>Message-Id: <19890316215008.1.BARMAR@OCCAM.THINK.COM>    re:  However, it still raises the question of whether we should define	 per-function for every CL function whether any of the arguments is	 permitted to be "saved" so that CL programs don't get any funny surprises.	 If we don't, it ends up being implementor's discretion how to resolve	 cases like this, and everyone might not agree that all cases are as 	 obvious as this one was.    ...    It is necessary for an optimizing compiler to know something about    what happens to the data it passes along to "system" functions; for    example, it could assume that GET doesn't clobber the list given    to it, nor does it retain pointers to any part of it [what was the    terminology in the revised proposal?  "saved"? and "proper part"?]    The issue LISP-SYMBOL-REDEFINITION might help here, in that an    implementation's compilers could depend upon it's own internal    database.  But it wouldn't hurt at all to have some of these    requirements "up front" in the standard.I don't think that solves the problem.  Yes, in a system where PRINTsaves its argument the compiler could detect that in	(defun print-em (&rest stuff)	  (declare (dynamic-extent stuff))	  (print stuff))the declaration is obviously in error and may be ignored (or it mightgenerate a warning).  In the case of Genera Dynamic Windows, whetherPRINT saves is actually an attribute of the stream, so it isquestionable whether the compiler should override the declaration(perhaps the programmer knows that the function will only be called with*STANDARD-OUTPUT* bound to a non-saving stream).  Also, what about thefunction	(defun process-em (&rest stuff)	  (declare (dynamic-extent stuff))	  (frobnicate stuff))If FROBNICATE hasn't been written yet the compiler has no way ofknowing whether it calls any system functions that save the argument.I think that if we really want this declaration (and I'd like to see itincluded, as it is the right compromise for a long-standing problem) weMUST say something about passing dynamic data to standard functions.  Ithink it would be sufficient to say that if the standard doesn't specifythat an argument must be saved then a dynamic object must be acceptable.In other words, if a user reading the standard can't infer that anargument will be saved then a conforming program may pass dynamic datain that argument.  This means that PRINT must accept a dynamic object,and it is the implementation's responsibility to solve the potentialproblems if it normally saves what PRINT prints.                                                barmar*start*01968 00024 US GV-Info: Moon@STONY-BROOK.SCRC.Symbolics.COM at 16-Mar-89 14:15:53 from AGReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 16 MAR 89 14:15:54 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 558915; Thu 16-Mar-89 17:15:26 ESTDate: Thu, 16 Mar 89 17:15 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue DYNAMIC-EXTENT: a remarkTo: Guy Steele <gls@Think.COM>cc: masinter.pa, X3J13@sail.stanford.eduIn-Reply-To: <8903162034.AA05881@verdi.think.com>Message-ID: <19890316221519.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Thu, 16 Mar 89 15:34:53 EST    From: Guy Steele <gls@Think.COM>	  A "proper	  part" of an object A is any object that is accessible at the beginning	  of the scope of the declaration -only- by applying a function to A or to	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^	  a "proper part" of A.  This means that any objects freshly allocated	  during the construction of the initial value of the declared variable,	  and not "saved" during the construction of that value, are "proper	  parts" and can be allocated on a stack.    I believe that the words indicated above should be replaced by    "the extent of the binding for which the delaration was made".That would change the meaning, since the declaration might not be attachedto a binding.    The reference appears to be to a point in time.  Scopes are in space;    the beginning of a scope is a character position in the text (or    something like that).  Extents are in time.  Is this what you meant?You're right that there is something wrong with this wording.  How aboutif it said "at the beginning of execution of the forms in the scope ofthe declaration"?  Do declarations have extents?  If so, could it say"at the beginning of the extent of the declaration"?*start*02456 00024 US GV-Info: gls@Think.COM at 16-Mar-89 12:38:37 from AGReturn-Path: <gls@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 16 MAR 89 12:38:22 PSTReceived: from fafnir.think.com by Think.COM; Thu, 16 Mar 89 15:36:50 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Thu, 16 Mar 89 15:38:04 ESTReceived: by verdi.think.com; Thu, 16 Mar 89 15:34:53 ESTDate: Thu, 16 Mar 89 15:34:53 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903162034.AA05881@verdi.think.com>To: masinter.paCc: X3J13@sail.stanford.eduIn-Reply-To: masinter.pa@xerox.com's message of 16 Mar 89 11:59 PST <890316-120057-5042@Xerox>Subject: Issue DYNAMIC-EXTENT: a remarkThis is the last paragraph of the proposal DYNAMIC-EXTENT:NEW-DECLARATION:      The meaning of a dynamic extent declaration is that execution of the      forms in the scope of the declaration will not "save" any "proper part"      of the initial value of the declared variable.  To "save" an object      means to cause a reference to that object to be accessible outside the      dynamic extent of the form at the beginning of whose body the      declaration appears.  An object can be "saved" by storing it with a      side-effecting operation and not replacing it with a different value      before the end of the dynamic extent, by using it as a component of a      freshly-allocated object that is itself "saved," by capturing it in a      function closure that is itself "saved," by returning it as a value, or      by transmitting it outside the dynamic extent with THROW.  A "proper      part" of an object A is any object that is accessible at the beginning      of the scope of the declaration -only- by applying a function to A or to         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^      a "proper part" of A.  This means that any objects freshly allocated      during the construction of the initial value of the declared variable,      and not "saved" during the construction of that value, are "proper      parts" and can be allocated on a stack.I believe that the words indicated above should be replaced by"the extent of the binding for which the delaration was made".The reference appears to be to a point in time.  Scopes are in space;the beginning of a scope is a character position in the text (orsomething like that).  Extents are in time.  Is this what you meant?--Conan the Pedantrian  (a.k.a. Guy)*start*01677 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 11:13:55 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 10:38:43 PSTReceived: from REAGAN.AI.MIT.EDU by SAIL.Stanford.EDU with TCP; 17 Mar 89  10:32:06 PSTReceived: from ISABEL-PERON.AI.MIT.EDU by REAGAN.AI.MIT.EDU via CHAOS with CHAOS-MAIL id 182328; Fri 17-Mar-89 13:26:45 ESTDate: Fri, 17 Mar 89 13:29 ESTFrom: Richard Mlynarik <Mly@AI.AI.MIT.EDU>Subject: DYNAMIC-EXTENTTo: CL-Cleanup@sail.stanford.eduIn-Reply-To: <890316-120057-5042@Xerox>Message-ID: <19890317182930.6.MLY@ISABEL-PERON.AI.MIT.EDU>I don't see any way in the proposal to declare that a closure itself, rather thanits arguments, has dynamic extent.  My greatest single use for dynamic-extentdeclarations is to ensure stack-consing of closures.Symbolics have a declaration SYS:DOWNWARD-FUNCTION for this case.Perhaps CL could use DYNAMIC-EXTENT-FUNCTION(flet ((test (a b)         (declare (dynamic-extent-function))         ...))  (foo #'test))(foo (lambda (a b)       (declare (dynamic-extent-function))       ...))Another feature which I find sorely needed (and which nobody seemsto support) is a way to declare that the result of a formhas dynamic extent.  For example,  (defmacro with-frob (thunk &body body)    `(let ((*frob-stack* (cons (the dynamic-extent-object ,thunk) *frob-stack*)))       (declare (dynamic-extent *frob-stack*))       ,@body))The idea is to avoid making all users of the with-frob macroput in explicit dynamic-extent-function declarations.*start*02430 00024 US GV-Info: gls@Think.COM at 17-Mar-89 13:15:58 from AGReturn-Path: <gls@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 17 MAR 89 13:15:06 PSTReceived: from fafnir.think.com by Think.COM; Fri, 17 Mar 89 14:55:24 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 17 Mar 89 14:54:21 ESTReceived: by verdi.think.com; Fri, 17 Mar 89 14:51:09 ESTDate: Fri, 17 Mar 89 14:51:09 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903171951.AA09006@verdi.think.com>To: Moon@stony-brook.scrc.symbolics.comCc: gls@Think.COM, masinter.pa, X3J13@sail.stanford.eduIn-Reply-To: David A. Moon's message of Thu, 16 Mar 89 17:15 EST <19890316221519.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue DYNAMIC-EXTENT: a remark   Date: Thu, 16 Mar 89 17:15 EST   From: David A. Moon <Moon@stony-brook.scrc.symbolics.com>   Line-Fold: No       Date: Thu, 16 Mar 89 15:34:53 EST       From: Guy Steele <gls@Think.COM>	     A "proper	     part" of an object A is any object that is accessible at the beginning	     of the scope of the declaration -only- by applying a function to A or to		^^^^^^^^^^^^^^^^^^^^^^^^^^^^	     a "proper part" of A.  This means that any objects freshly allocated	     during the construction of the initial value of the declared variable,	     and not "saved" during the construction of that value, are "proper	     parts" and can be allocated on a stack.       I believe that the words indicated above should be replaced by       "the extent of the binding for which the delaration was made".   That would change the meaning, since the declaration might not be attached   to a binding.I am not certain that I understand the meaningful uses of this declarationin cases where it is not attached to a binding.       The reference appears to be to a point in time.  Scopes are in space;       the beginning of a scope is a character position in the text (or       something like that).  Extents are in time.  Is this what you meant?   You're right that there is something wrong with this wording.  How about   if it said "at the beginning of execution of the forms in the scope of   the declaration"?  Do declarations have extents?  If so, could it say   "at the beginning of the extent of the declaration"?I think you have to speak in terms of run-time instantiationsof executable code.  Not sure.--Guy*start*02640 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 12:31:10 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 12:31:07 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 17 Mar 89  12:27:59 PSTReceived: from fafnir.think.com by Think.COM; Fri, 17 Mar 89 15:23:26 ESTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Fri, 17 Mar 89 15:24:37 ESTReceived: by verdi.think.com; Fri, 17 Mar 89 15:21:24 ESTDate: Fri, 17 Mar 89 15:21:24 ESTFrom: Guy Steele <gls@Think.COM>Message-Id: <8903172021.AA09135@verdi.think.com>To: Mly@ai.ai.mit.eduCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: Richard Mlynarik's message of Fri, 17 Mar 89 13:29 EST <19890317182930.6.MLY@ISABEL-PERON.AI.MIT.EDU>Subject: DYNAMIC-EXTENT   Date: Fri, 17 Mar 89 13:29 EST   From: Richard Mlynarik <Mly@ai.ai.mit.edu>   I don't see any way in the proposal to declare that a closure itself, rather than   its arguments, has dynamic extent.  My greatest single use for dynamic-extent   declarations is to ensure stack-consing of closures.   Symbolics have a declaration SYS:DOWNWARD-FUNCTION for this case.   Perhaps CL could use DYNAMIC-EXTENT-FUNCTION   (flet ((test (a b)	    (declare (dynamic-extent-function))	    ...))     (foo #'test))   (foo (lambda (a b)	  (declare (dynamic-extent-function))	  ...))This is a genuine need.  I suggest(flet ((test (a b) ...))  (declare (dynamic-fextent test))	;So pick a better name  (foo #'test))   Another feature which I find sorely needed (and which nobody seems   to support) is a way to declare that the result of a form   has dynamic extent.  For example,     (defmacro with-frob (thunk &body body)       `(let ((*frob-stack* (cons (the dynamic-extent-object ,thunk) *frob-stack*)))	  (declare (dynamic-extent *frob-stack*))	  ,@body))   The idea is to avoid making all users of the with-frob macro   put in explicit dynamic-extent-function declarations.This proposal has problems.  It is not enough to say"foo has dynamic extent extent".  You have to say somethingabout when it starts and ends.  For executable constructswe implicitly refer to the time execution enters theconstruct and the time execution leaves it.  For objectsit is more difficult, and I claim you need to tie it tocode execution.  How do I know that the "thunk" is supposedto last for the duration of the LET, rather than just theduration of the call to CONS, or the duration of the callerof the macro?--Guy*start*02089 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 17-Mar-89 13:30:03 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 MAR 89 13:28:21 PSTReceived: from REAGAN.AI.MIT.EDU by SAIL.Stanford.EDU with TCP; 17 Mar 89  13:27:36 PSTReceived: from ISABEL-PERON.AI.MIT.EDU by REAGAN.AI.MIT.EDU via CHAOS with CHAOS-MAIL id 182401; Fri 17-Mar-89 16:22:14 ESTDate: Fri, 17 Mar 89 16:24 ESTFrom: Richard Mlynarik <Mly@AI.AI.MIT.EDU>Subject: DYNAMIC-EXTENTTo: gls@think.comcc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <8903172021.AA09135@verdi.think.com>Message-ID: <19890317212454.9.MLY@ISABEL-PERON.AI.MIT.EDU>    Date: Fri, 17 Mar 89 15:21:24 EST    From: Guy Steele <gls@think.com>    This is a genuine need.  I suggest    (flet ((test (a b) ...))      (declare (dynamic-fextent test))	;So pick a better name      (foo #'test))A declaration in the body of the function feels preferable to meas a user -- otherwise it is necessary to create a name for a functionsimply to declare something about it.  There may indeed be semanticreasons to decide otherwise.       Another feature which I find sorely needed (and which nobody seems       to support) is a way to declare that the result of a form       has dynamic extent.    This proposal has problems.  It is not enough to say    "foo has dynamic extent extent".  [...]Forget it.  I was confused (probably by the fact that I use a lispimplementation which has a dynamic-extent declaration within closuresbut no general dynamic-extent declaration in the sense of the proposal.)I should have written my sample macro as(defmacro with-frob (thunk &body body)  (let ((tem (gensym)))    `(let ((,tem ,thunk))       (declare (dynamic-extent ,tem))       (let ((*frob-stack* (cons ,tem *frob-stack*)))         ...))))where I assume that the implementation knows to stack-allocate the `y' in(let* ((foo 1)       (y (lambda () foo)))  (declare (dynamic-extent y))  ... y ...)*start*02440 00024 US Date:  4 Apr 89 11:18 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: DYNAMIC-EXTENTTo: CL-Cleanup%SAIL.Stanford:EDU:Xeroxcc: sandra%defun%CS.Utah:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENTTo: CL-Cleanup@SAIL.Stanford.EDUcc: sandra%defun@CS.Utah.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 11:16:13 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:10:38 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571083; Tue 4-Apr-89 14:10:29 EDTOriginal-Date: Tue, 4 Apr 89 14:10 EDTMessage-ID: <890404141003.4.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVSandra and Gabriel initially claimed to oppose this even in principle.However, Steele and I drafted a revised proposal over lunch Thursday.The text of the revised proposal was: GLS and KMP 3/30/89 Amendment to DYNAMIC-EXTENT:NEW-DECLARATION * Strike sentences 3 and 4 of paragraph 1. * Move paragraphs 3 through n-1 to the examples. * Strike last paragraph. * Add this text after paragraph 1:   _Definition_: Object _x_ is an _otherwise_inaccessible_part_ (OIP)    of _y_ iff making _y_ inaccessible would make _x_ inaccessible.    (Note that every object is an OIP of itself.)   Suppose that construct _c_ contains a DYNAMIC-EXTENT declaration   for variable _v_ (which need not be bound by _c_).  Consider the   values _w1_, ..., _wN_ taken on by _v_ during the course of some   execution of _c_.  The declaration asserts that if object _x_ is   an OIP of _wI_ when _wI_ ever becomes the value of _v_, then   just after execution of _c_ terminates _x_ will be either    inaccessible or still an OIP of _v_.The proposal was also amended in the meeting to say: "If the assertion is ever violated, the conseqeuences are undefined."The fully amended proposal passed 17-0.It was generally agreed that we would also like to consider a proposalon dynamic extent functions at the next meeting. (Sandra said she wouldprepare one, and has already done so. See issue DYNAMIC-EXTENT-FUNCTION.)*start*01925 00024 US Date:  4 Apr 89 11:47 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Re: Issue: DYNAMIC-EXTENTIn-Reply-to: <8904041817.AA19138@defun.utah.edu>To: sandra%defun%cs.utah:EDU:Xeroxcc: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xerox, CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DYNAMIC-EXTENTTo: sandra%defun@cs.utah.educc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8904041817.AA19138@defun.utah.edu>Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 11:30:12 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:26:13 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 571107; 4 Apr 89 14:21:42 EDTOriginal-Date: Tue, 4 Apr 89 14:21 EDTMessage-ID: <890404142113.2.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Tue, 4 Apr 89 12:17:17 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    > Sandra and Gabriel initially claimed to oppose this even in principle.    Gack -- I've been misquoted!  The principle is fine with me and the    revision fixed the thing that bugged me the most (making the    declaration apply to *any* value assigned to the variable instead of    just its initial value) about the original proposal.Ok, I stand corrected -- and I'm glad to see you're happy with whatwe decided.The whole reason I'm distributing this stuff is to make sure my view ofwhat happened aligns with other people's.  I guess if it's catchingdiscrepancies, that's a sign that the process is worthwhile. :-}*start*01655 00024 US Date:  4 Apr 89 11:52 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: sandra%defun%cs.utah:EDU:XeroxSubject: Re: Issue: DYNAMIC-EXTENTIn-Reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Tue, 4 Apr 89 14:10 EDTTo: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xeroxcc: CL-Cleanup%SAIL.Stanford:EDU:Xerox, sandra%defun%cs.utah:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Subject: Re: Issue: DYNAMIC-EXTENTTo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.Stanford.EDU, sandra%defun@cs.utah.eduIn-Reply-To: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Tue, 4 Apr 89 14:10 EDTReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 11:35:26 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 4 Apr 89  11:17:25 PDTReceived: from defun.utah.edu by cs.utah.edu (5.61/utah-2.1-cs)	id AA02524; Tue, 4 Apr 89 12:17:20 -0600Received: by defun.utah.edu (5.61/utah-2.0-leaf)	id AA19138; Tue, 4 Apr 89 12:17:18 -0600Message-Id: <8904041817.AA19138@defun.utah.edu>Original-Date: Tue, 4 Apr 89 12:17:17 MDTGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV> Sandra and Gabriel initially claimed to oppose this even in principle.Gack -- I've been misquoted!  The principle is fine with me and therevision fixed the thing that bugged me the most (making thedeclaration apply to *any* value assigned to the variable instead ofjust its initial value) about the original proposal.-Sandra-------*start*12300 00024 US Date:  5 Apr 89 12:17 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: DYNAMIC-EXTENT (Version 4)To: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENT (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 APR 89 12:01:24 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 5 Apr 89  11:59:13 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571894; Wed 5-Apr-89 14:59:05 EDTOriginal-Date: Wed, 5 Apr 89 14:58 EDTMessage-ID: <890405145837.2.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis was approved but it was so piecemeal it was hard to read so I produceda new copy for reference.I made the changes per our meeting and also changed some usages of"proper part" in the examples to refer to OIP's instead. I trimmedfrom the Discussion and Additional Discussion those things which seemedno longer relevant.I hope this fairly represents the current state of what was approved.-----Forum:	      CleanupIssue:        DYNAMIC-EXTENTReferences:   Scope and ExtentCategory:     ADDITIONEdit history: 27-Jun-88, Version 1 by Pitman (as issue STACK-LET)  	      15-Nov-88, Version 2 by Pitman (issue renamed, major revision)	      11-Jan-89, Version 3 by Masinter (Moon's proposal)	      05-Apr-89, Version 4 by Pitman and Steele (changes per X3J13)Related-Issues: REST-ARGUMENT-EXTENT, WITH-DYNAMIC-EXTENTStatus:	Accepted DYNAMIC-EXTENT:X3J13-MAR-89, 30-Mar-89 on a 17-0 vote.Problem Description:  Sometimes a programmer knows that a particular data structure  will have only dynamic extent. In some implementations, it is  possible to allocate such structures in a way that will make them  easier to reclaim than by general purpose garbage collection  (eg, on the stack or in some temporary area). Currently, however,  there is no way to request the use of such an allocation mechanism.Proposal (DYNAMIC-EXTENT:NEW-DECLARATION):  Introduce a new declaration called DYNAMIC-EXTENT. The arguments to  this declaration are names of variables.  It is permissible for an implementation to simply ignore this declaration.  In implementations which do not ignore it, the compiler (or interpreter)  is free to make whatever optimizations are appropriate given this  information; the most common optimization is to stack-allocate the  initial value of the object. What data types (if any) can have dynamic  extent will can vary from implementation to implementation.  Definition: Object <x> is an ``otherwise inaccessible part'' (OIP)    of <y> iff making <y> inaccessible would make <x> inaccessible.    (Note that every object is an OIP of itself.)  Suppose that construct <c> contains a DYNAMIC-EXTENT declaration for  variable <v> (which need not be bound by <c>).  Consider the values  <w1>, ..., <wN> taken on by <v> during the course of some execution of  <c>.  The declaration asserts that if object <x> is an OIP of <wI>  when <wI> ever becomes the value of <v>, then just after execution of  <c> terminates <x> will be either inaccessible or still an OIP of <v>.  If the assertion is ever violated, the conseqeuences are undefined.Examples:  Since stack allocation of the initial value entails knowing at the  object's creation time that the object can be stack-allocated, it is  not generally useful to declare DYNAMIC-EXTENT for variables for  which have no lexically apparent initial value. For example,	(DEFUN F ()	  (LET ((X (LIST 1 2 3)))	    (DECLARE (DYNAMIC-EXTENT X))	    ...))  would permit those compilers which wish to do so to stack-allocate the  list in X. However,	(DEFUN G (X) (DECLARE (DYNAMIC-EXTENT X)) ...)	(DEFUN F () (G (LIST 1 2 3)))  could not typically permit a similar optimization in G because it would  be a modularity violation for the compiler to assume facts about G from  within F. Only an implementation which was willing to be responsible for  recompiling F if G's definition changed incompatibly could stack-allocate  the list argument to G in F.  Other interesting cases are:	(PROCLAIM '(INLINE G))	(DEFUN G (X) (DECLARE (DYNAMIC-EXTENT X)) ...)	(DEFUN F () (G (LIST 1 2 3)))    and	(DEFUN F ()	  (FLET ((G (X) (DECLARE (DYNAMIC-EXTENT X)) ...))	    (G (LIST 1 2 3))))  where some compilers might realize the optimization was possible and others  might not.  An interesting variant of this is the so-called `stack allocated rest list'  which can be achieved (in implementations supporting the optimization) by:	(DEFUN F (&REST X)	  (DECLARE (DYNAMIC-EXTENT X))	  ...)  Note here that although the initial value of X is not explicit, the F  function is responsible for assembling the list X from the passed arguments,  so the F function can be optimized by the compiler to construct a   stack-allocated list instead of a heap-allocated list in implementations  which support such.In            (LET ((X (LIST 'A1 'B1 'C1))                  (Y (CONS 'A2 (CONS 'B2 (CONS 'C2 NIL)))))              (DECLARE (DYNAMIC-EXTENT X Y))              ...)The OIP's of X are three conses, and the OIP's of Y are three otherconses.  None of the symbols A1, B1, C1, A2, B2, C2, or NIL is anOIP of X or Y.  However, if a freshly allocated uninterned symbol hadbeen used, it would have been an OIP.- - - - - - - -          (DOTIMES (I N)             (DECLARE (DYNAMIC-EXTENT I))This is particularly instructive.  Since I is an integer by thedefinition of DOTIMES, but EQ and EQL are not necessarily equivalent forintegers, what are the OIP's of I, which this declarationrequires the body of the DOTIMES not to "save"?  If the value of I is 3,and the body does (SETQ FOO 3), is that an error?  The answer is no, butthe interesting thing is that it depends on the implementation-dependentbehavior of EQ on numbers.  In an implementation where EQ and EQL areequivalent for 3, then 3 is not an OIP because (EQ I (+ 2 1)) is true,and therefore there is another way to access the object besidesgoing through I.  On the other hand, in an implementation where EQ andEQL are not equivalent for 3, then the particular 3 that is the value ofI is an OIP, but any other 3 is not.  Thus (SETQ FOO 3) is validbut (SETQ FOO I) is erroneous.  Since (SETQ FOO I) is erroneous in someimplementations, it is erroneous in all portable programs, but some otherimplementations may not be able to detect the error.- - - - - - - -  (LET ((X (LIST 1 2 3)))    (DECLARE (DYNAMIC-EXTENT X))    (PRINT X)    NIL)  PRINT does not "save" any part of its input.  This prints (1 2 3)- - - - - - - -  (DO ((L (LIST-ALL-PACKAGES) (CDR L)))      ((NULL L))    (DECLARE (DYNAMIC-EXTENT L))    (PRINT (CAR L)))  prints all packages; none of the newly-allocated list structures are saved.- - - - - - - -  (DEFUN ADD (&REST X) (DECLARE (DYNAMIC-EXTENT X)) (APPLY #'+ X))  (ADD 1 2 3) => 6I.e., useful way to declare that &REST lists have dynamic extent- - - - - - - -  (DEFUN ZAP (X Y Z)    (DO ((L (LIST X Y Z) (CDR L)))	((NULL L))      (DECLARE (DYNAMIC-EXTENT L))      (PRIN1 (CAR L))))  (ZAP 1 2 3)  prints 123- - - - - - - -  (DEFUN ZAP (N M)    ;; Computes (RANDOM (+ M 1)) at relative speed of roughly O(N).    ;; It may be slow, but with a good compiler at least it    ;; doesn't waste much heap storage.  :-)    (LET ((A (MAKE-ARRAY N)))      (DECLARE (DYNAMIC-EXTENT A))      (DOTIMES (I N) 	(DECLARE (DYNAMIC-EXTENT I))	(SETF (AREF A I) (RANDOM (+ I 1))))      (AREF A M)))  (< (ZAP 5 3) 3) => T- - - - - - - -The following are in error, since the value of X is used outside of itsextent:       (LENGTH (LIST (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)))  (PROGN (LET ((X (LIST 1 2 3))) (DECLARE (DYNAMIC-EXTENT X)) X)         NIL)- - - - - - - -Rationale:  This permits a programmer to offer advice to an implementation about  what may be stack-allocated for efficiency.  It may be difficult or impossible for a compiler to infer this  same information statically.  Since a number of implementations offer this capability and there  is demand from users for access to the capability, this ``codifies  existing practice.''  Because this approach is purely lexical, it does not interact badly with  other programs in the way that the macro WITH-DYNAMIC-EXTENT (see issue  by same name) would.Current Practice:  Symbolics Genera and Symbolics Cloe offer stack allocation, though not  in this strategy.  [KMP thinks that] Lucid supports the proposal.Cost to Implementors:  No cost is forced since implementations are permitted to simply  ignore the DYNAMIC-EXTENT declaration.Cost to Users:  None. This change is upward compatible.  There may be some hidden costs to debugging using this declaration (or any  feature which permits the user to access dynamic extent objects without  the compiler proving that they are appropriate). If the user misdeclares  something and returns a pointer into the stack (or stores it in the heap),  an undefined situation may result and the integrity of the Lisp storage  mechanism may be compromised. Debugging these situations may be tricky,  but users who have asked for this feature have indicated a willingness  to deal with such costs. Nevertheless, the perils should be clearly  documented and casual users should not be encouraged to use this  declaration.Cost of Non-Adoption:  Some portable code would be forced to run more slowly (due to  GC overhead), or to use non-portable language features.Benefits:  The cost of non-adoption is avoided.Aesthetics:  This declaration allows a fairly low level optimization to work  by asking the user to provide only very high level information.  The alternatives (sharpsign conditionals, some of which may  lead to more bit-picky abstractions) are far less aesthetic.Discussion:  A previous version of this proposal suggested primitives STACK-LET  and STACK-LET*. Consensus was that the more general declaration facility  would be more popular.  Moon came up with a description of something called a "proper part" which  Steele formalized into the idea of an "otherwise inaccessible part". The  two are essentially interchangeable, but Steele's description was more  rigorous.  KMP: ... it still raises the question of whether we should define        per-function for every CL function whether any of the arguments is       permitted to be "saved" so that CL programs don't get any funny       surprises. If we don't, it ends up being implementor's discretion how       to resolve cases ... and everyone might not agree that all cases are       ... obvious ...  JonL: PDP10 MacLisp had a similar problem w.r.t pdlnums.  That is why	"identity" functions were so troublsome for it -- in order to        return a guaranteed safe value, it typically had to copy it's	pdlnum argument, thereby making some cases of "fast arithmetic" 	code much worse than interpreted code!  [Remember PRINT in MacLisp?	it returns T rather than it's argument for just this reason.]	It is necessary for an optimizing compiler to know something about	what happens to the data it passes along to "system" functions; for	example, it could assume that GET doesn't clobber the list given	to it, nor does it retain pointers to any part of it [what was the	terminology in the revised proposal?  "saved"? and "proper part"?]	The issue LISP-SYMBOL-REDEFINITION might help here, in that an	implementation's compilers could depend upon it's own internal	database.  But it wouldn't hurt at all to have some of these	requirements "up front" in the standard.  It was generally agreed that we would also like to consider a proposal  on dynamic extent functions at the next meeting. (Sandra said she would  prepare one, and has already done so. See issue DYNAMIC-EXTENT-FUNCTION.)*start*01379 00024 US Date:  5 Apr 89 12:27 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: DYNAMIC-EXTENT (Version 4)In-Reply-to: <890405145837.2.KMP@BOBOLINK.SCRC.Symbolics.COM>To: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DYNAMIC-EXTENT (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <890405145837.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 APR 89 12:07:54 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 5 Apr 89  12:06:04 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571908; Wed 5-Apr-89 15:06:07 EDTOriginal-Date: Wed, 5 Apr 89 15:05 EDTMessage-ID: <890405150540.4.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVSigh. As you can probably tell, I meant to change the name of theproposal from NEW-DECLARATION to X3J13-MAR-89 like Masinter's beendoing and I only did it half-way. There's only one proposal soplease don't be confused. Anyway, the text is right so I'm gonnaleave it...