*start*01628 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 21 JUN 88 17:40:23 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 21 Jun 88  17:39:38 PDTReceived: by labrea.stanford.edu; Tue, 21 Jun 88 17:39:43 PDTReceived: from blacksox.lucid.com by edsel id AA21953g; Tue, 21 Jun 88 14:13:19 PDTReceived: by blacksox id AA00406g; Tue, 21 Jun 88 14:12:17 pdtDate: Tue, 21 Jun 88 14:12:17 pdtFrom: Eric Benson <edsel!eb@labrea.stanford.edu>Message-Id: <8806212112.AA00406@blacksox.lucid.com>To: KMP@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: Kent M Pitman's message of Mon, 20 Jun 88 16:14 EDT <880620161405.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Subject: Issue: TRACE-ERROR (Version 1)It seems to me that this is beyond the scope of the cleanup committeeor even the standardization effort.  What you are describing is a bugin a particular implementation of TRACE.  It is a bug because itreduces the usability of TRACE, not because that version of TRACE doesnot conform to some present or future Common Lisp standard.  Send abug report to your Lisp supplier.P.S. As it happens, I think that supplier is Lucid!  I believe thatour TRACE implementation accepts the :WHEREIN keyword but does notimplement its functionality.  As it turns out, I think we can nowimplement :WHEREIN easily, but everyone forgot about it!  Send in abug report and it will go on the queue of things to do.  (I couldsubmit a bug report myself, but customers get higher priority.)*start*03710 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 20 JUN 88 13:16:07 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 20 Jun 88  13:16:01 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 422142; Mon 20-Jun-88 16:14:36 EDTDate: Mon, 20 Jun 88 16:14 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TRACE-ERROR (Version 1)To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880620161405.4.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Issue:        TRACE-ERRORReferences:   TRACE (p440), UNTRACE (p440)Category:     CHANGEEdit history: 20-Jun-88, Version 1 by PitmanStatus:	      For Internal DiscussionProblem Description:  TRACE does not signal an error when given invalid options in  some implementations. For example, more than one implementation  might an extended syntax such as:   (TRACE (FOO {key value}*))  but they might still vary as to what options they provided.  In some such implementations, GET might be used to detect the   options the implementation is interested in, rather than iterating  down the list trying to determine which options really apply.  As such, if   (TRACE (FOO :WHEREIN BAR))  is done by someone used to an implementation that allowed a :WHEREIN  keyword, an implementation might simply ignore the :WHEREIN keyword.  It may not be until a computation is well underway that the ignored  (possibly mis-named or mis-spelled) keyword is detected. Backing up  to retry the trace once the problem is detected may be expensive and  frustrating.Proposal (TRACE-ERROR:REQUIRE-SIGNAL):  Permit the use of non-standard syntax, but require that TRACE and UNTRACE  do careful syntax checking and signal an error if any unknown options  or syntax are used.Test Case:  (TRACE (FOO :WHEREIN BAR))  might mean any of a variety of things, but would not be permitted to just  trace FOO and silently ignore the :WHEREIN option as if it had not been  specified.Rationale:  TRACE is an environmental interface which varies greatly between  implementations. Implementors moving frequently between implementations  can get confused about which implementation they are dealing with and  make mistakes that were trivially avoidable by simple error checking at  the proper time.  Some errors of this kind are not eliminated by this proposal. For example,  two implementations may use the same syntax and/or option in different ways.  However, in many cases where implementations offer extensions, the namings  are not done in a vacuum and they frequently try to agree on naming -- so  this problem is more rare than random chance might suggest. In any case,  this proposal clearly reduces risk of error even if it does not eliminate it.Current Practice:  Implementations are currently permitted to ignore spurious TRACE  options/syntax because of TRACE's weak contract, and many do.Cost to Implementors:  Trivial error checking would have to be added to TRACE and UNTRACE.Cost to Users:  This change is upward compatible.Cost of Non-Adoption:  Some interactive problems would continue to be likely to occur periodically.Benefits:  A possible source of interactive debugging error is removed.Aesthetics:  Users will feel a little safer.Discussion:  Pitman wrote and supports TRACE-ERROR:REQUIRE-SIGNAL.  This issue came up while debugging Macsyma on a system which quietly   ignored what Pitman felt were TRACE options that should either be used  or complained about.*start*01614 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 JUN 88 23:18:29 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 22 Jun 88  23:17:32 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 22 JUN 88 23:16:36 PDTDate: 22 Jun 88 23:06 PDTFrom: masinter.paSubject: Re: Issue: TRACE-ERROR (Version 1)In-reply-to: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>'s message of Mon, 20 Jun 88 16:14 EDTTo: KMP@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880622-231636-3071@Xerox>I would like to separate out, if possible, the requirement for conformance --what it is you have to have to say that you have ANSI Common Lisp -- and thestrong recommendations the standard might make for having an acceptableenvironment. This issue is in many ways like IF-BODY; it attempts to put someconstraints on things that implementations do that aren't part of the standardanyway.I don't know for sure that there is precedent, but I vaguely remember somesimilar wording in other standards documents. I'd like to see the only"standard" for ED, TRACE, BREAK and the other "environment" features be thatthey exist in the Lisp package and that the implementations document what theydo; secondly, we can strongly *recommend* (maybe in the notes) that TRACE doerror checking and that DRIBBLE change the current *terminal-io* rather thanwork with an embedded top-level loop.We certainly gutted DRIBBLE, I don't know why we should turn around and tightenup TRACE.*start*04538 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 23 JUN 88 07:24:58 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 423614; Thu 23-Jun-88 10:24:49 EDTDate: Thu, 23 Jun 88 10:24 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: TRACE-ERROR (Version 1)To: masinter.pacc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880622-231636-3071@Xerox>Message-ID: <880623102431.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: 22 Jun 88 23:06 PDT    From: masinter.pa@Xerox.COM    I would like to separate out, if possible, the requirement for    conformance -- what it is you have to have to say that you have    ANSI Common Lisp -- and the strong recommendations the standard    might make for having an acceptable environment.I'm completely baffled by why anyone thinks this has anything whatsoeverto do with conformance. Conformance has to do with adherence to what iswritten. I'm suggesting we write something different. Whether peopleconform or not will be judged against what we write and is, indeed,something beyond our jurisdiction.    This issue is in many ways like IF-BODY; it attempts to put some    constraints on things that implementations do that aren't part of    the standard anyway.There are things that are intended to be left open and things thatare not. We have to separate them out. I am asserting that the rightto ignore a user's TRACE specification without a hint that that's whatyou're doing is something we don't want to leave open, even if we leaveopen what kinds of TRACE extensions we allow. This is no different thanallowing people to extend COERCE or OPEN or SUBTYPEP, but requiringspecifying that COERCE must signal an error if it can't do the coercionor that OPEN must still return a stream even if the keywords are non-standard or how TYPEP passes back information about the fact that it couldn't do its job correctly.    I don't know for sure that there is precedent, but I vaguely    remember some similar wording in other standards documents. I'd like    to see the only "standard" for ED, TRACE, BREAK and the other    "environment" features be that they exist in the Lisp package and    that the implementations document what they do; I'd be almost ammenable to this except that I'd want to specify that ifthey do nothing they must either return some CL-specified value orelse do typeout informing the user that they did nothing.For example, on the 3600, ED communicates with and/or spins off a newprocess which will run the editor. It therefore returns before it has`done anything'. On the 3600, you have a bar at the bottom of the screenthat tells you that the machine is still busy, so this isn't too baffling.If I were on a machine that did not have a status line at the bottom ofthe screen and called ED only to see it return, I might not know if itwas still doing something in background and might not know how to decidewhen to stop waiting.    secondly, we can strongly *recommend* (maybe in the notes) that TRACE do    error checkingThis would be ok, but since no one has advanced a reason why TRACE shouldnot always do error checking, this is pretty wimpy.    and that DRIBBLE change the current *terminal-io* rather than    work with an embedded top-level loop.People have advanced valid reasons for this not to happen. It's interestingthat you pick these examples because you seem to intend me to be able tosend a bug report to an implementation which doesn't follow the recommendationsaying "gosh, i wish it did" and yet I hope you're not trying to inciteLispm users to riot by inserting a recommendation about DRIBBLE which isnon-binding but which has been shown not to be generally agreed upon by thetechnical community.I personally think there is no place for notes in the standard. Therebindingness on conformity (or lack thereof) is just too confusing.    We certainly gutted DRIBBLE, I don't know why we should turn around and tighten    up TRACE.Not so. We didn't gut DRIBBLE, we acknowledged the status quo (a status quowhich was supported by the existing vague wording). Making any change wouldhave forced some implementation to make an incompatible change. On the otherhand, the proposed change to TRACE is not interestingly incompatible. The twoissues are not at all in the same class as I see it.*start*03285 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 JUN 88 12:01:18 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 22 Jun 88  10:04:05 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 423231; Wed 22-Jun-88 13:03:12 EDTDate: Wed, 22 Jun 88 13:02 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TRACE-ERROR (Version 1)To: edsel!eb@labrea.stanford.educc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <8806212112.AA00406@blacksox.lucid.com>Message-ID: <880622130258.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Tue, 21 Jun 88 14:12:17 pdt    From: Eric Benson <edsel!eb@labrea.stanford.edu>    It seems to me that this is beyond the scope of the cleanup committee    or even the standardization effort.  What you are describing is a bug    in a particular implementation of TRACE.Not necessarily if the documentation doesn't say it's a bug. Some vendorsprefer not to change anything that the standard doesn't require them to change.Also, the time between releases may be very long. And, as far as I can see,there's no good reason I should ever find myself inconvenienced by this problem.    It is a bug because it reduces the usability of TRACE, Few vendors use this criterion in general for determining what's a bugand what's not.    not because that version of TRACE does not conform to some present or    future Common Lisp standard. Certainly not if we don't agree to discuss it in this forum, but that'sa bit self-defeatist.    Send a bug report to your Lisp supplier.But it's not guaranteed to help since I have no leverage.I (wearing my third-party application developer hat) can afford todiscriminate against a CL because it doesn't do floating point or bignumsright, or because it doesn't implement lexical closures, but if it reachesand interesting target market and it doesn't do TRACE right, I'm probablygoing to be stuck using it. Some vendors want to implement just the bareminimum and appeal to the full force of the "is an error" rule whereverpossible. I think that where reasonable we should raise the least commondenominator, and I think a reasonable place to start is in places thatusers (eg, me, in this case) report that there's been a problem.In this particular case, any reasonable vendor is probably going to givein to my demands, but this bug is an easy mistake to make and there's noreason not to put the feature I'm asking for in the standard if only toremind all vendors to get the feature into release 1 of their product.    P.S. As it happens, I think that supplier is Lucid! ...I'm pretty sure it was not.    I believe that our TRACE implementation accepts the :WHEREIN keyword    but does not implement its functionality.[Actually, I just pulled :WHEREIN out of a hat. I don't remember the realkeyword, but I know I never use :WHEREIN. Maybe it was :BREAK...] Anyway,I'm inclined to believe this would be acceptable as long as TRACE doestypeout saying that it was not using the keyword. Anything that tells theuser what's going on.*start*02296 00024 US Date: 25 Mar 89 21:29 PSTFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: TRACE-ERRORTo: chapman%aitg.dec%decwrl.dec:COM:Xeroxcc: KMP%STONY-BROOK.SCRC.Symbolics:COM:Xerox, Masinter:PA:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: TRACE-ERRORTo: chapman%aitg.dec@decwrl.dec.comcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, Masinter.PAReturn-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 25 MAR 89 21:29:00 PSTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 565452; Sun 26-Mar-89 00:28:15 ESTOriginal-Date: Sun, 26 Mar 89 00:27 ESTMessage-ID: <890326002743.7.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVI wrote an issue a while back called TRACE-ERROR which never got anywhere.The issue is that when people do (TRACE ...), some implementations [I thinkVaxlisp was one of the offenders, by the way] do not adequately check theirarguments to make sure all the options you specified really got used.Everyone was [mistakenly, I think] afraid that I was trying to legislate the behavior of the environment on this one.  I've let the issue itselfdrop, but I'd like to talk you into adding a statement like the followingin Notes under TRACE. The idea behind this note is just to remind implementorswho would like to provide useful features without really requiring anyspecific change to any implementation: Although implementations are permitted to extend TRACE to permit non-standard options, implementors are encouraged (but not required) to flag the use of syntax or options which are neither specified by Common Lisp nor by the  implementation. Programmers moving frequently from implementation to  implementation have been known to occassionally forget which implementation offers which options, and to unintentionally use options which are not supported. If unrecognized syntax or options are quietly permitted without any indication to the user that they are being ignored, the programmer can end up running experiments the results of which are unreliable or misleading.-kmp