*start*03498 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 26 JUL 88 16:59:04 PDTReceived: from hub (ucsbcsl.ucsb.edu) by SAIL.Stanford.EDU with TCP; 26 Jul 88  16:57:42 PDTReceived: from csilvax.ucsb.edu by hub (5.59) id AA08778; Tue, 26 Jul 88 16:57:41 PDTReceived: from  by csilvax.ucsb.CSNET (5.51) id AA00851; Tue, 26 Jul 88 16:51:37 PDTDate: Tue, 26 Jul 88 16:51:37 PDTFrom: Skona Brittain <skona%csilvax@hub.ucsb.edu>Posted-Date: Tue, 26 Jul 88 16:51:37 PDTTo: cl-cleanup@SAIL.Stanford.eduSubject: ISSUE: DEFSTRUCT-REDEFINITIONCc: SKONA@csilvax.ucsbIssue:          DEFSTRUCT-REDEFINITIONReferences:     Category:       CLARIFICATIONEdit history:   Revision 1 by Skona Brittain 07/26/88Problem Description:The case of a structure type being redefined is not discussed in CLtL.Proposal (DEFSTRUCT-REDEFINITION:ERROR-ITSELF):It is an error to redefine a structure.Proposal (DEFSTRUCT-REDEFINITION:ERROR-IFF-OLD-USE):Redefining a structure is ok but it is an error to access, in any way,an instance of the structure that was created prior to the redefinition.This applies to instances of other structures that :INCLUDEd the redefined structure. It is also an error to use any of the redefined structures accessorson any instances of a structure that :INCLUDEd the previous definition.Test Cases:(I)(defstruct struc1   slot1 slot2)(setq s (make-struc1 :slot1 1 :slot2 2))(defstruct struc1  ; this is an error according to ERROR-BY-ITSELF   slot2 slot1)    ;          but not according to ERROR-IFF-USE(struc1-slot1 s)   ; this is an error according to ERROR-IFF-USE(II)(defstruct struc1   slot1 slot2)(defstruct (struc2 (:include struc1))  slot 3)(defstruct struc1  slot2 slot1)(setq s (make-struc2 :slot1 1 :slot2 2))(struc1-slot1 s)   ; this is an error according to ERROR-IFF-USERationale:The issue of redefinition should be addressed since there are always consequences that affect use of the structures: at the very least, the constructor function gets overwritten when a structure is redefined.ERROR-BY-ITSELF is simpler, but ERROR-IFF-USED is more amenable to use.Current Practice:None of KCL, Lucid, & Symbolics detect a redefinition, but all of themreturn 2 as the value of the last forms in each of the above test case sets.Cost to Implementors:ERROR-ITSELF:  none if not signaled. extremely slight if signaled.ERROR-IFF-OLD-USE:  none if not signaled. much more if signaled.Cost to Users:ERROR-ITSELF:  It can be quite inconvenient to be prevented from "correcting"a structure definition, which would presumably happen if the error were signaled.ERROR-IFF-OLD-USE:  None.Cost of Non-Adoption:Confusion.Benefits:Clarity.Aethetics:Something that is not well-defined and leads to erratic behavior should be explicitly considered an error.Discussion: Larry supports ERROR-BY-ITSELF, "in that slot-accessors for structures are presumed to be declared "inline".  If users want more flexibility than that, they should use defclass."Various inbetween proposals are possible, such as only incompatible redefinitions cause errors, but they're too hard to define.My feeling is that it's a cop-out to just say it's an error to redefinea structure but then never signal the error - users will still be confusedby the differing seemingly erratic behavior and code. *start*01119 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 28 JUL 88 22:01:19 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 28 Jul 88  22:00:31 PDTReceived: from Burger.ms by ArpaGateway.ms ; 28 JUL 88 21:59:13 PDTFrom: masinter.paDate: 28 Jul 88 21:58:08 PDTSubject: Re: ISSUE: DEFSTRUCT-REDEFINITIONIn-reply-to: skona%csilvax@hub.ucsb.edu's message of Tue, 26 Jul 88 16:51:37 PDTTo: Skona Brittain <skona%csilvax@hub.ucsb.edu>cc: cl-cleanup@SAIL.Stanford.eduMessage-ID: <880728-215913-4668@Xerox>Portable programs should not dynamically redefine structures.Programming environments are allowed, encouraged, etc. to allow suchredefinition, perhaps with warning messages. It is beyond the scope of thelanguage standard to define those interactions, except to note that they are notportable. I don't think it is a cop-out. I certainly don't want an error to be signalled.I'm lacking a good terminology for describing the "is an error" situation that Ithink this should be.*start*01130 00024 US Return-Path: <@multimax.ARPA:pierson%mist@multimax.ARPA>Received: from multimax.ARPA ([192.5.63.14]) by Xerox.COM ; 29 JUL 88 08:03:10 PDTReceived:  by multimax.ARPA (5.51/25-eef)	id AA21344; Fri, 29 Jul 88 11:01:14 EDTReceived: from localhost by mist.UUCP (3.2/4.7)	id AA05303; Fri, 29 Jul 88 11:05:02 EDTMessage-Id: <8807291505.AA05303@mist.UUCP>To: masinter.pa%Xerox.COM@multimax.ARPACc: cl-cleanup%SAIL.Stanford.edu@multimax.ARPASubject: Re: ISSUE: DEFSTRUCT-REDEFINITION In-Reply-To: Your message of 28 Jul 88 21:58:08 -0700.Date: Fri, 29 Jul 88 11:04:58 EDTFrom: Dan L. Pierson <pierson%mist@multimax.ARPA>    Programming environments are allowed, encouraged, etc. to allow such    redefinition, perhaps with warning messages. It is beyond the scope of    the language standard to define those interactions, except to note    that they are not portable.  I don't think it is a cop-out. I    certainly don't want an error to be signalled.  I'm lacking a good    terminology for describing the "is an error" situation that I think    this should be.    Why not "is non-portable"?*start*00939 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 13 SEP 88 06:38:43 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 13 Sep 88  06:37:46 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA23237; Tue, 13 Sep 88 06:36:30 PDTDate: Tue, 13 Sep 88 06:36:30 PDTMessage-Id: <8809131336.AA23237@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: DEFSTRUCT-REDEFINITIONAlthough I tend towards the ideas in DEFSTRUCT-REDEFINITION:ERROR-IFF-OLD-USE,perhaps people would be a little more comfortable if implementations wereencouraged not to treat an "exact" redefinition as an error (either atdefinition time or at access time).There are several references to the proposal alternative ERROR-IFF-USErather than ERROR-IFF-OLD-USE.			---Walter*start*01582 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 15 SEP 88 11:28:57 PDTMessage-ID: <17bcLU@SAIL.Stanford.EDU>Date: 14 Sep 88 22:07 PDTFrom: System Files <SYS@SAIL.Stanford.EDU>Subject: Re: Issue: DEFSTRUCT-REDEFINITION   Received: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Sep 88  22:07:25 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 14 SEP 88 21:31:45 PDTDate: 14 Sep 88 21:31 PDTFrom: masinter.pa@Xerox.COMSubject: Re: Issue: DEFSTRUCT-REDEFINITIONIn-reply-to: vanroggen%aitg.DEC@decwrl.dec.com's message of Tue, 13 Sep 88 06:36:30 PDTTo: cl-cleanup@sail.stanford.eduMessage-ID: <880914-213145-1852@Xerox>Using the new terminology from the error/CLOS proposals, I would say that theresults of an old-use are undefined.At the time the proposal was written, the new terminology wasn't around. I'mlooking for the copy of the new "error terminology" but I seem to have misfiledit...Xerox Common Lisp implements error-if-old-use: if a structure is redefined*incompatibly*, old instances become invalid. An incompatible redefinition isone that changes the number of slots or their type in an incompatible way (i.e.,the total size or the layout of pointer vs. non-pointer fields changes.) Awarning message is printed if the underlying structure changes. We might want to at least reference the redefintion protocol of CLOS.Skona: there's been several comments; are you up for producing a new version?Thanks,Larry*start*03943 00024 US Date:  8 Oct 88 15:44 PDTSender: masinter.paSubject: DRAFT Issue: DEFSTRUCT-REDEFINITION (Version 1)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterThis issue is a draft; we need to sort out the nature ofwhat happens if you redefine a DEFSTRUCT with accessorsthat were previously compiled, old instances, etc.Presumably there is no groundswell for eliminating DEFSTRUCTin favor of DEFCLASS.Issue:          DEFSTRUCT-REDEFINITIONReferences:     Category:       CLARIFICATIONEdit history:   Revision 1 by Skona Brittain 07/26/88Problem Description:The case of a structure type being redefined is not discussed in CLtL.Proposal (DEFSTRUCT-REDEFINITION:ERROR-ITSELF):It is an error to redefine a structure.Proposal (DEFSTRUCT-REDEFINITION:ERROR-IFF-OLD-USE):Redefining a structure is ok but it is an error to access, in any way,an instance of the structure that was created prior to the redefinition.This applies to instances of other structures that :INCLUDEd the redefined structure. It is also an error to use any of the redefined structures accessorson any instances of a structure that :INCLUDEd the previous definition.Test Cases:(I)(defstruct struc1   slot1 slot2)(setq s (make-struc1 :slot1 1 :slot2 2))(defstruct struc1  ; this is an error according to ERROR-BY-ITSELF   slot2 slot1)    ;          but not according to ERROR-IFF-USE(struc1-slot1 s)   ; this is an error according to ERROR-IFF-USE(II)(defstruct struc1   slot1 slot2)(defstruct (struc2 (:include struc1))  slot 3)(defstruct struc1  slot2 slot1)(setq s (make-struc2 :slot1 1 :slot2 2))(struc1-slot1 s)   ; this is an error according to ERROR-IFF-USERationale:The issue of redefinition should be addressed since there are always consequences that affect use of the structures: at the very least, the constructor function gets overwritten when a structure is redefined.ERROR-BY-ITSELF is simpler, but ERROR-IFF-USED is more amenable to use.Current Practice:None of KCL, Lucid, & Symbolics detect a redefinition, but all of themreturn 2 as the value of the last forms in each of the above test case sets.Cost to Implementors:ERROR-ITSELF:  none if not signaled. extremely slight if signaled.ERROR-IFF-OLD-USE:  none if not signaled. much more if signaled.Cost to Users:ERROR-ITSELF:  It can be quite inconvenient to be prevented from "correcting"a structure definition, which would presumably happen if the error were signaled.ERROR-IFF-OLD-USE:  None.Cost of Non-Adoption:Confusion.Benefits:Clarity.Aethetics:Something that is not well-defined and leads to erratic behavior should be explicitly considered an error.Discussion: Larry supports ERROR-BY-ITSELF, "in that slot-accessors for structures are presumed to be declared "inline".  If users want more flexibility than that, they should use defclass."Various inbetween proposals are possible, such as only incompatible redefinitions cause errors, but they're too hard to define.My feeling is that it's a cop-out to just say it's an error to redefinea structure but then never signal the error - users will still be confusedby the differing seemingly erratic behavior and code. -- - - Additional Comments  - - -"Portable programs should not dynamically redefine structures.Programming environments are allowed, encouraged, etc. to allow suchredefinition, perhaps with warning messages. It is beyond the scope of thelanguage standard to define those interactions, except to note that they are notportable. I don't think it is a cop-out. I certainly don't want an error to be signalled.I'm lacking a good terminology for describing the "is an error" situation that Ithink this should be.""Why not "is non-portable"?""We might want to at least reference the redefintion protocol of CLOS"*start*04267 00024 USfReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 15:58:48 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  15:47:25 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 OCT 88 15:44:14 PDTDate: 8 Oct 88 15:44 PDTSender: masinter.paSubject: DRAFT Issue: DEFSTRUCT-REDEFINITION (Version 1)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-154414-2285@Xerox>This issue is a draft; we need to sort out the nature ofwhat happens if you redefine a DEFSTRUCT with accessorsthat were previously compiled, old instances, etc.Presumably there is no groundswell for eliminating DEFSTRUCTin favor of DEFCLASS.!Issue:          DEFSTRUCT-REDEFINITIONReferences:     Category:       CLARIFICATIONEdit history:   Revision 1 by Skona Brittain 07/26/88Problem Description:The case of a structure type being redefined is not discussed in CLtL.Proposal (DEFSTRUCT-REDEFINITION:ERROR-ITSELF):It is an error to redefine a structure.Proposal (DEFSTRUCT-REDEFINITION:ERROR-IFF-OLD-USE):Redefining a structure is ok but it is an error to access, in any way,an instance of the structure that was created prior to the redefinition.This applies to instances of other structures that :INCLUDEd the redefined structure. It is also an error to use any of the redefined structures accessorson any instances of a structure that :INCLUDEd the previous definition.Test Cases:(I)(defstruct struc1   slot1 slot2)(setq s (make-struc1 :slot1 1 :slot2 2))(defstruct struc1  ; this is an error according to ERROR-BY-ITSELF   slot2 slot1)    ;          but not according to ERROR-IFF-USE(struc1-slot1 s)   ; this is an error according to ERROR-IFF-USE(II)(defstruct struc1   slot1 slot2)(defstruct (struc2 (:include struc1))  slot 3)(defstruct struc1  slot2 slot1)(setq s (make-struc2 :slot1 1 :slot2 2))(struc1-slot1 s)   ; this is an error according to ERROR-IFF-USERationale:The issue of redefinition should be addressed since there are always consequences that affect use of the structures: at the very least, the constructor function gets overwritten when a structure is redefined.ERROR-BY-ITSELF is simpler, but ERROR-IFF-USED is more amenable to use.Current Practice:None of KCL, Lucid, & Symbolics detect a redefinition, but all of themreturn 2 as the value of the last forms in each of the above test case sets.Cost to Implementors:ERROR-ITSELF:  none if not signaled. extremely slight if signaled.ERROR-IFF-OLD-USE:  none if not signaled. much more if signaled.Cost to Users:ERROR-ITSELF:  It can be quite inconvenient to be prevented from "correcting"a structure definition, which would presumably happen if the error were signaled.ERROR-IFF-OLD-USE:  None.Cost of Non-Adoption:Confusion.Benefits:Clarity.Aethetics:Something that is not well-defined and leads to erratic behavior should be explicitly considered an error.Discussion: Larry supports ERROR-BY-ITSELF, "in that slot-accessors for structures are presumed to be declared "inline".  If users want more flexibility than that, they should use defclass."Various inbetween proposals are possible, such as only incompatible redefinitions cause errors, but they're too hard to define.My feeling is that it's a cop-out to just say it's an error to redefinea structure but then never signal the error - users will still be confusedby the differing seemingly erratic behavior and code. -- - - Additional Comments  - - -"Portable programs should not dynamically redefine structures.Programming environments are allowed, encouraged, etc. to allow suchredefinition, perhaps with warning messages. It is beyond the scope of thelanguage standard to define those interactions, except to note that they are notportable. I don't think it is a cop-out. I certainly don't want an error to be signalled.I'm lacking a good terminology for describing the "is an error" situation that Ithink this should be.""Why not "is non-portable"?""We might want to at least reference the redefintion protocol of CLOS"*start*00948 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 12:10:08 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 13 Oct 88  12:10:29 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA13980; Thu, 13 Oct 88 12:08:50 PDTDate: Thu, 13 Oct 88 12:08:50 PDTMessage-Id: <8810131908.AA13980@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: DEFSTRUCT-REDEFINITIONI'd favor requiring redefining the same DEFSTRUCT as not being an error.One way to tell that two DEFSTRUCTs are the same (although probably notthe way any implementation would really want to do it) it that twocalls to DEFSTRUCT are the same if they are EQUAL.  It's hard to specifysomething more general that might not get into problems with variousimplementations.			---Walter*start*01014 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:18:26 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:18:44 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475799; Thu 13-Oct-88 16:17:14 EDTDate: Thu, 13 Oct 88 16:17 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFSTRUCT-REDEFINITION (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013161705.8.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Masinter and Gregor will take care of preparing a new writeup.X3J13 meeting: Someone noted there's an unstated relation to CLOS chapter 3. RWK: Typo -- some uses of "ERROR-ITSELF" should be      "ERROR-BY-ITSELF" (or vice versa) for internal consistency.*start*00782 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:38:42 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:37:28 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA19000; Thu, 13 Oct 88 14:35:52 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19844; Thu, 13 Oct 88 14:35:50 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132035.AA19844@defun.utah.edu>Date: Thu, 13 Oct 88 14:35:49 MDTSubject: issue DEFSTRUCT-REDEFINITIONTo: cl-cleanup@sail.stanford.eduI would vote for either of the proposals given here, but I'd feel muchbetter about ERROR-IFF-OLD-USE.-Sandra-------*start*01714 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 OCT 88 19:57:13 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 20 Oct 88  19:55:19 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA08389g; Thu, 20 Oct 88 19:55:06 PDTReceived: by bhopal id AA09021g; Thu, 20 Oct 88 19:53:30 PDTDate: Thu, 20 Oct 88 19:53:30 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810210253.AA09021@bhopal>To: vanroggen%aitg.DEC@decwrl.dec.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: vanroggen%aitg.DEC@decwrl.dec.com's message of Thu, 13 Oct 88 12:08:50 PDT <8810131908.AA13980@decwrl.dec.com>Subject: Issue: DEFSTRUCT-REDEFINITIONre: I'd favor requiring redefining the same DEFSTRUCT as not being an error.    One way to tell that two DEFSTRUCTs are the same (although probably not    the way any implementation would really want to do it) it that two    calls to DEFSTRUCT are the same if they are EQUAL.  It's hard to specify    something more general that might not get into problems with various    implementations.I'll echo your sentiments.One can also have a class of errors called REDEFINITION, meaning thatit wasn't mechanically certifiable that the new definition is compatiblewith the previous one.  I wouldn't mind having the normal state forthis to be merely a warning.  Lucid has a global variable named*REDEFINITION-ACTION* which controls whether such redefinition causewarnings, interactive queries (equivalent to continuable error), or nothing at all.Of course, compile-file might provider a "handler" for REDEFINITION.-- JonL --*start*09232 00024 US Date: 31 Oct 88 10:55 PSTFrom: masinter.paSubject: [cl-cleanup@sail.stanford.edu: DRAFT Issue: DEFSTRUCT-REDEFINITION (Version 1)]To: Gregorcc: masinter.pa"We" were named as producing a new version. Since I've not a good clue to what is currently in Chapter 3, maybe you can help? Or else there should be a chapter 4 which shows how DEFSTRUCT is re-specified in terms of CLOS?     ----- Begin Forwarded Messages -----Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 15:58:48 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  15:47:25 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 08 OCT 88 15:44:14 PDTDate: 8 Oct 88 15:44 PDTSender: masinter.paSubject: DRAFT Issue: DEFSTRUCT-REDEFINITION (Version 1)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-154414-2285@Xerox>This issue is a draft; we need to sort out the nature ofwhat happens if you redefine a DEFSTRUCT with accessorsthat were previously compiled, old instances, etc.Presumably there is no groundswell for eliminating DEFSTRUCTin favor of DEFCLASS.!Issue:          DEFSTRUCT-REDEFINITIONReferences:     Category:       CLARIFICATIONEdit history:   Revision 1 by Skona Brittain 07/26/88Problem Description:The case of a structure type being redefined is not discussed in CLtL.Proposal (DEFSTRUCT-REDEFINITION:ERROR-ITSELF):It is an error to redefine a structure.Proposal (DEFSTRUCT-REDEFINITION:ERROR-IFF-OLD-USE):Redefining a structure is ok but it is an error to access, in any way,an instance of the structure that was created prior to the redefinition.This applies to instances of other structures that :INCLUDEd the redefined structure. It is also an error to use any of the redefined structures accessorson any instances of a structure that :INCLUDEd the previous definition.Test Cases:(I)(defstruct struc1   slot1 slot2)(setq s (make-struc1 :slot1 1 :slot2 2))(defstruct struc1  ; this is an error according to ERROR-BY-ITSELF   slot2 slot1)    ;          but not according to ERROR-IFF-USE(struc1-slot1 s)   ; this is an error according to ERROR-IFF-USE(II)(defstruct struc1   slot1 slot2)(defstruct (struc2 (:include struc1))  slot 3)(defstruct struc1  slot2 slot1)(setq s (make-struc2 :slot1 1 :slot2 2))(struc1-slot1 s)   ; this is an error according to ERROR-IFF-USERationale:The issue of redefinition should be addressed since there are always consequences that affect use of the structures: at the very least, the constructor function gets overwritten when a structure is redefined.ERROR-BY-ITSELF is simpler, but ERROR-IFF-USED is more amenable to use.Current Practice:None of KCL, Lucid, & Symbolics detect a redefinition, but all of themreturn 2 as the value of the last forms in each of the above test case sets.Cost to Implementors:ERROR-ITSELF:  none if not signaled. extremely slight if signaled.ERROR-IFF-OLD-USE:  none if not signaled. much more if signaled.Cost to Users:ERROR-ITSELF:  It can be quite inconvenient to be prevented from "correcting"a structure definition, which would presumably happen if the error were signaled.ERROR-IFF-OLD-USE:  None.Cost of Non-Adoption:Confusion.Benefits:Clarity.Aethetics:Something that is not well-defined and leads to erratic behavior should be explicitly considered an error.Discussion: Larry supports ERROR-BY-ITSELF, "in that slot-accessors for structures are presumed to be declared "inline".  If users want more flexibility than that, they should use defclass."Various inbetween proposals are possible, such as only incompatible redefinitions cause errors, but they're too hard to define.My feeling is that it's a cop-out to just say it's an error to redefinea structure but then never signal the error - users will still be confusedby the differing seemingly erratic behavior and code. -- - - Additional Comments  - - -"Portable programs should not dynamically redefine structures.Programming environments are allowed, encouraged, etc. to allow suchredefinition, perhaps with warning messages. It is beyond the scope of thelanguage standard to define those interactions, except to note that they are notportable. I don't think it is a cop-out. I certainly don't want an error to be signalled.I'm lacking a good terminology for describing the "is an error" situation that Ithink this should be.""Why not "is non-portable"?""We might want to at least reference the redefintion protocol of CLOS"     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 12:10:08 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 13 Oct 88  12:10:29 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA13980; Thu, 13 Oct 88 12:08:50 PDTDate: Thu, 13 Oct 88 12:08:50 PDTMessage-Id: <8810131908.AA13980@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: DEFSTRUCT-REDEFINITIONI'd favor requiring redefining the same DEFSTRUCT as not being an error.One way to tell that two DEFSTRUCTs are the same (although probably notthe way any implementation would really want to do it) it that twocalls to DEFSTRUCT are the same if they are EQUAL.  It's hard to specifysomething more general that might not get into problems with variousimplementations.			---Walter     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:18:26 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:18:44 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475799; Thu 13-Oct-88 16:17:14 EDTDate: Thu, 13 Oct 88 16:17 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFSTRUCT-REDEFINITION (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013161705.8.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: Masinter and Gregor will take care of preparing a new writeup.X3J13 meeting: Someone noted there's an unstated relation to CLOS chapter 3. RWK: Typo -- some uses of "ERROR-ITSELF" should be      "ERROR-BY-ITSELF" (or vice versa) for internal consistency.     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:38:42 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:37:28 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA19000; Thu, 13 Oct 88 14:35:52 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19844; Thu, 13 Oct 88 14:35:50 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132035.AA19844@defun.utah.edu>Date: Thu, 13 Oct 88 14:35:49 MDTSubject: issue DEFSTRUCT-REDEFINITIONTo: cl-cleanup@sail.stanford.eduI would vote for either of the proposals given here, but I'd feel muchbetter about ERROR-IFF-OLD-USE.-Sandra-------     ----- Next Message -----Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 OCT 88 19:57:13 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 20 Oct 88  19:55:19 PDTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA08389g; Thu, 20 Oct 88 19:55:06 PDTReceived: by bhopal id AA09021g; Thu, 20 Oct 88 19:53:30 PDTDate: Thu, 20 Oct 88 19:53:30 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810210253.AA09021@bhopal>To: vanroggen%aitg.DEC@decwrl.dec.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: vanroggen%aitg.DEC@decwrl.dec.com's message of Thu, 13 Oct 88 12:08:50 PDT <8810131908.AA13980@decwrl.dec.com>Subject: Issue: DEFSTRUCT-REDEFINITIONre: I'd favor requiring redefining the same DEFSTRUCT as not being an error.    One way to tell that two DEFSTRUCTs are the same (although probably not    the way any implementation would really want to do it) it that two    calls to DEFSTRUCT are the same if they are EQUAL.  It's hard to specify    something more general that might not get into problems with various    implementations.I'll echo your sentiments.One can also have a class of errors called REDEFINITION, meaning thatit wasn't mechanically certifiable that the new definition is compatiblewith the previous one.  I wouldn't mind having the normal state forthis to be merely a warning.  Lucid has a global variable named*REDEFINITION-ACTION* which controls whether such redefinition causewarnings, interactive queries (equivalent to continuable error), or nothing at all.Of course, compile-file might provider a "handler" for REDEFINITION.-- JonL --     ----- End Forwarded Messages -----*start*01258 00024 USfDate: Wed, 7 Dec 88 19:56 PSTFrom: Gregor.paSubject: Re: [masinter.pa: [cl-cleanup@sail.stanford.edu: DRAFT Issue: DEFSTRUCT-REDEFINITION (Version 1)]]To: masinter.paFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: The message of 7 Dec 88 15:40 PST from masinter.paMessage-ID: <19881208035629.7.GREGOR@PORTNOY.parc.xerox.com>Line-fold: noSorry, but I just don't have the time to write this up just now.  I ambarely managing to do what I have to do.  Chapter 3 can support eitherof the proposals.  As I have written it now, I believe it specifieserror-if-redefined.The only point about the relation to chapter 3 is that chapter 3 gives atechnical language for defining it.  There are really three options:error-if-redefinederror-iff-instances-existerror-iff-usedIn CLOS terminology these are:(defmethod reinitialize-instance ((c structure-class) &rest ignore)  (error "..."))or(defmethod reinitialize-instance ((c structure-class) &rest ignore)  (when (class-finalized-p c)    (error "...")))or"The results are undefined if an instance with metaclass structure-classis accessed after the generic function make-instances-obsolete has beencalled with that class as an argument."-------*start*02350 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 12 DEC 88 09:50:41 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 12 Dec 88  09:49:40 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 12 DEC 88 09:45:21 PSTDate: 12 Dec 88 09:44 PSTFrom: masinter.paSubject: Issue: DEFSTRUCT-REDEFINITION (version 1)To: cl-cleanup@sail.stanford.eduMessage-ID: <881212-094521-4222@Xerox>Perhaps we can bring a new version of this issue with us for distributionat the January meeting.I think the problem is that defstruct accessors are often compiled with"knowledge" of the structure, in a way that defclass accessors are not. Ithink of "defstruct" as "the most efficient defclass", i.e., I'd like toleave maximum room for optimization. However, error-if-redefined seems abit too strong, e.g., if all I do is change the initial value, it doesn'told compiled accessors or even old instances.      ----- Begin Forwarded Messages -----Date: Wed, 7 Dec 88 19:56 PSTFrom: Gregor.paSubject: Re: [masinter.pa: [cl-cleanup@sail.stanford.edu: DRAFT Issue:DEFSTRUCT-REDEFINITION (Version 1)]]To: masinter.paFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: The message of 7 Dec 88 15:40 PST from masinter.paMessage-ID: <19881208035629.7.GREGOR@PORTNOY.parc.xerox.com>Line-fold: noSorry, but I just don't have the time to write this up just now.  I ambarely managing to do what I have to do.  Chapter 3 can support eitherof the proposals.  As I have written it now, I believe it specifieserror-if-redefined.The only point about the relation to chapter 3 is that chapter 3 gives atechnical language for defining it.  There are really three options:error-if-redefinederror-iff-instances-existerror-iff-usedIn CLOS terminology these are:(defmethod reinitialize-instance ((c structure-class) &rest ignore)  (error "..."))or(defmethod reinitialize-instance ((c structure-class) &rest ignore)  (when (class-finalized-p c)    (error "...")))or"The results are undefined if an instance with metaclass structure-classis accessed after the generic function make-instances-obsolete has beencalled with that class as an argument."-------     ----- End Forwarded Messages -----*start*05315 00024 USmReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 30 JUN 88 09:35:13 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 30 Jun 88  09:26:34 PDTReturn-Path: <barmar@Think.COM>Received: from brigit.think.com by Think.COM; Thu, 30 Jun 88 12:24:23 EDTReceived: from OCCAM.THINK.COM by brigit.think.com; Thu, 30 Jun 88 00:12:59 EDTDate: Thu, 30 Jun 88 00:10 EDTFrom: Barry Margolin <barmar@Think.COM>Subject: various DEFSTRUCT issuesTo: cl-cleanup@sail.stanford.eduMessage-Id: <19880630041044.9.BARMAR@OCCAM.THINK.COM>At the X3J13 meeting there was an issue about DEFSTRUCT and duplicatedslot names.  This has caused me to think a bit about some other relatedproblems with DEFSTRUCT.  I haven't really given a whole lot of thoughtto these, but I wanted to get them out to some other people before Iforgot.Issue 1: Slots with STRING-EQUAL namesThis is the one that I briefly mentioned at the meeting.  Consider thefollowing:(in-package 'foo)(defstruct struct  slot1  bar:slot1)The problem with this is that the package of the slot name is generallynot used by DEFSTRUCT.  The constructor takes keyword arguments, so itwould be ambiguous which slot is being initialized by (make-struct:slot1 <val>).  And accessor functions are interned in the package thatis current when the DEFSTRUCT is being expanded, so it would try todefine FOO::STRUCT-SLOT1 as an accessor for both slots.In the case of a single structure definition, like above, it wouldprobably be OK to specify that string-equal slot names are notpermitted.  However, they are more likely to occur when :INCLUDEing astructure in a different package:(in-package 'foo)(defstruct foo-struct  slot1)and in a different file:(in-package 'bar)(defstruct (bar-struct (:include foo:foo-struct))  slot1)In this case you don't have a problem with the accessors, because theyare FOO::FOO-STRUCT-SLOT1 and BAR::BAR-STRUCT-SLOT1.  However, you stillhave a problem with MAKE-BAR-STRUCT, because of the keyword argument.I think the solution to this is to make use of the extension to keywordargument syntax that was done for CLOS.  The keyword arguments tostructure constructors would be the actual name of the argument.However, for back compatibility, we can also specify that :keywords arealso accepted (but we should deprecate this use).  However, it is an errorto use the :keyword version if the structure contains two string-equalslot names.Additionally, the specification of the default printed representation ofstructures must be tightened, as it currently allows the slot names tobe printed in any package.  They should be printed with their correctpackage prefixes.Existing practice: Sun Common Lisp 2.0.3 (Lucid, I believe) detectsattempts to define structures with string-equal slots at defstructexpansion time, whether the conflicting slot comes from inheritance ornot.  Symbolics Common Lisp in Genera 7.2 and Kyoto Common Lisp June 3,1987 don't notice the conflict.  In SCL, (make-bar-struct :slot1 <val>)creates a structure in which both slots contain <val>); in KCL, theFOO::SLOT1 slot contains VAL, while the BAR::SLOT1 slot contains NIL.Regarding printed reps, Symbolics currently prints all the slot names as:keywords; KCL simply PRIN1's the slot name symbols, so it correspondsto my proposal; Sun CL uses no package prefixes at all.Issue 2: Redefining structuresCLOS specifies in greate detail what happens when classes are redefined.What happens when structures are redefined?  Does CLtL discuss thisanywhere?  Assuming existing practice is what I think it is, we shouldprobably specify that it is an error to use a structure accessor orcopier on a structure that was created prior to the redefinition; thismay imply that it is an error to try to print such a structure, as theprint function might use an accessor.But what about redefining :INCLUDEd structures?  What does this do:(defstruct foo  a b)(defstruct (bar (:include foo))  c)(defstruct foo  b a d)How does this redefinition of FOO affect the BAR structure?  In the veryleast, I think my above statement should be taken to imply that any BARscreated before FOO is redefined are no longer accessible using the FOO-accessors.  But what about new structures created by MAKE-BAR after theredefinition?  In all three implementations I tried, the redefinitionhad absolutely no effect on MAKE-BAR, nor on the printing of BARstructures.  The only anomoly is that (foo-b (make-bar :a 1 :b 2)) nowreturns 1; all three apparently implement structures internally asvectors, and accessors are simply AREFs.  One could imagine, however, animplementation that used property lists or alists internally, so thatFOO-B would continue to return the B slot of BAR structures.So, we could say that after redefining a structure, it is an error touse any of its accessors on structures that :INCLUDE that structure butwhich have not been reevaluated/recompiled.  (Actually, that wording ispretty attrocious.)  And after the :INCLUDEing structure is redefined,the :INCLUDEe's accessors may only be used on new instances.                                                barmar*start*05444 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 JAN 89 22:35:32 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Jan 89  22:34:58 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 07 JAN 89 22:30:18 PSTDate: 7 Jan 89 22:29 PSTFrom: masinter.pato: cl-cleanup@sail.stanford.eduSubject: Issue: DEFSTRUCT-REDEFINITION (Version 2)Message-ID: <890107-223018-2952@Xerox>I've not known exactly what to do with this issue even though I said Iwould tackle it. This proposal a fairly arbitrary choice of the options wecould consider, but it is most consistent with my experience of trying tomake DEFSTRUCT efficient. !Status; **DRAFT**Issue:          DEFSTRUCT-REDEFINITIONReferences:     DEFSTRUCT (CLtL pp 305-320)Related-issues: DEFSTRUCT-ACCESS-FUNCTIONS-INLINECategory:       CLARIFICATIONEdit history:   Version 1 by Skona Brittain 07/26/88		Version 2 by Larry Masinter  7-Jan-89Problem Description:The case of a structure type being redefined is not discussed in CLtL. Isit legal to redefine a DEFSTRUCT? What happens to DEFSTRUCTS that :INCLUDEthe one defined. What things might be "wired in" in compiled code thatrefered to the previous DEFSTRUCT?Proposal: (DEFSTRUCT-REDEFINITION:ERROR):Redefining a DEFSTRUCT structure is not portable. The results of doing soare not specified in the standard. Rationale:DEFSTRUCT is intended as "the most efficient" structure class. DEFCLASSallows much more flexible structures to be defined. Thus, implementationsshould be free to "wire in" much of the behavior of a DEFSTRUCT intocompiled code.The issue of redefinition should be addressed since there are alwaysconsequences that affect use of the structures.Current Practice:None of KCL, Lucid, & Symbolics detect a redefinition.Envos Medley goes to some effort to detect if a new structure is"compatible" with the old -- e.g., slots might change names, initialvalues, but, since the space allocated in an instance is determined by the:TYPE, an incompatible set of :TYPE forms would cause old instances to bemarked "obsolete". (The TYPE-OF an old instance changes to **OBSOLETE**,for example.)Cost to Implementors:This proposal attempts to be consistent with current practice.Cost to Users:It is doubtful that any current programs actually define structures morethan once. Thus, constraints on DEFSTRUCT redefinition primarily affect thedebugging environment.Cost of Non-Adoption:Confusion.Benefits:Clarity.Aethetics:Something that is not well-defined and leads to erratic behavior should beexplicitly considered an error.Discussion: Common implementation techniques may cause the following behavior if aDEFSTRUCT is redefined:If the new DEFSTRUCT is identical to the old DEFSTRUCT except for theinitialization forms for slots,  previous structure objects probably cancontinue to be accessed with previously compiled slot accessors. DEFSTRUCTconstructor, test functions are proclaimed INLINE, and if these havechanged, previously compiled occurrences of them may behave unpredictably.If any change is made to the definiton of the slots (either in number,name, or :TYPE), attempting to execute a slot accessor of the olddefinition may behave unpredictably: if a slot name of the old definitionalso names a slot of the new definition, any "compiled" code might use theold definition instead.  DEFSTRUCT constructor, test functions may also be proclaimed INLINE, andmay behave unpredictably if previously compiled. In particular, a compiledoccurance of a constructor might have the previously slot initial values"wired in".If the new DEFSTRUCT differs from the old in any aspect other than theinitialization forms for slots, the results of attempting to access any oldinstance might result in unspecified behavior. For example, if the size ofthe structure became considerably shorter, an old accessor might "accessoff the end" of an instance of a new object; it might signal an error orhave other unpredictable results.Masinter supports this proposal.  If users want more flexibility thanDEFSTRUCT allows, they should use DEFCLASS.Some felt strongly that  just saying it's an error to redefine a structurebut not requiring the error to be signalled will cause users to be confusedby the differing seemingly erratic behavior and code. Programming environments are allowed, encouraged, etc. to allow suchredefinition, perhaps with warning messages. It is beyond the scope of thelanguage standard to define those interactions, except to note that theyare not portable. Here's an example where reexecuting an EQUAL DEFSTRUCT might result indifferent behavior:(defvar *token-counter* 0)(defstruct token (cookie '("unique-string")) (counter (incf*token-counter*)))(defvar *first-token* (make-token))(eql (token-cookie *first-token*) (token-cookie (make-token))) => true(defstruct token (cookie '("unique-string")) (counter (incf*token-counter*))) (eql (token-cookie *first-token*) (token-cookie (make-token))) => falseI.e., even though the second DEFSTRUCT is EQUAL to the first, thestructures are not EQL.This is related to the compiler issue QUOTE-MAY-COPY, but is not the sameissue, since that proposal isn't proposing that QUOTE might copy its value*every time* it is executed.*start*05431 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 FEB 89 13:26:22 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 7 Feb 89  13:25:44 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 07 FEB 89 11:23:12 PSTDate: 6 Feb 89 17:01 PSTFrom: masinter.pato: cl-cleanup@sail.stanford.eduSubject: Issue: DEFSTRUCT-REDEFINITION (Version 3)Message-ID: <890207-112312-1669@Xerox>Accepted, with amendment to use the word "undefined". I presumethat this meant to replace "not specified in the standard." !Status:	Passed (as amended) Jan 89 X3J13Issue:          DEFSTRUCT-REDEFINITIONReferences:     DEFSTRUCT (CLtL pp 305-320)Related-issues: DEFSTRUCT-ACCESS-FUNCTIONS-INLINECategory:       CLARIFICATIONEdit history:   Version 1 by Skona Brittain 07/26/88		Version 2 by Larry Masinter  7-Jan-89		Version 3 by Masinter 6-Feb-89 as per Jan 89 X3J13 amendmentProblem Description:The case of a structure type being redefined is not discussed in CLtL. Isit legal to redefine a DEFSTRUCT? What happens to DEFSTRUCTS that :INCLUDEthe one defined. What things might be "wired in" in compiled code thatrefered to the previous DEFSTRUCT?Proposal: (DEFSTRUCT-REDEFINITION:ERROR):Redefining a DEFSTRUCT structure is not portable. The results of doing soare undefined. Rationale:DEFSTRUCT is intended as "the most efficient" structure class. DEFCLASSallows much more flexible structures to be defined. Thus, implementationsshould be free to "wire in" much of the behavior of a DEFSTRUCT intocompiled code.The issue of redefinition should be addressed since there are alwaysconsequences that affect use of the structures.Current Practice:None of KCL, Lucid, & Symbolics detect a redefinition.Envos Medley goes to some effort to detect if a new structure is"compatible" with the old -- e.g., slots might change names, initialvalues, but, since the space allocated in an instance is determined by the:TYPE, an incompatible set of :TYPE forms would cause old instances to bemarked "obsolete". (The TYPE-OF an old instance changes to **OBSOLETE**,for example.)Cost to Implementors:This proposal attempts to be consistent with current practice.Cost to Users:It is doubtful that any current programs actually define structures morethan once. Thus, constraints on DEFSTRUCT redefinition primarily affect thedebugging environment.Cost of Non-Adoption:Confusion.Benefits:Clarity.Aethetics:Something that is not well-defined and leads to erratic behavior should beexplicitly considered an error.Discussion: Common implementation techniques may cause the following behavior if aDEFSTRUCT is redefined:If the new DEFSTRUCT is identical to the old DEFSTRUCT except for theinitialization forms for slots,  previous structure objects probably cancontinue to be accessed with previously compiled slot accessors. DEFSTRUCTconstructor, test functions are proclaimed INLINE, and if these havechanged, previously compiled occurrences of them may behave unpredictably.If any change is made to the definiton of the slots (either in number,name, or :TYPE), attempting to execute a slot accessor of the olddefinition may behave unpredictably: if a slot name of the old definitionalso names a slot of the new definition, any "compiled" code might use theold definition instead.  DEFSTRUCT constructor, test functions may also be proclaimed INLINE, andmay behave unpredictably if previously compiled. In particular, a compiledoccurance of a constructor might have the previously slot initial values"wired in".If the new DEFSTRUCT differs from the old in any aspect other than theinitialization forms for slots, the results of attempting to access any oldinstance might result in unspecified behavior. For example, if the size ofthe structure became considerably shorter, an old accessor might "accessoff the end" of an instance of a new object; it might signal an error orhave other unpredictable results.Masinter supports this proposal.  If users want more flexibility thanDEFSTRUCT allows, they should use DEFCLASS.Some felt strongly that  just saying it's an error to redefine a structurebut not requiring the error to be signalled will cause users to be confusedby the differing seemingly erratic behavior and code. Programming environments are allowed, encouraged, etc. to allow suchredefinition, perhaps with warning messages. It is beyond the scope of thelanguage standard to define those interactions, except to note that theyare not portable. Here's an example where reexecuting an EQUAL DEFSTRUCT might result indifferent behavior:(defvar *token-counter* 0)(defstruct token (cookie '("unique-string")) (counter (incf*token-counter*)))(defvar *first-token* (make-token))(eql (token-cookie *first-token*) (token-cookie (make-token))) => true(defstruct token (cookie '("unique-string")) (counter (incf*token-counter*))) (eql (token-cookie *first-token*) (token-cookie (make-token))) => falseI.e., even though the second DEFSTRUCT is EQUAL to the first, thestructures are not EQL.This is related to the compiler issue QUOTE-MAY-COPY, but is not the sameissue, since that proposal isn't proposing that QUOTE might copy its value*every time* it is executed.     ----- End Forwarded Messages -----