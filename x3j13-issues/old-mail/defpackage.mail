*start*02168 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 MAR 88 16:16:34 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 12 Mar 88  16:14:22 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 361822; Sat 12-Mar-88 19:14:43 ESTDate: Sat, 12 Mar 88 19:14 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: New issue: DEFPACKAGETo: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUReferences: <19880313000007.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <880312191420.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>I support the general idea of this proposal, but have a few nits to pick...  * I think IN-PACKAGE is broken for being able to demand-create a package.    It serves two unrelated roles, one of which being selection and the other    being creation. Extending it to allow more keywords will worsen the problem.    Given DEFPACKAGE, I would rather see IN-PACKAGE incompatibly changed to NOT    allow demand creation. This would fix a lot of bugs.  * There might should be a :SHADOWING-IMPORT-FROM.  * I think that all options listed as symbol/string should be string-only.    People should be discouraged from naming symbols before the package structure    is fully in place. I'll stop short of suggesting that :IMPORT-FROM and    :SHADOWING-IMPORT-FROM completely replace :IMPORT and :SHADOWING-IMPORT,    which still muck with symbols.  * I'm surprised you left out the Genera :INCLUDE feature, but I guess that    could always be added later if it was seen to be desired so it's ok.  * :PREFIX-NAME is mentioned only in the same. To have it in an integrated fashion,    you'd need a PACKAGE-PREFIX-NAME function and some discussion of that it was    automatically a nickname if not explicitly in the list of names or nicknames.I'm in a hurry so didn't write much on each of these. I can elaborate on any thatare found to be not clear.*start*01295 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 MAR 88 16:48:27 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 12 Mar 88  16:46:24 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Sat 12 Mar 88 19:47:02-ESTDate: Sat, 12 Mar 88 19:46 ESTMessage-ID: <FAHLMAN.12381856106.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: CL-Cleanup@SAIL.STANFORD.EDUSubject: New issue: DEFPACKAGEIn-reply-to: Msg of 12 Mar 1988  19:00-EST from David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>In response to David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>This looks good, as far as it goes, and the fact that it has actuallybeen tested in practice is a big plus -- it tends to give one confidencethat nothign critical has been overlooked.I'm a bit uneasy about the syntax that you propose for the options.  Itwould be more compatible with the rest of Common Lisp to use alternatingkeywords and arguments.  Some users may find the odd syntax of yourDEFPACKAGE to be confusing.  Is there some real advantage to the syntaxyou propose, or is this just a bit of Zetalisp culture peeking through?-- Scott*start*05001 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 12 MAR 88 16:02:27 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 12 Mar 88  15:59:58 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 361817; Sat 12-Mar-88 19:00:11 ESTDate: Sat, 12 Mar 88 19:00 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: New issue: DEFPACKAGETo: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <19880313000007.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Issue:         DEFPACKAGEReferences:    CLtL section 11.7.Category:      ADDITIONEdit history:  Version 1, 12-Mar-88, MoonProblem description:The package functions included in CLtL encourage a programming stylethat tends to evoke the worst aspects of the package system.  Theproblem is that if the definition of a package is scattered througha program, as a number of individual forms, it is very easy to reada symbol before the package setup needed to read that symbol correctlyhas been accomplished.  Three examples: an inherited symbol that shouldhave been shadowed might be accessed; a single-colon prefix might beused for a symbol that will later be exported, causing an error; a localsymbol might be accessed where a symbol that will later be imported orinherited was intended.  These problems can be difficult to understandor even to recognize, are difficult to recover from without completelyrestarting the Lisp, and give Common Lisp a bad name.Proposal (DEFPACKAGE:ADDITION):          Add a DEFPACKAGE macro to the language.  It encourages putting theentire definition of a package in a single place.  It also encouragesputting all the package definitions of a program in a single file, whichcan be loaded before loading or compiling anything that depends on thosepackages.  In addition, it allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Also expand MAKE-PACKAGE and IN-PACKAGE to take all the same keywordarguments as DEFPACKAGE, for consistency.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is either a keyword or a list of a keyword andarguments.  A keyword standing by itself is an abbreviation fora list (keyword T).  Nothing in a DEFPACKAGE form is evaluated.package-name is a symbol or a string; if a symbol, only its namematters.Standard options for DEFPACKAGE are as follows; additional options mightbe present in an implementation, and each implementation must signal anerror if an option not recognized by that implementation is present.Each option may appear at most once.(:EXPORT {symbol/string}*)        Create symbols with the specified names and export them.(:IMPORT {symbol}*)        Import the specified symbols.(:IMPORT-FROM {(package-name {symbol/string}*)}*)(:IMPORT-FROM package-name {symbol/string}*)        Find the specified symbols in the specified packages and import        them into the package being defined.  The second syntax is a        convenient abbreviation when only one package is specified.(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified strings.(:SHADOW {symbol/string}*)        Create the specified symbols in the package and place them        on the shadowing list.(:SHADOWING-IMPORT {symbol}*)        Import the specified symbols into the package and make them        shadow any inherited symbols.(:SIZE integer)        Declare the approximate number of symbols expected in the package.(:USE {package}*)        Inherit from the specified packages.Example:(DEFPACKAGE MY-PACKAGE  (:USE LISP)  (:SHADOW CAR CDR CONS)  (:NICKNAMES MP MYPKG)  (:PREFIX-NAME MYPKG))Rationale:See first paragraph of Proposal section.Current practice:Symbolics Common Lisp has always had this, and uses it in preferenceto individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCL versionof DEFPACKAGE has quite a few additional options, but none of themappear to be necessary to propose for Common Lisp at this time.Cost to Implementors:Should be small as the macro can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:No cost, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:The "Put in seven extremely random user interface commands" businessdescribed at the end of chapter 11 could be removed, and the specialcompiler handling of these functions necessary to support that could beremoved.  As this would be an incompatible change, it is not part ofthis proposal.*start*00842 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 13 MAR 88 16:40:02 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 13 Mar 88  16:37:12 PSTReceived: from Salvador.ms by ArpaGateway.ms ; 13 MAR 88 16:31:47 PSTDate: Sun, 13 Mar 88 16:31:26 PSTFrom: Pavel.paSubject: Re: New issue: DEFPACKAGEIn-reply-to: <19880313000007.3.MOON@EUPHRATES.SCRC.Symbolics.COM>To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880313-163147-1810@Xerox>Just a nit for the moment:	``A keyword standing by itself is an abbreviation for a list (keyword T).''This doesn't appear to be very useful, since none of the options will commonlywant to have an option-argument of T.	Pavel*start*01698 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 MAR 88 01:17:31 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 14 Mar 88  01:14:20 PSTReceived: by labrea.Stanford.EDU; Mon, 14 Mar 88 01:15:04 PSTReceived: from kent-state.lucid.com by edsel id AA11326g; Mon, 14 Mar 88 01:02:08 PSTReceived: by kent-state id AA00538g; Mon, 14 Mar 88 01:10:57 PSTDate: Mon, 14 Mar 88 01:10:57 PSTFrom: Eric Benson <edsel!eb@labrea.Stanford.EDU>Message-Id: <8803140910.AA00538@kent-state.lucid.com>To: Fahlman@c.cs.cmu.eduCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: "Scott E. Fahlman"'s message of Sat, 12 Mar 1988  19:46 EST <FAHLMAN.12381856106.BABYL@C.CS.CMU.EDU>Subject: New issue: DEFPACKAGE   Date: Sat, 12 Mar 1988  19:46 EST   Sender: FAHLMAN@C.CS.CMU.EDU   From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>   In response to David A. Moon <Moon at STONY-BROOK.SCRC.Symbolics.COM>   This looks good, as far as it goes, and the fact that it has actually   been tested in practice is a big plus -- it tends to give one confidence   that nothign critical has been overlooked.   I'm a bit uneasy about the syntax that you propose for the options.  It   would be more compatible with the rest of Common Lisp to use alternating   keywords and arguments.  Some users may find the odd syntax of your   DEFPACKAGE to be confusing.  Is there some real advantage to the syntax   you propose, or is this just a bit of Zetalisp culture peeking through?   -- ScottThis syntax resembles that used for DEFSTRUCT options, so it does havea precedent in CLtL.*start*01935 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 MAR 88 06:01:58 PSTReceived: from REAGAN.AI.MIT.EDU by SAIL.Stanford.EDU with TCP; 14 Mar 88  05:59:06 PSTReceived: from KLYTEMNESTRA.AI.MIT.EDU by REAGAN.AI.MIT.EDU via CHAOS with CHAOS-MAIL id 98596; Mon 14-Mar-88 08:59:27 ESTDate: Mon, 14 Mar 88 08:59 ESTFrom: Richard Mlynarik <MLY@AI.AI.MIT.EDU>Subject: New issue: DEFPACKAGETo: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <FAHLMAN.12381856106.BABYL@C.CS.CMU.EDU>Message-ID: <880314085910.1.MLY@KLYTEMNESTRA.AI.MIT.EDU>    Date: Sat, 12 Mar 1988  19:46 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    I'm a bit uneasy about the syntax that you propose for the options.  It    would be more compatible with the rest of Common Lisp to use alternating    keywords and arguments.  Some users may find the odd syntax of your    DEFPACKAGE to be confusing.  Is there some real advantage to the syntax    you propose, or is this just a bit of Zetalisp culture peeking through?DEFSTRUCT (which nobody has ever accused of having non-`odd' syntax) also suffersfrom the same non-&KEY-style.The saddest things is that this type of syntactical lossage has infectedCLOS DEFxxx, probably because of the precedent in DEFFLAVOR.  I personallydislike the whole style; unfortunately it seems that few others feel stronglyenough about this issue to raise objections.[As an aside, I generally prefer not to use macros whose syntax I can'tdescribe with destructuring lambda-list technology.  Unfortunately,LET doesn't fit into this class, which I hope says something aboutmissing &rest-destructuring functionality rather than about my owninconsistency.]When I implemented DEFPACKAGE some time ago I preferred and advertised&KEY-style, but also allowed "(:keyword option)"-style for compatibility.*start*01314 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 MAR 88 06:41:17 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 14 Mar 88  06:37:36 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Mon 14 Mar 88 09:38:01-ESTDate: Mon, 14 Mar 88 09:37 ESTMessage-ID: <FAHLMAN.12382269523.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: cl-cleanup@SAIL.STANFORD.EDUSubject: DEFPACKAGE syntaxYes, DEFSTRUCT has a syntax similar to what is proposed for DEFPACKAGE.In that case, people can see that DEFSTRUCT is so complex that thesimple alternating keyword/value style wouldn't cut it.  In DEFSTRUCT,the structure has its set of keyword values and each slot does as well.I see no such complexity in DEFPACKAGE, so the question is whether thereis any reason we have to go to a less-familiar syntax in this case.I'm not going to fight to the death over this.  I just thought it wasneedlessly confusing and thought I'd raise the issue while there wasstill time.  On the other side of the balance is the convenience to partof the Common Lisp community of adopting a syntax compatible with theDEFPACKAGE they are already using.-- Scott*start*02817 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 21 MAY 88 05:21:40 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 21 May 88  05:20:44 PDTReceived: by labrea.stanford.edu; Sat, 21 May 88 05:21:08 PDTReceived: from bhopal.lucid.com by edsel id AA19658g; Sat, 21 May 88 05:10:11 PDTReceived: by bhopal id AA08230g; Sat, 21 May 88 05:13:49 PDTDate: Sat, 21 May 88 05:13:49 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805211213.AA08230@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 20 May 88 22:12 EDT <19880521021246.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 2)re: Well, wait a minute.  Either :IMPORT-FROM does exactly the same thing as    :IMPORT in terms of creating symbols that did not already exist, in    which case removing :IMPORT doesn't solve anything, . . . That isn't quite right.  :IMPORT explicitly requires you to put symbolsin the source code, and it is the reading in of that code (with itsliklihood of having bogon-producing :: syntax) that causes the lossage.For example, if your file had in it:	(defpackage my-package (:import 'uluz::bunkie))then the damage to the ULUZ package is done by the reader long before defpackage or :import ever has a chance to muck things up.I suggest removing :IMPORT because the :IMPORT-FROM format can be madeto work given only the symbol-name (not the symbol itself, with it's homepackage known);  there would be no other way to indicate the package information for :IMPORT if you used only symbol-names as arguments.Oddly enough, looking back over the mail on this issue, it seems as thoughKMP wanted to suggest exactly the same thing, in a messaged datedSat, 12 Mar 88 19:14 EST.  Your disagreement with him was phrased asfollows:    I disagree because of alphabetic case issues in strings.  Note that in    these symbol/string arguments, the symbol is being used only for its    name, so there are never any package issues.  . . .but this argument fails to account for the fact that the damage is doneby the reader, when it is required to read in symbols, rather than byany action of defpackage itself.re:   Do you think :IMPORT-FROM should be changed      to be like single-colon package prefix?Well, only in that it not create an entry *** in some other package *** whereone doesn't already exist; I wouldn't necessarily want it to require the symbol to be external.  Yes, I think it would be a tremendous step forward in helping to prevent one of the most obscure nits that even an experienced package user can fall into.-- JonL --*start*04121 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 24 MAY 88 13:58:16 PDTReceived: from JASPER.SCRC.Symbolics.COM ([128.81.41.58]) by SAIL.Stanford.EDU with TCP; 24 May 88  13:55:35 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by JASPER.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 191919; Tue 24-May-88 16:55:27 EDTDate: Tue, 24 May 88 16:55 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 2)To: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <8805211213.AA08230@bhopal.lucid.com>Message-ID: <19880524205536.6.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Sat, 21 May 88 05:13:49 PDT    From: Jon L White <edsel!jonl@labrea.stanford.edu>    re: Well, wait a minute.  Either :IMPORT-FROM does exactly the same thing as	:IMPORT in terms of creating symbols that did not already exist, in	which case removing :IMPORT doesn't solve anything, . . .     That isn't quite right.  :IMPORT explicitly requires you to put symbols    in the source code, and it is the reading in of that code (with its    liklihood of having bogon-producing :: syntax) that causes the lossage.    For example, if your file had in it:	    (defpackage my-package (:import 'uluz::bunkie))    then the damage to the ULUZ package is done by the reader long before     defpackage or :import ever has a chance to muck things up.    I suggest removing :IMPORT because the :IMPORT-FROM format can be made    to work given only the symbol-name (not the symbol itself, with it's home    package known);  there would be no other way to indicate the package     information for :IMPORT if you used only symbol-names as arguments.None of this addresses my comment.  If the user insists on referencing anon-exported symbol of the ULUZ package, what is the difference betweenreferencing (and hence creating) that symbol while reading an argumentto the :IMPORT option, and referencing (and hence creating) that symbolwhile obeying the :IMPORT-FROM option?    Oddly enough, looking back over the mail on this issue, it seems as though    KMP wanted to suggest exactly the same thing, in a messaged dated    Sat, 12 Mar 88 19:14 EST.  Your disagreement with him was phrased as    follows:	I disagree because of alphabetic case issues in strings.  Note that in	these symbol/string arguments, the symbol is being used only for its	name, so there are never any package issues.  . . .Oh, yes, I had forgotten the argument for allowing symbols as argumentswhen strings would do, so people can write their code in lower caseeven though Common Lisp is an upper case language.  Good point.    but this argument fails to account for the fact that the damage is done    by the reader, when it is required to read in symbols, rather than by    any action of defpackage itself.See above.    re:   Do you think :IMPORT-FROM should be changed	  to be like single-colon package prefix?    Well, only in that it not create an entry *** in some other package *** where    one doesn't already exist; I wouldn't necessarily want it to require the     symbol to be external.  Yes, I think it would be a tremendous step forward     in helping to prevent one of the most obscure nits that even an experienced     package user can fall into.Okay, you're proposing that :IMPORT-FROM be changed to do somethingdifferent from any of the previous proposals, namely to callFIND-SYMBOL instead of INTERN or the secret version of INTERN thatsingle-colon uses.  I wish you had come right out and said so.The problem I see with this is that if the user hasn't already donesomething to create the symbol, he gets an error.  Thus the problemwe were trying to address with DEFPACKAGE, of having to load everythingin a certain order or it doesn't work, wouldn't be completely solved.It might be worth it.Then again, maybe this whole problem is a non-problem.  Maybe anybodywho uses the double-colon package prefix is just asking to lose andnothing we do can change that.*start*03721 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 26 MAY 88 21:04:44 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 26 May 88  21:01:23 PDTReceived: by labrea.stanford.edu; Thu, 26 May 88 21:01:47 PDTReceived: from bhopal.lucid.com by edsel id AA20331g; Thu, 26 May 88 20:46:43 PDTReceived: by bhopal id AA06807g; Thu, 26 May 88 20:50:49 PDTDate: Thu, 26 May 88 20:50:49 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8805270350.AA06807@bhopal.lucid.com>To: Moon@stony-brook.scrc.symbolics.comCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 24 May 88 16:55 EDT <19880524205536.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 2)re: None of this addresses my comment.  If the user insists on referencing a    non-exported symbol of the ULUZ package, what is the difference between    referencing (and hence creating) that symbol while reading an argument    to the :IMPORT option, and referencing (and hence creating) that symbol    while obeying the :IMPORT-FROM option?I think you must have made this comment before reading the rest of my notethat you are replying to.re: Okay, you're proposing that :IMPORT-FROM be changed to do something    different from any of the previous proposals, namely to call    FIND-SYMBOL instead of INTERN or the secret version of INTERN that    single-colon uses.  I wish you had come right out and said so.The situation is not quite so simple as that.  I do favor altering the actionof :IMPORT-FROM in the way you deduce, since that would afford a much greater measure of package integrity than is now common practice.  However, I *strongly* favor removing the requirement for symbols, even if we can't agree on the first alteration just mentioned.  The reason why this latter semi-proposal affords a difference over doing nothing is two-fold:   (1) Certain kinds of non-EVAL file processors may be able to read this       form  without evaluating it (cross-reference programs come to mind);      thus reading in the form with symbols in it  "damages" the ULUZ package      in a way that "processing" alone would not.  (2) Many more soure-file/compile-file incompatibilities can easily be      turned up when the source-file has double-colon qualifications in      it.  Thus apart from any evaluaton action of the defpackage form,      there is a possibility that compiled form of the file has different,      and ocasionlly much worse, side effects than the source file.For example:  Source file:      (DEFPACKAGE  "FOO"  (:IMPORT 'uluz::bunkie))  Compiled-file: [actions, more or less]      1. intern DEFPACKAGE in current package [probably inherit from CL]      2. make string "FOO"      3. intern BUNKIE in what package????? depends on how that symbol	 was accessible at compile time.  The fact that the user specified	 it as uluz::bunkie is completely and totally lost after the source	 code has been read-in!      4. intern IMPORT in the keyword package      5. call EVAL on cons'd-up formIn fact, the original motivation that caused me to start discussing adefpackage months and months ago was the frequency at which "vanilla"code can be read-in differently after being compiled [differently, becauseof the information-losing property of double-colon format].  So even if:IMPORT-FROM were to continue in its present (Symbolics) semantics, it wouldstill be of some benefit to use strings as args rather than symbols, in orderto prevent the occurance of obscure source/compiled-file differences.-- JonL --*start*06939 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAR 88 11:53:44 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Mar 88  11:49:49 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 368796; Wed 23-Mar-88 14:49:59 ESTDate: Wed, 23 Mar 88 14:49 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 2)To: CL-Cleanup@SAIL.STANFORD.EDUReferences: <19880313000007.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19880323194958.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Issue:         DEFPACKAGEReferences:    CLtL section 11.7.Category:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussionProblem description:The package functions included in CLtL encourage a programming stylethat tends to evoke the worst aspects of the package system.  Theproblem is that if the definition of a package is scattered througha program, as a number of individual forms, it is very easy to reada symbol before the package setup needed to read that symbol correctlyhas been accomplished.  Three examples: an inherited symbol that shouldhave been shadowed might be accessed; a single-colon prefix might beused for a symbol that will later be exported, causing an error; a localsymbol might be accessed where a symbol that will later be imported orinherited was intended.  These problems can be difficult to understandor even to recognize, are difficult to recover from without completelyrestarting the Lisp, and give Common Lisp a bad name.Proposal (DEFPACKAGE:ADDITION):          Add a DEFPACKAGE macro to the language.  It encourages putting theentire definition of a package in a single place.  It also encouragesputting all the package definitions of a program in a single file, whichcan be loaded before loading or compiling anything that depends on thosepackages.  This file can be read in the USER package, avoiding anypackage bootstrapping issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Also expand MAKE-PACKAGE and IN-PACKAGE to take all the same keywordarguments as DEFPACKAGE, for consistency.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.package-name is a symbol or a string; if a symbol, only its namematters, not what package it is in.  If a string, capitalizationmatters, normally uppercase is used.Standard options for DEFPACKAGE are listed below.  Additional optionsmight be present in an implementation, and each implementation mustsignal an error if an option not recognized by that implementation ispresent.  Additional implementation-dependent options might take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.Each option may appear at most once.  If duplicate options are present,DEFPACKAGE signals an error.(:EXPORT {symbol}*)        Create symbols with the specified names and export them.        Note that only the name of each argument symbol is used.        The symbol that gets exported is not necessarily the one given        as an argument; it's a symbol with that name but in the package        being defined.(:IMPORT {symbol}*)        Import the specified symbols.(:IMPORT-FROM {(package-name {symbol}*)}*)(:IMPORT-FROM package-name {symbol}*)        Find the specified symbols in the specified packages and import        them into the package being defined.  The second syntax is a        convenient abbreviation when only one package is specified.        Note that only the name of each argument symbol is used.  The        actual symbol that gets imported is not necessarily the one        given as an argument; it's a symbol with that name accessible in        the named package.(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified strings.(:SHADOW {symbol}*)        Create the specified symbols in the package and place them on        the shadowing list.  Note that only the name of each argument        symbol is used.(:SHADOWING-IMPORT {symbol}*)        Import the specified symbols into the package and make them        shadow any inherited symbols.(:SHADOWING-IMPORT-FROM {(package-name {symbol}*)}*)(:SHADOWING-IMPORT-FROM package-name {symbol}*)        Find the specified symbols in the specified packages and import        them into the package being defined, making them shadow any        inherited symbols.  The second syntax is a convenient        abbreviation when only one package is specified.  Note that only        the name of each argument symbol is used.  The actual symbol        that gets imported is not necessarily the one given as an        argument; it's a symbol with that name accessible in the named        package.(:SIZE integer)        Declare the approximate number of symbols expected in the package.(:USE {package}*)        Inherit from the specified packages.Example:(DEFPACKAGE MY-PACKAGE  (:USE LISP)  (:SHADOW CAR CDR CONS)  (:NICKNAMES MYPKG MY-PKG))Rationale:See first paragraph of Proposal section.Current practice:Symbolics Common Lisp has always had this, and uses it in preferenceto individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCL versionof DEFPACKAGE has quite a few additional options, but none of themappear to be necessary to propose for Common Lisp at this time.Cost to Implementors:Should be small as the macro can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:No cost, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:The "Put in seven extremely random user interface commands" businessdescribed at the end of chapter 11 could be removed, and the specialcompiler handling of these functions necessary to support that could beremoved.  As this would be an incompatible change, it is not part ofthis proposal.KMP suggests that IN-PACKAGE should be incompatibly changed only torecognize existing packages, not to create them, which would fix a lotof bugs.  IN-PACKAGE would then not accept any keyword arguments.Moon thinks this is a reasonable idea but should be the subject of aseparate proposal.*start*06671 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 MAR 88 11:54:35 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 23 Mar 88  11:50:50 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 368789; 23 Mar 88 14:45:34 ESTDate: Wed, 23 Mar 88 14:45 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: New issue: DEFPACKAGETo: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>, Scott E. Fahlman <Fahlman@C.CS.CMU.EDU>, Pavel.pa, Eric Benson <edsel!eb@labrea.Stanford.EDU>, Richard Mlynarik <MLY@AI.AI.MIT.EDU>cc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880312191420.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>,             <FAHLMAN.12381856106.BABYL@C.CS.CMU.EDU>,             <880313-163147-1810@Xerox>,             <8803140910.AA00538@kent-state.lucid.com>,             <880314085910.1.MLY@KLYTEMNESTRA.AI.MIT.EDU>,             <FAHLMAN.12382269523.BABYL@C.CS.CMU.EDU>Message-ID: <19880323194526.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoHere are my responses to comments received.  My next message will be arevised version of the proposal.    Date: Sat, 12 Mar 88 19:14 EST    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    I support the general idea of this proposal, but have a few nits to pick...      * I think IN-PACKAGE is broken for being able to demand-create a package.	It serves two unrelated roles, one of which being selection and the other	being creation. Extending it to allow more keywords will worsen the problem.	Given DEFPACKAGE, I would rather see IN-PACKAGE incompatibly changed to NOT	allow demand creation. This would fix a lot of bugs.Agreed, but I think that should be a separate proposal.  Added to thediscussion section.      * There might should be a :SHADOWING-IMPORT-FROM.Agreed.      * I think that all options listed as symbol/string should be string-only.	People should be discouraged from naming symbols before the package structure	is fully in place. I'll stop short of suggesting that :IMPORT-FROM and	:SHADOWING-IMPORT-FROM completely replace :IMPORT and :SHADOWING-IMPORT,	which still muck with symbols.I disagree because of alphabetic case issues in strings.  Note that inthese symbol/string arguments, the symbol is being used only for itsname, so there are never any package issues.  For instance, in :EXPORT,if a symbol is given, the symbol that is exported from the package isnot necessarily that same symbol.  It's a symbol with that name in thepackage being defined.  After looking at CLtL's writeup of SHADOW again,I changed all of these to be symbol-only.      * I'm surprised you left out the Genera :INCLUDE feature, but I guess that	could always be added later if it was seen to be desired so it's ok.I was not trying to propose any extensions to the semantics of packages.(:INCLUDE is a Zetalisp release 4 compatibility feature that allows usingpackage A to automatically imply using package B as well.)      * :PREFIX-NAME is mentioned only in the same. To have it in an integrated fashion,	you'd need a PACKAGE-PREFIX-NAME function and some discussion of that it was	automatically a nickname if not explicitly in the list of names or nicknames.This was an editing error.  I didn't mean to propose the prefix-nameextension.  (Prefix-name provides control over which name or nickname ofa package the printer uses when printing a symbol.)    Date: Sun, 13 Mar 88 16:31:26 PST    From: Pavel.pa@Xerox.COM    Just a nit for the moment:	    ``A keyword standing by itself is an abbreviation for a list (keyword T).''    This doesn't appear to be very useful, since none of the options will commonly    want to have an option-argument of T.Right.  This should have been in the part about implementation-dependent options.I seem to have been pretty careless in the editing of this proposal.    Date: Sat, 12 Mar 1988  19:46 EST    From: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>    This looks good, as far as it goes, and the fact that it has actually    been tested in practice is a big plus -- it tends to give one confidence    that nothign critical has been overlooked.Thanks.    I'm a bit uneasy about the syntax that you propose for the options.  It    would be more compatible with the rest of Common Lisp to use alternating    keywords and arguments.  Some users may find the odd syntax of your    DEFPACKAGE to be confusing.  Is there some real advantage to the syntax    you propose, or is this just a bit of Zetalisp culture peeking through?Symbolics has a very large number of macros that work this way, and we havefound it to be easier to use and less confusing than alternating keywordsand arguments.  For one thing, it decreases the common confusion among bothnaive and experienced users, in which they think they are supposed to putin a ' in front of an argument when invoking a macro, as they would whencalling a function.  Another point is that the semantics of duplicatedkeywords is different.  In a function call, Common Lisp specifies thatduplicate appearances of a keyword argument after the first are to beignored.  In a macro, duplicate options should certainly not be ignored;either the options should be combined in some way or an error should besignalled, depending on the semantics of the particular option.  I reallybelieve that a list of option name and arguments is the best syntax formacros that take a bunch of options that are really a special-purposelanguage for describing something.With CLOS, Common Lisp will acquire several more macros that use thissyntax for options, which should make it less of a surprise to users whohave not seen this before.    Date: Mon, 14 Mar 88 01:10:57 PST    From: Eric Benson <edsel!eb@labrea.Stanford.EDU>    This syntax resembles that used for DEFSTRUCT options, so it does have    a precedent in CLtL.Right.    Date: Mon, 14 Mar 88 08:59 EST    From: Richard Mlynarik <MLY@AI.AI.MIT.EDU>    DEFSTRUCT (which nobody has ever accused of having non-`odd' syntax) also suffers    from the same non-&KEY-style.    The saddest things is that this type of syntactical lossage has infected    CLOS DEFxxx, probably because of the precedent in DEFFLAVOR.  I personally    dislike the whole style; unfortunately it seems that few others feel strongly    enough about this issue to raise objections.I have to strongly disagree with you here, for the reasons alluded to earlier.*start*07050 00024 USfDate:  8 Jun 88 19:16 PDTFrom: Masinter.paSubject: Issue: DEFPACKAGE (version 2)To: X3J13@Sail.Stanford.EDUcc: Masinterreply-to: CL-Cleanup@Sail.stanford.eduline-fold: NOThis issue is still a DRAFT. The ongoing discussion, however, centers around the details of the operations of some of the keyword arguments(e.g., should :IMPORT-FROM take strings instead of/as well as symbols.)Status: DRAFT - for discussion at June 1988 X3J13 meeting Issue:         DEFPACKAGEReferences:    CLtL section 11.7.Category:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussionProblem description:The package functions included in CLtL encourage a programming stylethat tends to evoke the worst aspects of the package system.  Theproblem is that if the definition of a package is scattered througha program, as a number of individual forms, it is very easy to reada symbol before the package setup needed to read that symbol correctlyhas been accomplished.  Three examples: an inherited symbol that shouldhave been shadowed might be accessed; a single-colon prefix might beused for a symbol that will later be exported, causing an error; a localsymbol might be accessed where a symbol that will later be imported orinherited was intended.  These problems can be difficult to understandor even to recognize, are difficult to recover from without completelyrestarting the Lisp, and give Common Lisp a bad name.Proposal (DEFPACKAGE:ADDITION):          Add a DEFPACKAGE macro to the language.  It encourages putting theentire definition of a package in a single place.  It also encouragesputting all the package definitions of a program in a single file, whichcan be loaded before loading or compiling anything that depends on thosepackages.  This file can be read in the USER package, avoiding anypackage bootstrapping issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Also expand MAKE-PACKAGE and IN-PACKAGE to take all the same keywordarguments as DEFPACKAGE, for consistency.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.package-name is a symbol or a string; if a symbol, only its namematters, not what package it is in.  If a string, capitalizationmatters, normally uppercase is used.Standard options for DEFPACKAGE are listed below.  Additional optionsmight be present in an implementation, and each implementation mustsignal an error if an option not recognized by that implementation ispresent.  Additional implementation-dependent options might take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.Each option may appear at most once.  If duplicate options are present,DEFPACKAGE signals an error.(:EXPORT {symbol}*)        Create symbols with the specified names and export them.        Note that only the name of each argument symbol is used.        The symbol that gets exported is not necessarily the one given        as an argument; it's a symbol with that name but in the package        being defined.(:IMPORT {symbol}*)        Import the specified symbols.(:IMPORT-FROM {(package-name {symbol}*)}*)(:IMPORT-FROM package-name {symbol}*)        Find the specified symbols in the specified packages and import        them into the package being defined.  The second syntax is a        convenient abbreviation when only one package is specified.        Note that only the name of each argument symbol is used.  The        actual symbol that gets imported is not necessarily the one        given as an argument; it's a symbol with that name accessible in        the named package.(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified strings.(:SHADOW {symbol}*)        Create the specified symbols in the package and place them on        the shadowing list.  Note that only the name of each argument        symbol is used.(:SHADOWING-IMPORT {symbol}*)        Import the specified symbols into the package and make them        shadow any inherited symbols.(:SHADOWING-IMPORT-FROM {(package-name {symbol}*)}*)(:SHADOWING-IMPORT-FROM package-name {symbol}*)        Find the specified symbols in the specified packages and import        them into the package being defined, making them shadow any        inherited symbols.  The second syntax is a convenient        abbreviation when only one package is specified.  Note that only        the name of each argument symbol is used.  The actual symbol        that gets imported is not necessarily the one given as an        argument; it's a symbol with that name accessible in the named        package.(:SIZE integer)        Declare the approximate number of symbols expected in the package.(:USE {package}*)        Inherit from the specified packages.Example:(DEFPACKAGE MY-PACKAGE  (:USE LISP)  (:SHADOW CAR CDR CONS)  (:NICKNAMES MYPKG MY-PKG))Rationale:See first paragraph of Proposal section.Current practice:Symbolics Common Lisp has always had this, and uses it in preferenceto individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCL versionof DEFPACKAGE has quite a few additional options, but none of themappear to be necessary to propose for Common Lisp at this time.Cost to Implementors:Should be small as the macro can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:No cost, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:The "Put in seven extremely random user interface commands" businessdescribed at the end of chapter 11 could be removed, and the specialcompiler handling of these functions necessary to support that could beremoved.  As this would be an incompatible change, it is not part ofthis proposal.KMP suggests that IN-PACKAGE should be incompatibly changed only torecognize existing packages, not to create them, which would fix a lotof bugs.  IN-PACKAGE would then not accept any keyword arguments.Moon thinks this is a reasonable idea but should be the subject of aseparate proposal.        TITAN 
         TITAN 
          
TIMESROMAN 
          Š              4                                          
              c             9              ‚       	       ]              +                           d              &              6       
       K                           M      û !zº*start*00835 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 SEP 88 12:27:49 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Sep 88  12:25:57 PDTReceived: from Burger.ms by ArpaGateway.ms ; 14 SEP 88 12:08:35 PDTDate: 14 Sep 88 12:07 PDTFrom: masinter.paSubject: Re: Issue: DEFPACKAGE (version 2)In-reply-to: Masinter.pa's message of 8 Jun 88 19:16 PDTTo: CL-Cleanup@Sail.stanford.educc: masinter.paMessage-ID: <880914-120836-2043@Xerox>There's been no discussion on this proposal since 8 Jun, when it was distributedin draft form to X3J13. I am taking this to mean that people are not unhappywith the version of 23-Mar-88 -- at least not unhappy enough to complain orsuggest improvements.*start*05222 00024 USfReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 20 SEP 88 10:18:38 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04438g; Tue, 20 Sep 88 09:18:09 PSTReceived: by bhopal id AA18425g; Tue, 20 Sep 88 10:17:37 PDTDate: Tue, 20 Sep 88 10:17:37 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809201717.AA18425@bhopal>To: masinter.paCc: CL-Cleanup@Sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 14 Sep 88 12:07 PDT <880914-120836-2043@Xerox>Subject: Issue: DEFPACKAGE (version 2)re: There's been no discussion on this proposal since 8 Jun, when it was     distributed in draft form to X3J13. I am taking this to mean that people     are not unhappy with the version of 23-Mar-88 -- at least not unhappy     enough to complain or suggest improvements.Not so.  When you distributed the draft in June, I reminded you then thatI had serious objections to one part of this proposal, and that moonhadn't addressed them satisfactorily at that time.A series of messages took place on "Cleanup" after I sent out the onereproduced below.  Moon acceeded to the first point one, but never came to any resolution about point two -- to flush two redundant and *dangerous*options :IMPORT and :SHADOWING-IMPORT.   There still has not been a revisedversion of the proposal circulated; presumably the revision should wait until the second point is resolved.-- JonL ---------------------------------------------------------------------------------    Date: Tue, 17 May 88 02:05:55 PDT    From: Jon L White <edsel!jonl@labrea.stanford.edu>    To: Moon@stony-brook.scrc.symbolics.com    Cc: CL-Cleanup@sail.stanford.edu    In-Reply-To: David A. Moon's message of Wed, 23 Mar 88 14:49 EST ...    Subject: Issue: DEFPACKAGE (version 2)    There is one very dangerous loophole in this proposal, which could be    trivially plugged up.  The issue is whether symbols are a critical    arugment to any of the options, or whether "names" would be satisfactory.    What would you say to the following alterations:      (1) Change most uses of the meta-variable {symbol} to {name}, with	  an explicit statement that such a {name} must be either a string,	  or a symbol.  Thus the description of :IMPORT-FROM would go from 	    (:IMPORT-FROM {(package-name {symbol}*)}*)	  to	    (:IMPORT-FROM {(package-name {name}*)}*)	  or maybe even	    (:IMPORT-FROM {(package-name {symbol-name}*)}*)	  Change also the phrase "Note that only the name of each argument symbol 	  is used." to something like "Note that only the name of each argument	  is used; if a symbol is passed, its symbol-name is used".      (2) Flush the two options that require symbols, as opposed to names --	  namely :IMPORT and :SHADOWING-IMPORT.  Note that these are the only 	  two that don't have the phrase "Note that only the name of each 	  argument symbol is used." in their description.  These two options 	  are superfluous since their functionality is completely covered by 	  :IMPORT-FROM and :SHADOWING-IMPORT-FROM.    The :IMPORT option as currently specified makes it all too easy to violate     reasonable package modularity rules -- e.g. (:IMPORT foo::bar) -- without     considering the warning given on CLtL p175 (top of page) "... since     accessing an internal symbol of some other package is usually a mistake".    Much worse, I've seen even very experienced hackers (more than 10 years    experience) fall into the trap of thinking that FOO::BAR means "access    the internal symbol BAR in the FOO package", or "access the symbol BAR    present in the FOO package, regardless of whether it is external or not".    The disaster that occurs once in a long while is that merely reading in    FOO::BAR creates some imposter symbol in the BAR package that shouldn't    be there at all; but the poor loser who does this doesn't find that out    until a much later time, when a USE-PACKAGE or EXPORT is done.  And of    course by the time he finds it out, there is little hope of ferreting    out all the structures already read-in that point to the bogon symbol.    It may be too much to ask that the :IMPORT-FROM option signal an error    if no symbol of the requested name is available in the specified package.    This would (desirably, I think) differ from the reader's action when     parsing a double-colon notation.  But at the very least, why add the     :IMPORT and :SHADOWING-IMPORT options that *require* symbols as opposed to     names?  Why, when there are perfectly good alternatives that don't have     the modularity-violating implications described above?    If these two alterations are made, then a DEFPACKAGE can be written with    all data specified as strings; and in the cases when symbols are actually    are supplied, then the compiler can convert them to strings as they are    put out into the fasl file. (Essentially the same compiler conversion    takes place now in Symbolics treatment of SHADOW, and in Lucid's 3.0    release version of SHADOW).    -- JonL ---------------------------------------------------------------------------------*start*01315 00024 USfReturn-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 20 SEP 88 10:36:45 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 462476; Tue 20-Sep-88 13:36:20 EDTDate: Tue, 20 Sep 88 13:36 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 2)To: Jon L White <jonl@lucid.com>cc: masinter.pa, CL-Cleanup@Sail.stanford.eduIn-Reply-To: <8809201717.AA18425@bhopal>Message-ID: <19880920173616.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI've re-read the mail from May and I simply don't buy your arguments.I don't see any need to change anything in the version 2 proposal.If you want to write a competitive proposal, that's fine; not onlywill I not complain, I'll be enthusiastic that I'm not the only oneworking on the issue.  However, you'll have to be clearer in yourarguments than in May to convince me that your proposal isbetter.  I think all your arguments are variations on: using symbolswith package prefixes in a DEFPACKAGE form is more dangerous thanusing symbols with package prefixes in other forms.  My positionis that DEFPACKAGE is no different from anything else in this respect.*start*04803 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 23 SEP 88 17:03:27 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA08083g; Fri, 23 Sep 88 16:02:45 PSTReceived: by bhopal id AA11135g; Fri, 23 Sep 88 17:02:14 PDTDate: Fri, 23 Sep 88 17:02:14 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809240002.AA11135@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: masinter.pa, CL-Cleanup@Sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 20 Sep 88 13:36 EDT <19880920173616.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 2)re: ... I simply don't buy your arguments. ...     I think all your arguments are variations on: using symbols    with package prefixes in a DEFPACKAGE form is more dangerous than    using symbols with package prefixes in other forms.  My position    is that DEFPACKAGE is no different from anything else in this respect.Either you are not reading the same May criticisms, or you're not understanding them fully.  In very simplified form, they are:  -- Everything done by :IMPORT can be done with :IMPORT-FROM; thus     :IMPORT is redundant (and similarly for :SHADOWING-IMPORT).  -- :IMPORT _requires_ symbols and cannot accept strings; thus     :IMPORT-FROM has greater flexibility;  -- At package-creation time the user can, with proper imports, virtually     subsume all need for double-colon syntax in the remaining code; but      his purpose is defeated if he has to use double-colons in the creator      expression. [We discuss elsewhere how double-colons cause trouble].Only one of the three arguments is about the danger of altering other random packages while merely *** reading in *** some package creator expressions.  I'm really surprised that you haven't seen this problem before, since DEFPACKAGE is in fact nothing beyond the capability nowin use of doing (PROGN (SHADOW...) (EXPORT ...) (USE-PACKAGE ...) ...)[Incidentally, the problem is never caused by just "using symbols with package prefixes", but rather by using double-colon prefixes.  I'm sureyou're aware of that already.]At least with top level calls to IMPORT, you can say either:     (A) (import 'loser::bar)     (B) (import (intern "BAR" "LOSER"))     (C) (import (or (find-symbol "BAR" "LOSER") (error "Missing Symbol")))but in the current state of the DEFPACKAGE proposal, there is no capabilityequivalent to (B) or (C) for the :IMPORT option.  Hence the desirabililty of not adding a *dangerous* construct to the language when a harmless one-- :IMPORT-FROM -- is already planned.The point of all this not to say that defpackage as proposed is guaranteedto cause irreconcilable name-conflict problems.   Rather, I think that the penalty for minor order-of-event mistakes should be a continuable error signalled before the damage is done, rather than the situation that RichardGreenblatt described at the Fort Collins meeting.The last mail interchange back in May concerned whether or not :IMPORT-FROMshould complain if the requested symbol didn't already exist, or whetherit should take the possibly dangerous step of creating it quietly.   A partof that interchange is copied below, since it is highly relevant to the"dangerousness" issue.-- JonL --  Date: Fri, 27 May 88 18:04:22 PDT  From: Jon L White <edsel!jonl@labrea.stanford.edu>  To: Moon@stony-brook.scrc.symbolics.com  Cc: CL-Cleanup@sail.stanford.edu  In-Reply-To: David A. Moon's message of Tue, 24 May 88 16:55 EDT <19880524205536.6.MOON@EUPHRATES.SCRC.Symbolics.COM>  Subject: [More on] Issue: DEFPACKAGE   . . .   re: Okay, you're proposing that :IMPORT-FROM be changed to do something      different from any of the previous proposals, namely to call      FIND-SYMBOL instead of INTERN or the secret version of INTERN that ...  This is wrong.  Your message of "Wed, 23 Mar 88 14:49 EST", which was the  presentation of (Version 2), said the following about :IMPORT-FROM (and  :SHADOWING-IMPORT-FROM):      (:IMPORT-FROM {(package-name {symbol}*)}*)      (:IMPORT-FROM package-name {symbol}*)	      Find the specified symbols in the specified packages and import	      them into the package being defined.  The second syntax is a	      convenient abbreviation when only one package is specified.	      Note that only the name of each argument symbol is used.  The	      actual symbol that gets imported is not necessarily the one	      given as an argument; it's a symbol with that name accessible in	      the named package.  "Find the specified symbols" --  not "INTERN".    Maybe the Symbolics   implementation does call INTERN, and you were thinking of that rather   than the DEFPACKAGE proposal?  -- JonL --*start*00915 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 26 SEP 88 21:05:12 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 466133; Tue 27-Sep-88 00:04:47 EDTDate: Tue, 27 Sep 88 00:04 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 2)To: Jon L White <jonl@lucid.com>cc: masinter.pa, CL-Cleanup@Sail.stanford.eduIn-Reply-To: <8809240002.AA11135@bhopal>Message-ID: <19880927040452.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoI remain confused by the discussion.  Rather than going around and aroundin circles, why don't you just write up the proposal your way, leaving outarguments comparing it with the previous proposal, and then I will eithercriticize it constructively or accede to it.*start*11615 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 SEP 88 22:57:10 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 27 Sep 88  22:56:45 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00600g; Tue, 27 Sep 88 21:41:44 PSTSite: Received: by bhopal id AA06405g; Tue, 27 Sep 88 22:41:16 PDTDate: Tue, 27 Sep 88 22:41:16 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809280541.AA06405@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@Sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 27 Sep 88 00:04 EDT <19880927040452.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 3)re: ... why don't you just write up the proposal your way, leaving out    arguments comparing it with the previous proposal, and then I will     either criticize it constructively or accede to it.Well, ok, but all I really wanted to do was to get consensus on the onepoint of removing :IMPORT and :SHADOWING-IMPORT.Here is your version 2 from 23-Mar-88 with that deletion, and with the following emmendations, all of which are minor except for (3):  (1) "symbol" --> "symbol-name" in numerous places, as per your mail      message of "Date: Fri, 20 May 88 22:12 EDT"; also added appropriate      commentary about depending only the "name", not the symbol.  (2) Specify that :IMPORT-FROM (and :SHADOWING-IMPORT-FROM) signals an       error if any of the specified symbols do not already exist in the       "from" package.  (3) Explicitly permit EXPORT to work after the other options, so that      it can apply to imported and inherited symbols, as well as to      absolutly fresh ones; this is new -- I hope you can agree to it, or      give constructive criticism.  (4) Added, and updated, references to Issues IN-PACKAGE-FUNCTIONALITY      and PROCLAIM-ETC-IN-COMPILE-FILE; also added my "support" for the      former into the Discussion section.  (5) Added an alternate form under Examples; added "canonicalization"      comment to Discussion.  (6) Re-order the presentation of the options to accord with a revised      order for the "7 Extremely Randoms" of CLtL p191 [not very important].-- JonL --!Issue:         DEFPACKAGEReferences:    CLtL section 11.7.               Issue: IN-PACKAGE-FUNCTIONALITYCategory:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussion               Version 3, 27-Mar-88, JonL 		(remove :import, :shadowing-import; allow :export to work on		 imported and inherited; update references to in-package, etc.)Problem description:The package functions included in CLtL encourage a programming stylethat tends to evoke the worst aspects of the package system.  Theproblem is that if the definition of a package is scattered througha program, as a number of individual forms, it is very easy to reada symbol before the package setup needed to read that symbol correctlyhas been accomplished.  Three examples: an inherited symbol that shouldhave been shadowed might be accessed; a single-colon prefix might beused for a symbol that will later be exported, causing an error; a localsymbol might be accessed where a symbol that will later be imported orinherited was intended.  These problems can be difficult to understandor even to recognize, are difficult to recover from without completelyrestarting the Lisp, and give Common Lisp a bad name.Proposal (DEFPACKAGE:ADDITION):          Add a DEFPACKAGE macro to the language.  It encourages putting theentire definition of a package in a single place.  It also encouragesputting all the package definitions of a program in a single file, whichcan be loaded before loading or compiling anything that depends on thosepackages.  This file can be read in the USER package, avoiding anypackage bootstrapping issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Also expand MAKE-PACKAGE (and IN-PACKAGE, unless the cleanup IssueIN-PACKAGE-FUNCTIONALITY is adopted) to take all the same keywordarguments as DEFPACKAGE, for consistency.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.'package-name' is a symbol or a string; if a symbol, only its namematters, not what package it is in.  If a string, capitalizationmatters, normally uppercase is used.Standard options for DEFPACKAGE are listed below.  Additional optionsmight be present in an implementation, and each implementation mustsignal an error if an option not recognized by that implementation ispresent.  Additional implementation-dependent options might take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.Each option may appear at most once.  If duplicate options are present,DEFPACKAGE signals an error.(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified names.(:USE {package-name}*)        Inherit from the specified packages.(:SHADOW {symbol-name}*)        Create the specified symbols in the package being defined, and         place them on the shadowing symbols list.   Each 'symbol-name'         argument must be either a string or a symbol.  If given as a        symbol, only its name is used; and in this case the shadowing         symbol entered into the package being defined is definitely not         the one given as argument, but rather a symbol of the same name         freshly created as a shadow in the package.(:SHADOWING-IMPORT-FROM {(package-name {symbol-name}*)}*)(:SHADOWING-IMPORT-FROM package-name {symbol}*)        Find the specified symbols in the specified packages and import        them into the package being defined, and place them on the         shadowing symbols list.  Each 'symbol-name' argument must be         either a string or a symbol.  If given as a symbol, only its         name is used; and in this case, the symbol that is imported is         not necessarily the one given as an argument, but rather the symbol         of that name accessible in the "from" package.   In no case will         symbols be created in any package other than the one being defined;         a continuable error is signalled if no symbol is accessible for         one of the names in its corresponding "from" package.  The second         syntax is simply a convenient abbreviation when only one package         is specified. (:IMPORT-FROM {(package-name {symbol-name}*)}*)(:IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified packages and import        them into the package being defined.  Each 'symbol-name' argument         must be either a string or a symbol.  If given as a symbol, only        its name is used; and in this case, the symbol that is imported is         not necessarily the one given as argument, but rather the symbol         of that name accessible in the "from" package.   In no case will         symbols be created in a package other than the one being defined;         a continuable error is signalled if no symbol is accessible for         one of the names in its corresponding "from" package.  The second         syntax is simply a convenient abbreviation when only one package         is specified. (:EXPORT {symbol-name}*)        Find or create symbols with the specified names and export them.        Each 'symbol-name' argument must be either a string or a symbol.        If given as a symbol, only its name is used; and in this case,        the symbol that is made external in the defined package is not         necessarily the one given as an argument, but rather a symbol of        that name freshly interned in the package being defined.  Note an         interaction with the :USE option, since intern'ing may inherit         symbols rather than creating new ones; note also an interaction         with the :IMPORT-FROM and :SHADOWING-IMPORT-FROM options, since         intern'ing will merely access an already imported symbol. (:SIZE integer)        Declare the approximate number of symbols expected in the package.        This is an efficiency hint only, so that the package's table will        not have to be frequently re-expanded when new symbols are added        to it (e.g., by reading in a large file "in" that package.)The collection of symbol-name arguments given to the options :SHADOW,:IMPORT-FROM, and :SHADOWING-IMPORT-FROM must all be disjoint; an erroris signalled otherwise.  In a chronological sense, the :EXPORT may bethought of as ocurring last so that it can make reference to inheritedor imported symbols already created by the other three options.Examples:;;; Play it super-safe, and use only strings as names; do not even assume;;;  assume that the package it is read in to "uses" LISP; do *not* create;;;  any symbols whatsoever in the package that it is read in to.(LISP:DEFPACKAGE "MY-PACKAGE"  (:NICKNAMES "MYPKG" "MY-PKG")  (:USE "LISP")  (:SHADOW "CAR" "CDR")  (:SHADOWING-IMPORT-FROM "VENDOR-COMMON-LISP"  "CONS")  (:IMPORT-FROM 	  "VENDOR-COMMON-LISP"  "GC")  (:EXPORT "EQ" "CONS" "FROBOLA")  );;; A similar call, using symbols rather than strings as names; expects;;;  to be read in to a package that "uses" LISP, and *may* create;;;  random internal symbols in that package (such as MY-PACKAGE etc).(DEFPACKAGE MY-PACKAGE  (:NICKNAMES MYPKG :MY-PKG)  (:USE LISP)  (:SHADOW CAR :CDR #:CONS)  )Rationale:See first paragraph of Proposal section.Current practice:Symbolics Common Lisp has always had a DEFPACKAGE, and uses it in preference to individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCL version of DEFPACKAGE has quite a few additional options, but none of themappear to be necessary to propose for Common Lisp at this time.Cost to Implementors:Should be small as the macro can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:No cost, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:The "Put in seven extremely random user interface commands" mnemonicdescribed in CLtL p.191 could be removed, and the special compiler handling of these functions necessary to support that could be removed (except possibly for REQUIRE and PROCLAIM -- see the Issue PROCLAIM-ETC-IN-COMPILE-FILE).  As this would be an incompatible change,it is not part of this proposal.The issue IN-PACKAGE-FUNCTIONALITY recommends that IN-PACKAGE  be incompatibly changed to recognize only existing packages, not to create them.  IN-PACKAGE would then not accept any keyword arguments.Moon (and JonL and KMP) thinks this is a reasonable idea, and is the subject of a separate proposal.  The macroexpansion of DEFPACKAGE should be permitted to canonicalizeinto the strings-as-name form, so that even though the source fileshowed random symbols in the DEFPACKAGE form, the compiled file mighthave only strings in it.*start*02853 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 13:23:58 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Sep 88  13:22:52 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00967g; Wed, 28 Sep 88 12:20:22 PSTReceived: by bhopal id AA09354g; Wed, 28 Sep 88 13:19:55 PDTDate: Wed, 28 Sep 88 13:19:55 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809282019.AA09354@bhopal>To: Gregor.paCc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@Sail.stanford.eduIn-Reply-To: Gregor.pa@Xerox.COM's message of Wed, 28 Sep 88 09:21 PDT <19880928162127.8.GREGOR@PORTNOY.parc.xerox.com>Subject: Issue: DEFPACKAGE (version 3)re: I think that at least IN-PACKAGE should not accept these options, and    should be used for selection only.  The reason is the same as the one    for adding DEFPACKAGE.  If you do this to IN-PACKAGE, people will end    up making the same mistake of using in-package with different arguments    in different files of their program.The relevant section of the proposal (version 3) reads:    Also expand MAKE-PACKAGE (and IN-PACKAGE, unless the cleanup Issue    IN-PACKAGE-FUNCTIONALITY is adopted) to take all the same keyword    arguments as DEFPACKAGE, for consistency.As moon rightly points out, we have to address the pull-back ofIN-PACKAGE separately, since it is a serious incompatible change.[Note that I'm agreeing with you -- I just want to move the discussion about it into the pre-existing Cleanup issue.]re: Also, wherever it currently takes a symbol or a symbol-name (string), it    should just take a string.  . . . I'd certainly be happy with that, but my impression is that moon and kmpfeel it is important to be able to use symbols just for their print-name;the issue being that case-conversion happens automatically for symbols,but doesn't for strings.  Given the option to use strings everywhere, andgiven implementation techniques that permit the compiler to evade packageissues (in the compiled output for a DEFPACKAGE), this admission to "lazy typing" seems harmless.  Note also that many users have discovered the wonderous insensitivity to package problems that the notations :FOO and #:FOO have.re:  . . . In systems which use    a "structure" editor, forms which take symbols as their argument,     and then change the print-name of those symbols, cause all sorts of    problems.  So, at least the import options will cause problems for     this system.    -------There is no common-lisp capability to "change the print-name" of symbols.This DEFPACKAGE proposal doesn't suggest that, so if you think it impliedit somehow, maybe you could point out the confusing phrases.-- JonL --*start*02091 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 14:03:12 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Sep 88  13:55:01 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 467279; Wed 28-Sep-88 16:52:55 EDTDate: Wed, 28 Sep 88 16:52 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 3)To: jonl@lucid.comcc: Gregor.pa, Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@Sail.stanford.eduIn-Reply-To: <8809282019.AA09354@bhopal>Message-ID: <880928165233.4.KMP@GRYPHON.SCRC.Symbolics.COM>    Date: Wed, 28 Sep 88 13:19:55 PDT    From: Jon L White <jonl@lucid.com>    ...    re: Also, wherever it currently takes a symbol or a symbol-name (string), it	should just take a string.  . . .     I'd certainly be happy with that, but my impression is that moon and kmp    feel it is important to be able to use symbols just for their print-name;    the issue being that case-conversion happens automatically for symbols,    but doesn't for strings.Just Moon thinks this. KMP is strongly in favor of accepting strings onlybecause he thinks the issue of stray symbols being accidentally internedin the wrong package is considerably more important than the issue of makingsomeone type "FOO" instead of "foo".(On the other hand, KMP programs about half the time in uppercase andhalf the time in lower case and has no particular phobia of seeing uppercasecharacters in a mostly lowercase program, so maybe he undervalues theimportance to some people of never seeing an uppercase character anywherein their code. :-)    ... Note also that many users have discovered the wonderous insensitivity    to package problems that the notations :FOO and #:FOO have. ...(Only half-serious, I think) Maybe we should permit only unpackaged symbolsor symbols in the keyword package...*start*02187 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 11:06:22 PDTMessage-ID: <1qiYPw@SAIL.Stanford.EDU>Date: 28 Sep 88 10:49 PDTFrom: System Files <SYS@SAIL.Stanford.EDU>Subject: Re: Issue: DEFPACKAGE (version 3)   Received: from Xerox.COM by SAIL.Stanford.EDU with TCP; 28 Sep 88  10:47:30 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 28 SEP 88 09:23:05 PDTDate: Wed, 28 Sep 88 09:21 PDTFrom: Gregor.pa@Xerox.COMSubject: Re: Issue: DEFPACKAGE (version 3)To: Jon L White <jonl@lucid.com>cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@Sail.stanford.eduFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: <8809280541.AA06405@bhopal>Message-ID: <19880928162127.8.GREGOR@PORTNOY.parc.xerox.com>Line-fold: no    Date: Tue, 27 Sep 88 22:41:16 PDT    From: Jon L White <jonl@lucid.com>    Add a DEFPACKAGE macro to the language.  It encourages putting the    entire definition of a package in a single place.  It also encourages    putting all the package definitions of a program in a single file, which    can be loaded before loading or compiling anything that depends on those    packages.  This file can be read in the USER package, avoiding any    package bootstrapping issues.I think that at least IN-PACKAGE should not accept these options, andshould be used for selection only.  The reason is the same as the onefor adding DEFPACKAGE.  If you do this to IN-PACKAGE, people will end	up making the same mistake of using in-package with different argumentsin different files of their program.Also, wherever it currently takes a symbol or a symbol-name (string), itshould just take a string.  There are two reasons for this.  The firstis simplicity, the current description of what happens with symbols isconfusing.  More importantly is current practice.  In systems which usea "structure" editor, forms which take symbols as their argument, andthen change the print-name of those symbols, cause all sorts ofproblems.  So, at least the import options will cause problems for thissystem.-------*start*01461 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 16:56:11 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 28 Sep 88  16:56:14 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 28 SEP 88 16:48:00 PDTDate: Wed, 28 Sep 88 16:47 PDTFrom: Gregor.paSubject: Re: Issue: DEFPACKAGE (version 3)To: Jon L White <jonl@lucid.com>cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@Sail.stanford.eduFcc: BD:>Gregor>mail>outgoing-mail-4.text.newestIn-Reply-To: <8809282019.AA09354@bhopal>Message-ID: <19880928234749.5.GREGOR@PORTNOY.parc.xerox.com>Line-fold: no    Date: Wed, 28 Sep 88 13:19:55 PDT    From: Jon L White <jonl@lucid.com>    There is no common-lisp capability to "change the print-name" of symbols.    This DEFPACKAGE proposal doesn't suggest that, so if you think it implied    it somehow, maybe you could point out the confusing phrases.I should have said "the way a symbol is printed".  In a programmingenvironment in which the users program passes through READ and PRINTthis is an issue.  Given that package is bound to some package FOO whichonly uses LISP, this form:  (import 'pcl::class-direct-slots)Once I read this form, it will print out as:  (IMPORT 'CLASS-DIRECT-SLOTS)So that when I load it again in a fresh world, I won't get the resultI got the first time.-------*start*02173 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 18:47:01 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Sep 88  18:46:33 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01414g; Wed, 28 Sep 88 17:43:59 PSTReceived: by bhopal id AA10743g; Wed, 28 Sep 88 18:43:33 PDTDate: Wed, 28 Sep 88 18:43:33 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809290143.AA10743@bhopal>To: Gregor.paCc: Moon@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@Sail.stanford.eduIn-Reply-To: Gregor.pa@Xerox.COM's message of Wed, 28 Sep 88 16:47 PDT <19880928234749.5.GREGOR@PORTNOY.parc.xerox.com>Subject: Issue: DEFPACKAGE (version 3)re: I should have said "the way a symbol is printed".  In a programming    environment in which the users program passes through READ and PRINT    this is an issue.  Given that package is bound to some package FOO which    only uses LISP, this form:      (import 'pcl::class-direct-slots)    Once I read this form, it will print out as:      (IMPORT 'CLASS-DIRECT-SLOTS)    So that when I load it again in a fresh world, I won't get the result    I got the first time.This is precisely one of the situations that I've been referring towhen I argue for the removal of the :IMPORT option.  Note however,that the revised proposal does *not* have this misfeature even ifyou use _symbols_ in the :IMPORT-FROM option.  That's the whole pointof it.  [Yes, your structure editor might package-qualify one suchsymbol differently, if PRINTed at the "wrong" times, but that will be completely irrelevant.]You did mention before that you found the documentation about the symbols-vs-strings as arguments somewhat unclear, so maybe thispoint didn't get through.  Wanna suggest some re-wordings?-- JonL --P.S. By the bye, are you aware of the existence of the Decency in Packaging     League, which will slap you with a citation for writing code like:	(import 'pcl::class-direct-slots)     rather than:	(import (intern "CLASS-DIRECT-SLOTS" "PCL"))*start*03125 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 17:52:28 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 28 Sep 88  17:52:21 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 28 SEP 88 17:41:58 PDTDate: 28 Sep 88 17:41 PDTFrom: vanMelle.paSubject: Re: Issue: DEFPACKAGE (version 2)To: cl-cleanup@Sail.stanford.educc: vanMelle.paMessage-ID: <880928-174158-2043@Xerox>I strongly agree with JonL on point one, that it is important that the specpermit strings in all the places that currently say "symbol" (except, of course,:import and :shadowing-import).  I don't want to be forced to use a form thathas a side effect of interning random symbols that I'm then going to discard.As a simple example, the following sequence:	(in-package 'user)	(defpackage foo (:export bar baz))	(use-package 'foo)will complain that foo:bar conflicts with user::bar.  Environments withresidential structure editors probably feel even more strongly of the need forstrings.  I take it there was no serious disagreement on this.JonL's second point, that :import and :shadowing-import should be flushed, isless clear.  I agree with Moon that allowing a user to type foo::bar in adefpackage is no worse than allowing it in some random program.  I also agreewith JonL that :[shadowing-]import is of relatively little utility given theexistence of :[shadowing-]import-from.  I see it mainly as a shorthand (and aperfectly "safe" one in the case of external symbols), though not one that savesmore than typing a couple of parentheses.  Here are a couple other arguments forgetting rid of :[shadowing-]import on aesthetic grounds:(1) It's the only option that really does require symbols.  If you omit it, youcan explain the various options solely in terms of pnames, without constantlysaying "if symbol, only its name is used".  JonL alludes to this.(2) It's unusable altogether in residential environments unless the environmentgoes to special effort to be careful.  E.g., if I read in the form	(defpackage foo (:import window:bar))and later print it out in the foo package, it comes out as	(defpackage foo (:import bar))which, of course, is not what I had in mind.At any rate, the spec really should spell out what :import-from does if thespecified symbol is not accessible in the package.  I.e., does it behave like(:import package::name), thus creating the symbol anyway, or like (or(find-symbol name package) (error ...)).By the way, there are a couple things missing from the proposal that really needto be stated somewhere, though I doubt any of them are difficult to answer:(1) What, exactly, does defpackage do?  Yes, it creates the package according tothe specified options.  Does it do also do an in-package?  Does it return thepackage as value?(2) What happens when the package already exists?  Nothing?  Overrides previousoptions?  "Union" of both?  I think the union method is best, but it may alsorequire more explaining.	Bill*start*00965 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 SEP 88 17:34:48 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 29 Sep 88  17:33:13 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00392g; Thu, 29 Sep 88 16:31:09 PSTReceived: by bhopal id AA14046g; Thu, 29 Sep 88 17:30:42 PDTDate: Thu, 29 Sep 88 17:30:42 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809300030.AA14046@bhopal>To: vanMelle.paCc: cl-cleanup@Sail.stanford.eduIn-Reply-To: Jon L White's message of Thu, 29 Sep 88 16:29:48 PDT <8809292329.AA13827@bhopal>Subject: Issue: DEFPACKAGE (version 2)Foo, whereever my message said "(version 2)", I meant to say "(version 3)".Version 3 is the one I sent out on  Date: Tue, 27 Sep 88 22:41:16 PDTcorrecting most of the problems you brought up in yesterday's note.-- JonL --*start*03241 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 SEP 88 16:32:23 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 29 Sep 88  16:32:23 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00331g; Thu, 29 Sep 88 15:30:15 PSTReceived: by bhopal id AA13827g; Thu, 29 Sep 88 16:29:48 PDTDate: Thu, 29 Sep 88 16:29:48 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809292329.AA13827@bhopal>To: vanMelle.paCc: cl-cleanup@Sail.stanford.eduIn-Reply-To: vanMelle.pa@Xerox.COM's message of 28 Sep 88 17:41 PDT <880928-174158-2043@Xerox>Subject: Issue: DEFPACKAGE (version 2)re: I strongly agree with JonL on point one, that it is important that the spec    permit strings in all the places that currently say "symbol" (except ...(version 2) actually says "symbol-name" rather than "symbol"; I think moonagreed to this in a message last May.re: . . . allowing a user to type foo::bar in a defpackage    is no worse than allowing it in some random program.  Well, damage is often in the eye of the beholder, but DEFPACKAGE is a bit of a "lever" in that if you don't need colon qualifications in it, you cangenerally say that you don't need it in your file at all.  Let's grant for the moment that single-colon qualifiers in files are bad; so bad that even just *one* of them can be disastrous (as another part of your msg suggests).Then with a proper use of DEFPACKAGE, you can almost always "import" etc theneeded symbols so that they are available unqualified; but if you can't even name them in order to import them, you've completely lost "the battle of thecolons".  Thus the whole issue swings on the optionality of symbols in the options to DEFPACKAGE.re: At any rate, the spec really should spell out what :import-from does if the    specified symbol is not accessible in the package.  I.e., does it ...Bill, are you sure you've been reading (version 2) and not (version 1)?  Thispoint was also recently changed; the specification of :IMPORT-FROM says:  (:IMPORT-FROM {(package-name {symbol-name}*)}*)  (:IMPORT-FROM package-name {symbol-name}*)	  Find the specified symbols in the specified packages and import	  them into the package being defined.  . . .  In no case will 	  symbols be created in a package other than the one being defined; 	  a continuable error is signalled if no symbol is accessible for 	  one of the names in its corresponding "from" package.  ...re: (1) What, exactly, does defpackage do?  ... Does it do also do an     in-package?  Does it return the package as value?Good point.  It's probably arbitrary, but should be spelled out.re: (2) What happens when the package already exists?  I think the union         method is best, but it may also require more explaining.My msg of  Date: Wed, 28 Sep 88 14:50:29 PDT  proposed three alternatives;your suggestion of "union" is probably similar to alternative (3), whichKMP also favored.  I see that we need some discusson on this point of whatit means to "resolve" an existing package with a candidate new definition.Got any ideas?-- JonL --*start*02365 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 30 SEP 88 10:20:55 PDTReceived: from NSS.Cs.Ucl.AC.UK by SAIL.Stanford.EDU with TCP; 30 Sep 88  10:16:46 PDTReceived: from aiai.edinburgh.ac.uk by NSS.Cs.Ucl.AC.UK   via Janet with NIFTP           id aa05436; 30 Sep 88 17:16 BSTDate: Fri, 30 Sep 88 17:57:28 BSTMessage-Id: <2809.8809301657@subnode.aiai.ed.ac.uk>From: Jeff Dalton <jeff%aiai.edinburgh.ac.uk@NSS.Cs.Ucl.AC.UK>Subject: Re: Issue: DEFPACKAGE (version 3)To: Kent M Pitman <KMP@scrc-stony-brook.arpa>, jonl <@sail.stanford.edu:jonl@lucid.com>In-Reply-To: Kent M Pitman's message of Wed, 28 Sep 88 16:52 EDTCc: Gregor.pa, Moon@scrc-stony-brook.arpa, CL-Cleanup@sail.stanford.edu>   Date: Wed, 28 Sep 88 13:19:55 PDT>   From: Jon L White <jonl@lucid.com>>>   I'd certainly be happy with that, but my impression is that moon and kmp>   feel it is important to be able to use symbols just for their print-name;>   the issue being that case-conversion happens automatically for symbols,>   but doesn't for strings.> > Just Moon thinks this.I think so too.  I dislike being forced to use upper case;I'd reather use :foo than "FOO".Of course, if we were to change the internal case to lower (perhaps,for backwards compatibility, using a canonical case trick like theone suggested for pathnames), this problem would disappear for me,though perhaps not for someone who was concerned about case conversionper se (no matter what the internal case) rather than about upperverses lower.> (On the other hand, KMP programs about half the time in uppercase and> half the time in lower case and has no particular phobia of seeing uppercase> characters in a mostly lowercase program, so maybe he undervalues the> importance to some people of never seeing an uppercase character anywhere> in their code. :-)Maybe the lower case on the machines you use isn't very readable, sothat upper case doesn't seem so bad. :-)>   ... Note also that many users have discovered the wonderous insensitivity>   to package problems that the notations :FOO and #:FOO have. ...> > (Only half-serious, I think) Maybe we should permit only unpackaged symbols> or symbols in the keyword package...It's worth considering.*start*00762 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 SEP 88 09:01:47 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 29 Sep 88  07:27:46 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 28 SEP 88 23:42:19 PDTDate: 28 Sep 88 23:42 PDTFrom: masinter.paSubject: Re: Issue: DEFPACKAGE (version 3)In-reply-to: vanMelle.pa's message of 28 Sep 88 17:41 PDTTo: cl-cleanup@Sail.stanford.educc: vanmelle.paMessage-ID: <880928-234219-233@Xerox>I think we're very close on this one.As for Bill's questions:DEFPACKAGE should in fact do an in-package? In fact, isn't it simply written portably?I like removing features.*start*00678 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 01 OCT 88 18:32:07 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01483g; Sat, 1 Oct 88 17:30:58 PSTReceived: by bhopal id AA08729g; Sat, 1 Oct 88 18:30:30 PDTDate: Sat, 1 Oct 88 18:30:30 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810020130.AA08729@bhopal>To: masinter.paCc: Moon@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: masinter.pa@Xerox.COM's message of 1 Oct 88 01:22 PDT <881001-012210-1872@Xerox>Subject: Issue: DEFPACKAGE (version 4)I have no objections to your "surgery", and will defer to moon on it.-- JonL --*start*09154 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 01 OCT 88 01:59:56 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 1 Oct 88  01:55:50 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 01 OCT 88 01:22:10 PDTDate: 1 Oct 88 01:22 PDTFrom: masinter.paTo: CL-Cleanup@Sail.stanford.eduSubject: Issue: DEFPACKAGE (version 4)Message-ID: <881001-012210-1872@Xerox>Well, I did some surgery to this, some of which you might not like:I moved the rationale that was in the proposal down to the Rationale section.I made some minor changes in various parts of the proposal, (e.g., "give Common Lisp a bad name" =>"frustrate programmers")I removed the part about MAKE-PACKAGE taking the same keywords. It didn't seem well motivated to me, and I thought could be a separate proposal.I shortened the proposal by saying once that package-name and symbol-namecould be symbols but only the symbol-name is used.!Issue:         DEFPACKAGEReferences:    CLtL section 11.7.               Issue: IN-PACKAGE-FUNCTIONALITYCategory:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussion               Version 3, 27-Sep-88, JonL 		(remove :import, :shadowing-import; allow :export to work on		 imported and inherited; update references to in-package, etc.)		Version 4,  1-Oct-88, MasinterProblem description:The package functions included in CLtL encourage a programming stylethat tends to evoke the worst aspects of the package system.  Theproblem is that if the definition of a package is scattered througha program, as a number of individual forms, it is very easy to reada symbol before the package setup needed to read that symbol correctlyhas been accomplished.  Three examples: an inherited symbol that shouldhave been shadowed might be accessed; a single-colon prefix might beused for a symbol that will later be exported, causing an error; a localsymbol might be accessed where a symbol that will later be imported orinherited was intended.  These problems can be difficult to understandor even to recognize, are difficult to recover from without completelyrestarting the Lisp, and frustrating programmers.Proposal (DEFPACKAGE:ADDITION):          Add a DEFPACKAGE macro to the language.  In the description below,'package-name' and 'symbol-name' can be a symbol or a string; if a symbol, only its name matters, not what package it is in.  If a string, capitalizationmatters, normally uppercase is used.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.Standard options for DEFPACKAGE are listed below.  Each option may appear at most once.  If duplicate options are present,DEFPACKAGE signals an error.(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified names.(:USE {package-name}*)        Inherit from the specified packages.(:SHADOW {symbol-name}*)        Create the specified symbols in the package being defined, and         place them on the shadowing symbols list.  (:SHADOWING-IMPORT-FROM {(package-name {symbol-name}*)}*)(:SHADOWING-IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified packages and import        them into the package being defined, and place them on the         shadowing symbols list.  In no case will         symbols be created in any package other than the one being defined;         a continuable error is signalled if no symbol is accessible for         one of the names in its corresponding "from" package.  The second         syntax is simply a convenient abbreviation when only one package         is specified. (:IMPORT-FROM {(package-name {symbol-name}*)}*)(:IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified packages and import        them into the package being defined.  Each 'symbol-name' argument         must be either a string or a symbol.  In no case will         symbols be created in a package other than the one being defined;         a continuable error is signalled if no symbol is accessible for         one of the names in its corresponding "from" package.  The second         syntax is simply a convenient abbreviation when only one package         is specified. (:EXPORT {symbol-name}*)        Find or create symbols with the specified names and export them.        Note an interaction with the :USE option, since intern'ing may inherit         symbols rather than creating new ones; note also an interaction         with the :IMPORT-FROM and :SHADOWING-IMPORT-FROM options, since         intern'ing will merely access an already imported symbol. (:SIZE integer)        Declare the approximate number of symbols expected in the package.        This is an efficiency hint only, so that the package's table will        not have to be frequently re-expanded when new symbols are added        to it (e.g., by reading in a large file "in" that package.)The collection of symbol-name arguments given to the options :SHADOW,:IMPORT-FROM, and :SHADOWING-IMPORT-FROM must all be disjoint; an erroris signalled otherwise.  In a chronological sense, the :EXPORT may bethought of as ocurring last so that it can make reference to inheritedor imported symbols already created by the other three options.DEFPACKAGE creates the package as specified, and returns it as itsvalue. It has no other side effects; i.e., it does not do an IN-PACKAGE.Examples:;;; Play it super-safe, and use only strings as names; do not even assume;;;  assume that the package it is read in to "uses" LISP; do *not* create;;;  any symbols whatsoever in the package that it is read in to.(LISP:DEFPACKAGE "MY-PACKAGE"  (:NICKNAMES "MYPKG" "MY-PKG")  (:USE "LISP")  (:SHADOW "CAR" "CDR")  (:SHADOWING-IMPORT-FROM "VENDOR-COMMON-LISP"  "CONS")  (:IMPORT-FROM 	  "VENDOR-COMMON-LISP"  "GC")  (:EXPORT "EQ" "CONS" "FROBOLA")  );;; A similar call, using symbols rather than strings as names; expects;;;  to be read in to a package that "uses" LISP, and *may* create;;;  random internal symbols in that package (such as MY-PACKAGE etc).(DEFPACKAGE MY-PACKAGE  (:NICKNAMES MYPKG :MY-PKG)  (:USE LISP)  (:SHADOW CAR :CDR #:CONS)  )Rationale:The availability of DEFPACKAGE encourages putting theentire definition of a package in a single place.  It also encouragesputting all the package definitions of a program in a single file, whichcan be loaded before loading or compiling anything that depends on thosepackages.  This file can be read in the USER package, avoiding anypackage bootstrapping issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Current practice:Symbolics Common Lisp has always had a DEFPACKAGE, and uses it in preference to individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCL version of DEFPACKAGE has quite a few additional options, but none of themappear to be necessary to propose for Common Lisp at this time. Cost to Implementors:Small; DEFPACKAGE can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:Small, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:The "Put in seven extremely random user interface commands" mnemonicdescribed in CLtL p.191 could be removed, and the special compiler handling of these functions necessary to support that could be removed (except possibly for REQUIRE and PROCLAIM -- see the compiler Issue PROCLAIM-ETC-IN-COMPILE-FILE).  As this would be an incompatible change,it is not part of this proposal.The issue IN-PACKAGE-FUNCTIONALITY recommends that IN-PACKAGE  be incompatibly changed to recognize only existing packages, not to create them.  IN-PACKAGE would then not accept any keyword arguments.The function MAKE-PACKAGE might also be extended to take all the keywordsthat DEFPACKAGE does. This could be subject of a separate cleanup.The macroexpansion of DEFPACKAGE should be permitted to canonicalizeinto the strings-as-name form, so that even though the source fileshowed random symbols in the DEFPACKAGE form, the compiled file mighthave only strings in it.Additional options might be present in an implementation; implementationsshould probably signal an error if an option not recognized by that implementation ispresent.Frequently additional implementation-dependent options  take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.*start*03044 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 06 OCT 88 01:12:49 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 471568; Thu 6-Oct-88 04:13:04 EDTDate: Thu, 6 Oct 88 04:12 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (Version 4)To: Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881006041254.2.KMP@BOBOLINK.SCRC.Symbolics.COM>I have some (mostly non-technical) wording gripes which I think shouldbe made for clarity... - Don't refer to uppercase being "normally used". It depends on   the application, etc. Just refer the user to INTERN. - Don't refer to "inheriting" in the description of :USE.   Refer to USE-PACKAGE. Similarly, :SHADOW should refer to   SHADOW, etc. After all, we've gone to considerable trouble   to explain each of these concepts and we can't afford to have   some bit of vague wording accidentally bind us into an   inconsistency here. It is easier and more correct to simply   say exactly what primitive these are giving us access to. - Rather than say what happens last,etc just say these will happen   in an order that makes it all work if it's possible to make work.   One of the major flaws of the ``put in seven...'' slogan is that   it is not always possible to win that way -- it's only a rule of   thumb and sometimes you have to use another ordering. DEFPACKAGE   should be capable of constructing a correct ordering regardless   of what order the user uses. - It's hard to tell if the comment in the examples is intended as   general advice to people about how they should use DEFPACKAGE   or a comment about what's going on in this particular DEFPACKAGE.   It's obvious once you see the next test, but I think some fixing   up should be done to avoid initial confusion. In fact, I might   invert the order of the examples. - Also, I'd show the examples in lower case (with uppercase strings,   of course) to emphasize the uppercasing feature of symbols that   people seem so hooked on. Also, that would make it clear (by   contrast) that the case of strings had to be uppercase and was   not just accidentally matching the surrounding code. - I'm not a big fan of permitting the package name itself (the   cadr of the DEFPACKAGE form) to be a string. That interacts badly   with our editor (and many others I know of). But maybe that just   means we should fix our editor. I dunno. I'd prefer people just   put the package name in the keyword package. - In the Discussion, the remark about "The macroexpansion of   DEFPACKAGE should be permitted to canonicalize into the ..."   appears to belong elsewhere in the proposal. If it's `just an   idea,' and not intended as part of the proposal, it should say   so very clearly.   Ditto for "Additional options might be present..."   and "Frequently additional implementation-dependent..."*start*01203 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 21:19:43 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Oct 88  21:18:35 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472358; Fri 7-Oct-88 00:17:13 EDTDate: Fri, 7 Oct 88 00:16 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (Version 4)To: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881006041254.2.KMP@BOBOLINK.SCRC.Symbolics.COM>Message-ID: <19881007041654.7.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 6 Oct 88 04:12 EDT    From: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>    I have some (mostly non-technical) wording gripes which I think should    be made for clarity...Oops, I didn't see this message before I made a revised version.I generally agree with Kent's comments here, but I also don't thinkany of them are important enough to block adoption, so I'm notgoing to take the time to make another revised version.*start*09972 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 21:16:10 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Oct 88  21:14:39 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472357; Fri 7-Oct-88 00:13:11 EDTDate: Fri, 7 Oct 88 00:12 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 5)To: CL-Cleanup@Sail.stanford.eduIn-Reply-To: <881001-012210-1872@Xerox>Message-ID: <19881007041242.6.MOON@EUPHRATES.SCRC.Symbolics.COM>I almost approve version 4, but there are a couple of problems with it(enumerated below).  In the interest of saving time, here is a version 5with the problems fixed and no other changes.  Naturally I approve it.- fix trivial typos- the complex forms of :IMPORT-FROM and :SHADOWING-IMPORT-FROM can  be removed if the prohibition against repeated options is lifted.  This seems like a worthwhile simplification.- the change to :IMPORT-FROM and :SHADOWING-IMPORT-FROM to call  FIND-SYMBOL instead of INTERN inadvertently made them useless,  since there is no way to assure that non-exported, non-shadowed  symbols exist.  Add a :INTERNAL option to take care of this.- change current practice to note that this is an incompatible change  for Symbolics- specify what happens if the package already existsIssue:         DEFPACKAGEReferences:    CLtL section 11.7.               Issue: IN-PACKAGE-FUNCTIONALITYCategory:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussion               Version 3, 27-Sep-88, JonL                 (remove :import, :shadowing-import; allow :export to work on                 imported and inherited; update references to in-package, etc.)               Version 4,  1-Oct-88, Masinter               Version 5, 6-Oct-88, MoonProblem description:The package functions included in CLtL encourage a programming stylethat tends to evoke the worst aspects of the package system.  Theproblem is that if the definition of a package is scattered througha program, as a number of individual forms, it is very easy to reada symbol before the package setup needed to read that symbol correctlyhas been accomplished.  Three examples: an inherited symbol that shouldhave been shadowed might be accessed; a single-colon prefix might beused for a symbol that will later be exported, causing an error; a localsymbol might be accessed where a symbol that will later be imported orinherited was intended.  These problems can be difficult to understandor even to recognize, are difficult to recover from without completelyrestarting the Lisp, and frustrating to programmers.Proposal (DEFPACKAGE:ADDITION):      Add a DEFPACKAGE macro to the language.  In the description below,'package-name' and 'symbol-name' can be a symbol or a string; if a symbol, only its name matters, not what package it is in.  If a string, capitalizationmatters, normally uppercase is used.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.Standard options for DEFPACKAGE are listed below.   Options may appearmore than once (useful mainly for :IMPORT-FROM and :SHADOWING-IMPORT-FROM).It is an error to specify :SIZE more than once.(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified names.(:USE {package-name}*)        Inherit from the specified packages.(:SHADOW {symbol-name}*)        Create the specified symbols in the package being defined, and         place them on the shadowing symbols list.  (:SHADOWING-IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined, and place them on the         shadowing symbols list.  In no case will         symbols be created in any package other than the one being defined;         a continuable error is signalled if no symbol is accessible in the        package named package-name for one of the symbol-names.(:IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined.  In no case will         symbols be created in a package other than the one being defined;         a continuable error is signalled if no symbol is accessible in the        package named package-name for one of the symbol-names.(:EXPORT {symbol-name}*)        Find or create symbols with the specified names and export them.        Note an interaction with the :USE option, since intern'ing may inherit         symbols rather than creating new ones; note also an interaction         with the :IMPORT-FROM and :SHADOWING-IMPORT-FROM options, since         intern'ing will merely access an already imported symbol. (:INTERNAL {symbol-name}*)        Find or create symbols with the specified names.  This is useful        if a :IMPORT-FROM or :SHADOWING-IMPORT-FROM option in a later        DEFPACKAGE for another package expects to find these symbols,        but the symbols are not to be exported.(:SIZE integer)        Declare the approximate number of symbols expected in the package.        This is an efficiency hint only, so that the package's table will        not have to be frequently re-expanded when new symbols are added        to it (e.g., by reading in a large file "in" that package.)Additional options might be allowed by an implementation;implementations should signal an error if an option not recognized bythat implementation is present.The collection of symbol-name arguments given to the options :SHADOW,:INTERNAL, :IMPORT-FROM, and :SHADOWING-IMPORT-FROM must all bedisjoint; an error is signalled otherwise.  In a chronological sense,the :EXPORT may be thought of as occurring last so that it can makereference to inherited or imported symbols already created by the otheroptions.DEFPACKAGE creates the package as specified, and returns it as itsvalue.  It has no other side effects; i.e., it does not do anIN-PACKAGE.  If a package with the specified name already exists, theexisting package is modified, by adding to its attributes but notremoving any (for example EXPORT may be called, but UNEXPORT is nevercalled).Examples:;;; Play it super-safe, and use only strings as names; do not even;;;  assume that the package it is read in to "uses" LISP; do *not* create;;;  any symbols whatsoever in the package that it is read in to.(LISP:DEFPACKAGE "MY-PACKAGE"  (:NICKNAMES "MYPKG" "MY-PKG")  (:USE "LISP")  (:SHADOW "CAR" "CDR")  (:SHADOWING-IMPORT-FROM "VENDOR-COMMON-LISP"  "CONS")  (:IMPORT-FROM           "VENDOR-COMMON-LISP"  "GC")  (:EXPORT "EQ" "CONS" "FROBOLA")  );;; A similar call, using symbols rather than strings as names; expects;;;  to be read in to a package that "uses" LISP, and *may* create;;;  random internal symbols in that package (such as MY-PACKAGE etc).(DEFPACKAGE MY-PACKAGE  (:NICKNAMES MYPKG :MY-PKG)  (:USE LISP)  (:SHADOW CAR :CDR #:CONS)  )Rationale:The availability of DEFPACKAGE encourages putting theentire definition of a package in a single place.  It also encouragesputting all the package definitions of a program in a single file, whichcan be loaded before loading or compiling anything that depends on thosepackages.  This file can be read in the USER package, avoiding anypackage bootstrapping issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Current practice:Symbolics Common Lisp has always had a DEFPACKAGE, and uses it in preference to individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCL version of DEFPACKAGE has quite a few additional options, but none of themappear to be necessary to propose for Common Lisp at this time.  Thisproposal is incompatible with Symbolics DEFPACKAGE in some ways thatwill probably not cause major problems.Cost to Implementors:Small; DEFPACKAGE can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:Small, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:The "Put in seven extremely random user interface commands" mnemonicdescribed in CLtL p.191 could be removed, and the special compiler handling of these functions necessary to support that could be removed (except possibly for REQUIRE and PROCLAIM -- see the compiler Issue PROCLAIM-ETC-IN-COMPILE-FILE).  As this would be an incompatible change,it is not part of this proposal.The issue IN-PACKAGE-FUNCTIONALITY recommends that IN-PACKAGE  be incompatibly changed to recognize only existing packages, not to create them.  IN-PACKAGE would then not accept any keyword arguments.The function MAKE-PACKAGE might also be extended to take all the keywordsthat DEFPACKAGE does. This could be the subject of a separate cleanup.The macroexpansion of DEFPACKAGE can usefully canonicalizeinto the strings-as-name form, so that even though the source fileshowed random symbols in the DEFPACKAGE form, the compiled file mighthave only strings in it.Frequently additional implementation-dependent options take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.*start*01655 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 14:54:37 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Sep 88  14:53:02 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01076g; Wed, 28 Sep 88 13:50:55 PSTReceived: by bhopal id AA09835g; Wed, 28 Sep 88 14:50:29 PDTDate: Wed, 28 Sep 88 14:50:29 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809282150.AA09835@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@SAIL.Stanford.EDUSubject: Issues: IN-PACKAGE-FUNCTIONALITY and DEFPACKAGEIn Kent's note of Tue, 27 Sep 88 12:25 EDT, he points out the action of MAKE-PACKAGE, for an existing package, is to "break" (in mostimplementations.)    It occurs to me that the DEFPACKAGE proposalis silent (hence, subject to varying interpretations) about how to handle the case of defining a package on a name that already exists.I see three possibilities:  (1) "break", just like MAKE-PACKGE  (2) Simply do the new definition (as DEFUN and DEFCLASS do), possibly      issuing a warning message based upon vendor-specific facilities.  (3) Quietly do the new definition, providing that it is essentially      compatible with the old one; signal an error if not compatible.I think I'd prefer (3), since it allows you to re-load a file thatis under development, without getting spurious breaks or warningmessages; yet it provides some assurance that you aren't about tobreak your whold world.Comments?-- JonL --*start*00805 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 15:21:37 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 28 Sep 88  15:19:36 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 28 SEP 88 15:06:38 PDTDate: 28 Sep 88 15:06 PDTFrom: masinter.paSubject: Re: Issues: IN-PACKAGE-FUNCTIONALITY and DEFPACKAGEIn-reply-to: Jon L White <jonl@lucid.com>'s message of Wed, 28 Sep 88 14:50:29 PDTTo: Jon L White <jonl@lucid.com>cc: Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <880928-150638-1741@Xerox>I like it, but it is necessary to define what "essentially compatible" means.Please.*start*01429 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 SEP 88 15:04:31 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 28 Sep 88  15:03:00 PDTReceived: from GRYPHON.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 467326; Wed 28-Sep-88 18:01:26 EDTDate: Wed, 28 Sep 88 18:01 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issues: IN-PACKAGE-FUNCTIONALITY and DEFPACKAGETo: jonl@lucid.comcc: Moon@STONY-BROOK.SCRC.Symbolics.COM, KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8809282150.AA09835@bhopal>Message-ID: <880928180109.6.KMP@GRYPHON.SCRC.Symbolics.COM>I like option 3, too. But I note that all kinds of packages aregoing to be defined as just :USE LISP and nothing else, so that'snot enough safeguard to be completely sure that clobberage is notoccurring. I think we (Symbolics) will want to provide [implementation-dependent] support for complaining more forcefullyif the DEFPACKAGE is in a different file than the previous one(to help us distinguish re-loading from clobbering back and forth),so try to leave the wording vague enough to accomodate discretionabout exactly why the error might be signalled in the case of redefinition.*start*01368 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 15:29:09 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  15:28:43 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00777g; Fri, 7 Oct 88 15:27:21 PDTReceived: by bhopal id AA01833g; Fri, 7 Oct 88 15:25:41 PDTDate: Fri, 7 Oct 88 15:25:41 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810072225.AA01833@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@Sail.stanford.eduIn-Reply-To: David A. Moon's message of Fri, 7 Oct 88 00:12 EDT <19881007041242.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 5)I approve of this version.I also like :internal, and had intended to bring it up before.  The comment about uselessness:    - the change to :IMPORT-FROM and :SHADOWING-IMPORT-FROM to call      FIND-SYMBOL instead of INTERN inadvertently made them useless,      since there is no way to assure that non-exported, non-shadowed      symbols exist.  . . . is a bit overly pessimistic here, since internals symbols are created merely by reading files.  But there's no question that defpackage should have a way of creating internal non-exported, non-shadowing symbols.-- JonL --*start*10185 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 00:48:48 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 8 Oct 88  00:47:53 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01325g; Sat, 8 Oct 88 00:46:31 PDTReceived: by bhopal id AA03642g; Sat, 8 Oct 88 00:44:52 PDTDate: Sat, 8 Oct 88 00:44:52 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080744.AA03642@bhopal>To: CL-Cleanup@Sail.stanford.eduSubject: Issue: DEFPACKAGE (version 6)Fix up :EXPORT to also refer to :INTERNAL.Tighten up requirements as to package redefinition -- "retractions" permitted  after continuing from a continuable error.Fixed a few nits as suggedted by KMP's msg of Date: Thu, 6 Oct 88 04:12 EDT.-- Incorporated the "use" and "shadow" suggestions-- Slight re-wording about the ordering of execution re :export-- Fixed up the commentary for the first example; downcased much of the   second example.Note that we now have three continuable errors being specified, but havenot specified the condition names.  This ought to be remedied.-- JonL --!Issue:         DEFPACKAGEReferences:    CLtL section 11.7.               Issue: IN-PACKAGE-FUNCTIONALITYCategory:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussion               Version 3, 27-Sep-88, JonL                 (remove :import, :shadowing-import; allow :export to work on                 imported and inherited; update references to in-package, etc.)               Version 4,  1-Oct-88, Masinter               Version 5, 6-Oct-88, Moon               Version 6, 6-Oct-88, JonL (little nits)Problem description:The package functions included in CLtL encourage a programming stylethat tends to evoke the worst aspects of the package system.  Theproblem is that if the definition of a package is scattered througha program, as a number of individual forms, it is very easy to reada symbol before the package setup needed to read that symbol correctlyhas been accomplished.  Three examples: an inherited symbol that shouldhave been shadowed might be accessed; a single-colon prefix might beused for a symbol that will later be exported, causing an error; a localsymbol might be accessed where a symbol that will later be imported orinherited was intended.  These problems can be difficult to understandor even to recognize, are difficult to recover from without completelyrestarting the Lisp, and frustrating to programmers.Proposal (DEFPACKAGE:ADDITION):      Add a DEFPACKAGE macro to the language.  In the description below,'package-name' and 'symbol-name' can be a symbol or a string; if a symbol, only its name matters, not what package it is in.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.Standard options for DEFPACKAGE are listed below.   Options may appearmore than once (useful mainly for :IMPORT-FROM and :SHADOWING-IMPORT-FROM).It is an error to specify :SIZE more than once.(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified names.(:USE {package-name}*)        The package is to "use" the other designated packages; that is,        it will inherit from them.(:SHADOW {symbol-name}*)        Create the specified symbols in the package being defined,         making them shadows, just at the function SHADOW would do.(:SHADOWING-IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined, and place them on the         shadowing symbols list.  In no case will         symbols be created in any package other than the one being defined;         a continuable error is signalled if no symbol is accessible in the        package named package-name for one of the symbol-names.(:IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined.  In no case will         symbols be created in a package other than the one being defined;         a continuable error is signalled if no symbol is accessible in the        package named package-name for one of the symbol-names.(:INTERNAL {symbol-name}*)        Find or create symbols with the specified names.  This is useful        if a :IMPORT-FROM or :SHADOWING-IMPORT-FROM option in a later        DEFPACKAGE for another package expects to find these symbols,        but the symbols are not to be exported.(:EXPORT {symbol-name}*)        Find or create symbols with the specified names and export them.        Note an interaction with the :USE option, since intern'ing may inherit         symbols rather than creating new ones; note also an interaction         with the :INTERNAL, :IMPORT-FROM and :SHADOWING-IMPORT-FROM options,        since intern'ing will merely access an already imported symbol. (:SIZE integer)        Declare the approximate number of symbols expected in the package.        This is an efficiency hint only, so that the package's table will        not have to be frequently re-expanded when new symbols are added        to it (e.g., by reading in a large file "in" that package.)Additional options might be allowed by an implementation; allimplementations should signal an error if an option not recognized bythat implementation is present.The collection of symbol-name arguments given to the options :SHADOW,:INTERNAL, :IMPORT-FROM, and :SHADOWING-IMPORT-FROM must all bedisjoint; an error is signalled otherwise.  The :EXPORT option canbe thought of as occuring after all the other options have beenexecuted, since it may reference names found in "used" packages, or found in the argument lists to a :SHADOW, :INTERNAL, :IMPORT-FROM, or :SHADOWING-IMPORT-FROM option.DEFPACKAGE creates the package as specified, and returns it as its value.It has no other side effects; i.e., it does not do an IN-PACKAGE.  If a package with the specified name already exists, the existing package is modified by possibly adding to its attributes.  An attempt to re-definea package with a smaller set of attributes should signal a continuable error;at most one such error is to be signalled per call to DEFPACKAGE, regardless of how many attributes are being re-tracted; upon continuation, the packageis created with exactly as specified.Examples:;;; An example which "plays it super-safe", by using only strings as names; ;;;  does not even assume that the package it is read in to "uses" LISP; ;;   *never* creates any symbols whatsoever in the package that it is read ;;     in to.(LISP:DEFPACKAGE "MY-PACKAGE"  (:NICKNAMES "MYPKG" "MY-PKG")  (:USE "LISP")  (:SHADOW "CAR" "CDR")  (:SHADOWING-IMPORT-FROM "VENDOR-COMMON-LISP"  "CONS")  (:IMPORT-FROM           "VENDOR-COMMON-LISP"  "GC")  (:EXPORT "EQ" "CONS" "FROBOLA")  );;; A similar call, mostly using symbols rather than strings as names.;;; Expects to be read in to a package that "uses" LISP, and *may* create;;;  random internal symbols in that package (such as MY-PACKAGE etc).(defpackage my-package  (:nicknames mypkg :MY-PKG)		;remember CL conventions for case  (:use lisp)				; conversion on symbols  (:shadow CAR :cdr #:cons)  (:export "CONS")			;yes, this is the shadowed one.  )Rationale:The availability of DEFPACKAGE encourages putting theentire definition of a package in a single place.  It also encouragesputting all the package definitions of a program in a single file, whichcan be loaded before loading or compiling anything that depends on thosepackages.  This file can be read in the USER package, avoiding anypackage bootstrapping issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Current practice:Symbolics Common Lisp has always had a DEFPACKAGE, and uses it in preference to individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCL version of DEFPACKAGE has quite a few additional options, but none of themappear to be necessary to propose for Common Lisp at this time.  Thisproposal is incompatible with Symbolics DEFPACKAGE in some ways thatwill probably not cause major problems.Cost to Implementors:Small; DEFPACKAGE can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:Small, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:The "Put in seven extremely random user interface commands" mnemonicdescribed in CLtL p.191 could be removed, and the special compiler handling of these functions necessary to support that could be removed (except possibly for REQUIRE and PROCLAIM -- see the compiler Issue PROCLAIM-ETC-IN-COMPILE-FILE).  As this would be an incompatible change,it is not part of this proposal.The issue IN-PACKAGE-FUNCTIONALITY recommends that IN-PACKAGE  be incompatibly changed to recognize only existing packages, not to create them.  IN-PACKAGE would then not accept any keyword arguments.The function MAKE-PACKAGE might also be extended to take all the keywordsthat DEFPACKAGE does. This could be the subject of a separate cleanup.The macroexpansion of DEFPACKAGE can usefully canonicalizeinto the strings-as-name form, so that even though the source fileshowed random symbols in the DEFPACKAGE form, the compiled file mighthave only strings in it.Frequently additional implementation-dependent options take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.*start*09714 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 08 OCT 88 14:59:41 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 8 Oct 88  14:41:30 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 08 OCT 88 14:39:27 PDTDate: 8 Oct 88 14:39 PDTFrom: masinter.paSubject: DRAFT Issue: DEFPACKAGE (version 6)To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: Masinter.paMessage-ID: <881008-143927-2237@Xerox>This issue is only marked DRAFT because there were some last minute edits to it.!Issue:         DEFPACKAGEReferences:    CLtL section 11.7.               Issue: IN-PACKAGE-FUNCTIONALITYCategory:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussion               Version 3, 27-Sep-88, JonL                 (remove :import, :shadowing-import; allow :export to work on                 imported and inherited; update references to in-package, etc.)               Version 4,  1-Oct-88, Masinter               Version 5, 6-Oct-88, Moon               Version 6, 8-Oct-88, JonL (little nits)Problem description:The package functions included in CLtL encourage a programming stylethat tends to evoke the worst aspects of the package system.  Theproblem is that if the definition of a package is scattered througha program, as a number of individual forms, it is very easy to reada symbol before the package setup needed to read that symbol correctlyhas been accomplished.  Three examples: an inherited symbol that shouldhave been shadowed might be accessed; a single-colon prefix might beused for a symbol that will later be exported, causing an error; a localsymbol might be accessed where a symbol that will later be imported orinherited was intended.  These problems can be difficult to understandor even to recognize, are difficult to recover from without completelyrestarting the Lisp, and frustrating to programmers.Proposal (DEFPACKAGE:ADDITION):      Add a DEFPACKAGE macro to the language.  In the description below,'package-name' and 'symbol-name' can be a symbol or a string; if a symbol, only its name matters, not what package it is in.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.Standard options for DEFPACKAGE are listed below.   Options may appearmore than once (useful mainly for :IMPORT-FROM and :SHADOWING-IMPORT-FROM).It is an error to specify :SIZE more than once.(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified names.(:USE {package-name}*)        The package is to "use" the other designated packages; that is,        it will inherit from them.(:SHADOW {symbol-name}*)        Create the specified symbols in the package being defined,         making them shadows, just at the function SHADOW would do.(:SHADOWING-IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined, and place them on the         shadowing symbols list.  In no case will         symbols be created in any package other than the one being defined;         a continuable error is signalled if no symbol is accessible in the        package named package-name for one of the symbol-names.(:IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined.  In no case will         symbols be created in a package other than the one being defined;         a continuable error is signalled if no symbol is accessible in the        package named package-name for one of the symbol-names.(:INTERNAL {symbol-name}*)        Find or create symbols with the specified names.  This is useful        if a :IMPORT-FROM or :SHADOWING-IMPORT-FROM option in a later        DEFPACKAGE for another package expects to find these symbols,        but the symbols are not to be exported.(:EXPORT {symbol-name}*)        Find or create symbols with the specified names and export them.        Note an interaction with the :USE option, since intern'ing may inherit         symbols rather than creating new ones; note also an interaction         with the :INTERNAL, :IMPORT-FROM and :SHADOWING-IMPORT-FROM options,        since intern'ing will merely access an already imported symbol. (:SIZE integer)        Declare the approximate number of symbols expected in the package.        This is an efficiency hint only, so that the package's table will        not have to be frequently re-expanded when new symbols are added        to it (e.g., by reading in a large file "in" that package.)Additional options might be allowed by an implementation; allimplementations should signal an error if an option not recognized bythat implementation is present.The collection of symbol-name arguments given to the options :SHADOW,:INTERNAL, :IMPORT-FROM, and :SHADOWING-IMPORT-FROM must all bedisjoint; an error is signalled otherwise.  The :EXPORT option canbe thought of as occuring after all the other options have beenexecuted, since it may reference names found in "used" packages, or found in the argument lists to a :SHADOW, :INTERNAL, :IMPORT-FROM, or :SHADOWING-IMPORT-FROM option.DEFPACKAGE creates the package as specified, and returns it as its value.It has no other side effects; i.e., it does not do an IN-PACKAGE.  If a package with the specified name already exists, the existing package is modified by possibly adding to its attributes.  An attempt to re-definea package with a smaller set of attributes should signal a continuable error;at most one such error is to be signalled per call to DEFPACKAGE, regardless of how many attributes are being re-tracted; upon continuation, the packageis created with exactly as specified.Examples:;;; An example which "plays it super-safe", by using only strings as names; ;;;  does not even assume that the package it is read in to "uses" LISP; ;;   *never* creates any symbols whatsoever in the package that it is read ;;     in to.(LISP:DEFPACKAGE "MY-PACKAGE"  (:NICKNAMES "MYPKG" "MY-PKG")  (:USE "LISP")  (:SHADOW "CAR" "CDR")  (:SHADOWING-IMPORT-FROM "VENDOR-COMMON-LISP"  "CONS")  (:IMPORT-FROM           "VENDOR-COMMON-LISP"  "GC")  (:EXPORT "EQ" "CONS" "FROBOLA")  );;; A similar call, mostly using symbols rather than strings as names.;;; Expects to be read in to a package that "uses" LISP, and *may* create;;;  random internal symbols in that package (such as MY-PACKAGE etc).(defpackage my-package  (:nicknames mypkg :MY-PKG)		;remember CL conventions for case  (:use lisp)				; conversion on symbols  (:shadow CAR :cdr #:cons)  (:export "CONS")			;yes, this is the shadowed one.  )Rationale:The availability of DEFPACKAGE encourages putting theentire definition of a package in a single place.  It also encouragesputting all the package definitions of a program in a single file, whichcan be loaded before loading or compiling anything that depends on thosepackages.  This file can be read in the USER package, avoiding anypackage bootstrapping issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Current practice:Symbolics Common Lisp has always had a DEFPACKAGE, and uses it in preference to individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCL version of DEFPACKAGE has quite a few additional options, but none of themappear to be necessary to propose for Common Lisp at this time.  Thisproposal is incompatible with Symbolics DEFPACKAGE in some ways thatwill probably not cause major problems.Cost to Implementors:Small; DEFPACKAGE can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:Small, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:The "Put in seven extremely random user interface commands" mnemonicdescribed in CLtL p.191 could be removed, and the special compiler handling of these functions necessary to support that could be removed (except possibly for REQUIRE and PROCLAIM -- see the compiler Issue PROCLAIM-ETC-IN-COMPILE-FILE).  As this would be an incompatible change,it is not part of this proposal.The issue IN-PACKAGE-FUNCTIONALITY recommends that IN-PACKAGE  be incompatibly changed to recognize only existing packages, not to create them.  IN-PACKAGE would then not accept any keyword arguments.The function MAKE-PACKAGE might also be extended to take all the keywordsthat DEFPACKAGE does. This could be the subject of a separate cleanup.The macroexpansion of DEFPACKAGE can usefully canonicalizeinto the strings-as-name form, so that even though the source fileshowed random symbols in the DEFPACKAGE form, the compiled file mighthave only strings in it.Frequently additional implementation-dependent options take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.Note that we now have three continuable errors being specified, but havenot specified the condition names.  This ought to be remedied.*start*09706 00024 US Date:  8 Oct 88 14:39 PDTFrom: masinter.paSubject: DRAFT Issue: DEFPACKAGE (version 6)To: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterThis issue is only marked DRAFT because there were some last minute edits to it.Issue:         DEFPACKAGEReferences:    CLtL section 11.7.               Issue: IN-PACKAGE-FUNCTIONALITYCategory:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussion               Version 3, 27-Sep-88, JonL                 (remove :import, :shadowing-import; allow :export to work on                 imported and inherited; update references to in-package, etc.)               Version 4,  1-Oct-88, Masinter               Version 5, 6-Oct-88, Moon               Version 6, 8-Oct-88, JonL (little nits)Problem description:The package functions included in CLtL encourage a programming stylethat tends to evoke the worst aspects of the package system.  Theproblem is that if the definition of a package is scattered througha program, as a number of individual forms, it is very easy to reada symbol before the package setup needed to read that symbol correctlyhas been accomplished.  Three examples: an inherited symbol that shouldhave been shadowed might be accessed; a single-colon prefix might beused for a symbol that will later be exported, causing an error; a localsymbol might be accessed where a symbol that will later be imported orinherited was intended.  These problems can be difficult to understandor even to recognize, are difficult to recover from without completelyrestarting the Lisp, and frustrating to programmers.Proposal (DEFPACKAGE:ADDITION):      Add a DEFPACKAGE macro to the language.  In the description below,'package-name' and 'symbol-name' can be a symbol or a string; if a symbol, only its name matters, not what package it is in.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.Standard options for DEFPACKAGE are listed below.   Options may appearmore than once (useful mainly for :IMPORT-FROM and :SHADOWING-IMPORT-FROM).It is an error to specify :SIZE more than once.(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified names.(:USE {package-name}*)        The package is to "use" the other designated packages; that is,        it will inherit from them.(:SHADOW {symbol-name}*)        Create the specified symbols in the package being defined,         making them shadows, just at the function SHADOW would do.(:SHADOWING-IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined, and place them on the         shadowing symbols list.  In no case will         symbols be created in any package other than the one being defined;         a continuable error is signalled if no symbol is accessible in the        package named package-name for one of the symbol-names.(:IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined.  In no case will         symbols be created in a package other than the one being defined;         a continuable error is signalled if no symbol is accessible in the        package named package-name for one of the symbol-names.(:INTERNAL {symbol-name}*)        Find or create symbols with the specified names.  This is useful        if a :IMPORT-FROM or :SHADOWING-IMPORT-FROM option in a later        DEFPACKAGE for another package expects to find these symbols,        but the symbols are not to be exported.(:EXPORT {symbol-name}*)        Find or create symbols with the specified names and export them.        Note an interaction with the :USE option, since intern'ing may inherit         symbols rather than creating new ones; note also an interaction         with the :INTERNAL, :IMPORT-FROM and :SHADOWING-IMPORT-FROM options,        since intern'ing will merely access an already imported symbol. (:SIZE integer)        Declare the approximate number of symbols expected in the package.        This is an efficiency hint only, so that the package's table will        not have to be frequently re-expanded when new symbols are added        to it (e.g., by reading in a large file "in" that package.)Additional options might be allowed by an implementation; allimplementations should signal an error if an option not recognized bythat implementation is present.The collection of symbol-name arguments given to the options :SHADOW,:INTERNAL, :IMPORT-FROM, and :SHADOWING-IMPORT-FROM must all bedisjoint; an error is signalled otherwise.  The :EXPORT option canbe thought of as occuring after all the other options have beenexecuted, since it may reference names found in "used" packages, or found in the argument lists to a :SHADOW, :INTERNAL, :IMPORT-FROM, or :SHADOWING-IMPORT-FROM option.DEFPACKAGE creates the package as specified, and returns it as its value.It has no other side effects; i.e., it does not do an IN-PACKAGE.  If a package with the specified name already exists, the existing package is modified by possibly adding to its attributes.  An attempt to re-definea package with a smaller set of attributes should signal a continuable error;at most one such error is to be signalled per call to DEFPACKAGE, regardless of how many attributes are being re-tracted; upon continuation, the packageis created with exactly as specified.Examples:;;; An example which "plays it super-safe", by using only strings as names; ;;;  does not even assume that the package it is read in to "uses" LISP; ;;   *never* creates any symbols whatsoever in the package that it is read ;;     in to.(LISP:DEFPACKAGE "MY-PACKAGE"  (:NICKNAMES "MYPKG" "MY-PKG")  (:USE "LISP")  (:SHADOW "CAR" "CDR")  (:SHADOWING-IMPORT-FROM "VENDOR-COMMON-LISP"  "CONS")  (:IMPORT-FROM           "VENDOR-COMMON-LISP"  "GC")  (:EXPORT "EQ" "CONS" "FROBOLA")  );;; A similar call, mostly using symbols rather than strings as names.;;; Expects to be read in to a package that "uses" LISP, and *may* create;;;  random internal symbols in that package (such as MY-PACKAGE etc).(defpackage my-package  (:nicknames mypkg :MY-PKG)		;remember CL conventions for case  (:use lisp)				; conversion on symbols  (:shadow CAR :cdr #:cons)  (:export "CONS")			;yes, this is the shadowed one.  )Rationale:The availability of DEFPACKAGE encourages putting theentire definition of a package in a single place.  It also encouragesputting all the package definitions of a program in a single file, whichcan be loaded before loading or compiling anything that depends on thosepackages.  This file can be read in the USER package, avoiding anypackage bootstrapping issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Current practice:Symbolics Common Lisp has always had a DEFPACKAGE, and uses it in preference to individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCL version of DEFPACKAGE has quite a few additional options, but none of themappear to be necessary to propose for Common Lisp at this time.  Thisproposal is incompatible with Symbolics DEFPACKAGE in some ways thatwill probably not cause major problems.Cost to Implementors:Small; DEFPACKAGE can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:Small, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:The "Put in seven extremely random user interface commands" mnemonicdescribed in CLtL p.191 could be removed, and the special compiler handling of these functions necessary to support that could be removed (except possibly for REQUIRE and PROCLAIM -- see the compiler Issue PROCLAIM-ETC-IN-COMPILE-FILE).  As this would be an incompatible change,it is not part of this proposal.The issue IN-PACKAGE-FUNCTIONALITY recommends that IN-PACKAGE  be incompatibly changed to recognize only existing packages, not to create them.  IN-PACKAGE would then not accept any keyword arguments.The function MAKE-PACKAGE might also be extended to take all the keywordsthat DEFPACKAGE does. This could be the subject of a separate cleanup.The macroexpansion of DEFPACKAGE can usefully canonicalizeinto the strings-as-name form, so that even though the source fileshowed random symbols in the DEFPACKAGE form, the compiled file mighthave only strings in it.Frequently additional implementation-dependent options take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.Note that we now have three continuable errors being specified, but havenot specified the condition names.  This ought to be remedied.        TITAN 
         TITAN 
                                      G              
             »             8              %             V             Œ              Y              $              6       
       K                           E      $— zº*start*01268 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:11:16 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:10:56 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475780; Thu 13-Oct-88 16:08:44 EDTDate: Thu, 13 Oct 88 16:08 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (Version 6)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013160835.4.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...X3J13 meeting: A straw poll was taken and there was unanimous approval of the concept of DEFPACKAGE, so it seems very likely this will ultimately pass. Walter: Wants to see a portable definition distributed. KMP: Notes that one issue is that DEFPACKGE needs to work somewhat      differently when definitions are re-loaded than it did the      first time. That issue would show up in the portable code,      but the proposal is not specific enough to address that.      Perhaps the proposal should be expanded to cover this situation?*start*01843 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:36:28 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:35:47 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA18928; Thu, 13 Oct 88 14:34:08 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19839; Thu, 13 Oct 88 14:34:06 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132034.AA19839@defun.utah.edu>Date: Thu, 13 Oct 88 14:34:04 MDTSubject: issue DEFPACKAGETo: cl-cleanup@sail.stanford.eduA few minor complaints on this one.A question was raised at the meeting about having macros signallingerrors during expansion at compile time.  Macro expansion time is theobvious time for signalling a syntax error for an unrecognized optionand I think that should be made clear in the standard.  The compilercommittee is dealing with the issue of compile time errors and makingthis particular error happen only at run-time won't get rid of themore general problem.I presume it's the intention of the proposal that the expansion ofDEFPACKAGE should be wrapped with an (EVAL-WHEN (EVAL COMPILE LOAD)...).  An explicit statement of what you intend for the compiler to dowith DEFPACKAGE should either appear in this proposal, or becommunicated to the compiler committee so that we can put it in one ofour issues. I would also like to see more detail on the order that the various thingsare supposed to happen in, in the expansion of the macro.  I'm guessing thatit's supposed to be the same as "Put In Seven Extremely Random ..." butI think the description needs to be more explicit.	Finally, what is the motivation for not having DEFPACKAGE setq *PACKAGE*?-Sandra-------*start*02381 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 17 OCT 88 17:18:55 PDTReceived: from Sun.COM by SAIL.Stanford.EDU with TCP; 17 Oct 88  17:17:51 PDTReceived: from snail.Sun.COM by Sun.COM (4.0/SMI-4.0)	id AA29538; Mon, 17 Oct 88 17:15:21 PDTReceived: from denali.sun.com by snail.Sun.COM (4.0/SMI-4.0)	id AA20323; Mon, 17 Oct 88 17:18:17 PDTReceived: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA06479; Mon, 17 Oct 88 17:19:55 PDTMessage-Id: <8810180019.AA06479@denali.sun.com>To: CL-Cleanup@Sail.stanford.eduSubject: Re: Issue: DEFPACKAGE (version 5)Date: Mon, 17 Oct 88 17:19:14 -0700From: peck@Sun.COM I hope it isn't too late to pik a couple of nits on this proposal...Nit 1, :INTERNAL Most of the clause names are verbals (:USE, :EXPORT, :IMPORT-FROM, ...)But the lately added :INTERNAL is more adjectival, and unlike :EXPORT and :USE and :SHADOW which mimic the function of the same name,it appears to have a gratuitously different name from INTERN.I suggest that the :INTERNAL option be renamed :INTERN.Another nit:Re: interaction with PACKAGE-CLUTTER, default :use list Please verify for me that if there is no :USE clause, whetherthe created package will use:  1. (:lisp)  2. *default-use-list* (or whatever it is in jonl's PACKAGE-CLUTTER proposal)  3. NILThe correct answer is 1, i believe.  If i do (:use NIL) then I get 3,how would I get 2? [use #+ for implementation specific packages, this is for PORTABLE code!]The rest of the question is whether using the :LISP package is donein the MAKE-PACKAGE, or lastly, in the (USE-PACKAGE).  Like all USE'ingthis should be deferred until after the shadowing is done, no?Next nit, order of events:  I think it is implicit, but not stated that DEFPACKAGE arrangesto sort the execution of all the various clauses to conform to (put in seven...) [although proposal says Export happens last..?]Clarify that the order of the clauses in the source code has no effect.Final nit:Also, it says re: side-effects "ie, no IN-PACKAGE is done", clarify that this does not proscribe an implementation like: `(let ((*package *package*))   (in-package ,new-name :use nil)   ...)Ps,  If anyone has code to implement DEFPACKAGE, i'd appreciate a copy.*start*03837 00024 US Return-Path: <CL-Compiler-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 OCT 88 12:53:46 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Oct 88  18:54:47 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00712g; Fri, 21 Oct 88 18:54:30 PDTReceived: by bhopal id AA12710g; Fri, 21 Oct 88 18:52:57 PDTDate: Fri, 21 Oct 88 18:52:57 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810220152.AA12710@bhopal>To: sandra%defun@cs.utah.eduCc: cl-cleanup@sail.stanford.edu, cl-compiler@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Thu, 13 Oct 88 14:34:04 MDT <8810132034.AA19839@defun.utah.edu>Subject: issue DEFPACKAGEre: I presume it's the intention of the proposal that the expansion of    DEFPACKAGE should be wrapped with an (EVAL-WHEN (EVAL COMPILE LOAD)    ...).  An explicit statement of what you intend for the compiler to do    with DEFPACKAGE should either appear in this proposal, or be    communicated to the compiler committee so that we can put it in one of    our issues. This should be covered the "normal" way, like any other defining form, by the cl-compiler issue COMPILE-FILE-HANDLING-OF-TOP-LEVEL-FORMS.  I thinkit should be implicitly eval-when(eval compile load).Incidentally, echoing my previous sentiment, it seems simpler and hencepreferable to force the issue on COMPIL-FILE -- simply say that certaintoplevel forms are defaultly eval-when(eval compile load), unless the user explicitly wraps some other eval-when around them.  It's far too confusing to worry about when COMPILE-FILE retracts definitions that were in effect"for the duration" of the compilation.  KMP also expressed this sentimentwhen replying about the options for DEFCONSTANT-HARD-WIRED (or whatever).re: I would also like to see more detail on the order that the various things    are supposed to happen in, in the expansion of the macro.  I'm guessing     that it's supposed to be the same as "Put In Seven Extremely Random ..."     but I think the description needs to be more explicit.The proposal does say something about this, and the only time ordering dependencies that are important (I think) are:  (1) the package must be created, with it's :use links all set up, before      any symbols are placed into it  (2) most of the symbol creators/importers have to be disjoint, so it      doesn't matter what order they are performed in.  The exception is      :EXPORT.  The relevant wording from the proposal is:	The collection of symbol-name arguments given to the options :SHADOW,	:INTERNAL, :IMPORT-FROM, and :SHADOWING-IMPORT-FROM must all be	disjoint; an error is signalled otherwise.  The :EXPORT option can	be thought of as occuring after all the other options have been	executed, since it may reference names found in "used" packages, 	or found in the argument lists to a :SHADOW, :INTERNAL, :IMPORT-FROM, 	or :SHADOWING-IMPORT-FROM option.Perhaps a line or two like (1) and (2) could be added for clarity?re: Finally, what is the motivation for not having DEFPACKAGE setq *PACKAGE*?Defining forms usually just establish a name-to-object mapping; there islittle precedent for them also modifying global context state.  The oneform that is currently "confused" this way is the subject of an importantcleanup issue IN-PACKAGE-FUNCTIONALITY:SELECT-ONLY to restore simplicity.Note that if DEFPACKAGE also did an IN-PACKAGE, then the following reasonable file would become somewhat jumbled, because it wouldn't all be in on package:   (in-package "USER")   (defpackage "PHLOGISTON" (:use "LISP")             (:export "FIRE"))   (defpackage "ALCHEMY"    (:use "LISP" "PHLOGISTON) (:export "GOLD"))-- JonL --*start*02634 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 OCT 88 12:53:51 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Oct 88  19:12:31 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00724g; Fri, 21 Oct 88 19:12:14 PDTReceived: by bhopal id AA12781g; Fri, 21 Oct 88 19:10:42 PDTDate: Fri, 21 Oct 88 19:10:42 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810220210.AA12781@bhopal>To: peck@Sun.COMCc: CL-Cleanup@Sail.stanford.eduIn-Reply-To: peck@Sun.COM's message of Mon, 17 Oct 88 17:19:14 -0700 <8810180019.AA06479@denali.sun.com>Subject: Issue: DEFPACKAGE (version 5)re: I suggest that the :INTERNAL option be renamed :INTERN.Hmmm, you've indeed exposed a serious discompatibility in nomenclaturestyle.  But I think I'd prefere to see the :EXPORT option renamed tobe :EXTERNAL rather than introduce a gratuitously new keyword [notethat symbols present in a package must be either :INTERNAL or :EXTERNAL.]Anyone else on CL-Cleanup have a preference?re: The rest of the question is whether using the :LISP package is done    in the MAKE-PACKAGE, or lastly, in the (USE-PACKAGE). If the DEFPACKAGE form doesn't specify a :USE option, then the obviousthing to do is to default it exactly the same as MAKE-PACKAGE would.  [Incidentally, the name of the relevant issue on this topic is something like MAKE-PACKAGE-USE-DEFAULT -- PACKAGE-CLUTTER is a separte issue].re:                                            . . . Like all USE'ing    this should be deferred until after the shadowing is done, no?Ooops, I guess you're right.  Shadowing that creates new symbols isn'timportant; but shadowing that in effect "blocks" the inheritance of two different symbols with the same name must be done before the "using".So the package should be created with a :use list of NIL, then thetwo "shadowings" should be done (if any), then the :IMPORT and :INTERNALones done, and then finally the :EXTERNAL.re: Clarify that the order of the clauses in the source code has no effect.Right! good point.  Indeed this will have to go in the ultimate version.re: Also, it says re: side-effects "ie, no IN-PACKAGE is done",     clarify that this does not proscribe an implementation like: ...I guess the more clear way to say what was intended here is that theevaluation of a DEFPACKAGE form does not change the value of *package*.I'll make another version "soon", to incorporate your "nits" and thoseof Sandra and myself.-- JonL --*start*02090 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 20:00:15 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Oct 88  19:58:44 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 482737; Wed 26-Oct-88 22:58:57 EDTDate: Wed, 26 Oct 88 22:58 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 6)To: CL-Cleanup@Sail.stanford.eduIn-Reply-To: <8810080744.AA03642@bhopal>Message-ID: <19881027025834.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Version 6 is okay with me, except for two exceptions noted below:  (:INTERNAL {symbol-name}*):INTERNAL was a typo for :INTERN; I apologize.  Wherever possiblethe option keywords were chosen to be analogous to existing CommonLisp functions, to make it easier for users to remember them andto guess what they do.    An attempt to re-define    a package with a smaller set of attributes should signal a continuable error;    at most one such error is to be signalled per call to DEFPACKAGE, regardless     of how many attributes are being re-tracted; upon continuation, the package    is created with exactly as specified.Even without the typos I would object to this.  It's not clear to methat signalling an error is the correct response in all programmingenvironments for evaluating a DEFPACKAGE with fewer attributes.Furthermore, in no other place (outside of DEFVAR and CLOS) does CommonLisp currently define what happens when you define something twice.  Ittook an enormous amount of time and effort to get that right in CLOS,and many people still argue that CLOS got it wrong.  I think it's a badidea to take on that difficult a complex of issues in CL-Cleanup whenthere are only two months left.  I think it would be a much better ideato leave redefinition of packages undefined, just like redefinition offunctions or macros.*start*04403 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 20:13:25 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Oct 88  20:11:42 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 482749; Wed 26-Oct-88 23:11:16 EDTDate: Wed, 26 Oct 88 23:11 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue DEFPACKAGETo: Sandra J Loosemore <sandra%defun@cs.utah.edu>, peck@Sun.COM, Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.edu, cl-compiler@sail.stanford.eduIn-Reply-To: <8810132034.AA19839@defun.utah.edu>,             <8810180019.AA06479@denali.sun.com>,             <8810220152.AA12710@bhopal>,             <8810220210.AA12781@bhopal>Message-ID: <19881027031103.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Comments on comments received.  I'll keep it as brief as I can.    Date: Thu, 13 Oct 88 14:34:04 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    A question was raised at the meeting about having macros signalling    errors during expansion at compile time.  Macro expansion time is the    obvious time for signalling a syntax error for an unrecognized option    and I think that should be made clear in the standard.Sure, but I hope we don't have to address this separately for each andevery macro.    I presume it's the intention of the proposal that the expansion of    DEFPACKAGE should be wrapped with an (EVAL-WHEN (EVAL COMPILE LOAD)I don't know about mandating that specific implementation, especiallywhen the definition of EVAL-WHEN is in flux, but certainly the idea isthat writing a DEFPACKAGE form at top level is sufficient to informthe compiler of what you mean.  It's usually good practice to putDEFPACKAGE forms into separate files, in which case the issue doesnot arise, but I don't think we need to forbid putting a DEFPACKAGEform in the same file as a program.    Finally, what is the motivation for not having DEFPACKAGE setq *PACKAGE*?What is the motivation for not having DEFUN call the function?That's not a joke, my point is that the two operations of defininga package and switching the current package have little to do witheach other and are rarely done together.    Date: Mon, 17 Oct 88 17:19:14 -0700    From: peck@Sun.COM    I suggest that the :INTERNAL option be renamed :INTERN.Right, that was a mistake on my part.  :INTERN is right.     Please verify for me that if there is no :USE clause, whether    the created package will use....The default for DEFPACKAGE is the same as for MAKE-PACKAGE, and isthe subject of a separate cleanup issue.    Clarify that the order of the clauses in the source code has no effect.Right, good point.    Date: Fri, 21 Oct 88 18:52:57 PDT    From: Jon L White <jonl@lucid.com>    re: I presume it's the intention of the proposal that the expansion of	DEFPACKAGE should be wrapped with an (EVAL-WHEN (EVAL COMPILE LOAD)    This should be covered the "normal" way, like any other defining formRight.    Date: Fri, 21 Oct 88 19:10:42 PDT    From: Jon L White <jonl@lucid.com>    I'd prefere to see the :EXPORT option renamed to    be :EXTERNAL rather than introduce a gratuitously new keyword [note    that symbols present in a package must be either :INTERNAL or :EXTERNAL.]I strongly object to removing the analogy between the names of theseoptions and the already existing package functions.  :INTERNAL insteadof :INTERN was a typographical error on my part.    re:                                            . . . Like all USE'ing	this should be deferred until after the shadowing is done, no?    Ooops, I guess you're right.  Shadowing that creates new symbols isn't    important; but shadowing that in effect "blocks" the inheritance of two     different symbols with the same name must be done before the "using".That's correct.  It's not hard to figure out in what order the optionsshould be processed, but part of the idea of having DEFPACKAGE is thatonly implementors have to figure that out.    I guess the more clear way to say what was intended here is that the    evaluation of a DEFPACKAGE form does not change the value of *package*.Right.*start*01996 00024 US Return-Path: <CL-Compiler-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 21:50:29 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 26 Oct 88  21:39:40 PDTReceived: from defun.utah.edu by cs.utah.edu (5.59/utah-2.0-cs)	id AA00225; Wed, 26 Oct 88 22:30:28 MDTReceived: by defun.utah.edu (5.59/utah-2.0-leaf)	id AA29800; Wed, 26 Oct 88 22:28:19 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810270428.AA29800@defun.utah.edu>Date: Wed, 26 Oct 88 22:28:17 MDTSubject: Re: issue DEFPACKAGETo: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Cc: Sandra J Loosemore <sandra%defun@cs.ARPA>, peck@Sun.COM, Jon L White <jonl@lucid.com>, cl-cleanup@sail.stanford.edu, cl-compiler@sail.stanford.eduIn-Reply-To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, Wed, 26 Oct 88 23:11 EDT> Date: Wed, 26 Oct 88 23:11 EDT> From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>> >     Finally, what is the motivation for not having DEFPACKAGE setq *PACKAGE*?> > What is the motivation for not having DEFUN call the function?> That's not a joke, my point is that the two operations of defining> a package and switching the current package have little to do with> each other and are rarely done together.My original impression of what this proposal was for was to introducea somewhat cleaner mechanism to do what one currently uses the SevenExtremely Randoms for.  IN-PACKAGE is one of those.  If one followsthe style set forth in CLtL, then defining a package and switching thecurrent package -are- usually done together.  I don't have any problemwith DEFPACKAGE not setq'ing *PACKAGE*, I just think the proposalshould make it more clear why it doesn't, and emphasize thatDEFPACKAGE really isn't supposed to be used the same way as the SevenExtremely Randoms.  I was confused and maybe other people are too.-Sandra-------*start*02416 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 27 OCT 88 11:51:33 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 27 Oct 88  09:53:55 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 482989; Thu 27-Oct-88 12:53:29 EDTDate: Thu, 27 Oct 88 12:53 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: issue DEFPACKAGETo: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: peck@Sun.COM, Jon L White <jonl@lucid.com>, cl-cleanup@sail.stanford.edu, cl-compiler@sail.stanford.eduIn-Reply-To: <8810270428.AA29800@defun.utah.edu>Message-ID: <19881027165315.1.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Wed, 26 Oct 88 22:28:17 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    > Date: Wed, 26 Oct 88 23:11 EDT    > From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    >     >     Finally, what is the motivation for not having DEFPACKAGE setq *PACKAGE*?    >     > What is the motivation for not having DEFUN call the function?    > That's not a joke, my point is that the two operations of defining    > a package and switching the current package have little to do with    > each other and are rarely done together.    My original impression of what this proposal was for was to introduce    a somewhat cleaner mechanism to do what one currently uses the Seven    Extremely Randoms for.  IN-PACKAGE is one of those.  If one follows    the style set forth in CLtL, then defining a package and switching the    current package -are- usually done together.  I see.  But the thing is, part of the reason for introducing DEFPACKAGE,and for removing the ability of IN-PACKAGE to create packages, is thatthe style set forth in CLtL is broken and doesn't work.  I guess I've beensaying that for so long now (about five years) that I've forgotten it isn'tintuitively evident.						  I don't have any problem    with DEFPACKAGE not setq'ing *PACKAGE*, I just think the proposal    should make it more clear why it doesn't, and emphasize that    DEFPACKAGE really isn't supposed to be used the same way as the Seven    Extremely Randoms.  I was confused and maybe other people are too.    -Sandra    -------*start*02631 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 29 OCT 88 00:17:37 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 29 Oct 88  00:16:18 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02676g; Sat, 29 Oct 88 00:15:27 PDTReceived: by bhopal id AA17560g; Sat, 29 Oct 88 00:14:00 PDTDate: Sat, 29 Oct 88 00:14:00 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810290714.AA17560@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@Sail.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 26 Oct 88 22:58 EDT <19881027025834.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DEFPACKAGE (version 6)re: :INTERNAL was a typo for :INTERN; I apologize. Ok, fine by me; we stick with the "VERB" analogy for the options namesrather than the "ADJECTIVE" analogy.re: 	An attempt to re-define a package with a smaller set of attributes 	should signal a  continuable error; at most one such error is to be	signalled per call to DEFPACKAGE, regardless of how many attributes         are being re-tracted; upon continuation, the package is created with         exactly as specified.    Even without the typos I would object to this.  It's not clear to me    that signalling an error is the correct response in all programming    environments for evaluating a DEFPACKAGE with fewer attributes.    . . .     I think it would be a much better idea to leave redefinition of packages    undefined, just like redefinition of functions or macros.I thought the above wording came from a consensus among several people (who? maybe KMP and vanMelle?); probably that was the week that you were out.  Nevertheless, I strongly disagree that we can leave the redefinition question completely alone; we simply cannot allow DEFPACKAGE to operatelike DEFUN, where only the name-to-object mapping is changed.  [By theway, even if CLtL doesn't spell it out, "common practice" for more than20 years says that re-doing a DEFUN or DEFMACRO doesn't alter an existing function object, but instead simply changes the symbol-function "cell".]Like CLOS classes and generic functions, packages are a global databasereferenced "by name" and incrementally definable; a subsequent redefinitionmust give some accountability to the old instances.   I'm not at all impressed that "many people still argue that CLOS got it wrong";  at least it clearly states that class redefinition isn't merely an alteration of the name-to-class mapping.-- JonL --*start*01564 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 31 OCT 88 17:00:07 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 31 Oct 88  10:59:51 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 31 OCT 88 10:38:01 PSTDate: 31 Oct 88 10:37 PSTFrom: masinter.paSubject: Re: Issue: DEFPACKAGE (version 6)In-reply-to: Jon L White <jonl@lucid.com>'s message of Sat, 29 Oct 88 00:14:00 PDTTo: CL-Cleanup@Sail.stanford.eduMessage-ID: <881031-103801-5947@Xerox>Arguments of the form "we should leave A undefined because B is undefined"are weak, especially if there is some hope of defining B.However, I don't think we will make much progress on DEFPACKAGE unless weleave, for now, that the results of executing more than one DEFPACKAGE onthe same string is unspecified. We might want to add to the commentary thatwe expect some implementations may signal a continuable error, but otherenvironment-specific action might also be reasonable.Now that we have the new error terminology, I think encoruaging thesignalling of an error might be a reasonable resolution if we expectlegitimate programs to actually catch the error and process it. Onecriteria by which we should judge that might be how far we are willing tospecify the exact nature of the condition to be signalled.In this case, we're not close to a good design that is agreeable.Could we get a new writeup with the "redefinition" behavior explicitlyvague?*start*13520 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 NOV 88 13:17:01 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 3 Nov 88  20:21:32 PSTReceived: from bhopal ([192.9.200.13]) by LUCID.COM id AA01943g; Thu, 3 Nov 88 20:20:37 PSTReceived: by bhopal id AA21511g; Thu, 3 Nov 88 20:19:13 PSTDate: Thu, 3 Nov 88 20:19:13 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811040419.AA21511@bhopal>To: CL-Cleanup@SAIL.Stanford.eduSubject: Issue: DEFPACKAGE (version 7)Here's a "cleanup" of the cleanup, incorporating nits etc from    sandra%defun@cs.utah.edu on Date: Thu, 13 Oct 88 14:34:04 MDT    peck@Sun.COM on Mon, 17 Oct 88 17:19:14 -0700    Moon@STONY-BROOK.SCRC.Symbolics.COM on Wed, 26 Oct 88 22:58 EDT    masinter.pa@Xerox.COM on 31 Oct 88 10:37 PSTas well as some further discussion and re-wordings by me.  In particular,the discussion contains a new suggestion to replace the mnemonic of the "7 Extremely Randoms".-- JonL --!Issue:         DEFPACKAGEReferences:    CLtL section 11.7.               Issue: IN-PACKAGE-FUNCTIONALITY               Issue: MAKE-PACKAGE-USE-DEFAULT               Issue: PACKAGE-DELETIONCategory:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussion               Version 3, 27-Sep-88, JonL                 (remove :import, :shadowing-import; allow :export to work on                 imported and inherited; update references to in-package, etc.)               Version 4,  1-Oct-88, Masinter               Version 5, 6-Oct-88, Moon               Version 6, 6-Oct-88, JonL (little nits)               Version 7, 2-Nov-88, JonL 		 (incorporate further discussion; simplify handling of		  syntactic errors; specify ordering constraints).Problem description:Many users incorrectly think that package operations can be performedin any order.  CLtL (p.192) contributes to this misconception.Programmers need direction on the ordering constraint, especially forcreating packages, since doing things out of order can lead toconfusing or even intractable problems.If the definition of a package is scattered throughout a program as a number of individual forms, it is very easy to read a symbol before the package setup needed to read that symbol correctly has been accomplished. Three examples: an inherited symbol that should have been shadowed might be accessed; a single-colon prefix might be used for a symbol that hasn'tyet been exported; an internal symbol might be created afresh where a symbol that will later be imported or inherited was intended.  These problems can be difficult to understand or even to recognize; in some cases it is difficult or impossible to correct the situation in thesame Lisp image.Proposal (DEFPACKAGE:ADDITION):      Add a DEFPACKAGE macro to the language.  In the description below,'package-name' and 'symbol-name' can be a symbol or a string; if a symbol, only its name matters, not what package it is in.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.Standard options for DEFPACKAGE are listed below.   Except for :SIZE, options may appear more than once (this is useful primarily for :IMPORT-FROM and :SHADOWING-IMPORT-FROM).(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified names.(:USE {package-name}*)        The package is to "use" the other designated packages; that is,        it will inherit from them.  The default value for this option         should be the same as it is for MAKE-PACKAGE (also see the issue        MAKE-PACKAGE-USE-DEFAULT).(:SHADOW {symbol-name}*)        Create the specified symbols in the package being defined,         making them shadows, just as the function SHADOW would do.(:SHADOWING-IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package, import        them into the package being defined, and place them on the         shadowing symbols list.  In no case will symbols be created in         any package other than the one being defined; a continuable error         is signaled if no symbol is accessible in the package named         package-name for one of the symbol-names.(:IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined.  In no case will symbols be         created in a package other than the one being defined; a continuable        error is signaled if no symbol is accessible in the package named         package-name for one of the symbol-names.(:EXPORT {symbol-name}*)        Find or create symbols with the specified names and export them.        Note an interaction with the :USE option, since inherited symbols         can be used rather than new ones created;  note also an interaction         with the :IMPORT-FROM and :SHADOWING-IMPORT-FROM options, since 	imported symbols can be used rather than new ones created.(:INTERN {symbol-name}*)        Find or create symbols with the specified names.  Note an         interaction with the :USE option, since inherited symbols         can be used rather than new ones created.  This option is useful if         an :IMPORT-FROM or a :SHADOWING-IMPORT-FROM option in a subsequent         call to DEFPACKAGE (for some other package) expects to find these         symbols accessible but not necessarily external.(:SIZE integer)        Declare the approximate number of symbols expected in the package.        This is an efficiency hint only, so that the package's table will        not have to be frequently re-expanded when new symbols are added        to it (e.g., by reading in a large file "in" that package).The order in which the options occur in a DEFPACKAGE form is irrelevant;but since the effects of the entry-making options are context-sensitive, the order in which they will be executed is as follows:  (1) :SHADOW and :SHADOWING-IMPORT-FROM   (2) :USE   (3) :IMPORT-FROM and :INTERN  (4) :EXPORTShadows are established first, since they may be necessary to block spurious name conflicts when the use link is established.  Use links are established next so that :intern and :export may refer to normally inherited symbols.  The :export is done last so that it may refer to symbols created by any of the other options; in particular, shadows and imported symbols can be made external.  Note also the prescription on CLtL p.178 to cover the case of calling EXPORT on an inherited symbol.DEFPACKAGE creates the package as specified and returns it as its value.It has no other side effects; e.g., it does not alter the value of *PACKAGE*.The function COMPILE-FILE should treat top-level DEFPACKAGE forms thesame way it treats the other package-effecting functions (see CLtL p.182).If the specified name already refers to an existing package, then the name-to-package mapping for that name is not changed.   At most, the existing package will be modified to reflect the new definition;  it is undefined what happens if the new definition is at variance with the current state of that package.  If one of the specified nicknames alreadyrefers to an existing package, then an error is signaled just the sameas MAKE-PACKAGE would.  See the issue PACKAGE-DELETION for undoing thename-to-package mapping.Some DEFPACKAGE errors are, however,  purely syntactic.  (1) An error should be signaled if :SIZE appears than once.  (2) Since extended options might be allowed by other implementations,       an error should be signaled if an option is present that is not       actually supported in this implementation.  (3) The collection of symbol-name arguments given to the options       :SHADOW, :INTERN, :IMPORT-FROM, and :SHADOWING-IMPORT-FROM must       all be disjoint; additionally, the symbol-name arguments given to       :EXPORT and :INTERN must be disjoint. If either condition is       violated, an error should be signaled.Name conflict errors will, of course, be handled by the underlying calls to USE-PACKAGE, IMPORT, and EXPORT.Examples:;;; An example that "plays it super-safe" by using only strings as names; ;;;  does not even assume that the package it is read in to "uses" LISP; ;;   *never* creates any symbols whatsoever in the package that it is read ;;     in to.(LISP:DEFPACKAGE "MY-PACKAGE"  (:NICKNAMES "MYPKG" "MY-PKG")  (:USE "LISP")  (:SHADOW "CAR" "CDR")  (:SHADOWING-IMPORT-FROM "VENDOR-COMMON-LISP"  "CONS")  (:IMPORT-FROM           "VENDOR-COMMON-LISP"  "GC")  (:EXPORT "EQ" "CONS" "FROBOLA")  );;; A similar call, mostly using symbols rather than strings as names.;;; Expects to be read in to a package that "uses" LISP and *may* create;;;  random internal symbols in that package (such as MY-PACKAGE etc).(defpackage my-package  (:nicknames mypkg :MY-PKG)		;remember CL conventions for case  (:use lisp)				; conversion on symbols  (:shadow CAR :cdr #:cons)  (:export "CONS")			;yes, this is the shadowed one.  )Rationale:The availability of DEFPACKAGE encourages putting the entire package definition in a single place.  It also encourages putting all the package definitions of a program in a single file, which can be loaded before loading or compiling anything else that depends on those packages; such afile can be read in the USER package, avoiding any initial state issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Current practice:Symbolics Common Lisp (SCL) has always had a DEFPACKAGE, and usersprefer it to individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCLversion of DEFPACKAGE has quite a few additional options, but none ofthem appears to be necessary to propose for Common Lisp at this time.This proposal is incompatible with Symbolics DEFPACKAGE in some waysthat will probably not cause major problems.Cost to Implementors:Small--DEFPACKAGE can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:Small, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:It has been suggested that the "Put IN Seven EXtremely Random USErInterface COmmands" mnemonic described in CLtL p.191 could be removed;and with possibly a few exceptions, the special handling of them byCOMPILE-FILE could be removed.  As this would be an incompatible change, it is not part of this proposal.  However, a new mnemonic can be offered, to help remember the ordering constraints mentioned above:          I REmember Six USEr Interface ExpressionsEach word in the sentence corresponds to one operation listed below:   I				IN-PACKAGE	;"foot" to stand on   REmember			REQUIRE		;ensure pre-requisite packages   Six				SHADOW		;block multiple-inheritances   USEr				USE-PACKAGE	;go for it!   Interface			IMPORT		;bring in "foreign" symbols   EXpressions			EXPORT		;a "face" to show to others.It is noted that DEFPACKAGE cannot be used to create two "mutuallyrecursive" packages, such as:    (defpackage my-package      (:use lisp your-package)	        ;requires 'your-package' to exist first      (:export "MY-FUN"))    (defpackage your-package      (:use lisp)      (:import-from my-package "MY-FUN") ;requires 'my-package' to exist first      (:export "MY-FUN"))However, nothing prevents one from using the package-effecting functions such as USE-PACKAGE, IMPORT, and EXPORT to establish such links (whichought to be very rare) after a more standard use of DEFPACKAGE.The macroexpansion of DEFPACKAGE could usefully canonicalize the namesinto strings, so that even if a source file has random symbols in theDEFPACKAGE form, the compiled file would only contain strings.Frequently additional implementation-dependent options take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.Definition forms in Common Lisp usually just establish a name-to-objectmapping; there is little precedent for them to modify other global-contextstate.  For this reason, we didn't want DEFPACKAGE also to "go" into the new package.  If it did so, like IN-PACKAGE, then the following reasonable file would become confused, because it wouldn't all be in one package:   (in-package "USER")   (defpackage "WATER"      (:use "LISP")             (:export "FISH"))   (defpackage "ALCHEMY"    (:use "LISP" "PHLOGISTON) (:export gold))Should the token 'gold' be read while in the USER package, or in thethe WATER package?The issue IN-PACKAGE-FUNCTIONALITY recommends that IN-PACKAGE  be incompatibly changed to recognize only existing packages, not to create them.  IN-PACKAGE would then not accept any keyword arguments.The function MAKE-PACKAGE might also be extended to take all the keywordsthat DEFPACKAGE does. This could be the subject of a separate cleanup.*start*12961 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 DEC 88 17:02:27 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Dec 88  16:41:24 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 05 DEC 88 16:39:43 PSTDate: 5 Dec 88 16:39 PSTSender: masinter.pato: X3J13@sail.stanford.eduFrom: cl-cleanup@sail.stanford.eduSubject: Issue: DEFPACKAGE (Version 7)reply-to: CL-CLEANUP@Sail.stanford.eduMessage-ID: <881205-163943-4628@Xerox>!Issue:         DEFPACKAGEReferences:    CLtL section 11.7.               Issue: IN-PACKAGE-FUNCTIONALITY               Issue: MAKE-PACKAGE-USE-DEFAULT               Issue: PACKAGE-DELETIONCategory:      ADDITIONEdit history:  Version 1, 12-Mar-88, Moon               Version 2, 23-Mar-88, Moon, changes based on discussion               Version 3, 27-Sep-88, JonL                 (remove :import, :shadowing-import; allow :export to work on                 imported and inherited; update references to in-package, etc.)               Version 4,  1-Oct-88, Masinter               Version 5, 6-Oct-88, Moon               Version 6, 6-Oct-88, JonL (little nits)               Version 7, 2-Nov-88, JonL 		 (incorporate further discussion; simplify handling of		  syntactic errors; specify ordering constraints).Problem description:Many users incorrectly think that package operations can be performedin any order.  CLtL (p.192) contributes to this misconception.Programmers need direction on the ordering constraint, especially forcreating packages, since doing things out of order can lead toconfusing or even intractable problems.If the definition of a package is scattered throughout a program as a number of individual forms, it is very easy to read a symbol before the package setup needed to read that symbol correctly has been accomplished. Three examples: an inherited symbol that should have been shadowed might be accessed; a single-colon prefix might be used for a symbol that hasn'tyet been exported; an internal symbol might be created afresh where a symbol that will later be imported or inherited was intended.  These problems can be difficult to understand or even to recognize; in some cases it is difficult or impossible to correct the situation in thesame Lisp image.Proposal (DEFPACKAGE:ADDITION):      Add a DEFPACKAGE macro to the language.  In the description below,'package-name' and 'symbol-name' can be a symbol or a string; if a symbol, only its name matters, not what package it is in.The syntax of DEFPACKAGE is  (DEFPACKAGE package-name {option}*)where each option is a list of a keyword and arguments.  Nothing in aDEFPACKAGE form is evaluated.Standard options for DEFPACKAGE are listed below.   Except for :SIZE, options may appear more than once (this is useful primarily for :IMPORT-FROM and :SHADOWING-IMPORT-FROM).(:NICKNAMES {package-name}*)        Set the package's nicknames to the specified names.(:USE {package-name}*)        The package is to "use" the other designated packages; that is,        it will inherit from them.  The default value for this option         should be the same as it is for MAKE-PACKAGE (also see the issue        MAKE-PACKAGE-USE-DEFAULT).(:SHADOW {symbol-name}*)        Create the specified symbols in the package being defined,         making them shadows, just as the function SHADOW would do.(:SHADOWING-IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package, import        them into the package being defined, and place them on the         shadowing symbols list.  In no case will symbols be created in         any package other than the one being defined; a continuable error         is signaled if no symbol is accessible in the package named         package-name for one of the symbol-names.(:IMPORT-FROM package-name {symbol-name}*)        Find the specified symbols in the specified package and import        them into the package being defined.  In no case will symbols be         created in a package other than the one being defined; a continuable        error is signaled if no symbol is accessible in the package named         package-name for one of the symbol-names.(:EXPORT {symbol-name}*)        Find or create symbols with the specified names and export them.        Note an interaction with the :USE option, since inherited symbols         can be used rather than new ones created;  note also an interaction         with the :IMPORT-FROM and :SHADOWING-IMPORT-FROM options, since 	imported symbols can be used rather than new ones created.(:INTERN {symbol-name}*)        Find or create symbols with the specified names.  Note an         interaction with the :USE option, since inherited symbols         can be used rather than new ones created.  This option is useful if         an :IMPORT-FROM or a :SHADOWING-IMPORT-FROM option in a subsequent         call to DEFPACKAGE (for some other package) expects to find these         symbols accessible but not necessarily external.(:SIZE integer)        Declare the approximate number of symbols expected in the package.        This is an efficiency hint only, so that the package's table will        not have to be frequently re-expanded when new symbols are added        to it (e.g., by reading in a large file "in" that package).The order in which the options occur in a DEFPACKAGE form is irrelevant;but since the effects of the entry-making options are context-sensitive, the order in which they will be executed is as follows:  (1) :SHADOW and :SHADOWING-IMPORT-FROM   (2) :USE   (3) :IMPORT-FROM and :INTERN  (4) :EXPORTShadows are established first, since they may be necessary to block spurious name conflicts when the use link is established.  Use links are established next so that :intern and :export may refer to normally inherited symbols.  The :export is done last so that it may refer to symbols created by any of the other options; in particular, shadows and imported symbols can be made external.  Note also the prescription on CLtL p.178 to cover the case of calling EXPORT on an inherited symbol.DEFPACKAGE creates the package as specified and returns it as its value.It has no other side effects; e.g., it does not alter the value of *PACKAGE*.The function COMPILE-FILE should treat top-level DEFPACKAGE forms thesame way it treats the other package-effecting functions (see CLtL p.182).If the specified name already refers to an existing package, then the name-to-package mapping for that name is not changed.   At most, the existing package will be modified to reflect the new definition;  it is undefined what happens if the new definition is at variance with the current state of that package.  If one of the specified nicknames alreadyrefers to an existing package, then an error is signaled just the sameas MAKE-PACKAGE would.  See the issue PACKAGE-DELETION for undoing thename-to-package mapping.Some DEFPACKAGE errors are, however,  purely syntactic.  (1) An error should be signaled if :SIZE appears than once.  (2) Since extended options might be allowed by other implementations,       an error should be signaled if an option is present that is not       actually supported in this implementation.  (3) The collection of symbol-name arguments given to the options       :SHADOW, :INTERN, :IMPORT-FROM, and :SHADOWING-IMPORT-FROM must       all be disjoint; additionally, the symbol-name arguments given to       :EXPORT and :INTERN must be disjoint. If either condition is       violated, an error should be signaled.Name conflict errors will, of course, be handled by the underlying calls to USE-PACKAGE, IMPORT, and EXPORT.Examples:;;; An example that "plays it super-safe" by using only strings as names; ;;;  does not even assume that the package it is read in to "uses" LISP; ;;   *never* creates any symbols whatsoever in the package that it is read ;;     in to.(LISP:DEFPACKAGE "MY-PACKAGE"  (:NICKNAMES "MYPKG" "MY-PKG")  (:USE "LISP")  (:SHADOW "CAR" "CDR")  (:SHADOWING-IMPORT-FROM "VENDOR-COMMON-LISP"  "CONS")  (:IMPORT-FROM           "VENDOR-COMMON-LISP"  "GC")  (:EXPORT "EQ" "CONS" "FROBOLA")  );;; A similar call, mostly using symbols rather than strings as names.;;; Expects to be read in to a package that "uses" LISP and *may* create;;;  random internal symbols in that package (such as MY-PACKAGE etc).(defpackage my-package  (:nicknames mypkg :MY-PKG)		;remember CL conventions for case  (:use lisp)				; conversion on symbols  (:shadow CAR :cdr #:cons)  (:export "CONS")			;yes, this is the shadowed one.  )Rationale:The availability of DEFPACKAGE encourages putting the entire package definition in a single place.  It also encourages putting all the package definitions of a program in a single file, which can be loaded before loading or compiling anything else that depends on those packages; such afile can be read in the USER package, avoiding any initial state issues.In addition, DEFPACKAGE allows a programming environment to processthe whole package setup as a unit, providing better error-checking andmore assistance with package problems, by dint of global knowledge ofthe package setup.Current practice:Symbolics Common Lisp (SCL) has always had a DEFPACKAGE, and usersprefer it to individual calls to EXPORT, IMPORT, SHADOW, etc.  The SCLversion of DEFPACKAGE has quite a few additional options, but none ofthem appears to be necessary to propose for Common Lisp at this time.This proposal is incompatible with Symbolics DEFPACKAGE in some waysthat will probably not cause major problems.Cost to Implementors:Small--DEFPACKAGE can be implemented simply as a bunch ofcalls to existing functions.Cost to Users:Small, this is upward compatible.Cost of non-adoption:Packages continue to be difficult to use correctly.Benefits:Guide users away from using packages in ways that get them into trouble.Esthetics:Neutral.Discussion:It has been suggested that the "Put IN Seven EXtremely Random USErInterface COmmands" mnemonic described in CLtL p.191 could be removed;and with possibly a few exceptions, the special handling of them byCOMPILE-FILE could be removed.  As this would be an incompatible change, it is not part of this proposal.  However, a new mnemonic can be offered, to help remember the ordering constraints mentioned above:          I REmember Six USEr Interface ExpressionsEach word in the sentence corresponds to one operation listed below:   I				IN-PACKAGE	;"foot" to stand on   REmember			REQUIRE		;ensure pre-requisite packages   Six				SHADOW		;block multiple-inheritances   USEr				USE-PACKAGE	;go for it!   Interface			IMPORT		;bring in "foreign" symbols   EXpressions			EXPORT		;a "face" to show to others.It is noted that DEFPACKAGE cannot be used to create two "mutuallyrecursive" packages, such as:    (defpackage my-package      (:use lisp your-package)	      ;requires 'your-package' to exist first      (:export "MY-FUN"))    (defpackage your-package      (:use lisp)      (:import-from my-package "MY-FUN") ;requires 'my-package' to exist first      (:export "MY-FUN"))However, nothing prevents one from using the package-effecting functions such as USE-PACKAGE, IMPORT, and EXPORT to establish such links (whichought to be very rare) after a more standard use of DEFPACKAGE.The macroexpansion of DEFPACKAGE could usefully canonicalize the namesinto strings, so that even if a source file has random symbols in theDEFPACKAGE form, the compiled file would only contain strings.Frequently additional implementation-dependent options take theform of a keyword standing by itself as an abbreviation for a list(keyword T); this syntax should be properly reported as an unrecognizedoption in implementations that do not support it.Definition forms in Common Lisp usually just establish a name-to-objectmapping; there is little precedent for them to modify other global-contextstate.  For this reason, we didn't want DEFPACKAGE also to "go" into the new package.  If it did so, like IN-PACKAGE, then the following reasonable file would become confused, because it wouldn't all be in one package:   (in-package "USER")   (defpackage "WATER"      (:use "LISP")             (:export "FISH"))   (defpackage "ALCHEMY"    (:use "LISP" "PHLOGISTON) (:export gold))Should the token 'gold' be read while in the USER package, or in thethe WATER package?The issue IN-PACKAGE-FUNCTIONALITY recommends that IN-PACKAGE  be incompatibly changed to recognize only existing packages, not to create them.  IN-PACKAGE would then not accept any keyword arguments.The function MAKE-PACKAGE might also be extended to take all the keywordsthat DEFPACKAGE does. This could be the subject of a separate cleanup.*start*01785 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 DEC 88 08:06:47 PSTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 6 Dec 88  08:00:41 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Tue, 6 Dec 88 10:20:15 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Tue, 6 Dec 88 10:58:05 ESTDate: Tue, 6 Dec 88 10:58 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: DEFPACKAGE (Version 7)To: CL-CLEANUP@sail.stanford.eduIn-Reply-To: <881205-163943-4628@Xerox>Message-Id: <19881206155814.7.BARMAR@OCCAM.THINK.COM>    Date: 5 Dec 88 16:39 PST    From: cl-cleanup@sail.stanford.edu    If the specified name already refers to an existing package, then the     name-to-package mapping for that name is not changed.   At most, the     existing package will be modified to reflect the new definition;  it is     undefined what happens if the new definition is at variance with the     current state of that package.What does "at variance" mean in this context?  Is the followingundefined?(progn  (defpackage my-package    (:use lisp))  (defpackage my-package    (:use lisp)    (:import-from my-other-package another-symbol)))Is the second definition (which specifies an imported symbol that is notaccessible in the package at the time) at variance with the state of thepackage?My first reaction is that the only thing that should be undefined is ifthe new definition specifies a different :USE list.  The rest of thepossible conflicts could be handled using the normal error handling ofthe package modification functions.                                                barmar*start*01281 00024 US Return-Path: <barmar@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 06 DEC 88 21:34:17 PSTReturn-Path: <barmar@Think.COM>Received: from kulla.think.com by Think.COM; Tue, 6 Dec 88 23:53:22 ESTReceived: by kulla.think.com; Wed, 7 Dec 88 00:31:55 ESTDate: Wed, 7 Dec 88 00:31:55 ESTFrom: barmar@Think.COMMessage-Id: <8812070531.AA25121@kulla.think.com>To: masinter.paCc: CL-CLEANUP@sail.stanford.eduIn-Reply-To: masinter.pa@xerox.com's message of 6 Dec 88 18:02 PST <881206-180400-7319@Xerox>Subject: Issue: DEFPACKAGE (Version 7)In that case, I guess I want to know what the writeup meant when itsaid "At most, the existing package will be modified to reflect thenew definition".  Is this just a suggestion to implementors about whatthey MIGHT do, but not a requirement to do it?Yes, I think it would be nice if this were reworded to make thisclearer.  Assuming I am correct above, this could be something like"It is undefined but benign [or whatever we decided the appropriatewording for this situation is] what happens if the new definition is atvariance with the current state of the package; if this has anyeffect, it will be no more than updating the existing package toreflect the new definition."						barmar*start*01194 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 DEC 88 18:18:37 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Dec 88  18:08:38 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 06 DEC 88 18:04:00 PSTDate: 6 Dec 88 18:02 PSTFrom: masinter.paSubject: Re: Issue: DEFPACKAGE (Version 7)In-reply-to: Barry Margolin <barmar@Think.COM>'s message of Tue, 6 Dec 88 10:58 ESTTo: Barry Margolin <barmar@Think.COM>cc: CL-CLEANUP@sail.stanford.eduMessage-ID: <881206-180400-7319@Xerox>Our intent in "at variance" was specifically to make the behavior ofDEFPACKAGE undefined in the example you cited. We specifically did not wantto proscribe that DEFPACKAGE had to resolve conflicts according to "thenormal error handling of the package modification functions", becauseDEFPACKAGE, when it occurs at the beginning of a file during compilation,might have some extra processing associated with it that would make such"normal error handling" difficult or impossible.Do you think we need to revise the writeup before ballot to clarify thispoint?*start*02547 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 DEC 88 01:17:28 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Dec 88  01:11:07 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00939g; Wed, 7 Dec 88 01:08:43 PSTReceived: by bhopal id AA11758g; Wed, 7 Dec 88 01:10:34 PSTDate: Wed, 7 Dec 88 01:10:34 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812070910.AA11758@bhopal>To: barmar@Think.COMCc: CL-CLEANUP@sail.stanford.eduIn-Reply-To: Barry Margolin's message of Tue, 6 Dec 88 10:58 EST <19881206155814.7.BARMAR@OCCAM.THINK.COM>Subject: Issue: DEFPACKAGE (Version 7)re: My first reaction is that the only thing that should be undefined is if    the new definition specifies a different :USE list.  The rest of the    possible conflicts could be handled using the normal error handling of    the package modification functions.The term isn't "conflicts", but "variances" between the first definitionand the second.  The :use list isn't the only significant variance;consider the set of :export'd symbols.One of the most common recipes for disaster is to have differing EXPORTsin two package definitions, and then to load a file which was compiled inone of these two enviroments into a "runtime" image that has the otherenvironment.  The file being loaded may expect to inherit some symbols(due to their being EXPORT'd from a "used" package at compile time); but failing to inherit at "run time", it will create a Doppelganger in the current packageVirtually any difference *can* be made to be critical, due to the factthat the package system is a global database in a flat namespace (thereis no "context" for FIND-PACKAGE).  Leaving it undefined as to how to handle varying package re-definitions allows the implementations toexperiment with helpful warnings, recovery stratagies, etc.-- JonL --P.S. For many years now, I've  used the term "Doppelganger" to refer to     a symbol of the same print-name, but not EQ to the one desired.     Sooner or later, a Doppelganger _may_ cause a name-conflict error;     but often it is only after pointers to it have been read-in and     distributed throughout the whole system (makeing it almost      impossible to correct the problem).  Often the Doppelganger just     quitely masquarades as the real thing, and you get "unbound     function" errors rather than package name conflicts.*start*03068 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 07 DEC 88 15:01:03 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00466g; Wed, 7 Dec 88 14:59:01 PSTReceived: by bhopal id AA01408g; Wed, 7 Dec 88 15:00:53 PSTDate: Wed, 7 Dec 88 15:00:53 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812072300.AA01408@bhopal>To: masinter.pa, barmar@Think.COMCc: CL-CLEANUP@sail.stanford.eduIn-Reply-To: messages from masinter.pa@Xerox.COM  6 Dec 88 18:02 PST,     and from barmar@Think.COM 7 Dec 88 00:31:55 ESTSubject: Issue: DEFPACKAGE (Version 7)re: Date: 6 Dec 88 18:02 PST    From: masinter.pa@Xerox.COM    Subject: Re: Issue: DEFPACKAGE (Version 7)    Our intent in "at variance" was specifically to make the behavior of    DEFPACKAGE undefined in the example you cited. We specifically did not want    to proscribe that DEFPACKAGE had to resolve conflicts according to "the    normal error handling of the package modification functions", because    DEFPACKAGE, when it occurs at the beginning of a file during compilation,    might have some extra processing associated with it that would make such    "normal error handling" difficult or impossible.What you mean "We", white man?We specifically do mean that DEFPACKAGE must resolve name conflicts caused by the creation of such a package. There is an entire sectionof the proposal dealing with the order of sub-events so that, forexample, shadowing can be done before "using", and thus preventspurious name conflicts.re: Date: Wed, 7 Dec 88 00:31:55 EST    From: barmar@Think.COM    Subject: Issue: DEFPACKAGE (Version 7)    In that case, I guess I want to know what the writeup meant when it    said "At most, the existing package will be modified to reflect the    new definition".  Is this just a suggestion to implementors about what    they MIGHT do, but not a requirement to do it?The very sentence in the proposal just before the one you are wonderingabout explains what "At most ..." means.  The context is:    If the specified name already refers to an existing package, then the     name-to-package mapping for that name is not changed.   At most, the     existing package will be modified to reflect the new definition;  it is     undefined what happens if the new definition is at variance with the     current state of that package.  If one of the specified nicknames already    refers to an existing package, then an error is signaled just the same    as MAKE-PACKAGE would.  See the issue PACKAGE-DELETION for undoing the    name-to-package mapping.You may not however assume that effect is "benign"!  In general, package changes are frequently _not_ benign; so continuing at all carries somerisk of disaster.  Yet so often, many common, trivial changes ought to beoverlooked -- the implementation can be a bit "forgiving"; for that very reason we decided to allow an implementation-dependent recovery action,rather than requiring an error signal.-- JonL --*start*04363 00024 USaReturn-Path: <barmar@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 07 DEC 88 15:54:08 PSTReturn-Path: <barmar@Think.COM>Received: from sauron.think.com by Think.COM; Wed, 7 Dec 88 18:12:38 ESTReceived: from OCCAM.THINK.COM by sauron.think.com; Wed, 7 Dec 88 18:52:01 ESTDate: Wed, 7 Dec 88 18:52 ESTFrom: Barry Margolin <barmar@Think.COM>Subject: Issue: DEFPACKAGE (Version 7)To: Jon L White <jonl@lucid.com>Cc: masinter.pa, CL-CLEANUP@sail.stanford.eduIn-Reply-To: <8812072300.AA01408@bhopal>Message-Id: <19881207235211.4.BARMAR@OCCAM.THINK.COM>    Date: Wed, 7 Dec 88 15:00:53 PST    From: Jon L White <jonl@lucid.com>    re: Date: 6 Dec 88 18:02 PST	From: masinter.pa@Xerox.COM	Subject: Re: Issue: DEFPACKAGE (Version 7)	Our intent in "at variance" was specifically to make the behavior of	DEFPACKAGE undefined in the example you cited. We specifically did not want	to proscribe that DEFPACKAGE had to resolve conflicts according to "the	normal error handling of the package modification functions", because	DEFPACKAGE, when it occurs at the beginning of a file during compilation,	might have some extra processing associated with it that would make such	"normal error handling" difficult or impossible.    What you mean "We", white man?    We specifically do mean that DEFPACKAGE must resolve name conflicts     caused by the creation of such a package. There is an entire section    of the proposal dealing with the order of sub-events so that, for    example, shadowing can be done before "using", and thus prevent    spurious name conflicts.He's referring to the name conflicts caused by re-executing a DEFPACKAGEwith different options, not the name conflicts resulting from an initialDEFPACKAGE.  The issues aren't the same.  In particular, if the secondDEFPACKAGE has a :SHADOW option, it will be executed after the firstDEFPACKAGE's :USE, violating the intent of DEFPACKAGE.    re: Date: Wed, 7 Dec 88 00:31:55 EST	From: barmar@Think.COM	Subject: Issue: DEFPACKAGE (Version 7)	In that case, I guess I want to know what the writeup meant when it	said "At most, the existing package will be modified to reflect the	new definition".  Is this just a suggestion to implementors about what	they MIGHT do, but not a requirement to do it?    The very sentence in the proposal just before the one you are wondering    about explains what "At most ..." means.  The context is:	If the specified name already refers to an existing package, then the 	name-to-package mapping for that name is not changed.   At most, the 	existing package will be modified to reflect the new definition;  it is 	undefined what happens if the new definition is at variance with the 	current state of that package.  If one of the specified nicknames already	refers to an existing package, then an error is signaled just the same	as MAKE-PACKAGE would.  See the issue PACKAGE-DELETION for undoing the	name-to-package mapping.The additional context doesn't help.  The first sentence of theparagraph only says that it won't do one particular thing.  The problemwith the phrase "at most" is that it assumes a well-defined set ofpossible results, so that one can decide whether a particular result iswithin that set.    You may not however assume that effect is "benign"!  In general, package     changes are frequently _not_ benign; so continuing at all carries some    risk of disaster.  Yet so often, many common, trivial changes ought to be    overlooked -- the implementation can be a bit "forgiving"; for that very     reason we decided to allow an implementation-dependent recovery action,    rather than requiring an error signal.The intent of the "undefined but benign" (I don't think this is Kathy'sterminology, but I don't remember what it is) error situation is tospecify that while the results are implementation-dependent, they don'tdirectly result in fatal errors.  Calling DEFPACKAGE twice with the samepackage name but different options should never damage the Lispenvironment, but it might result in unexpected package relationships;compare this with the specification of the results of (+ 'a 'b), whichmight result in a core dump on a conventional architecture with highspeed and low safety.                                                barmar*start*00765 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 17:49:51 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  17:48:30 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 17:43:54 PSTDate: 9 Dec 88 17:42 PSTFrom: masinter.paSubject: Re: Issue: DEFPACKAGE (Version 7)In-reply-to: Barry Margolin <barmar@Think.COM>'s message of Wed, 7 Dec 88 18:52 ESTTo: Barry Margolin <barmar@Think.COM>, Jon L White <jonl@lucid.com>, CL-CLEANUP@sail.stanford.eduMessage-ID: <881209-174354-1798@Xerox>Apparently the writeup (already released to X3J13 on 7 Dec) needs a clarification. Who will prepare it?*start*03322 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 10 DEC 88 00:19:27 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03076g; Sat, 10 Dec 88 00:17:33 PSTReceived: by bhopal id AA07741g; Sat, 10 Dec 88 00:19:29 PSTDate: Sat, 10 Dec 88 00:19:29 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812100819.AA07741@bhopal>To: barmar@Think.COMCc: masinter.pa, CL-CLEANUP@sail.stanford.eduIn-Reply-To: Barry Margolin's message of Wed, 7 Dec 88 18:52 EST <19881207235211.4.BARMAR@OCCAM.THINK.COM>Subject: Issue: DEFPACKAGE (Version 7)re: He's referring to the name conflicts caused by re-executing a DEFPACKAGE    with different options, not the name conflicts resulting from an initial    DEFPACKAGE.  The issues aren't the same.  In particular, if the second    DEFPACKAGE has a :SHADOW option, it will be executed after the first    DEFPACKAGE's :USE, violating the intent of DEFPACKAGE.Somebody's confused here.  If a second (or subsequent) call to DEFPACKAGEsupplies a :SHADOW option, that will in no way cause a violation orconflict with the pre-existing package.  Shadowing is always safe.  The ordering constraints of the proposal are there to insure that a single DEFPACKAGE call has only one interpretation as to whether it causes name conflicts or not;  as such, DEFPACKAGE really can use "the normal error handling of the package modification functions".   If you are worryingabout how to merge two different definitions, then that is a differentquestion [see below for more on "merging" definitions.]As to your basic question --- what it means "at most the existingpackage will be modified" -- I don't think there are very many optionssuch that one needs to wonder about it.  The only possible options areset by the pattern of other CL defining forms:   (1) create a new <frob>, abandoning the old <frob> and updating       the global name-to-<frob> mapping   [e.g., DEFUN, DEFPARAMETER]   (2) alter the existing <frob>, without changing the global        name-to-<frob> mapping  [e.g., IN-PACKAGE, and DEFMETHOD]   (3) "undefined"  [sigh, probably DEFTYPE]At one time, I had worked out a partial prescription for how to mergean existing package definition with the new redefinition.  However,many folks objected to this level of detail being in the portablestandard.  So that is why the current status of redefinition is moreor less "undefined";  but I don't think implementators will be at a lossto come up with variations on "merging" algorithms.  When the variationsbetween such mergings becomes a problem, then I suppose we can haveanother cleanup issue to settle it more concretely.  But right now itis undefined except in so far as it is licensed to "modify" the existing package.Possibly your concern is that you are implicitly worring about theconsequences of one particular merging algorithm, without specificallysaying which one you are thinking about?Re: "benign"Well, this cannot be left up to the imagination.  The naive meaning here must not imply that you are safe from catastrophic errors.  If what is meant is "maintain memory integrity" or "cause no hardware or operating system exceptions", then this would have to be spelled out clearly.-- JonL --*start*01516 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 10 DEC 88 04:06:40 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03476g; Sat, 10 Dec 88 04:04:30 PSTReceived: by bhopal id AA00288g; Sat, 10 Dec 88 04:06:27 PSTDate: Sat, 10 Dec 88 04:06:27 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812101206.AA00288@bhopal>To: masinter.paCc: barmar@Think.COM, CL-CLEANUP@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 9 Dec 88 17:42 PST <881209-174354-1798@Xerox>Subject: (Released?)Issue: DEFPACKAGE (Version 7)I don't think we should stir the pot on this one.  "Release" to X3J13ought to have a more permanent status than merely "Draft, for discussion"in the subcommittee.  Version 7 had been stable in subcommittee for nearlya month when you "released" it.  Subcommittee members had ample opportunityto comment upon it during that time.Members of the full committee will no doubt have commentary on all ofthe issues; I strongly suggest *not* flooding them with the volume ofdisucssion, re-hashing, etc that has been commonplace for the pastseveral months on the cl-cleanup list.  Only when there are "egregious"errors should there be need for emmendations of "released" issues.Especially I think we ought to wait on this question -- to see if manymore committee members are as confused as Barry has been about what the words "undefined" and "at variance" mean in the proposal.-- JonL --*start*01735 00024 US Return-Path: <barmar@Think.COM>Received: from Think.COM ([10.4.0.6]) by Xerox.COM ; 10 DEC 88 12:58:27 PSTReturn-Path: <barmar@Think.COM>Received: from kulla.think.com by Think.COM; Sat, 10 Dec 88 15:14:06 ESTReceived: by kulla.think.com; Sat, 10 Dec 88 15:57:29 ESTDate: Sat, 10 Dec 88 15:57:29 ESTFrom: barmar@Think.COMMessage-Id: <8812102057.AA18056@kulla.think.com>To: jonl@lucid.comCc: masinter.pa, CL-CLEANUP@sail.stanford.eduIn-Reply-To: Jon L White's message of Sat, 10 Dec 88 00:19:29 PST <8812100819.AA07741@bhopal>Subject: Issue: DEFPACKAGE (Version 7)    Possibly your concern is that you are implicitly worring about the    consequences of one particular merging algorithm, without specifically    saying which one you are thinking about?I'm not worried about any particular algorithm.  I just don't like theambiguous wording of the original spec.  How about this as analternative to "at most the original package will be updated":"however, no objects other than the original package will bemodified as a result."    Re: "benign"    Well, this cannot be left up to the imagination.  The naive meaning here     must not imply that you are safe from catastrophic errors.  If what is     meant is "maintain memory integrity" or "cause no hardware or operating     system exceptions", then this would have to be spelled out clearly.I'm not leaving anything up to the imagination.  Kathy's proposal forthe new classification system of error situations includes adescription of this case.  As I said, I don't remember the actualterminology she used for this case (I suggested "undefined butbenign", but she rejected it), but the description was like what youdescribed.*start*01829 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 DEC 88 01:43:41 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 14 Dec 88  01:43:09 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA07351g; Wed, 14 Dec 88 01:40:25 PSTReceived: by bhopal id AA12144g; Wed, 14 Dec 88 01:42:24 PSTDate: Wed, 14 Dec 88 01:42:24 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812140942.AA12144@bhopal>To: barmar@Think.COMCc: CL-CLEANUP@sail.stanford.eduIn-Reply-To: barmar@Think.COM's message of Sat, 10 Dec 88 15:57:29 EST <8812102057.AA18056@kulla.think.com>Subject: Issue: DEFPACKAGE (Version 7)re: . . .  How about this as an    alternative to "at most the original package will be updated":    "however, no objects other than the original package will be    modified as a result."Doesn't work -- by performing the newer definition, you may require linksto be modified in other packages' used-by lists.  If this really is an insoluable problem for you, and if other peoplealso feel so uncomfortable with it, then maybe we should just flushthe whole phrase; after all, the primary things we want to say are that:  (1) you don't change the name-to-package mapping, and  (2) you *might* alter the existing package [then again, you might not].re: . . . Kathy's proposal for    the new classification system of error situations includes a    description of this case.  As I said, I don't remember the actual    terminology she used for this case (I suggested "undefined but    benign", but she rejected it), but the description was like what you    described.Hmmm, well I'm not familiar with this yet newer error terminology proposal.-- JonL --*start*02439 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 JAN 89 23:48:58 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Jan 89  23:48:53 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 06 JAN 89 23:47:46 PSTDate: 6 Jan 89 23:47 PSTFrom: masinter.paSubject: Re: Issue: DEFPACKAGE (Version 7)In-reply-to: Jon L White <jonl@lucid.com>'s message of Wed, 14 Dec 88 01:42:24 PSTTo: Jon L White <jonl@lucid.com>cc: barmar@Think.COM, CL-CLEANUP@sail.stanford.eduMessage-ID: <890106-234746-2045@Xerox>After re-reading the discussion, I think the only issue is to defineexplicitly what "at variance with the current state of that package" means.I think a subjunctive definition might be OK, here's a try:Add to the Proposal: A DEFPACKAGE is "at variance with the current state of a pre-existingpackage" if the result of executing the DEFPACKAGE with a different namewould create a package with a different set of exported symbols, adifferent set of USEd packages, with any *more* shadowing symbols, or adifferent set of nicknames.A DEFPACKAGE is not at variance with the current state of a pre-existingpackage even if the size of the pre-existing package differs from the :SIZEof the DEFPACKAGE form, or if it the pre-existing package has more internalsymbols.If there is a new proposal (rather than an amendment), it might be usefulto add to the discussion:"One of the most common recipes for disaster is to have differing EXPORTsin two package definitions, and then to load a file which was compiled inone of these two enviroments into a "runtime" image that has the otherenvironment.  The file being loaded may expect to inherit some symbols(due to their being EXPORT'd from a "used" package at compile time); but failing to inherit at "run time", it will create a Doppelganger in the current packageVirtually any difference *can* be made to be critical, due to the factthat the package system is a global database in a flat namespace (thereis no "context" for FIND-PACKAGE).  Leaving it undefined as to how to handle varying package re-definitions allows the implementations toexperiment with helpful warnings, recovery stratagies, etc."How this will get into the standard in the Rationale section is not clear,but hopefully KC can find a way to cope with it.*start*02596 00024 US Return-Path: <peck@Sun.COM>Received: from Sun.COM ([10.7.0.2]) by Xerox.COM ; 11 JAN 89 18:19:36 PSTReceived: from snail.Sun.COM by Sun.COM (4.1/SMI-4.0)	id AA14739; Wed, 11 Jan 89 18:22:25 PSTReceived: from denali.sun.com by snail.Sun.COM (4.1/SMI-4.0)	id AA25540; Wed, 11 Jan 89 18:19:03 PSTReceived: from localhost by denali.sun.com (3.2/SMI-3.2)	id AA08867; Wed, 11 Jan 89 18:21:44 PSTMessage-Id: <8901120221.AA08867@denali.sun.com>To: masinter.paCc: Jon L White <jonl@lucid.com>Cc: barmar@Think.COM, CL-CLEANUP@sail.stanford.eduSubject: Re: Issue: DEFPACKAGE (Version 7) In-Reply-To: Your message of 06 Jan 89 23:47:00 -0800;	<890106-234746-2045@Xerox> .Date: Wed, 11 Jan 89 18:21:37 PSTFrom: peck@Sun.COM>After re-reading the discussion, I think the only issue is to define>explicitly what "at variance with the current state of that package" means.I'd like to make sure that it is possible to define mutuallydependent packages using DEFPACKAGE.What i envision is using TWO passes with DEFPACKAGE for each package.The first pass defines symbols that are interned (home-package) in that package, ie, using :SHADOW, :INTERN, :EXPORTand a second pass which enables access to symbols homed in other packages ie, using :SHADOWING-IMPORT-FROM, :USE, :IMPORT-FROM,     and possibly :EXPORT them to users of this packageYes, i have seen applications where this is used and useful.This disciplined used of two DEFPACKAGE forms on the same packageshould enable creating the desired package and symbol-inheritance structure.Doing this with two DEFPACKAGE forms should not produce any statewhich is "at variance" with the state of the package, no?For example of a small fragment:(DEFPACKAGE main	; pass 1, intern symbols homed in MAIN and UTIL	(:export 'main1))		; for :USE and :IMPORT-FROM(DEFPACKAGE util	(:export 'util1))		; create and export to USEr's of util(DEFPACKAGE util	; pass 2, now import or otherwise inherit symbols	(:import-from main 'main1)	; inherit main:main1					; for programmers in-package UTIL(DEFPACKAGE main	(:use 'util)	; programmers in MAIN will want access to all UTIL:syms	(:export 'util)); USEr's of MAIN will expect access to UTIL1.			; and may not even know of package UTIL!I strongly support the view that DEFPACKAGE should be constructedout of the existing primitives, and let the concept of "at variance"be determined by when those primitives detect incompatible package changes.[it is true that in this example the two forms for (DEFPACKAGE util...) could be coalesced into one.] *start*03339 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 11 JAN 89 19:26:57 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04418g; Wed, 11 Jan 89 19:22:25 PSTReceived: by bhopal id AA07308g; Wed, 11 Jan 89 19:24:39 PSTDate: Wed, 11 Jan 89 19:24:39 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901120324.AA07308@bhopal>To: masinter.paCc: barmar@Think.COM, CL-CLEANUP@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 6 Jan 89 23:47 PST <890106-234746-2045@Xerox>Subject: Issue: DEFPACKAGE (Version 7)re  A DEFPACKAGE is "at variance with the current state of a pre-existing    package" if the result of executing the DEFPACKAGE with a different name    would create a package with a different set of exported symbols, a    different set of USEd packages, with any *more* shadowing symbols, or a    different set of nicknames.    A DEFPACKAGE is not at variance with the current state of a pre-existing    package even if the size of the pre-existing package differs from the :SIZE    of the DEFPACKAGE form, or if it the pre-existing package has more internal    symbols.The second paragraph is fine.  The first is questionable.  I think theonly way to say it is that a DEFPACKAGE form is "at variance" with anexisting package (of the specified name) if any of the following holds:  (1) the set of used packages specified by the form is different from      that of the existing package;  (2) the set of nicknames specified by the form is different from      that of the existing package;  (3) the set of exported symbols specified ... ;  (4) the set of shadowing symbols specified ... ;  (5) the set of "foreign" symbols specified ... ; [I will use "foreign"      here to mean a symbol present in a package, but "homed" in some      other package; these are created via :IMPORT-FROM etc.][I hope this is clear enough, and we don't have to explain what it means for "the set of used packages" to be different!!!]Perhaps a better alternative is to give a standard canonical macro-expansion of DEFPACKAGE into calls on existing functions (such as EXPORT,FIND-SYMBOL, etc).  This is perfectly doable now, since the proposal fully specifies ordering constraints for the subparts that matter.Of course, an implementation wouldn't be required to use that canonicalexpansion, but the semantics would be required to be the same.  Theadvantage of this is that it allows for redefinitions using the alreadyexisting notions of name-conflicts etc, without having to specify thatevery possible significant change has "undefined" consequences.Tactical point:  we are nearing the wire for having presentableproposals.  Some of the feedback of the past two weeks seems reasonableto incorporate and some of it is "unclear" (to say the least).  Doyou really want to tinker with the wording of any issue already mailedout between now and net Tuesday?  I would think the safer thing to dowould be to collect a bunch of "amendments" and bring them to themeeting.  There are probably two dozen minor, non-controversialamendments, and maybe two or three majorly controversial ones.  ButI'm leary of us "digging a hole" similar to the one opened up at thevery last minute on DECLARE-TYPE-FREE.-- JonL --*start*03484 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 19:28:51 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 11 Jan 89  19:27:55 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04418g; Wed, 11 Jan 89 19:22:25 PSTReceived: by bhopal id AA07308g; Wed, 11 Jan 89 19:24:39 PSTDate: Wed, 11 Jan 89 19:24:39 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901120324.AA07308@bhopal>To: masinter.paCc: barmar@Think.COM, CL-CLEANUP@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 6 Jan 89 23:47 PST <890106-234746-2045@Xerox>Subject: Issue: DEFPACKAGE (Version 7)re  A DEFPACKAGE is "at variance with the current state of a pre-existing    package" if the result of executing the DEFPACKAGE with a different name    would create a package with a different set of exported symbols, a    different set of USEd packages, with any *more* shadowing symbols, or a    different set of nicknames.    A DEFPACKAGE is not at variance with the current state of a pre-existing    package even if the size of the pre-existing package differs from the :SIZE    of the DEFPACKAGE form, or if it the pre-existing package has more internal    symbols.The second paragraph is fine.  The first is questionable.  I think theonly way to say it is that a DEFPACKAGE form is "at variance" with anexisting package (of the specified name) if any of the following holds:  (1) the set of used packages specified by the form is different from      that of the existing package;  (2) the set of nicknames specified by the form is different from      that of the existing package;  (3) the set of exported symbols specified ... ;  (4) the set of shadowing symbols specified ... ;  (5) the set of "foreign" symbols specified ... ; [I will use "foreign"      here to mean a symbol present in a package, but "homed" in some      other package; these are created via :IMPORT-FROM etc.][I hope this is clear enough, and we don't have to explain what it means for "the set of used packages" to be different!!!]Perhaps a better alternative is to give a standard canonical macro-expansion of DEFPACKAGE into calls on existing functions (such as EXPORT,FIND-SYMBOL, etc).  This is perfectly doable now, since the proposal fully specifies ordering constraints for the subparts that matter.Of course, an implementation wouldn't be required to use that canonicalexpansion, but the semantics would be required to be the same.  Theadvantage of this is that it allows for redefinitions using the alreadyexisting notions of name-conflicts etc, without having to specify thatevery possible significant change has "undefined" consequences.Tactical point:  we are nearing the wire for having presentableproposals.  Some of the feedback of the past two weeks seems reasonableto incorporate and some of it is "unclear" (to say the least).  Doyou really want to tinker with the wording of any issue already mailedout between now and net Tuesday?  I would think the safer thing to dowould be to collect a bunch of "amendments" and bring them to themeeting.  There are probably two dozen minor, non-controversialamendments, and maybe two or three majorly controversial ones.  ButI'm leary of us "digging a hole" similar to the one opened up at thevery last minute on DECLARE-TYPE-FREE.-- JonL --*start*01813 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 12 JAN 89 04:17:40 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04802g; Thu, 12 Jan 89 04:14:35 PSTReceived: by bhopal id AA01212g; Thu, 12 Jan 89 04:16:52 PSTDate: Thu, 12 Jan 89 04:16:52 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901121216.AA01212@bhopal>To: peck@Sun.COMCc: masinter.pa, barmar@Think.COM, CL-CLEANUP@sail.stanford.eduIn-Reply-To: peck@Sun.COM's message of Wed, 11 Jan 89 18:21:37 PST <8901120221.AA08867@denali.sun.com>Subject: Issue: DEFPACKAGE (Version 7) Here's an excerpt from Version 7:  It is noted that DEFPACKAGE cannot be used to create two "mutually  recursive" packages, such as:   (defpackage my-package     (:use lisp your-package)           ;requires 'your-package' to exist first     (:export "MY-FUN"))   (defpackage your-package     (:use lisp)     (:import-from my-package "MY-FUN") ;requires 'my-package' to exist first     (:export "MY-FUN"))  However, nothing prevents one from using the package-effecting functions   such as USE-PACKAGE, IMPORT, and EXPORT to establish such links (which  ought to be very rare) after a more standard use of DEFPACKAGE.The problem is similar to "defining" a circular list; typically youhave to start out with a non-circular "definition" [e.g., such asby (CONS 'A NIL)] and then make a circularizing step [e.g., such as(RPLACD X X)].Your two-pass approach would *probably* work in many reasonable implementations, even though the two passes would be "at variance"by the definitions given previously.  The problem still seems tobe that we "ran out of time" before agreeing on how to reconciletwo defpackage calls that weren't basically the same.-- JonL --