*start*05988 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 23-May-89 12:34:06 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 23 MAY 89 12:34:08 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 23 May 89  12:31:28 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 599463; 23 May 89 15:03:18 EDTDate: Tue, 23 May 89 15:07 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FLOAT-UNDERFLOW (version 2)To: CL-Cleanup@sail.stanford.eduMessage-ID: <19890523190746.4.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This is a new issue.  It arose from an investigation of featuresthat are plausibly needed but missing from draft ANSI Common Lisp.This issue seems sufficiently simple and noncontroversial thatI would like to see it on the agenda for the June X3J13 meeting.Let's use the cleanup subcommittee to test the assertion that thisis a simple and noncontroversial issue.  If it's controversial,let's just drop it, otherwise let's give X3J13 a chance to votefor or against it.Issue:         FLOAT-UNDERFLOWReferences:    CLtL p.231Related issues:LEAST-POSITIVE-SINGLE-FLOAT-NORMALIZATION (not written up),               ERROR-CHECKING-IN-NUMBERS-CHAPTERCategory:      ADDITION and CLARIFICATIONEdit history:  Version 1, 9-May-89, by Moon (suggested in January, but                        the writeup was late)               Version 2, 23-May-89, by Moon (final cleanup for post-CLtL			changes to Common Lisp)Problem description:    In implementations with denormalized floating point numbers (as in IEEE  floating point), which are closer to zero than any non-zero normalized  floating point numbers, should the LEAST-POSITIVE- and  MOST-POSITIVE-XXX-FLOAT constants be the normalized or denormalized  values?  Which is preferred depends on the application.  Note that in  IEEE floating point, denormalized results are normally only produced  as a result of underflow.    Also, there is no portable way to control what happens when a floating  point number underflows.  Sometimes this is an error, sometimes not.  Indeed there is no mention at all of underflow or overflow in CLtL.  Pending issue ERROR-CHECKING-IN-NUMBERS-CHAPTER does not mention floating  point overflow or underflow.  Draft ANSI Common Lisp specifies error  conditions named FLOATING-POINT-OVERFLOW and FLOATING-POINT-UNDERFLOW  but does not specify the circumstances in which they are signalled and  does not provide any way to suppress underflow checking.Proposal (FLOAT-UNDERFLOW:ADD-CONTROLS):    Clarify that the existing LEAST-POSITIVE-XXX-FLOAT and  LEAST-NEGATIVE-XXX-FLOAT constants are literally as defined, and  therefore can be denormalized numbers in implementations that have  denormalized numbers.    Add the following constants, whose values are the normalized floating  point numbers closest in value to (but not equal to) zero.  In  implementations that don't have denormalized numbers, the values of  these constants are the same as the values of the other constants.      LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT [Constant]    LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT [Constant]    LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT [Constant]    LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT [Constant]    LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT [Constant]    LEAST-POSITIVE-NORMALIZED-LONG-FLOAT [Constant]    LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT [Constant]    LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT [Constant]    Add the WITHOUT-FLOATING-UNDERFLOW-TRAPS macro.  Within the dynamic  extent of its body, the result of a computation which would otherwise  underflow is a denormalized number or zero, whichever is closest to the  mathematical result.  Clarify that outside the dynamic extent of  WITHOUT-FLOATING-UNDERFLOW-TRAPS, a computation that underflows should  signal an error of type FLOATING-POINT-UNDERFLOW.  Clarify that a computation that underflows should signal an error of  type FLOATING-POINT-OVERFLOW.Example: (not portable of course)  (expt 0.1 40) => error    (describe (without-floating-underflow-traps (expt 0.1 40))) =>   1.0e-40 is a single-precision floating-point number.  Sign 0, exponent 0, 23-bit fraction 213302 (denormalized)Rationale:  The ANSI Common Lisp standard should be compatible with the  widely used IEEE Floating Point standard.  WITHOUT-FLOATING-UNDERFLOW-TRAPS is provided as a macro to allow  implementation flexibility.  It could expand into HANDLER-BIND for  FLOATING-POINT-UNDERFLOW, but in most implementations it will probably  expand into implementation-dependent code that sets a hardware mode bit.  Specifying "should signal" rather than "signals" or "might signal" for  floating-point overflows and underflows seems the best balance between  safety and implementation freedom.  It wouldn't harm the proposal to  change it to one of the other two phrases.Current practice:  The proposal exactly matches Symbolics Genera release 7.Cost to Implementors:  Adding the constants and the macro is easy.  Since it was never clarified  that floating point underflow is to be detected in safe code, implementors  who had not already implemented that might have to go to some expense.  In the laissez-faire spirit of floating point in Common Lisp, we could  relax the specification and say only that underflow might signal rather  than should signal.Cost to Users:  None.Cost of non-adoption:  Each Common Lisp implementation that uses IEEE Floating Point will have  to invent its own way to deal with underflow and denormalized numbers.Performance impact:  No effect on code optimized for speed.Benefits:  Increased portability and correctness of floating point code.Esthetics:  Neutral.Discussion:  None.*start*01693 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 24-May-89 10:12:05 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAY 89 09:30:02 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 24 May 89  08:16:48 PDTReceived: from bhopal ([192.43.178.13]) by heavens-gate id AA06744g; Wed, 24 May 89 08:15:43 PDTReceived: by bhopal id AA13086g; Wed, 24 May 89 08:15:24 PDTDate: Wed, 24 May 89 08:15:24 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8905241515.AA13086@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Tue, 23 May 89 15:07 EDT <19890523190746.4.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>Subject: Issue: FLOAT-UNDERFLOW (version 2)Lucid 3.0 and later has LEAST-{NEGATIVE,POSITIVE}-NORMALIZED-<mumble>-FLOAT,and in fact copied the names from Symbolics.  These, and the prescription that LEAST-{NEGATIVE,POSITIVE}-<mumble>-FLOAT be denormalized in implementatons which support it, seem very non-controversial to me.But WITHOUT-FLOATING-UNDERFLOW-TRAPS is too limited.  The topic needsmore thought, because much more than "underflow" should be considered.Lucid 3.0 and later has WITH-FLOATING-POINT-TRAPS, which takes twolists of condition names relevant to floating point operations andselectively enables or disables them (one list for "enablements", andone for "disablements").  And I wouldn't like to bet on our beingable to achieve consensus on this design over the next few weeks,even though I agree that it is an important topic.-- JonL --*start*02478 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 24-May-89 11:29:49 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 24 MAY 89 11:18:14 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 24 May 89  11:13:58 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 600010; 24 May 89 13:19:09 EDTDate: Wed, 24 May 89 13:23 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FLOAT-UNDERFLOW (version 2)To: Jon L White <jonl@lucid.com>cc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <8905241515.AA13086@bhopal>Message-ID: <19890524172312.2.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>    Date: Wed, 24 May 89 08:15:24 PDT    From: Jon L White <jonl@lucid.com>    Lucid 3.0 and later has LEAST-{NEGATIVE,POSITIVE}-NORMALIZED-<mumble>-FLOAT,    and in fact copied the names from Symbolics.  These, and the prescription     that LEAST-{NEGATIVE,POSITIVE}-<mumble>-FLOAT be denormalized in     implementatons which support it, seem very non-controversial to me.Thanks, I'll add that to the current practice section in the next version.    But WITHOUT-FLOATING-UNDERFLOW-TRAPS is too limited.  The topic needs    more thought, because much more than "underflow" should be considered.    Lucid 3.0 and later has WITH-FLOATING-POINT-TRAPS, which takes two    lists of condition names relevant to floating point operations and    selectively enables or disables them (one list for "enablements", and    one for "disablements").  And I wouldn't like to bet on our being    able to achieve consensus on this design over the next few weeks,    even though I agree that it is an important topic.The inability to converge on a design for such an elaborate feature isprecisely the reason for proposing the very simple feature.  Also notethat underflow is the _only_ exception that some applications have avery strong need to enable while at the same time other applicationshave a very strong need to disable.  Thus just the simple feature getsus most of the way towards perfection.  By the way if you want to writeup a proposal for the Lucid WITH-FLOATING-POINT-TRAPS so we can discussit, that would be fine with me.  But I will be very disappointed if theend result is that we can't agree on it and do nothing at all.*start*02722 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 25-May-89 13:48:30 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 MAY 89 13:44:46 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 25 May 89  13:43:27 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 601047; 25 May 89 16:45:15 EDTDate: Thu, 25 May 89 16:49 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: FLOAT-UNDERFLOW (version 2)To: Jon L White <jonl@lucid.com>cc: CL-Cleanup@sail.stanford.eduIn-Reply-To: <8905251957.AA16095@bhopal>Message-ID: <19890525204907.5.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>    Date: Thu, 25 May 89 12:57:13 PDT    From: Jon L White <jonl@lucid.com>    ....    What makes me a bit leary of this proposal, at this stage of the game,    is that I thought we had agreed to close down Cleanup for new proposals,    in order to concentrate our efforts of finishing the large amount of    work already started but not completed.Agreed.  Let me explain my purpose in bringing up now these new issueslike FLOAT-UNDERFLOW (the pathnames ones are not new, although one ofthem had not been written up before).  I want to get a decision on whetherthese things are going to be in or out of ANSI Common Lisp.  If they areout, I am not going to have a tantrum, it just means my efforts should beredirected towards a de facto standard rather than a de jure standard.Of course if ANSI Common Lisp doesn't address these issues, that will makeit a worse language than it would be otherwise, but we already know thatANSI Common Lisp is not going to be a perfect language, and we assume weall had accepted that in our hearts quite a long time ago or we wouldn'tstill be working on it.The CL-Cleanup committee could make a decision never to show these issuesto X3J13 and I wouldn't have a tantrum over that either.  You're sayingthat FLOAT-UNDERFLOW is best not brought up at this time, and I think thatis a reasonable position to take (although I don't know whether I myselfagree with it, since I haven't read your sketch of a proposal yet).There are a number of other issues that I decided on my own not to bringup with CL-Cleanup at all, since they are clearly inappropriate topropose at this late date for the current de jure standard, even thoughthey are clearly issues that a language with the goals of ANSI CommonLisp ought to address.  I'd rather not distract you by listing thoseissues right now.Comments on the specifics of your proposal later.*start*01133 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 13-Jun-89 15:19:17 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JUN 89 15:19:21 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 13 Jun 89  15:18:08 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 610807; 13 Jun 89 18:19:59 EDTDate: Tue, 13 Jun 89 18:19 EDTFrom: Kim Barrett <IIM@ECLA.USC.EDU>Sender: KMP@STONY-BROOK.SCRC.Symbolics.COMSubject: Issue: FLOAT-UNDERFLOW (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUComments: Received from Kim Barrett by KMP on MSDOS floppy disk via US MailMessage-ID: <19890613221949.4.KMP@BOBOLINK.SCRC.Symbolics.COM>Mostly ok.Fix C-Y bug.  FLOATING-POINT-OVERFLOW signaled when a computation overflows,not underflows.I think changing "should signal" to "signals" is likely to generate too muchheat for what I see as an otherwise pretty uncontroversial proposal.  Even"should signal" may be too strong.*start*07525 00024 US GV-Info: X3J13-mailer@SAIL.Stanford.EDU at 19-Jun-89 09:05:41 from AGReturn-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 JUN 89 09:05:30 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 19 Jun 89  08:51:26 PDTReceived: from KENNETH-WILLIAMS.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 612931; 19 Jun 89 11:53:09 EDTDate: Mon, 19 Jun 89 11:51 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Reply-To: CL-Cleanup@sail.stanford.eduSubject: Issue: FLOAT-UNDERFLOW (version 3)To: X3J13@sail.stanford.eduMessage-ID: <19890619155127.2.MOON@KENNETH-WILLIAMS.SCRC.Symbolics.COM>This is a new issue.  It arose from an investigation of featuresthat are plausibly needed but missing from draft ANSI Common Lisp.This issue seems sufficiently simple and noncontroversial thatI would like to see it on the agenda for the June X3J13 meeting.Issue:         FLOAT-UNDERFLOWReferences:    CLtL p.231Related issues:LEAST-POSITIVE-SINGLE-FLOAT-NORMALIZATION (not written up),               ERROR-CHECKING-IN-NUMBERS-CHAPTERCategory:      ADDITION and CLARIFICATIONEdit history:  Version 1, 9-May-89, by Moon (suggested in January, but                        the writeup was late)               Version 2, 23-May-89, by Moon (final cleanup for post-CLtL                        changes to Common Lisp)               Version 3, 18-Jun-89, by Moon (update based on discussion                        within the cleanup subcommittee)Problem description:    In implementations with denormalized floating point numbers (as in IEEE  floating point), which are closer to zero than any non-zero normalized  floating point numbers, should the LEAST-POSITIVE- and  MOST-POSITIVE-XXX-FLOAT constants be the normalized or denormalized  values?  Which is preferred depends on the application.  Note that in  IEEE floating point, denormalized results are normally only produced  as a result of underflow.    Also, there is no portable way to control what happens when a floating  point number underflows.  Sometimes this is an error, sometimes not.  Indeed there is no mention at all of underflow or overflow in CLtL.  Pending issue ERROR-CHECKING-IN-NUMBERS-CHAPTER does not mention floating  point overflow or underflow.  Draft ANSI Common Lisp specifies error  conditions named FLOATING-POINT-OVERFLOW and FLOATING-POINT-UNDERFLOW  but does not specify the circumstances in which they are signalled and  does not provide any way to suppress underflow checking.Proposal (FLOAT-UNDERFLOW:ADD-CONTROLS):    1. Clarify that the existing LEAST-POSITIVE-XXX-FLOAT and  LEAST-NEGATIVE-XXX-FLOAT constants are literally as defined, and  therefore can be denormalized numbers in implementations that have  denormalized numbers.    2. Add the following constants, whose values are the normalized floating  point numbers closest in value to (but not equal to) zero.  In  implementations that don't have denormalized numbers, the values of these  constants are the same as the values of the other constants.      LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT [Constant]    LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT [Constant]    LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT [Constant]    LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT [Constant]    LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT [Constant]    LEAST-POSITIVE-NORMALIZED-LONG-FLOAT [Constant]    LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT [Constant]    LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT [Constant]    3. Add the following macro:  WITHOUT-FLOATING-UNDERFLOW-TRAPS &body body                   [Macro]    Within the dynamic extent of the body, the result of a floating point    computation which would otherwise underflow is a denormalized number    (if they are supported in the implementation) or zero, whichever is    closest to the mathematical result.    The values of WITHOUT-FLOATING-UNDERFLOW-TRAPS are the values of the    last body form, or NIL if there are no body forms.  4. Clarify that outside the dynamic extent of  WITHOUT-FLOATING-UNDERFLOW-TRAPS, a floating point computation that  underflows should signal an error of type FLOATING-POINT-UNDERFLOW.  A  result that can only be represented in denormalized form is considered an  underflow in implementations that support denormalized floating point  numbers.  5. Clarify that a floating point computation that overflows should signal  an error of type FLOATING-POINT-OVERFLOW.Example: (not portable of course)  (expt 0.1 40) => FLOATING-POINT-UNDERFLOW error    (describe (without-floating-underflow-traps (expt 0.1 40))) =>   1.0e-40 is a single-precision floating-point number.  Sign 0, exponent 0, 23-bit fraction 213302 (denormalized)Rationale:  The ANSI Common Lisp standard should be compatible with the widely used  IEEE Floating Point standard.  WITHOUT-FLOATING-UNDERFLOW-TRAPS is provided as a macro to allow  implementation flexibility.  It could expand into HANDLER-BIND for  FLOATING-POINT-UNDERFLOW, but in most implementations it will probably  expand into implementation-dependent code that sets a hardware mode bit.  Specifying "should signal" rather than "signals" or "might signal" for  floating-point overflows and underflows seems the best balance between  safety and implementation freedom.  It wouldn't harm the proposal to  change it to one of the other two phrases.Current practice:  The proposal exactly matches Symbolics Genera release 7 except for  the names of the conditions.  Lucid Common Lisp 3.0 implements parts 1, 2, 4, and 5 of the proposal.  Instead of point 3 of the proposal, Lucid Common Lisp 3.0 has a macro  (WITH-FLOATING-POINT-TRAPS enable-condition-list disable-condition-list  &body body) that enables and disables a variety of floating-point-related  conditions, a function ENABLED-FLOATING-POINT-TRAPS that returns a list  of condition names, a constant SUPPORTED-FLOATING-POINT-CONDITIONS whose  value is a list of condition names, and several additional condition  names (the exact set of condition names varies, depending on the  hardware).Cost to Implementors:  Adding the constants and the macro is easy.  Since it was never clarified  that floating point underflow is to be detected in safe code, implementors  who had not already implemented that might have to go to some expense.  In the laissez-faire spirit of floating point in Common Lisp, we could  relax the specification and say only that underflow might signal rather  than should signal.Cost to Users:  None.Cost of non-adoption:  Each Common Lisp implementation that uses IEEE Floating Point will have  to invent its own way to deal with underflow and denormalized numbers.Performance impact:  No effect on code optimized for speed rather than safety.Benefits:  Increased portability and correctness of floating point code.Esthetics:  Neutral.Discussion:  Maybe point 3 of the proposal should be replaced by the more complex  feature from Lucid.  This would allow re-enabling underflow checking  after it had been disabled, and would allow control over other traps such  as overflow and inexact result.  Moon would prefer to keep it simple,  but if others support the more general mechanism, he can accept it.  If the group cannot agree on this, Moon suggests dropping point 3 from  the proposal and passing points 1, 2, 4, and 5.