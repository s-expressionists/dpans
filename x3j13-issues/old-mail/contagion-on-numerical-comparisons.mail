*start*04446 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([10.0.0.11]) by Xerox.COM ; 14 SEP 88 14:21:02 PDTReceived: from ALLEGHENY.SCRC.Symbolics.COM ([128.81.41.45]) by SAIL.Stanford.EDU with TCP; 14 Sep 88  13:29:27 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by ALLEGHENY.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 106665; Wed 14-Sep-88 16:28:05 EDTDate: Wed, 14 Sep 88 16:27 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: CONTAGION-ON-NUMERICAL-COMPARISONSTo: CL-Cleanup@sail.stanford.eduReferences: <8807200836.AA02976@bhopal.lucid.com>,            <19880719152249.9.MOON@EUPHRATES.SCRC.Symbolics.COM>,            <19880719213809.1.GREENWALD@SWALLOW.SCRC.Symbolics.COM>,            <870402170955.6.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19880914202753.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Issue:         CONTAGION-ON-NUMERICAL-COMPARISONSReferences:    CLtL p.194Category:      CHANGEEdit history:  Version 1, 14-Sep-88, MoonProblem description:The numerical contagion rules specified on CLtL p.194 make it impossiblefor the numerical comparison functions to be transitive when givenarguments of mixed floating and rational types (see example below).Proposal (CONTAGION-ON-NUMERICAL-COMPARISONS:TRANSITIVE):	  Instead of using the same contagion rule both for combining functionsand for comparing functions, make the present rule apply only tocombining functions and add the following rule:  When rational andfloating-point numbers are compared by a numerical function, thefunction RATIONAL is called to convert the floating-point number to arational and then an exact comparison is performed.  In the case ofcomplex numbers (RATIONAL is for some unknown reason only allowed onreals), the real and imaginary parts are handled individually.It is of course valid to use a more efficient implementation thanactually calling RATIONAL, as long as the result of the comparison isthe same.Test Cases/Examples:(defvar a (/ 10.0 single-float-epsilon))(= a (1+ (floor a)))should be NIL, since (= a (floor a))is certainly T and(= (floor a) (1+ (floor a)))is certainly NIL.  However, by the rule of floating-point contagion,(= a (1+ (floor a)))is the same as (= a (float (1+ (floor a)) a))and the latter form is certainly T.To understand this example better, it helps to realize that(= a (+ a 1.0))is always true, by the definition of single-float-epsilon.Here is a second example:(defvar i (floor a))(<= a (+ i 1)) is T.(< (+ i 1) (+ i 2)) is T.(<= (+ i 2) a) is T by CLtL, NIL by this proposal.Thus CLtL requires  a <= i+1 < i+2 <= awhich ought to imply  a < awhich is absurd.Rationale:Transitivity of = and of < are important to many algorithms.  What CLtLsays now was probably not intentional, but just the result of thinkingthat comparing and combining could be lumped together without reallythinking about it.Without this change, it is impossible to extend the :TEST argument toMAKE-HASH-TABLE to allow = or EQUALP, since there could be two tableentries with rational keys that are not =, then GETHASH could bepresented with a floating-point argument that is = to both keys.Current practice:Lucid is said to implement the proposal.  As far as I know all otherimplementations do what CLtL currently says.Cost to Implementors:This requires a change in what is likely to be intricate andimplementation-dependent code.  However, the total effort shouldbe small compared to the cost of writing that code originally.Cost to Users:This is an incompatible change.  It's difficult to know if any usersare depending on the current behavior.  It seems likely that most userswould expect the proposed behavior, and may be wondering why theirprograms don't quite work when the numbers get large.Cost of non-adoption:Comparison functions in Common Lisp will be non-transitive.Benefits:Comparison functions in Common Lisp will be transitive.Esthetics:Having two rules of floating-point contagion may seem less esthetic,but I'm certain that having the comparison functions behave in a moremathematically correct fashion outweighs that esthetically.Discussion:Everyone who has expressed an opinion has thought this was the rightthing for years, but we never got around to writing it up as a cleanupproposal.*start*01857 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 SEP 88 10:47:40 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 20 Sep 88  10:46:59 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA04482g; Tue, 20 Sep 88 09:45:17 PSTReceived: by bhopal id AA18564g; Tue, 20 Sep 88 10:44:45 PDTDate: Tue, 20 Sep 88 10:44:45 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809201744.AA18564@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: CL-Cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 14 Sep 88 16:27 EDT <19880914202753.3.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: CONTAGION-ON-NUMERICAL-COMPARISONSThis proposal accurately reflects the state of Lucid Common Lisp, Release 3.0; previous releases implemented CLtL.Incidentally, I know we thrashed this issue out on Common-Lisp@SU-AI some months ago; and I remember initiating the discussion with a querymsg to find out how other people felt about the issue.  However your "References" field shows only the very cryptic:	    <8807200836.AA02976@bhopal.lucid.com>,            <19880719152249.9.MOON@EUPHRATES.SCRC.Symbolics.COM>,            <19880719213809.1.GREENWALD@SWALLOW.SCRC.Symbolics.COM>,            <870402170955.6.MOON@EUPHRATES.SCRC.Symbolics.COM>I've noticed that this kind of encryption always occurs whe Symbolicsfolks try to reference prior mail; it must be some kind of "feature"in the Symbolics mailer?Could you possibly restore something more like the original dateline;on these references, with at least (1) which mailing list to whichthe msg was sent, (2) the "From" name, and (3) a readily understandabledate format [e.g. Wed, 14 Sep 88 16:27 EDT].  Thanks.-- JonL --*start*00747 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 SEP 88 03:19:23 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Sep 88  03:19:10 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 21 SEP 88 03:17:49 PDTDate: 21 Sep 88 03:17 PDTFrom: masinter.paSubject: Re: Issue: CONTAGION-ON-NUMERICAL-COMPARISONSIn-reply-to: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>'s message of Wed, 14 Sep 88 16:27 EDTTo: CL-Cleanup@sail.stanford.eduMessage-ID: <880921-031749-5707@Xerox>I think Version 1 is Ready for Release; that is, none of the minor edits I wastempted to make to it would improve it.*start*03785 00024 USfDate:  6 Oct 88 19:18 PDTFrom: masinter.pato: X3J13@sail.stanford.educc: masinterSubject: Issue:         CONTAGION-ON-NUMERICAL-COMPARISONS (version 1)reply-to: cl-cleanup@sail.stanford.eduline-fold: NOIssue:         CONTAGION-ON-NUMERICAL-COMPARISONSReferences:    CLtL p.194Category:      CHANGEEdit history:  Version 1, 14-Sep-88, MoonProblem description:The numerical contagion rules specified on CLtL p.194 make it impossiblefor the numerical comparison functions to be transitive when givenarguments of mixed floating and rational types (see example below).Proposal (CONTAGION-ON-NUMERICAL-COMPARISONS:TRANSITIVE):	  Instead of using the same contagion rule both for combining functionsand for comparing functions, make the present rule apply only tocombining functions and add the following rule:  When rational andfloating-point numbers are compared by a numerical function, thefunction RATIONAL is called to convert the floating-point number to arational and then an exact comparison is performed.  In the case ofcomplex numbers (RATIONAL is for some unknown reason only allowed onreals), the real and imaginary parts are handled individually.It is of course valid to use a more efficient implementation thanactually calling RATIONAL, as long as the result of the comparison isthe same.Test Cases/Examples:(defvar a (/ 10.0 single-float-epsilon))(= a (1+ (floor a)))should be NIL, since (= a (floor a))is certainly T and(= (floor a) (1+ (floor a)))is certainly NIL.  However, by the rule of floating-point contagion,(= a (1+ (floor a)))is the same as (= a (float (1+ (floor a)) a))and the latter form is certainly T.To understand this example better, it helps to realize that(= a (+ a 1.0))is always true, by the definition of single-float-epsilon.Here is a second example:(defvar i (floor a))(<= a (+ i 1)) is T.(< (+ i 1) (+ i 2)) is T.(<= (+ i 2) a) is T by CLtL, NIL by this proposal.Thus CLtL requires  a <= i+1 < i+2 <= awhich ought to imply  a < awhich is absurd.Rationale:Transitivity of = and of < are important to many algorithms.  What CLtLsays now was probably not intentional, but just the result of thinkingthat comparing and combining could be lumped together without reallythinking about it.Without this change, it is impossible to extend the :TEST argument toMAKE-HASH-TABLE to allow = or EQUALP, since there could be two tableentries with rational keys that are not =, then GETHASH could bepresented with a floating-point argument that is = to both keys.Current practice:Lucid is said to implement the proposal.  As far as I know all otherimplementations do what CLtL currently says.Cost to Implementors:This requires a change in what is likely to be intricate andimplementation-dependent code.  However, the total effort shouldbe small compared to the cost of writing that code originally.Cost to Users:This is an incompatible change.  It's difficult to know if any usersare depending on the current behavior.  It seems likely that most userswould expect the proposed behavior, and may be wondering why theirprograms don't quite work when the numbers get large.Cost of non-adoption:Comparison functions in Common Lisp will be non-transitive.Benefits:Comparison functions in Common Lisp will be transitive.Esthetics:Having two rules of floating-point contagion may seem less esthetic,but I'm certain that having the comparison functions behave in a moremathematically correct fashion outweighs that esthetically.Discussion:Everyone who has expressed an opinion has thought this was the rightthing for years, but we never got around to writing it up as a cleanupproposal.     ----- End Forwarded Messages -----*start*04109 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 20:02:38 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 6 Oct 88  19:21:12 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 06 OCT 88 19:18:51 PDTDate: 6 Oct 88 19:18 PDTFrom: masinter.pato: X3J13@sail.stanford.educc: masinter.paSubject: Issue:         CONTAGION-ON-NUMERICAL-COMPARISONS (version 1)reply-to: cl-cleanup@sail.stanford.eduline-fold: NOMessage-ID: <881006-191851-1973@Xerox>!Issue:         CONTAGION-ON-NUMERICAL-COMPARISONSReferences:    CLtL p.194Category:      CHANGEEdit history:  Version 1, 14-Sep-88, MoonProblem description:The numerical contagion rules specified on CLtL p.194 make it impossiblefor the numerical comparison functions to be transitive when givenarguments of mixed floating and rational types (see example below).Proposal (CONTAGION-ON-NUMERICAL-COMPARISONS:TRANSITIVE):	  Instead of using the same contagion rule both for combining functionsand for comparing functions, make the present rule apply only tocombining functions and add the following rule:  When rational andfloating-point numbers are compared by a numerical function, thefunction RATIONAL is called to convert the floating-point number to arational and then an exact comparison is performed.  In the case ofcomplex numbers (RATIONAL is for some unknown reason only allowed onreals), the real and imaginary parts are handled individually.It is of course valid to use a more efficient implementation thanactually calling RATIONAL, as long as the result of the comparison isthe same.Test Cases/Examples:(defvar a (/ 10.0 single-float-epsilon))(= a (1+ (floor a)))should be NIL, since (= a (floor a))is certainly T and(= (floor a) (1+ (floor a)))is certainly NIL.  However, by the rule of floating-point contagion,(= a (1+ (floor a)))is the same as (= a (float (1+ (floor a)) a))and the latter form is certainly T.To understand this example better, it helps to realize that(= a (+ a 1.0))is always true, by the definition of single-float-epsilon.Here is a second example:(defvar i (floor a))(<= a (+ i 1)) is T.(< (+ i 1) (+ i 2)) is T.(<= (+ i 2) a) is T by CLtL, NIL by this proposal.Thus CLtL requires  a <= i+1 < i+2 <= awhich ought to imply  a < awhich is absurd.Rationale:Transitivity of = and of < are important to many algorithms.  What CLtLsays now was probably not intentional, but just the result of thinkingthat comparing and combining could be lumped together without reallythinking about it.Without this change, it is impossible to extend the :TEST argument toMAKE-HASH-TABLE to allow = or EQUALP, since there could be two tableentries with rational keys that are not =, then GETHASH could bepresented with a floating-point argument that is = to both keys.Current practice:Lucid is said to implement the proposal.  As far as I know all otherimplementations do what CLtL currently says.Cost to Implementors:This requires a change in what is likely to be intricate andimplementation-dependent code.  However, the total effort shouldbe small compared to the cost of writing that code originally.Cost to Users:This is an incompatible change.  It's difficult to know if any usersare depending on the current behavior.  It seems likely that most userswould expect the proposed behavior, and may be wondering why theirprograms don't quite work when the numbers get large.Cost of non-adoption:Comparison functions in Common Lisp will be non-transitive.Benefits:Comparison functions in Common Lisp will be transitive.Esthetics:Having two rules of floating-point contagion may seem less esthetic,but I'm certain that having the comparison functions behave in a moremathematically correct fashion outweighs that esthetically.Discussion:Everyone who has expressed an opinion has thought this was the rightthing for years, but we never got around to writing it up as a cleanupproposal.     ----- End Forwarded Messages -----*start*00875 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 12:55:43 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  12:55:48 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475745; Thu 13-Oct-88 15:54:20 EDTDate: Thu, 13 Oct 88 15:54 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: CONTAGION-ON-NUMERICAL-COMPARISONS (Version 1)To: CL-Cleanup@SAIL.Stanford.EDUMessage-ID: <881013155412.9.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...X3J13 meeting: There was discussion of voting on this, but van Roggen wanted time to review the issue carefully before voting.*start*04148 00024 US Date:  5 Dec 88 14:58 PSTFrom: masinter.pato: masinterSubject: Issue:         CONTAGION-ON-NUMERICAL-COMPARISONS (version 1)reply-to: cl-cleanup@sail.stanford.eduline-fold: NOForum:         CleanupIssue:         CONTAGION-ON-NUMERICAL-COMPARISONSReferences:    CLtL p.194Category:      CHANGEEdit history:  Version 1, 14-Sep-88, MoonProblem description:The numerical contagion rules specified on CLtL p.194 make it impossiblefor the numerical comparison functions to be transitive when givenarguments of mixed floating and rational types (see example below).Proposal (CONTAGION-ON-NUMERICAL-COMPARISONS:TRANSITIVE):	  Instead of using the same contagion rule both for combining functionsand for comparing functions, make the present rule apply only tocombining functions and add the following rule:  When rational andfloating-point numbers are compared by a numerical function, thefunction RATIONAL is called to convert the floating-point number to arational and then an exact comparison is performed.  In the case ofcomplex numbers (RATIONAL is for some unknown reason only allowed onreals), the real and imaginary parts are handled individually.It is of course valid to use a more efficient implementation thanactually calling RATIONAL, as long as the result of the comparison isthe same.Test Cases/Examples:(defvar a (/ 10.0 single-float-epsilon))(= a (1+ (floor a)))should be NIL, since (= a (floor a))is certainly T and(= (floor a) (1+ (floor a)))is certainly NIL.  However, by the rule of floating-point contagion,(= a (1+ (floor a)))is the same as (= a (float (1+ (floor a)) a))and the latter form is certainly T.To understand this example better, it helps to realize that(= a (+ a 1.0))is always true, by the definition of single-float-epsilon.Here is a second example:(defvar i (floor a))(<= a (+ i 1)) is T.(< (+ i 1) (+ i 2)) is T.(<= (+ i 2) a) is T by CLtL, NIL by this proposal.Thus CLtL requires  a <= i+1 < i+2 <= awhich ought to imply  a < awhich is absurd.Rationale:Transitivity of = and of < are important to many algorithms.  What CLtLsays now was probably not intentional, but just the result of thinkingthat comparing and combining could be lumped together without reallythinking about it.Without this change, it is impossible to extend the :TEST argument toMAKE-HASH-TABLE to allow = or EQUALP, since there could be two tableentries with rational keys that are not =, then GETHASH could bepresented with a floating-point argument that is = to both keys.Current practice:Lucid is said to implement the proposal.  As far as I know all otherimplementations do what CLtL currently says.Cost to Implementors:This requires a change in what is likely to be intricate andimplementation-dependent code.  However, the total effort shouldbe small compared to the cost of writing that code originally.Cost to Users:This is an incompatible change.  It's difficult to know if any usersare depending on the current behavior.  It seems likely that most userswould expect the proposed behavior, and may be wondering why theirprograms don't quite work when the numbers get large.Cost of non-adoption:Comparison functions in Common Lisp will be non-transitive.Benefits:Comparison functions in Common Lisp will be transitive.Esthetics:Having two rules of floating-point contagion may seem less esthetic,but I'm certain that having the comparison functions behave in a moremathematically correct fashion outweighs that esthetically.Discussion:Everyone who has expressed an opinion has thought this was the rightthing for years, but we never got around to writing it up as a cleanupproposal.        TITAN 
         TITAN 
         ; -(TEXTFONT 7 (TIMESROMAN 12) NIL (CLASSIC 10))            ¹                            $                                                        Ò       :      ±             ·             ÷              t              ¿                           >       
       :              É              ˜      ‚ !zº