*start*02918 00024 USfReturn-Path: <spar!schoen@decwrl.dec.com>Received: from decwrl.dec.com by Xerox.COM ; 08 JUL 87 14:18:08 PDTReceived: by decwrl.dec.com (5.54.3/4.7.34)	id AA25408; Wed, 8 Jul 87 14:17:34 PDTReceived: By spar.SPAR.CAS.SLB.COM (from gyro.SPAR.CAS.SLB.COM)	id AA00706; Wed, 8 Jul 87 10:59:57 PDTReturn-Path: <schoen@gyro>Received: By gyro.SPAR.CAS.SLB.COM	id AA09848; Wed, 8 Jul 87 10:59:31 PDTDate: Wed, 8 Jul 87 10:59:31 PDTFrom: Eric Schoen <spar!schoen@decwrl.dec.com>Message-Id: <8707081759.AA09848@gyro.SPAR.CAS.SLB.COM>To: masinter.paSubject: Common Lisp cleanupLarry:I think I have a submission for the cleanup committee, but I've lost yoursubmission format.  I'll try to provide the information you want.Let's call this issue LET:SPECIAL-SCOPE or somesuch.  Here's the crux of theproblem.  Consider a LET expression like:	(let ((a <foo>))          (declare (special a))          (bar))I've macroexpanded this example under Franz, Lucid, TI, and Symbolics CommonLisps.  The first three macroexpand to:	((lambda nil	   (declare (special a)) 	   ((lambda (a)              (declare (special a))              (bar))            <foo>)))The last expands to:	((lambda nil 	   ((lambda (a)              (declare (special a))              (bar))            <foo>)))These are exactly equivalent unless <foo> happens to be the variable a.  UnderTI, Lucid, and Franz's implementations, the interior a gets bound to thedynamic binding of a as of the time the entire expression is entered.  UnderSymbolics, the interior a gets bound to the lexical value of a when theexpression is entered (assuming there is a lexically apparent binding of a).So which is the proper treatment of the special declaration?  I tend tobelieve Symbolics is doing it correctly, but then why do so many otherimplementations do it differently?This came up when I was trying something like the following:(setq c (let ((a 1))          #'(lambda (function &rest args)              (let ((a a))                (declare (special a))                (apply function args)))))(funcall c 'eval 'a)When you do the funcall with a unbound globally, the TI, Franz, and Lucidimplementations signal an error because a is unbound, whereas the Symbolicsimplementation returns 1.  The idea in this example is to return a closurewhich captures the lexical value of a variable and makes it availabledynamically when the closure is applied.  I tried simpler approaches likelocally declaring a special within the closure, but these failed on allimplementations.I imagine the cost of fixing all implementations to behave like the Symbolicsimplementation would be very low, since it's only a matter of changing themacro definition of let.  The impact ought to be minor, since this is a veryunusual situation.  I also think it deserves a clarification in the silverbook.Eric*start*02556 00024 USfOriginator: @SAIL.STANFORD.EDU:Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxDate: 18 Aug 87 14:14From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: FLET & declarationsIn-Reply-to: <12327146435.14.GZ@OZ.AI.MIT.EDU>To: GZ%OZ.AI.MIT.EDU%XX.LCS.MIT:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: FLET & declarationsTo: GZ%OZ.AI.MIT.EDU@XX.LCS.MIT.EDUcc: common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <12327146435.14.GZ@OZ.AI.MIT.EDU>Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 18 AUG 87 14:14:29 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 18 Aug 87  13:28:28 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 215806; Tue 18-Aug-87 16:28:17 EDTOriginal-Date: Tue, 18 Aug 87 16:27 EDTMessage-ID: <870818162759.2.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon 17 Aug 87 03:57:47-EDT    From: GZ%OZ.AI.MIT.EDU@XX.LCS.MIT.EDU    Are 'pervasive' declarations in FLET supposed to apply to the function bodies?    E.g.      (flet ((foo () x)) ;Is this x special?	(declare (special x))	...)      (flet ((foo () (foo) ...))  ;Does this call to (foo) return a fixnum?	(declare (function foo () fixnum))	...)      (flet ((foo () (foo 17))) ;Is (foo 17) inline?	(declare (inline foo))	...)CLtL does not permit DECLARE to be used in that position (see p.113).I believe it has been proposed to change that, although I couldn'tfind a copy of the proposal in my rather disorganized files.  I wouldargue that the paragraph in the middle of page 155 of CLtL supportsthe position that when this extension is made, the pervasive declarationsshould apply to the function bodies.Note that the FUNCTION declaration used in your middle example is notpervasive.  Since you use FLET rather than LABELS, this declarationwould not apply to the call to FOO within the body of FOO.  It's adifferent FOO.The INLINE declaration is said by CLtL to be pervasive, however Ibelieve that to be a bug since it makes it unclear which of the twoFOOs in your example it refers to.  Perhaps it refers to both.Anyone putting together a proposal to clean up the specification ofdeclarations in Common Lisp ought to address the issues raised byyour question.*start*00956 00024 US Originator: @SAIL.STANFORD.EDU:GZ%OZ.AI.MIT.EDU%MC.LCS.MIT:EDU:XeroxDate: 17 Aug 87 01:20From: GZ%OZ.AI.MIT.EDU%XX.LCS.MIT:EDU:XeroxSubject: FLET & declarationsTo: common-lisp%SAIL.STANFORD:EDU:XeroxReturn-Path: <@SAIL.STANFORD.EDU:GZ%OZ.AI.MIT.EDU@MC.LCS.MIT.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 17 AUG 87 01:19:59 PDTReceived: from MC.LCS.MIT.EDU by SAIL.STANFORD.EDU with TCP; 17 Aug 87  00:54:33 PDTOriginal-Date: Mon, 17 Aug 87 03:57:47 EDTMessage-ID: <12327146435.14.GZ@OZ.AI.MIT.EDU>Are 'pervasive' declarations in FLET supposed to apply to the function bodies?E.g.  (flet ((foo () x)) ;Is this x special?    (declare (special x))    ...)  (flet ((foo () (foo) ...))  ;Does this call to (foo) return a fixnum?    (declare (function foo () fixnum))    ...)  (flet ((foo () (foo 17))) ;Is (foo 17) inline?    (declare (inline foo))    ...)-------*start*36677 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 19 NOV 87 18:14:06 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 19 Nov 87  18:06:56 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 19 NOV 87 17:59:49 PSTDate: 19 Nov 87 17:59 PSTFrom: Masinter.paSubject: Issue: DECLARATION-SCOPETo: Pavel.pa, SMH%Franz.uucp@berkeley.educc: cl-cleanup@Sail.stanford.eduMessage-ID: <871119-175949-1009@Xerox>My notes from Denver are a little fuzzy on this issue; I think what theymean is that you might be convinced to write up a proposal on theseissues...I've started using our  common-lisp mailing list index again, andretrieved some of the previous mail on this subject.       ----- Begin Forwarded Messages -----Return-Path: <spar!schoen@decwrl.dec.com>Received: from decwrl.dec.com by Xerox.COM ; 08 JUL 87 14:18:08 PDTReceived: by decwrl.dec.com (5.54.3/4.7.34)	id AA25408; Wed, 8 Jul 87 14:17:34 PDTReceived: By spar.SPAR.CAS.SLB.COM (from gyro.SPAR.CAS.SLB.COM)	id AA00706; Wed, 8 Jul 87 10:59:57 PDTReturn-Path: <schoen@gyro>Received: By gyro.SPAR.CAS.SLB.COM	id AA09848; Wed, 8 Jul 87 10:59:31 PDTDate: Wed, 8 Jul 87 10:59:31 PDTFrom: Eric Schoen <spar!schoen@decwrl.dec.com>Message-Id: <8707081759.AA09848@gyro.SPAR.CAS.SLB.COM>To: masinter.paSubject: Common Lisp cleanupLarry:I think I have a submission for the cleanup committee, but I've lostyoursubmission format.  I'll try to provide the information you want.Let's call this issue LET:SPECIAL-SCOPE or somesuch.  Here's the crux oftheproblem.  Consider a LET expression like:	(let ((a <foo>))          (declare (special a))          (bar))I've macroexpanded this example under Franz, Lucid, TI, and SymbolicsCommonLisps.  The first three macroexpand to:	((lambda nil	   (declare (special a)) 	   ((lambda (a)              (declare (special a))              (bar))            <foo>)))The last expands to:	((lambda nil 	   ((lambda (a)              (declare (special a))              (bar))            <foo>)))These are exactly equivalent unless <foo> happens to be the variable a.UnderTI, Lucid, and Franz's implementations, the interior a gets bound to thedynamic binding of a as of the time the entire expression is entered.UnderSymbolics, the interior a gets bound to the lexical value of a when theexpression is entered (assuming there is a lexically apparent binding ofa).So which is the proper treatment of the special declaration?  I tend tobelieve Symbolics is doing it correctly, but then why do so many otherimplementations do it differently?This came up when I was trying something like the following:(setq c (let ((a 1))          #'(lambda (function &rest args)              (let ((a a))                (declare (special a))                (apply function args)))))(funcall c 'eval 'a)When you do the funcall with a unbound globally, the TI, Franz, andLucidimplementations signal an error because a is unbound, whereas theSymbolicsimplementation returns 1.  The idea in this example is to return aclosurewhich captures the lexical value of a variable and makes it availabledynamically when the closure is applied.  I tried simpler approacheslikelocally declaring a special within the closure, but these failed on allimplementations.I imagine the cost of fixing all implementations to behave like theSymbolicsimplementation would be very low, since it's only a matter of changingthemacro definition of let.  The impact ought to be minor, since this is averyunusual situation.  I also think it deserves a clarification in thesilverbook.Eric     ----- Next Message -----Originator: @SAIL.STANFORD.EDU:Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxDate: 18 Aug 87 14:14From: Moon%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: FLET & declarationsIn-Reply-to: <12327146435.14.GZ@OZ.AI.MIT.EDU>To: GZ%OZ.AI.MIT.EDU%XX.LCS.MIT:EDU:Xeroxcc: common-lisp%SAIL.STANFORD:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: FLET & declarationsTo: GZ%OZ.AI.MIT.EDU@XX.LCS.MIT.EDUcc: common-lisp@SAIL.STANFORD.EDUIn-Reply-To: <12327146435.14.GZ@OZ.AI.MIT.EDU>Return-Path: <@SAIL.STANFORD.EDU:Moon@STONY-BROOK.SCRC.Symbolics.COM>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.STANFORD.EDU by Xerox.COM ; 18 AUG 87 14:14:29 PDTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 18Aug 87  13:28:28 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM bySTONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 215806; Tue18-Aug-87 16:28:17 EDTOriginal-Date: Tue, 18 Aug 87 16:27 EDTMessage-ID: <870818162759.2.MOON@EUPHRATES.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Mon 17 Aug 87 03:57:47-EDT    From: GZ%OZ.AI.MIT.EDU@XX.LCS.MIT.EDU    Are 'pervasive' declarations in FLET supposed to apply to thefunction bodies?    E.g.      (flet ((foo () x)) ;Is this x special?	(declare (special x))	...)      (flet ((foo () (foo) ...))  ;Does this call to (foo) return afixnum?	(declare (function foo () fixnum))	...)      (flet ((foo () (foo 17))) ;Is (foo 17) inline?	(declare (inline foo))	...)CLtL does not permit DECLARE to be used in that position (see p.113).I believe it has been proposed to change that, although I couldn'tfind a copy of the proposal in my rather disorganized files.  I wouldargue that the paragraph in the middle of page 155 of CLtL supportsthe position that when this extension is made, the pervasivedeclarationsshould apply to the function bodies.Note that the FUNCTION declaration used in your middle example is notpervasive.  Since you use FLET rather than LABELS, this declarationwould not apply to the call to FOO within the body of FOO.  It's adifferent FOO.The INLINE declaration is said by CLtL to be pervasive, however Ibelieve that to be a bug since it makes it unclear which of the twoFOOs in your example it refers to.  Perhaps it refers to both.Anyone putting together a proposal to clean up the specification ofdeclarations in Common Lisp ought to address the issues raised byyour question.     ----- End Forwarded Messages -----05-Jul-86  1654	Pavel.pa@Xerox.COM 	DECLARE SPECIAL Considered ConfusingReceived: from XEROX.COM by SU-AI.ARPA with TCP; 5 Jul 86  16:54:09 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 05 JUL 86 16:54:24 PDTDate: 5 Jul 86 16:54 PDTFrom: Pavel.pa@Xerox.COMSubject: DECLARE SPECIAL Considered ConfusingTo: Common-Lisp@SU-AI.ARPAMessage-ID: <860705-165424-2715@Xerox>I have a question concerning some ambiguity in the description of thescope of a special declaration inside a LET.  Consider this code:	(setq foo 6)	(let ((foo 7))		(let ((foo (1+ foo)))			(declare (special foo))			foo))Both Symbolics and CLISP return 8 for this, but VAXLISP returns 7.Clearly, the question is whether or not the special declaration coversthe init-form of the enclosing LET or just the bindings themselves.According to the ``nonsense'' example in CLtL, page 155, the referenceto ``foo'' in the call to 1+ should be special.  The GLS clarificationfor page 159, however, seems to support a different philosophy:``(*) 159  Clarify that in the following example		(defun foo (x)		  (declare (inline bar))		  (bar x)                           ; first		  (flet ((bar (z) (bar (+ z 1))))   ; second		    (bar x))                        ; third		  (bar x)                           ; fourth the first, second andfourth calls to BAR are affected by the INLINE declaration, but not thethird one.''This seems to support the view that the init-form of a binding is in ascope outside of that of the binding itself and the body of the LET (orFLET or ...).  I prefer this view.I would like to propose the following rule for the scope of declarationsin binding forms:``A declaration in a binding form (such as LET) affects the body of theform and the bindings themselves.  It does not affect the init-forms forthe bindings; they are in the same scope as the binding form as awhole.''This rule has the advantage (over the rule given for the nonsenseexample) that the scope of the declarations is the same as the scope ofthe bindings.  Thus, for the nonsense example:		(defun nonsense (k x z)		  (foo z x)                   ;First call to foo		  (let ((j (foo k x))         ;Second call to foo		        (x (* k k)))		    (declare (inline foo)		             (special x z))		    (foo x j z)))             ;Third call to foothe inline declaration affects only the third call to foo (not thesecond) and only the references to x and z in the third call to foo arespecial (not the reference to x in the second call).There would be only two exceptions to this rule:	-- In a LABELS binding, references in the definitions of the functionsto the very functions being bound would be affected by any declarationsaffecting the bindings themselves.  This makes sense because of therecursive quality of the binding.	-- The PROCLAIM function establishes pervasive declarations, coveringall bindings of and references to the symbols named.  Such declarationscan, of course, be countermanded by local declarations or laterproclamations.What do people think?  It would appear that some implementations alreadywork this way.	Pavel Curtis	Xerox AIS!07-Jul-86  0704	DCP@QUABBIN.SCRC.Symbolics.COM 	DECLARE SPECIALConsidered Confusing  Received: from SCRC-QUABBIN.ARPA by SU-AI.ARPA with TCP; 7 Jul 8607:04:50 PDTReceived: from FIREBIRD.SCRC.Symbolics.COM by QUABBIN.SCRC.Symbolics.COMvia CHAOS with CHAOS-MAIL id 16663; Mon 7-Jul-86 10:03:32 EDTDate: Mon, 7 Jul 86 10:03 EDTFrom: David C. Plummer <DCP@QUABBIN.SCRC.Symbolics.COM>Subject: DECLARE SPECIAL Considered ConfusingTo: Pavel.pa@Xerox.COM, Common-Lisp@SU-AI.ARPAIn-Reply-To: <860705-165424-2715@Xerox>Message-ID: <860707100308.8.DCP@FIREBIRD.SCRC.Symbolics.COM>    Date: 5 Jul 86 16:54 PDT    From: Pavel.pa@Xerox.COM    What do people think?  It would appear that some implementationsalready    work this way.I agree.  Consider LET to be a macro that turns into LAMBDA:	(let ((foo (1+ foo)))	  (declare (special foo))	  foo)	=> ((lambda (foo)	      (declare (special foo))	      foo)	    (1+ foo)) [I think this is what MacLisp actually did (does?).]  Thescoping here is clear: the foo in (1+ foo) is outside the scope of thedeclaration.!Received: from [192.10.41.41] by SU-AI.ARPA with TCP; 7 Jul 86  18:15:31PDTReceived: from EUPHRATES.SCRC.Symbolics.COM byELEPHANT-BUTTE.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 36962;Mon 7-Jul-86 20:58:58 EDTDate: Mon, 7 Jul 86 20:59 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: DECLARE SPECIAL Considered ConfusingTo: Pavel.pa@Xerox.COMcc: Common-Lisp@SU-AI.ARPAIn-Reply-To: <860705-165424-2715@Xerox>Message-ID: <860707205952.2.MOON@EUPHRATES.SCRC.Symbolics.COM>I do not wish to defend the current choice of declaration-scoping rulesin Common Lisp as the best or only choice, but I do wish to clarify whatthe rules are in the language as it is currently defined.  It wouldn'tbother me if a future revision of the language adopted simpler rules,provided they were truly (not just superficially) simpler.    Date: 5 Jul 86 16:54 PDT    From: Pavel.pa@Xerox.COM    I have a question concerning some ambiguity in the description ofthe    scope of a special declaration inside a LET.  Consider this code:	    (setq foo 6)	    (let ((foo 7))		    (let ((foo (1+ foo)))			    (declare (special foo))			    foo))    Both Symbolics and CLISP return 8 for this, but VAXLISP returns 7.VAXLISP is incorrect here.  The SPECIAL declaration is pervasive forreferences (but non-pervasive for bindings).  Because SPECIAL ispervasive for references it affects the reference to foo inside 1+.    Clearly, the question is whether or not the special declarationcovers    the init-form of the enclosing LET or just the bindings themselves.    According to the ``nonsense'' example in CLtL, page 155, thereference    to ``foo'' in the call to 1+ should be special.  The GLSclarification    for page 159, however, seems to support a different philosophy:    ``(*) 159  Clarify that in the following example		    (defun foo (x)		      (declare (inline bar))		      (bar x)                           ; first		      (flet ((bar (z) (bar (+ z 1))))   ; second			(bar x))                        ; third		      (bar x)                           ; fourth    the first, second and fourth calls to BAR are affected by the INLINE    declaration, but not the third one.''    This seems to support the view that the init-form of a binding is ina    scope outside of that of the binding itself and the body of the LET(or    FLET or ...).  I prefer this view.The scoping of variables (and FLET functions) is different from thescoping of pervasive declarations.  There is no analogy between thisexample and your previous one, because the INLINE declaration is notattached to a binding, but the SPECIAL declaration is attached to abinding.  All that's shown by this clarification is that INLINE, justlike SPECIAL, is shadowed by an occurrence of another binding of thesame name inside its scope.Incidentally, the bottom of p.154 says that SPECIAL is the onlydeclaration that falls into both classes, but I think INLINE is reallyin the same category.  It concerns a particular binding, but can also beused in the absence of a binding and is pervasive for references, justlike SPECIAL.    I would like to propose the following rule for the scope ofdeclarations    in binding forms:    ``A declaration in a binding form (such as LET) affects the body ofthe    form and the bindings themselves.  It does not affect the init-formsfor    the bindings; they are in the same scope as the binding form as a    whole.''    This rule has the advantage (over the rule given for the nonsense    example) that the scope of the declarations is the same as the scopeof    the bindings.  Thus, for the nonsense example:		    (defun nonsense (k x z)		      (foo z x)                   ;First call to foo		      (let ((j (foo k x))         ;Second call to foo			    (x (* k k)))			(declare (inline foo)				 (special x z))			(foo x j z)))             ;Third call to foo    the inline declaration affects only the third call to foo (not the    second) and only the references to x and z in the third call to fooare    special (not the reference to x in the second call).    There would be only two exceptions to this rule:	    -- In a LABELS binding, references in the definitions of thefunctions    to the very functions being bound would be affected by anydeclarations    affecting the bindings themselves.  This makes sense because of the    recursive quality of the binding.	    -- The PROCLAIM function establishes pervasive declarations,covering    all bindings of and references to the symbols named.  Suchdeclarations    can, of course, be countermanded by local declarations or later    proclamations.What about declarations inside the body of DEFUN?  With your rules Icannot see how a declaration could ever affect the default value formsfor &optional, &key, and &aux variables.  And what about declarationsinside the body of a LET*?  The scoping of ones attached to variables isfairly obvious, but what about ones not attached to variables?We went all through this during the design of Common Lisp (I think thediscussion is available online) and the current rules resulted.  Giventhat we must have DECLARE at all (a point which you should notnecessarily be willing to concede), the current rules seem to work moreconsistently than the alternatives that were considered.!Received: from BBNG.ARPA by SU-AI.ARPA with TCP; 7 Jul 86  19:45:22 PDTDate: 7 Jul 1986 22:44-EDTSender: NGALL@G.BBN.COMSubject: Re: DECLARE SPECIAL Considered ConfusingFrom: NGALL@G.BBN.COMTo: Moon@SCRC-STONY-BROOK.ARPACc: Pavel.pa@XEROX.COM, Common-Lisp@SU-AI.ARPAMessage-ID: <[G.BBN.COM] 7-Jul-86 22:44:13.NGALL>In-Reply-To: <860707205952.2.MOON@EUPHRATES.SCRC.Symbolics.COM>	    Date: Mon, 7 Jul 86 20:59 EDT    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    To: Pavel.pa@Xerox.COM    Subject: DECLARE SPECIAL Considered Confusing    In-Reply-To: <860705-165424-2715@Xerox>    Message-ID: <860707205952.2.MOON@EUPHRATES.SCRC.Symbolics.COM>         ...	Date: 5 Jul 86 16:54 PDT	From: Pavel.pa@Xerox.COM    	I have a question concerning some ambiguity in the description of the	scope of a special declaration inside a LET.  Consider this code:    		(setq foo 6)		(let ((foo 7))			(let ((foo (1+ foo)))				(declare (special foo))				foo))    	Both Symbolics and CLISP return 8 for this, but VAXLISP returns 7.        VAXLISP is incorrect here.  The SPECIAL declaration is pervasive for    references (but non-pervasive for bindings).  Because SPECIAL is    pervasive for references it affects the reference to foo inside 1+.    I don't wish to add to the confusion here, but my reading of pg 155agrees with VaxLisp: the above example should return 7.  The outermostLET binds a lexical var. named foo that is never referenced.  Thespecial declaration in the inner LET affects the variable being bound bythe LET (foo) and it affects the reference to foo in the explicit body(i.e. the last reference to foo) and the reference to foo in theinit-form in the inner LET is also special.  The global value of foo is6, and 6 + 1 = 7.-- Nick!Received: from SCRC-QUABBIN.ARPA by SU-AI.ARPA with TCP; 7 Jul 8620:15:02 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM byQUABBIN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 17091; Mon7-Jul-86 23:13:40 EDTDate: Mon, 7 Jul 86 23:13 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: DECLARE SPECIAL Considered ConfusingTo: Pavel.pa@Xerox.COMcc: Common-Lisp@SU-AI.ARPAIn-Reply-To: <860705-165424-2715@Xerox>Supersedes: <860707205952.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <860707231340.6.MOON@EUPHRATES.SCRC.Symbolics.COM>I do not wish to defend the current choice of declaration-scoping rulesin Common Lisp as the best or only choice, but I do wish to clarify whatthe rules are in the language as it is currently defined.  It wouldn'tbother me if a future revision of the language adopted simpler rules,provided they were truly (not just superficially) simpler.    Date: 5 Jul 86 16:54 PDT    From: Pavel.pa@Xerox.COM    I have a question concerning some ambiguity in the description ofthe    scope of a special declaration inside a LET.  Consider this code:	    (setq foo 6)	    (let ((foo 7))		    (let ((foo (1+ foo)))			    (declare (special foo))			    foo))    Both Symbolics and CLISP return 8 for this, but VAXLISP returns 7.VAXLISP is correct here.  The SPECIAL declaration is pervasive forreferences (but non-pervasive for bindings).  Because SPECIAL ispervasive for references it affects the reference to foo inside 1+.I apologize for the incorrect earlier version of this message that saidthat VAXLISP was incorrect here.  I didn't mean to add to the confusion;it must have been a Freudian slip.Incidentally, the incorrect result returned here by the Symbolicsimplementation is a (poorly) documented incompatibility with Common Lispthat will be fixed at some time in the future.    Clearly, the question is whether or not the special declarationcovers    the init-form of the enclosing LET or just the bindings themselves.    According to the ``nonsense'' example in CLtL, page 155, thereference    to ``foo'' in the call to 1+ should be special.  The GLSclarification    for page 159, however, seems to support a different philosophy:    ``(*) 159  Clarify that in the following example		    (defun foo (x)		      (declare (inline bar))		      (bar x)                           ; first		      (flet ((bar (z) (bar (+ z 1))))   ; second			(bar x))                        ; third		      (bar x)                           ; fourth    the first, second and fourth calls to BAR are affected by the INLINE    declaration, but not the third one.''    This seems to support the view that the init-form of a binding is ina    scope outside of that of the binding itself and the body of the LET(or    FLET or ...).  I prefer this view.The scoping of variables (and FLET functions) is different from thescoping of pervasive declarations.  There is no analogy between thisexample and your previous one, because the INLINE declaration is notattached to a binding, but the SPECIAL declaration is attached to abinding.  All that's shown by this clarification is that INLINE, justlike SPECIAL, is shadowed by an occurrence of another binding of thesame name inside its scope.Incidentally, the bottom of p.154 says that SPECIAL is the onlydeclaration that falls into both classes, but I think INLINE is reallyin the same category.  It concerns a particular binding, but can also beused in the absence of a binding and is pervasive for references, justlike SPECIAL.    I would like to propose the following rule for the scope ofdeclarations    in binding forms:    ``A declaration in a binding form (such as LET) affects the body ofthe    form and the bindings themselves.  It does not affect the init-formsfor    the bindings; they are in the same scope as the binding form as a    whole.''    This rule has the advantage (over the rule given for the nonsense    example) that the scope of the declarations is the same as the scopeof    the bindings.  Thus, for the nonsense example:		    (defun nonsense (k x z)		      (foo z x)                   ;First call to foo		      (let ((j (foo k x))         ;Second call to foo			    (x (* k k)))			(declare (inline foo)				 (special x z))			(foo x j z)))             ;Third call to foo    the inline declaration affects only the third call to foo (not the    second) and only the references to x and z in the third call to fooare    special (not the reference to x in the second call).    There would be only two exceptions to this rule:	    -- In a LABELS binding, references in the definitions of thefunctions    to the very functions being bound would be affected by anydeclarations    affecting the bindings themselves.  This makes sense because of the    recursive quality of the binding.	    -- The PROCLAIM function establishes pervasive declarations,covering    all bindings of and references to the symbols named.  Suchdeclarations    can, of course, be countermanded by local declarations or later    proclamations.What about declarations inside the body of DEFUN?  With your rules Icannot see how a declaration could ever affect the default value formsfor &optional, &key, and &aux variables.  And what about declarationsinside the body of a LET*?  The scoping of ones attached to variables isfairly obvious, but what about ones not attached to variables?We went all through this during the design of Common Lisp (I think thediscussion is available online) and the current rules resulted.  Giventhat we must have DECLARE at all (a point which you should notnecessarily be willing to concede), the current rules seem to work moreconsistently than the alternatives that were considered.!Received: from CS.UCL.AC.UK by SU-AI.ARPA with TCP; 8 Jul 86  13:54:24PDTReceived: from aiva.edinburgh.ac.uk by 44d.Cs.Ucl.AC.UK   via Janet withNIFTP           id a002506; 7 Jul 86 19:30 BSTFrom: Jeff Dalton <jeff%aiva.edinburgh.ac.uk@Cs.Ucl.AC.UK>Date: Mon, 7 Jul 86 19:27:20 -0100Message-Id: <1672.8607071827@aiva.ed.ac.uk>To: Common-Lisp@su-ai.arpa, DCP@scrc-quabbin.arpa, Pavel.pa@xerox.comSubject: Re:  DECLARE SPECIAL Considered Confusing   Date: Mon, 7 Jul 86 10:03 EDT   From: "David C. Plummer" <DCP@arpa.scrc-quabbin>   Subject: DECLARE SPECIAL Considered Confusing          Date: 5 Jul 86 16:54 PDT       From: Pavel.pa@Xerox.COM          What do people think?  It would appear that some implementationsalready       work this way.      I agree.  Consider LET to be a macro that turns into LAMBDA:      (let ((foo (1+ foo)))        (declare (special foo))        foo)      => ((lambda (foo)            (declare (special foo))            foo)          (1+ foo))   [I think this is what MacLisp actually did (does?).]  The scopinghere   is clear: the foo in (1+ foo) is outside the scope of thedeclaration.   If the SPECIAL declaration is to apply to the init forms, LET can be amacro that turns into two lambdas:	(let ((foo (1+ foo))) (declare (special foo)) foo)	 => ((lambda ()	      (declare (special foo))	      ((lambda (foo) foo) (declare (special foo)) (1+ foo))))Some implementations do work this way.!Received: from USC-ECL.ARPA by SU-AI.ARPA with TCP; 10 Mar 86  20:19:59PSTDate:     Mon, 10 Mar 86 19:01:24 PSTFrom: Jeff Barnett <jbarnett%NRTC@USC-ECL.ARPA>To: common-lisp@SU-AI.ARPASubject:  Re Scope and declarationsVia:  Nrtc; 10 Mar 86 20:04:19Sorry I wasn't specific enough in my last query.  Therefore, I'll startfrom scratch.  The point that bothers me is the one made on page 155 ofCLtL. As I understand things,  (setq x 5)  (defun foo (x)    (declare (unspecial x))    (let((x (1+ x)))      (declare (special x))      x)  (print (foo 0)) outputs 6, not 1.  The declare in the let formprevades the preset expression so that the expression (1+ x) assumes thecurrent global binding of x outside outside the let.  I can understandthat this will often be the right thing and require less writing.  Ialso understand that if I want to grab the lexical x that I could changethe let to start  (let((x (let()(declare (unspecial x)) (1+ x)))) which I suppose works.(Does it?)  However, if the let is produced by a macro, there is no wayto achieve this effect unless the macro can enumerate the scope of theexpression that it uses for the preset.  Since the preset may be passedinto the macro, I don't think it can recover in any graceful way unlessyou think that  (let((g exp))    (let((x g))      (declare (special x)) etc)) where g is a gensym, is graceful.Another problem with declares prevading presets is that the followingare not equivelent:  (let((v1 e1) (v2 e2)) (declare (something-about v1 v2)) body...)  ((lambda(v1 v2) (declare (something-about v1 v2)) body...) e1 e2)Further, I think the proposed standard is incompatible with virtuallyall other LISP implementations.  I don't think that this is a good ideafor CL. Any comments and clarifications as to all of this would beappreciated.	Jeff!Received: from SCRC-STONY-BROOK.ARPA by SU-AI.ARPA with TCP; 5 May 8516:33:05 PDTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM bySCRC-STONY-BROOK.ARPA via CHAOS with CHAOS-MAIL id 230444; Sun 5-May-8519:31:32-EDTDate: Sun, 5 May 85 19:30 EDTFrom: Kent M Pitman <KMP@SCRC-STONY-BROOK.ARPA>Subject: mysterious declarations off in left fieldTo: Fahlman@CMU-CS-C.ARPAcc: Common-Lisp@SU-AI.ARPAIn-Reply-To: <FAHLMAN.12108630198.BABYL@CMU-CS-C.ARPA>Message-ID: <850505193039.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>    Date: Sun, 5 May 1985  14:12 EDT    From: "Scott E. Fahlman" <Fahlman@CMU-CS-C.ARPA>	Don't packages offer an alternative way of scoping declarations?    Sure, but packages normally function at a very large grain size.    Sometimes you want to add something to a package without having toscan    the whole package definition to ensure that some fool has notdeclared X    to be a quadruple-float.Or SPECIAL! I've already had problems in Macsyma source code withclosures that didn't "close" because someone decided STRING should be aspecial variable. I guess you can imagine how that would be a prettyhigh-probability variable name and a poor choice of special name ...Consider too that names like LIST, STRING, etc. are not likely to beprivate -- nearly everyone is going to inherit them from GLOBAL -- sothe first time anyone in any "package" declares one of them to bespecial, it screws everyone else who tries to do compilations in thatenvironment.    If I bind a lexical X, that's my X and I'm not interested in anyone     else's views about what type X's in general should be.Indeed.Actually, I wonder if we shouldn't have said that type proclamationsshould pertain only to special variables. eg, (PROCLAIM '(TYPE FLOAT TOLERANCE))might have only applied to special occurrences of TOLERANCE. This wouldmean that people using variables lexically in other modules would be farless likely to find irrelevant declarations affecting them...In cases where people wanted to make assertions about lexical variables,they should perhaps have to scope such declarations lexically.Although obviously such a change is somewhat incompatible, we mightconsider it (or something like it) for the next round of revisions. (Analternate approach which would achieve the same end would be tointroduce a new declaration operator which had the property of applyingonly to special occurrences so that people could choose which style they wanted.)Of course this doesn't solve the problem I alluded to earlier of havingpeople declare things special behind my back...!Received: from MIT-ML by SU-AI with TCP/SMTP; 20 Dec 83  12:52:05 PSTReceived: from SCRC-EUPHRATES by SCRC-TENEX with CHAOS; Tue 20-Dec-8315:53:04-ESTDate: Tue, 20 Dec 83 15:50 ESTFrom: "David A. Moon" <Moon%SCRC-TENEX@MIT-MC.ARPA>Subject: DeclarationsTo: Common-Lisp@SU-AI.ARPAI have an alternate proposal for declarations.  It is mainly intended asan easier-to-understand way of explaining things that gives the samesemantics, but it also resolves the inconsistencies in the manual (MaryPoppins and Excelsior editions) in a way that is probably inconsistentwith the intent of the manual, but is more consistent with the Laseredition and with the practice in previous lisps such as Maclisp and LispMachine Lisp. I realize it is rather late for this kind of thing, butgiven that the manual is inconsistent with itself and that some peoplewere surprised by the change from last year's version of the language,maybe we can reconsider. In any case this way of explaining things seemsto be easier to understand.The basic problem is the SPECIAL declaration, which falls into bothcategories of declarations: it both concerns the binding of variablesand is pervasive. This is not well explained in the manual and seems tobe a great source of confusion.  I propose to flush the idea thatSPECIAL declarations are pervasive.  Read on before judging.There are two disjoint classes of declaration: those that are attachedto a particular variable binding, and those that are not.  Note that Iam not discussing proclamations here; they have their own scoping ruleswhich are different from the rules for declarations.The scoping rule for the first kind of declaration is that it applies toprecisely the text that is in the lexical scope of the variable bindingwith which it is associated.  Such declarations are shadowed by avariable binding for the same name inside their scope.  Since thelexical scoping rules are very well and precisely defined, we alreadyunderstand everything about this kind of declaration.The scoping rule for the second kind of declaration is that it ispervasive.  The declaration is attached to a lambda-expression or to aform (one of the special forms listed on page 125).  The declarationapplies to all text inside that expression or form; there are no specialcases such as init-forms of LET or DO.  Such declarations are shadowedby a conflicting declaration inside their scope.Possible names for the two kinds of declaration are "lexical" and"pervasive" or "variable" and "non-variable."None of this is new.  What about SPECIAL declarations?  I propose thatSPECIAL declarations be put entirely into the first category, in thefollowing way:When a declaration, (SPECIAL X), is attached to a form (orlambda-expression) it creates a -lexical- binding of the name X in thatform.  Unlike all other bindings, this binding does not associate avalue with the name X.  Instead, it associates a "special" marker withthe name.  Any text that is in the lexical scope of this binding, anduses the variable X, refers to the dynamic binding of X, because it seesthe "special" marker.  The scope of a SPECIAL declaration is preciselydefined by the scope of this binding.  Note how close this definition isto the way that some interpreters actually work internally.In addition to creating this lexical binding, a (SPECIAL X) declarationalso changes the meaning of a binding, if there is one, of the variableX in the form to which the declaration is attached; it causes thatbinding to be a dynamic binding rather than a lexical binding.  Thisapplies only to the form to which the declaration is directly attached,not to any subforms of it. (This is not new.)The declaration-allowing forms FLET, LABELS, LOCALLY, and MACROLET donot normally create bindings of variable names (only function names), sowe have a slight exception, permitting SPECIAL declarations inside themto create such bindings.We now understand completely how the SPECIAL declaration works in LET.Three examples:	(defun foo (x)	  (let ((x x))	    (declare (special x))	    (bar x))) Reading from left to right, there are five occurrences ofx.  The declaration causes the second and fifth to refer to a dynamicvariable, while the first and third refer to a lexical variable.  (Thefourth occurrence is the one in the declaration itself).  The thirdoccurrence of x does not refer to the dynamic variable, because it isnot in the scope of the lexical binding of the name x created by thespecial declaration, because of the way LET defines scoping in itssubforms.	(defun foo ()	  (declare (special x))	  (bar x)) The declaration causes the second occurrence of x to refer,freely, to a dynamic variable, because this x is inside the lexicalscope of a binding of the name x attached to the defun.	(defun foo ()	  (let ((x (quux)))	    (mumble x)	    (locally	      (declare (special x))	      (bar x)))) Here the first and second occurrences of x refer to alexical variable, while the fourth refers to a dynamic variable.  Thebinding of the name x in the LOCALLY shadows the binding of the name xin the LET.There remains the issue of how sequential binding forms such as LET* andDEFUN should work.  (DEFUN uses sequential binding with respect toinitial value forms for &optional, &key, and &aux variables).  When aSPECIAL declaration creates a lexical binding of a name in such a form,at what position in the sequence of bindings should it be inserted?This makes a difference because it affects whether the scope of thedeclaration includes or excludes the initial value forms.  Clearly ifthe form includes a (dynamic) binding of the name being declared, thenthe (lexical) binding created by the declaration should be inserted atthat point.  Otherwise we can either insert the declaration's binding atthe beginning of the sequence of bindings, giving it the largestpossible scope, or at the end, giving it the smallest possible scope.  Isuggest putting it at the beginning, because that is what people seem toexpect with DEFUN (see the example at the bottom of page 126.) Twoexamples:	(defun foo (x)	  (let* ((x (bar x))		 (y (quu x)))	    (declare (special x))	    ...)) The first and third occurrences of x refer to a lexicalvariable, while the second and fourth refer to a dynamic variable.  (barx) is outside the scope of the special declaration while (quu x) isinside its scope.	(defun foo (x)	  (let* ((w (bar x))		 (y (quu x)))	    (declare (special x))	    ...)) The first occurrence of x refers to a lexical variable, whilethe second and third refer, freely, to a dynamic variable.  Both (bar x)and (quu x) are inside the scope of the special declaration.  If let hadbeen used instead of let*, neither of them would be inside the scope ofthe declaration.For explanatory purposes, the above two examples could be written onpaper as	(defun foo (x)	  (let* ((x (bar x))		 (x @I[special])		 (y (quu x)))	    (declare (special x))	    ...))	(defun foo (x)	  (let* ((x @I[special])		 (w (bar x))		 (y (quu x)))	    (declare (special x))	    ...))*start*00957 00024 US Date: Thu, 19 Nov 87 18:43:23 PSTFrom: Pavel.paSubject: Re: Issue: DECLARATION-SCOPEIn-reply-to: "Masinter's message of 19 Nov 87 17:59 PST"To: MasinterCc: PavelHow can you send me such a thing just when I'm trying to get back to work on my thesis?  Sigh.I would love to submit a proposal on this and I think that I could write up a good one at that, but I can't justify spending any significant amount of time on Common Lisp until after I've defended, at least.  What will happen if I say that I won't submit a proposal until, say, January or so?  Is there a big hurry that I'm unaware of?  If the result of my postponing it will be that some utter bozo such as Haflich (why is he Cc'd on the message?) will write it, then I'm alarmed (but please don't take advantage of me).  If the result is just that the issue won't be brought up for another couple of months, then I won't be alarmed at all.What's the story?	Pavel*start*00499 00024 US From: masinter.PADate: 20-Nov-87  9:07:01 PSTSubject: Re: Issue: DECLARATION-SCOPEIn-reply-to: Your message of Thu, 19 Nov 87 18:43:23 PSTTo: Pavelcc: MasinterSteele was putting on some pressure that we should have a draft of the standard by a year, and it meant getting the bulk of the currently open cleanup issues out of the way within 6 months.This was just the first of the issues going thru them in alphabetic order.We won't pass anything without review....*start*08008 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 JAN 88 05:23:22 PSTReceived: from [128.81.41.109] by SAIL.STANFORD.EDU with TCP; 5 Jan 88  05:21:13 PSTReceived: from WINTER.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 156176; Tue 5-Jan-88 08:21:23 ESTDate: Tue, 5 Jan 88 08:21 ESTFrom: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPETo: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <871119-175949-1009@Xerox>Message-ID: <19880105132119.9.HORNIG@WINTER.SCRC.Symbolics.COM>Issue:         DECLARATION-SCOPINGReferences:    Section 9.1 (pp. 153-157).Category:      CHANGEEdit history:  V1: Hornig@Symbolics.COM -- 5 January 1988Problem description:The description of the scope of declarations made with DECLARE is bothunclear (although unambiguous) and arguably a mistake.  The issue iswhether the scope of some or all of the declarations includes codeappearing in the non-body part of the special form containing thedeclaration.Proposal DECLARATION-SCOPING:LIKE-VARIABLE:For the purposes of this proposal, we divide all declarations introducedwith DECLARE into two classes.  When a declaration of a variable appearsbefore the body of a special form or lambda-expression that binds thatvariable, the declaration is called `normal'.  All other declarationsare called `free'.  This division replaces the division into pervasive,nonpervasive, and SPECIAL declarations appearing in CLtL.The scope of a `normal' declaration is exactly the scope of theassociated lexical variable or function.  If the declaration isassociated with a special variable, the scope is the scope the variablewould have had if it had not been special.  `Free' declarations arescoped as if they appeared in a new LOCALLY form which surrounded theentire special form of which the declaration appears at the beginning ofthe body.SPECIAL declarations may be either `normal', affecting both a bindingand references, or `free', affecting only references.  TYPE and IGNOREdeclarations may only be `normal'.  (There has been some discussion inX3J13 of permitting `free' TYPE declarations.)If Common Lisp is extended to permit declarations in FLET and LABELSforms, then declarations of functions (FTYPE, FUNCTION, INLINE, andNOTINLINE) which appear before the body of a FLET or LABELS form whichdefines that function are also `normal'.Common Lisp is ambiguous about whether a variable may be bound severaltimes by a single form.  It has been proposed that multiple bindings bepermitted for LET*, DO*, PROG* forms and for &AUX variables in lambdaexpressions.  If multiple bindings are permitted, `normal' declarationsare treated as if there were a separate `normal' declaration for each ofthe bindings.Examples:;;; Some examples of `free' and `normal' declarations.(let ((a 1))  (declare (optimize speed))		;this is a `free' declaration  (let ((b 2))    (declare (type integer b))		;this is a `normal' declaration    (declare (special a))		;this is a `free' declaration    ()));;; This example applies if you believe that FLET may have declarations.(flet ((foo (x) (1+ x)))  (declare (notinline foo))		;this is a `normal' declaration  (declare (notinline 1+))		;this is a `free' declaration  ());;; The following code is from Pavel.;;; It produces 7 in existing implementations.;;; If the proposal is adopted, it will produce 8.(let ((foo 6))			;a special binding of FOO  (declare (special foo))	;`normal' declaration  (let ((foo 7))		;a lexical binding of FOO    (let ((foo (1+ foo)))	;is the second FOO special or not?      (declare (special foo))	;`normal' declaration      foo)));;; Treatment of LET* under the proposal if multiple bindings of the same name are allowed.;;; This form produces the value 9.(let ((foo 6))			;a special binding of FOO  (declare (special foo))	;`normal' declaration  (let ((foo 7))		;a lexical binding of FOO    (let* ((foo (1+ foo))	;special binding, lexical reference           (foo (1+ foo)))	;special binding, special reference      (declare (special foo))	;`normal' declaration, applies to both bindings       foo))		        ;special referenceRationale:`Normal' declarations are made to control a particular binding of avariable and should be scoped the same way as that binding.  This is astrue of `normal' declarations which were pervasive under the old rulesas it is of those that were not.Current practice:The `normal'/`free' division based on context replaces CLtL's staticpervasive/nonpervasive/SPECIAL division.  Most implementations implementthe rules in CLtL.  Symbolics currently implements rules based onZetalisp which are different from both this proposal and Common Lisp.Symbolics plans to change to Common Lisp rules in the future.Cost to Implementors:The cost of implementing this change should be moderate.  The changewill be localized to a handful of places in the compiler and interpreterwhich apply declarations to variables.  The other cost would be inproviding tools for users to find programs whose meaning will change.Cost to Users:The proposal changes only the treatment of `normal' declarations.  Thischange will break very few existing production programs.It is possible to mechanically examine a program to determine whetherits behavior would change under the new rules.  This permits animplementation to provide a transition tool to ease conversion to thenew definition.Cost of non-adoption:The ability of a `normal' declaration to affect code outside the scopeof the variable which it appears to declare has led to endless confusionand discussion at Symbolics, on the Common-Lisp mailing list, andelsewhere.  It will continue to do so unless it is smoothed over somehow.Benefits:The costs of non-adoption will be avoided.Aesthetics:The distinction between `normal' and `free' declarations introduced bythis proposal is a natural one.Discussion:A proposal to forbid `free' declarations except in LOCALLY forms and aproposal to have `free' declarations affect only the body were discardedas being too incompatible.The mapping from the existing pervasive/nonpervasive/SPECIAL division ofdeclarations and the one proposed here is complex.  In general,nonpervasive declarations are `normal' and pervasive declarations are`free'.  SPECIAL declarations are either `normal' or `free' based ontheir context, and are no longer treated as a special case.Some historical support for having `free' and `normal' declarations:Date: Tue, 20 Dec 83 15:50 ESTFrom: "David A. Moon" <Moon%SCRC-TENEX@MIT-MC.ARPA>Subject: DeclarationsTo: Common-Lisp@SU-AI.ARPA...There are two disjoint classes of declaration: those that are attachedto a particular variable binding, and those that are not.  Note that Iam not discussing proclamations here; they have their own scoping ruleswhich are different from the rules for declarations.The scoping rule for the first kind of declaration is that it applies toprecisely the text that is in the lexical scope of the variable bindingwith which it is associated.  Such declarations are shadowed by avariable binding for the same name inside their scope.  Since thelexical scoping rules are very well and precisely defined, we alreadyunderstand everything about this kind of declaration.The scoping rule for the second kind of declaration is that it ispervasive.  The declaration is attached to a lambda-expression or to aform (one of the special forms listed on page 125).  The declarationapplies to all text inside that expression or form; there are no specialcases such as init-forms of LET or DO.  Such declarations are shadowedby a conflicting declaration inside their scope.Possible names for the two kinds of declaration are "lexical" and"pervasive" or "variable" and "non-variable."...*start*00952 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 JAN 88 09:39:31 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 5 Jan 88  09:37:59 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via INTERNET with SMTP id 315295; 5 Jan 88 12:35:50 ESTDate: Tue, 5 Jan 88 12:35 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPETo: cl-cleanup@SAIL.STANFORD.EDUcc: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>In-Reply-To: <19880105132119.9.HORNIG@WINTER.SCRC.Symbolics.COM>Message-ID: <19880105173525.2.MOON@EUPHRATES.SCRC.Symbolics.COM>I'm strongly in favor of DECLARATION-SCOPING:LIKE-VARIABLE; I thinkit nicely settles a long-standing problem with Common Lisp.  I supportthis even though I'm usually opposed to incompatible changes.*start*01866 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 JAN 88 13:47:38 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 5 Jan 88  13:45:23 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 05 JAN 88 13:45:00 PSTDate: Tue, 5 Jan 88 13:44:36 PSTFrom: Pavel.paSubject: Re: Issue: DECLARATION-SCOPEIn-reply-to: <19880105132119.9.HORNIG@WINTER.SCRC.Symbolics.COM>To: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>Cc: cl-cleanup@SAIL.STANFORD.EDUMessage-ID: <880105-134500-4150@Xerox>Unsurprisingly, since it's so close to what I informally proposed a year or twoago, I generally favor this proposal; it is much much better than the statusquo.  I do have a few concerns, though:1) It is not clear to me that free declarations should cover the entire form.  Inote, in particular, that none of the discussion or rationale mentions thescoping of free declarations.  The alternative that seems more natural to me hasthem covering only the body of the special form in which they appear, not theentire special form.  Charles, could you discuss this?2) I would very much like to see more detail in the proposal.  In particular, Iwould like a complete listing of the types of declarations and their kinds(normal vs. free).  Conceivably, a list of all of the macros and special formssupporting declarations and the scopes in each case should also be included.  Itmay be, however, that this description is implied by the (sometimes nonexistent)definitions of the semantics of the various macros and special forms.3) I don't like using the name ``normal'' for one half of a dichotomy,especially considering that the other half is named ``free''.  Is there anyreason not to call the others ``bound'' instead of ``normal''?	Pavel*start*02696 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 JAN 88 14:32:53 PSTReceived: from [128.81.41.109] by SAIL.STANFORD.EDU with TCP; 5 Jan 88  14:30:28 PSTReceived: from WINTER.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 156483; Tue 5-Jan-88 17:30:38 ESTDate: Tue, 5 Jan 88 17:30 ESTFrom: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARATION-SCOPETo: Pavel.pacc: cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880105-134500-4150@Xerox>Message-ID: <19880105223028.7.HORNIG@WINTER.SCRC.Symbolics.COM>    Date: Tue, 5 Jan 88 13:44:36 PST    From: Pavel.pa@Xerox.COM    Unsurprisingly, since it's so close to what I informally proposed a year or two    ago, I generally favor this proposal; it is much much better than the status    quo.  I do have a few concerns, though:    1) It is not clear to me that free declarations should cover the entire form.  I    note, in particular, that none of the discussion or rationale mentions the    scoping of free declarations.  The alternative that seems more natural to me has    them covering only the body of the special form in which they appear, not the    entire special form.  Charles, could you discuss this?I was trying for greater compatibility.  Most `free' declarations arecurrently pervasive and apply to the entire form.  The intent of theproposal was to leave them mostly as they are now.  I would considerchanging them to apply only to the body to be a separable and separatechange.     2) I would very much like to see more detail in the proposal.  In particular, I    would like a complete listing of the types of declarations and their kinds    (normal vs. free).  Conceivably, a list of all of the macros and special forms    supporting declarations and the scopes in each case should also be included.  It    may be, however, that this description is implied by the (sometimes nonexistent)    definitions of the semantics of the various macros and special forms.When I started to do this, I got bogged down in all sorts of unrelatedissues.  For example, are free TYPE declarations permitted in CommonLisp?  I didn't want this proposal to become a vehicle for all sorts ofunrelated changes or claraifications to declaration processing.    3) I don't like using the name ``normal'' for one half of a dichotomy,    especially considering that the other half is named ``free''.  Is there any    reason not to call the others ``bound'' instead of ``normal''?I'd love to use a better name.  I hope others will comment on this.*start*01944 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 JAN 88 15:00:43 PSTReceived: from SCRC-STONY-BROOK.ARPA by SAIL.STANFORD.EDU with TCP; 5 Jan 88  14:58:10 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 315732; Tue 5-Jan-88 17:57:50 ESTDate: Tue, 5 Jan 88 17:57 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARATION-SCOPETo: Pavel.pa, Moon@STONY-BROOK.SCRC.Symbolics.COM, Hornig@ALDERAAN.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDUIn-Reply-To: <880105-134500-4150@Xerox>,             <19880105173525.2.MOON@EUPHRATES.SCRC.Symbolics.COM>,             <19880105132119.9.HORNIG@WINTER.SCRC.Symbolics.COM>Message-ID: <880105175714.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>I concur with Moon's supportive remarks about Hornig's proposal.    Date: Tue, 5 Jan 88 13:44:36 PST    From: Pavel.pa@Xerox.COM    ... It is not clear to me that free declarations should cover the entire form. ...We discussed this internally before Hornig sent the proposal. I and others herewanted free declarations to cover the entire form mainly because you need to beable to declare things in the lambda list of a DEFUN form and you can't put aLOCALLY around the outside of the DEFUN or the defun will no longer be at toplevel (and hence may not get compiled in some implementations). eg, consider(DEFUN FOO (&OPTIONAL (X Z) (Y Z))  (DECLARE (SPECIAL Z))  ...)If you don't have the proposed semantics, you have to write:(LOCALLY (DECLARE (SPECIAL Z))  (DEFUN FOO (&OPTIONAL (X Z) (Y Z))    ...))which doesn't really work for the reasons cited above, or(DEFUN FOO (&OPTIONAL (X (LOCALLY (DECLARE (SPECIAL Z)) Z))		      (Y (LOCALLY (DECLARE (SPECIAL Z)) Z)))  ...)which works but is very tedious to write.*start*01183 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 JAN 88 16:45:43 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 5 Jan 88  16:44:00 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 05 JAN 88 16:42:09 PSTDate: Tue, 5 Jan 88 16:41:43 PSTFrom: Pavel.paSubject: Re: Issue: DECLARATION-SCOPEIn-reply-to: <880105175714.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>To: Hornig@ALDERAAN.SCRC.Symbolics.COM, CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880105-164209-4496@Xerox>Kent points out that having free declarations cover the entire form allows oneto conveniently cover the expressions in &optional, &key and &aux expressions.In some sense, those expressions are a part of the ``body'' of the lambdaexpression.  Perhaps a more picky definition of ``body'' would be better thanthe blanket coverage.  That is, let declarations in lambda forms cover theentire form but those in, say, LET forms only cover the body.  This allows me tounderstand LET as a macro expanding into a simple call of a LAMBDA without anycaveats about declaration parsing.	Pavel*start*01045 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 JAN 88 19:24:24 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 5 Jan 88  19:22:16 PSTReceived: ID <FAHLMAN@C.CS.CMU.EDU.#Internet>; Tue 5 Jan 88 22:22:19-ESTDate: Tue, 5 Jan 88 22:22 ESTMessage-ID: <FAHLMAN.12364320725.BABYL@C.CS.CMU.EDU>Sender: FAHLMAN@C.CS.CMU.EDUFrom: "Scott E. Fahlman" <Fahlman@C.CS.CMU.EDU>To: CL-Cleanup@SAIL.STANFORD.EDUSubject: Issue: DECLARATION-SCOPEDECLARATION-SCOPE:LIKE-VARIABLE looks good to me.I agree that "normal" is a somewhat loaded term.  "Bound" seems wrong.How about calling these "binding-related declarations"?  Not acritically important issue in any case.Is there any effective difference between saying that "free" declarationssurround the whole form and saying that they surround only the body, butthat the init forms are part of the body?  If not, the former way ofstating it seems clearer.-- Scott*start*02311 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 05 JAN 88 20:01:05 PSTReceived: from XEROX.COM by SAIL.STANFORD.EDU with TCP; 5 Jan 88  19:58:42 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 05 JAN 88 19:57:40 PSTDate: Tue, 5 Jan 88 19:57:09 PSTFrom: Pavel.paSubject: Re: Issue: DECLARATION-SCOPEIn-reply-to: <FAHLMAN.12364320725.BABYL@C.CS.CMU.EDU>To: CL-Cleanup@SAIL.STANFORD.EDUMessage-ID: <880105-195740-4775@Xerox>Scott asks, ``Is there any effective difference between saying that "free"declarations surround the whole form and saying that they surround only thebody, but that the init forms are part of the body?  If not, the former way ofstating it seems clearer.''I assume that this is addressed to my suggestion that free declarations inLAMBDA-forms cover the default-value expressions in &optional, &aux, and &keyparameters.  The point is that I would rather that such declarations didn'tcover the init-expressions in LET and the bodies of the lexical functions inFLET and LABELS.  If you macroexpand LET in the obvious way, with thedeclarations inside the LAMBDA form, then the init forms are outside of thescope of the free declarations, as I would desire.I think that the reason that I want this is that in the following:	(let ((foo init-expression))	   (declare ((bound-declaration foo)	             (free-declaration)))	   body)the free declaration covers the init expression while the bound one does not.  Ithink of declarations as appearing at the head of the code that they cover andso I'd want both of these declarations to cover only the body.  In fact, I thinkthat I would rather that the free declarations in a LAMBDA form only cover thereal body, and not the default-value expressions, for just this reason.  I guessthat I'm not impressed by Kent's example since I don't see very much use forlocal declarations around default-value expressions.  Perhaps he'll show me somestartlingly clear-cut example of this being useful.Bound declarations, on the other hand, should have identical scope with thevariable to which they refer.  This seems intuitive since they are, in effect,changing the overal meaning of that variable.	Pavel*start*01779 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 06 JAN 88 07:39:00 PSTReceived: from C.CS.CMU.EDU by SAIL.STANFORD.EDU with TCP; 6 Jan 88  07:36:46 PSTReceived: ID <RAM@C.CS.CMU.EDU.#Internet>; Wed 6 Jan 88 10:36:51-ESTDate: Wed, 6 Jan 88 10:29 ESTMessage-ID: <RAM.12364453185.BABYL@>Sender: RAM.PAFrom: Ram at c.cs.cmu.eduTo: Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>Cc: CL-Cleanup at SAIL.STANFORD.EDU,     Hornig at ALDERAAN.SCRC.Symbolics.COM,     Moon at STONY-BROOK.SCRC.Symbolics.COM, Pavel.pa at Xerox.COMSubject: Issue: DECLARATION-SCOPEIn-reply-to: Msg of 5 Jan 1988  17:57-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>ReSent-Date: Wed 6 Jan 88 10:36:50-ESTReSent-From: Rob.MacLachlan@C.CS.CMU.EDUReSent-To: cl-cleanup@SAIL.STANFORD.EDUReSent-Message-ID: <12364454448.17.RAM@C.CS.CMU.EDU>    Date: Tuesday, 5 January 1988  17:57-EST    From: Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>    cc:   CL-Cleanup at SAIL.STANFORD.EDU    Re:   Issue: DECLARATION-SCOPE    [...] I and others here wanted free declarations to cover the    entire form mainly because you need to be able to declare things    in the lambda list of a DEFUN form and you can't put a LOCALLY    around the outside of the DEFUN or the defun will no longer be at    top level (and hence may not get compiled in some    implementations). I think that this argument is pretty weak, since the concept of "attop level" doesn't belong in the language (and isn't currentlydefined).  Any implementation that doesn't compile a definitionwhen a LOCALLY (or anything else) is wrapped around it is a brokenimplementation.  Rob*start*03495 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup­.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 06 JAN 88 20:36:57 PSTReceived: from LABREA.STANFORD.EDU by SAIL.STANFORD.EDU with TCP; 6 Jan 88  20:34:17 PSTReceived: by labrea.stanford.edu; Wed, 6 Jan 88 20:34:19 PSTReceived: from bhopal.lucid.com by edsel id AA00386g; Wed, 6 Jan 88 20:23:40 PSTReceived: by bhopal id AA14597g; Wed, 6 Jan 88 20:26:00 PSTDate: Wed, 6 Jan 88 20:26:00 PSTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8801070426.AA14597@bhopal.lucid.com>To: labrea!Hornig%ALDERAAN.SCRC.Symbolics.COM@labrea.stanford.eduCc: labrea!cl-cleanup%SAIL@labrea.stanford.eduIn-Reply-To: Charles Hornig's message of Tue, 5 Jan 88 08:21 EST <19880105132119.9.HORNIG@WINTER.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPEI welcome this proposal wholeheartedly -- it irons out another of those brainos for which no one can now even remember a decent rationale.However, there is one point I'd like to see pressed further.  You propose:    The scope of a `normal' declaration is exactly the scope of the    associated lexical variable or function.  . . .     SPECIAL declarations may be either `normal', affecting both a binding    and references, or `free', affecting only references.  TYPE and IGNORE    declarations may only be `normal'.  (There has been some discussion in    X3J13 of permitting `free' TYPE declarations.)I think it is very shortsighted to limit the TYPE and IGNORE declarationsthis way.  In so far as IGNORE is merely advice to the compiler to stopissuing worthless "bound, but unreferenced" warning messages, there isno incompatiblity with it being in a LOCALLY form;  it just means inhibitwarning messages for instances found in this lexical range.Now the probable rationale for limiting the TYPE declaration must have been so that it could affect the way in which bindings occur [e.g., inpdp10 MacLisp, a flonum is stored on a float pdl, but a regular variableis stored on the regpdl.]  It is all well and fine if the user-suppliedscoping information can include the binding; but what if it can't?  is itso bad that the supplied information can be only partly useful inoptimization?  Isn't it much better to permit the compiler to use theuseful part than to prohibit it from noticing at all? Take, for example:    (let ((x <some-value>))      (if (floatp x)	  (locally (type float x)            (+ x 3.4))          (if (integerp x)	      (ash x -3)              (error "What the heck"))))If the compiler is prohibited from noticing the LOCALLY type declaration,then it can't open-code the "+" operation; otherwise, it can open-code it.True, it will be fetching x from a regular "pointer" location rather thanfrom a floating-point register (or whatever), but at least it will bedoing something that can make an order of magnitude difference in speed(at least with Lucid's compiler).After all, nothing compels a conforming compiler to do anything *different*with a binding when it notices a TYPE declaration affecting the variablebeing bound.This particular problem may be more than you wanted to bite off; if so,maybe I'll be able to find the time to submit a separate proposal on it.But since you've taken the plunge already on declaration scoping (andsince I've been so busy with product deadlines etc.) I thought you maywant to field the whole matter.-- JonL --*start*02419 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 07 JAN 88 06:00:24 PSTReceived: from [128.81.41.109] by SAIL.STANFORD.EDU with TCP; 7 Jan 88  05:55:26 PSTReceived: from WINTER.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 156925; Thu 7-Jan-88 08:55:37 ESTDate: Thu, 7 Jan 88 08:55 ESTFrom: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPETo: Jon L White <edsel!jonl@labrea.stanford.edu>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8801070426.AA14597@bhopal.lucid.com>Message-ID: <19880107135530.3.HORNIG@WINTER.SCRC.Symbolics.COM>    Date: Wed, 6 Jan 88 20:26:00 PST    From: Jon L White <edsel!jonl@labrea.stanford.edu>    I welcome this proposal wholeheartedly -- it irons out another of those     brainos for which no one can now even remember a decent rationale.    However, there is one point I'd like to see pressed further.  You propose:	The scope of a `normal' declaration is exactly the scope of the	associated lexical variable or function.  . . . 	SPECIAL declarations may be either `normal', affecting both a binding	and references, or `free', affecting only references.  TYPE and IGNORE	declarations may only be `normal'.  (There has been some discussion in	X3J13 of permitting `free' TYPE declarations.)    I think it is very shortsighted to limit the TYPE and IGNORE declarations    this way.  In so far as IGNORE is merely advice to the compiler to stop    issuing worthless "bound, but unreferenced" warning messages, there is    no incompatiblity with it being in a LOCALLY form;  it just means inhibit    warning messages for instances found in this lexical range.    ....    This particular problem may be more than you wanted to bite off; if so,    maybe I'll be able to find the time to submit a separate proposal on it.    But since you've taken the plunge already on declaration scoping (and    since I've been so busy with product deadlines etc.) I thought you may    want to field the whole matter.My intention was only to restate what was already in CLtL.  I would behappy to see a proposal to permit `free' TYPE declarations.  I am tryingnot to let the DECLARATION-SCOPING proposal get side-tracked againtrying to become a "fix all bugs with declarations" proposal.*start*01244 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 14 JAN 88 20:55:38 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 14 Jan 88  20:23:25 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 14 JAN 88 19:46:17 PSTDate: 14 Jan 88 19:45 PSTFrom: Masinter.paSubject: Re: Issue: DECLARATION-SCOPEIn-reply-to: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>'s message of Thu, 7 Jan 88 08:55 ESTTo: Hornig@ALDERAAN.SCRC.Symbolics.COMcc: cl-cleanup@sail.stanford.eduMessage-ID: <880114-194617-4828@Xerox>In order for this proposal to go out in the mailing to X3J13 committee members,we will need a version of the proposal that reflects, either in the cost/benefitanalysis, or in the discussion, the topics mentioned in the mail so far. If you want to separate out the issues of type declarations into a separateproposal, then this proposal is misnamed, it probably should beDECLARE-SPECIAL-SCOPE and you need another one that is DECLARE-TYPE-SCOPE. Personally, I think we are close enough to attempt a comprehensive set of rulesfor DECLARATION-SCOPE and that you should go for it; there's not that much time.*start*11144 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 FEB 88 08:00:14 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 3 Feb 88  07:57:36 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 334297; Tue 2-Feb-88 22:46:51 ESTDate: Tue, 2 Feb 88 22:46 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPE (Version 2)To: cl-cleanup@SAIL.STANFORD.EDUcc: Hornig@ALDERAAN.SCRC.Symbolics.COMIn-Reply-To: <880114-194617-4828@Xerox>Message-ID: <19880203034640.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 14 Jan 88 19:45 PST    From: Masinter.pa@Xerox.COM    In order for this proposal to go out in the mailing to X3J13 committee members,    we will need a version of the proposal that reflects, either in the cost/benefit    analysis, or in the discussion, the topics mentioned in the mail so far. In the hope of helping out, I re-read the mail on the topic.  Thesuggested changes were:-- use a less judgemental term than `normal'.  Suggestions were `bound'and `binding-related'.  `Bound' doesn't have quite the right connotations,but I prefer it over `normal'.-- change the scope of `free' declarations to be something different fromwhat CLtL p.155 defines to be the scope of `pervasive' declarations.  Therewas no coherent proposal, instead the discussion was diverted by a varietyof red herrings.-- extend Common Lisp to allow TYPE declarations to be used `free'.The proposal already mentions that X3J13 is discussing this.  It's acomplex issue, and is concerned with semantics rather than with scoping,so I believe it should be handled independently.-- extend Common Lisp to allow IGNORE declarations to be used `free'.However, no meaningful interpretation of this was proposed.-- include a table of all existing declarations, showing whether they are`normal' or `free'.    If you want to separate out the issues of type declarations into a separate    proposal, then this proposal is misnamed, it probably should be    DECLARE-SPECIAL-SCOPE and you need another one that is DECLARE-TYPE-SCOPE. Free type declarations are not a scoping issue.    Personally, I think we are close enough to attempt a comprehensive set of rules    for DECLARATION-SCOPE and that you should go for it; there's not that much time.Here is a revision that addresses the only two suggested changes abovewhere it was actually possible to take any action.  I'd like to see thissent out, since I think this issue is important.  I didn't check with Hornigbefore rewriting his proposal, so I hope I have not done any damage to it.Issue:         DECLARATION-SCOPEReferences:    Section 9.1 (pp. 153-157).	       Cleanup issue FLET-DECLARATIONS.Category:      CHANGEEdit history:  V1: Hornig@Symbolics.COM -- 5 January 1988	       Version 2, Moon, 2-Feb-1988 (edits based on discussion)Problem description:The description of the scope of declarations made with DECLARE is bothunclear (although unambiguous) and arguably a mistake.  The issue iswhether the scope of some or all of the declarations includes codeappearing in the non-body part of the special form containing thedeclaration.Proposal DECLARATION-SCOPING:LIKE-VARIABLE:For the purposes of this proposal, we divide all declarations introducedwith DECLARE into two classes.  When a declaration of a variable appearsbefore the body of a special form or lambda-expression that binds thatvariable, the declaration is called `bound'.  All other declarationsare called `free'.  This division replaces the division into pervasive,nonpervasive, and SPECIAL declarations appearing in CLtL.The scope of a `bound' declaration is exactly the scope of theassociated lexical variable or function.  If the declaration isassociated with a special variable, the scope is the scope the variablewould have had if it had not been special.`Free' declarations are scoped as if they appeared in a new LOCALLY formwhich surrounded the entire special form at the beginning of whose bodythe declaration appears.  This is the same as what CLtL p.155 defines tobe the scope of `pervasive' declarations.The following is a complete listing of the types of declarations andtheir class (`bound' or `free'):SPECIAL declarations may be either `bound', affecting both a binding andreferences, or `free', affecting only references, depending on whetherthe declaration is attached to a variable binding, as described above.TYPE declarations may only be `bound' (see next section).FTYPE and FUNCTION declarations may only be `free' (see next section).INLINE declarations may only be `free' (see next section).NOTINLINE declarations may only be `free' (see next section).IGNORE declarations may only be `bound'.OPTIMIZE declarations may only be `free'.The `free' or `bound' scoping of implementation-dependent declarationspecifiers is implementation-dependent.Interactions with other proposals:There has been some discussion in X3J13 of permitting `free' TYPEdeclarations.  This is a semantic issue, not a scoping issue, and shouldbe treated independently.If Common Lisp is extended to permit declarations in FLET and LABELSforms, by acceptance of cleanup proposal FLET-DECLARATIONS:ALLOW,then declarations of functions (FTYPE, FUNCTION, INLINE, andNOTINLINE) which appear before the body of a FLET or LABELS form whichdefines that function are `bound'.  Such declarations in other contextsremain `free'.Common Lisp is ambiguous about whether a variable may be bound severaltimes by a single form.  It has been proposed that multiple bindings bepermitted for LET*, DO*, PROG* forms and for &AUX variables in lambdaexpressions.  If multiple bindings are permitted, `bound' declarationsare treated as if there were a separate `bound' declaration for each ofthe bindings.Examples:;;; Some examples of `free' and `bound' declarations.(let ((a 1))  (declare (optimize speed))		;this is a `free' declaration  (let ((b 2))    (declare (type integer b))		;this is a `bound' declaration    (declare (special a))		;this is a `free' declaration    ()));;; This example applies if you believe that FLET may have declarations.(flet ((foo (x) (1+ x)))  (declare (notinline foo))		;this is a `bound' declaration  (declare (notinline 1+))		;this is a `free' declaration  ());;; The following code is from Pavel.;;; It produces 7 in existing implementations.;;; If the proposal is adopted, it will produce 8.(let ((foo 6))			;a special binding of FOO  (declare (special foo))	;`bound' declaration  (let ((foo 7))		;a lexical binding of FOO    (let ((foo (1+ foo)))	;is the second FOO special or not?      (declare (special foo))	;`bound' declaration      foo)));;; Treatment of LET* under the proposal if multiple bindings of the same name are allowed.;;; This form produces the value 9.(let ((foo 6))			;a special binding of FOO  (declare (special foo))	;`bound' declaration  (let ((foo 7))		;a lexical binding of FOO    (let* ((foo (1+ foo))	;special binding, lexical reference           (foo (1+ foo)))	;special binding, special reference      (declare (special foo))	;`bound' declaration, applies to both bindings       foo))		        ;special referenceRationale:`Bound' declarations are made to control a particular binding of avariable and should be scoped the same way as that binding.  This is astrue of `bound' declarations which were pervasive under the old rulesas it is of those that were not.Current practice:The `bound'/`free' division based on context replaces CLtL's staticpervasive/nonpervasive/SPECIAL division.  Most implementations implementthe rules in CLtL.  Symbolics currently implements rules based onZetalisp which are different from both this proposal and Common Lisp.Symbolics plans to change to Common Lisp rules in the future.Cost to Implementors:The cost of implementing this change should be moderate.  The changewill be localized to a handful of places in the compiler and interpreterwhich apply declarations to variables.  The other cost would be inproviding tools for users to find programs whose meaning will change.Cost to Users:The proposal changes only the treatment of `bound' declarations.  Thischange will break very few existing production programs.It is possible to mechanically examine a program to determine whetherits behavior would change under the new rules.  This permits animplementation to provide a transition tool to ease conversion to thenew definition.Cost of non-adoption:The ability of a `bound' declaration to affect code outside the scopeof the variable which it appears to declare has led to endless confusionand discussion at Symbolics, on the Common-Lisp mailing list, andelsewhere.  It will continue to do so unless it is smoothed over somehow.Benefits:The costs of non-adoption will be avoided.Aesthetics:The distinction between `bound' and `free' declarations introduced bythis proposal is a natural one.Discussion:A proposal to forbid `free' declarations except in LOCALLY forms and aproposal to have `free' declarations affect only the body were discardedas being too incompatible.The mapping from the existing pervasive/nonpervasive/SPECIAL division ofdeclarations and the one proposed here is complex.  In general,nonpervasive declarations are `bound' and pervasive declarations are`free'.  SPECIAL declarations are either `bound' or `free' based ontheir context, and are no longer treated as a special case.Some historical support for having `free' and `bound' declarations:Date: Tue, 20 Dec 83 15:50 ESTFrom: "David A. Moon" <Moon%SCRC-TENEX@MIT-MC.ARPA>Subject: DeclarationsTo: Common-Lisp@SU-AI.ARPA...There are two disjoint classes of declaration: those that are attachedto a particular variable binding, and those that are not.  Note that Iam not discussing proclamations here; they have their own scoping ruleswhich are different from the rules for declarations.The scoping rule for the first kind of declaration is that it applies toprecisely the text that is in the lexical scope of the variable bindingwith which it is associated.  Such declarations are shadowed by avariable binding for the same name inside their scope.  Since thelexical scoping rules are very well and precisely defined, we alreadyunderstand everything about this kind of declaration.The scoping rule for the second kind of declaration is that it ispervasive.  The declaration is attached to a lambda-expression or to aform (one of the special forms listed on page 125).  The declarationapplies to all text inside that expression or form; there are no specialcases such as init-forms of LET or DO.  Such declarations are shadowedby a conflicting declaration inside their scope.Possible names for the two kinds of declaration are "lexical" and"pervasive" or "variable" and "non-variable."...*start*04773 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 FEB 88 19:48:16 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 3 Feb 88  19:45:24 PSTReceived: by labrea.Stanford.EDU; Wed, 3 Feb 88 19:45:35 PSTReceived: from bhopal.lucid.com by edsel id AA04962g; Wed, 3 Feb 88 19:35:03 PSTReceived: by bhopal id AA12851g; Wed, 3 Feb 88 19:39:14 PSTDate: Wed, 3 Feb 88 19:39:14 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8802040339.AA12851@bhopal.lucid.com>To: labrea!Moon%STONY-BROOK.SCRC.Symbolics.COM@labrea.Stanford.EDUCc: labrea!cl-cleanup%SAIL@labrea.Stanford.EDU, labrea!Hornig%ALDERAAN.SCRC.Symbolics.COM@labrea.Stanford.EDUIn-Reply-To: David A. Moon's message of Tue, 2 Feb 88 22:46 EST <19880203034640.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPE (Version 2)I'm not a little dismayed at the verbosity of this proposal.  Does thefollowing 3-sentence summary encompass most of the statement of problem:  (1) Some declarations only affect how a particular instance of a binding      is interpreted.  [these are called 'bound' in the terminology of      the proposal].  (2) Some don't.  [i.e, they affect something else other than some      property of a particular instance of a binding.]  (3) Except for SPECIAL,  no declaration in category (1) is permitted      to have any other interpretation.[Thus (3) prevents the following "natural" extension of declare IGNORE:   (locally      ...     (let ((x <computation>))       (declare (ignore x))       <body-without-x>)     ...) <==>    (locally (declare (ignore x))      ...     (let ((x <computation>))       <body-without-x>)     ...)]The proposal, then, is presumably to clarify that  (4) The scope of a `bound' declaration is exactly the scope of the      associated [lexical] variable or function.  [Since only SPECIAL is permitted to have both 'free' and 'bound' meanings,then (4) really only applies to it,  for otherwise, the scope of a 'bound'declaration is simply the one binding it is attached to.]A primary consequence of this is that      (let ((x <computation>))       (declare (special x))       <body>)is not equivalent to     (locally (declare (special x))       (let ((x <computation>))	 <body>))nor is it equivalent to      (locally (declare (special x))       (let ((x <computation>))	 (declare (special x))	 <body>))because the LOCALLY form would be permitted to affect the references in<computation> and the scope of the variable 'x' does not include theform <computation>.  On the other hand, because the following SPECIAL declaration is notlinked to the binding(s) occuring in the surrounding LET, then     (let ((x <computation>))       (declare (special y))       <body>)is equivalent to     (locally (declare (special y))       (let ((x <computation>))	 <body>))in which case the declaration *does* affect the (free) references to'y' found in <computation>.Is this indeed the intended effect?  If so, is this the answer to thequestions about how to gag the compiler messages about "free" variablesappearing in &optional (etc) init forms of defuns?Now, I think (3) above has some nasty consequences; in particular theinability to give local type declarations over a lexical interval.MacLisp wasn't scoped like this.  I vaguely remember discussion a longtime ago that the reason why Common Lisp variable declarations aren'tscoped like this is because of the inadvertent capturing of lexically-apparent declarations by macroexpanded code.  [Indeed, some implementationsof DEFSUBST still have the bug that they have macro-expansion semanticsrather than function-call semantics.]  It would be a shame if the declarational scheme had to be castrated simply because no one could figure out a better solution to the captured lexical environment problem.  I really don't see that having one construct --ordinary macros -- that can lose referential transparency is so bad; wecertainly need a "safe" version thereof, like DEFSUBST should be; butthis hardly seems the time to grossly revise the semantics of macroexpansion, which  have other problems with lack of transparency.  [Someonemay point out that the phrase "Kohlbecker's Thesis" ought to be invokedhere.]If the macro-induced lack of "referential transparency" isn't a factorat all in CL's prohibition against allowing "pervasive" declarations toaffect bindings found in enclosed forms, then I apologies for the abovetwo-paragraph excursion.  But I still would like to see a more succinct3-or-4-sentence summary of this proposal's problem description.-- JonL --*start*07509 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 FEB 88 20:25:27 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 3 Feb 88  20:22:51 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 335527; Wed 3-Feb-88 23:22:25 ESTDate: Wed, 3 Feb 88 23:22 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPE (Version 2)To: Jon L White <edsel!jonl@labrea.Stanford.EDU>cc: cl-cleanup@SAIL.STANFORD.EDU, Hornig@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <8802040339.AA12851@bhopal.lucid.com>Message-ID: <19880204042224.7.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Wed, 3 Feb 88 19:39:14 PST    From: Jon L White <edsel!jonl@labrea.Stanford.EDU>    I'm not a little dismayed at the verbosity of this proposal.  Hornig can correct me, but I believe that was in response to requestsfor clarity and specificity.								  Does the    following 3-sentence summary encompass most of the statement of problem:      (1) Some declarations only affect how a particular instance of a binding	  is interpreted.  [these are called 'bound' in the terminology of	  the proposal].      (2) Some don't.  [i.e, they affect something else other than some	  property of a particular instance of a binding.]Sorry, but I can't figure out what precisely the above two sentences mean.      (3) Except for SPECIAL,  no declaration in category (1) is permitted	  to have any other interpretation.There appear to be several types of declarations that can be either freeor bound, depending on whether they appear attached to a binding of thevariable or function that they declare, or appear someplace else.  Themajor error in the existing declaration scoping, I feel, was the ideathat pervasive or non-pervasive could be a property of a declarationspecifier, independent of context.    [Thus (3) prevents the following "natural" extension of declare IGNORE:       (locally 	 ...	 (let ((x <computation>))	   (declare (ignore x))	   <body-without-x>)	 ...)     <==>        (locally (declare (ignore x)) 	 ...	 (let ((x <computation>))	   <body-without-x>)	 ...)    ]I can't figure out what you intend this supposedly natural extension tomean.  The ignore declaration would apply to all references to x insideits scope, except for references shadowed by an inner binding of thename x.  But this is nonsense!  The ignore declaration applies to theabsence of references; the only way it applies to references is theminor feature that CLtL suggests the compiler ought to warn if youdeclare a variable to be ignored and then reference it.    The proposal, then, is presumably to clarify that      (4) The scope of a `bound' declaration is exactly the scope of the	  associated [lexical] variable or function.      [Since only SPECIAL is permitted to have both 'free' and 'bound' meanings,    then (4) really only applies to it,  for otherwise, the scope of a 'bound'    declaration is simply the one binding it is attached to.]It's not true that special is the only such declaration.    A primary consequence of this is that 	 (let ((x <computation>))	   (declare (special x))	   <body>)    is not equivalent to	 (locally (declare (special x))	   (let ((x <computation>))	     <body>))    nor is it equivalent to 	 (locally (declare (special x))	   (let ((x <computation>))	     (declare (special x))	     <body>))    because the LOCALLY form would be permitted to affect the references in    <computation> and the scope of the variable 'x' does not include the    form <computation>.  The above is true unless I have misunderstood what you're saying.    On the other hand, because the following SPECIAL declaration is not    linked to the binding(s) occuring in the surrounding LET, then	 (let ((x <computation>))	   (declare (special y))	   <body>)    is equivalent to	 (locally (declare (special y))	   (let ((x <computation>))	     <body>))    in which case the declaration *does* affect the (free) references to    'y' found in <computation>.That's correct too, I believe.  It's also the same as in CLtL.    Is this indeed the intended effect?  If so, is this the answer to the    questions about how to gag the compiler messages about "free" variables    appearing in &optional (etc) init forms of defuns?I can't figure out what that question has to do with any of this.  Perhapsthose questions were on some mailing list that I am happily not a member of?    Now, I think (3) above has some nasty consequences; in particular the    inability to give local type declarations over a lexical interval.    MacLisp wasn't scoped like this.  I vaguely remember discussion a long    time ago that the reason why Common Lisp variable declarations aren't    scoped like this is because of the inadvertent capturing of lexically-    apparent declarations by macroexpanded code.  [Indeed, some implementations    of DEFSUBST still have the bug that they have macro-expansion semantics    rather than function-call semantics.]      It would be a shame if the declarational scheme had to be castrated simply     because no one could figure out a better solution to the captured lexical     environment problem.  I really don't see that having one construct --    ordinary macros -- that can lose referential transparency is so bad; we    certainly need a "safe" version thereof, like DEFSUBST should be; but    this hardly seems the time to grossly revise the semantics of macro    expansion, which  have other problems with lack of transparency.  [Someone    may point out that the phrase "Kohlbecker's Thesis" ought to be invoked    here.]    If the macro-induced lack of "referential transparency" isn't a factor    at all in CL's prohibition against allowing "pervasive" declarations to    affect bindings found in enclosed forms, then I apologies for the above    two-paragraph excursion.I can't figure out what any of this means.  Perhaps you're still going onabout the fact that Hornig refuses to include in his DECLARATION-SCOPE proposalthe unrelated proposal to change what CLtL says about TYPE, namely thatit affects only variable bindings (not references)?  I'm on Hornig's sidethere; it's not a good idea to bundle unrelated proposals together.  If youwant to change the rules for TYPE, and by the way I agree with you thatthey should be changed, just write a CL-Cleanup proposal to do so and letit stand on its own merits.  It's completely and totally independent ofHornig's proposal.  It can go into the language with exactly the samesemantics regardless of whether Hornig's proposal is approved or rejected.The only difference would be whether the description of a TYPE declarationthat is not attached to a binding uses the word "free" or uses the word"pervasive".    But I still would like to see a more succinct    3-or-4-sentence summary of this proposal's problem description.It seems clear that my attempt to revise the proposal to make it clearer,in response to the mail discussion, didn't work.  I'm willing to spendsome more time helping with this proposal, but since I don't really understandwhat's unclear about it to you, I don't see what to change.  Perhaps youcould tell me what questions it doesn't answer.*start*01241 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 03 FEB 88 07:53:46 PSTReceived: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by SAIL.Stanford.EDU with TCP; 3 Feb 88  07:50:47 PSTReceived: from WINTER.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 165444; Wed 3-Feb-88 09:13:15 ESTDate: Wed, 3 Feb 88 09:13 ESTFrom: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPE (Version 2)To: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>, cl-cleanup@SAIL.STANFORD.EDUIn-Reply-To: <19880203034640.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19880203141314.4.HORNIG@WINTER.SCRC.Symbolics.COM>    Date: Tue, 2 Feb 88 22:46 EST    From: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>    ...    Here is a revision that addresses the only two suggested changes above    where it was actually possible to take any action.  I'd like to see this    sent out, since I think this issue is important.  I didn't check with Hornig    before rewriting his proposal, so I hope I have not done any damage to it.I am happy with Moon's revisions....*start*07179 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 04 FEB 88 15:32:05 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 4 Feb 88  15:29:09 PSTReceived: by labrea.Stanford.EDU; Thu, 4 Feb 88 15:29:25 PSTReceived: from bhopal.lucid.com by edsel id AA08824g; Thu, 4 Feb 88 14:13:28 PSTReceived: by bhopal id AA00979g; Thu, 4 Feb 88 14:17:52 PSTDate: Thu, 4 Feb 88 14:17:52 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8802042217.AA00979@bhopal.lucid.com>To: labrea!Moon%STONY-BROOK.SCRC.Symbolics.COM@labrea.Stanford.EDUCc: labrea!cl-cleanup%SAIL@labrea.Stanford.EDU, labrea!Hornig%STONY-BROOK.SCRC.Symbolics.COM@labrea.Stanford.EDUIn-Reply-To: David A. Moon's message of Wed, 3 Feb 88 23:22 EST <19880204042224.7.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPE (Version 2)re: It seems clear that my attempt to revise the proposal to make it clearer,    in response to the mail discussion, didn't work. ... I don't really     understand what's unclear about it to you, I don't see what to change.      Perhaps you could tell me what questions it doesn't answer.Here's one, taken from our interchange:  {JonL}      [Since only SPECIAL is permitted to have both 'free' and 'bound' meanings      then (4) really only applies to it,  for otherwise, the scope of a 'bound      declaration is simply the one binding it is attached to.]  {Moon}    It's not true that special is the only such declaration.I didn't fully believe that either, but taking the words from yourrewriting of the proposal:    The following is a complete listing of the types of declarations and    their class (`bound' or `free'):    SPECIAL declarations may be either `bound', affecting both a binding and    references, or `free', affecting only references, depending on whether    the declaration is attached to a variable binding, as described above.    TYPE declarations may only be `bound' (see next section).    FTYPE and FUNCTION declarations may only be `free' (see next section).    INLINE declarations may only be `free' (see next section).    NOTINLINE declarations may only be `free' (see next section).    IGNORE declarations may only be `bound'.    OPTIMIZE declarations may only be `free'.All except SPECIAL are restricted to one kind or the other, and this isalleged to be a complete list.Now, I would prefer to see SPECIAL, NOT/INLINE, and TYPE declarations allhave the same scoping rules.  For example, if the "cleanup" proposal forNOT/INLINE declarations on lexical functions were accepted, then a form like:    (locally (declare (notinline car))			[1]      (flet ((car (z)					[2]               (list (cdr z) (car z))))			[3]	(declare (inline car))				[4]	. . . 	(print (car x))))				[5]wouldn't be ambiguous, as it apprently now is.  If NOTINLINE were scoped like this proposal for SPECIAL, then it would be clear that the declaration on line [4] applies only to the "car" defined on line [2], and that the usage of "car" on line [3] isn't affected by it {see how nice and parallel that is to the SPECIAL rules}; on the other hand, the usage on line [3] is affected by the 'free' declaration on line [1].  I hope that this is your preference too.One of the problems I had in reading the proposal was figuring out what you meant by "'bound' declaration".  I realize that this isn't a specific question that you can "answer", but it was a concern.  Apparently, in return, you couldn't figure out my question as to its meaning.  I had asked if it was like:      (1) Some declarations only affect how a particular instance of a binding	  is interpreted.  [these are called 'bound' in the terminology of	  the proposal].If I may try again, let me point to the declare on line [4] above.  It applies to the *particular* instance of the binding of the name "car" on line [2], does it not?  It says "interpret this function as an inlineversion of something named car".  It doesn't separately apply to the usage on line [5], because [5] is a reference to the lexical name established by [2] and its properties are completely determined by that binding on line [2].  Furthermore, unlike MacLisp's scoping rules, the declare on line [4] would have no effect on any inner re-bindings (by FLET) of "car" such as might occur in the part elided ". . .".  That's why I say "aparticular instance of a binding".If this still isn't clear to you, and if no one else is particularlyconcerned about it, then maybe we could take any further comments "off-line".You have also expressed confusion as to what the non-standard code   (locally (declare (ignore x))     (let ((x 3))       (mumble)))could possibly mean.  I thought I stated it by giving an equivalent instandard code.  That is, unlike existing practice, but *like* MacLisp, I could imagine it to mean the same as:     (let ((x 3))       (declare (ignore x))       (mumble))It shouldn't be too hard to believe that such a translation can be donefully mechanically.  Since this kind of declaration inheritance wasthe norm in MacLisp, and since you used MacLisp for years, I didn't realize you'd have trouble remembering it [the "norm", in particularfor SPECIAL and TYPE declarations].I know only too well that such a interpretation of 'pervasive', or 'free',declarations conflicts with meaning given for them by CLtL -- that any inner binding of a name is completely shielded from any outer, lexical declarations.  This is one of the two parts that differ substantially from MacLisp -- the other being that a declare before the body of a special form is not generally equivalent to the same declare wrapped LOCALLY around the form.  But since PROCLAMations stick with the name, and are not walled-out by ordinary bindings, then it's not too hard to imagine some 'free' declarations operating this way.  [One might use the term "shadowed" rather than "walled-out", but I dislike it since there is another technical meaningfor "shadow"; also, the allegedly shadowing binding isn't by itself providing an alternate "shadowing" declaration.]I perceive the current dilemma, which "DECLARATION-SCOPE" proposesto alleviate in some small way, as stemming from Common Lisp's partialattempt to cure the problem of captured lexical declarations during macro expansion.  That's all I intended to say in the two-paragraph essay near the end of my msg.  Consequently, I'm totally amazed at your reply to it:    . . . Perhaps you're still going on about the     fact that Hornig refuses to include in his DECLARATION-SCOPE  proposal     the unrelated proposal to change what CLtL says about TYPE, . . . especially since I publicly lauded this proposal when it came out, andhave never expressed dissatisfaction with Hornig's handling of it.  I remember remarking on the similarity of the two issues -- they are *not*totally unrelated -- but that has nothing at all to do with the conjecture about "macroexpansions capturing lexical declarations".-- JonL --*start*00727 00024 US Date:  4 Feb 88 17:34 PSTFrom: Masinter.paSubject: Re: Issue: DECLARATION-SCOPE (Version 2)In-reply-to: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>'s message of Wed, 3 Feb 88 09:13 ESTTo: Hornig@ALDERAAN.SCRC.Symbolics.COM, Moon@STONY-BROOK.SCRC.Symbolics.COM, edsel!jonl@labrea.Stanford.EDUcc: MasinterMuch as I would like to have this issue ready for voting by the March meeting, it doesn't look like it is ready. DECLARATION-SCOPE seems like a good candidate to discuss at that meeting, however. I encourage you  to try to reach some agreement about the issue wording within the next week or so; it would be useful to at least send it via electronic mail prior to the March meeting.*start*02613 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 FEB 88 10:59:56 PSTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 8 Feb 88  10:58:21 PSTReceived: from RIO-DE-JANEIRO.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 338755; Mon 8-Feb-88 13:58:07 ESTDate: Mon, 8 Feb 88 13:57 ESTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPE (Version 2)To: Moon@STONY-BROOK.SCRC.Symbolics.COMcc: CL-Cleanup@SAIL.STANFORD.EDU, KMP@STONY-BROOK.SCRC.Symbolics.COM, Hornig@ALDERAAN.SCRC.Symbolics.COMIn-Reply-To: <19880203034640.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <880208135758.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>I support DECLARATION-SCOPE:LIKE-VARIABLE, but I have some relatedissues I'd like to ask about while we're on the topic. I wonder aboutthe following cases. Do we believe that they all follow clearly from theindicated rules (and/or other known and agreed upon rules)?(DEFUN FOO-1 (X)  (DECLARE (INLINE FOO-1))  (+ X 1))(DEFUN BAR-1 (X) (FOO-1 X))Can FOO-1 be inlined in BAR-1? I say no because of modularity and incremental debugging constraints. I think there are implementationswhich do this inlining. I would like to see this and other situationstreated explicitly.(DEFUN BAR-2 (X)  (FLET ((FOO-2 (X)	   (DECLARE (INLINE FOO-2))	   (+ X 1)))    (FOO-2 X)))Can FOO-2 be inlined in BAR-2? I say it's not totally unreasonableand I wouldn't be surprised if some implementations have resorted tothis as a way for users to say that FOO-2 is inline since they cannotput the information at the top of the FLET body. I found the wordingof this proposal to be a little vague on whether this INLINEdeclaration spans the whole FLET, but my final impression was thatit does. Is this right? Can we get this into the spec?Other examples I'd like to see made explicit:(DEFUN FOO-3 (X)  (DECLARE (FUNCTION FOO-3 (FIXNUM) FIXNUM))  (+ X 1))(DEFUN BAR-3 (X)  (THE FIXNUM (+ (FOO-3 X) 1)))Can I use fixnum arithmetic in FOO-3? (I say yes.)Can I use fixnum arithmetic in BAR-3? (I say no, to avoidproblems if one function is changed while the other is not.)(LABELS ((FOO-4 (X)	   (DECLARE (FUNCTION FOO-4 (FIXNUM) FIXNUM))	   (+ X 1))	 (BAR-4 (X)	   (THE FIXNUM (+ (FOO-4 X) 1))))  (FLET ((BAZ-4 (X) (THE FIXNUM (+ (FOO-4 X) 1))))    ...))Can I use fixnum arithmetic in FOO-4? in BAR-4? In BAZ-4?I hope yes to all.*start*06316 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 FEB 88 02:04:32 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 10 Feb 88  02:02:58 PSTReceived: by labrea.Stanford.EDU; Wed, 10 Feb 88 02:02:57 PSTReceived: from bhopal.lucid.com by edsel id AA05180g; Wed, 10 Feb 88 01:45:42 PSTReceived: by bhopal id AA05095g; Wed, 10 Feb 88 01:50:27 PSTDate: Wed, 10 Feb 88 01:50:27 PSTFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>Message-Id: <8802100950.AA05095@bhopal.lucid.com>To: labrea!KMP%STONY-BROOK.SCRC.Symbolics.COM@labrea.Stanford.EDUCc: labrea!CL-Cleanup%SAIL@labrea.Stanford.EDU, labrea!Hornig%ALDERAAN.SCRC.Symbolics.COM.labrea!moon%STONY-BROOK.SCRC.Symbolics.COM@labrea.Stanford.EDUIn-Reply-To: Kent M Pitman's message of Mon, 8 Feb 88 13:57 EST <880208135758.6.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPE You are asking a broader set of questions that Horning apparently didn't want to address in his original cleanup proposal.  There are a plethora of issues related to this -- the whole semantics of declarations in Common Lisp seems to be in disarray now.I think these broader issues must be raised, and that is one reason why what started out as a very small clarification has grown into a much larger controversy.  Perhaps it was premature to think we could take the dragon by the tail and not feel his hot breath too.  I would actuallylike to see a *coordinated* set of cleanup issues on declarations."Coordinated", because it often doesn't make sense to talk about theseissues in isolation; witness the extremely close link of this scopingproposal with the FLET-DECLARATIONS:ALLOW proposal.If this proposal -- DECLARATION-SCOPE:LIKE-VARIABLE is to be seriouslyconsidered in isolation, the I would at least like to suggest an alterationas outlined below.  First, a very brief overview of the proposal:Hornig's purpose stated in the original message of "Tue, 5 Jan 88 08:21 EST" was:    . . .  The issue is    whether the scope of some or all of the declarations includes code    appearing in the non-body part of the special form containing the    declaration.    . . .     `Normal' declarations are made to control a particular binding of a    variable and should be scoped the same way as that binding.  This is as    true of `normal' declarations which were pervasive under the old rules    as it is of those that were not.So the original DECLARATION-SCOPE proposal would seem to be addressingthe specific kinds of problem illustrated by this example:    (setf (symbol-value 'x) 0)    (trace car)    (defun foo (x y)      (let ((x (car y))	    (car (+ 4 x)))	(declare (special x) (inline car +))        (list car (car x))))A reasonable test, after compiling [and hypothetically assuming that a callto CAR that isn't declared "inline" will go out-of-line] works like:    (foo 4 '((hello))) 	==>   {fn: CAR, arglist: ( ((hello)) )}	;trace output			      (8 hello)namely, that unlike in some implementations, the special declarationdoes not apply to the form "(+ 4 x)", and further, the inline declarationapplies to "(car x)" but not to "(car y)".But still a lot of issues are left open.  [One of them, for example, is how to say that the inline declaration of "car" above doesn't apply to the binding of the variable "car" established in the special form in which the declaration occurs 'normally'.  It seems obvious to a reader with intuition; it's not so obvious from reading all the legalese andgeneralizations of a formal prescription.]I call attention again to Hornig's guiding principle:    `Normal' declarations are made to control a particular binding of a    variable and should be scoped the same way as that binding. I think it would be a great simplification that declares in a bindingspecial form (like, LET, PROG, LABELS, etc) should either "controla particular binding" and thus by definition have the scope of that binding [and nothing more], or be scoped as follows.  For those declarations that in a binding special form that don't correlate with any of the bindings being established -- like the inline declaration for "+" in the example above -- their scope should be the same as if there had been a "variable" in the binding list for it to "control".That is, rather than      (let ((z (+ 4 x)))	(declare (special z) (inline +))        (+ z 5))being equivalent to      (locally (declare (inline +))        (let ((z (+ 4 x)))	  (declare (special z))          (+ z 5)))I think it would be more consistent for it to be equivalent to:      (let ((z (+ 4 x)))	(declare (special z))	(locally (declare (inline +))          (+ z 5)))I could submit a proposal called DECLARATION-SCOPE:FULLY-LEXICAL to specifythis.  But as I said before, I think there are a whole plethora of issuesthat ought to be considered together, so some attention needs to be paidto all the related issues.This FULLY-LEXICAL approach would help certify one of your feelings; youposed the example    (DEFUN FOO-1 (X)      (DECLARE (INLINE FOO-1))      (+ X 1))    (DEFUN BAR-1 (X) (FOO-1 X))and suggeted that the inline declaration should not apply to the "reference"to FOO-1 in function BAR-1.  Easily handled by the "lexical" approach.However, I would even question the appropriateness a form like    (DEFUN FOO-3 (X)      (DECLARE (FUNCTION FOO-3 (FIXNUM) FIXNUM))      (+ X 1))The kind of binding being in this special form is a LAMBDA binding -- a "variable" binding, not a "function" binding -- so the ftype declaration on FOO-3 certainly doesn't apply to X.  Hence it ought not to act like a global proclaim.  Indeed, PROCLAIM exists precisely to cover the case of setting a global function cell; and this isn't the same kind of binding that occurs in, say, FLET, or LABELS.  To achieve the effect you aresupposing, you might have to say:    (locally (declare (function foo-3 (fixnum) fixnum))      (defun foo-3 (x)        (+ x 1)))or possibly    (defun foo-3 (X)      (flet ((foo-3 (x)                (+ x 1)))       (declare (function foo-3 (fixnum) fixnum))      (foo-3 x)))-- JonL --      *start*04853 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 10 FEB 88 10:09:49 PSTReceived: from C.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 10 Feb 88  10:07:39 PSTReceived: ID <RAM@C.CS.CMU.EDU.#Internet>; Wed 10 Feb 88 13:08:48-ESTDate: Wed, 10 Feb 88 13:08 ESTMessage-ID: <RAM.12373657131.BABYL@>Sender: RAM@From: Ram@C.CS.CMU.EDUTo: cl-cleanup@SAIL.STANFORD.EDUSubject: Issue: DECLARATION-SCOPE (Version 2)In-reply-to: Msg of 8 Feb 1988  13:57-EST from Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>    Date: Monday, 8 February 1988  13:57-EST    From: Kent M Pitman <KMP at STONY-BROOK.SCRC.Symbolics.COM>    To:   Moon at STONY-BROOK.SCRC.Symbolics.COM    Re:   Issue: DECLARATION-SCOPE (Version 2)    [...] I wonder about the following cases.I don't understand the unclarity that you seem to perceive in therules for scoping.  We may not agree on what the lexical scope forDECLARE should be, but I think we all agree that it is lexical.  ADECLARE at the head of a DEFUN (or lambda, or let, or anything else)shouldn't affect anything outside of the body.  The onlypseudo-exception is macros, which are known to violate referentialtransparency.    (DEFUN FOO-1 (X)      (DECLARE (INLINE FOO-1))      (+ X 1))    (DEFUN BAR-1 (X) (FOO-1 X))    Can FOO-1 be inlined in BAR-1?No, because the call to FOO-1 isn't within the scope of thedeclaration.    [...]  I think there are implementations which do this inlining. I    would like to see this and other situations treated explicitly.I agree, and in my compiler cleanup proposal I have treated theconcept of compile-time function binding (which inlining is a specialcase of) at some length.    (DEFUN BAR-2 (X)      (FLET ((FOO-2 (X)    	   (DECLARE (INLINE FOO-2))    	   (+ X 1)))        (FOO-2 X)))    Can FOO-2 be inlined in BAR-2? I say it's not totally unreasonable    and I wouldn't be surprised if some implementations have resorted to    this [...]  Is this right? Can we get this into the spec?Yes, but not for the reason you say.  A lexical function can be calledhowever the compiler bloody well wants to, since there is no way thatthe user can ever redefine it.  If the compiler happens to take aspurious declaration as a cue, that's fine, but it could just as welluse the phase of the moon.  But once again, it is clear that theINLINE declaration doesn't affect the function FOO-2 that you aretalking about, it is allowing inline expansion of some other FOO-2(presumably global) within the body of the lexical FOO-2.    [...]    (DEFUN FOO-3 (X)      (DECLARE (FUNCTION FOO-3 (FIXNUM) FIXNUM))      (+ X 1))    Can I use fixnum arithmetic in FOO-3? (I say yes.)I don't think so, although this rides on a combination ofinterpretations of sticky points: function types in general, andpervasive function type declarations in particular.First of all, function type semantics require that the compiler provethat the argument is a fixnum before it can assume that the result isa fixnum.  This means that even a global function type declaration isuseless when compiling the body, since there is no way the compilercan convince itself it has seen all possible calls.Secondly, the interpretation of the pervasive function typedeclarations is really unclear, especially in the absence of any callswithin the scope.  It seems that what you are saying is that withinthis scope (but perhaps not elsewhere), FOO-3 will return a fixnumwhen given a fixnum.  If the compiler could prove that a declarationthat is true in this scope would be true in any scope (hereplausible), then this type declaration could perhaps be applied toother calls, but only when the compiler could be sure that the sameFOO-3 was being referred to, which is difficult given the lack of ageneral mechanism for allowing compile-time resolution of globalfunction names.  But the fact that there is no call to FOO-3 withinthe scope leads one to wonder whether any random declaration might bevacuously true.As I have said before, I think that the concept of function type inCommon Lisp (as correctly interpreted) is fairly useless.  In mycompiler cleanup proposal, I handle compile-time function typing as aspecial case of compile-time function binding.If you have a proclamation that says all gloabal references to afunction are to a version that has been processed by the compiler,then the compiler can propagate the types declared for the formalparameter variables to the actual calls.  The compiler is free to usewhatever type-inference method it pleases to determine the resulttype.The other examples you gave seem to refelect a similarly perplexinginterpretation of pervasive function type declartions.  Rob*start*01043 00024 US Return-Path: <Hornig@ALDERAAN.SCRC.Symbolics.COM>Received: from ALDERAAN.SCRC.Symbolics.COM ([128.81.41.109]) by Xerox.COM ; 16 FEB 88 07:56:52 PSTReceived: from WINTER.SCRC.Symbolics.COM by ALDERAAN.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 170127; Tue 16-Feb-88 10:55:53 ESTDate: Tue, 16 Feb 88 10:55 ESTFrom: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARATION-SCOPE (Version 2)To: Masinter.pacc: moon@ALDERAAN.SCRC.Symbolics.COMIn-Reply-To: <880213-130244-10324@Xerox>Message-ID: <19880216155550.0.HORNIG@WINTER.SCRC.Symbolics.COM>    Date: 13 Feb 88 13:02 PST    From: Masinter.pa@Xerox.COM    Will you be at the March meeting? No, I will not.    Do you have any response to the subsequent mail on this topic? (e.g., KMP's    message of 8-Feb, JonL and RAM's messages of 10 Feb?)I am trying to have Dave Moon handle the detailed discussion since heknows the people involved better than I do and is more likely tounderstand what they're trying to get at.*start*04655 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by Xerox.COM ; 29 FEB 88 18:17:01 PSTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 353307; Mon 29-Feb-88 20:45:25 ESTDate: Mon, 29 Feb 88 20:45 ESTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Re: Issue: DECLARATION-SCOPE (Version 2)To: Masinter.pacc: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>, Moon@STONY-BROOK.SCRC.Symbolics.COMIn-Reply-To: <19880216155550.0.HORNIG@WINTER.SCRC.Symbolics.COM>Message-ID: <19880301014524.1.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: No    Date: Tue, 16 Feb 88 10:55 EST    From: Charles Hornig <Hornig@ALDERAAN.SCRC.Symbolics.COM>	Date: 13 Feb 88 13:02 PST	From: Masinter.pa@Xerox.COM	Do you have any response to the subsequent mail on this topic? (e.g., KMP's	message of 8-Feb, JonL and RAM's messages of 10 Feb?)    I am trying to have Dave Moon handle the detailed discussion since he    knows the people involved better than I do and is more likely to    understand what they're trying to get at.Unfortunately it usually takes me multiple readings and several hoursof concentrated effort to understand a JonL message.  Often it's worthit, but I don't always have the time to invest.  My impression is thatnone of these comments are relevant to Hornig's proposal.  Remember,this is a very simple and limited proposal.  All it says is that thepresent concept of non-pervasive declaration scope should be replacedwith the concept of a declaration whose scope is identical to thescope of a variable (or function) binding.  It doesn't propose to changethe semantics of any declaration.Okay, I found some time to read those messages yet again.  Here's mysummary of what I think they are saying.  Moon's remarks, rather thanparaphrases, are in brackets.JonL 4 Feb: Misunderstanding of the "conditionalization" of the wordingof the proposal to be independent of whether FLET-DECLARATIONS:ALLOW isaccepted or rejected.  [I don't see how this wording could possiblybe made more explicit than it already is.]  Also some questions aboutthe exact meaning of "instance of a binding."KMP 8 Feb: Do the INLINE and FUNCTION declarations have weird scopingrules different from what anyone has yet proposed?  (Does a declarationwhose scope is the function's body, with the same name as the function,affect references to the function that are outside the scope of thatdeclaration by either Hornig's proposed scoping rule or CLtL's currentscoping rule?)RAM 10 Feb: No, and by the way his compiler cleanup proposal has a moreexplicit definition than CLtL of the semantics of INLINE and FUNCTION.JonL 10 Feb: "witness the extremely close link of this scoping proposalwith the FLET-DECLARATIONS:ALLOW proposal."  [I dispute that.  The onlyconnection is that FLET-DECLARATIONS:ALLOW changes the places wheredeclarations can appear, and hence requires a small wording change inDECLARATION-SCOPE; there is no deep semantic link between these.]JonL 10 Feb: a paraphrase of Hornig's proposal containing many errorsof transcription.  I don't see that this requires a reply.  Maybe itmeans the proposal needs more examples so it is harder to misread?JonL 10 Feb: Proposal to re-adopt one of the alternatives that wasdropped from Hornig's proposal on grounds of incompatibility withcurrent Common Lisp as well as some incoherency in the case of LET*,namely that free declarations are scoped to the body rather than to thewhole form.  JonL doesn't seem to have seen the previous discussion ofthis.  The discussion section of the present proposal briefly mentionsthat this was considered and rejected, either JonL didn't read that far,didn't realize this was the same thing he was proposing, or didn't care,since the discussion section didn't explain why it was rejected.My conclusion from all this is that unless I have missed something inthese messages, the only problems with version 2 of DECLARATION-SCOPEare editorial problems, in that it is possible for a reader to failto understand what the proposal proposes.  Since I've already taken mybest shot at making it clear, I don't see what more can be done.  Wecould send it out as-is; wait until FLET-DECLARATIONS:ALLOW and thefree TYPE declaration proposal (which I don't think has been formallywritten up) are accepted or rejected, then remove the conditionalizationand send it out; or I could ask a professional technical writer to takea look at it and try to clean it up.*start*01224 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 22 Jan 88 19:06Subject: type declarations of special bindingsFrom: gz%spt.entity:COM:XeroxTo: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: common-lisp@sail.stanford.eduSubject: type declarations of special bindingsFrom: gz@spt.entity.com (Gail Zacharias)Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 22 JAN 88 19:06:24 PSTReceived: from EDDIE.MIT.EDU by SAIL.Stanford.EDU with TCP; 22 Jan 88  18:31:21 PSTReceived: by EDDIE.MIT.EDU with UUCP with smail2.5 with sendmail-5.45/4.7 id <AA00256@EDDIE.MIT.EDU>; Fri, 22 Jan 88 21:30:12 ESTReceived: by spt.entity.com (smail2.5); 22 Jan 88 18:12:35 EST (Fri)Message-Id: <8801221812.AA05095@spt.entity.com>Original-Date: 22 Jan 88 18:12:35 EST (Fri)GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVIn the following example, does the fixnum declaration apply to theinner reference to X (in the setq)?	(let ((X 17))	  (declare (special X) (fixnum X))	  (let ((X 'local))	    (locally	      (declare (special X))	      (setq X (foo)))))*start*02068 00024 US Originator: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxDate: 23 Jan 88 01:53From: edsel!jonl%labrea.Stanford:EDU:XeroxIn-Reply-to: Gail Zacharias's message of 22 Jan 88 18:12:35 EST (Fri) <8801221812.AA05095@spt.entity.com>Subject: type declarations of special bindingsTo: gz%spt.entity:COM:Xeroxcc: labrea!common-lisp%sail%labrea.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jon L White <edsel!jonl@labrea.Stanford.EDU>To: gz@spt.entity.comCc: labrea!common-lisp%sail@labrea.Stanford.EDUIn-Reply-To: Gail Zacharias's message of 22 Jan 88 18:12:35 EST (Fri) <8801221812.AA05095@spt.entity.com>Subject: type declarations of special bindingsReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU by Xerox.COM ; 23 JAN 88 01:53:35 PSTReceived: from labrea.Stanford.EDU by SAIL.Stanford.EDU with TCP; 23 Jan 88  01:22:30 PSTReceived: by labrea.Stanford.EDU; Sat, 23 Jan 88 01:22:39 PSTReceived: from bhopal.lucid.com by edsel id AA29772g; Sat, 23 Jan 88 01:14:53 PSTReceived: by bhopal id AA05388g; Sat, 23 Jan 88 01:18:23 PSTOriginal-Date: Sat, 23 Jan 88 01:18:23 PSTMessage-Id: <8801230918.AA05388@bhopal.lucid.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVre: In the following example, does the fixnum declaration apply to the    inner reference to X (in the setq)?      (let ((X 17))	(declare (special X) (fixnum X))	(let ((X 'local))	  (locally	    (declare (special X))	    (setq X (foo)))))CLtL, p 158 says that type declarations affect the binding "and specifiesthat the variable[s] mentioned will take on values only of the specifiedtype".  The inner reference is to the variable bound specially, not tothe one bound locally, so it is the same variable whose binding wasdeclared fixnum.  Hence, in theory, it should be as if the form	(setq X (foo))were written as	(setq X (the fixnum (foo)))but I suspect very few, if any, compilers actually make this leap of type inferencing.-- JonL --*start*09189 00024 UShDate:  8 Jun 88 12:39 PDTFrom: Masinter.paTo: X3J13@Sail.stanford.eduSubject: Issue: DECLARATION-SCOPE (Version 2)cc: Masinterreply-to: cl-cleanup@Sail.stanford.eduThere was significant discussion of this issue in the cleanup committee after Version 2 was distributed, but no revision of the proposal has been produced. This DRAFT is for your information and discussion at the June X3J13 meeting, but it is not in final form.Status:	 DRAFTIssue:         DECLARATION-SCOPEReferences:    Section 9.1 (pp. 153-157).	       Cleanup issue FLET-DECLARATIONS.Category:      CHANGEEdit history:  V1: Hornig@Symbolics.COM -- 5 January 1988	       Version 2, Moon, 2-Feb-1988 (edits based on discussion)Problem description:The description of the scope of declarations made with DECLARE is bothunclear (although unambiguous) and arguably a mistake.  The issue iswhether the scope of some or all of the declarations includes codeappearing in the non-body part of the special form containing thedeclaration.Proposal DECLARATION-SCOPING:LIKE-VARIABLE:For the purposes of this proposal, we divide all declarations introducedwith DECLARE into two classes.  When a declaration of a variable appearsbefore the body of a special form or lambda-expression that binds thatvariable, the declaration is called `bound'.  All other declarationsare called `free'.  This division replaces the division into pervasive,nonpervasive, and SPECIAL declarations appearing in CLtL.The scope of a `bound' declaration is exactly the scope of theassociated lexical variable or function.  If the declaration isassociated with a special variable, the scope is the scope the variablewould have had if it had not been special.`Free' declarations are scoped as if they appeared in a new LOCALLY formwhich surrounded the entire special form at the beginning of whose bodythe declaration appears.  This is the same as what CLtL p.155 defines tobe the scope of `pervasive' declarations.The following is a complete listing of the types of declarations andtheir class (`bound' or `free'):SPECIAL declarations may be either `bound', affecting both a binding andreferences, or `free', affecting only references, depending on whetherthe declaration is attached to a variable binding, as described above.TYPE declarations may only be `bound' (see next section).FTYPE and FUNCTION declarations may only be `free' (see next section).INLINE declarations may only be `free' (see next section).NOTINLINE declarations may only be `free' (see next section).IGNORE declarations may only be `bound'.OPTIMIZE declarations may only be `free'.The `free' or `bound' scoping of implementation-dependent declarationspecifiers is implementation-dependent.Interactions with other proposals:There has been some discussion in X3J13 of permitting `free' TYPEdeclarations.  This is a semantic issue, not a scoping issue, and shouldbe treated independently.If Common Lisp is extended to permit declarations in FLET and LABELSforms, by acceptance of cleanup proposal FLET-DECLARATIONS:ALLOW,then declarations of functions (FTYPE, FUNCTION, INLINE, andNOTINLINE) which appear before the body of a FLET or LABELS form whichdefines that function are `bound'.  Such declarations in other contextsremain `free'.Common Lisp is ambiguous about whether a variable may be bound severaltimes by a single form.  It has been proposed that multiple bindings bepermitted for LET*, DO*, PROG* forms and for &AUX variables in lambdaexpressions.  If multiple bindings are permitted, `bound' declarationsare treated as if there were a separate `bound' declaration for each ofthe bindings.Examples:;;; Some examples of `free' and `bound' declarations.(let ((a 1))  (declare (optimize speed))		;this is a `free' declaration  (let ((b 2))    (declare (type integer b))		;this is a `bound' declaration    (declare (special a))		;this is a `free' declaration    ()));;; This example applies if you believe that FLET may have declarations.(flet ((foo (x) (1+ x)))  (declare (notinline foo))		;this is a `bound' declaration  (declare (notinline 1+))		;this is a `free' declaration  ());;; The following code is from Pavel.;;; It produces 7 in existing implementations.;;; If the proposal is adopted, it will produce 8.(let ((foo 6))			;a special binding of FOO  (declare (special foo))	;`bound' declaration  (let ((foo 7))		;a lexical binding of FOO    (let ((foo (1+ foo)))	;is the second FOO special or not?      (declare (special foo))	;`bound' declaration      foo)));;; Treatment of LET* under the proposal if multiple bindings of the same name are allowed.;;; This form produces the value 9.(let ((foo 6))			;a special binding of FOO  (declare (special foo))	;`bound' declaration  (let ((foo 7))		;a lexical binding of FOO    (let* ((foo (1+ foo))	;special binding, lexical reference           (foo (1+ foo)))	;special binding, special reference      (declare (special foo))	;`bound' declaration, applies to both bindings       foo))		        ;special referenceRationale:`Bound' declarations are made to control a particular binding of avariable and should be scoped the same way as that binding.  This is astrue of `bound' declarations which were pervasive under the old rulesas it is of those that were not.Current practice:The `bound'/`free' division based on context replaces CLtL's staticpervasive/nonpervasive/SPECIAL division.  Most implementations implementthe rules in CLtL.  Symbolics currently implements rules based onZetalisp which are different from both this proposal and Common Lisp.Symbolics plans to change to Common Lisp rules in the future.Cost to Implementors:The cost of implementing this change should be moderate.  The changewill be localized to a handful of places in the compiler and interpreterwhich apply declarations to variables.  The other cost would be inproviding tools for users to find programs whose meaning will change.Cost to Users:The proposal changes only the treatment of `bound' declarations.  Thischange will break very few existing production programs.It is possible to mechanically examine a program to determine whetherits behavior would change under the new rules.  This permits animplementation to provide a transition tool to ease conversion to thenew definition.Cost of non-adoption:The ability of a `bound' declaration to affect code outside the scopeof the variable which it appears to declare has led to endless confusionand discussion at Symbolics, on the Common-Lisp mailing list, andelsewhere.  It will continue to do so unless it is smoothed over somehow.Benefits:The costs of non-adoption will be avoided.Aesthetics:The distinction between `bound' and `free' declarations introduced bythis proposal is a natural one.Discussion:A proposal to forbid `free' declarations except in LOCALLY forms and aproposal to have `free' declarations affect only the body were discardedas being too incompatible.The mapping from the existing pervasive/nonpervasive/SPECIAL division ofdeclarations and the one proposed here is complex.  In general,nonpervasive declarations are `bound' and pervasive declarations are`free'.  SPECIAL declarations are either `bound' or `free' based ontheir context, and are no longer treated as a special case.Some historical support for having `free' and `bound' declarations:Date: Tue, 20 Dec 83 15:50 ESTFrom: "David A. Moon" <Moon%SCRC-TENEX@MIT-MC.ARPA>Subject: DeclarationsTo: Common-Lisp@SU-AI.ARPA...There are two disjoint classes of declaration: those that are attachedto a particular variable binding, and those that are not.  Note that Iam not discussing proclamations here; they have their own scoping ruleswhich are different from the rules for declarations.The scoping rule for the first kind of declaration is that it applies toprecisely the text that is in the lexical scope of the variable bindingwith which it is associated.  Such declarations are shadowed by avariable binding for the same name inside their scope.  Since thelexical scoping rules are very well and precisely defined, we alreadyunderstand everything about this kind of declaration.The scoping rule for the second kind of declaration is that it ispervasive.  The declaration is attached to a lambda-expression or to aform (one of the special forms listed on page 125).  The declarationapplies to all text inside that expression or form; there are no specialcases such as init-forms of LET or DO.  Such declarations are shadowedby a conflicting declaration inside their scope.Possible names for the two kinds of declaration are "lexical" and"pervasive" or "variable" and "non-variable."...        TITAN 
         TITAN 
          
TIMESROMAN 
          ´       	                                   E                            l                     ,             #      }       
      x              õ             V                          _                    
       -              h             k      "D #zº*start*01199 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 09 JUN 88 15:26:11 PDTReceived: from labrea.stanford.edu by SAIL.Stanford.EDU with TCP; 9 Jun 88  15:25:16 PDTReceived: by labrea.stanford.edu; Thu, 9 Jun 88 15:24:14 PDTReceived: from bhopal.lucid.com by edsel id AA16555g; Thu, 9 Jun 88 15:19:42 PDTReceived: by bhopal id AA25468g; Thu, 9 Jun 88 15:18:17 PDTDate: Thu, 9 Jun 88 15:18:17 PDTFrom: Jon L White <edsel!jonl@labrea.stanford.edu>Message-Id: <8806092218.AA25468@bhopal.lucid.com>To: Masinter.paCc: X3J13@sail.stanford.edu, labrea!cl-cleanup@sail.stanford.eduIn-Reply-To: Masinter.pa@Xerox.COM's message of 8 Jun 88 12:39 PDT <880608-123958-2954@Xerox>Subject: Issue: DECLARATION-SCOPE (Version 2)Did you really want to distribute this to the X3J13 committee as a whole?I had proposed a major rewrite of this issue, based on treating DECLAREsimply as a lexical construct, but haven't had the time to work on it beforethe upcoming meeting.  I'd hoped to see cleanup subcommittee discuss itagain before bringing the issue to the committee as a whole.-- JonL --*start*09292 00024 US Date: 29 Mar 88 08:07From: fsbrn%BRL:ARPA:XeroxSubject: more comments on defvarTo: info-1100%sumex-aim.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Ferd Brundick (VLD/LTTB) <fsbrn@BRL.ARPA>To: info-1100@sumex-aim.stanford.EDUSubject: more comments on defvarReturn-Path: <@SUMEX-AIM.Stanford.EDU:fsbrn@BRL.ARPA>Redistributed: Info-1100-Redistribute^.XReceived: from SUMEX-AIM.Stanford.EDU by Xerox.COM ; 29 MAR 88 08:07:46 PSTReceived: from BRL-VIM.ARPA by SUMEX-AIM.Stanford.EDU with TCP; Tue, 29 Mar 88 04:56:38 PSTOriginal-Date: Tue, 29 Mar 88 7:54:33 ESTMessage-ID: <8803290754.aa20298@VIM.BRL.ARPA>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVHaah,Last week I posted a letter about the use of defconstant, defparameter,and defvar.  I've gotten a couple of responses, and the one from ChrisSchmidt pointed me in a new direction.He says he doesn't agree with my generalization "... that the defconstructs apply to global variables."  He then says "DEFVAR proclaimsa variable special (CLtL, p 68)."  Sure enough, that's what it says inthe middle of page 68.  However, the top line of the page says "Thedefvar and defparameter [and defconstant] special forms are the usualmeans of specifying globally defined variables [and constants]."  Onpage 69 Steele says "These constructs are normally used only astop-level forms."  I'll get back to that statement later.I think the real issue is "what are 'special' variables and how arethey used (and misused)?", but first another aside.The first LISP I was exposed to was Franz, which is dynamicallyscoped.  We were given the kernel of a program, and over a period oftime it evolved and grew until only a few of the original functionnames remained.  After we bought our first Xerox Lisp machines Itranslated everything into Interlisp-D, and about a year ago I rewroteit again, this time in Gould CL.Like I said in my previous note, I would bind my "global" variables toa "main" function and use Franz's dynamic scoping to access thesevariables from the subfunctions.  There are far too many variables inthe program to pass them around in argument lists.  When I startedusing CL I read that it is lexically scoped, and I got the idea thatvariables must be *global* or local.  (When I say *global* I mean thevariables are bound at the top level.  "global" or "semi-global meansthey are bound somewhere in the calling sequence and accessed throughthe stack.)  I also thought "special" meant *global*.  In my rewrite Ididn't bind the *global* variables to anything and the program workedthe way it always had.Once I got a copy of Lyric I downloaded the files and got them to workwith only minor changes (mostly OS-dependent).  Then I learned that"special" means "dynamically scoped" so I started binding "semi-global"variables the way I did in Franz.  Now I think of (DECLARE (SPECIALVARxxx)) to mean "export" in the function that binds VARxxx and"import" in all the functions that use VARxxx.  (Why didn't Steele usethe words "export" and "import" if they are accurate?)  If no one bindsVARxxx then it is *global*, which is essentially what I had been doing.How does this affect the Xerox environment?  Again referring to myearlier note, the vmem is persistant.  If a program creates any*global* variables they will hang around until they are explicitlyunbound (with MAKUNBOUND), the vmem is recopied, or a (LOGOUT T) isperformed (the last 2 being brute force approaches).  At the Lyricconversion course I attended the instructor pointed out that *global*variables are a Bad Thing in a multi-processing environment.  How canyou run multiple copies of a program if they all use the same *global*variables?  I have modified a module (the changes were fairly minor)to use a hash table instead of property lists to store lots of data.Not only can I bind the hash table so multiple processes may be run,but I don't have to worry about the data structures being garbagecollected after I'm done (there aren't any multiple references).The issue now seems to be largely a matter of style.  If you think theuse of *global* or "global" variables is a Bad Thing this doesn'taffect you.  Property lists are by nature *global*, which is why I'veswitched to hash tables.  What is the "preferred" way (or yourfavorite way, I suppose) to bind and reference global variables?I used to append a program's name to each of its functions so I couldkeep track of them and not overwrite another program's function withthe same name.  While this is still done in the Library and Lispusermodules, packages are one way around the problem.  However, thisdoesn't help global variables with multiple copies of the same program.Yes, another technique is to use property lists on a program's mainwindow, which is what I use for *some* of my variables.  I don't wantthe overhead of GETing and PUTing properties every time I need tosee or modify a value.My two main sources for CL information are Steele's book (CLtL) andTatar's book, _A Programmer's Guide to CL_.  Chris and I have alreadymentioned what Steele says about the "def" macros.  His description of"special" (pp 157-8) says "All variable bindings affected are made tobe dynamic binding rather than the current local binding."  He thengives a simple example and a very contorted one.  On pp 76-7, Tatarsays "Variables are lexically scoped unless they are declared special,in which case they are dynamically scoped."  She then gives a coupleof examples similar to Steele's simple one.  Ok so far.  After theexamples she says (p 78) "Special variables are not often used in thisform [accessing dynamic variables on the stack].  However, there is ageneralization of the 'special variable' idea which is used frequently.So-called global variables in Lisp are, in fact, dynamically scopedspecial variables."  This is her intro to the "def" macros, the"top-level variable declarations" and free variables.Now I've come full circle.  Tatar says to use def* to declare globalfree variables, but I don't want free vars so I can run multiplecopies.  Is it safe to say that both Steele and Tatar are assuming asingle process, static environment, and that the Xerox environmentrequires new rules and techniques?As an experiment I created two functions, FOO and BAR.  FOO binds avariable in a LET, tries to DEFVAR it, and calls BAR.  BAR tries toaccess the variable.  The results I got when I ran this are so weirdI'm sure that I tried to use defvar in a nonsensical manner.  *IF*what I did makes no sense, then it is not strictly true that def*means the same as "special".  It also makes me wonder if you candefvar a variable anywhere *except* at the top level, even thoughSteele claims "These constructs are normally used only as top-levelforms."Do I have a gross misunderstanding of how these things are "supposed"to work, or am I just making an issue out of nothing?  I haven't readall of Tatar's book (yet) and I haven't seen any "real" examples ofhow and when to use defvar vs. dynamically scoped semi-globalvariables.  Is Tatar wrong when she says "special" variables arerarely used?  I looked at her programs near the back of the book andshe prefers to use defvar at the top level for all her *global*variables and never says (DECLARE (SPECIAL VARxxx)).  [When I try tocompile functions that reference free variables the compiler warns methat it is assuming the variable is special.  Putting in a DECLARESPECIAL statement silences the compiler.  Running interpreted doesn'tseem to care.  This happened on all 3 CLs I tried.]  The book _CommonLISPCraft_ doesn't even talk about special variables or def*.  (In myopinion the book is a minor rewrite of _LISPCraft_ using CL functionnames instead of Franz names.  A lot of CL's power is ignored.)Here is a dribble file of the test I tried under Lyric.  It shows thefunctions FOO and BAR, 2 sample calls to FOO, a modification of FOO,and another call to FOO.  What is supposed to happen is FOO binds Y toitself, makes it "special" with defvar, then calls BAR which shouldsee the binding of Y on the stack.  That happens in the second andthird calls but not the first.  I try to get the value of Y at the endto show that it isn't just a *global* value.263> pp fooFUNCTIONS definition for FOO:(DEFUN FOO (X)    (LET (Y)      (DEFVAR Y '(INITIAL VALUE))      (FORMAT T "foo: ~A  ~A~%" X Y)      (BAR X)))264> pp barFUNCTIONS definition for BAR:(DEFUN BAR (X2)   (FORMAT T "foo: ~A  ~A~%" X2 Y))265> foo(alpha)foo: ALPHA  (INITIAL VALUE)Unbound variable: Y.266> foo(beta)foo: BETA  NILfoo: BETA  NILNIL267> ed(foo)Editing FUNCTIONS definition of FOOFOO268> pp fooFUNCTIONS definition for FOO:(DEFUN FOO (X)   (LET (Y)      (DEFVAR Y '(INITIAL VALUE))      (SETQ Y '(NEW VALUE))      (FORMAT T "foo: ~A  ~A~%" X Y)      (BAR X)))269> foo(gamma)foo: GAMMA  (NEW VALUE)foo: GAMMA  (NEW VALUE)NIL270> yUnbound variable: Y.                                        dsw, fferd                                        Fred S. Brundick                                        USABRL, APG, MD.                                        <fsbrn@brl.arpa> *start*02096 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 APR 88 09:53:07 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 8 Apr 88  09:51:19 PDTReceived: by ti.com id AA28559; Fri, 8 Apr 88 11:49:24 CDTReceived: from dsg by tilde id AA20789; Fri, 8 Apr 88 11:29:46 CDTReceived: From Kelvin By dsg Via CHAOS-NET With CHAOS-MAIL; Mon, 4 Apr 88  13:55:55 CDTMessage-Id: <2785172148-710565@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 4 Apr 88 13:55:48 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: CL-Cleanup@SAIL.Stanford.eduSubject: special var type declsHere's something that the Common Lisp clean-up committee might want toconsider for clarification:Is the following legal?  (PROCLAIM '(TYPE NUMBER *X*))  (DEFVAR *X*)  (DEFUN FOO ()     (LET ((*X* T))	(DECLARE (TYPE SYMBOL *X*))	(BAR)))Page 156 of Steele says that a proclamation is "always in force unlesslocally shadowed" and page 158 says type declarations "only affectvariable bindings", which might be interpreted to mean that the DECLARElocally shadows the PROCLAIM.  However, that interpretation would makethe global type proclamation useless because it could not be relied onwhen compiling a function such as BAR.  Consequently I would be inclinedto say that the above example is an error.  That still leaves a questionof whether local type declarations for special bindings should bepermitted if they specify a subtype of the globally proclaimed type, orwhether (DECLARE (TYPE ...)) is only meaningful for lexical variables.Another example of ambiguity regarding global versus local declarationsis that section 9.2 of Steele begins "Here is a list of validdeclaration specifiers for use in DECLARE." What about PROCLAIM?  Doesthat imply that FTYPE cannot be used in a PROCLAIM since it is notexplicitly mentioned under the PROCLAIM function?  On the other hand,IGNORE doesn't make sense in a PROCLAIM, but it doesn't explicitly saythat it can't be used there.  -- David Gray*start*02096 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 08 APR 88 09:53:20 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 8 Apr 88  09:51:30 PDTReceived: by ti.com id AA28563; Fri, 8 Apr 88 11:49:29 CDTReceived: from dsg by tilde id AA20827; Fri, 8 Apr 88 11:30:21 CDTReceived: From Kelvin By dsg Via CHAOS-NET With CHAOS-MAIL; Mon, 4 Apr 88  13:55:55 CDTMessage-Id: <2785172148-710565@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 4 Apr 88 13:55:48 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: CL-Cleanup@SAIL.Stanford.eduSubject: special var type declsHere's something that the Common Lisp clean-up committee might want toconsider for clarification:Is the following legal?  (PROCLAIM '(TYPE NUMBER *X*))  (DEFVAR *X*)  (DEFUN FOO ()     (LET ((*X* T))	(DECLARE (TYPE SYMBOL *X*))	(BAR)))Page 156 of Steele says that a proclamation is "always in force unlesslocally shadowed" and page 158 says type declarations "only affectvariable bindings", which might be interpreted to mean that the DECLARElocally shadows the PROCLAIM.  However, that interpretation would makethe global type proclamation useless because it could not be relied onwhen compiling a function such as BAR.  Consequently I would be inclinedto say that the above example is an error.  That still leaves a questionof whether local type declarations for special bindings should bepermitted if they specify a subtype of the globally proclaimed type, orwhether (DECLARE (TYPE ...)) is only meaningful for lexical variables.Another example of ambiguity regarding global versus local declarationsis that section 9.2 of Steele begins "Here is a list of validdeclaration specifiers for use in DECLARE." What about PROCLAIM?  Doesthat imply that FTYPE cannot be used in a PROCLAIM since it is notexplicitly mentioned under the PROCLAIM function?  On the other hand,IGNORE doesn't make sense in a PROCLAIM, but it doesn't explicitly saythat it can't be used there.  -- David Gray*start*04807 00024 US Return-Path: <boyer@CLI.COM>Received: from CLI.COM by Xerox.COM ; 20 JUN 88 07:26:34 PDTReceived: by CLI.COM (4.0/1); Mon, 20 Jun 88 09:22:45 CDTDate: Mon, 20 Jun 88 09:22:45 CDTFrom: Robert S. Boyer <boyer@CLI.COM>Message-Id: <8806201422.AA07863@CLI.COM>To: cl-cleanup@sail.stanford.eduCc: yuasa%tutics.tut.junet@utokyo-relay.CSNET, Masinter.paSubject: KCL scoping bug?Larry,Here is all the correspondence on that particular issue from the kclmailing list.From: vax135!melmac!ilan@ucbvax.Berkeley.EDUDate: Tue, 3 May 88 10:25:26 edtTo: ilan@ucbvax.Berkeley.EDU, vax135!froggy.ics.utexas.edu!boyerSubject: KCL scoping bug?Hi,I'm not sure how to post stuff to the KCL board at the moment, so I'msending this to you.  If you deem it worthwhile please post itto the KCL mailing-list.The following produces a scoping error in the interpreter (June 3, 87) -the compiler handles the code correctly. (The example is lifted directly from CLtL p. 155).--------->(setq x 'x-dyn z 'z-dyn)Z-DYN>(load "nonsense.l")Loading nonsense.lFinished loading nonsense.lT>#'foo(LAMBDA-BLOCK FOO (&REST ARGS) (PRINT ARGS) (LIST ARGS))>#'nonsense(LAMBDA-BLOCK NONSENSE (K X Z)  (FOO Z X)  (LET ((J (FOO K X)) (X (* K K)))    (DECLARE (INLINE FOO) (SPECIAL X Z))    (FOO X J Z)))>(nonsense 1 2 3)(3 2)(1 2)			;;; <---- SHOULD BE (1 X-DYN)(1 ((1 2)) Z-DYN)	;;; <---- SHOULD BE (1 ((1 X-DYN)) Z-DYN)((1 ((1 2)) Z-DYN))	;;; <---- SHOULD BE ((1 ((1 X-DYN)) Z-DYN))>(compile 'nonsense)End of Pass 1.  End of Pass 2.  OPTIMIZE levels: Safety=0 (No runtime error checking), Space=0, Speed=3NONSENSE>(nonsense 1 2 3)(3 2)(1 X-DYN)(1 ((1 X-DYN)) Z-DYN)((1 ((1 X-DYN)) Z-DYN))--------------------Ilan Caron ..!ucbvax!vax135!lcuxlj!ilanFrom: vax135!melmac!ilan@ucbvax.Berkeley.EDUDate: Tue, 24 May 88 13:41:32 edtMessage-Id: <8805241741.AA29869@vax135.UUCP>To: ilan@ucbvax.Berkeley.EDU, vax135!cli.com!kclSubject: KCL scoping bug?A couple of weeks ago I posted what seemed to be a KCL interpreterscoping bug using the example from CLtL p. 155.Having seen no response to what seems to be a potential sourceof major confusion, I'm reposting the bug - this time on a simplerpiece of code.  The interpreter doesn't make a special referencefor Y in spite of the special declaration.Please note that the bug only manifests itself when interpreted, thecompiler handles the situation correctly.------------------KCL (June 3, 1987)------------------Starts dribbling to x (1988/5/25, 2:29:20).NIL> #'foo(LAMBDA-BLOCK FOO (X Y Z)  (LET ((X Y) (Y Z)) (DECLARE (SPECIAL Y Z)) (LIST X Y Z)))>(setq x 'dyn-x y 'dyn-y z 'dyn-z)DYN-Z>(foo 'lex-x 'lex-y 'lex-z)(LEX-Y DYN-Z DYN-Z)			;;; <---- should be (DYN-Y ...)> (compile 'foo); (DEFUN FOO ...) is being compiled.;; Warning: The variable X is not used.;; Warning: The variable Y is not used.;; Warning: The variable Z is not used.End of Pass 1.  End of Pass 2.  OPTIMIZE levels: Safety=0 (No runtime error checking), Space=0, Speed=3FOO>(foo 'lex-x 'lex-y 'lex-z)(DYN-Y DYN-Z DYN-Z)			;;; <---- this is correct>-----------ilan caronDate: Thu, 26 May 88 10:10:26 jstFrom: Taiichi Yuasa <yuasa%tutics.tut.junet@relay.cs.net>To: kcl@cli.comSubject: Re: KCL scoping bug?Here's the story.I noticed long time ago that there's an inconsistency as youposted.  However, at that time I did not know which interpretationis correct.  So, I decided to leave the inconsistency untilsomeone (x3j13, perhaps) clarifies which is correct.  I still do notknow which is correct.  It's easy to solve the inconsistency.Is there any general consensus on this matter?If most people agree that the compiler is correct and the interpreteris wrong, I'm happy to fix the bug immediately.-- TaiichiReceived: by CLI.COM (4.0/1); Tue, 31 May 88 12:41:47 CDTReceived: by ucbvax.Berkeley.EDU (5.59/1.28)	id AA01603; Tue, 31 May 88 09:18:42 PDTFrom: vax135!melmac!ilan@ucbvax.Berkeley.EDUDate: Tue, 31 May 88 12:13:03 edtMessage-Id: <8805311613.AA03145@vax135.UUCP>To: vax135!cli.com!kclSubject: Re:  KCL scoping bug?The example and explanation on p. 155 CLtL makes it prettyclear that the compiler is correct, (i.e. that the specialdeclaration also applies to references within the initformsof a LET) - in particular, The Book says: "The referenceto X in the second call to FOO is also a special reference".------------------------------------------------------------For those interested, the relevant nonsensical code is:  (defun nonsense (k x z)    (foo z x)    (let     (      (j (foo k x))	;;; <--- the problematic reference to X      (x (* k k))      )     (declare (inline foo) (special x z))     (foo x j z)     )    )--ilan caron*start*01184 00024 USfReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 19 SEP 88 18:38:11 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03874g; Mon, 19 Sep 88 17:37:50 PSTReceived: by bhopal id AA15845g; Mon, 19 Sep 88 18:37:18 PDTDate: Mon, 19 Sep 88 18:37:18 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809200137.AA15845@bhopal>To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 13 Sep 88 02:43 PDT <880913-024302-2594@Xerox>Subject: Issue: DECLARATION-SCOPE (Version 2)re: This one I distributed to X3J13 on 8 Jun 88 12:39 PDT. You said that "I had    proposed a major rewrite of this issue, based on treating DECLARE simply as a    lexical construct, but haven't had the time to work on it before the upcoming    meeting. ...."Moon and I are having an private discussion about this one -- I sent himmy proposed changes some days after I sent you that note; and he has replied with a lengthy note that I haven't had time to read yet (it arrived over the weekend, and I'm still working on the masses of mail received duringthe two-week blitz at 3.0 release time.)-- JonL --*start*01598 00024 US Date: 30 Sep 88 17:23 PDTFrom: masinter.paSubject: [Jon L White <jonl@lucid.com>: Issue: DECLARATION-SCOPE (Version 2)]To: jonl@lucid.comcc: masinter.paYou mentioned the array element-type issue on the phone, but I'm also waiting for you on this one. If you don't think you'll make it this weekend, please let me know ...     ----- Begin Forwarded Messages -----Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 19 SEP 88 18:38:11 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03874g; Mon, 19 Sep 88 17:37:50 PSTReceived: by bhopal id AA15845g; Mon, 19 Sep 88 18:37:18 PDTDate: Mon, 19 Sep 88 18:37:18 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8809200137.AA15845@bhopal>To: masinter.paIn-Reply-To: masinter.pa@Xerox.COM's message of 13 Sep 88 02:43 PDT <880913-024302-2594@Xerox>Subject: Issue: DECLARATION-SCOPE (Version 2)re: This one I distributed to X3J13 on 8 Jun 88 12:39 PDT. You said that "I had    proposed a major rewrite of this issue, based on treating DECLARE simply as a    lexical construct, but haven't had the time to work on it before the upcoming    meeting. ...."Moon and I are having an private discussion about this one -- I sent himmy proposed changes some days after I sent you that note; and he has replied with a lengthy note that I haven't had time to read yet (it arrived over the weekend, and I'm still working on the masses of mail received duringthe two-week blitz at 3.0 release time.)-- JonL --     ----- End Forwarded Messages -----*start*01636 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 01 OCT 88 18:05:31 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01471g; Sat, 1 Oct 88 17:04:45 PSTReceived: by bhopal id AA08655g; Sat, 1 Oct 88 18:04:17 PDTDate: Sat, 1 Oct 88 18:04:17 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810020104.AA08655@bhopal>To: masinter.paCc: jonl@lucid.comIn-Reply-To: masinter.pa@Xerox.COM's message of 30 Sep 88 17:23 PDT <880930-172259-1470@Xerox>Subject: [Jon L White: Issue: DECLARATION-SCOPE (Version 2)]re: You mentioned the array element-type issue on the phone, but I'm also    waiting for you on this one. If you don't think you'll make it this    weekend, please let me know ...This one, unfortunately, is not going anywhere nearly as smoothlyas the array-type-element-type biz.  Moon has prepared a version 3which he sent to me privately; but it still didn't have the objectional parts removed.  I replied to him, and I don't think he had a chanceto read the reply before leaving town.  I suspect that he won't be "back" until after the CLOS workshop either.The problem is that I will submit a counter proposal if we can'tagree privately -- it would be called 	DECLARATION-SCOPE:PURELY-LEXICALbut I rather not do that if all that's missing is a "light" to go on in moon's head.Send me a reply as soon as you read this so I'll know whether ornot to fill out the PURELY-LEXICAL form.-- JonL --P.S.  Am working on array-element-type ... "in just a few minutes".      Really.  I'm only a few mail msgs behind now.*start*00802 00024 US Return-Path: <Moon@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 07 OCT 88 18:00:35 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472938; Fri 7-Oct-88 21:00:36 EDTDate: Fri, 7 Oct 88 21:00 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPE (version 3)To: Masinter.paIn-Reply-To: <19880918210307.0.MOON@EUPHRATES.SCRC.Symbolics.COM>Message-ID: <19881008010019.4.MOON@EUPHRATES.SCRC.Symbolics.COM>Line-fold: NoWell, I just came upon an incomplete private discussion withJonL on this topic.  I sent off another message to him, butit seems more than unlikely that this will get resolved by Monday.*start*00997 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 12:58:19 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 13 Oct 88  12:58:45 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 475754; Thu 13-Oct-88 15:57:14 EDTDate: Thu, 13 Oct 88 15:57 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: DECLARATION-SCOPE (Version 2)To: CL-Cleanup@SAIL.Stanford.EDUcc: JonL@Lucid.COMMessage-ID: <881013155704.0.KMP@BOBOLINK.SCRC.Symbolics.COM>My notes from Fairfax meeting...Cleanup meeting: JonL will produce next writeup.X3J13 meeting: Sandra: DECLARE-TYPE-FREE conflicts with this: This proposal mentions that	 free declarations are not possible. Make the relationship between	 the two proposals explicit in both.*start*01341 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:15:11 PDTReceived: from cs.utah.edu by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:15:22 PDTReceived: by cs.utah.edu (5.54/utah-2.0-cs)	id AA18009; Thu, 13 Oct 88 14:13:46 MDTReceived: by defun.utah.edu (5.54/utah-2.0-leaf)	id AA19827; Thu, 13 Oct 88 14:13:44 MDTFrom: sandra%defun@cs.utah.edu (Sandra J Loosemore)Message-Id: <8810132013.AA19827@defun.utah.edu>Date: Thu, 13 Oct 88 14:13:43 MDTSubject: issue DECLARATION-SCOPETo: cl-cleanup@sail.stanford.eduI generally like this proposal because the wording it uses is much moreunderstandable than the terminology in CLtL (which I have never succeededin grokking fully).  I have two big problems with the current writeup:other hand, it has two big problems:(1) The treatment of TYPE declarations contradicts proposalDECLARE-TYPE-FREE.  I don't think I could vote for either proposalwithout some better indication of how they are supposed to worktogether. (2) Since issue FLET-DECLARATIONS was passed at the March meeting, thewriteup needs to be changed to reflect that and give TYPE and FTYPEdeclarations the same treatment (either both "bound" or both "free").-Sandra-------*start*02696 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 22 OCT 88 12:53:55 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Oct 88  19:51:36 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00737g; Fri, 21 Oct 88 19:51:21 PDTReceived: by bhopal id AA12854g; Fri, 21 Oct 88 19:49:49 PDTDate: Fri, 21 Oct 88 19:49:49 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810220249.AA12854@bhopal>To: sandra%defun@cs.utah.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Sandra J Loosemore's message of Thu, 13 Oct 88 14:13:43 MDT <8810132013.AA19827@defun.utah.edu>Subject: issue DECLARATION-SCOPEre: (1) The treatment of TYPE declarations contradicts proposal    DECLARE-TYPE-FREE.  I don't think I could vote for either proposal    without some better indication of how they are supposed to work    together. The source of much confusion here has long been that TYPE declarations had to be treated differently from all other declarations; this was  because of the crazy prohibition found on p158 of CLtL.  Let's assume for now that DECLARE-TYPE-FREE is accepted; then I think we can just flush all crazy categorizations into "pervasive"/"non-pervasive" and  "free"/"bound" and simply say that declarations:  (1) always include the lexical scope of the body of the special form       in which  they are found;  (2) and furthermore, they also include the scope of the name-bindings,       if any, to which they apply.  [LET, LAMBDA, FLET, and LABELS       introduce "name bindings"; LOCALLY doesn't.]Since the scope of a "name-binding" also includes the body as mentionedin (1), then the only additional comment needed concerns LET* and LABELS.We might need to be reminded that:  -- for LET*, a variable's scope also includes the remaining value     forms, for subsequent variable bindings;  -- for LABELS, a function name's scope includes all the code for the     functions being defined [presumably, compiler writers know how not      to get into an infinite loop of in-line substitutions in these cases];We might also need to be reminded that new name-bindings "shadow" (aftera fashion) any higher level binding or declarations.  E.g., presumingno proclamations, consider the inner let bindings of:   (locally (declare (special x) (float y))      (let ((x 5) (y 10))        (print (+ x y))))then x is bound is local, not special; and y is bound with no particulartype information [because the 'y' being bound is a different variablethan the 'y' declared float in the outter scope].-- JonL --*start*01794 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 20:40:59 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Oct 88  20:39:47 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 482762; Wed 26-Oct-88 23:39:59 EDTDate: Wed, 26 Oct 88 23:39 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue DECLARATION-SCOPETo: Sandra J Loosemore <sandra%defun@cs.utah.edu>cc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8810132013.AA19827@defun.utah.edu>Message-ID: <19881027033947.4.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 13 Oct 88 14:13:43 MDT    From: sandra%defun@cs.utah.edu (Sandra J Loosemore)    I generally like this proposal because the wording it uses is much more    understandable than the terminology in CLtL (which I have never succeeded    in grokking fully).  I have two big problems with the current writeup:    other hand, it has two big problems:    (1) The treatment of TYPE declarations contradicts proposal    DECLARE-TYPE-FREE.  I don't think I could vote for either proposal    without some better indication of how they are supposed to work    together.     (2) Since issue FLET-DECLARATIONS was passed at the March meeting, the    writeup needs to be changed to reflect that and give TYPE and FTYPE    declarations the same treatment (either both "bound" or both "free").Mumble.  Both of these problems were corrected in version 3 of theproposal, which I sent to JonL on September 18.  Can it be that noone but JonL and me ever saw that version?  I may have screwed up.*start*03438 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 20:54:39 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 26 Oct 88  20:53:25 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 482771; Wed 26-Oct-88 23:52:30 EDTDate: Wed, 26 Oct 88 23:52 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: issue DECLARATION-SCOPETo: Jon L White <jonl@lucid.com>cc: sandra%defun@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: <8810220249.AA12854@bhopal>Message-ID: <19881027035211.5.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 21 Oct 88 19:49:49 PDT    From: Jon L White <jonl@lucid.com>    The source of much confusion here has long been that TYPE declarations had     to be treated differently from all other declarations; this was  because of     the crazy prohibition found on p158 of CLtL.  Let's assume for now that     DECLARE-TYPE-FREE is accepted; then I think we can just flush all crazy     categorizations into "pervasive"/"non-pervasive" and  "free"/"bound" and     simply say that declarations:      (1) always include the lexical scope of the body of the special form 	  in which  they are found;      (2) and furthermore, they also include the scope of the name-bindings, 	  if any, to which they apply.  [LET, LAMBDA, FLET, and LABELS 	  introduce "name bindings"; LOCALLY doesn't.]    Since the scope of a "name-binding" also includes the body as mentioned    in (1), then the only additional comment needed concerns LET* and LABELS.JonL, this makes me really angry.  I feel like I have explained this tentimes, but it never seems to get through to you.  I've started to replyto this several times, but cancelled it.  I hope the following isa calm and understandable explanation of the issue.  Please read it.First of all, the "free"/"bound" distinction isn't some crazycategorization that we can just remove.  It means exactly the samething as your phrase "the name-bindings, if any, to which they apply".As long as we have in the language both declarations that are attachedto bindings and declarations that are not attached to bindings, we havea "free"/"bound" distinction, whether we like it or not.  If we don'tlike those names, we could use other ones, although those are thestandard names for the concepts; however, changing the name won'teliminate the issue.But that's not the major point.  The major point is your claim that it'sobvious that the scope of a free declaration should be just the body ofthe special form, and not include any additional code, such asinitialization forms.  Perhaps we would choose to adopt this afterdiscussion, but it's not obviously correct, it's not obviously simplerthan setting the scope to the entire special form, and most importantlyit is an incompatible change, directly contradicting the scope definedby CLtL for the FTYPE, INLINE, NOTINLINE, and OPTIMIZE declarations,and for the SPECIAL declaration when not attached to a variable binding.My reason for preferring that the scope of a free declaration is theentire special form is to avoid an incompatible change.If you don't see that, look at the "defun few" example in the middleof page 155 of CLtL.*start*05858 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 OCT 88 23:35:58 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 28 Oct 88  23:33:50 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02661g; Fri, 28 Oct 88 23:31:51 PDTReceived: by bhopal id AA17474g; Fri, 28 Oct 88 23:30:24 PDTDate: Fri, 28 Oct 88 23:30:24 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810290630.AA17474@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: sandra%defun@cs.utah.edu, cl-cleanup@sail.stanford.eduIn-Reply-To: David A. Moon's message of Wed, 26 Oct 88 23:52 EDT <19881027035211.5.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: issue DECLARATION-SCOPEre: First of all, the "free"/"bound" distinction isn't some crazy    categorization that we can just remove.  I've never claimed that; I've only claimed that embellishing it, and usingit for the purpose of explaining DECLARE scoping is not only unnecessary, but adding to the confusion surrounding the issue.  [Incidentally, the "crazy" in my msg came from a characterization of the "prohibition found on p158 of CLtL", which happily is a matter of the past now that DECLARE-TYPE-FREE is virtually approved.  The whole point of my msgwas to glory in the fact that declaration scoping is now free of this"crazy" constraint; until this time, scoping had to have an explicitexception for "free" type declarations.]re: . . .  It [the "free"/"bound" distinction] means exactly the same    thing as your phrase "the name-bindings, if any, to which they apply".Well, I've never gotten that impression from the lengthy exposition in thecurrent proposal.  More to the point, the applicability of a declaration must be specified somewhere in the standards document *** and this must be done purely independently of the scoping issue ***.  My claim is that this independent specification can already be presumed when discussing the scoping issue.That is, somehow, one comes to understand:  (1) that SPECIAL and TYPE declarations never apply to function bindings;  (2) that INLINE and FTYPE declarations never apply to variable bindings;   (3) that OPTIMIZE and DECLARATION never apply to either kind of binding;  (4) and that (<declaration> X) never applies to a binding of Y.This "understanding" is for the most part distributed throughout the individual declaration definitions.  Surely, you can appreciate the importance of this point -- that the name-applicibility issue for bindingsmust be specified independently of how the declaration scoping issue isdecided, and it certainly will not depend on which of the three alternative scoping proposals is chosen!re: . . .  The major point is your claim that it's    obvious that the scope of a free declaration should be just the body of    the special form, and not include any additional code, such as    initialization forms.   ...That wasn't my claim [or, not exactly].  Restating it (for the nth time!):   (1) the scope should always include the body form, and   (2) it should also include any correlated name binding ... which by        the _already-specified_ rules of lexical scoping for variables        would include certain init-forms in LET* [but of course wouldn't        include any in plain LET].Part of the simplicity of the approach I've been advocating is that wereduce the thorny part of the scoping issue for DECLARE to the *** already solved *** scoping issue for lexical variables.  There certainly is no need to bring in the "free/bound declaration" distinction for the purpose of understanding lexical variable scoping.Indeed, not arbitrarily including init-forms in the declaration is slightly different from the opaque (even if "unambiguous") prescriptions given in CLtL; I claim it is a difference for the better, and will directly spell out three significant improvements when I put the claim into proposal format [Larry: I should have this done before next Wednesday].re:                       ...   Perhaps we would choose to adopt this after    discussion, but it's not obviously correct, it's not obviously simpler    than setting the scope to the entire special form, and most importantly    it is an incompatible change, directly contradicting the scope defined    by CLtL ... If you don't see that, look at the "defun few" example in     the middle of page 155 of CLtL.Quoting from the original DECLARATION-SCOPE proposal by Hornig, as well asthe version you most recently sent me privately, the categorey is listed as CHANGE -- meaning "incompatible change".  At stake is not whether one or the other is "an incompatible change", but which of the two alternative semantics is more natural, easier to specify, and less likely to be confusing to end-users.re:  My reason for preferring that the scope of a free declaration is the    entire special form is to avoid an incompatible change.Not only does the Category CHANGE, from you own version of the proposal,imply incompatible change, but you have apparently forgotten the"Current practice:" section of that proposal, which says in part:    ". . . Most implementations implement     the rules in CLtL.  Symbolics currently implements rules based on     Zetalisp which are different from both this proposal and Common Lisp.     Symbolics plans to change to Common Lisp rules in the future."The question, of course, is just what should "Common Lisp rules" be?  Since many folks have been grossly confused by CLtL, and since your ownproposal calls for a CHANGE, then let us strive to obtain a Change ForThe Better.  I might note that at least some part of one other system seems to implement the rules I've been praising.  -- JonL --*start*01784 00024 USaReturn-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 08 NOV 88 22:00:54 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA02174g; Tue, 8 Nov 88 22:00:03 PSTReceived: by bhopal id AA03393g; Tue, 8 Nov 88 21:58:42 PSTDate: Tue, 8 Nov 88 21:58:42 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8811090558.AA03393@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.eduSubject: Issue deadlinesI need more time to work on the several remaining issues that I'm acentral party to.  Could you possibly extend the deadline for one moreweek?  In particular, I have three nascent new version of issues that need airing:  SETF-FUNCTION-VS-MACRO  -- As per discussion at the Fairfax meeting --                             Gregor and I have a good plan; it's just a                              matter of writing it out and proofreading it;  DECLARATION-SCOPE       -- Again, I have it "scoped out", with partial                             discussion appearing recently, but need an                             hour or so to write out the simpler version;  HASH-TABLE-STABILITY    -- The issue that I explicitly asked for "more                              time" on at Fairfax; clarify what "Hash on                             EQ" implies.The problem, as usual, is that one's companies product deadlines don't just disappear when we go into high-speed "Cleanup" mode, and there is only so much time per week I can spend on reading x3 mail etc. [plusanother bout with the "flu".]I expect to be able to have fairly good versions of two of the threeissues above by this weekend, and the third one finished by the middleof next week.  Can this time frame be accommodated?-- JonL --*start*00897 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 DEC 88 15:34:28 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Dec 88  15:30:47 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 05 DEC 88 15:08:51 PSTDate: 5 Dec 88 15:07 PSTFrom: masinter.paSubject: Issue: DECLARATION-SCOPEIn-reply-to: Jon L White <jonl@lucid.com>'s message of Tue, 8 Nov 88 21:58:42 PSTTo: Jon L White <jonl@lucid.com>cc: masinter.pa, cl-cleanup@sail.stanford.eduMessage-ID: <881205-150851-4403@Xerox>Did I miss this, or did you not get around to it?  DECLARATION-SCOPE       -- Again, I have it "scoped out", with partial                             discussion appearing recently, but need an                             hour or so to write out the simpler version;*start*00922 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 DEC 88 14:34:38 PSTReceived: from RELAY.CS.NET (GW1.CS.NET) by SAIL.Stanford.EDU with TCP; 6 Dec 88  14:27:59 PSTReceived: from relay2.cs.net by RELAY.CS.NET id at16897; 6 Dec 88 14:02 ESTReceived: from draper.com by RELAY.CS.NET id ab08337; 6 Dec 88 12:57 ESTDate: Tue, 6 Dec 88 12:01 ESTFrom: "Steve Bacher (Batchman)" <SEB1525@draper.com>Subject: Re: Issue: DECLARATION-SCOPETo: cl-cleanup@SAIL.STANFORD.EDUX-VMS-To: CL-CLEANUP,SEB1525Do you really mean "extent"?  If so, what about SPECIAL variables?  Are thetype declarations supposed to apply to all references, even when notlexically apparent?  (This may be a moot question, but I'm sure there'ssomebody smart enough out there to come up with an example where it matters.)*start*17970 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 DEC 88 18:53:38 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 6 Dec 88  18:43:39 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00771g; Tue, 6 Dec 88 18:41:13 PSTReceived: by bhopal id AA11263g; Tue, 6 Dec 88 18:43:06 PSTDate: Tue, 6 Dec 88 18:43:06 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8812070243.AA11263@bhopal>To: cl-cleanup@sail.stanford.eduSubject: Issue: DECLARATION-SCOPE (version 4)[Apologies for delay -- I mailed this out a couple days ago, but itseems to have been "bounced" ago by one of the mail gateways.  I didn'tnotice that until Larry's recent probe about it.]Quite a few of us at Lucid have discussed this issue over the pastseveral weeks, and are unable to come to a single recommendation;we are individually and collectively divided between two possiblealternatives.  Consequently, we are passing along our two versions as an issue with two proposals, in the hopes that someone else may provide a cutting argument.  It is not so much that there are two camps at Lucid (as exemplified by the two proposals herein), but rather that each of us feels a measureof displeasure with some of the consequences of each proposal.  Theonly sure thing is that either proposal is better than the status quo.The alternative named NO-HOISTING is based on what many people feel is "right" (until they see some obscure screw cases).  The alternativenamed LIMITED-HOISTING may result in a scoping semantics equivalent toMoon's original versions of this issue [however, it is presented without recourse to an arbitrary classification of declarations into"pervasive"/"non-pervasive" or "free"/bound.]  Although both areincompatible changes, NO-HOISTING may have a wider arena of changeespecially in those implementations that actually pay attention to declarations other than just SPECIAL.-- JonL --!Issue:         DECLARATION-SCOPEReferences:    Declaration Syntax (CLtL, Section 9.1, pp. 153-157)	       LAMBDA-Expressions (CLtL, Section 5.2.2, pp. 59-66)               Cleanup issue FLET-DECLARATIONS (accepted)               Cleanup issue DECLARE-TYPE-FREE (accepted)Category:      CHANGE/CLARIFICATIONEdit history:  V1: Hornig@Symbolics.COM -- 5 January 1988               Version 2, Moon, 2-Feb-1988 (edits based on discussion)               Version 3, Moon, 18-Sep-88, for private discussion between JonL and Moon               Version 4, JonL, 15-Nov-88 add 2nd proposal; major rewrite.Problem description:The description of the scope of declarations made with DECLARE is unclear (although unambiguous) and arguably a mistake.  At issue iswhether the scope of some or all of the declarations at the head ofa special form includes code appearing in any non-body part of that special form.  CLtL p.155 attempts to address the issue by classifying declarations into two classes -- "pervasive" and "non-pervasive" -- but it does not succeed very well.A particular question of interest is whether the initial value forms for LET, LET*, FLET, LABELS, DO, PROG etc. are included.  The rules of CLtL,on some cases, are clear enough to see that a declaration inside the special form is "hoisted" up and around the whole form, so as to include all the "initial value" forms (and "stepper" forms and "result" forms for those constructs that have them).  This means that lexical argument variable X in the following function is inaccessible inside the initial value forms of the LET:  (defun bar (x y)	    ;[1] 1st instance of x    (let ((old-x x)	    ;[2] 2nd instance of x -- same as 1st instance?	  (x y))	    ;[3] 3rd instance      (declare (special x))      (list old-x x)))The declaration intended for the binding of X[3] also alters thescoping of the reference of X[2]; likely, this was not an intended consequence. [This is a simplification of the example on CLtL p.155].In this discussion, the term "body" will include any "stepper" or "result" forms, such as might be found in a DO or DO-mumble-SYMBOLSconstruct.  The reasoning for this is that such forms are always included in the scope of all name bindings (if any) being established by the special form.  They form an extended part of the "body".Proposal (DECLARATION-SCOPE:NO-HOISTING)Specify that the scope of a declaration located at the head of a special form or lambda expression is as follows:  (1) it always includes the body forms [as well as any "stepper" or       "result" forms]  (2) it also includes the scope of the name binding, if any, to which       it applies [LET, LAMBDA, FLET, DO, etc. introduce "name bindings";       LOCALLY doesn't.];This very straightforward prescription depends on one rather subtlepoint, namely that the scope of name bindings is an already solvedquestion.  Whether or not a particular declaration affects an initialvalue form (such as for LET or LET*) depends _solely_ on whether it isapplied to a variable or function (name) being bound whose scopeincludes such forms.  In this sense, the above specification limits thescope of declarations for name bindings to be exactly the scope of thename binding itself -- i.e. "like variable".  Thus there would be no"hoisting" of the special declarations in the example cited in theproblem description.  [See the Discussion section for a review of the CL rules on variable/function-name scoping in special forms.]Those declarations not correlated with any name binding do not cover anyof the initial-value forms; their scope simply includes the body (as well as any "stepper" or "result" forms).  In a sense, the above specification limits the scope of these kinds of declarations to be the same as anarbitrary name binding in a LET or FLET construct -- i.e. "like variable".[See also the issue DECLARE-TYPE-FREE.]Thus there is to be no "hoisting" for declarations in special forms or lambda expressions; the only initial value forms affected by a declaration will be those included indirectly, by the effect, if any, that a declaration has on a name binding. A question may arise as to what it means for a declaration to "apply to", or "be correlated to" a name binding.  As stated above about variablescoping, this is an already solved question in Common Lisp; it is not the purpose of this proposal to alter, clarify or in any other way bear upon the basic _applicability_ rules of declarations in Common Lisp.  However, a few reminders about these rules will help one understand the above specification:  --  SPECIAL and TYPE declarations never apply to function bindings;  --  INLINE and FTYPE declarations never apply to variable bindings;   --  OPTIMIZE never applies to either kind of binding;  --  (<declaration> X) never applies to a binding of Y.The specific rules are for the most part distributed throughout the individual declaration definitions.  The name-applicibility issue for bindings must be specified independently of how the declaration scoping issue is decided, and should not be confused with that scoping issue.Proposal (DECLARATION-SCOPE:LIMITED-HOISTING)Specify that the scope of a declaration located at the head of a special form or lambda expression is as follows:  (1) it always includes the body forms [as well as any "stepper" or       "result" forms]  (2) if the declaration is applicable to a name binding in that form,      then it is limited to exactly the scope of that name binding [LET,       LAMBDA, FLET, etc. introduce "name bindings"; LOCALLY doesn't.];  (3) if the declaration is not applicable to a name binding in that form,      then it includes all the initial value forms, in addition to the      body forms.This very straightforward prescription depends on one rather subtle point, namely that the scope of name bindings is an already solved question.  This applies not only to LET and LET* variables, but to the &optional, &key and &aux variables of LAMBDA-Expressions.  In this sense, the above specification limits the scope of declarations for name bindings to be exactly the scope of the name binding itself.  Thus there would be no "hoisting" of the special declarations in the example cited in theproblem description.Those declarations not correlated with any name binding act as if theywere included in a new LOCALLY construct wrapped around the entirespecial form.  Thus they are not scoped like an arbitrary variable(or, "name binding") in that special form, but rather are "hoisted" up.Whether or not a declaration is "hoisted" up around the special form in which it occurs depends on whether or not it is "captured en passant" by a correlated name binding.A question may arise as to what it means for a declaration to "apply to", or "be correlated to" a name binding.  As stated above about variablescoping, this is an already solved question in Common Lisp; it is not the purpose of this proposal to alter, clarify or in any other way bear upon the basic _applicability_ rules of declarations in Common Lisp.  However, a few reminders about these rules will help one understand the above specification:  --  SPECIAL and TYPE declarations never apply to function bindings;  --  INLINE and FTYPE declarations never apply to variable bindings;   --  OPTIMIZE never applies to either kind of binding;  --  (<declaration> X) never applies to a binding of Y.The specific rules are for the most part distributed throughout the individual declaration definitions.  The name-applicibility issue for bindings must be specified independently of how the declaration scoping issue is decided, and should not be confused with that scoping issue.Examples:;;; The following example is from a common-lisp mailing list discussion;;;  (from code suggested by Pavel Curtis).   The question is whether or;;;  not the special declaration in FOO applies to the  (1+ x) form.(setf (symbol-value 'x) 6)(defun foo (x)				;a lexical binding of X  (print x)  (let ((x (1+ x)))			;is the second X special or not?    (declare (special x))		;`normal' declaration    (bar))  (1+ x))(defun bar () (print (locally (declare (special x)) x)))(foo 10)  will  printout of 10 and 11 by either proposal herein(foo 10)  will  printout of 10 and 7 by CLtL style "hoisting";;; The following example is due to Jim Boyce, of Lucid Inc.  It shows how;;;  the "hoisting" of the declaration inadvertently causes it to act more;;;  like a proclamation than a declaration; namely, the declaration is;;;  applied to two different variables (which happen to have the same;;;  name) -- the first variable is the lexical one bound on line [1] and;;;  the second variables is bound on line [3].  Whereas lexical scoping;;;  rules would say that the reference in line [2] is to the variable;;;  bound on line [1], the effect of the "hoisted" declaration is to;;;  make the line [1]'s variable inaccessible in the initial value forms.(setf (symbol-value 'x) 6)(defun bar (x y)	    ;[1] 1st instance of x  (let ((old-x x)	    ;[2] 2nd instance of x -- same as 1st instance?        (x y))		    ;[3] 3rd instance    (declare (special x))    (list old-x x)))(bar 'first 'second)	==>  (first second)    ;by either proposal herein(bar 'first 'second)	==>  (6 second)        ;by "hoisting", a la CLtL.Rationale:These semantics are simpler to understand.  Almost everyone feels thatthe example of CLtL p.155 is very unnatural.  LIMITED-HOISTING is less of a change to CLtL semantics; but NO-HOISTING seems more natural to most people since it restores a closer equivalence between LET forms and LAMBDA-expressions.  Also, several vendors report that customers frequently seem to assume the semantics of NO-HOISTING.Current practice:Most implementations implement the rules in CLtL, as exemplified bythe example on p.155.  Symbolics currently implements rules based onZetalisp which are different from both this proposal and Common Lisp.Symbolics plans to change to Common Lisp rules in the future.Cost to Implementors:Modest; some minor fixes will be necessary to to compilers, interpreters and "code walkers" that parse declarations.Cost to Users:Modest.  It is mostly moot since users tend to avoid the "hoisting"situations on special declarations.It is possible to mechanically examine a program to determine whetherits behavior would change under the new rules.  This permits animplementation to provide a transition tool to ease conversion to thenew definition.Cost of non-adoption:Serious non-portability of code, since not every implementor seems to agree on how to read the disputed rules of CLtL pp. 153-157; continuingconfusion in the user community.Performance impact:None.Benefits:Elimination of confusion; increase of portability between implementations.Esthetics:Simplifies the scoping issue; eliminates special-case scoping rules forSPECIAL declarations.Discussion:Only the SPECIAL declaration has semantic import for CL; bothproposals specify an incompatible change for this case, to "retract"the expansive scope stated or implied in CLtL.  All other declarationsare considered "advice" to an optimizing compiler, and should haveno semantic effect on correct programs.  However, programmers makinguse of such declarations may notice a larger difference in theNO-HOISTING proposal, since some of their INLINE, OPTIMIZE, TYPE,etc. declarations will no longer apply to the initial-value forms.One idiom which will be adversely affected by both of these proposals is:   (let ((*a* *a*))     ;; rebind *a* to it's "old" value     (declare (special *a*))     ...)where *a* has not been proclaimed special.  This idiom would likelyhave to be written as:   (let ((*a* (locally (declare (special *a*)) *a*)))     ;; rebind *a* to it's "old" value     (declare (special *a*))     ...)or [preferably!] *a* should be proclaimed special.  Similar idiots like this may be in use for LAMBDA-Expressions, or DEFUNs etc.On the other hand, the inadvertent "shadowing" which prevents the following LET's initial value forms from referencing the input argumentis handily solved by either proposal herein.  If neither of these proposals is not adopted, then the intent of the code for BAR:  (defun bar (x y)	      ;[1] 1st instance of x    (let ((old-x x)	      ;[2] 2nd instance of x -- same as 1st instance?	  (x y))	      ;[3] 3rd instance      (declare (special x))      (list old-x x)))would likely have to be expressed by introducing new LET contours:  (defun bar (x y)	      ;[1] 1st instance of x    (let ((old-x x))	      ;[2] 2nd instance of x -- same as 1st instance?      (let ((x y))	      ;[3] 3rd instance        (declare (special x))        (list old-x x))))The source of additional confusion  has long been that TYPE declarations had to be treated differently from all other declarations; this was because of the prohibition found on p158 of CLtL.  Given the acceptance of theDECLARE-TYPE-FREE proposal, it no longer is necessary to make an exception for it, nor to categorize declarations into "pervasive" and "non-pervasive", or  "free" and "bound".It is not the purpose of this proposal to alter, clarify or in any other way bear upon the scoping rules of variables in Common Lisp.However, a few reminders about these rules will help one understand the above prescription.  Except LET*, PROG*, DO*, LABELS, and MACROLET,all the other special forms of CLtL p154 which admit declarations have the property that the scope of the name binding does not include anyinitial value form.  As a review of these scopes, note:  -- for LET, FLET, MULTIPLE-VALUE-BIND, none of the initial value      forms are included in the variables' (or functions') scope;  -- for DO-<mumble>-SYMBOLS, the initial value forms are not included,     but the optional result forms are included;  -- for DO, DOLIST, and DOTIMES, the initial value forms are not      included, but the stepper forms and the optional result forms      are included;  -- for LET*, PROG*, and DO*, a variable's scope also includes the      remaining initial value forms, for subsequent variable bindings;  -- for LABELS and MACROLET, a function name's scope includes all the      code forms for the functions being defined by the special form      [a compiler writer must know how not to get into an infinite loop      of substitutions when there are 'in-line' declarations on these      mutually recursive names];  -- for a LAMBDA application, none of the explicit value forms are       included in the bound variable scoping;  however, the 'initform'     code (if any) for &optional, &key, and &aux bindings are included      in the same way as LET* does;  -- for DEFUN, DEFMACRO, DEFTYPE and DEFSETF follow the rules for     LAMBDA-Expressions (CLtL, Section 5.2.2, pp. 59-66).     Remember also that new name bindings "shadow" (after a fashion) any higher level binding or declarations.  E.g., presuming that no proclamations are in effect, consider the inner let bindings of:   (locally (declare (special x) (float y))      (let ((x 5) (y 10))        (print (+ x y))))then x is bound as local (not special); and y is bound with no particulartype information [because the 'y' being bound is a different variablethan the 'y' declared float in the outer scope].It has been suggested that compilers could be a bit more helpful in detecting anomalous bindings, such as in the LET* following:  (defun bar (x y)    (let* ((old-x x)           (x y)           (new-x x))      (declare (special x))      (list old-x x new-x)))The collection of variables named X in the LET* binding and initialforms includes both local (lexical) and special ones.*start*16591 00024 US Date:  9 Dec 88 17:00 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: DECLARATION-SCOPE (Version 4)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinterline-fold: noThis issue has two proposals, NO-HOISTING and LIMITED-HOISTING.Issue:         DECLARATION-SCOPEReferences:    Declaration Syntax (CLtL, Section 9.1, pp. 153-157)	       LAMBDA-Expressions (CLtL, Section 5.2.2, pp. 59-66)               Cleanup issue FLET-DECLARATIONS (accepted)               Cleanup issue DECLARE-TYPE-FREE (accepted)Category:      CHANGE/CLARIFICATIONEdit history:  V1: Hornig@Symbolics.COM -- 5 January 1988               Version 2, Moon, 2-Feb-1988 (edits based on discussion)               Version 3, Moon, 18-Sep-88, for private discussion between JonL and Moon               Version 4, JonL, 15-Nov-88 add 2nd proposal; major rewrite.Problem description:The description of the scope of declarations made with DECLARE is unclear (although unambiguous) and arguably a mistake.  At issue iswhether the scope of some or all of the declarations at the head ofa special form includes code appearing in any non-body part of that special form.  CLtL p.155 attempts to address the issue by classifying declarations into two classes -- "pervasive" and "non-pervasive" -- but it does not succeed very well.A particular question of interest is whether the initial value forms for LET, LET*, FLET, LABELS, DO, PROG etc. are included.  The rules of CLtL,on some cases, are clear enough to see that a declaration inside the special form is "hoisted" up and around the whole form, so as to include all the "initial value" forms (and "stepper" forms and "result" forms for those constructs that have them).  This means that lexical argument variable X in the following function is inaccessible inside the initial value forms of the LET:  (defun bar (x y)	    ;[1] 1st instance of x    (let ((old-x x)	    ;[2] 2nd instance of x -- same as 1st instance?	  (x y))	    ;[3] 3rd instance      (declare (special x))      (list old-x x)))The declaration intended for the binding of X[3] also alters thescoping of the reference of X[2]; likely, this was not an intended consequence. [This is a simplification of the example on CLtL p.155].In this discussion, the term "body" will include any "stepper" or "result" forms, such as might be found in a DO or DO-mumble-SYMBOLSconstruct.  The reasoning for this is that such forms are always included in the scope of all name bindings (if any) being established by the special form.  They form an extended part of the "body".Proposal (DECLARATION-SCOPE:NO-HOISTING)Specify that the scope of a declaration located at the head of a special form or lambda expression is as follows:  (1) it always includes the body forms [as well as any "stepper" or       "result" forms]  (2) it also includes the scope of the name binding, if any, to which       it applies [LET, LAMBDA, FLET, DO, etc. introduce "name bindings";       LOCALLY doesn't.];This very straightforward prescription depends on one rather subtlepoint, namely that the scope of name bindings is an already solvedquestion.  Whether or not a particular declaration affects an initialvalue form (such as for LET or LET*) depends _solely_ on whether it isapplied to a variable or function (name) being bound whose scopeincludes such forms.  In this sense, the above specification limits thescope of declarations for name bindings to be exactly the scope of thename binding itself -- i.e. "like variable".  Thus there would be no"hoisting" of the special declarations in the example cited in theproblem description.  [See the Discussion section for a review of the CL rules on variable/function-name scoping in special forms.]Those declarations not correlated with any name binding do not cover anyof the initial-value forms; their scope simply includes the body (as well as any "stepper" or "result" forms).  In a sense, the above specification limits the scope of these kinds of declarations to be the same as anarbitrary name binding in a LET or FLET construct -- i.e. "like variable".[See also the issue DECLARE-TYPE-FREE.]Thus there is to be no "hoisting" for declarations in special forms or lambda expressions; the only initial value forms affected by a declaration will be those included indirectly, by the effect, if any, that a declaration has on a name binding. A question may arise as to what it means for a declaration to "apply to", or "be correlated to" a name binding.  As stated above about variablescoping, this is an already solved question in Common Lisp; it is not the purpose of this proposal to alter, clarify or in any other way bear upon the basic _applicability_ rules of declarations in Common Lisp.  However, a few reminders about these rules will help one understand the above specification:  --  SPECIAL and TYPE declarations never apply to function bindings;  --  INLINE and FTYPE declarations never apply to variable bindings;   --  OPTIMIZE never applies to either kind of binding;  --  (<declaration> X) never applies to a binding of Y.The specific rules are for the most part distributed throughout the individual declaration definitions.  The name-applicibility issue for bindings must be specified independently of how the declaration scoping issue is decided, and should not be confused with that scoping issue.Proposal (DECLARATION-SCOPE:LIMITED-HOISTING)Specify that the scope of a declaration located at the head of a special form or lambda expression is as follows:  (1) it always includes the body forms [as well as any "stepper" or       "result" forms]  (2) if the declaration is applicable to a name binding in that form,      then it is limited to exactly the scope of that name binding [LET,       LAMBDA, FLET, etc. introduce "name bindings"; LOCALLY doesn't.];  (3) if the declaration is not applicable to a name binding in that form,      then it includes all the initial value forms, in addition to the      body forms.This very straightforward prescription depends on one rather subtle point, namely that the scope of name bindings is an already solved question.  This applies not only to LET and LET* variables, but to the &optional, &key and &aux variables of LAMBDA-Expressions.  In this sense, the above specification limits the scope of declarations for name bindings to be exactly the scope of the name binding itself.  Thus there would be no "hoisting" of the special declarations in the example cited in theproblem description.Those declarations not correlated with any name binding act as if theywere included in a new LOCALLY construct wrapped around the entirespecial form.  Thus they are not scoped like an arbitrary variable(or, "name binding") in that special form, but rather are "hoisted" up.Whether or not a declaration is "hoisted" up around the special form in which it occurs depends on whether or not it is "captured en passant" by a correlated name binding.A question may arise as to what it means for a declaration to "apply to", or "be correlated to" a name binding.  As stated above about variablescoping, this is an already solved question in Common Lisp; it is not the purpose of this proposal to alter, clarify or in any other way bear upon the basic _applicability_ rules of declarations in Common Lisp.  However, a few reminders about these rules will help one understand the above specification:  --  SPECIAL and TYPE declarations never apply to function bindings;  --  INLINE and FTYPE declarations never apply to variable bindings;   --  OPTIMIZE never applies to either kind of binding;  --  (<declaration> X) never applies to a binding of Y.The specific rules are for the most part distributed throughout the individual declaration definitions.  The name-applicibility issue for bindings must be specified independently of how the declaration scoping issue is decided, and should not be confused with that scoping issue.Examples:;;; The following example is from a common-lisp mailing list discussion;;;  (from code suggested by Pavel Curtis).   The question is whether or;;;  not the special declaration in FOO applies to the  (1+ x) form.(setf (symbol-value 'x) 6)(defun foo (x)				;a lexical binding of X  (print x)  (let ((x (1+ x)))			;is the second X special or not?    (declare (special x))		;`normal' declaration    (bar))  (1+ x))(defun bar () (print (locally (declare (special x)) x)))(foo 10)  will  printout of 10 and 11 by either proposal herein(foo 10)  will  printout of 10 and 7 by CLtL style "hoisting";;; The following example is due to Jim Boyce, of Lucid Inc.  It shows how;;;  the "hoisting" of the declaration inadvertently causes it to act more;;;  like a proclamation than a declaration; namely, the declaration is;;;  applied to two different variables (which happen to have the same;;;  name) -- the first variable is the lexical one bound on line [1] and;;;  the second variables is bound on line [3].  Whereas lexical scoping;;;  rules would say that the reference in line [2] is to the variable;;;  bound on line [1], the effect of the "hoisted" declaration is to;;;  make the line [1]'s variable inaccessible in the initial value forms.(setf (symbol-value 'x) 6)(defun bar (x y)	    ;[1] 1st instance of x  (let ((old-x x)	    ;[2] 2nd instance of x -- same as 1st instance?        (x y))		    ;[3] 3rd instance    (declare (special x))    (list old-x x)))(bar 'first 'second)	==>  (first second)    ;by either proposal herein(bar 'first 'second)	==>  (6 second)        ;by "hoisting", a la CLtL.Rationale:These semantics are simpler to understand.  Almost everyone feels thatthe example of CLtL p.155 is very unnatural.  LIMITED-HOISTING is less of a change to CLtL semantics; but NO-HOISTING seems more natural to most people since it restores a closer equivalence between LET forms and LAMBDA-expressions.  Also, several vendors report that customers frequently seem to assume the semantics of NO-HOISTING.Current practice:Most implementations implement the rules in CLtL, as exemplified bythe example on p.155.  Symbolics currently implements rules based onZetalisp which are different from both this proposal and Common Lisp.Symbolics plans to change to Common Lisp rules in the future.Cost to Implementors:Modest; some minor fixes will be necessary to to compilers, interpreters and "code walkers" that parse declarations.Cost to Users:Modest.  It is mostly moot since users tend to avoid the "hoisting"situations on special declarations.It is possible to mechanically examine a program to determine whetherits behavior would change under the new rules.  This permits animplementation to provide a transition tool to ease conversion to thenew definition.Cost of non-adoption:Serious non-portability of code, since not every implementor seems to agree on how to read the disputed rules of CLtL pp. 153-157; continuingconfusion in the user community.Performance impact:None.Benefits:Elimination of confusion; increase of portability between implementations.Esthetics:Simplifies the scoping issue; eliminates special-case scoping rules forSPECIAL declarations.Discussion:Only the SPECIAL declaration has semantic import for CL; bothproposals specify an incompatible change for this case, to "retract"the expansive scope stated or implied in CLtL.  All other declarationsare considered "advice" to an optimizing compiler, and should haveno semantic effect on correct programs.  However, programmers makinguse of such declarations may notice a larger difference in theNO-HOISTING proposal, since some of their INLINE, OPTIMIZE, TYPE,etc. declarations will no longer apply to the initial-value forms.One idiom which will be adversely affected by both of these proposals is:   (let ((*a* *a*))     ;; rebind *a* to it's "old" value     (declare (special *a*))     ...)where *a* has not been proclaimed special.  This idiom would likelyhave to be written as:   (let ((*a* (locally (declare (special *a*)) *a*)))     ;; rebind *a* to it's "old" value     (declare (special *a*))     ...)or [preferably!] *a* should be proclaimed special.  Similar idiots like this may be in use for LAMBDA-Expressions, or DEFUNs etc.On the other hand, the inadvertent "shadowing" which prevents the following LET's initial value forms from referencing the input argumentis handily solved by either proposal herein.  If neither of these proposals is not adopted, then the intent of the code for BAR:  (defun bar (x y)	      ;[1] 1st instance of x    (let ((old-x x)	      ;[2] 2nd instance of x -- same as 1st instance?	  (x y))	      ;[3] 3rd instance      (declare (special x))      (list old-x x)))would likely have to be expressed by introducing new LET contours:  (defun bar (x y)	      ;[1] 1st instance of x    (let ((old-x x))	      ;[2] 2nd instance of x -- same as 1st instance?      (let ((x y))	      ;[3] 3rd instance        (declare (special x))        (list old-x x))))The source of additional confusion  has long been that TYPE declarations had to be treated differently from all other declarations; this was because of the prohibition found on p158 of CLtL.  Given the acceptance of theDECLARE-TYPE-FREE proposal, it no longer is necessary to make an exception for it, nor to categorize declarations into "pervasive" and "non-pervasive", or  "free" and "bound".It is not the purpose of this proposal to alter, clarify or in any other way bear upon the scoping rules of variables in Common Lisp.However, a few reminders about these rules will help one understand the above prescription.  Except LET*, PROG*, DO*, LABELS, and MACROLET,all the other special forms of CLtL p154 which admit declarations have the property that the scope of the name binding does not include anyinitial value form.  As a review of these scopes, note:  -- for LET, FLET, MULTIPLE-VALUE-BIND, none of the initial value      forms are included in the variables' (or functions') scope;  -- for DO-<mumble>-SYMBOLS, the initial value forms are not included,     but the optional result forms are included;  -- for DO, DOLIST, and DOTIMES, the initial value forms are not      included, but the stepper forms and the optional result forms      are included;  -- for LET*, PROG*, and DO*, a variable's scope also includes the      remaining initial value forms, for subsequent variable bindings;  -- for LABELS and MACROLET, a function name's scope includes all the      code forms for the functions being defined by the special form      [a compiler writer must know how not to get into an infinite loop      of substitutions when there are 'in-line' declarations on these      mutually recursive names];  -- for a LAMBDA application, none of the explicit value forms are       included in the bound variable scoping;  however, the 'initform'     code (if any) for &optional, &key, and &aux bindings are included      in the same way as LET* does;  -- for DEFUN, DEFMACRO, DEFTYPE and DEFSETF follow the rules for     LAMBDA-Expressions (CLtL, Section 5.2.2, pp. 59-66).     Remember also that new name bindings "shadow" (after a fashion) any higher level binding or declarations.  E.g., presuming that no proclamations are in effect, consider the inner let bindings of:   (locally (declare (special x) (float y))      (let ((x 5) (y 10))        (print (+ x y))))then x is bound as local (not special); and y is bound with no particulartype information [because the 'y' being bound is a different variablethan the 'y' declared float in the outer scope].It has been suggested that compilers could be a bit more helpful in detecting anomalous bindings, such as in the LET* following:  (defun bar (x y)    (let* ((old-x x)           (x y)           (new-x x))      (declare (special x))      (list old-x x new-x)))The collection of variables named X in the LET* binding and initialforms includes both local (lexical) and special ones.        TITAN 
         TITAN 
           Z              Æ                     å                                        ¾       )      
ã       .      
       
      e                                        y             H              ³                     
       N              b             Ø      ?= $zº*start*16537 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 09 DEC 88 17:25:37 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 9 Dec 88  17:05:11 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 09 DEC 88 17:00:53 PSTDate: 9 Dec 88 17:00 PSTSender: masinter.paTo: x3j13@sail.stanford.eduSubject: Issue: DECLARATION-SCOPE (Version 4)From: cl-cleanup@sail.stanford.edureply-to: cl-cleanup@sail.stanford.educc: masinter.paline-fold: noMessage-ID: <881209-170053-1466@Xerox>This issue has two proposals, NO-HOISTING and LIMITED-HOISTING.!Issue:         DECLARATION-SCOPEReferences:    Declaration Syntax (CLtL, Section 9.1, pp. 153-157)	       LAMBDA-Expressions (CLtL, Section 5.2.2, pp. 59-66)               Cleanup issue FLET-DECLARATIONS (accepted)               Cleanup issue DECLARE-TYPE-FREE (accepted)Category:      CHANGE/CLARIFICATIONEdit history:  V1: Hornig@Symbolics.COM -- 5 January 1988               Version 2, Moon, 2-Feb-1988 (edits based on discussion)               Version 3, Moon, 18-Sep-88, for private discussion between JonL and Moon               Version 4, JonL, 15-Nov-88 add 2nd proposal; major rewrite.Problem description:The description of the scope of declarations made with DECLARE is unclear (although unambiguous) and arguably a mistake.  At issue iswhether the scope of some or all of the declarations at the head ofa special form includes code appearing in any non-body part of that special form.  CLtL p.155 attempts to address the issue by classifying declarations into two classes -- "pervasive" and "non-pervasive" -- but it does not succeed very well.A particular question of interest is whether the initial value forms for LET, LET*, FLET, LABELS, DO, PROG etc. are included.  The rules of CLtL,on some cases, are clear enough to see that a declaration inside the special form is "hoisted" up and around the whole form, so as to include all the "initial value" forms (and "stepper" forms and "result" forms for those constructs that have them).  This means that lexical argument variable X in the following function is inaccessible inside the initial value forms of the LET:  (defun bar (x y)	    ;[1] 1st instance of x    (let ((old-x x)	    ;[2] 2nd instance of x -- same as 1st instance?	  (x y))	    ;[3] 3rd instance      (declare (special x))      (list old-x x)))The declaration intended for the binding of X[3] also alters thescoping of the reference of X[2]; likely, this was not an intended consequence. [This is a simplification of the example on CLtL p.155].In this discussion, the term "body" will include any "stepper" or "result" forms, such as might be found in a DO or DO-mumble-SYMBOLSconstruct.  The reasoning for this is that such forms are always included in the scope of all name bindings (if any) being established by the special form.  They form an extended part of the "body".Proposal (DECLARATION-SCOPE:NO-HOISTING)Specify that the scope of a declaration located at the head of a special form or lambda expression is as follows:  (1) it always includes the body forms [as well as any "stepper" or       "result" forms]  (2) it also includes the scope of the name binding, if any, to which       it applies [LET, LAMBDA, FLET, DO, etc. introduce "name bindings";       LOCALLY doesn't.];This very straightforward prescription depends on one rather subtlepoint, namely that the scope of name bindings is an already solvedquestion.  Whether or not a particular declaration affects an initialvalue form (such as for LET or LET*) depends _solely_ on whether it isapplied to a variable or function (name) being bound whose scopeincludes such forms.  In this sense, the above specification limits thescope of declarations for name bindings to be exactly the scope of thename binding itself -- i.e. "like variable".  Thus there would be no"hoisting" of the special declarations in the example cited in theproblem description.  [See the Discussion section for a review of the CL rules on variable/function-name scoping in special forms.]Those declarations not correlated with any name binding do not cover anyof the initial-value forms; their scope simply includes the body (as well as any "stepper" or "result" forms).  In a sense, the above specification limits the scope of these kinds of declarations to be the same as anarbitrary name binding in a LET or FLET construct -- i.e. "like variable".[See also the issue DECLARE-TYPE-FREE.]Thus there is to be no "hoisting" for declarations in special forms or lambda expressions; the only initial value forms affected by a declaration will be those included indirectly, by the effect, if any, that a declaration has on a name binding. A question may arise as to what it means for a declaration to "apply to", or "be correlated to" a name binding.  As stated above about variablescoping, this is an already solved question in Common Lisp; it is not the purpose of this proposal to alter, clarify or in any other way bear upon the basic _applicability_ rules of declarations in Common Lisp.  However, a few reminders about these rules will help one understand the above specification:  --  SPECIAL and TYPE declarations never apply to function bindings;  --  INLINE and FTYPE declarations never apply to variable bindings;   --  OPTIMIZE never applies to either kind of binding;  --  (<declaration> X) never applies to a binding of Y.The specific rules are for the most part distributed throughout the individual declaration definitions.  The name-applicibility issue for bindings must be specified independently of how the declaration scoping issue is decided, and should not be confused with that scoping issue.Proposal (DECLARATION-SCOPE:LIMITED-HOISTING)Specify that the scope of a declaration located at the head of a special form or lambda expression is as follows:  (1) it always includes the body forms [as well as any "stepper" or       "result" forms]  (2) if the declaration is applicable to a name binding in that form,      then it is limited to exactly the scope of that name binding [LET,       LAMBDA, FLET, etc. introduce "name bindings"; LOCALLY doesn't.];  (3) if the declaration is not applicable to a name binding in that form,      then it includes all the initial value forms, in addition to the      body forms.This very straightforward prescription depends on one rather subtle point, namely that the scope of name bindings is an already solved question.  This applies not only to LET and LET* variables, but to the &optional, &key and &aux variables of LAMBDA-Expressions.  In this sense, the above specification limits the scope of declarations for name bindings to be exactly the scope of the name binding itself.  Thus there would be no "hoisting" of the special declarations in the example cited in theproblem description.Those declarations not correlated with any name binding act as if theywere included in a new LOCALLY construct wrapped around the entirespecial form.  Thus they are not scoped like an arbitrary variable(or, "name binding") in that special form, but rather are "hoisted" up.Whether or not a declaration is "hoisted" up around the special form in which it occurs depends on whether or not it is "captured en passant" by a correlated name binding.A question may arise as to what it means for a declaration to "apply to", or "be correlated to" a name binding.  As stated above about variablescoping, this is an already solved question in Common Lisp; it is not the purpose of this proposal to alter, clarify or in any other way bear upon the basic _applicability_ rules of declarations in Common Lisp.  However, a few reminders about these rules will help one understand the above specification:  --  SPECIAL and TYPE declarations never apply to function bindings;  --  INLINE and FTYPE declarations never apply to variable bindings;   --  OPTIMIZE never applies to either kind of binding;  --  (<declaration> X) never applies to a binding of Y.The specific rules are for the most part distributed throughout the individual declaration definitions.  The name-applicibility issue for bindings must be specified independently of how the declaration scoping issue is decided, and should not be confused with that scoping issue.Examples:;;; The following example is from a common-lisp mailing list discussion;;;  (from code suggested by Pavel Curtis).   The question is whether or;;;  not the special declaration in FOO applies to the  (1+ x) form.(setf (symbol-value 'x) 6)(defun foo (x)				;a lexical binding of X  (print x)  (let ((x (1+ x)))			;is the second X special or not?    (declare (special x))		;`normal' declaration    (bar))  (1+ x))(defun bar () (print (locally (declare (special x)) x)))(foo 10)  will  printout of 10 and 11 by either proposal herein(foo 10)  will  printout of 10 and 7 by CLtL style "hoisting";;; The following example is due to Jim Boyce, of Lucid Inc.  It shows how;;;  the "hoisting" of the declaration inadvertently causes it to act more;;;  like a proclamation than a declaration; namely, the declaration is;;;  applied to two different variables (which happen to have the same;;;  name) -- the first variable is the lexical one bound on line [1] and;;;  the second variables is bound on line [3].  Whereas lexical scoping;;;  rules would say that the reference in line [2] is to the variable;;;  bound on line [1], the effect of the "hoisted" declaration is to;;;  make the line [1]'s variable inaccessible in the initial value forms.(setf (symbol-value 'x) 6)(defun bar (x y)	    ;[1] 1st instance of x  (let ((old-x x)	    ;[2] 2nd instance of x -- same as 1st instance?        (x y))		    ;[3] 3rd instance    (declare (special x))    (list old-x x)))(bar 'first 'second)	==>  (first second)    ;by either proposal herein(bar 'first 'second)	==>  (6 second)        ;by "hoisting", a la CLtL.Rationale:These semantics are simpler to understand.  Almost everyone feels thatthe example of CLtL p.155 is very unnatural.  LIMITED-HOISTING is less of a change to CLtL semantics; but NO-HOISTING seems more natural to most people since it restores a closer equivalence between LET forms and LAMBDA-expressions.  Also, several vendors report that customers frequently seem to assume the semantics of NO-HOISTING.Current practice:Most implementations implement the rules in CLtL, as exemplified bythe example on p.155.  Symbolics currently implements rules based onZetalisp which are different from both this proposal and Common Lisp.Symbolics plans to change to Common Lisp rules in the future.Cost to Implementors:Modest; some minor fixes will be necessary to to compilers, interpreters and "code walkers" that parse declarations.Cost to Users:Modest.  It is mostly moot since users tend to avoid the "hoisting"situations on special declarations.It is possible to mechanically examine a program to determine whetherits behavior would change under the new rules.  This permits animplementation to provide a transition tool to ease conversion to thenew definition.Cost of non-adoption:Serious non-portability of code, since not every implementor seems to agree on how to read the disputed rules of CLtL pp. 153-157; continuingconfusion in the user community.Performance impact:None.Benefits:Elimination of confusion; increase of portability between implementations.Esthetics:Simplifies the scoping issue; eliminates special-case scoping rules forSPECIAL declarations.Discussion:Only the SPECIAL declaration has semantic import for CL; bothproposals specify an incompatible change for this case, to "retract"the expansive scope stated or implied in CLtL.  All other declarationsare considered "advice" to an optimizing compiler, and should haveno semantic effect on correct programs.  However, programmers makinguse of such declarations may notice a larger difference in theNO-HOISTING proposal, since some of their INLINE, OPTIMIZE, TYPE,etc. declarations will no longer apply to the initial-value forms.One idiom which will be adversely affected by both of these proposals is:   (let ((*a* *a*))     ;; rebind *a* to it's "old" value     (declare (special *a*))     ...)where *a* has not been proclaimed special.  This idiom would likelyhave to be written as:   (let ((*a* (locally (declare (special *a*)) *a*)))     ;; rebind *a* to it's "old" value     (declare (special *a*))     ...)or [preferably!] *a* should be proclaimed special.  Similar idiots like this may be in use for LAMBDA-Expressions, or DEFUNs etc.On the other hand, the inadvertent "shadowing" which prevents the following LET's initial value forms from referencing the input argumentis handily solved by either proposal herein.  If neither of these proposals is not adopted, then the intent of the code for BAR:  (defun bar (x y)	      ;[1] 1st instance of x    (let ((old-x x)	      ;[2] 2nd instance of x -- same as 1st instance?	  (x y))	      ;[3] 3rd instance      (declare (special x))      (list old-x x)))would likely have to be expressed by introducing new LET contours:  (defun bar (x y)	      ;[1] 1st instance of x    (let ((old-x x))	      ;[2] 2nd instance of x -- same as 1st instance?      (let ((x y))	      ;[3] 3rd instance        (declare (special x))        (list old-x x))))The source of additional confusion  has long been that TYPE declarations had to be treated differently from all other declarations; this was because of the prohibition found on p158 of CLtL.  Given the acceptance of theDECLARE-TYPE-FREE proposal, it no longer is necessary to make an exception for it, nor to categorize declarations into "pervasive" and "non-pervasive", or  "free" and "bound".It is not the purpose of this proposal to alter, clarify or in any other way bear upon the scoping rules of variables in Common Lisp.However, a few reminders about these rules will help one understand the above prescription.  Except LET*, PROG*, DO*, LABELS, and MACROLET,all the other special forms of CLtL p154 which admit declarations have the property that the scope of the name binding does not include anyinitial value form.  As a review of these scopes, note:  -- for LET, FLET, MULTIPLE-VALUE-BIND, none of the initial value      forms are included in the variables' (or functions') scope;  -- for DO-<mumble>-SYMBOLS, the initial value forms are not included,     but the optional result forms are included;  -- for DO, DOLIST, and DOTIMES, the initial value forms are not      included, but the stepper forms and the optional result forms      are included;  -- for LET*, PROG*, and DO*, a variable's scope also includes the      remaining initial value forms, for subsequent variable bindings;  -- for LABELS and MACROLET, a function name's scope includes all the      code forms for the functions being defined by the special form      [a compiler writer must know how not to get into an infinite loop      of substitutions when there are 'in-line' declarations on these      mutually recursive names];  -- for a LAMBDA application, none of the explicit value forms are       included in the bound variable scoping;  however, the 'initform'     code (if any) for &optional, &key, and &aux bindings are included      in the same way as LET* does;  -- for DEFUN, DEFMACRO, DEFTYPE and DEFSETF follow the rules for     LAMBDA-Expressions (CLtL, Section 5.2.2, pp. 59-66).     Remember also that new name bindings "shadow" (after a fashion) any higher level binding or declarations.  E.g., presuming that no proclamations are in effect, consider the inner let bindings of:   (locally (declare (special x) (float y))      (let ((x 5) (y 10))        (print (+ x y))))then x is bound as local (not special); and y is bound with no particulartype information [because the 'y' being bound is a different variablethan the 'y' declared float in the outer scope].It has been suggested that compilers could be a bit more helpful in detecting anomalous bindings, such as in the LET* following:  (defun bar (x y)    (let* ((old-x x)           (x y)           (new-x x))      (declare (special x))      (list old-x x new-x)))The collection of variables named X in the LET* binding and initialforms includes both local (lexical) and special ones.*start*04954 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 20 JUN 88 07:30:56 PDTReceived: from CLI.COM by SAIL.Stanford.EDU with TCP; 20 Jun 88  07:27:35 PDTReceived: by CLI.COM (4.0/1); Mon, 20 Jun 88 09:22:45 CDTDate: Mon, 20 Jun 88 09:22:45 CDTFrom: Robert S. Boyer <boyer@CLI.COM>Message-Id: <8806201422.AA07863@CLI.COM>To: cl-cleanup@sail.stanford.eduCc: yuasa%tutics.tut.junet@utokyo-relay.CSNET, Masinter.paSubject: KCL scoping bug?Larry,Here is all the correspondence on that particular issue from the kclmailing list.From: vax135!melmac!ilan@ucbvax.Berkeley.EDUDate: Tue, 3 May 88 10:25:26 edtTo: ilan@ucbvax.Berkeley.EDU, vax135!froggy.ics.utexas.edu!boyerSubject: KCL scoping bug?Hi,I'm not sure how to post stuff to the KCL board at the moment, so I'msending this to you.  If you deem it worthwhile please post itto the KCL mailing-list.The following produces a scoping error in the interpreter (June 3, 87) -the compiler handles the code correctly. (The example is lifted directly from CLtL p. 155).--------->(setq x 'x-dyn z 'z-dyn)Z-DYN>(load "nonsense.l")Loading nonsense.lFinished loading nonsense.lT>#'foo(LAMBDA-BLOCK FOO (&REST ARGS) (PRINT ARGS) (LIST ARGS))>#'nonsense(LAMBDA-BLOCK NONSENSE (K X Z)  (FOO Z X)  (LET ((J (FOO K X)) (X (* K K)))    (DECLARE (INLINE FOO) (SPECIAL X Z))    (FOO X J Z)))>(nonsense 1 2 3)(3 2)(1 2)			;;; <---- SHOULD BE (1 X-DYN)(1 ((1 2)) Z-DYN)	;;; <---- SHOULD BE (1 ((1 X-DYN)) Z-DYN)((1 ((1 2)) Z-DYN))	;;; <---- SHOULD BE ((1 ((1 X-DYN)) Z-DYN))>(compile 'nonsense)End of Pass 1.  End of Pass 2.  OPTIMIZE levels: Safety=0 (No runtime error checking), Space=0, Speed=3NONSENSE>(nonsense 1 2 3)(3 2)(1 X-DYN)(1 ((1 X-DYN)) Z-DYN)((1 ((1 X-DYN)) Z-DYN))--------------------Ilan Caron ..!ucbvax!vax135!lcuxlj!ilanFrom: vax135!melmac!ilan@ucbvax.Berkeley.EDUDate: Tue, 24 May 88 13:41:32 edtMessage-Id: <8805241741.AA29869@vax135.UUCP>To: ilan@ucbvax.Berkeley.EDU, vax135!cli.com!kclSubject: KCL scoping bug?A couple of weeks ago I posted what seemed to be a KCL interpreterscoping bug using the example from CLtL p. 155.Having seen no response to what seems to be a potential sourceof major confusion, I'm reposting the bug - this time on a simplerpiece of code.  The interpreter doesn't make a special referencefor Y in spite of the special declaration.Please note that the bug only manifests itself when interpreted, thecompiler handles the situation correctly.------------------KCL (June 3, 1987)------------------Starts dribbling to x (1988/5/25, 2:29:20).NIL> #'foo(LAMBDA-BLOCK FOO (X Y Z)  (LET ((X Y) (Y Z)) (DECLARE (SPECIAL Y Z)) (LIST X Y Z)))>(setq x 'dyn-x y 'dyn-y z 'dyn-z)DYN-Z>(foo 'lex-x 'lex-y 'lex-z)(LEX-Y DYN-Z DYN-Z)			;;; <---- should be (DYN-Y ...)> (compile 'foo); (DEFUN FOO ...) is being compiled.;; Warning: The variable X is not used.;; Warning: The variable Y is not used.;; Warning: The variable Z is not used.End of Pass 1.  End of Pass 2.  OPTIMIZE levels: Safety=0 (No runtime error checking), Space=0, Speed=3FOO>(foo 'lex-x 'lex-y 'lex-z)(DYN-Y DYN-Z DYN-Z)			;;; <---- this is correct>-----------ilan caronDate: Thu, 26 May 88 10:10:26 jstFrom: Taiichi Yuasa <yuasa%tutics.tut.junet@relay.cs.net>To: kcl@cli.comSubject: Re: KCL scoping bug?Here's the story.I noticed long time ago that there's an inconsistency as youposted.  However, at that time I did not know which interpretationis correct.  So, I decided to leave the inconsistency untilsomeone (x3j13, perhaps) clarifies which is correct.  I still do notknow which is correct.  It's easy to solve the inconsistency.Is there any general consensus on this matter?If most people agree that the compiler is correct and the interpreteris wrong, I'm happy to fix the bug immediately.-- TaiichiReceived: by CLI.COM (4.0/1); Tue, 31 May 88 12:41:47 CDTReceived: by ucbvax.Berkeley.EDU (5.59/1.28)	id AA01603; Tue, 31 May 88 09:18:42 PDTFrom: vax135!melmac!ilan@ucbvax.Berkeley.EDUDate: Tue, 31 May 88 12:13:03 edtMessage-Id: <8805311613.AA03145@vax135.UUCP>To: vax135!cli.com!kclSubject: Re:  KCL scoping bug?The example and explanation on p. 155 CLtL makes it prettyclear that the compiler is correct, (i.e. that the specialdeclaration also applies to references within the initformsof a LET) - in particular, The Book says: "The referenceto X in the second call to FOO is also a special reference".------------------------------------------------------------For those interested, the relevant nonsensical code is:  (defun nonsense (k x z)    (foo z x)    (let     (      (j (foo k x))	;;; <--- the problematic reference to X      (x (* k k))      )     (declare (inline foo) (special x z))     (foo x j z)     )    )--ilan caron*start*04954 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU by Xerox.COM ; 20 JUN 88 07:30:56 PDTReceived: from CLI.COM by SAIL.Stanford.EDU with TCP; 20 Jun 88  07:27:35 PDTReceived: by CLI.COM (4.0/1); Mon, 20 Jun 88 09:22:45 CDTDate: Mon, 20 Jun 88 09:22:45 CDTFrom: Robert S. Boyer <boyer@CLI.COM>Message-Id: <8806201422.AA07863@CLI.COM>To: cl-cleanup@sail.stanford.eduCc: yuasa%tutics.tut.junet@utokyo-relay.CSNET, Masinter.paSubject: KCL scoping bug?Larry,Here is all the correspondence on that particular issue from the kclmailing list.From: vax135!melmac!ilan@ucbvax.Berkeley.EDUDate: Tue, 3 May 88 10:25:26 edtTo: ilan@ucbvax.Berkeley.EDU, vax135!froggy.ics.utexas.edu!boyerSubject: KCL scoping bug?Hi,I'm not sure how to post stuff to the KCL board at the moment, so I'msending this to you.  If you deem it worthwhile please post itto the KCL mailing-list.The following produces a scoping error in the interpreter (June 3, 87) -the compiler handles the code correctly. (The example is lifted directly from CLtL p. 155).--------->(setq x 'x-dyn z 'z-dyn)Z-DYN>(load "nonsense.l")Loading nonsense.lFinished loading nonsense.lT>#'foo(LAMBDA-BLOCK FOO (&REST ARGS) (PRINT ARGS) (LIST ARGS))>#'nonsense(LAMBDA-BLOCK NONSENSE (K X Z)  (FOO Z X)  (LET ((J (FOO K X)) (X (* K K)))    (DECLARE (INLINE FOO) (SPECIAL X Z))    (FOO X J Z)))>(nonsense 1 2 3)(3 2)(1 2)			;;; <---- SHOULD BE (1 X-DYN)(1 ((1 2)) Z-DYN)	;;; <---- SHOULD BE (1 ((1 X-DYN)) Z-DYN)((1 ((1 2)) Z-DYN))	;;; <---- SHOULD BE ((1 ((1 X-DYN)) Z-DYN))>(compile 'nonsense)End of Pass 1.  End of Pass 2.  OPTIMIZE levels: Safety=0 (No runtime error checking), Space=0, Speed=3NONSENSE>(nonsense 1 2 3)(3 2)(1 X-DYN)(1 ((1 X-DYN)) Z-DYN)((1 ((1 X-DYN)) Z-DYN))--------------------Ilan Caron ..!ucbvax!vax135!lcuxlj!ilanFrom: vax135!melmac!ilan@ucbvax.Berkeley.EDUDate: Tue, 24 May 88 13:41:32 edtMessage-Id: <8805241741.AA29869@vax135.UUCP>To: ilan@ucbvax.Berkeley.EDU, vax135!cli.com!kclSubject: KCL scoping bug?A couple of weeks ago I posted what seemed to be a KCL interpreterscoping bug using the example from CLtL p. 155.Having seen no response to what seems to be a potential sourceof major confusion, I'm reposting the bug - this time on a simplerpiece of code.  The interpreter doesn't make a special referencefor Y in spite of the special declaration.Please note that the bug only manifests itself when interpreted, thecompiler handles the situation correctly.------------------KCL (June 3, 1987)------------------Starts dribbling to x (1988/5/25, 2:29:20).NIL> #'foo(LAMBDA-BLOCK FOO (X Y Z)  (LET ((X Y) (Y Z)) (DECLARE (SPECIAL Y Z)) (LIST X Y Z)))>(setq x 'dyn-x y 'dyn-y z 'dyn-z)DYN-Z>(foo 'lex-x 'lex-y 'lex-z)(LEX-Y DYN-Z DYN-Z)			;;; <---- should be (DYN-Y ...)> (compile 'foo); (DEFUN FOO ...) is being compiled.;; Warning: The variable X is not used.;; Warning: The variable Y is not used.;; Warning: The variable Z is not used.End of Pass 1.  End of Pass 2.  OPTIMIZE levels: Safety=0 (No runtime error checking), Space=0, Speed=3FOO>(foo 'lex-x 'lex-y 'lex-z)(DYN-Y DYN-Z DYN-Z)			;;; <---- this is correct>-----------ilan caronDate: Thu, 26 May 88 10:10:26 jstFrom: Taiichi Yuasa <yuasa%tutics.tut.junet@relay.cs.net>To: kcl@cli.comSubject: Re: KCL scoping bug?Here's the story.I noticed long time ago that there's an inconsistency as youposted.  However, at that time I did not know which interpretationis correct.  So, I decided to leave the inconsistency untilsomeone (x3j13, perhaps) clarifies which is correct.  I still do notknow which is correct.  It's easy to solve the inconsistency.Is there any general consensus on this matter?If most people agree that the compiler is correct and the interpreteris wrong, I'm happy to fix the bug immediately.-- TaiichiReceived: by CLI.COM (4.0/1); Tue, 31 May 88 12:41:47 CDTReceived: by ucbvax.Berkeley.EDU (5.59/1.28)	id AA01603; Tue, 31 May 88 09:18:42 PDTFrom: vax135!melmac!ilan@ucbvax.Berkeley.EDUDate: Tue, 31 May 88 12:13:03 edtMessage-Id: <8805311613.AA03145@vax135.UUCP>To: vax135!cli.com!kclSubject: Re:  KCL scoping bug?The example and explanation on p. 155 CLtL makes it prettyclear that the compiler is correct, (i.e. that the specialdeclaration also applies to references within the initformsof a LET) - in particular, The Book says: "The referenceto X in the second call to FOO is also a special reference".------------------------------------------------------------For those interested, the relevant nonsensical code is:  (defun nonsense (k x z)    (foo z x)    (let     (      (j (foo k x))	;;; <--- the problematic reference to X      (x (* k k))      )     (declare (inline foo) (special x z))     (foo x j z)     )    )--ilan caron*start*00892 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 26 OCT 88 15:46:56 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 26 Oct 88  15:45:13 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 26 OCT 88 15:44:20 PDTDate: 26 Oct 88 15:44 PDTFrom: masinter.paSubject: Re: issue DECLARATION-SCOPEIn-reply-to: Jon L White <jonl@lucid.com>'s message of Fri, 21 Oct 88 19:49:49 PDTTo: Jon L White <jonl@lucid.com>cc: sandra%defun@cs.utah.edu, cl-cleanup@sail.stanford.eduMessage-ID: <881026-154420-14099@Xerox>I like your summary in this last message. I hope some form of it will getinto the next revision. Do you have an ETA on a revision for us?I want to make sure we get some of these harder issues done sooner so wehave time to get them "right".