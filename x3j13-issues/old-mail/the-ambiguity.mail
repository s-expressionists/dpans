*start*04436 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 OCT 88 13:06:45 PDTReceived: from void.ai.mit.edu by SAIL.Stanford.EDU with TCP; 21 Oct 88  13:03:05 PDTReceived: by void.ai.mit.edu (5.59/1.5)	id AA02556; Fri, 21 Oct 88 16:05:49 EDTDate: Fri, 21 Oct 88 16:05:49 EDTFrom: jar@void.ai.mit.edu (Jonathan Rees)Message-Id: <8810212005.AA02556@void.ai.mit.edu>To: cl-cleanup@sail.stanford.eduSubject: Issue: THE-AMBIGUITYReply-To: jar@zurich.ai.mit.eduI hear that the issue deadline has past, but this is only aquestion of clarification, and it seems to me like a necessaryclarification.Issue:        THE-AMBIGUITYReferences:   THE (page 161)Category:     CLARIFICATIONEdit history: 21-Oct-88, version 1 by ReesStatus:	      For internal discussionProblem description:  CLtL does not explicitly say whether the type specifier in a THE  form may be any type specifier or must be a type specifier suitable  for discrimination.  Although THE is decsribed as a "declaration"  form, some CL implementations have assumed that the specifier must  be for discrimination, and disallow e.g.    (THE (FUNCTION (T T) CONS) #'CONS)  We should either say that the implementations are right, or  explicitly say that they are wrong, since this case is easily  overlooked.Proposal (THE-AMBIGUITY:FOR-DECLARATION):  Clarify that the type specifier in	(THE type exp)  may be any valid type specifier.  In the case that exp returns one  value and type is not a VALUES type specifier, (THE type exp) is  equivalent to	(LET ((g exp))	  (DECLARE (TYPE type g))	  g)  where "g" is a gensym.  Proposal (THE-AMBIGUITY:FOR-DISCRIMINATION):  Clarify that the type specifier in	(THE type exp)  must be a valid type for discrimination, as for TYPEP, or it must  be of the form (VALUES type*) where type* are all valid for declaration.Current practice:  The Symbolics Genera and VAX LISP V2.2 interpreters signal errors for	(THE (FUNCTION (T T) CONS) #'CONS),  but this may not be intentional.  CLtL would seem to allow it.Test case:  (THE (FUNCTION (T T) CONS) #'CONS),  should return the CONS function under THE-AMBIGUITY:FOR-DISCRIMINATION,  and should be an error under THE-AMBIGUITY:FOR-DECLARATION.Cost to implementors:  Trivial cost for THE-AMBIGUITY:FOR-DISCRIMINATION; this is a compatible  restriction.  For THE-AMBIGUITY:FOR-DECLARATION, implementations that do not  already allow arbitrary type specifiers but which want to check that  the type in a THE is satisfied would have to create an internal  version of TYPEP which could manage not to signal invalid-type-specifier  errors in those situations where TYPEP would because the type is a  declaration-only one.Cost to users:  Users of implementations that support THE-AMBIGUITY:FOR-DECLARATION  might have to remove or change some uses of THE in their code if the  opposing alternative is adopted.Benefits:  Either way, an ambiguity in the language specification would be clarified.Aesthetics:  THE-AMBIGUITY:FOR-DECLARATION would seem to be more consistent with  DECLARE and with the intent of THE, which is supposed to be a way to  provide information for documentation and for the benefit of compilation.Discussion:  Rees supports THE-AMBIGUITY:FOR-DECLARATION.  Appropriate error situation terminology must be chosen for the  situation that a THE declaration (or other declaration) is  unsatisfied, but that must be done regardless of this proposal.  This proposal would suggest that a function should be added to CL to  do the checking that THE would want to do:	  (PROBABLY-TYPEP object type-spec)  [terrible name of course] returns multiple values a la SUBTYPEP: T T  if the object definitely has the type, NIL T if it definitely  doesn't, and T NIL (or NIL NIL?) otherwise.  Assuming that an  interpreted THE-expression actually checks types, you could almost  define this function using the condition system and EVAL.  (Ugh!)  Without PROBABLY-TYPEP, a meta-circular interpreter is more  difficult to write.  If a suitable name was found for this function, the additional  functionality could be suggested as an independent proposal, since  regardless of the outcome of this issue, the functionality is still  useful for checking DECLARE's.*start*01356 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 OCT 88 13:48:44 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 21 Oct 88  13:47:36 PDTReceived: from Cabernet.ms by ArpaGateway.ms ; 21 OCT 88 13:38:34 PDTDate: 21 Oct 88 13:38 PDTFrom: masinter.paSubject: Re: Issue: THE-AMBIGUITYIn-reply-to: jar@void.ai.mit.edu (Jonathan Rees)'s message of Fri, 21 Oct 88 16:05:49 EDTTo: jar@zurich.ai.mit.educc: cl-cleanup@sail.stanford.eduMessage-ID: <881021-133834-6458@Xerox>We've always said that issues that arise during the editorial process willstill be accepted. I'm trying to cut off the flood of "wouldn't it be niceif..."'s. Its probably important for us to put off new issues until we getthe letter ballot for all of the old ones resolved. (I have your name downnext to a couple of them.)On your proposed implementation: one string of issues that I still hope wecan resolve (if not by first draft) is to specify more fully the types oferrors signalled. CONDITIONS:INVALID-TYPE-SPECIFIER seems like a reasonableerror for TYPEP to signal if it is given one. An implementation of THEmight want to handler-bind that particular condition, although it would befree to do something else instead.*start*01389 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 OCT 88 14:03:39 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 21 Oct 88  14:00:30 PDTReceived: from blacksox ([192.9.201.39]) by heavens-gate.lucid.com id AA00402g; Fri, 21 Oct 88 14:00:10 PDTReceived: by blacksox id AA00251g; Fri, 21 Oct 88 13:56:14 pdtDate: Fri, 21 Oct 88 13:56:14 pdtFrom: Eric Benson <eb@lucid.com>Message-Id: <8810212056.AA00251@blacksox>To: jar@zurich.ai.mit.eduCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Jonathan Rees's message of Fri, 21 Oct 88 16:05:49 EDT <8810212005.AA02556@void.ai.mit.edu>Subject: Issue: THE-AMBIGUITY   Date: Fri, 21 Oct 88 16:05:49 EDT   From: jar@void.ai.mit.edu (Jonathan Rees)   Reply-To: jar@zurich.ai.mit.edu   Proposal (THE-AMBIGUITY:FOR-DISCRIMINATION):     Clarify that the type specifier in	   (THE type exp)     must be a valid type for discrimination, as for TYPEP, or it must     be of the form (VALUES type*) where type* are all valid for declaration.								 ^^^^^^^^^^^You mean "discrimination", right?By the way, I support FOR-DECLARATION.  Lucid CL has the same bug inthe interpreter as the others (a "bug" assuming FOR-DECLARATION).TYPEP is used to check the legality of the type specifier in THE.*start*00928 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 21 OCT 88 15:13:20 PDTReceived: from void.ai.mit.edu by SAIL.Stanford.EDU with TCP; 21 Oct 88  15:11:34 PDTReceived: by void.ai.mit.edu (5.59/1.5)	id AA02583; Fri, 21 Oct 88 18:14:02 EDTDate: Fri, 21 Oct 88 18:14:02 EDTFrom: jar@void.ai.mit.edu (Jonathan Rees)Message-Id: <8810212214.AA02583@void.ai.mit.edu>To: eb@lucid.comCc: cl-cleanup@sail.stanford.eduIn-Reply-To: Eric Benson's message of Fri, 21 Oct 88 13:56:14 pdt <8810212056.AA00251@blacksox>Subject: Issue: THE-AMBIGUITYReply-To: jar@zurich.ai.mit.edu   Date: Fri, 21 Oct 88 13:56:14 pdt   From: Eric Benson <eb@lucid.com>      Proposal (THE-AMBIGUITY:FOR-DISCRIMINATION): ... for declaration.					                   ^^^^^^^^^^^   You mean "discrimination", right?Right.*start*01725 00024 US Return-Path: <jar@void.ai.mit.edu>Received: from void.ai.mit.edu ([18.26.0.158]) by Xerox.COM ; 21 OCT 88 15:24:37 PDTReceived: by void.ai.mit.edu (5.59/1.5)	id AA02596; Fri, 21 Oct 88 18:27:19 EDTDate: Fri, 21 Oct 88 18:27:19 EDTFrom: jar@void.ai.mit.edu (Jonathan Rees)Message-Id: <8810212227.AA02596@void.ai.mit.edu>To: masinter.paCc: cl-cleanup@sail.stanford.eduIn-Reply-To: masinter.pa@Xerox.COM's message of 21 Oct 88 13:38 PDT <881021-133834-6458@Xerox>Subject: Issue: THE-AMBIGUITYReply-To: jar@zurich.ai.mit.edu   Date: 21 Oct 88 13:38 PDT   From: masinter.pa@Xerox.COM   On your proposed implementation: one string of issues that I still hope we   can resolve (if not by first draft) is to specify more fully the types of   errors signalled. CONDITIONS:INVALID-TYPE-SPECIFIER seems like a reasonable   error for TYPEP to signal if it is given one. An implementation of THE   might want to handler-bind that particular condition, although it would be   free to do something else instead.This implementation doesn't quite work because then there'd be no wayto distinguish between	(the (integer you lose big) #'cons)and	(the (function (t t) cons) #'cons),the first of which should be an error and the second of which shouldn't.I think there would have to be a distinct condition type, maybeINAPPROPRIATE-TYPE-SPECIFIER, for valid type specifiers that are usedin the wrong context.Also, in considering possible ways in which the type-checking logicfor THE and DECLARE might work, don't forget things like	(the (not (function (t t) integer)) 7),which you would want to signal an error.  I don't think this can bedone with only TYPEP and conditions.Jonathan*start*01971 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 25 OCT 88 13:32:22 PDTReceived: from ti.com by SAIL.Stanford.EDU with TCP; 25 Oct 88  13:30:40 PDTReceived: by ti.com id AA01365; Mon, 24 Oct 88 20:04:07 CDTReceived: from Kelvin by tilde id AA29658; Mon, 24 Oct 88 19:59:19 CDTMessage-Id: <2802733274-1499644@Kelvin>Sender: GRAY@Kelvin.csc.ti.comDate: Mon, 24 Oct 88 20:01:14 CDTFrom: David N Gray <Gray@DSG.csc.ti.com>To: jar@ZURICH.AI.MIT.EDUCc: cl-cleanup@SAIL.STANFORD.EDUSubject: Re: Issue: THE-AMBIGUITYIn-Reply-To: Msg of Fri, 21 Oct 88 16:05:49 EDT from Jonathan Rees <jar@void.ai.mit.edu>> Current practice:> >   The Symbolics Genera and VAX LISP V2.2 interpreters signal errors for> > 	(THE (FUNCTION (T T) CONS) #'CONS),> >   but this may not be intentional.  CLtL would seem to allow it.The TI Explorer permits this, so is consistent with proposalTHE-AMBIGUITY:FOR-DECLARATION. > Test case:> >   (THE (FUNCTION (T T) CONS) #'CONS),> >   should return the CONS function under THE-AMBIGUITY:FOR-DISCRIMINATION,>   and should be an error under THE-AMBIGUITY:FOR-DECLARATION.Shouldn't that be the other way around?>   For THE-AMBIGUITY:FOR-DECLARATION, implementations that do not>   already allow arbitrary type specifiers but which want to check that>   the type in a THE is satisfied would have to create an internal>   version of TYPEP which could manage not to signal invalid-type-specifier>   errors in those situations where TYPEP would because the type is a>   declaration-only one.What you really want is an internal function that tests whether a typespecifier is valid for TYPEP and the compiler uses that to decidewhether to generate a call to TYPEP.  Since types should be defined beforebeing used in a declaration, there shouldn't be any need to postpone thisdecision to runtime.*start*05029 00024 US Date: 11 Jan 89 23:14 PSTSender: masinter.paSubject: Issue: THE-AMBIGUITY (Version 2)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinterline-fold: NoThis issue has two proposals.Forum:        cleanupIssue:        THE-AMBIGUITYReferences:   THE (page 161)Category:     CLARIFICATIONEdit history: 21-Oct-88, version 1 by Rees              11-Jan-89, version 2 by Masinter (fix typos)Problem description:  CLtL does not explicitly say whether the type specifier in a THE  form may be any type specifier or must be a type specifier suitable  for discrimination.  Although THE is decsribed as a "declaration"  form, some CL implementations have assumed that the specifier must  be for discrimination, and disallow e.g.,    (THE (FUNCTION (T T) CONS) #'CONS)  We should either say that the implementations are right, or  explicitly say that they are wrong, since this case is easily  overlooked.Proposal (THE-AMBIGUITY:FOR-DECLARATION):  Clarify that the type specifier in	(THE type exp)  may be any valid type specifier.  In the case that exp returns one  value and type is not a VALUES type specifier, (THE type exp) is  equivalent to	(LET ((g exp))	  (DECLARE (TYPE type g))	  g)  where "g" is a gensym.  Proposal (THE-AMBIGUITY:FOR-DISCRIMINATION):  Clarify that the type specifier in	(THE type exp)  must be a valid type for discrimination, as for TYPEP, or it must  be of the form (VALUES type*) where type* are all valid for discrimination.Current practice:  The Symbolics Genera and VAX LISP V2.2 interpreters signal errors for	(THE (FUNCTION (T T) CONS) #'CONS),  but this may not be intentional.  CLtL would seem to allow it.Test case:  (THE (FUNCTION (T T) CONS) #'CONS),  should return the CONS function under FOR-DECLARATION,  and should be an error under FOR-DISCRIMINATION.Cost to implementors:  Trivial cost for THE-AMBIGUITY:FOR-DISCRIMINATION; this is a compatible  restriction.  For THE-AMBIGUITY:FOR-DECLARATION, implementations that do not  already allow arbitrary type specifiers but which want to check that  the type in a THE is satisfied would have to create an internal  version of TYPEP which could manage not to signal invalid-type-specifier  errors in those situations where TYPEP would because the type is a  declaration-only one.Cost to users:  Users of implementations that support THE-AMBIGUITY:FOR-DECLARATION  might have to remove or change some uses of THE in their code if the  opposing alternative is adopted.Benefits:  Either way, an ambiguity in the language specification would be clarified.Aesthetics:  THE-AMBIGUITY:FOR-DECLARATION would seem to be more consistent with  DECLARE and with the intent of THE, which is supposed to be a way to  provide information for documentation and for the benefit of compilation.Discussion:  Rees supports THE-AMBIGUITY:FOR-DECLARATION.  Appropriate error situation terminology must be chosen for the  situation that a THE declaration (or other declaration) is  unsatisfied, but that must be done regardless of this proposal.  This proposal would suggest that a function should be added to CL to  do the checking that THE would want to do:	  (PROBABLY-TYPEP object type-spec)  [terrible name of course] returns multiple values a la SUBTYPEP: T T  if the object definitely has the type, NIL T if it definitely  doesn't, and T NIL (or NIL NIL?) otherwise.  Assuming that an  interpreted THE-expression actually checks types, you could almost  define this function using the condition system and EVAL.  (Ugh!)  Without PROBABLY-TYPEP, a meta-circular interpreter is more  difficult to write.  If a suitable name was found for this function, the additional  functionality could be suggested as an independent proposal, since  regardless of the outcome of this issue, the functionality is still  useful for checking DECLARE's.  Various implementation mechanisms were discussed for dealing  with THE checking.  Are there any remaining type specifiers beyond the list form  of the FUNCTION type that differ between "declaration" and  "discrimination"?  "I support FOR-DECLARATION.  Lucid CL has the same bug in  the interpreter as the others (a "bug" assuming FOR-DECLARATION).  TYPEP is used to check the legality of the type specifier in THE."  In considering possible ways in which the type-checking logic  for THE and DECLARE might work, don't forget things like	(the (not (function (t t) integer)) 7),  which you would want to signal an error.  I don't think this can be  done with only TYPEP and conditions.        TITAN 
          TITAN 
                                                                        Y             õ       *             -       Ë              ²              •             Î              ²       
       O              Û             Ý      I zº*start*05032 00024 US Return-Path: <X3J13-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 11 JAN 89 23:28:43 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 11 Jan 89  23:16:17 PSTReceived: from Cabernet.ms by ArpaGateway.ms ; 11 JAN 89 23:14:58 PSTDate: 11 Jan 89 23:14 PSTSender: masinter.paSubject: Issue: THE-AMBIGUITY (Version 2)To: X3J13@Sail.Stanford.EduReply-to: cl-cleanup@sail.stanford.eduFrom: cl-cleanup@sail.stanford.educc: masinter.paline-fold: NoMessage-ID: <890111-231458-11647@Xerox>This issue has two proposals.!Forum:        cleanupIssue:        THE-AMBIGUITYReferences:   THE (page 161)Category:     CLARIFICATIONEdit history: 21-Oct-88, version 1 by Rees              11-Jan-89, version 2 by Masinter (fix typos)Problem description:  CLtL does not explicitly say whether the type specifier in a THE  form may be any type specifier or must be a type specifier suitable  for discrimination.  Although THE is decsribed as a "declaration"  form, some CL implementations have assumed that the specifier must  be for discrimination, and disallow e.g.,    (THE (FUNCTION (T T) CONS) #'CONS)  We should either say that the implementations are right, or  explicitly say that they are wrong, since this case is easily  overlooked.Proposal (THE-AMBIGUITY:FOR-DECLARATION):  Clarify that the type specifier in	(THE type exp)  may be any valid type specifier.  In the case that exp returns one  value and type is not a VALUES type specifier, (THE type exp) is  equivalent to	(LET ((g exp))	  (DECLARE (TYPE type g))	  g)  where "g" is a gensym.  Proposal (THE-AMBIGUITY:FOR-DISCRIMINATION):  Clarify that the type specifier in	(THE type exp)  must be a valid type for discrimination, as for TYPEP, or it must  be of the form (VALUES type*) where type* are all valid for discrimination.Current practice:  The Symbolics Genera and VAX LISP V2.2 interpreters signal errors for	(THE (FUNCTION (T T) CONS) #'CONS),  but this may not be intentional.  CLtL would seem to allow it.Test case:  (THE (FUNCTION (T T) CONS) #'CONS),  should return the CONS function under FOR-DECLARATION,  and should be an error under FOR-DISCRIMINATION.Cost to implementors:  Trivial cost for THE-AMBIGUITY:FOR-DISCRIMINATION; this is a compatible  restriction.  For THE-AMBIGUITY:FOR-DECLARATION, implementations that do not  already allow arbitrary type specifiers but which want to check that  the type in a THE is satisfied would have to create an internal  version of TYPEP which could manage not to signal invalid-type-specifier  errors in those situations where TYPEP would because the type is a  declaration-only one.Cost to users:  Users of implementations that support THE-AMBIGUITY:FOR-DECLARATION  might have to remove or change some uses of THE in their code if the  opposing alternative is adopted.Benefits:  Either way, an ambiguity in the language specification would be clarified.Aesthetics:  THE-AMBIGUITY:FOR-DECLARATION would seem to be more consistent with  DECLARE and with the intent of THE, which is supposed to be a way to  provide information for documentation and for the benefit of compilation.Discussion:  Rees supports THE-AMBIGUITY:FOR-DECLARATION.  Appropriate error situation terminology must be chosen for the  situation that a THE declaration (or other declaration) is  unsatisfied, but that must be done regardless of this proposal.  This proposal would suggest that a function should be added to CL to  do the checking that THE would want to do:	  (PROBABLY-TYPEP object type-spec)  [terrible name of course] returns multiple values a la SUBTYPEP: T T  if the object definitely has the type, NIL T if it definitely  doesn't, and T NIL (or NIL NIL?) otherwise.  Assuming that an  interpreted THE-expression actually checks types, you could almost  define this function using the condition system and EVAL.  (Ugh!)  Without PROBABLY-TYPEP, a meta-circular interpreter is more  difficult to write.  If a suitable name was found for this function, the additional  functionality could be suggested as an independent proposal, since  regardless of the outcome of this issue, the functionality is still  useful for checking DECLARE's.  Various implementation mechanisms were discussed for dealing  with THE checking.  Are there any remaining type specifiers beyond the list form  of the FUNCTION type that differ between "declaration" and  "discrimination"?  "I support FOR-DECLARATION.  Lucid CL has the same bug in  the interpreter as the others (a "bug" assuming FOR-DECLARATION).  TYPEP is used to check the legality of the type specifier in THE."  In considering possible ways in which the type-checking logic  for THE and DECLARE might work, don't forget things like	(the (not (function (t t) integer)) 7),  which you would want to signal an error.  I don't think this can be  done with only TYPEP and conditions.*start*02776 00024 US Return-Path: <CL-Editorial-mailer@SAIL.Stanford.EDU>Received: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 JAN 89 19:02:51 PSTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 13 Jan 89  19:03:43 PSTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA03136g; Fri, 13 Jan 89 18:59:30 PSTReceived: by bhopal id AA08485g; Fri, 13 Jan 89 19:01:46 PSTDate: Fri, 13 Jan 89 19:01:46 PSTFrom: Jon L White <jonl@lucid.com>Message-Id: <8901140301.AA08485@bhopal>To: cl-cleanup@sail.stanford.edu, cl-editorial@sail.stanford.eduIn-Reply-To: cl-cleanup@sail.stanford.edu's message of 11 Jan 89 23:14 PST <890111-231458-11647@Xerox>Subject: Code as Spec: {Issue: THE-AMBIGUITY (Version 2)}re: Proposal (THE-AMBIGUITY:FOR-DECLARATION):      Clarify that the type specifier in	    (THE type exp)      may be any valid type specifier.  In the case that exp returns one      value and type is not a VALUES type specifier, (THE type exp) is      equivalent to	    (LET ((g exp))	      (DECLARE (TYPE type g))	      g)      where "g" is a gensym.I'm not very happy with this style of specification: instead ofspelling out what "for declaration" means, a piece of code isoffered which is allegedly "equivalent".  But "equivalent" underwhat terms?  Does this mean that for those types for which <type>has specialized storage (and for which the compiler takes advantageof declarations to use that specialization) then         (THE type exp)imples that "exp" must also be in specialized storeage?I remember a similar misleading definition -- the one that was workedout "on the fly" at the Boston meeting for:    (COERCE '(LAMBDA (...) ...) 'FUNCTION)It said that such a form should be like:    (EVAL '(FUNCTION (LAMBDA (...) ...)))[or, words like that].  Presumably this was a cheap way of trying to say"closure in the null lexical environment".  I objected to this as being acircular definition, since both forms will be implemented by somenon-portable code in each implementation, and it is precisely thebehaviour of that non-portable action that need specification.  Anyway,I mention this now because some vendors have, upon ocasion, delivered asubseted Common Lisp without an interpreter in it; the above-mentionedstyle of definition would imply that COERCE should not work in such asubset.  But in fact, COERCE can quite easily work; it is APPLY thatprobably cannot work.Code as illustrative example, of course, is fine.  And while thecolloquialisms of code segments can be a shorthand for fullerdefinitions, we need to be awfully careful that we don't use it insituations where the reader will really understand it only if he already knows what it is trying to say.-- JonL --*start*01062 00024 US Date:  4 Apr 89 13:04 PDTSender: CL-Cleanup-mailer%SAIL.Stanford:EDU:XeroxFrom: KMP%STONY-BROOK.SCRC.Symbolics:COM:XeroxSubject: Issue: THE-AMBIGUITYTo: CL-Cleanup%SAIL.Stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: THE-AMBIGUITYTo: CL-Cleanup@SAIL.Stanford.EDUReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 04 APR 89 12:52:19 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 4 Apr 89  12:46:09 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 571288; Tue 4-Apr-89 15:46:07 EDTOriginal-Date: Tue, 4 Apr 89 15:45 EDTMessage-ID: <890404154542.8.KMP@BOBOLINK.SCRC.Symbolics.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVThis was on the agenda but didn't come up.Being a clarification, I assume it might come up next meeting.*start*03221 00024 US Date: 19 Apr 89 14:37 PDTSender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxFrom: goldman%vaxa.isi:EDU:XeroxSubject: intent of (THE <type> <expression>)To: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 APR 89 14:21:54 PDTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 19 Apr 89  13:44:06 PDTPosted-Date: Wed, 19 Apr 89 12:44:00 PSTMessage-Id: <8904192044.AA21853@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.61/5.61)	id AA21853; Wed, 19 Apr 89 13:44:07 -0700Original-Date: Wed, 19 Apr 89 12:44:00 PST1) Is program P1 a correct common lisp program, or is it "an error":P1:  (let ((x 0))	(declare (integer x))	(setf x (truncate 7 3)))If P1 is correct, how about P2P2:   (let ((x 0))	(declare (integer x))	(setf x (the integer (truncate 7 3))))Why this is a question:  TRUNCATE returns 2 values.  Is (THE INTEGER <EXP>)equivalent to (THE (VALUES INTEGER &rest T) <EXP>)) -- in which case P2 iscorrect, and (THE INTEGER (TRUNCATE 7 3)) returns 2 values, 2 and 1?Or is (THE INTEGER <EXP>) equivalent to      (THE (VALUES INTEGER &REST T) (VALUES <EXP>))in which case P2 is correct and (THE INTEGER (TRUNCATE 7 3)) returns a singlevalue, 2?Observations:  If P1 is correct, and P2 is "an error", then the    "transformation" of wrapping (the <type-specifier> <expression>) around   expressions being assignmened to a variable for which a type has been   declared is NOT a correct transformation in Common Lisp.   Of course if BOTH P1 and P2 are incorrect, it may still be a legitimate   transformation.Empirical observation that raised this question:Symbolics' implementation signals an error for P2 (interpreted, though NOTcompiled).  It does not signal an error for P1 in any case.  This is consistent with considering P2 to be "is an error" and considering P1 tobe either correct OR "is an error".  I don't know what their position is.I am not able to determine a stance on this question from the text onpp 161-162 of CLtL84.Personal preference:  I would like (the  <type-spec> <exp>), where<type-spec> was not a VALUES type specifier, to mean  (the <type-spec> (VALUES <exp>))(the (values integer) (values 1 2)) would be an error.(the  integer (values 0 3)) would be correct and return only one value, 0.(the (values integer integer) (values 1 2)) would be correct and return 2 values, 1 and 2.Remotely related question -- can DEFTYPE be used to define VALUES styleor FUNCTION style type specifiers, or only the kind that TYPEP is willingto accept?  On my symbolics implementation, I can do  (deftype two-integers () (values integer integer))without any error.  The interpreter accepts  (the (values integer integer) (values 1 2))returning two values, 1 and 2.but the interpreter signals an error for  (the (two-integers) (values 1 2))which is consistent with considering it to be an error for a use of atype "macro" defined with DEFTYPE to produce a VALUES style type specifier.(although the error message scarcely makes that appear to be the offense.)Neil*start*02327 00024 US Date: 19 Apr 89 14:58 PDTSender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxFrom: mincy%Think:COM:XeroxSubject: intent of (THE <type> <expression>)In-Reply-to: <8904192044.AA21853@vaxa.isi.edu>To: goldman%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Jeff Mincy <mincy@Think.COM>Subject: intent of (THE <type> <expression>)To: goldman@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: <8904192044.AA21853@vaxa.isi.edu>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 APR 89 14:57:29 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 19 Apr 89  14:32:23 PDTReturn-Path: <mincy@Think.COM>Received: from sauron.think.com by Think.COM; Wed, 19 Apr 89 17:32:24 EDTReceived: from ZENO.THINK.COM by sauron.think.com; Wed, 19 Apr 89 17:31:33 EDTOriginal-Date: Wed, 19 Apr 89 17:31 EDTMessage-Id: <19890419213156.5.MINCY@ZENO.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Wed, 19 Apr 89 12:44:00 PST    From: goldman@vaxa.isi.edu    If P1 is correct, how about P2    P2:   (let ((x 0))	    (declare (integer x))	    (setf x (the integer (truncate 7 3))))    Personal preference:  I would like (the  <type-spec> <exp>), where    <type-spec> was not a VALUES type specifier, to mean      (the <type-spec> (VALUES <exp>))    (the  integer (values 0 3)) would be correct and return only one value, 0.    Neil(Correct) type declarations are not supposed to affectthe semantics of a correct program.  Your type declarationjust changed the the semantics.  (setq x (the integer (truncate 7 3))) should not signal an error.After all, only one value is being used, and I want to declarethat one value.  When giving a non values type declaration suchas INTEGER, it should be taken to declare the first value.  Anyother values returned are not declared.  If I want to declarethat something returns exactly one value, and it is an integer,then I can use the type (values integer).  The types INTEGER and (VALUES INTEGER) should either beequivalent or not,  and this should be specified betterin CLtL.  I think is it more useful if they are not equivalent.-jeff*start*03397 00024 US Date: 19 Apr 89 15:51 PDTSender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxFrom: barmar%Think:COM:XeroxSubject: intent of (THE <type> <expression>)In-Reply-to: <19890419213156.5.MINCY@ZENO.THINK.COM>To: mincy%Think:COM:Xeroxcc: goldman%vaxa.isi:EDU:Xerox, common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Barry Margolin <barmar@Think.COM>Subject: intent of (THE <type> <expression>)To: Jeff Mincy <mincy@Think.COM>Cc: goldman@vaxa.isi.edu, common-lisp@sail.stanford.eduIn-Reply-To: <19890419213156.5.MINCY@ZENO.THINK.COM>Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 19 APR 89 15:50:57 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 19 Apr 89  15:21:49 PDTReturn-Path: <barmar@Think.COM>Received: from OCCAM.THINK.COM by Think.COM; Wed, 19 Apr 89 18:17:14 EDTOriginal-Date: Wed, 19 Apr 89 18:16 EDTMessage-Id: <19890419221642.8.BARMAR@OCCAM.THINK.COM>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV    Date: Wed, 19 Apr 89 17:31 EDT    From: Jeff Mincy <mincy@Think.COM>	Date: Wed, 19 Apr 89 12:44:00 PST	From: goldman@vaxa.isi.edu	If P1 is correct, how about P2	P2:   (let ((x 0))		(declare (integer x))		(setf x (the integer (truncate 7 3))))	Personal preference:  I would like (the  <type-spec> <exp>), where	<type-spec> was not a VALUES type specifier, to mean	  (the <type-spec> (VALUES <exp>))	(the  integer (values 0 3)) would be correct and return only one value, 0.	Neil    (Correct) type declarations are not supposed to affect    the semantics of a correct program.  Your type declaration    just changed the the semantics.  The operative word is "correct".  If the expression returns two valuesand the type declaration is interpreted as specifying that it returnsexactly one value, then the type declaration isn't correct.  If this isthe correct interpretation of non-VALUES type specifiers in THE forms,then the above is just as incorrect as (the float 0).I'm not sure what the right interpretation of this is.  As far as I cantell, it hasn't come up in X3J13 (there's only one Cleanup issue relatedto THE, and it's about a different problem).  In the description of theTHE special form, the only wording I can find that indicates either wayis the comments in the examples on p.162.  When describing theinterpretation of (the integer (+ x 3)) the comments say "the result of+ will be an integer."  The use of the singular in these commentsimplies that the declaration specifies that + will only return onevalue.However, the description of THE as used with SETF, p.96, implies theother way.  It says that	(setf (the <type> <place>) <value>)is processed as if it were	(setf <place> (the <type> <value>))Therefore, (setf (the integer x) (truncate 7 3)) would be treated as(setf x (the integer (truncate 7 3))).  Intuitively, the originalversion seems correct, so the transformed version should be valid.  Itis certainly counterintuitive to require one to write	(setf (the (values integer integer) x)	      (truncate 7 3))This latter problem could be fixed either by fixing the definition ofthe THE special form, or by fixing the definition of the THE SETF-place.                                                barmar*start*02602 00024 US Date: 20 Apr 89 14:53 PDTSender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxFrom: goldman%vaxa.isi:EDU:XeroxSubject: re: intent of (THE <type> <expression>)To: common-lisp%sail.stanford:EDU:Xeroxcc: barmar%think:COM:Xerox, mincy%think:COM:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 APR 89 11:02:36 PDTReceived: from vaxa.isi.edu by SAIL.Stanford.EDU with TCP; 20 Apr 89  10:35:54 PDTPosted-Date: Thu, 20 Apr 89 09:35:50 PSTMessage-Id: <8904201735.AA13354@vaxa.isi.edu>Received: from LOCALHOST by vaxa.isi.edu (5.61/5.61)	id AA13354; Thu, 20 Apr 89 10:35:53 -0700Original-Date: Thu, 20 Apr 89 09:35:50 PSTJeff is absolutely correct in rejecting the resolution I stated asmy preference.  It would have said that:a) (truncate 7 3) is a correct program, and it returns two valuesb) (the integer (truncate 7 3)) is a correct program, and it returns one valueBut all that has happened (syntactically) is the addition of a type declaration to a correct program.I still think the meaning of (the <type-specifier> <expression>) needs clarification.What do you think of this alternative:1) if the <type-specifier> is not of the form (VALUES ...),then let (VALUES <type-specifier> &rest T) be the effective type specifier.Otherwise, <type-specifier> itself is the effective type specifier.2) The value(s) returned by expression must be compatible with theeffective type specifer, where compatibility is as described on page 48in the definition of VALUES style type specifiers.  [But that paragraphshould be expanded to include &allow-other-keys.  It should also makeexplicit that   i) the  value-type list is a lambda list in which type-specifiers     appear where parameter names would appear in a normal lambda list ii) none the the component type specifiers may be a VALUES type specifieriii) the type specifiers all appear as top-level components of the value-type     list for positional values (required or &optional),     and as (<symbol> type-specifier) for keyword type-specifiers     (I presume that was the intent?)  The <symbol>     is NOT coerced to the keyword package.  For example, (the (values integer &optional number	     &key (a symbol) (:b cons) &allow-other-keys)     (values 7  8 :b '(x 1) 'a  3 'b 2))would be correct.(the integer (truncate 7 3) would be correct, because it is treated as(the (values integer &rest t) (integer 7 3)(the (values integer) (truncate 7 3)) would be an error.Neil*start*01672 00024 US GV-Info: CL-Cleanup-mailer@SAIL.Stanford.EDU at 20-Apr-89 18:02:06 from AGReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 APR 89 14:56:00 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM by SAIL.Stanford.EDU with TCP; 20 Apr 89  14:54:19 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 582196; Thu 20-Apr-89 17:54:13 EDTDate: Thu, 20 Apr 89 17:53 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: THE-VALUES [was: intent of (THE <type> <expression>)]To: gls@Think.COMcc: KMP@STONY-BROOK.SCRC.Symbolics.COM, CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <8904202059.AA00383@joplin.think.com>Message-ID: <890420175328.4.KMP@BOBOLINK.SCRC.Symbolics.COM>[Outside world removed.]    Date: Thu, 20 Apr 89 16:59:15 EDT    From: Guy Steele <gls@Think.COM>       ...       PROPOSAL:       What it boils down to, is that THE should check only as many types       as requested (and pass back only as many).    No, this is not cool.  THE is supposed to act purely as a declaration,    but you are changing it to require it to pass on only as many values    as the type specifer indicates.  This could change the semantics of    a suitably devious program.    Better to say that it checks as many types as requsted, but passes on    exactly the values it receives.    --GuyEven though I agree with your position, I think it's worth our writing upa clarification issue to make sure we're all agreed and that it's 100% clearin the ANSI spec.*start*03440 00024 US Date: 20 Apr 89 16:51 PDTSender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxFrom: quiroz%cs.rochester:EDU:XeroxSubject: Re: intent of (THE <type> <expression>)In-Reply-to: Your message of Thu, 20 Apr 89 09:35:50 -0800.             <8904201735.AA13354@vaxa.isi.edu>To: common-lisp%sail.stanford:EDU:XeroxReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 APR 89 13:27:57 PDTReceived: from cayuga.cs.rochester.edu by SAIL.Stanford.EDU with TCP; 20 Apr 89  13:02:40 PDTReceived: from lesath.cs.rochester.edu by cayuga.cs.rochester.edu (5.59/l) id AA18246; Thu, 20 Apr 89 16:02:25 EDTReceived: from loopback by lesath.cs.rochester.edu (3.2/l) id AA02490; Thu, 20 Apr 89 16:02:14 EDTMessage-Id: <8904202002.AA02490@lesath.cs.rochester.edu>Original-Date: Thu, 20 Apr 89 16:02:10 -0400    Summary:  Don't disturb Unaware Callers.  Don't let THE pass    back values that it didn't check.  [For details, search down for    the string PROPOSAL.]After the latest note by Neil Goldman, I think I see with lesssympathy the proposed transformations to clarify THE.  I suggestthat a guiding concern be this:  Unaware Callers don't sufferunintended weirdness when they call a Multiple Value function.By Unaware Callers I mean those that don not intentionally use anyof the forms that do something with multiple values.So, I would have it this way:    (setf x (truncate 7 3)) ; the second value is discarded, right?    (setf x (the integer (truncate 7 3))) ; the second value is also discarded    (setf (the integer x) (truncate 7 3))would all do the same thing: discard the second value, even for typechecking.  I didn't request the second value, I don't want to haveto declare its type.  (Also, instead of truncate, think of a userdefined function that over time gets extended to return multiplevalues, I don't want this benign extension to break anything thatworked before).PROPOSAL:What it boils down to, is that THE should check only as many typesas requested (and pass back only as many).  This entails rewordingthe entry for THE in p. 138 of CLtL:* If the type specifier specifier of the THE form is not of the form(VALUES ...), only one value is checked and passed back.  Else, onlyas many returned values as specified in the (VALUES ...) specifierare checked and passed back. (Missing values are assumed to be nil,they are checked and passed back.)  A type specifier of the form (VALUES ...  &rest T) is used to indicate that extra values may bepresent, and are not type checked, but are passed back.Possible draw-back:    (multiple-value-bind (foo bar) (the integer (truncate 7 3))       (declare (type integer foo bar))       (list foo bar))would be in error (bar would be nil).  The program without the THEdeclaration looks correct to me, but the declaration screws it up.That's is philosophically OK with me (Aware Callers have all theresponsibility to do the right thing; only Unaware Callers areprotected from peculiarities of the Multiple Value system), butstill some may feel it to be a touch rude.  The fix, of course,would be:    (multiple-value-bind (foo bar) (the (values integer integer)                                        (truncate 7 3))       ...)So adding a corect declaration is still possible.Sorry this got too long.Cesar*start*01884 00024 US Date: 20 Apr 89 17:44 PDTSender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxFrom: gls%Think:COM:XeroxSubject: intent of (THE <type> <expression>)In-Reply-to: quiroz@cs.rochester.edu's message of Thu, 20 Apr 89 16:02:10 -0400 <8904202002.AA02490@lesath.cs.rocTo: quiroz%cs.rochester:EDU:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVFrom: Guy Steele <gls@Think.COM>To: quiroz@cs.rochester.eduCc: common-lisp@sail.stanford.eduIn-Reply-To: quiroz@cs.rochester.edu's message of Thu, 20 Apr 89 16:02:10 -0400 <8904202002.AA02490@lesath.cs.rochester.edu>Subject: intent of (THE <type> <expression>)Return-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 APR 89 14:27:07 PDTReceived: from Think.COM by SAIL.Stanford.EDU with TCP; 20 Apr 89  14:04:41 PDTReceived: from fafnir.think.com by Think.COM; Thu, 20 Apr 89 17:04:38 EDTReturn-Path: <gls@Think.COM>Received: from verdi.think.com by fafnir.think.com; Thu, 20 Apr 89 17:03:41 EDTReceived: from joplin.think.com by verdi.think.com; Thu, 20 Apr 89 16:59:42 EDTReceived: by joplin.think.com; Thu, 20 Apr 89 16:59:15 EDTOriginal-Date: Thu, 20 Apr 89 16:59:15 EDTMessage-Id: <8904202059.AA00383@joplin.think.com>GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV   ...   PROPOSAL:   What it boils down to, is that THE should check only as many types   as requested (and pass back only as many).No, this is not cool.  THE is supposed to act purely as a declaration,but you are changing it to require it to pass on only as many valuesas the type specifer indicates.  This could change the semantics ofa suitably devious program.Better to say that it checks as many types as requsted, but passes onexactly the values it receives.--Guy*start*01601 00024 US Date: 20 Apr 89 18:00 PDTSender: Common-Lisp-mailer%SAIL.Stanford:EDU:XeroxFrom: quiroz%cs.rochester:EDU:XeroxSubject: Re: intent of (THE <type> <expression>)In-Reply-to: Your message of Thu, 20 Apr 89 16:59:15 -0400.             <8904202059.AA00383@joplin.think.com>To: gls%Think:COM:Xeroxcc: common-lisp%sail.stanford:EDU:XeroxGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVTo: Guy Steele <gls@Think.COM>Cc: common-lisp@sail.stanford.eduSubject: Re: intent of (THE <type> <expression>)In-Reply-To: Your message of Thu, 20 Apr 89 16:59:15 -0400.             <8904202059.AA00383@joplin.think.com>From: quiroz@cs.rochester.eduReturn-Path: <Common-Lisp-mailer@SAIL.Stanford.EDU>Redistributed: Xerox-Common-Lisp^.xReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 20 APR 89 14:54:19 PDTReceived: from cayuga.cs.rochester.edu by SAIL.Stanford.EDU with TCP; 20 Apr 89  14:34:43 PDTReceived: from lesath.cs.rochester.edu by cayuga.cs.rochester.edu (5.59/l) id AA18692; Thu, 20 Apr 89 17:34:34 EDTReceived: from loopback by lesath.cs.rochester.edu (3.2/l) id AA02604; Thu, 20 Apr 89 17:34:28 EDTMessage-Id: <8904202134.AA02604@lesath.cs.rochester.edu>Original-Date: Thu, 20 Apr 89 17:34:24 -0400GVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGVGV| Better to say that it checks as many types as requsted, but passes on| exactly the values it receives.That sounds better, indeed.  So, do both of Neil's programs remaincorrect then?  (Meaning here:  "(setf x (the integer (truncate 7 3)))"is as correct as "(setf x (truncate 7 3))")Cesar