*start*04124 00024 USaReturn-Path: <mcconnel@ads.com>Received: from ads.com ([128.229.30.16]) by Xerox.COM ; 30 JUN 88 09:16:45 PDTReceived: by ads.com (5.59/1.14)	id AA22384; Thu, 30 Jun 88 09:19:40 PDTDate: Thu, 30 Jun 88 09:19:40 PDTFrom: Chris McConnell <mcconnel@ads.com>Message-Id: <8806301619.AA22384@ads.com>To: masinter.paCc: mcconnel@ads.comIn-Reply-To: masinter.pa@Xerox.COM's message of 29 Jun 88 23:58:18 PDT <880629-235850-4021@Xerox>Subject: cleanup proposal formatThere is an ambiguity in how CL handles the printing of circularreferences when a print-function is defined for a structure.  I wantto write out possibly circular structures in such a way that they canbe read back in.  As long as I want to print all of the slots in thestructures, I can do this by setting *print-circle* to T.  But, I havedefstructs that point to objects that can't be printed like closures.What I think I should be able to do is define a :print-function for mystructure that prints out #S syntax without all of the slots.(defstruct (woof (:print-function print-woof))   a b)(defun print-woof (woof stream depth)  (format stream "#S(WOOF A ~A)" (woof-a woof)))(progn  (setf *a (make-woof)	*b (make-woof)	(woof-a *a) *b	(woof-b *a) (let* ((a 3))		      #'(lambda (x) (+ x a)))	(woof-a *b) *a	*print-circle* t)  (print *a))Some implementations handle this, but most don't.  My reading of thespec says that the printer will handle circular references when*print-circle* is T.  It doesn't say anything about not handling itwhen you have print functions on structures.  One way to get thisbehavior is to have write check for circular structures something likethis:;;;(defvar *REAL-PRINT-CIRCLE* nil  "Global to control printing of circular objects.")(defvar *PRINT-HASH-TABLE* (make-hash-table)  "Hash table from objects being printed to their reader number.")(defvar *PRINT-COUNTER* 0  "Current counter number.");;;(unless (fboundp 'old-write)  (setf (symbol-function 'old-write) (symbol-function 'write)));;;(defun WRITE (object              &rest args              &key               (circle *print-circle*)              (stream *standard-output*)              &allow-other-keys)  "Fixed write function."  (if (or (symbolp object) (numberp object) (stringp object))    ;; Never have circular references    (apply #'old-write object args)    (if *real-print-circle*      ;; We've already entered write the circle T      (let* ((number (gethash object *print-hash-table*)))        (if number          (format stream "#~A#" number)          (progn            (setf (gethash object *print-hash-table*)                  (incf *print-counter*))            (format stream "#~A=" *print-counter*)            (apply #'old-write object args))))      (progn        (if circle          ;; First time with circle T          (let* ((*real-print-circle* t))            (setf (getf args :circle) nil)            (apply #'write object args)            (setq *print-counter* 0)            (clrhash *print-hash-table*))          ;; Circle is nil          (apply #'old-write object args)))))  object)This approach does generate a #n for every list, array, etc.  If youare willing to make two passes, you can generate only those #n's thatare really needed. If I set *print-circle* to T, I am perfectlywilling to have a #n= for every list, array and structure.  No it isnot pretty, but an important purpose of the #n syntax is to make it sothat objects can be written and then read back in using the reader.Since CLTL explicitly specifies that some things (like closures) doneed to be written in a way that can be read, I do not think that itis unreasonable to have the printer support print-functions thatsuppress those values.  I would write this stuff myself, except thatthere is no portable way to find the names of slots in defstructs.(Even if there were, monsterous defstructs like those used in CLOSwhere every slot is an array with all sorts of garbage in them wouldstill be a problem.)Has this been addressed by the cleanup committee?*start*07898 00024 US Date:  2 Sep 88 15:47 PDTFrom: Masinter.paSubject: Re: cleanup proposal formatIn-reply-to: your message of Thu, 30 Jun 88 09:19:40 PDTTo: Chris McConnell <mcconnel@ads.com>cc: masinter.paI just discovered that I had misfilled your message of June 30 and don't think I responded (did I?) I'll allocate the name PRINT-CIRCLE-STRUCTURE to this issue if you think it is appropriate.Received: from ads.com ([128.229.30.16]) by Xerox.COM ; 30 JUN 88 09:16:45 PDTReceived: by ads.com (5.59/1.14)	id AA22384; Thu, 30 Jun 88 09:19:40 PDTDate: Thu, 30 Jun 88 09:19:40 PDTFrom: Chris McConnell <mcconnel@ads.com>Message-Id: <8806301619.AA22384@ads.com>To: masinter.paCc: mcconnel@ads.comIn-Reply-To: masinter.pa@Xerox.COM's message of 29 Jun 88 23:58:18 PDT <880629-235850-4021@Xerox>Subject: cleanup proposal formatThere is an ambiguity in how CL handles the printing of circularreferences when a print-function is defined for a structure.  I wantto write out possibly circular structures in such a way that they canbe read back in.  As long as I want to print all of the slots in thestructures, I can do this by setting *print-circle* to T.  But, I havedefstructs that point to objects that can't be printed like closures.What I think I should be able to do is define a :print-function for mystructure that prints out #S syntax without all of the slots.(defstruct (woof (:print-function print-woof))   a b)(defun print-woof (woof stream depth)  (format stream "#S(WOOF A ~A)" (woof-a woof)))(progn  (setf *a (make-woof)	*b (make-woof)	(woof-a *a) *b	(woof-b *a) (let* ((a 3))		      #'(lambda (x) (+ x a)))	(woof-a *b) *a	*print-circle* t)  (print *a))Some implementations handle this, but most don't.  My reading of thespec says that the printer will handle circular references when*print-circle* is T.  It doesn't say anything about not handling itwhen you have print functions on structures.  One way to get thisbehavior is to have write check for circular structures something likethis:;;;(defvar *REAL-PRINT-CIRCLE* nil  "Global to control printing of circular objects.")(defvar *PRINT-HASH-TABLE* (make-hash-table)  "Hash table from objects being printed to their reader number.")(defvar *PRINT-COUNTER* 0  "Current counter number.");;;(unless (fboundp 'old-write)  (setf (symbol-function 'old-write) (symbol-function 'write)));;;(defun WRITE (object              &rest args              &key               (circle *print-circle*)              (stream *standard-output*)              &allow-other-keys)  "Fixed write function."  (if (or (symbolp object) (numberp object) (stringp object))    ;; Never have circular references    (apply #'old-write object args)    (if *real-print-circle*      ;; We've already entered write the circle T      (let* ((number (gethash object *print-hash-table*)))        (if number          (format stream "#~A#" number)          (progn            (setf (gethash object *print-hash-table*)                  (incf *print-counter*))            (format stream "#~A=" *print-counter*)            (apply #'old-write object args))))      (progn        (if circle          ;; First time with circle T          (let* ((*real-print-circle* t))            (setf (getf args :circle) nil)            (apply #'write object args)            (setq *print-counter* 0)            (clrhash *print-hash-table*))          ;; Circle is nil          (apply #'old-write object args)))))  object)This approach does generate a #n for every list, array, etc.  If youare willing to make two passes, you can generate only those #n's thatare really needed. If I set *print-circle* to T, I am perfectlywilling to have a #n= for every list, array and structure.  No it isnot pretty, but an important purpose of the #n syntax is to make it sothat objects can be written and then read back in using the reader.Since CLTL explicitly specifies that some things (like closures) doneed to be written in a way that can be read, I do not think that itis unreasonable to have the printer support print-functions thatsuppress those values.  I would write this stuff myself, except thatthere is no portable way to find the names of slots in defstructs.(Even if there were, monsterous defstructs like those used in CLOSwhere every slot is an array with all sorts of garbage in them wouldstill be a problem.)Has this been addressed by the cleanup committee?!  Format for proposals to the cleanup committee (Version 13)                    November 20, 1987Replace the text below in >> double inverted angle-brackets <<. Bebrief; leave testimonials and personal opinions to the discussion at theend. Be complete; do not expect someone else to fix or redesign parts.Spell out names (e.g., Masinter rather than LMM) and upper-case all Lispsymbols (DEFUN rather than Defun). I like it better if you write in thethird person rather than first.Issue:         >>A short descriptive label, which starts with a name               which occurs in the index of CLtL, and be a suitable               symbol in the Common Lisp style, e.g., CDR-TERMINATION.<<References:    >>The pages of CLtL which describe the feature being               discussed, and other references, including other               related issues.<<Category:      >>One or more of:               CLARIFICATION -- proposal to resolve an ambiguity or case               of under-specified situation in CLtL, where this               ambiguity interferes with portability of code.               CHANGE -- proposal for an incompatible change.               ADDITION -- proposal for a compatible extension<<Edit history:  >>Author and date of submission (version 1), and author               and date of subsequent versions.<<Problem description:>>Describe the problem being addressed -- why is the current situationunclear or unsatisfactory? Avoid describing the proposal here or arguingfor its adoption. <<Proposal (>>issue-label:proposal-label<<): >> Describe as precisely aspossible what you are proposing.  Ideally, this should take the form oftext that could be dropped into the new specification document.Proposals should be for changes to Common Lisp, rather than changes toCLtL.  If necessary, propose a set of labelled alternatives here, ratherthan a single proposal. Each proposal must be a complete design; do notleave out details.  Avoid arguing for the proposal here, just describeit.<<Test Cases/Examples:>> Examples are samples of Common Lisp code that illustrates the issue.along with explanatory text.Test Cases are simple stand-alone expressions which are valid anddo not signal an error if the proposal is adhered to. (Use ASSERTif you need.)<<Rationale:>> A one or two sentence summary of the arguments that follow. <<Current practice:>>Do some/many/no Common Lisp implementations already work this way?Survey independent Common Lisp implementations - preferably three ormore.<<Cost to Implementors:>>What is the cost to implementors of adopting the proposal?  How muchimplementation effort is required?  Is public-domain code available? Forpervasive changes, can the conversion be automated?<<Cost to Users:>>For incompatible changes, what is the cost to users of convertingexisting user code?  To what extent can the process be automated? How?<<Cost of non-adoption:>>How serious is it if nothing is done? <<Benefits:>>What is better if the proposal is adopted? How serious is the problemif just left as it is? <<Esthetics:>>How does this proposal affect the simplicity of the language, ease oflearning, etc. You can spell it aesthetics if you like. <<Discussion:>> Additional arguments, discussions, endorsements, testimonials, etc.should go here. A blow-by-blow account of debates is not necessary. <<*start*00340 00024 US Date: 19 Sep 88 16:57 PDTFrom: masinter.paSubject: Issue: PRINT-CIRCLE-STRUCTUREIn-reply-to: your message of Thu, 30 Jun 88 09:19:40 PDTTo: Chris McConnell <mcconnel@ads.com>cc: masinter.paHi -- we're getting close to the deadline for proposals for the October X3J13 meeting. Do you have a proposal writup?*start*06400 00024 USfReturn-Path: <Christopher.McConnell@a.gp.cs.cmu.edu>Received: from A.GP.CS.CMU.EDU ([128.2.242.7]) by Xerox.COM ; 23 SEP 88 10:34:29 PDTDate: Fri, 23 Sep 88 12:12:08From: Christopher.McConnell@A.GP.CS.CMU.EDUTo: masinter.paIn-reply-to: masinter.pa@Xerox.COM's message of 22 Sep 88 21:02 PDT <880922-210211-3786@Xerox>Subject: Issue: PRINT-CIRCLE-STRUCTUREHere is what I have.  I will send you any modifications as soon as Ican.ThanksIssue:         	PRINT-CIRCLE-STRUCTUREReferences:    	pp. 370-371Category:      	CLARIFICATIONEdit history:	Version 1.0, Chris McConnell 9/20/88Problem description:When a print function for a structure is defined using the:print-function option to defstruct, circular references are no longerprinted with #n# syntax even though *print-circle* is T.  Thisprevents printing structures that point to objects that cannot beprinted and prevents the development of new printed representationsthat can be read by the reader.Proposal PRINT-CIRCLE-STRUCTURE: When *print-circle* is T, the printer should detect and printcircularities using the #n# syntax even if a structure has a userdefined print-function.  Circularities need only be detected forobjects that would normally be printed by the default structureprint-function.  A user defined print-function can print any objectthat is pointed to by the structure being printed, or any object thatwould normally be printed as a component of such an object and expectcircularities to be detected.Test Cases/Examples:;;;;;; Define a structure that can be circular and that has a slot with a;;; value that cannot be printed.;;;(defstruct (TEST (:print-function print-test))  ptr  (function #'(lambda (x) 		(error "No function is defined."))));;;;;; This print function generates a machine readable printed;;; representation for a structure with a slot that cannot be printed.;;;(defun PRINT-TEST (structure stream depth)  (format stream "#S(TEST PTR ~A)" (test-ptr structure)));;;;;; Define two structures that point to each other.  If this;;; expression successfully evaluates at the top level, then the;;; printed result should look like:;;; #1=#S(TEST PTR #S(TEST PTR #1#));;;;;; If it does not work then it will generate an infinite printed;;; representation. (setf *print-circle* t      *a (make-test)      *b (make-test)      (test-ptr *a) *b      (test-ptr *b) *a)Rationale:Many structures are circular and point to complex data structures thatmay include things like closures that cannot be printed.  It should bepossible to define a way to print these data structures such that theycan be read back in.  Common LISP provides two mechanisms for theseproblems (*print-circle* and the :print-function option to defstruct),but they do not currently work together.Current practice:None of the Common LISPs that I have worked with currently implementthis proposal.  That includes Symbolics 7.2, Lucid 3.0, KCL, Coral andFranz.Cost to Implementors:I believe that it is a rather straightforward change.  All of theimplementations detect circularities for the default structureprinter.  All that is required is to perform the same circularitycheck and printing #n= before or #n# instead of what would normally begenerated by the user defined print-function.Cost to Users: NoneCost of non-adoption: If nothing is done, the whole effort to provide a portable printedrepresentation of LISP structures is of minimal usefulness.  In almostany real application, there are circular structures with non printableobjects such as closures and hash tables that need to be printed.  Inaddition the development of printers for new reader macros becomesmuch more of an effort then it should be since it requiresreimplementing the complete circularity detection mechanism.Benefits:If the proposal is adopted, then it becomes easier to define newprinted representations that are compact and that still capture theinformation needed to rebuild data structure instances.  It allows aprinted representation to hide the actual details of how a datastructure is implemented in terms of underlying LISP data structures.For an example see the discussion section.Esthetics: This proposal increases the uniformity of the language by making*print-circle* work in all cases including where a user has defined anew print function.Discussion:I first came across this problem in trying to generate a printedrepresentation for CLOS instances.  The current PCL implementation ofCLOS implements an instance as a structure with four slots.  One ofthe slots points to an array that stores information about the classthat the structure is an instance of.  That array points to a numberof other data structures that cache various information and that pointto other data structures some of which point to closures.  If you tryto print an instance using the #S syntax, most printers will blow upbecause eventually, you try to print a closure.  In addition, there isall sorts of extraneous detail that does not really belong in aprinted representation of an instance.  A #I reader syntax can easilybe defined that represents a CLOS instance as a class name and a listof slot names and values much like the #S syntax.  When this is doneby defining a structure print-function, the circularity detector nolonger detects circularities.  The only way to get around this is towrite your own circularity detector that works for all LISP objects.This can be done, but it seems like a lot of effort when the exactmechanism that is needed is already built into Common LISP.Part of the reason for wanting to be able to do things like this is tobe able to generate files that have a compiled representation of datastructures in them.  To do this, you put something like:(setq *a '#.*a)in a file and then you compile it in an environment where *a is boundto the data structure you would like to save in the file.  The resultis a compiled file that contains the data structure that you want.  Inorder for this to work, some compilers use the printer mechanism togenerate a printed form of the data structure and then compile that.This use of the printed representation of objects could be alleviatedif there existed some mechanism equivalent to thesys:dump-forms-to-file function provided by Symbolics.*start*03203 00024 US Return-Path: <KMP@STONY-BROOK.SCRC.Symbolics.COM>Received: from STONY-BROOK.SCRC.Symbolics.COM ([128.81.41.144]) by Xerox.COM ; 05 OCT 88 21:41:56 PDTReceived: from BOBOLINK.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 471525; Thu 6-Oct-88 00:41:55 EDTDate: Thu, 6 Oct 88 00:41 EDTFrom: Kent M Pitman <KMP@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRINT-CIRCLE-STRUCTURE (Version 1)To: Christopher.McConnell@A.GP.CS.CMU.EDU, Masinter.PAcc: CL-Cleanup@SAIL.Stanford.EDUIn-Reply-To: <881005-204718-2157@Xerox>Message-ID: <881006004144.6.KMP@BOBOLINK.SCRC.Symbolics.COM>Given that no one currently supports the suggested action, thismay technically be a clarification, but I think it would be betterto say CLARIFICATION/CHANGE to be clear up front about the factthat careful reading is in order.I would prefer if ~S was used instead of ~A in the examples.This is not a clarification. It's     Date: 5 Oct 88 20:47 PDT    From: masinter.pa@Xerox.COM    ...    Issue:         	PRINT-CIRCLE-STRUCTURE    ...    Proposal PRINT-CIRCLE-STRUCTURE:     When *print-circle* is T, the printer should detect and print    circularities using the #n# syntax even if a structure has a user    defined print-function.  Circularities need only be detected for    objects that would normally be printed by the default structure    print-function.Sentences one and two are vague enough that I can't tell why they don'tcontradict each other.    A user defined print-function can print any object that is pointed    to by the structure being printed, or any object that would normally    be printed as a component of such an object and expect circularities    to be detected.This isn't adequately specific for my taste.  I can sort of guess wherethese restrictions are coming from, but from the point of view of theexplicitly written text here, they seem unmotivated.    ...    Cost to Implementors:    I believe that it is a rather straightforward change.  All of the    implementations detect circularities for the default structure    printer.  All that is required is to perform the same circularity    check and printing #n= before or #n# instead of what would normally be    generated by the user defined print-function.I don't think this is specific enough.    ...    Discussion:    ...    This use of the printed representation of objects could be alleviated    if there existed some mechanism equivalent to the    sys:dump-forms-to-file function provided by Symbolics.This is in a throwaway position in the document. If it's really truethat this is an alternative in general (which I'm not sure I believe),then I don't think this proposal has given me an adequate survey ofthe issues and options.Overall I'm sympathetic to the issue but not (yet) to the proposal.There's something kind of vague and hand-wavey about the writeup thatdoesn't make me feel like I know exactly what I'm signing up for or why.It's entirely possible that a tighter rewrite of the same idea would fixthings, though. At this point, I don't have any sense of a fundamentalobjection looming in the wings.*start*06571 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 05 OCT 88 20:50:26 PDTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 5 Oct 88  20:50:14 PDTReceived: from Semillon.ms by ArpaGateway.ms ; 05 OCT 88 20:47:18 PDTDate: 5 Oct 88 20:47 PDTFrom: masinter.paSubject: Issue: PRINT-CIRCLE-STRUCTURE (Version 1)To: cl-cleanup@sail.stanford.educc: Christopher.McConnell@A.GP.CS.CMU.EDUMessage-ID: <881005-204718-2157@Xerox>I discovered that I had neglected to forward this issue, forwhich I apologize. !Issue:         	PRINT-CIRCLE-STRUCTUREReferences:    	pp. 370-371Category:      	CLARIFICATIONEdit history:	Version 1.0, Chris McConnell 9/20/88Problem description:When a print function for a structure is defined using the:print-function option to defstruct, circular references are no longerprinted with #n# syntax even though *print-circle* is T.  Thisprevents printing structures that point to objects that cannot beprinted and prevents the development of new printed representationsthat can be read by the reader.Proposal PRINT-CIRCLE-STRUCTURE: When *print-circle* is T, the printer should detect and printcircularities using the #n# syntax even if a structure has a userdefined print-function.  Circularities need only be detected forobjects that would normally be printed by the default structureprint-function.  A user defined print-function can print any objectthat is pointed to by the structure being printed, or any object thatwould normally be printed as a component of such an object and expectcircularities to be detected.Test Cases/Examples:;;;;;; Define a structure that can be circular and that has a slot with a;;; value that cannot be printed.;;;(defstruct (TEST (:print-function print-test))  ptr  (function #'(lambda (x) 		(error "No function is defined."))));;;;;; This print function generates a machine readable printed;;; representation for a structure with a slot that cannot be printed.;;;(defun PRINT-TEST (structure stream depth)  (format stream "#S(TEST PTR ~A)" (test-ptr structure)));;;;;; Define two structures that point to each other.  If this;;; expression successfully evaluates at the top level, then the;;; printed result should look like:;;; #1=#S(TEST PTR #S(TEST PTR #1#));;;;;; If it does not work then it will generate an infinite printed;;; representation. (setf *print-circle* t      *a (make-test)      *b (make-test)      (test-ptr *a) *b      (test-ptr *b) *a)Rationale:Many structures are circular and point to complex data structures thatmay include things like closures that cannot be printed.  It should bepossible to define a way to print these data structures such that theycan be read back in.  Common LISP provides two mechanisms for theseproblems (*print-circle* and the :print-function option to defstruct),but they do not currently work together.Current practice:None of the Common LISPs that I have worked with currently implementthis proposal.  That includes Symbolics 7.2, Lucid 3.0, KCL, Coral andFranz.Cost to Implementors:I believe that it is a rather straightforward change.  All of theimplementations detect circularities for the default structureprinter.  All that is required is to perform the same circularitycheck and printing #n= before or #n# instead of what would normally begenerated by the user defined print-function.Cost to Users: NoneCost of non-adoption: If nothing is done, the whole effort to provide a portable printedrepresentation of LISP structures is of minimal usefulness.  In almostany real application, there are circular structures with non printableobjects such as closures and hash tables that need to be printed.  Inaddition the development of printers for new reader macros becomesmuch more of an effort then it should be since it requiresreimplementing the complete circularity detection mechanism.Benefits:If the proposal is adopted, then it becomes easier to define newprinted representations that are compact and that still capture theinformation needed to rebuild data structure instances.  It allows aprinted representation to hide the actual details of how a datastructure is implemented in terms of underlying LISP data structures.For an example see the discussion section.Esthetics: This proposal increases the uniformity of the language by making*print-circle* work in all cases including where a user has defined anew print function.Discussion:I first came across this problem in trying to generate a printedrepresentation for CLOS instances.  The current PCL implementation ofCLOS implements an instance as a structure with four slots.  One ofthe slots points to an array that stores information about the classthat the structure is an instance of.  That array points to a numberof other data structures that cache various information and that pointto other data structures some of which point to closures.  If you tryto print an instance using the #S syntax, most printers will blow upbecause eventually, you try to print a closure.  In addition, there isall sorts of extraneous detail that does not really belong in aprinted representation of an instance.  A #I reader syntax can easilybe defined that represents a CLOS instance as a class name and a listof slot names and values much like the #S syntax.  When this is doneby defining a structure print-function, the circularity detector nolonger detects circularities.  The only way to get around this is towrite your own circularity detector that works for all LISP objects.This can be done, but it seems like a lot of effort when the exactmechanism that is needed is already built into Common LISP.Part of the reason for wanting to be able to do things like this is tobe able to generate files that have a compiled representation of datastructures in them.  To do this, you put something like:(setq *a '#.*a)in a file and then you compile it in an environment where *a is boundto the data structure you would like to save in the file.  The resultis a compiled file that contains the data structure that you want.  Inorder for this to work, some compilers use the printer mechanism togenerate a printed form of the data structure and then compile that.This use of the printed representation of objects could be alleviatedif there existed some mechanism equivalent to thesys:dump-forms-to-file function provided by Symbolics.*start*00857 00024 US Return-Path: <jonl@lucid.com>Received: from lucid.com ([192.26.25.1]) by Xerox.COM ; 06 OCT 88 20:01:05 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00937g; Thu, 6 Oct 88 20:00:50 PDTReceived: by bhopal id AA07175g; Thu, 6 Oct 88 19:59:09 PDTDate: Thu, 6 Oct 88 19:59:09 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810070259.AA07175@bhopal>To: masinter.paCc: cl-cleanup@sail.stanford.edu, Christopher.McConnell@A.GP.CS.CMU.EDUIn-Reply-To: masinter.pa@Xerox.COM's message of 5 Oct 88 20:47 PDT <881005-204718-2157@Xerox>Subject: Issue: PRINT-CIRCLE-STRUCTURE (Version 1)Correction:  Lucid Common Lisp 3.0 implements the proposed suggestion.I belive Chris simply tried it out on a very early "beta" release of LCL3.0; but the product version indeed has this lacuna fixed.-- JonL --*start*01453 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 06 OCT 88 21:25:42 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 6 Oct 88  21:24:29 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472359; Fri 7-Oct-88 00:23:04 EDTDate: Fri, 7 Oct 88 00:22 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRINT-CIRCLE-STRUCTURE (Version 1)To: cl-cleanup@sail.stanford.educc: Christopher.McConnell@A.GP.CS.CMU.EDUIn-Reply-To: <881005-204718-2157@Xerox>Message-ID: <19881007042246.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: 5 Oct 88 20:47 PDT    From: masinter.pa@Xerox.COM    Circularities need only be detected for    objects that would normally be printed by the default structure    print-function.I cannot accept any proposal with this kludgey restriction in it.  Ifcircularities are going to be detected at all, they should be doneright.  It's not difficult to call the user-defined print-function oncewith a special stream argument that detects what the function prints(i.e. what calls to WRITE and equivalent functions and FORMAT directivesit makes using that stream), and use that for circularity detection.That's how the Symbolics Genera implementation works.*start*01423 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 06:50:48 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 7 Oct 88  06:50:50 PDTReceived: from SEF1.SLISP.CS.CMU.EDU by SEF1.SLISP.CS.CMU.EDU;  7 Oct 88 09:47:09 EDTTo: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.edu, Christopher.McConnell@A.GP.CS.CMU.EDUSubject: Re: Issue: PRINT-CIRCLE-STRUCTURE (Version 1) In-reply-to: Your message of Thu, 06 Oct 88 19:59:09 -0700.             <8810070259.AA07175@bhopal> Date: Fri, 07 Oct 88 09:46:18 EDTFrom: Scott.Fahlman@B.GP.CS.CMU.EDUJonl,Since Lucid has this running, can you comment (or get someone there tocomment) on the accuracy of Chris's guess that it shouldn't be too hard toimplement this?  In your implementation, does the outer print communicatewith the inner one by some set of special variables that are visible acrossthe invocation of the user's structure-printing function?  Do you know ofany "gotchas" that have to be addressed in the proposal -- odd interactionsbetween circle printing and things the user might do in his unrestrictedprint function, for example?  I'd feel a lot better about this proposal ifwe had some real experience to base it on (and maybe even some exampleimplementation code to copy).-- Scott*start*04564 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 13:04:56 PDTReceived: from A.GP.CS.CMU.EDU by SAIL.Stanford.EDU with TCP; 7 Oct 88  13:04:37 PDTDate: Fri, 7 Oct 88 15:50:41From: Christopher.McConnell@A.GP.CS.CMU.EDUTo: cl-cleanup@sail.stanford.eduSubject: PRINT-CIRCLE-STRUCTUREI have updated the proposal based on feedback from Dave Touretzky,Scott Fahlman, Jon White, David Moon and Kent Pitman.Issue:         	PRINT-CIRCLE-STRUCTUREReferences:    	pp. 370-371Category:      	CLARIFICATIONEdit history:	Version 1.1, Chris McConnell 10/05/88	        Version 1.0, Chris McConnell 09/20/88Problem description:When a lisp object is printed that points to a structure with a userdefined print-function and there is a pointer back to the containingobject, the printer will recurse infinitely even when *print-circle*is set to T.  This prevents printing circular structures that point toobjects that cannot be printed and prevents the development of newprinted representations that can be read by the reader.Proposal PRINT-CIRCLE-STRUCTURE: When *print-circle* is T, a user defined print-function can printobjects to the supplied stream using WRITE, PRIN1, PRINC, or FORMATand expect circularities to be detected and printed using #n# syntax.If a user defined print-function prints to a stream other than the onethat was supplied, then circularity detection starts over for thatstream. Test Cases/Examples:;;;;;; Define a structure that can be circular and that has a slot with a;;; value that cannot be printed.;;;(defstruct (TEST (:print-function print-test))  ptr  (function #'(lambda (x) 		(error "No function is defined."))));;;;;; This print function generates a machine readable printed;;; representation for a structure with a slot that cannot be printed.;;;(defun PRINT-TEST (structure stream depth)  (format stream "#S(TEST PTR ~S)" (test-ptr structure)));;;;;; Define two structures that point to each other.  If this;;; expression successfully evaluates at the top level, then the;;; printed result should look like:;;; #1=#S(TEST PTR #S(TEST PTR #1#));;;;;; If it does not work then it will generate an infinite printed;;; representation. (setf *print-circle* t      *a (make-test)      *b (make-test)      (test-ptr *a) *b      (test-ptr *b) *a)Rationale:Many structures are circular and point to complex data structures thatmay include things like closures that cannot be printed.  It should bepossible to define a way to print these data structures such that theycan be read back in.  Common LISP provides two mechanisms for theseproblems (*print-circle* and the :print-function option to defstruct),but they do not currently work together in most implementations.Current practice:Lucid 3.0 and the Genera do work on the test case.  (Previous versionsdid not.)  KCL, Coral and Franz do not work.Cost to Implementors:Lucid and Symbolics have done it, so they could give an idea of thedifficulty.  Possible techniques include passing the printer stateinformation by dynamic binding rather than by explicit parameters orby supplying an internal stream to the user print function.Cost to Users: NoneCost of non-adoption: Currently this problem causes an infinite recursion whenever a userprint-function prints a lisp object that contains the structure thatis being printed by the user print function.  If nothing is done, thiserror will remain and the whole effort to provide a portable printedrepresentation of LISP structures is of minimal usefulness.  In almostany real application, there are circular structures with non printableobjects such as closures and hash tables that need to be printed.  Inaddition the development of printers for new reader macros becomesmuch more of an effort then it should be since it requiresreimplementing the complete circularity detection mechanism.Benefits:If the proposal is adopted, then it becomes easier to define newprinted representations that are compact and that still capture theinformation needed to rebuild data structure instances.  It allows aprinted representation to hide the actual details of how a datastructure is implemented in terms of underlying LISP data structures.Esthetics: This proposal increases the uniformity of the language by making*print-circle* work in all cases including where a user has defined anew print function.Discussion:*start*01647 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 17:33:20 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  17:31:34 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA00912g; Fri, 7 Oct 88 17:29:56 PDTReceived: by bhopal id AA02294g; Fri, 7 Oct 88 17:28:16 PDTDate: Fri, 7 Oct 88 17:28:16 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080028.AA02294@bhopal>To: Scott.Fahlman@B.GP.CS.CMU.EDUCc: cl-cleanup@sail.stanford.edu, Christopher.McConnell@A.GP.CS.CMU.EDUIn-Reply-To: Scott.Fahlman@B.GP.CS.CMU.EDU's message of Fri, 07 Oct 88 09:46:18 EDT <8810071349.AA01222@lucid.com>Subject: Issue: PRINT-CIRCLE-STRUCTURE (Version 1) re: . . . can you comment (or get someone there to    comment) on the accuracy of Chris's guess that it shouldn't be too hard to    implement this?  In your implementation, does the outer print communicateLucid's circle printer was implemented by someone who left Lucid abouta year ago.  About a half-year ago, I diddled with the code, due to acomplaint from a PCL user (it wasn't Chris) who had circular instances.I spent far more time at it that I wanted to, bolstered by the thoughts:  (1) that with just a little more probing, I'd be able to understand the       opaque algorithms being employed; and  (2) I considered the former behaviour a clear "bug" that was actually      impeding a user's work.There is no guarantee that all such bugs are fixed now.Sorry I couldn't be of more help.-- JonL --*start*02331 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 20:19:06 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  20:19:11 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472990; Fri 7-Oct-88 22:00:21 EDTDate: Fri, 7 Oct 88 22:00 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRINT-CIRCLE-STRUCTURE (Version 1)To: Jon L White <jonl@lucid.com>cc: cl-cleanup@sail.stanford.edu, Christopher.McConnell@A.GP.CS.CMU.EDUIn-Reply-To: <8810080135.AA02628@bhopal>Message-ID: <19881008020002.2.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Fri, 7 Oct 88 18:35:06 PDT    From: Jon L White <jonl@lucid.com>    re:     Date: 5 Oct 88 20:47 PDT	    From: masinter.pa@Xerox.COM	    Circularities need only be detected for	    objects that would normally be printed by the default structure	    print-function.	I cannot accept any proposal with this kludgey restriction in it.  If	circularities are going to be detected at all, they should be done	right.  It's not difficult to call the user-defined print-function once	with a special stream argument that detects what the function prints	(i.e. what calls to WRITE and equivalent functions and FORMAT directives	it makes using that stream), and use that for circularity detection.	That's how the Symbolics Genera implementation works.    A "first cut" implementation is merely to descend all components of objects    when looking for circularities.  At worst this will cause spurious #n='s     to appear in the output (which CLtL doesn't seem to proscribe), and may     impose some extra traffic on the "looker" (probably a hash-table).What's a "component"?Suppose I'm using defstruct instead of CLOS, and I want to add a slotcompatibly.  Since I'm not using CLOS, I have to store that slot in atable on-the-side.  How does the component finder find it?  The answer isthat it can't, which is why I maintain that the only viable approach isto based circularity detection on what the user-defined print functionactually prints, not on any guesses as to what it might print.*start*01824 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 20:41:07 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  20:41:17 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01063g; Fri, 7 Oct 88 18:36:46 PDTReceived: by bhopal id AA02628g; Fri, 7 Oct 88 18:35:06 PDTDate: Fri, 7 Oct 88 18:35:06 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080135.AA02628@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.edu, Christopher.McConnell@A.GP.CS.CMU.EDUIn-Reply-To: David A. Moon's message of Fri, 7 Oct 88 00:22 EDT <19881007042246.8.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: PRINT-CIRCLE-STRUCTURE (Version 1)re:     Date: 5 Oct 88 20:47 PDT	From: masinter.pa@Xerox.COM	Circularities need only be detected for	objects that would normally be printed by the default structure	print-function.    I cannot accept any proposal with this kludgey restriction in it.  If    circularities are going to be detected at all, they should be done    right.  It's not difficult to call the user-defined print-function once    with a special stream argument that detects what the function prints    (i.e. what calls to WRITE and equivalent functions and FORMAT directives    it makes using that stream), and use that for circularity detection.    That's how the Symbolics Genera implementation works.A "first cut" implementation is merely to descend all components of objectswhen looking for circularities.  At worst this will cause spurious #n='s to appear in the output (which CLtL doesn't seem to proscribe), and may impose some extra traffic on the "looker" (probably a hash-table).-- JonL --*start*01143 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 20:13:45 PDTReceived: from lucid.com by SAIL.Stanford.EDU with TCP; 7 Oct 88  20:13:38 PDTReceived: from bhopal ([192.9.200.13]) by heavens-gate.lucid.com id AA01161g; Fri, 7 Oct 88 20:12:26 PDTReceived: by bhopal id AA02929g; Fri, 7 Oct 88 20:10:43 PDTDate: Fri, 7 Oct 88 20:10:43 PDTFrom: Jon L White <jonl@lucid.com>Message-Id: <8810080310.AA02929@bhopal>To: Moon@STONY-BROOK.SCRC.Symbolics.COMCc: cl-cleanup@sail.stanford.edu, Christopher.McConnell@A.GP.CS.CMU.EDUIn-Reply-To: David A. Moon's message of Fri, 7 Oct 88 22:00 EDT <19881008020002.2.MOON@EUPHRATES.SCRC.Symbolics.COM>Subject: Issue: PRINT-CIRCLE-STRUCTURE (Version 1)re: What's a "component"?It's "half a loaf" of a "first cut". Yea, I know that a :print-function can grab information which is not at all apparent from the defined components of an object.  But it's "rare".The "first cut" simply doesn't stop where the _default_ structure printerwould stop.-- JonL --*start*00878 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 07 OCT 88 20:18:38 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 7 Oct 88  20:18:38 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 472980; Fri 7-Oct-88 21:46:41 EDTDate: Fri, 7 Oct 88 21:46 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRINT-CIRCLE-STRUCTURE (version 1.1)To: Christopher.McConnell@A.GP.CS.CMU.EDUcc: cl-cleanup@sail.stanford.eduIn-Reply-To: The message of 7 Oct 88 15:50 EDT from Christopher.McConnell@A.GP.CS.CMU.EDUMessage-ID: <19881008014611.8.MOON@EUPHRATES.SCRC.Symbolics.COM>PRINT-CIRCLE-STRUCTURE: looks good to me.*start*04770 00024 US Date:  8 Oct 88 21:01 PDTSender: masinter.paSubject: PRINT-CIRCLE-STRUCTURE (Version 3)From: cl-cleanup@sail.stanford.eduTo: x3j13@sail.stanford.eduREPLY-TO: cl-cleanup@sail.stanford.eduline-fold: NOcc: MasinterIssue:         	PRINT-CIRCLE-STRUCTUREReferences:    	pp. 370-371Category:      	CLARIFICATIONEdit history:	Version 3, Masinter 10/8/88 (minor cleanup)                  Version 2, Chris McConnell 10/05/88                  Version 1, Chris McConnell 09/20/88Problem description:When a lisp object is printed that points to a structure with a userdefined print-function and there is a pointer back to the containingobject, the printer will recurse infinitely even when *print-circle*is set to T.  This prevents printing circular structures that point toobjects that cannot be printed and prevents the development of newprinted representations that can be read by the reader.Proposal PRINT-CIRCLE-STRUCTURE:USER-FUNCTIONS-WORK: When *print-circle* is T, a user defined print-function can printobjects to the supplied stream using WRITE, PRIN1, PRINC, or FORMATand expect circularities to be detected and printed using #n# syntax.If a user defined print-function prints to a stream other than the onethat was supplied, then circularity detection starts over for thatstream. Test Cases/Examples:;;;;;; Define a structure that can be circular and that has a slot with a;;; value that cannot be printed.;;;(defstruct (TEST (:print-function print-test))  ptr  (function #'(lambda (x) 		(error "No function is defined."))));;;;;; This print function generates a machine readable printed;;; representation for a structure with a slot that cannot be printed.;;;(defun PRINT-TEST (structure stream depth)  (format stream "#S(TEST PTR ~S)" (test-ptr structure)));;;;;; Define two structures that point to each other.  If this;;; expression successfully evaluates at the top level, then the;;; printed result should look like:;;; #1=#S(TEST PTR #S(TEST PTR #1#));;;;;; If it does not work then it will generate an infinite printed;;; representation. (setf *print-circle* t      *a (make-test)      *b (make-test)      (test-ptr *a) *b      (test-ptr *b) *a)Rationale:Many structures are circular and point to complex data structures thatmay include things like closures that cannot be printed.  It should bepossible to define a way to print these data structures such that theycan be read back in.  Common LISP provides two mechanisms for theseproblems (*print-circle* and the :print-function option to defstruct),but they do not currently work together in most implementations.Current practice:Lucid 3.0 and the Genera do work on the test case.  (Previous versionsdid not.)  KCL, Coral and Franz do not work.Cost to Implementors:Lucid and Symbolics have done it, so they could give an idea of thedifficulty.  Possible techniques include passing the printer stateinformation by dynamic binding rather than by explicit parameters orby supplying an internal stream to the user print function.Cost to Users: NoneCost of non-adoption: Currently this problem causes an infinite recursion whenever a userprint-function prints a lisp object that contains the structure thatis being printed by the user print function.  If nothing is done, thiserror will remain and the whole effort to provide a portable printedrepresentation of LISP structures is of minimal usefulness.  In almostany real application, there are circular structures with non printableobjects such as closures and hash tables that need to be printed.  Inaddition the development of printers for new reader macros becomesmuch more of an effort then it should be since it requiresreimplementing the complete circularity detection mechanism.Benefits:If the proposal is adopted, then it becomes easier to define newprinted representations that are compact and that still capture theinformation needed to rebuild data structure instances.  It allows aprinted representation to hide the actual details of how a datastructure is implemented in terms of underlying LISP data structures.Esthetics: This proposal increases the uniformity of the language by making*print-circle* work in all cases including where a user has defined anew print function.Discussion:At least three members of the cleanup committee read this and thinkit looks good.        TITAN 
         TITAN 
           ﬁ                                                        ö             ì       6      a             u             £              v             
                           ¶       
      R              ù              T      = z∫*start*00947 00024 USaReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 13 OCT 88 13:45:10 PDTReceived: from decwrl.dec.com by SAIL.Stanford.EDU with TCP; 13 Oct 88  13:45:27 PDTReceived: by decwrl.dec.com (5.54.5/4.7.34)	id AA19823; Thu, 13 Oct 88 13:43:44 PDTDate: Thu, 13 Oct 88 13:43:44 PDTMessage-Id: <8810132043.AA19823@decwrl.dec.com>From: vanroggen%aitg.DEC@decwrl.dec.comTo: cl-cleanup@sail.stanford.eduSubject: Issue: PRINT-CIRCLE-STRUCTUREBTW, VAX LISP behaves as desired.This reminds me of another issue which may deserve a cleanup issue:*PRINT-CIRCLE* ought to say that the printer detects shared structureas well as circularity.  The description of #n# and #n= does mentionreferring to shared structures as well as circular ones, so it wouldmake sense that the printer should behave in this manner.			---Walter*start*01387 00024 US Return-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 14 OCT 88 10:59:25 PDTReceived: from STONY-BROOK.SCRC.Symbolics.COM (SCRC-STONY-BROOK.ARPA) by SAIL.Stanford.EDU with TCP; 14 Oct 88  10:55:56 PDTReceived: from EUPHRATES.SCRC.Symbolics.COM by STONY-BROOK.SCRC.Symbolics.COM via CHAOS with CHAOS-MAIL id 476544; Fri 14-Oct-88 13:55:35 EDTDate: Fri, 14 Oct 88 13:55 EDTFrom: David A. Moon <Moon@STONY-BROOK.SCRC.Symbolics.COM>Subject: Issue: PRINT-CIRCLE-STRUCTURETo: vanroggen%aitg.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduIn-Reply-To: <8810132043.AA19823@decwrl.dec.com>Message-ID: <19881014175516.8.MOON@EUPHRATES.SCRC.Symbolics.COM>    Date: Thu, 13 Oct 88 13:43:44 PDT    From: vanroggen%aitg.DEC@decwrl.dec.com    This reminds me of another issue which may deserve a cleanup issue:    *PRINT-CIRCLE* ought to say that the printer detects shared structure    as well as circularity.  The description of #n# and #n= does mention    referring to shared structures as well as circular ones, so it would    make sense that the printer should behave in this manner.Good point.  This may in fact be controversial, since detecting sharedstructure can be considerably more expensive to implement than onlydetecting circular structure.*start*00833 00024 USfReturn-Path: <CL-Cleanup-mailer@SAIL.Stanford.EDU>Redistributed: xerox-cl-cleanup^.paReceived: from SAIL.Stanford.EDU ([36.86.0.194]) by Xerox.COM ; 28 NOV 88 11:46:50 PSTReceived: from Xerox.COM by SAIL.Stanford.EDU with TCP; 28 Nov 88  11:41:13 PSTReceived: from Semillon.ms by ArpaGateway.ms ; 28 NOV 88 10:24:10 PSTDate: 26 Nov 88 20:34 PSTFrom: masinter.paSubject: Re: Issue: PRINT-CIRCLE-STRUCTUREIn-reply-to: vanroggen%aitg.DEC@decwrl.dec.com's message of Thu, 13 Oct 88 13:43:44 PDTTo: vanroggen%aitg.DEC@decwrl.dec.comcc: cl-cleanup@sail.stanford.eduMessage-ID: <881128-102410-1316@Xerox>Can you submit a new issue on the question of whether *print-circle*requires detecting of shared structure. I am uncertain about how I wouldvote myself, since all of the options have negatives.